<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Endeavor</title>
  
  <subtitle>狂歌痛饮 来访雁丘处</subtitle>
  <link href="http://chengsx21.github.io/atom.xml" rel="self"/>
  
  <link href="http://chengsx21.github.io/"/>
  <updated>2024-06-30T09:52:55.509Z</updated>
  <id>http://chengsx21.github.io/</id>
  
  <author>
    <name>Chengsx</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>编译原理 实验6</title>
    <link href="http://chengsx21.github.io/2024/01/02/bian-yi-yuan-li-lab-6/"/>
    <id>http://chengsx21.github.io/2024/01/02/bian-yi-yuan-li-lab-6/</id>
    <published>2024-01-02T09:18:57.000Z</published>
    <updated>2024-06-30T09:52:55.509Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Stage-6-报告"><a href="#Stage-6-报告" class="headerlink" title="Stage 6 报告"></a>Stage 6 报告</h1><blockquote><p><em>写在前面:</em><br>    这一个 Stage 的实现中对着前中后端的报错疯狂调 Bug, 基本实现过程就是 [构造测例] -&gt; [看报错] -&gt; [调代码], 好在终于是实现地较为完备, 痛并快乐着 (×).<br>    报告或许会较长, 尽管尝试简化对实现思路的叙述, 最后还是保留了如下内容, 以便用尽可能简洁的描述, 将实现过程清晰地展示出来.</p></blockquote><h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><h3 id="step-10"><a href="#step-10" class="headerlink" title="step 10"></a>step 10</h3><p><strong>词法语法分析</strong>: 修改 <code>frontend/ast/tree.py</code> 中 <code>Program</code> 节点的定义, 并添加 <code>globalVars()</code> 方法传递<strong>全局变量</strong>键值对. 在 <code>frontend/parser/ply_parser.py</code> 中参考已有实现, 给出相关 <code>CFG</code> 文法:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># frontend/ast/tree.py</span><span class="token keyword">class</span> <span class="token class-name">Program</span><span class="token punctuation">(</span>ListNode<span class="token punctuation">[</span>Union<span class="token punctuation">[</span><span class="token string">"Function"</span><span class="token punctuation">,</span> <span class="token string">"Declaration"</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">def</span> <span class="token function">globalVars</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">dict</span><span class="token punctuation">[</span><span class="token builtin">str</span><span class="token punctuation">,</span> <span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token punctuation">{</span>decl<span class="token punctuation">.</span><span class="token builtin">getattr</span><span class="token punctuation">(</span><span class="token string">'symbol'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name<span class="token punctuation">:</span> decl<span class="token punctuation">.</span><span class="token builtin">getattr</span><span class="token punctuation">(</span><span class="token string">'symbol'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>initValue <span class="token keyword">for</span> decl <span class="token keyword">in</span> self <span class="token keyword">if</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>decl<span class="token punctuation">,</span> Declaration<span class="token punctuation">)</span><span class="token punctuation">}</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>语义分析</strong>: 只需修改 <code>frontend/typecheck/namer.py</code> 的 <code>visitDeclaration</code> 部分, 如果当前作用域为全局作用域, 修改 <code>symbol.isGlobal = True</code> 即可, 并为<strong>全局变量</strong>设置<strong>初始值</strong> <code>symbol.initValue</code>.</p><p><strong>中间代码生成</strong>: 在 <code>utils/tac/tacinstr.py</code> 中参照已有实现, 添加全局变量地址加载、全局变量加载和存储的 TAC 指令:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># utils/tac/tacinstr.py</span><span class="token keyword">class</span> <span class="token class-name">LoadAddress</span><span class="token punctuation">(</span>TACInstr<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment"># LOAD SYMBOL ADDRESS...</span><span class="token keyword">class</span> <span class="token class-name">LoadIntLiteral</span><span class="token punctuation">(</span>TACInstr<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># LOAD SYMBOL...</span><span class="token keyword">class</span> <span class="token class-name">StoreIntLiteral</span><span class="token punctuation">(</span>TACInstr<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># STORE SYMBOL...</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 <code>utils/tac/tacgen.py</code> 中 <code>TACFuncEmitter</code> 类实现与之有关的 <code>Visitor</code> 模式方法, 修改 <code>TACGen</code> 类的 <code>visitAssignment</code> 及 <code>visitIdentifier</code> 方法, 判断访问标识符和赋值操作是否对<strong>全局变量</strong>进行:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># utils/tac/tacgen.py</span><span class="token keyword">class</span> <span class="token class-name">TACGen</span><span class="token punctuation">(</span>Visitor<span class="token punctuation">[</span>TACFuncEmitter<span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">visitIdentifier</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> ident<span class="token punctuation">:</span> Identifier<span class="token punctuation">,</span> mv<span class="token punctuation">:</span> TACFuncEmitter<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>        <span class="token comment">#! 标识符是全局变量</span>        <span class="token keyword">if</span> ident<span class="token punctuation">.</span><span class="token builtin">getattr</span><span class="token punctuation">(</span><span class="token string">"symbol"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>isGlobal<span class="token punctuation">:</span>            ident<span class="token punctuation">.</span><span class="token builtin">setattr</span><span class="token punctuation">(</span><span class="token string">'val'</span><span class="token punctuation">,</span> mv<span class="token punctuation">.</span>visitLoadIntLiteral<span class="token punctuation">(</span>ident<span class="token punctuation">.</span><span class="token builtin">getattr</span><span class="token punctuation">(</span><span class="token string">'symbol'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token comment">#! 否则</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            ident<span class="token punctuation">.</span><span class="token builtin">setattr</span><span class="token punctuation">(</span><span class="token string">'val'</span><span class="token punctuation">,</span> ident<span class="token punctuation">.</span><span class="token builtin">getattr</span><span class="token punctuation">(</span><span class="token string">'symbol'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>temp<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">visitAssignment</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> expr<span class="token punctuation">:</span> Assignment<span class="token punctuation">,</span> mv<span class="token punctuation">:</span> TACFuncEmitter<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>        expr<span class="token punctuation">.</span>rhs<span class="token punctuation">.</span>accept<span class="token punctuation">(</span>self<span class="token punctuation">,</span> mv<span class="token punctuation">)</span>        <span class="token comment">#! 左值是全局变量</span>        <span class="token keyword">if</span> expr<span class="token punctuation">.</span>lhs<span class="token punctuation">.</span><span class="token builtin">getattr</span><span class="token punctuation">(</span><span class="token string">'symbol'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>isGlobal<span class="token punctuation">:</span>            mv<span class="token punctuation">.</span>visitStoreIntLiteral<span class="token punctuation">(</span>expr<span class="token punctuation">.</span>lhs<span class="token punctuation">.</span><span class="token builtin">getattr</span><span class="token punctuation">(</span><span class="token string">'symbol'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> expr<span class="token punctuation">.</span>rhs<span class="token punctuation">.</span><span class="token builtin">getattr</span><span class="token punctuation">(</span><span class="token string">"val"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token comment">#! 否则</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            expr<span class="token punctuation">.</span>lhs<span class="token punctuation">.</span>accept<span class="token punctuation">(</span>self<span class="token punctuation">,</span> mv<span class="token punctuation">)</span>            expr<span class="token punctuation">.</span><span class="token builtin">setattr</span><span class="token punctuation">(</span>                <span class="token string">"val"</span><span class="token punctuation">,</span> mv<span class="token punctuation">.</span>visitAssignment<span class="token punctuation">(</span>expr<span class="token punctuation">.</span>lhs<span class="token punctuation">.</span><span class="token builtin">getattr</span><span class="token punctuation">(</span><span class="token string">"symbol"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>temp<span class="token punctuation">,</span> expr<span class="token punctuation">.</span>rhs<span class="token punctuation">.</span><span class="token builtin">getattr</span><span class="token punctuation">(</span><span class="token string">"val"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>目标代码生成</strong>: 在 <code>utils/riscv.py</code> 中参照已有实现, 添加<strong>全局变量</strong>地址获取、加载和存储的 RISC-V 指令:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># utils/riscv.py</span><span class="token keyword">class</span> <span class="token class-name">LoadAddress</span><span class="token punctuation">(</span>TACInstr<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment"># LOAD SYMBOL ADDRESS...</span><span class="token keyword">class</span> <span class="token class-name">LoadIntLiteral</span><span class="token punctuation">(</span>TACInstr<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># LOAD SYMBOL...</span><span class="token keyword">class</span> <span class="token class-name">StoreIntLiteral</span><span class="token punctuation">(</span>TACInstr<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># STORE SYMBOL...</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 <code>backend/riscv/riscvasmemitter.py</code> 中, <code>RiscvAsmEmitter</code> 对象初始化时打印全局变量至 <code>.data</code> 区, 并为 <code>RiscvInstrSelector</code> 实现相应全局变量指令访问方法:</p><h3 id="step-11"><a href="#step-11" class="headerlink" title="step 11"></a>step 11</h3><p><strong>词法语法分析</strong>: 修改 <code>frontend/ast/tree.py</code>, 通过 <code>Program</code> 的 <code>globalVars()</code> 方法返回<strong>全局变量</strong>与<strong>全局数组</strong>键值对; 修改 <code>Declaration</code> 节点定义, 添加数组维度声明 <code>init_dim</code>; 同时添加索引运算节点 <code>IndexExpr</code>:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># frontend/ast/tree.py</span><span class="token keyword">class</span> <span class="token class-name">IndexExpr</span><span class="token punctuation">(</span>Expression<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> base<span class="token punctuation">:</span> Expression<span class="token punctuation">,</span> index<span class="token punctuation">:</span> Expression<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>        <span class="token builtin">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token string">"index_expr"</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>base <span class="token operator">=</span> base        self<span class="token punctuation">.</span>index <span class="token operator">=</span> index<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 <code>frontend/parser/ply_parser.py</code> 中参考已有实现, 给出相关 <code>CFG</code> 文法.</p><p><strong>语义分析</strong>: 修改 <code>frontend/typecheck/namer.py</code>, <code>visitFunction</code> 中记录当前函数声明的<strong>局部数组</strong>; 在 <code>visitDeclaration</code> 中依据标识符类型进行初始化, 如果是数组则调用 <code>ArrayType.multidim</code>; 添加 <code>visitIndexExpr</code> 中递归实现数组索引访问.</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># frontend/typecheck/namer.py</span><span class="token keyword">def</span> <span class="token function">visitDeclaration</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> decl<span class="token punctuation">:</span> Declaration<span class="token punctuation">,</span> ctx<span class="token punctuation">:</span> ScopeStack<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token keyword">if</span> decl<span class="token punctuation">.</span>init_dim<span class="token punctuation">:</span>        decl_type <span class="token operator">=</span> ArrayType<span class="token punctuation">.</span>multidim<span class="token punctuation">(</span>decl<span class="token punctuation">.</span>var_t<span class="token punctuation">.</span><span class="token builtin">type</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">[</span>dim<span class="token punctuation">.</span>value <span class="token keyword">for</span> dim <span class="token keyword">in</span> decl<span class="token punctuation">.</span>init_dim<span class="token punctuation">]</span><span class="token punctuation">)</span>        symbol <span class="token operator">=</span> VarSymbol<span class="token punctuation">(</span>decl<span class="token punctuation">.</span>ident<span class="token punctuation">.</span>value<span class="token punctuation">,</span> decl_type<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>arrays<span class="token punctuation">.</span>append<span class="token punctuation">(</span>symbol<span class="token punctuation">)</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        decl_type <span class="token operator">=</span> decl<span class="token punctuation">.</span>var_t<span class="token punctuation">.</span><span class="token builtin">type</span>        symbol <span class="token operator">=</span> VarSymbol<span class="token punctuation">(</span>decl<span class="token punctuation">.</span>ident<span class="token punctuation">.</span>value<span class="token punctuation">,</span> decl_type<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">def</span> <span class="token function">visitIndexExpr</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> expr<span class="token punctuation">:</span> IndexExpr<span class="token punctuation">,</span> ctx<span class="token punctuation">:</span> ScopeStack<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>expr<span class="token punctuation">.</span>base<span class="token punctuation">,</span> Identifier<span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token keyword">not</span> ctx<span class="token punctuation">.</span>lookupOverStack<span class="token punctuation">(</span>expr<span class="token punctuation">.</span>base<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">raise</span> DecafUndefinedVarError<span class="token punctuation">(</span>expr<span class="token punctuation">.</span>base<span class="token punctuation">.</span>value<span class="token punctuation">)</span>    expr<span class="token punctuation">.</span>base<span class="token punctuation">.</span>accept<span class="token punctuation">(</span>self<span class="token punctuation">,</span> ctx<span class="token punctuation">)</span>    expr<span class="token punctuation">.</span>index<span class="token punctuation">.</span>accept<span class="token punctuation">(</span>self<span class="token punctuation">,</span> ctx<span class="token punctuation">)</span>    <span class="token comment">#! 根据 base 类型设置 expr 的类型</span>    <span class="token keyword">if</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>expr<span class="token punctuation">.</span>base<span class="token punctuation">,</span> Identifier<span class="token punctuation">)</span><span class="token punctuation">:</span>        expr<span class="token punctuation">.</span><span class="token builtin">setattr</span><span class="token punctuation">(</span><span class="token string">'type'</span><span class="token punctuation">,</span> expr<span class="token punctuation">.</span>base<span class="token punctuation">.</span><span class="token builtin">getattr</span><span class="token punctuation">(</span><span class="token string">'symbol'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">type</span><span class="token punctuation">.</span>indexed<span class="token punctuation">)</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        expr<span class="token punctuation">.</span><span class="token builtin">setattr</span><span class="token punctuation">(</span><span class="token string">'type'</span><span class="token punctuation">,</span> expr<span class="token punctuation">.</span>base<span class="token punctuation">.</span><span class="token builtin">getattr</span><span class="token punctuation">(</span><span class="token string">'type'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>indexed<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过对节点的 <code>setattr('type')</code> 与 <code>getattr('type')</code> 操作实现类型运算一致性检查, 一共有 <code>INT</code> 与 <code>ArrayType</code> 两种类型, 如果相应运算类型不一致, 则会抛出异常 <code>DecafBadReturnTypeError</code>.</p><p><strong>中间代码生成</strong>: 在 <code>utils/tac/tacgen.py</code> 中 <code>TACFuncEmitter</code> 类实现了依地址的读写数组元素的方法:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># frontend/tacgen/tacgen.py</span><span class="token keyword">class</span> <span class="token class-name">TACFuncEmitter</span><span class="token punctuation">(</span>TACVisitor<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">visitLoadByAddress</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> addr<span class="token punctuation">:</span> Temp<span class="token punctuation">)</span><span class="token punctuation">:</span>        dst <span class="token operator">=</span> self<span class="token punctuation">.</span>freshTemp<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>func<span class="token punctuation">.</span>add<span class="token punctuation">(</span>LoadIntLiteral<span class="token punctuation">(</span>dst<span class="token punctuation">,</span> addr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> dst    <span class="token keyword">def</span> <span class="token function">visitStoreByAddress</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> value<span class="token punctuation">:</span> Temp<span class="token punctuation">,</span> addr<span class="token punctuation">:</span> Temp<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>func<span class="token punctuation">.</span>add<span class="token punctuation">(</span>StoreIntLiteral<span class="token punctuation">(</span>value<span class="token punctuation">,</span> addr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>修改 <code>TACGen</code> 类的 <code>visitIndexExpr</code>, <code>visitAssignment</code> 及 <code>visitIdentifier</code> 方法, 设置数组索引表达式的地址, 并判断访问标识符和赋值操作是否对数组进行:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># utils/tac/tacgen.py</span><span class="token keyword">class</span> <span class="token class-name">TACGen</span><span class="token punctuation">(</span>Visitor<span class="token punctuation">[</span>TACFuncEmitter<span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">visitIdentifier</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> ident<span class="token punctuation">:</span> Identifier<span class="token punctuation">,</span> mv<span class="token punctuation">:</span> TACFuncEmitter<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>    <span class="token comment"># 数组类型 -&gt; 设置数组地址</span>        <span class="token keyword">if</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>ident<span class="token punctuation">.</span><span class="token builtin">getattr</span><span class="token punctuation">(</span><span class="token string">'symbol'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">type</span><span class="token punctuation">,</span> ArrayType<span class="token punctuation">)</span><span class="token punctuation">:</span>            ident<span class="token punctuation">.</span><span class="token builtin">setattr</span><span class="token punctuation">(</span><span class="token string">'addr'</span><span class="token punctuation">,</span> mv<span class="token punctuation">.</span>visitLoadAddress<span class="token punctuation">(</span>ident<span class="token punctuation">.</span><span class="token builtin">getattr</span><span class="token punctuation">(</span><span class="token string">'symbol'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">def</span> <span class="token function">visitIndexExpr</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> expr<span class="token punctuation">:</span> IndexExpr<span class="token punctuation">,</span> mv<span class="token punctuation">:</span> TACFuncEmitter<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>        expr<span class="token punctuation">.</span>base<span class="token punctuation">.</span><span class="token builtin">setattr</span><span class="token punctuation">(</span><span class="token string">'slice'</span><span class="token punctuation">,</span> <span class="token boolean">True</span><span class="token punctuation">)</span>        expr<span class="token punctuation">.</span>base<span class="token punctuation">.</span>accept<span class="token punctuation">(</span>self<span class="token punctuation">,</span> mv<span class="token punctuation">)</span>        expr<span class="token punctuation">.</span>index<span class="token punctuation">.</span>accept<span class="token punctuation">(</span>self<span class="token punctuation">,</span> mv<span class="token punctuation">)</span>        <span class="token comment">#! 递归计算当前索引的偏移量</span>        addr <span class="token operator">=</span> mv<span class="token punctuation">.</span>visitLoad<span class="token punctuation">(</span>expr<span class="token punctuation">.</span><span class="token builtin">getattr</span><span class="token punctuation">(</span><span class="token string">'type'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>size<span class="token punctuation">)</span>        mv<span class="token punctuation">.</span>visitBinarySelf<span class="token punctuation">(</span>tacop<span class="token punctuation">.</span>TacBinaryOp<span class="token punctuation">.</span>MUL<span class="token punctuation">,</span> addr<span class="token punctuation">,</span> expr<span class="token punctuation">.</span>index<span class="token punctuation">.</span><span class="token builtin">getattr</span><span class="token punctuation">(</span><span class="token string">'val'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        mv<span class="token punctuation">.</span>visitBinarySelf<span class="token punctuation">(</span>tacop<span class="token punctuation">.</span>TacBinaryOp<span class="token punctuation">.</span>ADD<span class="token punctuation">,</span> addr<span class="token punctuation">,</span> expr<span class="token punctuation">.</span>base<span class="token punctuation">.</span><span class="token builtin">getattr</span><span class="token punctuation">(</span><span class="token string">'addr'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        expr<span class="token punctuation">.</span><span class="token builtin">setattr</span><span class="token punctuation">(</span><span class="token string">'addr'</span><span class="token punctuation">,</span> addr<span class="token punctuation">)</span>        <span class="token comment">#! 递归完毕, 通过地址获得数组元素值</span>        <span class="token comment">#! `slice` 属性表示为数组切片, 无需获取数据</span>        <span class="token comment">#! 保证递归结束只有完整的索引表达式设置了返回值</span>        <span class="token keyword">if</span> <span class="token keyword">not</span> expr<span class="token punctuation">.</span><span class="token builtin">getattr</span><span class="token punctuation">(</span><span class="token string">'slice'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            expr<span class="token punctuation">.</span><span class="token builtin">setattr</span><span class="token punctuation">(</span><span class="token string">'val'</span><span class="token punctuation">,</span> mv<span class="token punctuation">.</span>visitLoadByAddress<span class="token punctuation">(</span>addr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">visitAssignment</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> expr<span class="token punctuation">:</span> Assignment<span class="token punctuation">,</span> mv<span class="token punctuation">:</span> TACFuncEmitter<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>        <span class="token comment"># 索引类型 -&gt; 访问数组地址</span>        <span class="token keyword">if</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>expr<span class="token punctuation">.</span>lhs<span class="token punctuation">,</span> IndexExpr<span class="token punctuation">)</span><span class="token punctuation">:</span>            expr<span class="token punctuation">.</span>lhs<span class="token punctuation">.</span><span class="token builtin">setattr</span><span class="token punctuation">(</span><span class="token string">'slice'</span><span class="token punctuation">,</span> <span class="token boolean">True</span><span class="token punctuation">)</span>            expr<span class="token punctuation">.</span>lhs<span class="token punctuation">.</span>accept<span class="token punctuation">(</span>self<span class="token punctuation">,</span> mv<span class="token punctuation">)</span>            mv<span class="token punctuation">.</span>visitStoreByAddress<span class="token punctuation">(</span>expr<span class="token punctuation">.</span>rhs<span class="token punctuation">.</span><span class="token builtin">getattr</span><span class="token punctuation">(</span><span class="token string">'val'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> expr<span class="token punctuation">.</span>lhs<span class="token punctuation">.</span><span class="token builtin">getattr</span><span class="token punctuation">(</span><span class="token string">'addr'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            expr<span class="token punctuation">.</span><span class="token builtin">setattr</span><span class="token punctuation">(</span><span class="token string">'val'</span><span class="token punctuation">,</span> expr<span class="token punctuation">.</span>rhs<span class="token punctuation">.</span><span class="token builtin">getattr</span><span class="token punctuation">(</span><span class="token string">"val"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>目标代码生成</strong>: 在 <code>utils/riscv.py</code> 中实现了 <code>addi</code> 的 RISC-V 指令, 用于加载通过 <code>TACFunc.arrays</code> 传递并保存在栈的<strong>局部数组</strong> (仍通过 <code>Program.globalVars</code> 加载<strong>全局数组</strong>地址):</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># utils/riscv.py</span><span class="token keyword">class</span> <span class="token class-name">ImmAdd</span><span class="token punctuation">(</span>TACInstr<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> dst<span class="token punctuation">:</span> Temp<span class="token punctuation">,</span> src<span class="token punctuation">:</span> Temp<span class="token punctuation">,</span> value<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token builtin">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span>InstrKind<span class="token punctuation">.</span>SEQ<span class="token punctuation">,</span> <span class="token punctuation">[</span>dst<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>src<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>value <span class="token operator">=</span> value    <span class="token keyword">def</span> <span class="token function">__str__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">str</span><span class="token punctuation">:</span>        <span class="token keyword">assert</span> <span class="token operator">-</span><span class="token number">2048</span> <span class="token operator">&lt;=</span> self<span class="token punctuation">.</span>value <span class="token operator">&lt;=</span> <span class="token number">2047</span>  <span class="token comment"># Riscv imm [11:0]</span>        <span class="token keyword">return</span> <span class="token string">"addi "</span> <span class="token operator">+</span> Riscv<span class="token punctuation">.</span>FMT3<span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>            <span class="token builtin">str</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>dsts<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token builtin">str</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>srcs<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token builtin">str</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>value<span class="token punctuation">)</span>        <span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>进入一个函数前, 提前将其中的<strong>局部数组压栈</strong>, 在 <code>backend/subroutineinfo.py</code> 中计算得到各数组偏移量及占用栈帧大小:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># backend/subroutineinfo.py</span><span class="token keyword">class</span> <span class="token class-name">SubroutineInfo</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> funcLabel<span class="token punctuation">:</span> FuncLabel<span class="token punctuation">,</span> numArgs<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">,</span> arrays<span class="token punctuation">:</span> Dict<span class="token punctuation">[</span><span class="token builtin">str</span><span class="token punctuation">,</span> VarSymbol<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>offsets<span class="token punctuation">:</span> Dict<span class="token punctuation">[</span><span class="token builtin">str</span><span class="token punctuation">,</span> <span class="token builtin">int</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>        self<span class="token punctuation">.</span>size <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> name<span class="token punctuation">,</span> symbol <span class="token keyword">in</span> self<span class="token punctuation">.</span>arrays<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>offsets<span class="token punctuation">[</span>name<span class="token punctuation">]</span> <span class="token operator">=</span> self<span class="token punctuation">.</span>size            self<span class="token punctuation">.</span>size <span class="token operator">+=</span> symbol<span class="token punctuation">.</span><span class="token builtin">type</span><span class="token punctuation">.</span>size<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 <code>backend/riscv/riscvasmemitter.py</code> 中, <code>RiscvAsmEmitter</code> 对象初始化时打印<strong>全局数组</strong>至 <code>.bss</code> 区, <code>RiscvInstrSelector</code> 中通过偏移量实现<strong>局部数组</strong>访问:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># backend/riscv/riscvasmemitter.py</span><span class="token keyword">class</span> <span class="token class-name">RiscvAsmEmitter</span><span class="token punctuation">(</span>AsmEmitter<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token keyword">class</span> <span class="token class-name">RiscvInstrSelector</span><span class="token punctuation">(</span>TACVisitor<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">visitLoadAddress</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> instr<span class="token punctuation">:</span> LoadAddress<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> instr<span class="token punctuation">.</span>symbol<span class="token punctuation">.</span>isGlobal<span class="token punctuation">:</span>                <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                self<span class="token punctuation">.</span>seq<span class="token punctuation">.</span>append<span class="token punctuation">(</span>Riscv<span class="token punctuation">.</span>ImmAdd<span class="token punctuation">(</span>instr<span class="token punctuation">.</span>dsts<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> Riscv<span class="token punctuation">.</span>SP<span class="token punctuation">,</span> self<span class="token punctuation">.</span>info<span class="token punctuation">.</span>offsets<span class="token punctuation">[</span>instr<span class="token punctuation">.</span>symbol<span class="token punctuation">.</span>name<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此时的 <code>self.nextLocalOffset</code> 及保存 <code>RA</code>, <code>FP</code> 和 <code>Callee-saved</code> 寄存器时需要额外加上 <code>self.info.size</code> 由<strong>局部数组</strong>占用的栈帧大小.</p><h3 id="step-12"><a href="#step-12" class="headerlink" title="step 12"></a>step 12</h3><p><strong>代码流读入</strong>: 在 <code>main.py</code> 中给出 <code>memset</code> 函数 <code>fill_csx</code> 的<strong>字符串表示</strong>, 命名方式是为了防止可能的函数重名 (虽然根据给出的测例, 没有名为 <code>fill_csx</code> 的函数, 但更好的方法是在语法分析后动态命名). 随后直接将代码加入输入的 <code>code</code> 前:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># main.py</span>memsetFunc <span class="token operator">=</span> <span class="token triple-quoted-string string">r"""int fill_csx(int array[], int cnt) {    for (int i = 0; i &lt; cnt; i = i + 1) {        array[i] = 0;    }    return 0;}"""</span><span class="token keyword">def</span> <span class="token function">step_parse</span><span class="token punctuation">(</span>args<span class="token punctuation">:</span> argparse<span class="token punctuation">.</span>Namespace<span class="token punctuation">)</span><span class="token punctuation">:</span>    code <span class="token operator">=</span> memsetFunc <span class="token operator">+</span> <span class="token string">"\n"</span> <span class="token operator">+</span> readCode<span class="token punctuation">(</span>args<span class="token punctuation">.</span><span class="token builtin">input</span><span class="token punctuation">)</span>    r<span class="token punctuation">:</span> Program <span class="token operator">=</span> parser<span class="token punctuation">.</span>parse<span class="token punctuation">(</span>code<span class="token punctuation">,</span> lexer<span class="token operator">=</span>lexer<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>词法语法分析</strong>: 修改 <code>frontend/ast/tree.py</code>, 修改 <code>Parameter</code> 节点定义, 添加维度声明 <code>init_dim</code> 标识<strong>数组传参</strong>; 同时添加<strong>数组初始化列表</strong>节点 <code>InitList</code>.</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># frontend/ast/tree.py</span><span class="token keyword">class</span> <span class="token class-name">InitList</span><span class="token punctuation">(</span>Node<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> init_list<span class="token punctuation">:</span> List<span class="token punctuation">[</span>IntLiteral<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token builtin">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token string">"init_list"</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>init_list <span class="token operator">=</span> init_list        self<span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token punctuation">[</span>item<span class="token punctuation">.</span>value <span class="token keyword">for</span> item <span class="token keyword">in</span> init_list<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 <code>frontend/parser/ply_parser.py</code> 中参考已有实现, 给出相关 <code>CFG</code> 文法.</p><p><strong>语义分析</strong>: 修改 <code>frontend/typecheck/namer.py</code>, 在 <code>visitFunction</code> 中记录函数声明中进行传参的<strong>参数数组</strong>; 在 <code>visitParameter</code> 中依据参数类型进行标识符 <code>symbol</code> 生成, 如果是数组则调用 <code>ArrayType.multidim</code> 生成相应的数据类型.</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># frontend/typecheck/namer.py</span><span class="token keyword">def</span> <span class="token function">visitParameter</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> param<span class="token punctuation">:</span> Parameter<span class="token punctuation">,</span> ctx<span class="token punctuation">:</span> ScopeStack<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">#! 为数组参数, 检查并生成相应的数据类型</span>  <span class="token keyword">if</span> param<span class="token punctuation">.</span>init_dim<span class="token punctuation">:</span>        <span class="token keyword">for</span> index<span class="token punctuation">,</span> dim <span class="token keyword">in</span> <span class="token builtin">enumerate</span><span class="token punctuation">(</span>param<span class="token punctuation">.</span>init_dim<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> index <span class="token operator">==</span> <span class="token number">0</span> <span class="token keyword">and</span> dim <span class="token keyword">is</span> NULL<span class="token punctuation">:</span>                <span class="token keyword">continue</span>            <span class="token keyword">if</span> dim<span class="token punctuation">.</span>value <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">:</span>                <span class="token keyword">raise</span> DecafBadArraySizeError<span class="token punctuation">(</span><span class="token punctuation">)</span>        decl_type <span class="token operator">=</span> ArrayType<span class="token punctuation">.</span>multidim<span class="token punctuation">(</span>param<span class="token punctuation">.</span>var_t<span class="token punctuation">.</span><span class="token builtin">type</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">[</span>dim<span class="token punctuation">.</span>value <span class="token keyword">if</span> dim <span class="token keyword">else</span> <span class="token boolean">None</span> <span class="token keyword">for</span> dim <span class="token keyword">in</span> param<span class="token punctuation">.</span>init_dim<span class="token punctuation">]</span><span class="token punctuation">)</span>        symbol <span class="token operator">=</span> VarSymbol<span class="token punctuation">(</span>param<span class="token punctuation">.</span>ident<span class="token punctuation">.</span>value<span class="token punctuation">,</span> decl_type<span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>中间代码生成</strong>: 在 <code>utils/tac/tacgen.py</code> 中修改 <code>TACGen</code> 类的 <code>visitIdentifier</code> 方法, 对<strong>全局数组与局部数组</strong>直接加载数组地址, 对<strong>参数数组</strong>加载相应虚拟寄存器; 修改 <code>visitDeclaration</code> 方法, 若为<strong>带初始化列表</strong>的<strong>局部数组</strong>声明, 先调用 <code>fill_csx</code> 函数进行内存清零, 然后逐一进行元素初始化:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># utils/tac/tacgen.py</span><span class="token keyword">class</span> <span class="token class-name">TACGen</span><span class="token punctuation">(</span>Visitor<span class="token punctuation">[</span>TACFuncEmitter<span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">visitIdentifier</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> ident<span class="token punctuation">:</span> Identifier<span class="token punctuation">,</span> mv<span class="token punctuation">:</span> TACFuncEmitter<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>ident<span class="token punctuation">.</span><span class="token builtin">getattr</span><span class="token punctuation">(</span><span class="token string">'symbol'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">type</span><span class="token punctuation">,</span> ArrayType<span class="token punctuation">)</span><span class="token punctuation">:</span>          <span class="token comment"># 全局数组与局部数组</span>            <span class="token keyword">if</span> ident<span class="token punctuation">.</span><span class="token builtin">getattr</span><span class="token punctuation">(</span><span class="token string">"symbol"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>isGlobal <span class="token keyword">or</span> ident<span class="token punctuation">.</span><span class="token builtin">getattr</span><span class="token punctuation">(</span><span class="token string">'symbol'</span><span class="token punctuation">)</span> <span class="token keyword">not</span> <span class="token keyword">in</span> mv<span class="token punctuation">.</span>func<span class="token punctuation">.</span>p_arrays<span class="token punctuation">.</span>values<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                ident<span class="token punctuation">.</span><span class="token builtin">setattr</span><span class="token punctuation">(</span><span class="token string">'addr'</span><span class="token punctuation">,</span> mv<span class="token punctuation">.</span>visitLoadAddress<span class="token punctuation">(</span>ident<span class="token punctuation">.</span><span class="token builtin">getattr</span><span class="token punctuation">(</span><span class="token string">'symbol'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                ident<span class="token punctuation">.</span><span class="token builtin">setattr</span><span class="token punctuation">(</span><span class="token string">'val'</span><span class="token punctuation">,</span> ident<span class="token punctuation">.</span><span class="token builtin">getattr</span><span class="token punctuation">(</span><span class="token string">'addr'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token comment"># 参数数组</span>          <span class="token keyword">else</span><span class="token punctuation">:</span>                ident<span class="token punctuation">.</span><span class="token builtin">setattr</span><span class="token punctuation">(</span><span class="token string">'addr'</span><span class="token punctuation">,</span> ident<span class="token punctuation">.</span><span class="token builtin">getattr</span><span class="token punctuation">(</span><span class="token string">'symbol'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>temp<span class="token punctuation">)</span>                ident<span class="token punctuation">.</span><span class="token builtin">setattr</span><span class="token punctuation">(</span><span class="token string">'val'</span><span class="token punctuation">,</span> ident<span class="token punctuation">.</span><span class="token builtin">getattr</span><span class="token punctuation">(</span><span class="token string">'addr'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">visitDeclaration</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> decl<span class="token punctuation">:</span> Declaration<span class="token punctuation">,</span> mv<span class="token punctuation">:</span> TACFuncEmitter<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>decl<span class="token punctuation">.</span>init_expr<span class="token punctuation">,</span> InitList<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment">#! 调用 `fill_csx` 函数进行初始化</span>            symbol <span class="token operator">=</span> decl<span class="token punctuation">.</span><span class="token builtin">getattr</span><span class="token punctuation">(</span><span class="token string">"symbol"</span><span class="token punctuation">)</span>            addr <span class="token operator">=</span> mv<span class="token punctuation">.</span>visitLoadAddress<span class="token punctuation">(</span>symbol<span class="token punctuation">)</span>            <span class="token comment">#! size 为 4 -&gt; int 字长</span>            size <span class="token operator">=</span> symbol<span class="token punctuation">.</span><span class="token builtin">type</span><span class="token punctuation">.</span>full_indexed<span class="token punctuation">.</span>size            interval <span class="token operator">=</span> mv<span class="token punctuation">.</span>visitLoad<span class="token punctuation">(</span>size<span class="token punctuation">)</span>            mv<span class="token punctuation">.</span>visitParam<span class="token punctuation">(</span>addr<span class="token punctuation">)</span>            mv<span class="token punctuation">.</span>visitParam<span class="token punctuation">(</span>mv<span class="token punctuation">.</span>visitLoad<span class="token punctuation">(</span>symbol<span class="token punctuation">.</span><span class="token builtin">type</span><span class="token punctuation">.</span>size <span class="token operator">//</span> size<span class="token punctuation">)</span><span class="token punctuation">)</span>            mv<span class="token punctuation">.</span>visitCall<span class="token punctuation">(</span>FuncLabel<span class="token punctuation">(</span><span class="token string">"fill_csx"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token comment">#! 依次将初始化列表中的值存入数组中</span>            <span class="token keyword">for</span> value <span class="token keyword">in</span> decl<span class="token punctuation">.</span>init_expr<span class="token punctuation">.</span>value<span class="token punctuation">:</span>                mv<span class="token punctuation">.</span>visitStoreByAddress<span class="token punctuation">(</span>mv<span class="token punctuation">.</span>visitLoad<span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">,</span> addr<span class="token punctuation">)</span>                mv<span class="token punctuation">.</span>visitBinarySelf<span class="token punctuation">(</span>tacop<span class="token punctuation">.</span>TacBinaryOp<span class="token punctuation">.</span>ADD<span class="token punctuation">,</span> addr<span class="token punctuation">,</span> interval<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>目标代码生成</strong>: 在 <code>backend/riscv/riscvasmemitter.py</code> 中, <code>RiscvAsmEmitter</code> 对象初始化时打印<strong>带初始化列表</strong>的<strong>全局数组</strong>至 <code>.data</code> 区.</p><p>由于传参和调用分离, 对于<strong>参数数组</strong>的使用与<strong>普通函数参数</strong>并无区别, 这一步沿用 <strong>step 9</strong> 的实现即可, 后端无需进行其他工作.</p><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><h3 id="step-10-1"><a href="#step-10-1" class="headerlink" title="step 10"></a>step 10</h3><ol><li><p>写出 <code>la v0, a</code> 这一 RiscV 伪指令可能会被转换成的指令组合 (两种即可).</p><p> <strong>答:</strong> 查阅 <a href="https://cloud.tsinghua.edu.cn/f/396ace39c8d24411a28f/">The RISC-V Instruction Set Manual</a>.</p><ul><li><p>non-PIC 可能转换为:</p>  <pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">auipc v0, delta[31:12] + delta[11]addi v0, v0, delta[11:0]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>  其中 <code>delta</code> 为 <code>a</code> 相对 <code>PC</code> 的偏移量, 因为地址在编译时已知, 所以使用 <code>addi</code> 加载.</p></li><li><p>PIC 可能转换为:</p>  <pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">auipc v0, delta[31:12] + delta[11]lw v0, v0, delta[11:0]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>  其中 <code>delta</code> 为 <code>a</code> 在 GOT 中的地址相对 <code>PC</code> 的偏移量, 因为 GOT 中的地址可能在运行时进行重定位, 因此需要使用 <code>lw</code> 从内存中加载地址.</p></li><li><p>两种指令组合都存在 <code>+ delta[11]</code>, 这保证了在 <code>delta[11] = 1</code> 时, 低 12 位经过符号扩展, 最终也能够得到正确的结果.</p></li></ul></li></ol><h3 id="step-11-1"><a href="#step-11-1" class="headerlink" title="step 11"></a>step 11</h3><ol><li><p>C 语言规范规定, 允许局部变量是可变长度的数组 (VLA), 在我们的实验中为了简化, 选择不支持它. 请简要回答, 如果支持一维的可变长度的数组 (类似 <code>int n = 5; int a[n];</code>, 但不允许类似 <code>int n = ...; int m = ...; int a[n][m];</code>), 而且要求数组仍保存在栈上 (不允许用堆上动态内存申请), 应该在现有的实现基础上做出那些改动?</p><blockquote><p>提示: 不能再在进入函数时统一给局部变量分配内存, 离开时统一释放内存.</p></blockquote><p> <strong>答:</strong> 不能在进入函数时为 VLA 分配内存. 由于 VLA 的大小在编译期确定, 运行到声明 VLA 时, 将当前 <code>SP</code> 和 VLA 大小 <code>size</code> 保存到栈上 <code>-size(SP)</code> 处, 并移动 <code>SP</code>, 此时先前存储好的 <code>SP</code> 和 <code>size</code> 恰位于栈顶; 访问 VLA 的元素时, 计算偏移量 VLA 元素地址; 当 VLA 离开作用域时, 恢复 SP 即可.</p></li></ol><h3 id="step-12-1"><a href="#step-12-1" class="headerlink" title="step 12"></a>step 12</h3><ol><li><p>作为函数参数的数组类型第一维可以为空. 事实上, 在 C/C++ 中即使标明了第一维的大小, 类型检查依然会当作第一维是空的情况处理. 如何理解这一设计?</p><p> <strong>答:</strong> C/C++ 数组传参时, 数组名对应首元素地址; 函数无需为数组分配内存, 只需要通过首地址和偏移量即可访问到任意数组元素, 根据数组索引计算偏移量不会用到第一维的大小, 因此编译器会将数组参数的第一维视为空.</p></li></ol>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;Stage-6-报告&quot;&gt;&lt;a href=&quot;#Stage-6-报告&quot; class=&quot;headerlink&quot; title=&quot;Stage 6 报告&quot;&gt;&lt;/a&gt;Stage 6 报告&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;写在前面:&lt;/em&gt;&lt;br&gt;   </summary>
        
      
    
    
    
    <category term="CS" scheme="http://chengsx21.github.io/categories/CS/"/>
    
    <category term="Compiler" scheme="http://chengsx21.github.io/categories/CS/Compiler/"/>
    
    
    <category term="Compiler" scheme="http://chengsx21.github.io/tags/Compiler/"/>
    
  </entry>
  
  <entry>
    <title>编译原理 实验5</title>
    <link href="http://chengsx21.github.io/2023/12/13/bian-yi-yuan-li-lab-5/"/>
    <id>http://chengsx21.github.io/2023/12/13/bian-yi-yuan-li-lab-5/</id>
    <published>2023-12-13T09:18:57.000Z</published>
    <updated>2024-06-30T09:52:55.528Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Stage-5-报告"><a href="#Stage-5-报告" class="headerlink" title="Stage 5 报告"></a>Stage 5 报告</h1><h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><h3 id="step-9"><a href="#step-9" class="headerlink" title="step 9"></a>step 9</h3><p><strong>词法语法分析</strong>: 修改 <code>frontend/ast/tree.py</code>, 定义 <code>Call</code>, <code>Parameter</code>, <code>ParameterList</code>, <code>ExpressionList</code> 节点, 在 <code>frontend/parser/ply_parser.py</code> 中参考已有实现, 给出相关 <code>CFG</code> 文法.</p><p><strong>语义分析</strong>: 修改 <code>frontend/typecheck/namer.py</code>, 完成语义分析. <code>visitFunction</code> 中首先需要检查函数是否重复声明, 同时为了将函数参数与函数体置于同一个作用域, 需要修改 <code>func.body.accept</code>, 避免访问 <code>block</code> 而新开一个作用域:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># frontend/typecheck/namer.py</span><span class="token keyword">def</span> <span class="token function">visitFunction</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> func<span class="token punctuation">:</span> Function<span class="token punctuation">,</span> ctx<span class="token punctuation">:</span> ScopeStack<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> GlobalScope<span class="token punctuation">.</span>lookup<span class="token punctuation">(</span>func<span class="token punctuation">.</span>ident<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">raise</span> DecafDeclConflictError<span class="token punctuation">(</span>func<span class="token punctuation">.</span>ident<span class="token punctuation">.</span>value<span class="token punctuation">)</span>    symbol <span class="token operator">=</span> FuncSymbol<span class="token punctuation">(</span>func<span class="token punctuation">.</span>ident<span class="token punctuation">.</span>value<span class="token punctuation">,</span> func<span class="token punctuation">.</span>ret_t<span class="token punctuation">.</span><span class="token builtin">type</span><span class="token punctuation">,</span> GlobalScope<span class="token punctuation">)</span>    <span class="token keyword">for</span> param <span class="token keyword">in</span> func<span class="token punctuation">.</span>params<span class="token punctuation">.</span>children<span class="token punctuation">:</span>        symbol<span class="token punctuation">.</span>addParaType<span class="token punctuation">(</span>param<span class="token punctuation">.</span>var_t<span class="token punctuation">)</span>    GlobalScope<span class="token punctuation">.</span>declare<span class="token punctuation">(</span>symbol<span class="token punctuation">)</span>    func<span class="token punctuation">.</span><span class="token builtin">setattr</span><span class="token punctuation">(</span><span class="token string">'symbol'</span><span class="token punctuation">,</span> symbol<span class="token punctuation">)</span>    ctx<span class="token punctuation">.</span><span class="token builtin">open</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    func<span class="token punctuation">.</span>params<span class="token punctuation">.</span>accept<span class="token punctuation">(</span>self<span class="token punctuation">,</span> ctx<span class="token punctuation">)</span>    <span class="token keyword">for</span> child <span class="token keyword">in</span> func<span class="token punctuation">.</span>body<span class="token punctuation">.</span>children<span class="token punctuation">:</span>        child<span class="token punctuation">.</span>accept<span class="token punctuation">(</span>self<span class="token punctuation">,</span> ctx<span class="token punctuation">)</span>    ctx<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>visitCall</code> 中首先需要检查函数名是否被同级作用域声明的变量覆盖, 然后检查调用参数是否符合数目:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># frontend/typecheck/namer.py</span><span class="token keyword">def</span> <span class="token function">visitCall</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> call<span class="token punctuation">:</span> Call<span class="token punctuation">,</span> ctx<span class="token punctuation">:</span> ScopeStack<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> ctx<span class="token punctuation">.</span>lookup<span class="token punctuation">(</span>call<span class="token punctuation">.</span>ident<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">:</span>      <span class="token keyword">raise</span> DecafBadFuncCallError<span class="token punctuation">(</span>call<span class="token punctuation">.</span>ident<span class="token punctuation">.</span>value<span class="token punctuation">)</span>    func <span class="token operator">=</span> GlobalScope<span class="token punctuation">.</span>lookup<span class="token punctuation">(</span>call<span class="token punctuation">.</span>ident<span class="token punctuation">.</span>value<span class="token punctuation">)</span>    <span class="token keyword">if</span> <span class="token keyword">not</span> func <span class="token keyword">or</span> <span class="token keyword">not</span> func<span class="token punctuation">.</span>isFunc<span class="token punctuation">:</span>        <span class="token keyword">raise</span> DecafUndefinedFuncError<span class="token punctuation">(</span>call<span class="token punctuation">.</span>ident<span class="token punctuation">.</span>value<span class="token punctuation">)</span>    <span class="token keyword">if</span> func<span class="token punctuation">.</span>parameterNum <span class="token operator">!=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>call<span class="token punctuation">.</span>args<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">raise</span> DecafBadFuncCallError<span class="token punctuation">(</span><span class="token punctuation">)</span>    call<span class="token punctuation">.</span>ident<span class="token punctuation">.</span><span class="token builtin">setattr</span><span class="token punctuation">(</span><span class="token string">'symbol'</span><span class="token punctuation">,</span> func<span class="token punctuation">)</span>    <span class="token keyword">for</span> arg <span class="token keyword">in</span> call<span class="token punctuation">.</span>args<span class="token punctuation">:</span>        arg<span class="token punctuation">.</span>accept<span class="token punctuation">(</span>self<span class="token punctuation">,</span> ctx<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>中间代码生成</strong>: 使用传参和调用分离模式, 在 <code>utils/tac/tacop.py</code> 中添加两类指令类型定义:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># utils/tac/tacop.py</span><span class="token decorator annotation punctuation">@unique</span><span class="token keyword">class</span> <span class="token class-name">InstrKind</span><span class="token punctuation">(</span>Enum<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># Function call.</span>    CALL <span class="token operator">=</span> auto<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment"># Function parameter.</span>    PARAM <span class="token operator">=</span> auto<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 <code>utils/tac/tacinstr.py</code> 中参照已有实现定义了 <code>Call</code> 与 <code>Param</code> 两种 TAC 指令类, 在 <code>utils/tac/tacgen.py</code> 中实现与之有关的 <code>Visitor</code> 模式方法:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># utils/tac/tacgen.py</span><span class="token keyword">class</span> <span class="token class-name">TACFuncEmitter</span><span class="token punctuation">(</span>TACVisitor<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token keyword">def</span> <span class="token function">visitParam</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> value<span class="token punctuation">:</span> Temp<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>func<span class="token punctuation">.</span>add<span class="token punctuation">(</span>Param<span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">visitCall</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> label<span class="token punctuation">:</span> Label<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> Temp<span class="token punctuation">:</span>        temp <span class="token operator">=</span> self<span class="token punctuation">.</span>freshTemp<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>func<span class="token punctuation">.</span>add<span class="token punctuation">(</span>Call<span class="token punctuation">(</span>temp<span class="token punctuation">,</span> label<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> temp<span class="token keyword">class</span> <span class="token class-name">TACGen</span><span class="token punctuation">(</span>Visitor<span class="token punctuation">[</span>TACFuncEmitter<span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">visitParameter</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> param<span class="token punctuation">:</span> Parameter<span class="token punctuation">,</span> mv<span class="token punctuation">:</span> TACFuncEmitter<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>      <span class="token comment"># 分配虚拟寄存器</span>        param<span class="token punctuation">.</span><span class="token builtin">getattr</span><span class="token punctuation">(</span><span class="token string">'symbol'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>temp <span class="token operator">=</span> mv<span class="token punctuation">.</span>freshTemp<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">visitCall</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> call<span class="token punctuation">:</span> Call<span class="token punctuation">,</span> mv<span class="token punctuation">:</span> TACFuncEmitter<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>        <span class="token keyword">for</span> arg <span class="token keyword">in</span> call<span class="token punctuation">.</span>args<span class="token punctuation">.</span>children<span class="token punctuation">:</span>            arg<span class="token punctuation">.</span>accept<span class="token punctuation">(</span>self<span class="token punctuation">,</span> mv<span class="token punctuation">)</span>        <span class="token keyword">for</span> arg <span class="token keyword">in</span> call<span class="token punctuation">.</span>args<span class="token punctuation">.</span>children<span class="token punctuation">:</span>            mv<span class="token punctuation">.</span>visitParam<span class="token punctuation">(</span>arg<span class="token punctuation">.</span><span class="token builtin">getattr</span><span class="token punctuation">(</span><span class="token string">"val"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        call<span class="token punctuation">.</span><span class="token builtin">setattr</span><span class="token punctuation">(</span><span class="token string">'val'</span><span class="token punctuation">,</span> mv<span class="token punctuation">.</span>visitCall<span class="token punctuation">(</span>FuncLabel<span class="token punctuation">(</span>call<span class="token punctuation">.</span>ident<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>目标代码生成</strong>: 在 <code>utils/riscv.py</code> 中定义了 <code>Call</code> 与 <code>Param</code> 类指令用于寄存器分配的标识, 同时仿照 <code>SPAdd</code> 指令实现了 <code>FPAdd</code> 指令用于保存和恢复栈帧.</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># utils/riscv.py</span><span class="token keyword">class</span> <span class="token class-name">Call</span><span class="token punctuation">(</span>TACInstr<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> target<span class="token punctuation">:</span> Label<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>        <span class="token builtin">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span>InstrKind<span class="token punctuation">.</span>CALL<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> target<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>target <span class="token operator">=</span> target    <span class="token keyword">def</span> <span class="token function">__str__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">str</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token string">"call "</span> <span class="token operator">+</span> <span class="token builtin">super</span><span class="token punctuation">(</span>FuncLabel<span class="token punctuation">,</span> self<span class="token punctuation">.</span>target<span class="token punctuation">)</span><span class="token punctuation">.</span>__str__<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">Param</span><span class="token punctuation">(</span>TACInstr<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> src<span class="token punctuation">:</span> Temp<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>        <span class="token builtin">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span>InstrKind<span class="token punctuation">.</span>PARAM<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>src<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>backend/subroutineemitter.py</code> 实现了 <code>emitReg</code>,  <code>emitStoreParamToStack</code>, <code>emitRestoreStackPointer</code> 等方法用于保存参数到寄存器, 保存参数到栈中以及恢复栈指针.</p><p>在 <code>backend/riscv/riscvasmemitter.py</code> 中修改 <code>emitEnd</code> 打印 Riscv 指令的逻辑, 进入函数时将 <code>fp</code>, <code>ra</code> 寄存器存储到栈上, 保存 <code>callee_saved</code> 寄存器; 函数结束时, 从栈上恢复 <code>fp</code>, <code>ra</code> 寄存器和 <code>callee_saved</code> 寄存器:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># backend/riscv/riscvasmemitter.py</span><span class="token keyword">def</span> <span class="token function">emitEnd</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment"># store RA, FP and CalleeSaved regs here</span>    self<span class="token punctuation">.</span>printer<span class="token punctuation">.</span>printInstr<span class="token punctuation">(</span>Riscv<span class="token punctuation">.</span>SPAdd<span class="token punctuation">(</span><span class="token operator">-</span>self<span class="token punctuation">.</span>nextLocalOffset<span class="token punctuation">)</span><span class="token punctuation">)</span>    self<span class="token punctuation">.</span>printer<span class="token punctuation">.</span>printInstr<span class="token punctuation">(</span>Riscv<span class="token punctuation">.</span>NativeStoreWord<span class="token punctuation">(</span>Riscv<span class="token punctuation">.</span>RA<span class="token punctuation">,</span> Riscv<span class="token punctuation">.</span>SP<span class="token punctuation">,</span> <span class="token number">4</span> <span class="token operator">*</span> <span class="token builtin">len</span><span class="token punctuation">(</span>Riscv<span class="token punctuation">.</span>CalleeSaved<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    self<span class="token punctuation">.</span>printer<span class="token punctuation">.</span>printInstr<span class="token punctuation">(</span>Riscv<span class="token punctuation">.</span>NativeStoreWord<span class="token punctuation">(</span>Riscv<span class="token punctuation">.</span>FP<span class="token punctuation">,</span> Riscv<span class="token punctuation">.</span>SP<span class="token punctuation">,</span> <span class="token number">4</span> <span class="token operator">*</span> <span class="token builtin">len</span><span class="token punctuation">(</span>Riscv<span class="token punctuation">.</span>CalleeSaved<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    self<span class="token punctuation">.</span>printer<span class="token punctuation">.</span>printInstr<span class="token punctuation">(</span>Riscv<span class="token punctuation">.</span>FPAdd<span class="token punctuation">(</span>self<span class="token punctuation">.</span>nextLocalOffset<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment"># load RA, FP and CalleeSaved regs here</span>    self<span class="token punctuation">.</span>printer<span class="token punctuation">.</span>printInstr<span class="token punctuation">(</span>Riscv<span class="token punctuation">.</span>NativeLoadWord<span class="token punctuation">(</span>Riscv<span class="token punctuation">.</span>RA<span class="token punctuation">,</span> Riscv<span class="token punctuation">.</span>SP<span class="token punctuation">,</span> <span class="token number">4</span> <span class="token operator">*</span> <span class="token builtin">len</span><span class="token punctuation">(</span>Riscv<span class="token punctuation">.</span>CalleeSaved<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    self<span class="token punctuation">.</span>printer<span class="token punctuation">.</span>printInstr<span class="token punctuation">(</span>Riscv<span class="token punctuation">.</span>NativeLoadWord<span class="token punctuation">(</span>Riscv<span class="token punctuation">.</span>FP<span class="token punctuation">,</span> Riscv<span class="token punctuation">.</span>SP<span class="token punctuation">,</span> <span class="token number">4</span> <span class="token operator">*</span> <span class="token builtin">len</span><span class="token punctuation">(</span>Riscv<span class="token punctuation">.</span>CalleeSaved<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    self<span class="token punctuation">.</span>printer<span class="token punctuation">.</span>printInstr<span class="token punctuation">(</span>Riscv<span class="token punctuation">.</span>SPAdd<span class="token punctuation">(</span>self<span class="token punctuation">.</span>nextLocalOffset<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 <code>backend/reg/bruteregalloc.py</code> 中, 使用 <code>self.numArgs</code> 记录函数自身的参数数量, 使用 <code>self.functionParams</code> 记录子函数所使用的参数对应的虚拟寄存器, 使用 <code>self.callerSavedRegs</code> 保存 <code>caller_saved</code> 寄存器. 在函数开始先将实参绑定到寄存器中, 然后分析语句.</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># backend/reg/bruteregalloc.py</span><span class="token keyword">def</span> <span class="token function">accept</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> graph<span class="token punctuation">:</span> CFG<span class="token punctuation">,</span> info<span class="token punctuation">:</span> SubroutineInfo<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>    self<span class="token punctuation">.</span>numArgs <span class="token operator">=</span> info<span class="token punctuation">.</span>numArgs    self<span class="token punctuation">.</span>functionParams <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    self<span class="token punctuation">.</span>callerSavedRegs <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>allocForLoc</code> 为每行指令分配寄存器时, 若为 <code>Param</code> 类型, 累计参数小于 8 时直接分配参数寄存器; 若为 <code>Call</code> 类型, 先保存 <code>caller_saved</code> 寄存器, 将多余参数插入栈中, 调用后恢复除 <code>A0</code> 外的所有 <code>caller_saved</code> 寄存器, 否则返回值会被覆盖. 同样需要注意的是, 为虚拟寄存器分配实际寄存器时, 需要特殊判断虚拟寄存器是否对应存储在栈上的函数参数:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># backend/reg/bruteregalloc.py</span><span class="token keyword">def</span> <span class="token function">allocRegFor</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> temp<span class="token punctuation">:</span> Temp<span class="token punctuation">,</span> isRead<span class="token punctuation">:</span> <span class="token builtin">bool</span><span class="token punctuation">,</span> live<span class="token punctuation">:</span> <span class="token builtin">set</span><span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">,</span> subEmitter<span class="token punctuation">:</span> SubroutineEmitter<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token keyword">if</span> isRead<span class="token punctuation">:</span>        <span class="token comment"># 如果是存储在栈上的参数, 利用 FP 从栈中加载</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>self<span class="token punctuation">.</span>maxNumParams <span class="token operator">&lt;=</span> temp<span class="token punctuation">.</span>index <span class="token operator">&lt;</span> self<span class="token punctuation">.</span>numArgs<span class="token punctuation">)</span><span class="token punctuation">:</span>            subEmitter<span class="token punctuation">.</span>emitLoadParamFromStack<span class="token punctuation">(</span>reg<span class="token punctuation">,</span> temp<span class="token punctuation">.</span>index<span class="token punctuation">)</span>        <span class="token comment"># 否则, 利用 SP 从栈中加载</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            subEmitter<span class="token punctuation">.</span>emitLoadFromStack<span class="token punctuation">(</span>reg<span class="token punctuation">,</span> temp<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><h3 id="step-9-1"><a href="#step-9-1" class="headerlink" title="step 9"></a>step 9</h3><ol><li><p>你更倾向采纳哪一种中间表示中的函数调用指令的设计 (一整条函数调用 vs 传参和调用分离)? 写一些你认为两种设计方案各自的优劣之处.</p><p> <strong>答:</strong> 我更倾向采纳传参和调用分离, 这与实验文档给出的参考中间风格一致, 更接近目标语言.</p><p> <strong>一整条函数调用</strong>:</p><ul><li><strong>优势</strong>:<ul><li>调用过程封装在一个指令中, 语义清晰, 可读性好.</li><li>更接近高级语言, 有助于保留源代码结构和语义.</li></ul></li><li><p><strong>劣势</strong>:</p><ul><li>整条函数调用指令可能不够精确, 再特定架构下不能满足精细控制的需求.</li></ul><p><strong>传参和调用分离</strong>:</p></li><li><p><strong>优势</strong>:</p><ul><li>与实验文档给出的参考中间风格一致, 更接近目标语言.</li></ul></li><li><strong>劣势</strong>:<ul><li>需要增加 <code>Param</code> 指令描述参数传递, 提高了实现难度.</li><li>中间表示可读性略差.</li></ul></li></ul></li><li><p>为何 RISC-V 标准调用约定中要引入 <code>callee-saved</code> 和 <code>caller-saved</code> 两类寄存器, 而不是要求所有寄存器完全由 <code>caller/callee</code> 中的一方保存? 为何保存返回地址的 <code>ra</code> 寄存器是 <code>caller-saved</code> 寄存器?</p><p> <strong>答:</strong> 如果寄存器都由 <code>caller</code> 保存, <code>callee</code> 可能只使用很少几个, 恢复寄存器开销过大; 如果寄存器都由 <code>callee</code> 保存, 函数调用结束时恢复所有用到的寄存器开销过大. 引入 <code>callee-saved</code> 和 <code>caller-saved</code> 两类寄存器, 编译器可以让 <code>callee</code> 保存函数调用后依然有效的值 (如返回地址), 让 <code>caller</code> 保存函数调用过程后不再使用的值 (如函数参数).</p><p> 调用函数时, <code>ra</code> 中当前返回地址会被调用函数的返回地址替代, 因此需要在进入函数前保存好 <code>ra</code> 的值, 这应当由 <code>caller</code> 来完成.</p></li></ol>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;Stage-5-报告&quot;&gt;&lt;a href=&quot;#Stage-5-报告&quot; class=&quot;headerlink&quot; title=&quot;Stage 5 报告&quot;&gt;&lt;/a&gt;Stage 5 报告&lt;/h1&gt;&lt;h2 id=&quot;实验内容&quot;&gt;&lt;a href=&quot;#实验内容&quot;</summary>
        
      
    
    
    
    <category term="CS" scheme="http://chengsx21.github.io/categories/CS/"/>
    
    <category term="Compiler" scheme="http://chengsx21.github.io/categories/CS/Compiler/"/>
    
    
    <category term="Compiler" scheme="http://chengsx21.github.io/tags/Compiler/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络安全技术 笔记7</title>
    <link href="http://chengsx21.github.io/2023/12/13/ji-suan-ji-wang-luo-an-quan-ji-zhu-bi-ji-7/"/>
    <id>http://chengsx21.github.io/2023/12/13/ji-suan-ji-wang-luo-an-quan-ji-zhu-bi-ji-7/</id>
    <published>2023-12-13T09:18:57.000Z</published>
    <updated>2024-06-30T09:49:13.957Z</updated>
    
    <content type="html"><![CDATA[<h1 id="七、电子商务与-SET-协议"><a href="#七、电子商务与-SET-协议" class="headerlink" title="七、电子商务与 SET 协议"></a>七、电子商务与 SET 协议</h1><h2 id="电子商务安全"><a href="#电子商务安全" class="headerlink" title="电子商务安全"></a>电子商务安全</h2><ul><li>电子商务安全要求:<ul><li>数据传输的安全性:<ul><li>保证在公网上传送的资金帐号、客户密码、支付金额等网络支付信息数据不被第三方窃取.</li><li>采用对称加密实现, 数字信封利用非对称加密实现.</li></ul></li><li>数据的完整性:<ul><li>数据在传输过程中不被篡改.</li><li>通过安全的散列函数和数字签名实现, 双重数字签名保证多方通信时数据的完整性.</li></ul></li><li>身份验证:<ul><li>交换敏感信息时确认对方真实身份, 支付时确认账户信息真实有效.</li><li>采用口令技术, 非对称密码, 数字签名, 数字证书等技术实现.</li></ul></li><li>交易的不可抵赖:<ul><li>各方在进行数据传输时, 带有自身特有无法复制的信息, 交易双方在支付过程中都无法抵赖, 保证发生纠纷时有所对证.</li><li>通过时间戳, 数字签名, 数字证书等技术实现.</li></ul></li></ul></li><li>电子商务安全包括:<ul><li>基本加密算法.</li><li>以基本加密算法为基础的证书认证体系 CA, 及数字信封、数字签名等基本安全技术.</li><li>以基本加密算法、安全技术、CA 体系为基础的安全应用协议.</li></ul></li><li>CA 认证体系:<ul><li>以基本加密算法为基础, 采用基本安全技术.</li><li>为上层安全应用协议提供证书认证.</li><li>CA 证书标准:<ul><li>各国自行开发并拥有版权的认证体系.</li><li>为用户发放 CA 证书, 包括 SSL 证书.</li><li>CA 证书以 X.509 为基础, 进行扩展, 兼容多种协议证书.</li></ul></li><li>SET CA:<ul><li>符合 SET 标准.</li><li>专为基于银行支付卡的电子商务服务提供者及用户发放 SET 证书.</li></ul></li></ul></li><li>电子商务安全体系:<ul><li>网络系统安全: 针对物理技术系统.<ul><li>保证网络设施的正常运行.</li><li>避免受到外界的恶意攻击.</li></ul></li><li>网络信息安全: 针对商务逻辑系统.<ul><li>信息保密、信息完整.</li><li>身份认证、不可抵赖.</li><li>信息有效.</li></ul></li><li>网络交易安全:<ul><li>参与对象之间交易过程.</li><li>如 SSL, SET, 公钥基础设施 PKI.</li></ul></li></ul></li></ul><h2 id="安全电子交易协议-SET"><a href="#安全电子交易协议-SET" class="headerlink" title="安全电子交易协议 SET"></a>安全电子交易协议 SET</h2><ul><li><p>SET 简介:</p><ul><li>应用于互联网环境, 以信用卡为基础的安全电子交付协议.</li><li>不用信用卡支付的交易方式与 SET 无关.</li><li>给出了电子交易的过程规范.</li><li>实现电子商务交易中的加密、认证、密钥管理机制.</li></ul></li><li><p>SET 目标:</p><ul><li>保密性:<ul><li>防止数据被黑客或被内部人员窃取.</li></ul></li><li>真实性:<ul><li>多方认证问题:<ul><li>对消费者信用卡认证.<ul><li>商家能够验证卡用户是有效卡账号的合法用户.</li></ul></li><li>对网上商店认证.<ul><li>卡用户可以验证商家可以接受支付信用卡.</li></ul></li><li>消费者、商店与银行间的认证.</li></ul></li></ul></li><li>隐私性:<ul><li>保证订单信息和个人账号信息的隔离:<ul><li>客户资料通过商家到达银行, 但商家不能看到客户帐号信息.</li><li>银行不能看到用户订单信息.</li></ul></li></ul></li><li>实时性:<ul><li>网上交易的实时性, 所有支付过程都是在线.</li></ul></li></ul></li><li><p>SET 参与方:</p><ul><li>发卡银行 (issuer):<ul><li>发放信用卡, 交易中处理电子货币的审核和支付.</li><li>交易开始前, 查验持卡人的数据有效, 交易才能成立.</li></ul></li><li>持卡人 (cardholder):<ul><li>包括个人和团体消费者.</li><li>填写网上商店表单, 通过发卡银行的信用卡付费.</li></ul></li><li>网上商家 (merchant):<ul><li>网上符合 SET 规格的电子商店, 提供商品或服务.</li><li>具备相应电子货币使用条件, 从事商业交易的公司组织.</li><li>通常向用户提供 Web 界面, 和收款行建立信任关系.</li></ul></li><li>支付网关 (payment gateway):<ul><li>由银行操作, 将互联网传输数据转为金融机构内部数据.</li><li>或由指派第三方处理商家支付信息和顾客支付指令.</li><li>将 SET 和现有银行卡支付的网络系统作为接口.</li></ul></li><li>收款行 (acquirer):<ul><li>收款行为商家建立账号, 处理每笔交易的支付授权和实际支付.</li><li>代替商家与多个发卡行联系, 验证持卡人信用卡信息的有效性.</li></ul></li><li><p>证书授权 (CA):</p><ul><li>可信赖的公正组织.</li><li>接受持卡人、商店、银行及支付网关的数字认证申请, 签发管理数字证书, 使持卡人、商家和支付网关可通过数字证书进行认证.</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301710233.png" alt=""></p></li></ul></li><li><p>SET 交易过程:</p><ul><li><p>交易前完成认证:</p><ul><li>持卡人证书:<ul><li>持卡人的发卡机构向持卡人发放证书.</li><li>持卡人向支付网关提供帐号信息和秘密值用于验证.</li><li>持卡人证书连同购买请求和加密支付指令传给商家, 商家在最低程度上验证该帐号.</li></ul></li><li>商家证书:<ul><li>网上商家获得证书认证, 表明接受某个银行的支付卡.</li></ul></li><li>支付网关证书:<ul><li>持卡人从支付网关证书获取密钥, 加密账号信息.</li><li>只有支付网关能看到持卡人账号信息.</li></ul></li><li>收款行证书/发卡行证书:<ul><li>收款行/发卡行通过证书, 接收并处理商家证书请求.</li></ul></li></ul></li><li><p>网上支付处理过程——购买请求:</p><ul><li><p>发起请求报文:</p><ul><li>持卡人向商家发送信用卡品牌, ID. </li></ul></li><li><p>发起响应报文:</p><ul><li>商家向持卡人发送用商户私钥签名, Transiaction ID, 证书. </li></ul></li><li><p>持卡人验证商家证书, 生成 PI 和 OI, 将 Transiaction ID 放入.</p></li><li><p>PI 和 OI 必须分开加密和签名, 保证用户隐私不被泄漏.</p></li><li><p>PI 和 OI 必须有联系, 防止商家篡改信息产生纠纷.</p></li><li><p>购买请求报文:</p><ul><li>持卡人向商家发送 PI 和 OI.</li></ul></li><li><p>双签名:</p><ul><li>连接两个发送给不同接收者的报文.</li><li><p>KRc 为顾客私有签名密钥.</p><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301710234.png" alt=""></p></li></ul></li><li><p>客户生成购买请求:</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301710235.png" alt=""></p></li><li><p>商家验证用户的订单:</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301710236.png" alt=""></p></li></ul></li><li><p>网上支付处理过程——支付授权:</p><ul><li>商家通过支付网关、发卡行得到授权, 才能发货.</li><li>授权请求报文:<ul><li>与购买有关的信息: PI, 双签名.</li><li>与授权有关的信息: Es.</li><li>证书: 客户, 商家.</li></ul></li><li>授权响应报文:<ul><li>与授权有关的信息.</li><li>证书.</li></ul></li><li>支付网关处理授权请求:<ul><li>验证证书合法性.</li><li>解密数字信封, 获得会话密钥.</li><li>验证商家数字签名.</li><li>解密支付信息.</li><li>验证双签名.</li><li>验证 Transiaction ID 与 PI 一致.</li><li>从发卡行申请支付.</li></ul></li><li>商家获得授权后, 向用户确认商品清单.</li></ul></li><li><p>网上支付处理过程——支付获取:</p><ul><li>商家向发卡行申请支付.</li><li>商家通过支付获取, 才能完成银行转帐业务.</li><li>获取请求报文:<ul><li>支付的数量, 交易 ID, 获取权标, 商人签名密钥, 证书.</li></ul></li><li>获取响应报文:<ul><li>网关签名, 加密获取相应数据块, 网关签名密钥证书.</li></ul></li></ul></li></ul></li><li><p>SSL 与 SET 的比较:</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301710237.png" alt=""></p></li></ul>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;七、电子商务与-SET-协议&quot;&gt;&lt;a href=&quot;#七、电子商务与-SET-协议&quot; class=&quot;headerlink&quot; title=&quot;七、电子商务与 SET 协议&quot;&gt;&lt;/a&gt;七、电子商务与 SET 协议&lt;/h1&gt;&lt;h2 id=&quot;电子商务安全&quot;&gt;&lt;a</summary>
        
      
    
    
    
    <category term="CS" scheme="http://chengsx21.github.io/categories/CS/"/>
    
    <category term="Network Security" scheme="http://chengsx21.github.io/categories/CS/Network-Security/"/>
    
    
    <category term="Network Security" scheme="http://chengsx21.github.io/tags/Network-Security/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成原理 笔记8</title>
    <link href="http://chengsx21.github.io/2023/12/11/ji-suan-ji-zu-cheng-yuan-li-bi-ji-8/"/>
    <id>http://chengsx21.github.io/2023/12/11/ji-suan-ji-zu-cheng-yuan-li-bi-ji-8/</id>
    <published>2023-12-11T09:18:57.000Z</published>
    <updated>2024-06-30T09:53:39.689Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h1><h2 id="SRAM"><a href="#SRAM" class="headerlink" title="SRAM"></a>SRAM</h2><ul><li>无需刷新: 持续供电即可保持稳态; 掉电数据丢失: 无持久性.</li><li>存储密度低: DRAM 使用 1 个晶体管, SRAM 使用 6 个晶体管.</li></ul><h2 id="Cache-1"><a href="#Cache-1" class="headerlink" title="Cache"></a>Cache</h2><ul><li>目的: 根据程序局部性, 加快程序执行.</li><li>包含信息:<ul><li>地址.</li><li>数据.</li><li>Valid 位.</li></ul></li><li>设计原则:<ul><li>内存物理地址到 Cache 地址的地址映射关系.</li><li>Cache 使用虚拟地址 or 物理地址.<ul><li>CPU 提供虚拟地址, Cache 虚拟地址无需让 MMU 进行 Page Table Walker, 加速查询.</li><li>两个 Cache 虚拟地址对应同一物理地址, 一致性有误.</li><li>一个 Cache 虚拟地址对应两个物理地址, Cache 只能保存一项.</li><li>薛定谔的地址?</li></ul></li><li>控制位.</li><li>数据粒度.</li></ul></li><li><p>Cache Line:</p><ul><li>大小至少 4Byte, 使用一个 Valid 位控制.</li><li>若 Cache Line 过大, 可针对每 4Byte 或 8Byte 再设 Valid 位.</li></ul></li><li><p>不允许 Cache 的内存地址: MMIO 外设, 如串口寄存器, 读写慢. 需要将内存地址分类为 Cached/Uncached.</p></li><li>Cache 分类:<ul><li>L1 Cache: 多核 private, 分 Icache 与 Dcache. </li><li>L2 Cache: 多核 private.</li><li>L3 Cache: 多核 public.</li></ul></li><li><p>内存物理地址到 Cache 地址的映射关系:</p><ul><li>地址只允许被映射到一个位置.</li><li>地址允许被映射到多个位置.</li><li><p>全相联映射: 任何地址允许被映射到任何 Cache 的任何位置.</p><ul><li>Cache Line 大小为 4Byte: 地址前 30 位为 CT, 后 2 位为 CO.</li><li><p>条件:</p><ul><li>Valid 位为 1.</li><li>CT 相同.</li></ul></li><li><p>利用率高; 1024 路比较电路成本大, 硬件复杂, 延迟增加.</p></li><li>需要缓存替换算法.</li></ul></li><li><p>直接映射: 主存按 Cache 大小分块, 地址对应映射.</p><ul><li>Cache 大小为 4KB: 地址前 20 位为 CT, 中 10 位为 CI, 后 2 位为 CO.</li><li><p>条件:</p><ul><li>CI 索引 Cache Line 位置.</li><li>Valid 位为 1.</li><li>CT 相同.</li></ul></li><li><p>单路比较电路, 硬件简单; 利用率低.</p></li><li>无需缓存替换算法.</li></ul></li><li><p>组相联映射: 结合全相联映射与直接映射, 相当于多路直接映射.</p></li></ul></li><li>Cache 写策略:<ul><li>Write back (绝大多数):<ul><li>写分配:<ul><li>先替换, 替换时 Dirty 写回主存, 替换后再写 Cache.</li><li>程序 load/store 仅对 Cache 进行, 程序视角满足一致性.</li></ul></li></ul></li><li>Write through (MMIO 内存 or 多核 CPU 的 TLB 更新):<ul><li>写分配:<ul><li>先替换, 替换后先写 Cache, 再写主存.</li></ul></li><li>非写分配:<ul><li>直接写主存.</li></ul></li></ul></li></ul></li><li><p>Cache 缺失:</p><ul><li>必然缺失: 进程切换/首次访问.</li><li>容量缺失: 全相联映射.</li><li>冲突缺失: 直接映射/组相联映射.</li><li>无效缺失: 其他进程修改.</li></ul></li><li><p>Cache 替换策略:</p><ul><li>RAND.</li><li>FIFO.</li><li>LRU.</li></ul></li></ul>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;Cache&quot;&gt;&lt;a href=&quot;#Cache&quot; class=&quot;headerlink&quot; title=&quot;Cache&quot;&gt;&lt;/a&gt;Cache&lt;/h1&gt;&lt;h2 id=&quot;SRAM&quot;&gt;&lt;a href=&quot;#SRAM&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    <category term="CS" scheme="http://chengsx21.github.io/categories/CS/"/>
    
    <category term="Organization &amp; Design" scheme="http://chengsx21.github.io/categories/CS/Organization-Design/"/>
    
    
    <category term="Organization &amp; Design" scheme="http://chengsx21.github.io/tags/Organization-Design/"/>
    
    <category term="SV" scheme="http://chengsx21.github.io/tags/SV/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络安全技术 笔记6</title>
    <link href="http://chengsx21.github.io/2023/11/29/ji-suan-ji-wang-luo-an-quan-ji-zhu-bi-ji-6/"/>
    <id>http://chengsx21.github.io/2023/11/29/ji-suan-ji-wang-luo-an-quan-ji-zhu-bi-ji-6/</id>
    <published>2023-11-29T09:18:57.000Z</published>
    <updated>2024-06-30T09:49:13.956Z</updated>
    
    <content type="html"><![CDATA[<h1 id="六、SSL-及-HTTPS"><a href="#六、SSL-及-HTTPS" class="headerlink" title="六、SSL 及 HTTPS"></a>六、SSL 及 HTTPS</h1><h2 id="传输层安全协议-SSL"><a href="#传输层安全协议-SSL" class="headerlink" title="传输层安全协议 SSL"></a>传输层安全协议 SSL</h2><h3 id="传输层安全协议概述"><a href="#传输层安全协议概述" class="headerlink" title="传输层安全协议概述"></a>传输层安全协议概述</h3><ul><li>网络层安全协议:<ul><li>提供端到端的网络层安全传输.</li><li>无法处理同一端系统中不同应用的安全需求.</li><li>需要在传输层和更高层提供网络安全传输服务.</li></ul></li><li>传输层安全服务:<ul><li>保证两个应用之间的保密性和安全性, 提供应用层安全服务.</li></ul></li><li>常用协议: SP4、TLSP、SSH、SSL.</li></ul><h3 id="SSL-协议概述"><a href="#SSL-协议概述" class="headerlink" title="SSL 协议概述"></a>SSL 协议概述</h3><ul><li>发展历程:<ul><li>保护基于 WEB 的通信.</li><li>服务器认证.</li><li>客户认证 (可选).</li><li>SSL 链路上的数据完整性和保密性.</li></ul></li><li>设计目标:<ul><li>工作在 TCP 协议上 (不支持 UDP), 保护正常运行于 TCP 上的任何应用层协议 (HTTP、FTP、SMTP、Telnet 能透明建立于 SSL 上).</li><li>在应用层协议传输前, SSL 协议完成客户端和服务器的身份认证、加密算法和密钥协商, 建立一条安全可信的通信信道.</li><li>应用层协议传送的数据会被加密, 在传输过程中不被修改, 是最安全的在线交易模式, 广泛用于互联网财务等敏感信息处理.</li></ul></li><li>安全保护:<ul><li>机密性保护:<ul><li>SSL 客户机和服务器传送数据经过了加密处理.</li></ul></li><li>完整性保护:<ul><li>利用消息认证技术保证信息完整性, 避免信息受到破坏.</li></ul></li><li>认证保护:<ul><li>利用证书和可信第三方认证, 客户机和服务器相互认证对方身份.</li><li>证书持有者在握手时交换数字证书, 验证证书保证对方身份合法性.</li></ul></li></ul></li><li>使用步骤:<ul><li>用户: 浏览器输入.</li><li>HTTP 层: 将用户需求翻译成 HTTP 请求.</li><li>SSL 层: 借助下层协议信道安全地协商加密密钥, 加密 HTTP 请求.</li><li>TCP 层: 与 Web Server 443 端口连接, 传递 SSL 处理后的数据.</li><li>SSL 在 TCP 上建立了加密通道, 通过这层的数据经过加密.</li></ul></li></ul><h3 id="SSL-体系结构"><a href="#SSL-体系结构" class="headerlink" title="SSL 体系结构"></a>SSL 体系结构</h3><ul><li>两个实体:<ul><li>客户机/服务器.</li><li>基于证书在客户机和服务器间完成身份认证.</li></ul></li><li>两个概念:<ul><li>会话 Session:<ul><li>客户端和服务器之间的一个关联, 即虚拟连接关系.</li><li>通过握手协议建立, 协商密码算法、主密钥等.</li><li>一个会话协商可由多个连接共享.</li></ul></li><li>连接 Connection:<ul><li>一个特定的通信信道, 常映射成一个 TCP 连接.</li><li>一般短暂, 如 HTTPS 一次访问可能需要多个连接, 共享同一会话协商的密码算法、主密钥.</li></ul></li></ul></li><li>SSL 协议:<ul><li>握手协议: 数据传输前进行身份认证, 协商算法、密钥、初始向量等.</li><li>记录协议: 定义传输格式, 为高层协议提供数据封装、压缩、加密基本功能, 安全通信.</li><li>告警协议.</li><li>修改密码规约协议.</li></ul></li></ul><h3 id="SSL-记录协议"><a href="#SSL-记录协议" class="headerlink" title="SSL 记录协议"></a>SSL 记录协议</h3><ul><li><p>安全服务:</p><ul><li>保密性:<ul><li>用握手协议定义的共享密钥, 用传统密钥算法加密 SSL 载荷.</li></ul></li><li>报文完整性:<ul><li>用握手协议定义的共享密钥计算报文认证码 MAC.</li></ul></li></ul></li><li><p>操作过程:</p><ul><li>分段.</li><li>压缩 (可选): 不能丢失信息.</li><li>增加 MAC: 使用共享密钥.</li><li>加密: 对称加密算法.</li><li>增加首部.</li></ul></li><li><p>形成 SSL 记录协议数据单元.</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301710228.png" alt=""></p></li></ul><h3 id="SSL-握手协议"><a href="#SSL-握手协议" class="headerlink" title="SSL 握手协议"></a>SSL 握手协议</h3><ul><li><p>在传递应用数据之前使用.</p></li><li><p>安全服务: 认证、密钥和算法协商.</p><ul><li>握手协议允许 Client 和 Server 相互认证.<ul><li>Server 身份认证在 Client 身份认证之前.</li><li>Client 身份认证可选.</li></ul></li><li>协商加密算法和 MAC 算法.</li><li>协商主会话密钥 (Master Secret).</li><li>保护数据使用密钥通过 SSL 记录传送.</li></ul></li><li><p>消息类型: 10 种报文.</p></li><li><p>四个阶段:</p><ul><li><p>建立安全能力:</p><ul><li><p>client_hello/server_hello 报文: 包括 Version, Random, session id, cipher suite, compression method.</p></li><li><p>cipher suite: 包括</p><ul><li>密钥交换方法 (RSA, Diffie-Hellman, Fortezza).</li><li>加密算法 (RC4, RC2, DES, 3DES, IDEA, Fortezza).</li><li><p>MAC 算法 (MD5, SHA-1).</p><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301710229.png" alt=""></p></li></ul></li></ul></li><li><p>服务器认证和密钥交换:</p><ul><li><p>服务器发送 SSL 数字证书 Certificate.</p></li><li><p>(*) 如果服务器使用 SSL 3.0, 需要客户端提交数字证书, 发出 certificate_request 报文.</p></li><li><p>根据密钥交换算法:</p><ul><li>匿名 DH 算法, 不需要服务器发送证书, 但难防止中间人攻击.</li><li>DH 算法/RSA 算法, 发送 server_key_exchange, 交换密钥.</li></ul></li><li><p>服务器发送 sever_hello_done, 等待客户端响应.</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301710230.png" alt=""></p></li></ul></li><li><p>客户认证和密钥交换:</p><ul><li><p>客户端验证服务器证书是否有效.</p></li><li><p>(*) 如果收到 certificate-request, 则发送 SSL 数字证书 Certificate, 同时发出签有客户端专用密钥的 certificate_verify, 服务器验证此消息签名, 可以验证客户端数字证书所有权; 否则发送 no_certificate alert, 服务器应用程序使会话失败.</p></li><li><p>客户端发送 client_key_exchange, 含 pre_master_secret 和消息认证码密钥, 后续阶段用来计算 master_secret.</p></li><li><p>主密钥 master_secret 不直接用于数据加密和认证, 而是产生连接所需的一系列密钥.</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301710231.png" alt=""></p></li></ul></li><li><p>结束:</p><ul><li><p>客户端将 pre_master_secret 转为 master_secret, 派生所有密钥.</p></li><li><p>客户端发出 change_cipher_spec, 服务器转换为新协商密码对.</p></li><li><p>客户发送 finished, 验证密钥交换认证过程是否成功.</p></li><li><p>服务器发送 change_cipher_spec, 挂起状态迁移到当前 cipher_spec, 发送结束报文.</p></li><li><p>握手完成, 可以交换应用层数据.</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301710232.png" alt=""></p></li></ul></li></ul></li></ul><h3 id="SSL-告警协议"><a href="#SSL-告警协议" class="headerlink" title="SSL 告警协议"></a>SSL 告警协议</h3><ul><li>功能:<ul><li>向对等实体传递 SSL 相关警报, 告警消息按当前状态压缩和加密.</li></ul></li><li>Level 字节:<ul><li>值 1 表示告警.</li><li>值 2 表示致命错误.<ul><li>SSL 立即中止连接.</li><li>会话中其它连接继续进行.</li><li>不会在此会话中建立新连接.</li></ul></li></ul></li></ul><h3 id="SSL-修改密码规约协议"><a href="#SSL-修改密码规约协议" class="headerlink" title="SSL 修改密码规约协议"></a>SSL 修改密码规约协议</h3><ul><li>功能:<ul><li>握手协议结束阶段发送, 通知接收方使用协商的密码算法和密钥.</li><li>接收方将会话的挂起状态复制到当前状态, 以后连接使用这些密码参数.</li></ul></li></ul><h3 id="SSL-安全性分析"><a href="#SSL-安全性分析" class="headerlink" title="SSL 安全性分析"></a>SSL 安全性分析</h3><ul><li>逻辑严密性, 完整性, 正确性:<ul><li>每次安全连接产生一个 128 位长的随机连接序号, 防范重放攻击.</li><li>几乎所有 Web 服务器及浏览器支持 SSL 协议, 开发成本小.</li></ul></li><li>保密性:<ul><li>SSL 协议的数据安全性建立在 RSA 等算法安全性上.</li></ul></li><li>认证性:<ul><li>SSL 对应用层不透明, 只能提供交易中客户与服务器的双方认证, 涉及多方电子交易中不能协调安全传输和信任关系.</li></ul></li></ul><h2 id="应用层安全协议-HTTPS"><a href="#应用层安全协议-HTTPS" class="headerlink" title="应用层安全协议 HTTPS"></a>应用层安全协议 HTTPS</h2><h3 id="WEB-及其安全威胁"><a href="#WEB-及其安全威胁" class="headerlink" title="WEB 及其安全威胁"></a>WEB 及其安全威胁</h3><ul><li>Web 技术:<ul><li>平台独立, 系统分布.</li><li>第一个网页服务器和 Web 浏览器——WWW.</li><li>基础技术:<ul><li>HTML: 编写文档的超文本标记语言.</li><li>HTTP: 发布资源的超文本传输协议.</li><li>URL: 通过互联网引用其他可访问文档或资源的统一资源定位.</li></ul></li><li>WWW 使人们进入了网络时代.</li><li>WWW 技术是运行在互联网和 TCP/IP 上的一个客户/服务器程序.</li></ul></li><li>Web 安全威胁:<ul><li>威胁方式:<ul><li>主动攻击: 伪装成其它用户, 篡改消息或 Web 站点信息.</li><li>被动攻击: 在浏览器和服务器通信窃听, 获得限制使用的权限.</li></ul></li><li>威胁位置:<ul><li>Web 服务器安全.</li><li>Web 客户端安全.</li><li>服务器和客户端间的通信安全.</li></ul></li></ul></li><li>Web 流量安全方法:<ul><li>IP 级安全:<ul><li>IPSec 对终端用户和应用透明, 提供通用解决方案, 具有过滤功能.</li></ul></li><li>TCP 级安全:<ul><li>SSL 或 TLS 作为下层协议, 可对应用透明, 也可在特定包中使用.</li></ul></li><li>应用级安全:<ul><li>为应用定制安全协议, 典型应用是安全电子交易 SET.</li></ul></li></ul></li></ul><h3 id="针对-HTTP-的攻击"><a href="#针对-HTTP-的攻击" class="headerlink" title="针对 HTTP 的攻击"></a>针对 HTTP 的攻击</h3><ul><li>HTTP 的缺陷:<ul><li>明文传输, 没有数据完整性校验.</li><li>无状态连接, 无法验证双方身份.</li></ul></li><li>HTTP 攻击:<ul><li>监听嗅探:<ul><li>HTTP 采用明文信息传输, 可以被直接嗅探.</li></ul></li><li>篡改劫持:<ul><li>攻击者修改通信数据包, 篡改信息和劫持会话.</li></ul></li><li>伪造服务器:<ul><li>HTTP 不验证服务器可信度, 存在 ARP、DNS 欺骗及钓鱼风险.</li></ul></li></ul></li><li>ARP 欺骗:<ul><li>攻击者制造伪造的 ARP frame.</li><li>修改网内任何计算机的映射表.</li><li>切断目标主机的网络通讯, 窃取关键信息.</li><li>本机网卡可以抓取到被攻击者 HTTP 请求, 获取明文密码等敏感信息.</li></ul></li></ul><h3 id="HTTPS-HTTP-SSL"><a href="#HTTPS-HTTP-SSL" class="headerlink" title="HTTPS = HTTP + SSL"></a>HTTPS = HTTP + SSL</h3><ul><li>HTTPS 是协议的合并, 解决了数据加密、完整性校验、服务器身份认证等问题.<ul><li>HTTP 协议是简单的无状态连接.</li><li>HTTPS 协议是可进行加密传输、身份认证的连接.</li></ul></li><li>ARP 欺骗/报文篡改/服务器认证/证书替换/会话劫持.</li><li>HTTPS 无法避免 ARP 欺骗和嗅探攻击, 但 SSL 加密传输, 无法得到明文信息.</li><li>HTTPS 内容不压缩也是无法识别的密文, 攻击者无法进行报文篡改.</li><li>HTTPS 的加密证书在证书管理机构申请后发放, 拥有证书的单位不可被仿冒.<ul><li>HTTP 无法验证服务器身份, 某些浏览器的网站身份验证基于网站域名的, 遇到 DNS 劫持/欺骗时无法抵抗.</li></ul></li><li>HTTPS 通过钓鱼 WIFI 或恶意代理访问网站, 服务器证书可能被替换, 浏览器用红色表示地址栏并提示证书不受信任.</li><li>HTTPS 通信不全基于 HTTPS 协议, 百度只在登录采用 HTTPS 传输用户信息.</li></ul><h3 id="SSL-能否确保-HTTPS-安全"><a href="#SSL-能否确保-HTTPS-安全" class="headerlink" title="SSL 能否确保 HTTPS 安全"></a>SSL 能否确保 HTTPS 安全</h3><ul><li>SSLStrip 是专门针对 HTTPS 的攻击.</li></ul>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;六、SSL-及-HTTPS&quot;&gt;&lt;a href=&quot;#六、SSL-及-HTTPS&quot; class=&quot;headerlink&quot; title=&quot;六、SSL 及 HTTPS&quot;&gt;&lt;/a&gt;六、SSL 及 HTTPS&lt;/h1&gt;&lt;h2 id=&quot;传输层安全协议-SSL&quot;&gt;&lt;a</summary>
        
      
    
    
    
    <category term="CS" scheme="http://chengsx21.github.io/categories/CS/"/>
    
    <category term="Network Security" scheme="http://chengsx21.github.io/categories/CS/Network-Security/"/>
    
    
    <category term="Network Security" scheme="http://chengsx21.github.io/tags/Network-Security/"/>
    
  </entry>
  
  <entry>
    <title>编译原理 实验4</title>
    <link href="http://chengsx21.github.io/2023/11/26/bian-yi-yuan-li-lab-4/"/>
    <id>http://chengsx21.github.io/2023/11/26/bian-yi-yuan-li-lab-4/</id>
    <published>2023-11-26T09:18:57.000Z</published>
    <updated>2024-06-30T09:52:55.513Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Stage-4-报告"><a href="#Stage-4-报告" class="headerlink" title="Stage 4 报告"></a>Stage 4 报告</h1><h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><h3 id="step-7"><a href="#step-7" class="headerlink" title="step 7"></a>step 7</h3><p><strong>语义分析</strong>: 直接全部访问 <code>ConditionExpression</code> 的子节点即可.</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># frontend/typecheck/namer.py</span><span class="token keyword">def</span> <span class="token function">visitCondExpr</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> expr<span class="token punctuation">:</span> ConditionExpression<span class="token punctuation">,</span> ctx<span class="token punctuation">:</span> ScopeStack<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>    expr<span class="token punctuation">.</span>cond<span class="token punctuation">.</span>accept<span class="token punctuation">(</span>self<span class="token punctuation">,</span> ctx<span class="token punctuation">)</span>    expr<span class="token punctuation">.</span>then<span class="token punctuation">.</span>accept<span class="token punctuation">(</span>self<span class="token punctuation">,</span> ctx<span class="token punctuation">)</span>    expr<span class="token punctuation">.</span>otherwise<span class="token punctuation">.</span>accept<span class="token punctuation">(</span>self<span class="token punctuation">,</span> ctx<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>中间代码生成</strong>: 直接参考对 <code>if</code> 语句的实现, 由于 <code>ConditionExpression</code> 需要返回值, 在 <code>mv.visitCondBranch</code> 结束后, 使用 <code>expr.cond.getattr("val")</code> 储存该表达式的值 (这也是与 <code>visitIf</code> 的不同点).</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># frontend/tacgen/tacgen.py</span><span class="token keyword">def</span> <span class="token function">visitCondExpr</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> expr<span class="token punctuation">:</span> ConditionExpression<span class="token punctuation">,</span> mv<span class="token punctuation">:</span> TACFuncEmitter<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>    expr<span class="token punctuation">.</span>cond<span class="token punctuation">.</span>accept<span class="token punctuation">(</span>self<span class="token punctuation">,</span> mv<span class="token punctuation">)</span>    skipLabel <span class="token operator">=</span> mv<span class="token punctuation">.</span>freshLabel<span class="token punctuation">(</span><span class="token punctuation">)</span>    exitLabel <span class="token operator">=</span> mv<span class="token punctuation">.</span>freshLabel<span class="token punctuation">(</span><span class="token punctuation">)</span>    exprVal <span class="token operator">=</span> expr<span class="token punctuation">.</span>cond<span class="token punctuation">.</span><span class="token builtin">getattr</span><span class="token punctuation">(</span><span class="token string">"val"</span><span class="token punctuation">)</span>    mv<span class="token punctuation">.</span>visitCondBranch<span class="token punctuation">(</span>        tacop<span class="token punctuation">.</span>CondBranchOp<span class="token punctuation">.</span>BEQ<span class="token punctuation">,</span> exprVal<span class="token punctuation">,</span> skipLabel    <span class="token punctuation">)</span>    expr<span class="token punctuation">.</span>then<span class="token punctuation">.</span>accept<span class="token punctuation">(</span>self<span class="token punctuation">,</span> mv<span class="token punctuation">)</span>    mv<span class="token punctuation">.</span>visitAssignment<span class="token punctuation">(</span>exprVal<span class="token punctuation">,</span> expr<span class="token punctuation">.</span>then<span class="token punctuation">.</span><span class="token builtin">getattr</span><span class="token punctuation">(</span><span class="token string">"val"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment"># Here!</span>    mv<span class="token punctuation">.</span>visitBranch<span class="token punctuation">(</span>exitLabel<span class="token punctuation">)</span>    mv<span class="token punctuation">.</span>visitLabel<span class="token punctuation">(</span>skipLabel<span class="token punctuation">)</span>    expr<span class="token punctuation">.</span>otherwise<span class="token punctuation">.</span>accept<span class="token punctuation">(</span>self<span class="token punctuation">,</span> mv<span class="token punctuation">)</span>    mv<span class="token punctuation">.</span>visitAssignment<span class="token punctuation">(</span>exprVal<span class="token punctuation">,</span> expr<span class="token punctuation">.</span>otherwise<span class="token punctuation">.</span><span class="token builtin">getattr</span><span class="token punctuation">(</span><span class="token string">"val"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment"># Here!</span>    mv<span class="token punctuation">.</span>visitLabel<span class="token punctuation">(</span>exitLabel<span class="token punctuation">)</span>    expr<span class="token punctuation">.</span><span class="token builtin">setattr</span><span class="token punctuation">(</span><span class="token string">"val"</span><span class="token punctuation">,</span> exprVal<span class="token punctuation">)</span> <span class="token comment"># Here!</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="step-8"><a href="#step-8" class="headerlink" title="step 8"></a>step 8</h3><p>这一部分需要实现 <code>For</code> 与 <code>Continue</code> 语句.</p><p><strong>词法&amp;语法分析</strong>: 在 <code>frontend/lexer/lex.py</code> 添加 <code>For</code> 与 <code>Continue</code> 的关键字类型, 在 <code>frontend/ast/tree.py</code> 和 <code>frontend/ast/visitor.py</code> 实现 AST 节点及访问函数.</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># frontend/ast/tree.py</span><span class="token keyword">class</span> <span class="token class-name">For</span><span class="token punctuation">(</span>Statement<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>        self<span class="token punctuation">,</span>      init<span class="token punctuation">:</span> Expression<span class="token punctuation">,</span>      cond<span class="token punctuation">:</span> Expression<span class="token punctuation">,</span>      update<span class="token punctuation">:</span> Expression<span class="token punctuation">,</span>      body<span class="token punctuation">:</span> Statement    <span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>        <span class="token builtin">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token string">"for"</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>init <span class="token operator">=</span> init        self<span class="token punctuation">.</span>cond <span class="token operator">=</span> cond        self<span class="token punctuation">.</span>update <span class="token operator">=</span> update        self<span class="token punctuation">.</span>body <span class="token operator">=</span> body<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">class</span> <span class="token class-name">Continue</span><span class="token punctuation">(</span>Statement<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>        <span class="token builtin">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token string">"continue"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中 <code>For</code> 节点的成员可能为空, 但为了语法分析的简便, 没有使用 <code>Optional</code> 进行定义. 为消除可能带来的隐患, 只需在<strong>中间代码生成</strong>中添加相应检查即可. 定义上下文无关文法, 注意 <code>init</code> 成员可能为 <code>Declaration</code> 或 <code>Expression</code>.</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># frontend/parser/ply_parser.py</span><span class="token keyword">def</span> <span class="token function">p_for</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""    statement_matched : For LParen init_expression Semi opt_expression Semi opt_expression RParen statement_matched    statement_unmatched : For LParen init_expression Semi opt_expression Semi opt_expression RParen statement_unmatched    """</span>    p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> For<span class="token punctuation">(</span>p<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> p<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span> p<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">,</span> p<span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">p_for_init</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""    init_expression : opt_expression    init_expression : declaration    """</span>    p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> p<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>语义分析</strong>: 在 <code>ScopeStack</code> 数据结构中增加维护当前 <code>loop</code> 的层数.</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># frontend/scope/scopestack.py</span><span class="token keyword">class</span> <span class="token class-name">ScopeStack</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> globalScope<span class="token punctuation">:</span> Scope<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        self<span class="token punctuation">.</span>loopCount <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">def</span> <span class="token function">enterLoop</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>loopCount <span class="token operator">+=</span> <span class="token number">1</span>    <span class="token keyword">def</span> <span class="token function">exitLoop</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>loopCount <span class="token operator">-=</span> <span class="token number">1</span>    <span class="token keyword">def</span> <span class="token function">insideLoop</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>loopCount<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为 <code>For</code> 和 <code>While</code> 循环添加 <code>loop</code> 层数信息, 同时在进入 <code>For</code> 循环体时打开一个新的 <code>scope</code>.</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># frontend/typecheck/namer.py</span><span class="token keyword">def</span> <span class="token function">visitFor</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> stmt<span class="token punctuation">:</span> For<span class="token punctuation">,</span> ctx<span class="token punctuation">:</span> ScopeStack<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>    ctx<span class="token punctuation">.</span><span class="token builtin">open</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    stmt<span class="token punctuation">.</span>init<span class="token punctuation">.</span>accept<span class="token punctuation">(</span>self<span class="token punctuation">,</span> ctx<span class="token punctuation">)</span>    stmt<span class="token punctuation">.</span>cond<span class="token punctuation">.</span>accept<span class="token punctuation">(</span>self<span class="token punctuation">,</span> ctx<span class="token punctuation">)</span>    stmt<span class="token punctuation">.</span>update<span class="token punctuation">.</span>accept<span class="token punctuation">(</span>self<span class="token punctuation">,</span> ctx<span class="token punctuation">)</span>    ctx<span class="token punctuation">.</span>enterLoop<span class="token punctuation">(</span><span class="token punctuation">)</span>    stmt<span class="token punctuation">.</span>body<span class="token punctuation">.</span>accept<span class="token punctuation">(</span>self<span class="token punctuation">,</span> ctx<span class="token punctuation">)</span>    ctx<span class="token punctuation">.</span>exitLoop<span class="token punctuation">(</span><span class="token punctuation">)</span>    ctx<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">visitWhile</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> stmt<span class="token punctuation">:</span> While<span class="token punctuation">,</span> ctx<span class="token punctuation">:</span> ScopeStack<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>    stmt<span class="token punctuation">.</span>cond<span class="token punctuation">.</span>accept<span class="token punctuation">(</span>self<span class="token punctuation">,</span> ctx<span class="token punctuation">)</span>    ctx<span class="token punctuation">.</span>enterLoop<span class="token punctuation">(</span><span class="token punctuation">)</span>    stmt<span class="token punctuation">.</span>body<span class="token punctuation">.</span>accept<span class="token punctuation">(</span>self<span class="token punctuation">,</span> ctx<span class="token punctuation">)</span>    ctx<span class="token punctuation">.</span>exitLoop<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">visitBreak</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> stmt<span class="token punctuation">:</span> Break<span class="token punctuation">,</span> ctx<span class="token punctuation">:</span> ScopeStack<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> <span class="token keyword">not</span> ctx<span class="token punctuation">.</span>insideLoop<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">raise</span> DecafBreakOutsideLoopError<span class="token punctuation">(</span><span class="token punctuation">)</span>    ctx<span class="token punctuation">.</span>exitLoop<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">visitContinue</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> stmt<span class="token punctuation">:</span> Continue<span class="token punctuation">,</span> ctx<span class="token punctuation">:</span> ScopeStack<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> <span class="token keyword">not</span> ctx<span class="token punctuation">.</span>insideLoop<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">raise</span> DecafContinueOutsideLoopError<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>中间代码生成</strong>: 参考 <code>visitWhile</code> 实现了 <code>visitFor</code>, 参考 <code>visitBreak</code> 实现了 <code>visitContinue</code>. <code>For</code> 循环的控制流参考了<a href="https://decaf-lang.github.io/minidecaf-tutorial/docs/step8/example.html#%E4%B8%AD%E9%97%B4%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90">这里</a>给出的 TAC 码, 需要注意由于我们在 AST 节点实现中挖的坑, <code>stmt.cond</code> 可能为 <code>NULL</code>, 需要以此为依据判定是否添加 <code>BEQ</code> 指令跳转 (虽然测例里都是完整的 <code>for</code> 循环, 不会出现这个问题).</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># frontend/tacgen/tacgen.py</span><span class="token keyword">def</span> <span class="token function">visitFor</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> stmt<span class="token punctuation">:</span> For<span class="token punctuation">,</span> mv<span class="token punctuation">:</span> TACFuncEmitter<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>    beginLabel <span class="token operator">=</span> mv<span class="token punctuation">.</span>freshLabel<span class="token punctuation">(</span><span class="token punctuation">)</span>    loopLabel <span class="token operator">=</span> mv<span class="token punctuation">.</span>freshLabel<span class="token punctuation">(</span><span class="token punctuation">)</span>    breakLabel <span class="token operator">=</span> mv<span class="token punctuation">.</span>freshLabel<span class="token punctuation">(</span><span class="token punctuation">)</span>    mv<span class="token punctuation">.</span>openLoop<span class="token punctuation">(</span>breakLabel<span class="token punctuation">,</span> loopLabel<span class="token punctuation">)</span>    stmt<span class="token punctuation">.</span>init<span class="token punctuation">.</span>accept<span class="token punctuation">(</span>self<span class="token punctuation">,</span> mv<span class="token punctuation">)</span>    mv<span class="token punctuation">.</span>visitLabel<span class="token punctuation">(</span>beginLabel<span class="token punctuation">)</span>    <span class="token keyword">if</span> stmt<span class="token punctuation">.</span>cond<span class="token punctuation">:</span>        stmt<span class="token punctuation">.</span>cond<span class="token punctuation">.</span>accept<span class="token punctuation">(</span>self<span class="token punctuation">,</span> mv<span class="token punctuation">)</span>        mv<span class="token punctuation">.</span>visitCondBranch<span class="token punctuation">(</span>tacop<span class="token punctuation">.</span>CondBranchOp<span class="token punctuation">.</span>BEQ<span class="token punctuation">,</span> stmt<span class="token punctuation">.</span>cond<span class="token punctuation">.</span><span class="token builtin">getattr</span><span class="token punctuation">(</span><span class="token string">"val"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> breakLabel<span class="token punctuation">)</span>    stmt<span class="token punctuation">.</span>body<span class="token punctuation">.</span>accept<span class="token punctuation">(</span>self<span class="token punctuation">,</span> mv<span class="token punctuation">)</span>    mv<span class="token punctuation">.</span>visitLabel<span class="token punctuation">(</span>loopLabel<span class="token punctuation">)</span>    stmt<span class="token punctuation">.</span>update<span class="token punctuation">.</span>accept<span class="token punctuation">(</span>self<span class="token punctuation">,</span> mv<span class="token punctuation">)</span>    mv<span class="token punctuation">.</span>visitBranch<span class="token punctuation">(</span>beginLabel<span class="token punctuation">)</span>    mv<span class="token punctuation">.</span>visitLabel<span class="token punctuation">(</span>breakLabel<span class="token punctuation">)</span>    mv<span class="token punctuation">.</span>closeLoop<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><h3 id="step-7-1"><a href="#step-7-1" class="headerlink" title="step 7"></a>step 7</h3><ol><li><p>你使用语言的框架里是如何处理悬吊 else 问题的? 请简要描述.</p><p> <strong>答:</strong> <code>statement</code> 有 <code>statement_matched</code> 代表 <code>if</code> 与 <code>else</code> 匹配, 以及 <code>statement_unmatched</code> 代表仅有 <code>if</code>.</p><p> 若出现 <code>if</code>, <code>else</code> 匹配, 其之间一定是 <code>statement_matched</code> 的匹配类型, 这使得后续的悬吊 <code>else</code> 只能与同层的 <code>if</code> 结合, 构成 <code>statement_matched</code> 后, 这就是 <code>else</code> 与一个最近未匹配 <code>if</code> 的匹配.</p></li><li><p>在实验要求的语义规范中, 条件表达式存在短路现象. 即:</p> <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token punctuation">(</span>a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> a<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 会返回 0 而不是 2. 如果要求条件表达式不短路, 在你的实现中该做何种修改? 简述你的思路.</p><p> <strong>答:</strong> 修改 <code>frontend/tacgen/tacgen.py:visitCondExpr</code>, 将 <code>expr.then.accept(self, mv)</code>, <code>expr.otherwise.accept(self, mv)</code> 均提至函数首部即可, 这样条件表达式必定会访问 <code>then</code> 及 <code>otherwise</code>, 从而避免短路.</p></li></ol><h3 id="step-8-1"><a href="#step-8-1" class="headerlink" title="step 8"></a>step 8</h3><ol><li><p>将循环语句翻译成 IR 有许多可行的翻译方法, 例如 <code>while</code> 循环可以有以下两种翻译方式:</p><p> 第一种 (即实验指导中的翻译方式):</p><ul><li><code>label BEGINLOOP_LABEL</code>: 开始下一轮迭代</li><li><code>cond 的 IR</code></li><li><code>beqz BREAK_LABEL</code>: 条件不满足就终止循环</li><li><code>body 的 IR</code></li><li><code>label CONTINUE_LABEL</code>: continue 跳到这</li><li><code>br BEGINLOOP_LABEL</code>: 本轮迭代完成</li><li><p><code>label BREAK_LABEL</code>: 条件不满足，或者 break 语句都会跳到这儿</p><p>第二种:</p></li><li><p><code>cond 的 IR</code></p></li><li><code>beqz BREAK_LABEL</code>: 条件不满足就终止循环</li><li><code>label BEGINLOOP_LABEL</code>: 开始下一轮迭代</li><li><code>body 的 IR</code></li><li><code>label CONTINUE_LABEL</code>: continue 跳到这</li><li><code>cond 的 IR</code></li><li><code>bnez BEGINLOOP_LABEL</code>: 本轮迭代完成，条件满足时进行下一次迭代</li><li><p><code>label BREAK_LABEL</code>: 条件不满足，或者 break 语句都会跳到这儿</p><p>从执行的指令的条数这个角度 (<code>label</code> 不算做指令, 假设循环体至少执行了一次), 请评价这两种翻译方式哪一种更好?</p><p><strong>答:</strong> <strong>第二种</strong>翻译方式更好. 假设循环执行到不满足 <code>cond</code> 结束, 第一种翻译每个循环需要执行 <code>body</code>, <code>cond</code> 以及两次跳转, 而第二种翻译除了首次进入循环需要判定 <code>cond</code>, 其余每个循环只需执行一次跳转. 就普遍意义而言, 第二种翻译方式生成的程序比第一种每个循环少执行一次跳转, 这种翻译方式更好.</p></li></ul></li><li><p>我们目前的 TAC IR 中条件分支指令采用了单分支目标 (标签) 的设计, 即该指令的操作数中只有一个是标签; 如果相应的分支条件不满足, 则执行流会继续向下执行. 在其它 IR 中存在双目标分支 (标签) 的条件分支指令, 其形式如下:</p> <pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">br cond, false_target, true_target<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> 其中 <code>cond</code> 是一个临时变量, <code>false_target</code> 和 <code>true_target</code> 是标签. 其语义为: 如果 <code>cond</code> 的值为 0 (假), 则跳转到 <code>false_target</code> 处; 若 <code>cond</code> 非 0 (真), 则跳转到 <code>true_target</code> 处. 它与我们的条件分支指令的区别在于执行流总是会跳转到两个标签中的一个. 你认为中间表示的哪种条件分支指令设计 (单目标 vs 双目标)更合理? 为什么?</p><p> <strong>答:</strong> 我认为选择 “双目标分支” 更合理:</p><ul><li>双目标分支指令更加灵活, 符合编程语言的控制流结构, 允许根据条件跳转到两个不同位置, 在实现 <code>if-elif-else</code> 等结构会更方便.</li><li>双目标分支指令含义直观, 容易理解和调试, 能够提高代码的可读性和维护性.</li></ul></li></ol>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;Stage-4-报告&quot;&gt;&lt;a href=&quot;#Stage-4-报告&quot; class=&quot;headerlink&quot; title=&quot;Stage 4 报告&quot;&gt;&lt;/a&gt;Stage 4 报告&lt;/h1&gt;&lt;h2 id=&quot;实验内容&quot;&gt;&lt;a href=&quot;#实验内容&quot;</summary>
        
      
    
    
    
    <category term="CS" scheme="http://chengsx21.github.io/categories/CS/"/>
    
    <category term="Compiler" scheme="http://chengsx21.github.io/categories/CS/Compiler/"/>
    
    
    <category term="Compiler" scheme="http://chengsx21.github.io/tags/Compiler/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成原理 笔记7</title>
    <link href="http://chengsx21.github.io/2023/11/16/ji-suan-ji-zu-cheng-yuan-li-bi-ji-7/"/>
    <id>http://chengsx21.github.io/2023/11/16/ji-suan-ji-zu-cheng-yuan-li-bi-ji-7/</id>
    <published>2023-11-16T09:18:57.000Z</published>
    <updated>2024-06-30T09:53:39.681Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Exception"><a href="#Exception" class="headerlink" title="Exception"></a>Exception</h1><h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><ol><li><p>在支持中断异常的监控程序当中一共涉及几个内核态? 监控程序工作在什么内核态上? 什么时候会进入用户态 (U 态)?</p><p> <strong>答:</strong> 1 个; M 态; 在 <code>shell.S</code> 中执行 G 命令进入 <code>.ENTER_UESR</code> 执行 <code>mret</code>.</p></li><li><p>观察监控程序中 CSR 寄存器的变化. 监控程序在执行 G 命令执行用户程序时, 是如何切换内核态, 并跳转到对应位置的?</p><p> <strong>答:</strong> 设置 mepc, mpp, 执行 <code>mret</code> 指令跳转到对应位置.</p></li><li><p>用户程序执行 ecall 指令之后会发生什么?</p><p> <strong>答:</strong> 引发异常, 进入 M 态 <code>EXCEPTION_HANDLER</code>, 执行 <code>.HANDLE_ECALL</code> 代码段.</p></li><li><p>考虑中断处理. 监控程序的异常处理函数中严格过滤掉了在 M 态发生的时钟中断. 如何在异常处理函数中判断当前处理的异常发生在什么态? 来自 M 态的时钟中断会发生吗?</p><p> <strong>答:</strong> 读取 mstatus.mpp, 判断当前状态; 不会被发生和处理.</p></li><li><p>中断发生的具体条件是什么? 监控程序中发生的中断类型是?</p><p> <strong>答:</strong> mie 和 mip 相应位置 1; 时钟中断.</p></li><li><p>用户程序在执行完成后 (执行 <code>jr ra</code> 指令回到监控程序后) 会发生什么?</p><p> <strong>答:</strong> 跳转到 <code>.USERRET_USER</code>.</p></li><li><p>如何判断 CPU 当前运行在什么内核态? 这个信息有暴露给软件吗?</p><p> <strong>答:</strong> 在 CPU 内部每个流水阶段传递内核态信息; 没有, 软件只有在处理异常时可以获取发生异常时 CPU 的状态.</p></li><li><p>如何读写 mtime 和 mtimecmp 寄存器 (与串口的状态和数据寄存器进行类比)?</p><p> <strong>答:</strong> 在 mem_master 中重定向时钟寄存器地址, 增加单独的读写逻辑.</p></li><li><p>监控程序在处理 mtvec 寄存器时使用了复杂的逻辑. 结合 Privileged 2.3 节解释其原因, 并理解什么是 WARL.</p><p> <strong>答:</strong> mtvec 寄存器用于定义异常处理程序的基地址, RISC-V 允许两种异常处理模式: 直接模式和向量模式, 通过 mtvec 寄存器的最低位来设置; WARL 属性意味着对于某些寄存器, 当写入一个地址时, 系统可能会进行某些内部调整或转换, 但读取时, 总是得到你写入的地址.</p></li></ol><h2 id="Exception-1"><a href="#Exception-1" class="headerlink" title="Exception"></a>Exception</h2><ul><li>处理器<strong>内部产生</strong>, 可能可恢复, 也可能无法恢复.</li><li>异常恢复后重新执行<strong>本条指令</strong>.</li><li><p>IF: 访存地址不对齐; 访存缺页.</p><ul><li>ID: 非法指令.</li></ul></li><li><p>EXE: 除 0 计算.</p></li><li><p>MEM: 访存地址不对齐; 访存缺页.</p></li><li><p>WB: 无.</p></li></ul><h2 id="Interruption"><a href="#Interruption" class="headerlink" title="Interruption"></a>Interruption</h2><ul><li>处理器<strong>外部产生</strong>, 可恢复执行.</li><li>中断处理后跳到<strong>下一条指令</strong>执行.</li><li>保存和恢复由软件和硬件一同进行. 通用寄存器由软件操作, 特殊寄存器 (包括 PC, cause, IE) 由硬件进行.</li><li>发生中断时, 硬件将 PC 设为<strong>中断处理函数入口地址</strong>, 入口地址可以使用固定常数 (MIPS), 硬件将其进行硬编码, 也可以写入特殊寄存器 (Risc-V), 由硬件进行设置. 中断处理函数可以有<strong>多个</strong>, 操作系统提供多个入口; 也可以有<strong>一个</strong>, 根据中断 cause 跳转到不同的地址, 如中断向量表.</li><li>将中断安排在 <strong>EXE 和 MEM 阶段之间</strong>, 等待前面指令执行完毕, 使用 bubble 信号排空后面的指令, 再进行中断异常处理, 称为<strong>精确的中断和异常</strong>.</li></ul><h2 id="Privileged-Mode"><a href="#Privileged-Mode" class="headerlink" title="Privileged Mode"></a>Privileged Mode</h2><ul><li>硬件隔离: 性能损失少; 软件隔离: 性能损失多.</li><li>mtvec, mepc, mcause 在异常处理中由硬件保存.</li><li>mie, mip, mtval, mscratch, mstatus.</li><li>内存隔离机制: 通知 CPU 内存地址范围及处理权限, 将 APP 与 OS 隔离.<ul><li>地址映射将 APP 与 APP 隔离;</li><li>限制用户程序不更改监控程序;</li><li>限制 MEM 段 load/store 指令的行为;</li><li>否则抛出异常 (X86: Segment; Risc-V: PMP).</li></ul></li><li>只有 mret 将 pc 设置为 mepc, 切换 M 模式为 U 模式. 可以通过将 mepc 设置为其他程序的运行入口, 实现<strong>操作系统调度器</strong>.</li><li>异常、中断、硬件控制 (外设) 由 M 模式进行, 例如发起系统调用时, U 模式会主动切换到 M 模式, 相当于主动触发异常.</li><li><strong>进入</strong>中断处理函数<strong>前</strong>, 硬件保存中断地址到 mepc, 中断原因到 mcause, 将地址置为 mtvec, 将 mstatus 中的中断使能 mie 保存到 mpie, mie 置 0, 将权限模式保存到 mpp; <strong>进入</strong>中断处理函数<strong>后</strong>, 软件保存 mepc, mcause 到 stack 上, 然后软件将 mie 置 1, 此时可以支持嵌套的中断和异常; <strong>离开</strong>中断处理函数<strong>前</strong>, 软件将 mie 置 0, 并恢复 mepc, mcause, 硬件将 mie 置 1.</li></ul>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;Exception&quot;&gt;&lt;a href=&quot;#Exception&quot; class=&quot;headerlink&quot; title=&quot;Exception&quot;&gt;&lt;/a&gt;Exception&lt;/h1&gt;&lt;h2 id=&quot;Q-amp-A&quot;&gt;&lt;a href=&quot;#Q-amp-A&quot;</summary>
        
      
    
    
    
    <category term="CS" scheme="http://chengsx21.github.io/categories/CS/"/>
    
    <category term="Organization &amp; Design" scheme="http://chengsx21.github.io/categories/CS/Organization-Design/"/>
    
    
    <category term="Organization &amp; Design" scheme="http://chengsx21.github.io/tags/Organization-Design/"/>
    
    <category term="SV" scheme="http://chengsx21.github.io/tags/SV/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络安全技术 笔记5</title>
    <link href="http://chengsx21.github.io/2023/11/15/ji-suan-ji-wang-luo-an-quan-ji-zhu-bi-ji-5/"/>
    <id>http://chengsx21.github.io/2023/11/15/ji-suan-ji-wang-luo-an-quan-ji-zhu-bi-ji-5/</id>
    <published>2023-11-15T09:18:57.000Z</published>
    <updated>2024-06-30T09:49:13.955Z</updated>
    
    <content type="html"><![CDATA[<h1 id="五、网络层安全协议-IPsec"><a href="#五、网络层安全协议-IPsec" class="headerlink" title="五、网络层安全协议 IPsec"></a>五、网络层安全协议 IPsec</h1><h2 id="IPsec-网络层安全协议"><a href="#IPsec-网络层安全协议" class="headerlink" title="IPsec: 网络层安全协议"></a>IPsec: 网络层安全协议</h2><ul><li>IP 协议的安全特性:<ul><li>无连接, 不保证顺序到达.</li><li>重复包, 丢失包.</li><li>设备简单, 无状态.</li><li>不提供认证, 完整性, 保密性.</li><li>访问控制基于 IP 地址, 不完备.</li></ul></li><li>IPsec 保障 IP 级安全:<ul><li>认证, 保密, 密钥管理.</li><li>在 IP 层加密(或)认证所有流量.</li><li>网络层实现端到端的安全性:<ul><li>数据源认证机制.</li><li>数据加密机制.</li><li>密钥管理.</li></ul></li></ul></li><li>IPsec 的应用:<ul><li>分支机构通过互联网虚拟专用网安全互联.</li><li>终端用户远程安全访问互联网.</li><li>与合作者建立外联网和内联网联系.</li><li>加强电子商务安全性.</li></ul></li><li>IPsec 的实施:<ul><li>主机实现 (与操作系统集成):<ul><li>保障端到端安全.</li><li>对用户每个会话提供安全保障.</li><li>对应用透明, 不必修改用户或服务器软件.</li><li>对最终用户透明.</li></ul></li><li>防火墙实施:<ul><li>无须改变操作系统.</li><li>为内部所有应用提供安全服务.</li></ul></li><li>路由器实施:<ul><li>虚拟专用网 VPN.</li><li>对通过公用网络的两个子网的流动数据提供安全保护.</li></ul></li></ul></li></ul><h3 id="IPsec-体系结构"><a href="#IPsec-体系结构" class="headerlink" title="IPsec 体系结构"></a>IPsec 体系结构</h3><h4 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h4><ul><li><p>包认证和包加密在主 IP 报头中使用扩展报头 AH/ESP 实现安全性.</p></li><li><p>IPv6 必须支持这些特性, IPv4 可选.</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301709258.png" alt=""></p></li><li><p>IPsec 文档:</p><ul><li>体系结构: IPsec 技术一般性概念、需求和机制.</li><li>认证头 AH: 扩展域, 提供数据源发认证和完整性保护.</li><li>封装安全载荷 ESP: 扩展域, 提供数据保密、源发认证和完整性保护.</li><li>加密算法: 描述 ESP 使用的加密算法.</li><li>认证算法: 描述 AH 使用的认证算法和 ESP 认证选项.</li><li>密钥管理: 描述密钥管理模式.</li><li>解释域 (DOI): 其他文档彼此联系需要的值, 包括算法标识及操作参数.</li></ul></li></ul><h4 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h4><ul><li><p>IPsec 安全服务:</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301709259.png" alt=""></p></li></ul><h4 id="安全关联"><a href="#安全关联" class="headerlink" title="安全关联"></a>安全关联</h4><ul><li><p>安全关联 SA 是 IPsec 通信双方对要素的协商, 是安全信息参数集合.</p><ul><li>包括协议、操作模式、密码算法、认证算法、密钥、生存期.</li><li>SA 是发送方和接收方的单向关系, 为双方通信提供安全服务.</li><li>双方安全交换需建立两个 SA.</li><li>安全服务可由 AH 或 ESP 提供, 但不能两者都提供.</li></ul></li><li><p>SA 确定参数:</p><ul><li>安全参数索引 SPI:<ul><li>和 SA 相关的位串, 仅在本地有意义.</li><li>由 AH 和 ESP 携带, 接收方能选择合适 SA 处理包.</li></ul></li><li>IP 目的地址 IPDA:<ul><li>单一地址, 表示 SA 目的地址.</li><li>用户末端系统、防火墙或路由器.</li></ul></li><li>安全协议标识:<ul><li>标识关联是 AH 或 ESP 安全关联.</li></ul></li></ul></li><li><p>SA 安全参数:</p><ul><li><p>序列号计数器 (must):</p><ul><li>32 位整数, 用于生成 AH 或 ESP 头序列号域.</li><li>SA 保护包时增 1, 溢出后 SA 重新协商.</li><li>防范重放攻击.</li></ul></li><li><p>序列号溢出标志 (must):</p><ul><li>值 1 时产生审查事件, 阻止该 SA 继续下发数据包.</li></ul></li><li><p>反重放窗口 (must):</p><ul><li><p>决定输入 AH 或 ESP 报文是否是重放的计数器.</p><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301709260.png" alt=""></p></li></ul></li><li><p>AH 信息组 (AH must):</p><ul><li>认证算法, 密钥, 密钥生存期和 AH 的相关参数.</li></ul></li><li><p>ESP 信息组 (ESP must):</p><ul><li>加密和认证算法, 密钥, 初始值, 密钥生存期和 ESP 的相关参数.</li></ul></li><li><p>SA 生存期.</p><ul><li>生存期结束, SA 终止或用新 SA 替换.</li></ul></li><li><p>IPsec 协议模式 (must):</p><ul><li>隧道模式或传输模式.</li></ul></li><li><p>Path MTU (must):</p><ul><li>最大传送单位路径和迟滞变量.</li></ul></li></ul></li><li><p>安全关联数据库 SADB: 定义 SA.</p><ul><li>IP 数据包中, SA 由 IPv4 或 IPv6 报头中目的地址唯一标识.</li><li>SPI 封装在 AH 或 ESP 扩展头中.</li><li>收到数据包, 解析三元组 [SPI - 目的地址 - AH/ESP], 并查找 SADB:<ul><li>匹配的条目: 将参数与 AH 或 ESP 头中相关域比较, 一致则处理该数据包, 不一致则丢弃.</li><li>没有匹配的条目: 输入包—丢弃; 输出包—创建新 SA, 存入 SADB.</li></ul></li><li>定义与 SA 关联的参数, 决定进行何种安全操作.</li></ul></li><li><p>选择子:</p><ul><li>大粒度区分需要和不需要 IPsec 保护的流量.</li><li>通过 SPDB 定义 IP 流量与特定 SA 相关.</li><li>SPDB 包括定义 IP 流量子集的入口, 指向该流量 SA 的指针.<ul><li>多个 SPDB 入口可与一个 SA 相连.</li><li>多个 SA 可与一个 SPDB 入口相连.</li></ul></li><li>每个 SPDB 入口由 IP 集合和上层协议定义，称为选择子.<ul><li>过滤输出流量, 并映射到特定 SA.<ul><li>SPDB 中比较相应域的值, 寻找匹配入口, 可能是零或多个.</li><li>存在 SA, 则选定 SA 和关联的 SPI 执行 IPsec 处理.</li></ul></li></ul></li></ul></li><li><p>安全策略数据库 SPDB: 使用 SA.</p><ul><li>定义、标识、管理和维护安全策略:<ul><li>Discard: 不让包进入或外发.</li><li>Bypass: 不对进入或外发包进行安全服务.</li><li>Apply: 对外发包提供安全服务, 认为接收包已进行安全服务.</li></ul></li><li>包括定义 IP 流量子集的入口, 指向该流量 SA 的指针.</li><li>定义 IP 流量与特定 SA 相关, 决定对哪些出入数据包进行安全操作.</li></ul></li></ul><h4 id="传输模式与隧道模式"><a href="#传输模式与隧道模式" class="headerlink" title="传输模式与隧道模式"></a>传输模式与隧道模式</h4><ul><li><p>传输模式:</p><ul><li>为上层协议提供保护, 同时增加 IP 包载荷保护.</li><li><p>典型: 两台主机间的端到端通信.</p><ul><li>传输模式 AH 认证 IP 载荷和报头选中部分.</li><li>传输模式 ESP 加密(和认证) IP 载荷, 不包括报头.</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301709261.png" alt=""></p></li></ul></li><li><p>隧道模式:</p><ul><li>对整个 IP 包提供保护, 加上 AH/ESP 域后, 整个数据包和安全域当作新 IP 载荷, 并拥有一个新的外部 IP 报头.</li><li><p>新 IP 包利用隧道在网络中传输, 路由器不能检查内部 IP 报头.</p><ul><li>隧道模式 AH 认证整个内部 IP 包和外部 IP 报头选中部分.</li><li>隧道模式 ESP 加密(和认证)整个内部 IP 包, 包括内部 IP 报头.</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301709262.png" alt=""></p></li></ul></li></ul><h3 id="认证头-AH"><a href="#认证头-AH" class="headerlink" title="认证头 AH"></a>认证头 AH</h3><ul><li><p>数据完整性: 包传输过程中内容不可更改.</p></li><li><p>认证: 末端系统或网络设备对用户者应用程序进行认证, 提供流量过滤功能, 防止地址欺诈攻击和重放攻击, 基于共享公钥的消息认证码 MAC.</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301709263.png" alt=""></p></li><li><p>传输模式:</p><ul><li>不修改 IP 头, 只添加 AH 头.</li></ul></li><li><p>隧道模式:</p><ul><li>整个 IP 包作为数据, 增加一个新的 IP 头、AH 头.</li></ul></li><li><p>处理接收数据包:</p><ul><li>从端口收到输入数据包, 解析 SA 三元组, 查找 SADB.<ul><li>查找到匹配 SA 条目, 将参数与数据包域参数比较:<ul><li>一致则处理; 不一致则丢弃.</li></ul></li><li>没有查找到匹配 SA 条目, 丢弃该数据包</li></ul></li><li>使用滑动窗口, 检查序列号重放.</li><li>计算 ICV, 和数据包中值比较:<ul><li>相等则恢复数据包, 转 IP 协议栈路由; 不相等则丢弃并审计事件.</li></ul></li></ul></li><li><p>处理输出数据包:</p><ul><li>从 IP 协议栈收到转发数据包, 使用选择子查找 SPDB, 获取安全策略.</li><li>确定实施 IPsec 处理, 查找 SADB.<ul><li>SA 未建立, 调用 IKE 协商新的 SA.</li><li>SA 已建立, 直接进行下一步.</li></ul></li><li>产生序列号, 防止重放攻击.</li><li><p>选取参数计算 ICV, 转发报文.</p><div style="display: flex; justify-content: center;">   <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301709264.png" style="margin-right: 10px;" width="200">   <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301709265.png" style="margin-left: 10px;" width="200"> </div></li></ul></li></ul><h3 id="封装安全载荷-ESP"><a href="#封装安全载荷-ESP" class="headerlink" title="封装安全载荷 ESP"></a>封装安全载荷 ESP</h3><ul><li><p>保密性: 报文内容保密和流量限制保密.</p></li><li><p>认证: 与 AH 相同.</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301709266.png" alt=""></p></li><li><p>填充域功能:</p><ul><li>加密算法需要明文是倍数, 填充域扩展明文长度.</li><li>填充长度和邻接头域为右对齐的 32 位字.</li><li>隐藏载荷实际长度, 提供部分流量保护.</li></ul></li><li><p>传输模式:</p><ul><li>不修改 IP 头, 只添加 ESP 头与 ESP 尾, 可选添加 MAC.</li></ul></li><li><p>隧道模式:</p><ul><li>整个包为数据, 增加一个新的 IP 头、ESP 头、ESP 尾, 可选添加 MAC.</li></ul></li><li><p>处理接收数据包:</p><ul><li>从端口收到输入数据包, 解析 SA 三元组, 查找 SADB.<ul><li>查找到匹配 SA 条目, 将参数与数据包域参数比较:<ul><li>一致则处理; 不一致则丢弃.</li></ul></li><li>没有查找到匹配 SA 条目, 丢弃该数据包</li></ul></li><li>使用滑动窗口, 检查序列号重放.</li><li>计算 ICV, 和数据包中值比较:<ul><li>相等则恢复数据包, 转 IP 协议栈路由; 不相等则丢弃并审计事件.</li></ul></li><li>根据 SA 指定的算法/密钥/参数, 解密数据, 重构原始 IP 包, 准备路由.</li></ul></li><li><p>处理输出数据包:</p><ul><li>从 IP 协议栈收到转发数据包, 使用选择子查找 SPDB, 获取安全策略.</li><li>确定实施 IPsec 处理, 查找 SADB.<ul><li>SA 未建立, 调用 IKE 协商新的 SA.</li><li>SA 已建立, 直接进行下一步.</li></ul></li><li>产生序列号, 防止重放攻击.</li><li>选取参数加密数据报.</li><li><p>选取参数计算 ICV, 分片并转发报文.</p><div style="display: flex; justify-content: center;">   <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301709267.png" style="margin-right: 10px;" width="200">   <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301709268.png" style="margin-left: 10px;" width="200"> </div></li></ul></li></ul><h3 id="安全关联组合"><a href="#安全关联组合" class="headerlink" title="安全关联组合"></a>安全关联组合</h3><ul><li>单个 SA 可实现 AH 或 ESP, 但不能都实现.</li><li>例: 特定流量需在主机间提供 IPsec 服务, 安全网关间提供相同流量分离服务.</li><li>安全关联组合:<ul><li>提供特定 IPsec 服务集所需的 SA 序列.</li><li>传输邻接: 不使用隧道, 对一个 IP 包使用多个安全协议, 组合 AH 和 ESP 仅允许一级组合.</li><li>隧道迭代: 通过隧道应用多层安全协议, 允许多层嵌套.</li></ul></li></ul><h2 id="IKE-为-IPsec-管理密钥"><a href="#IKE-为-IPsec-管理密钥" class="headerlink" title="IKE: 为 IPsec 管理密钥"></a>IKE: 为 IPsec 管理密钥</h2><ul><li>IPsec 支持两种密钥管理类型:<ul><li>手工: 系统管理员手动配置, SA 永远存在, 小规模、结构简单网络.</li><li>自动: 大型分布系统中, SA 协商产生, 复杂拓扑和高安全性网络.</li></ul></li><li>IKE 协议简介:<ul><li>为 IPsec 自动协商交换密钥, 建立 SA, 维护 SADB.</li><li>在不安全网络环境中, 安全建立或更新共享密钥.</li><li>通用协议, 可为 SNMPv3, RIPv2, OSPFv2 等保密协议协商参数.</li><li>目前只在 IPsec 得到应用.</li><li>精髓:<ul><li>不在不安全网络上直接传送密钥.</li><li>通过一系列数据交换, 通信双方计算出共享密钥.</li></ul></li><li>核心技术:<ul><li>DH 秘钥交换算法, 完善的前向安全性 PFS.</li><li>一个密钥被破解, 不影响其他密钥安全性, 密钥没有派生关系.</li></ul></li><li>混合协议:<ul><li>ISAKMP 协议的格式和阶段.</li><li>Oakley 协议的模式.</li><li>SKEME 协议的验证公钥加密方法, 定义两种密钥交换方式.</li></ul></li></ul></li></ul><h3 id="IKE-报文格式"><a href="#IKE-报文格式" class="headerlink" title="IKE 报文格式"></a>IKE 报文格式</h3><ul><li>继承自 ISAKMP.</li><li>在任何传输层或 IP 层上实现, UDP 协议端口 500 传输.</li><li>交换信息形式: 定长报文头, 不定数量载荷.</li><li>定义 13 种载荷 (SSL 握手协议定义了 10 种).</li></ul><h3 id="IKE-体系结构"><a href="#IKE-体系结构" class="headerlink" title="IKE 体系结构"></a>IKE 体系结构</h3><ul><li><p>第一阶段:</p><ul><li><p>协商创建通信信道 IKE SA, 对信道进行验证.</p></li><li><p>为进一步 IKE 通信提供机密性、完整性及消息源验证.</p></li><li><p>主模式:</p><ul><li>6 个消息交互.</li><li><p>对通信双方的身份保护.</p><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301709269.png" alt=""></p></li></ul></li><li><p>积极模式:</p><ul><li>3 个消息交互.</li><li>适用于一方地址为动态的情况.</li><li><p>身份保护不必要, 减少信息传输, 提高协商效率.</p><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301709270.png" alt=""></p></li></ul></li></ul></li><li><p>第二阶段:</p><ul><li>使用建立的 IKE SA 建立 IPsec SA.</li><li>快速模式:<ul><li>3 个消息交互.</li><li>一个 IKE SA 协商可为多个 IPsec SA 协商提供服务.</li><li>协商内容与协商安全协议相关.</li><li>使用快速模式信息交换, 一个第二阶段协商可建立多个 SA.</li></ul></li></ul></li></ul><h3 id="IKE-工作模式"><a href="#IKE-工作模式" class="headerlink" title="IKE 工作模式"></a>IKE 工作模式</h3><ul><li>传输模式:<ul><li>端节点到端节点, 均实现 IPsec.</li><li>IP 头与数据间插入 IPsec 头, 保护数据载荷.</li></ul></li><li>隧道模式:<ul><li>安全网关到安全网关.</li><li>端系统无需实现 IPsec, 网络节点完成保护功能.</li><li>内部 IP 头包含实际端节点 IP 地址.</li></ul></li><li>工作模式: 嵌套组合.<ul><li>端节点到安全网关模式.</li><li>外部目的地址总是安全网关的地址.</li><li>内部目的地址是数据包的最终地址.</li></ul></li></ul><h3 id="IKE-工作过程"><a href="#IKE-工作过程" class="headerlink" title="IKE 工作过程"></a>IKE 工作过程</h3><ul><li>IKE 以守护进程方式后台运行.</li><li>启动 IKE 服务:<ul><li>内核提交创建 IKE SA 请求.</li><li>同级 IKE 守护进程提交协商 SA 请求.</li></ul></li><li>两个守护进程通过 UDP 协议 500 端口传递消息.</li><li>使用 SADB 和 SPDB 数据库, 保存在操作系统内核.</li><li>工作过程:<ul><li>首先查询 SPDB, SPDB 条目隐藏指针, 决定丢弃/绕过/应用.</li><li>IPsec 查询 SADB, 检查合适 SA:<ul><li>有则进行 IPsec 处理.</li><li>没有则向 IKE 守护进程发出创建 SA 请求.</li></ul></li><li>IKE 守护进程查询 SPDB, 得到协商参数, 向远程 IKE 进程发出协商请求.<ul><li>协商成功, 新协商 SA 增加到 SADB.</li><li>协商未成功, IKE 进程提示管理员配置 SPDB 参数.</li></ul></li><li>管理员指示 IKE 守护进程不再使用某 SA, IKE 守护进程从 SADB 中删除 SA, 向远地 IKE 守护进程发送删除信息.</li><li>远地 IKE 进程:<ul><li>删除相应 SA.</li><li>忽略信息, 保留相应 SA, 但不允许使用其继续通信.</li></ul></li></ul></li></ul><h3 id="IKE-不足"><a href="#IKE-不足" class="headerlink" title="IKE 不足"></a>IKE 不足</h3><ul><li>IKE 是复杂混合协议集合, 局限于为 IPsec 建立安全关联 SA.</li><li>标准定义复杂, 导致理解困难, 不同实现互操作困难.</li><li>协商消息往返次数多, 消耗计算以网络带宽资源.</li><li>容易受到拒绝服务攻击、中间人攻击、重放攻击.</li></ul>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;五、网络层安全协议-IPsec&quot;&gt;&lt;a href=&quot;#五、网络层安全协议-IPsec&quot; class=&quot;headerlink&quot; title=&quot;五、网络层安全协议 IPsec&quot;&gt;&lt;/a&gt;五、网络层安全协议 IPsec&lt;/h1&gt;&lt;h2</summary>
        
      
    
    
    
    <category term="CS" scheme="http://chengsx21.github.io/categories/CS/"/>
    
    <category term="Network Security" scheme="http://chengsx21.github.io/categories/CS/Network-Security/"/>
    
    
    <category term="Network Security" scheme="http://chengsx21.github.io/tags/Network-Security/"/>
    
  </entry>
  
  <entry>
    <title>编译原理 实验3</title>
    <link href="http://chengsx21.github.io/2023/11/12/bian-yi-yuan-li-lab-3/"/>
    <id>http://chengsx21.github.io/2023/11/12/bian-yi-yuan-li-lab-3/</id>
    <published>2023-11-12T09:18:57.000Z</published>
    <updated>2024-06-30T09:52:55.509Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Stage-3-报告"><a href="#Stage-3-报告" class="headerlink" title="Stage 3 报告"></a>Stage 3 报告</h1><h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><h3 id="step-6"><a href="#step-6" class="headerlink" title="step 6"></a>step 6</h3><p><strong>语义分析</strong>: 实现了 <code>ScopeStack</code> 数据结构维护层次嵌套的作用域.</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># frontend/scope/scopestack.py</span><span class="token keyword">class</span> <span class="token class-name">ScopeStack</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> globalScope<span class="token punctuation">:</span> Scope<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>globalScope <span class="token operator">=</span> globalScope        self<span class="token punctuation">.</span>scopeStack <span class="token operator">=</span> <span class="token punctuation">[</span>globalScope<span class="token punctuation">]</span>        self<span class="token punctuation">.</span>scopeDepth <span class="token operator">=</span> <span class="token number">512</span>    <span class="token keyword">def</span> <span class="token function">open</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> scope<span class="token punctuation">:</span> Scope<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>scopeStack<span class="token punctuation">)</span> <span class="token operator">&lt;</span> self<span class="token punctuation">.</span>scopeDepth<span class="token punctuation">:</span>            self<span class="token punctuation">.</span>scopeStack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>scope<span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">raise</span> ScopeOverflowError    <span class="token keyword">def</span> <span class="token function">close</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>scopeStack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">top</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> Scope<span class="token punctuation">:</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>scopeStack<span class="token punctuation">:</span>            <span class="token keyword">return</span> self<span class="token punctuation">.</span>scopeStack<span class="token punctuation">[</span><span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>scopeStack<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>globalScope  <span class="token comment"># 复用 Scope 类的成员函数</span>    <span class="token keyword">def</span> <span class="token function">isGlobalScope</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">bool</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>top<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>isGlobalScope<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">declare</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> symbol<span class="token punctuation">:</span> Symbol<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>top<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>declare<span class="token punctuation">(</span>symbol<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">lookup</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> name<span class="token punctuation">:</span> <span class="token builtin">str</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> Optional<span class="token punctuation">[</span>Symbol<span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>top<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>lookup<span class="token punctuation">(</span>name<span class="token punctuation">)</span>        <span class="token keyword">def</span> <span class="token function">lookupOverStack</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> name<span class="token punctuation">:</span> <span class="token builtin">str</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> Optional<span class="token punctuation">[</span>Symbol<span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token keyword">for</span> scope <span class="token keyword">in</span> <span class="token builtin">reversed</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>scopeStack<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> scope<span class="token punctuation">.</span>containsKey<span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> scope<span class="token punctuation">.</span>get<span class="token punctuation">(</span>name<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token boolean">None</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>将 <code>frontend/typecheck/namer.py</code>, <code>frontend/typecheck/typer.py</code> 的上下文信息修改为 “作用域栈” 后, 修改符号表建立过程的 <code>visitBlock</code> 函数, 开启一个代码块时, 新建作用域并压栈; 退出代码块时, 弹栈关闭作用域. <code>ScopeStack</code> 中为定义变量复用了 <code>Scope.lookup</code> 函数, 逐层查找变量实现 <code>ScopeStack.lookupOverStack</code> 函数.</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># frontend/typecheck/namer.py</span><span class="token keyword">def</span> <span class="token function">visitBlock</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> block<span class="token punctuation">:</span> Block<span class="token punctuation">,</span> ctx<span class="token punctuation">:</span> ScopeStack<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>    ctx<span class="token punctuation">.</span><span class="token builtin">open</span><span class="token punctuation">(</span>Scope<span class="token punctuation">(</span>ScopeKind<span class="token punctuation">.</span>LOCAL<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> child <span class="token keyword">in</span> block<span class="token punctuation">:</span>        child<span class="token punctuation">.</span>accept<span class="token punctuation">(</span>self<span class="token punctuation">,</span> ctx<span class="token punctuation">)</span>    ctx<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">visitDeclaration</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> decl<span class="token punctuation">:</span> Declaration<span class="token punctuation">,</span> ctx<span class="token punctuation">:</span> ScopeStack<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> ctx<span class="token punctuation">.</span>lookup<span class="token punctuation">(</span>decl<span class="token punctuation">.</span>ident<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">def</span> <span class="token function">visitIdentifier</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> ident<span class="token punctuation">:</span> Identifier<span class="token punctuation">,</span> ctx<span class="token punctuation">:</span> ScopeStack<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>    symbol <span class="token operator">=</span> ctx<span class="token punctuation">.</span>lookupOverStack<span class="token punctuation">(</span>ident<span class="token punctuation">.</span>value<span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>后端</strong>: 增加了 <code>reachable</code> 函数, 使用 BFS 算法判断某个基本块是否可达.</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># backend/dataflow/cfg.py</span><span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nodes<span class="token punctuation">:</span> <span class="token builtin">list</span><span class="token punctuation">[</span>BasicBlock<span class="token punctuation">]</span><span class="token punctuation">,</span> edges<span class="token punctuation">:</span> <span class="token builtin">list</span><span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    self<span class="token punctuation">.</span>reachability <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    reachable <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>nodes<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>reachability<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token boolean">False</span><span class="token punctuation">)</span>    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token keyword">not</span> reachable<span class="token punctuation">:</span>            <span class="token keyword">break</span>        cur <span class="token operator">=</span> reachable<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>reachability<span class="token punctuation">[</span>cur<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">True</span>        <span class="token keyword">for</span> succ <span class="token keyword">in</span> self<span class="token punctuation">.</span>getSucc<span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> <span class="token keyword">not</span> self<span class="token punctuation">.</span>reachability<span class="token punctuation">[</span>succ<span class="token punctuation">]</span><span class="token punctuation">:</span>                self<span class="token punctuation">.</span>reachability<span class="token punctuation">[</span>succ<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">True</span>                reachable<span class="token punctuation">.</span>append<span class="token punctuation">(</span>succ<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">reachable</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> <span class="token builtin">id</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> self<span class="token punctuation">.</span>reachability<span class="token punctuation">[</span><span class="token builtin">id</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果一个基本块不可达, 那么无须为它分配寄存器.</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># backend/reg/bruteregalloc.py</span><span class="token keyword">def</span> <span class="token function">accept</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> graph<span class="token punctuation">:</span> CFG<span class="token punctuation">,</span> info<span class="token punctuation">:</span> SubroutineInfo<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>index<span class="token punctuation">,</span> bb<span class="token punctuation">)</span> <span class="token keyword">in</span> <span class="token builtin">enumerate</span><span class="token punctuation">(</span>graph<span class="token punctuation">.</span>iterator<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token keyword">if</span> graph<span class="token punctuation">.</span>reachable<span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>localAlloc<span class="token punctuation">(</span>bb<span class="token punctuation">,</span> subEmitter<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><h3 id="step-6-1"><a href="#step-6-1" class="headerlink" title="step 6"></a>step 6</h3><ol><li><p>请画出下面 MiniDecaf 代码的控制流图.</p> <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">{</span>            <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> a<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> a<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> <strong>答:</strong> 这段代码的可能 TAC 码以及控制流图如下.</p><p> <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301643197.png" alt=""></p></li></ol>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;Stage-3-报告&quot;&gt;&lt;a href=&quot;#Stage-3-报告&quot; class=&quot;headerlink&quot; title=&quot;Stage 3 报告&quot;&gt;&lt;/a&gt;Stage 3 报告&lt;/h1&gt;&lt;h2 id=&quot;实验内容&quot;&gt;&lt;a href=&quot;#实验内容&quot;</summary>
        
      
    
    
    
    <category term="CS" scheme="http://chengsx21.github.io/categories/CS/"/>
    
    <category term="Compiler" scheme="http://chengsx21.github.io/categories/CS/Compiler/"/>
    
    
    <category term="Compiler" scheme="http://chengsx21.github.io/tags/Compiler/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成原理 笔记6</title>
    <link href="http://chengsx21.github.io/2023/11/06/ji-suan-ji-zu-cheng-yuan-li-bi-ji-6/"/>
    <id>http://chengsx21.github.io/2023/11/06/ji-suan-ji-zu-cheng-yuan-li-bi-ji-6/</id>
    <published>2023-11-06T09:18:57.000Z</published>
    <updated>2024-06-30T09:53:39.681Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Pipeline"><a href="#Pipeline" class="headerlink" title="Pipeline"></a>Pipeline</h1><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><ul><li>IF 阶段与 MEM 阶段, 一个周期内无法完成访存, 需要将其他部件全部卡住.</li><li>单周期比多周期 CPI 低, 但是多周期可以提高时钟频率, 在性能上更好.</li><li>流水线过长, 一定程度能够均分各阶段延迟, 但会引入流水线寄存器带来的固定延迟.</li><li>如何清空流水线? 插入气泡, 拒绝写寄存器、写内存等时序逻辑.</li><li>为什么加速比 &lt; 流水段数?<ul><li>流水段执行时间不等, 部分流水段时间过长;</li><li>流水线寄存器延迟;</li><li>插入气泡废弃指令.</li></ul></li><li>组合逻辑: 进入 ID 阶段即完成译码, 进入 EXE 阶段即完成执行.</li><li>时序逻辑: 进入 IF\MEM 阶段, 等待访存; 进入 WB 阶段, 下一周期写入完成.</li><li>从后向前生成控制信号, 避免信号生成遗漏.</li></ul><h2 id="Conflicts"><a href="#Conflicts" class="headerlink" title="Conflicts"></a>Conflicts</h2><ul><li>由 Von-Neumann 体系结构中指令的执行过程决定.</li><li><strong>结构冲突</strong>: 硬件资源不足.<ul><li>当 load 指令在 MEM 阶段和任意指令在 IF 阶段<strong>同时访存</strong>, 用 stall 信号卡住 MEM 阶段及以前的指令, 用 bubble 信号排空 WB 阶段的指令.</li><li>当 load 指令在 WB 阶段和其他指令在 ID 阶段<strong>同时读写寄存器</strong>, 增设读写端口避免冲突. 寄存器读是组合逻辑, 寄存器写是时序逻辑.</li><li>通过设置 I-cache 和 D-cache 增加资源.</li></ul></li><li><strong>数据冲突</strong>: 读后写冲突, 指令依赖于前面指令的结果数据.<ul><li>当读写寄存器<strong>次序冲突</strong>, 用 stall 信号卡住 ID 阶段的指令, 用 bubble 信号排空 EXE 阶段的指令.</li><li>当读写寄存器<strong>次序冲突</strong>, 使用数据旁路将 EXE 阶段的数据前传至 ID 阶段; 若为 <strong>load use 冲突</strong>, 只能使用 stall-bubble 方法, 并在 WB 阶段前传.</li></ul></li><li><strong>控制冲突</strong>: 执行分支转移类指令.<ul><li><strong>暂停</strong>流水线: 发现分支指令, 暂停流水线, 判断是否分支.</li><li><strong>预测</strong>分支<strong>不成功</strong>: IF 阶段直接取后续指令, ID\EXE 阶段判断是否分支.</li><li><strong>预测</strong>分支<strong>成功</strong>: ID 阶段计算分支地址并转移, ID\EXE 阶段判断是否分支.</li><li><strong>动态预测</strong>: 使用 BTB 表, 用 inst[11:2] 作为索引存储分支指令 inst[31:12] 和分支目标的映射. IF 阶段读取 BTB, ID\EXE 阶段计算分支目标地址和分支结果, 并填入 BTB.</li></ul></li><li><strong>卡住+气泡</strong>的延迟方法是万能的, 相当于将流水线处理器退化为多周期处理器.</li></ul>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;Pipeline&quot;&gt;&lt;a href=&quot;#Pipeline&quot; class=&quot;headerlink&quot; title=&quot;Pipeline&quot;&gt;&lt;/a&gt;Pipeline&lt;/h1&gt;&lt;h2 id=&quot;Overview&quot;&gt;&lt;a href=&quot;#Overview&quot;</summary>
        
      
    
    
    
    <category term="CS" scheme="http://chengsx21.github.io/categories/CS/"/>
    
    <category term="Organization &amp; Design" scheme="http://chengsx21.github.io/categories/CS/Organization-Design/"/>
    
    
    <category term="Organization &amp; Design" scheme="http://chengsx21.github.io/tags/Organization-Design/"/>
    
    <category term="SV" scheme="http://chengsx21.github.io/tags/SV/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络安全技术 笔记4</title>
    <link href="http://chengsx21.github.io/2023/10/31/ji-suan-ji-wang-luo-an-quan-ji-zhu-bi-ji-4/"/>
    <id>http://chengsx21.github.io/2023/10/31/ji-suan-ji-wang-luo-an-quan-ji-zhu-bi-ji-4/</id>
    <published>2023-10-31T09:18:57.000Z</published>
    <updated>2024-06-30T09:49:13.954Z</updated>
    
    <content type="html"><![CDATA[<h1 id="四、CIA-及其应用"><a href="#四、CIA-及其应用" class="headerlink" title="四、CIA 及其应用"></a>四、CIA 及其应用</h1><h2 id="计算机网络安全体系结构"><a href="#计算机网络安全体系结构" class="headerlink" title="计算机网络安全体系结构"></a>计算机网络安全体系结构</h2><ul><li><p>安全目标、服务、机制的关系:</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301707175.png" alt=""></p></li></ul><h3 id="安全目标"><a href="#安全目标" class="headerlink" title="安全目标"></a>安全目标</h3><ul><li>Confidentiality: 保密性.<ul><li>信息内容不会泄露给未授权实体.</li><li>业务数据、网络拓扑、流量都可能有保密性要求.</li><li>防止被动攻击.</li></ul></li><li>Integrity：完整性.<ul><li>保证信息不被未授权修改, 可以检测出来.</li><li>防止主动攻击 (篡改、插入、重放).</li></ul></li><li>Availability：可用性.<ul><li>保证授权用户访问到资源或服务.</li><li>对路由设备的处理能力、缓冲区、链路带宽等的攻击.</li><li>防止拒绝服务攻击.</li></ul></li></ul><h3 id="OSI-安全框架-X-800"><a href="#OSI-安全框架-X-800" class="headerlink" title="OSI 安全框架 (X.800)"></a>OSI 安全框架 (X.800)</h3><ul><li><p>安全服务:</p><ul><li>通过安全机制实现安全策略.</li></ul></li><li><p>安全机制:</p><ul><li>保护系统免受监听, 阻止安全攻击, 恢复系统.</li></ul></li><li><p>安全攻击:</p><ul><li><p>主动攻击、被动攻击.</p><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301707176.png" alt=""></p></li></ul></li></ul><h3 id="安全服务"><a href="#安全服务" class="headerlink" title="安全服务"></a>安全服务</h3><h4 id="Authentication-认证服务"><a href="#Authentication-认证服务" class="headerlink" title="Authentication 认证服务"></a>Authentication 认证服务</h4><ul><li>保证通信的真实性.</li><li>单条消息情况下:<ul><li>向接受方保证发送方的真实性.</li></ul></li><li>双方通信情况下:<ul><li>连接初始化阶段保证双方的真实性.</li><li>保证连接不受第三方非法伪装干扰.</li></ul></li><li>对等实体认证 (Peer Authentication):<ul><li>保证参与通信实体的身份是真实的.</li><li>实体不能试图伪装或进行非授权重放.</li><li>面向连接的应用.</li></ul></li><li>数据源认证 (Data original authentication):<ul><li>对数据来源提供确认, 但是复制和修改不提供保护.</li><li>保证接收到的信息来自宣称来源.</li><li>面向无连接的应用.</li></ul></li></ul><h4 id="Confidentiality-保密服务"><a href="#Confidentiality-保密服务" class="headerlink" title="Confidentiality 保密服务"></a>Confidentiality 保密服务</h4><ul><li>防止被动攻击, 防止流量分析.</li><li>连接保密服务与无连接保密服务</li><li>保密力度: 流、消息、选择字段.</li></ul><h4 id="Integrity-数据完整性服务"><a href="#Integrity-数据完整性服务" class="headerlink" title="Integrity 数据完整性服务"></a>Integrity 数据完整性服务</h4><ul><li>检测并防止主动攻击.</li><li>对消息流、单条消息或消息的选定部分进行保护.<ul><li>面向连接: 保证收到的消息和发出的消息一致.</li><li>面向无连接: 保证单条消息不被修改.</li></ul></li></ul><h4 id="Access-Control-访问控制服务"><a href="#Access-Control-访问控制服务" class="headerlink" title="Access Control 访问控制服务"></a>Access Control 访问控制服务</h4><ul><li>限制实体访问权限, 经过认证的合法实体可以访问.</li><li>标识与认证是访问控制的前提.</li></ul><h4 id="Non-Repudiation-抗抵赖服务"><a href="#Non-Repudiation-抗抵赖服务" class="headerlink" title="Non-Repudiation 抗抵赖服务"></a>Non-Repudiation 抗抵赖服务</h4><ul><li>防止发送方否认传输或接收方否认接收.</li><li>源发抗抵赖:<ul><li>发出后, 接收方证明消息由声称的发送方发出.</li></ul></li><li>交付抗抵赖:<ul><li>接收后, 发送方证明消息已被接收方收到.</li></ul></li></ul><h4 id="Availability-可用性服务"><a href="#Availability-可用性服务" class="headerlink" title="Availability 可用性服务"></a>Availability 可用性服务</h4><ul><li>按照授权的系统实体要求, 存取或使用系统资源.</li></ul><h3 id="安全机制"><a href="#安全机制" class="headerlink" title="安全机制"></a>安全机制</h3><ul><li>普通安全机制: 不属于协议层或安全服务.<ul><li>可信功能: 根据某些标准被认为是正确的.</li><li>安全标签: 指明资源的安全属性.</li><li>事件检测: 检测与安全相关的事件.</li><li>审计跟踪: 收集安全审计数据, 对系统记录和行为的回顾检查.</li><li>安全恢复: 处理来自安全机制的请求, 如事件处理和采取恢复行为.</li></ul></li><li>特定安全机制: 在特定协议层实现.<ul><li>加密机制、通信业务流量填充机制.</li><li>访问控制机制、数据完整性机制.</li><li>认证交换机制、数字签名机制.</li><li>路由控制机制、公证机制.</li></ul></li></ul><h3 id="安全攻击"><a href="#安全攻击" class="headerlink" title="安全攻击"></a>安全攻击</h3><ul><li>主动攻击: 改变系统资源或影响系统运行.</li><li>被动攻击: 了解或利用系统信息, 不影响系统资源.<ul><li>窃听和监测传输.</li><li>流量分析.</li></ul></li></ul><h2 id="无线局域网-WLAN"><a href="#无线局域网-WLAN" class="headerlink" title="无线局域网 WLAN"></a>无线局域网 WLAN</h2><h3 id="无线网络概述"><a href="#无线网络概述" class="headerlink" title="无线网络概述"></a>无线网络概述</h3><ul><li><p>计算机与移动通信技术的结合.</p></li><li><p>实现 6A 梦想/移动计算/普适计算的核心技术.</p></li><li><p>ALOHA 研究计划:</p><ul><li>最早的无线电计算机通信网 ALOHA.</li><li>采用无线电广播技术和 Pure ALOHA 协议.</li><li><p>第一个使用无线电通信代替点到点连接线路作为通信设施的计算机系统, 无线网络正式诞生.</p><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301709250.png" alt=""></p></li></ul></li></ul><h3 id="无线局域网安全威胁"><a href="#无线局域网安全威胁" class="headerlink" title="无线局域网安全威胁"></a>无线局域网安全威胁</h3><ul><li>与有线局域网相比:<ul><li>利用无线射频电波作为信息传输的媒介.</li><li>通信范围不受环境条件的限制.</li><li>无法采用物理隔离, 存在安全问题.</li></ul></li><li>安全威胁:<ul><li>无线窃听:<ul><li>无线信道具有开放性信道, 可通过窃听获得信息.</li><li>可以导致信息泄露与无线跟踪.</li></ul></li><li>假冒攻击:<ul><li>攻击者截获到合法用户身份, 假冒该身份入网.</li></ul></li><li>信息篡改:<ul><li>攻击者将窃听信息进行修改, 传给原本的接收者.</li></ul></li><li>重放、重路由、错误路由、删除消息:<ul><li>重新发送或重用消息以访问某种资源.</li><li>改变消息路由以便捕获有关信息.</li><li>将消息路由到错误的目的地.</li><li>在消息到达目的地前将消息删除掉.</li></ul></li><li>网络泛洪:<ul><li>入侵者发送大量伪造或无关消息, 使 AP 耗尽信道和系统资源.</li></ul></li></ul></li></ul><h3 id="无线局域网认证加密技术"><a href="#无线局域网认证加密技术" class="headerlink" title="无线局域网认证加密技术"></a>无线局域网认证加密技术</h3><h4 id="无加密认证"><a href="#无加密认证" class="headerlink" title="无加密认证"></a>无加密认证</h4><ul><li>无线接入点 AP:<ul><li>无线网络的创建者, 网络中心节点.</li><li>无线路由器就是一个 AP.</li></ul></li><li>STA 站点:<ul><li>连接到无线网络中的终端.</li></ul></li><li>SSID:<ul><li>为 AP 配置的标志名, 便于用户识别, 俗称 wifi 名.</li><li>使用者提出 SSID, AP 接受用户端登入请求.</li><li>AP 向外广播 SSID, 禁止广播以提高安全性.</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301709252.png" alt=""></p><h4 id="WEP-有线等效保密协议"><a href="#WEP-有线等效保密协议" class="headerlink" title="WEP (有线等效保密协议)"></a>WEP (有线等效保密协议)</h4><ul><li><p>与有线网络相同级别的安全保护, 协议标准为 IEEE 802.11b.</p></li><li><p>使用 WEP 协议:</p><ul><li>无线 AP 启用 WEP 功能, 创建密钥.</li><li>每个无线客户端启用 WEP, 输入密钥, 保证安全连接.</li></ul></li><li><p>安全措施:</p><ul><li><p>认证:</p><ul><li><p>开放系统认证: 默认认证方式, 提供明文认证.</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301709253.png" style="zoom:50%;"></p></li><li><p>共享密钥认证.</p></li></ul></li><li><p>保密性:</p><ul><li>对称加密 RC4 流密码, 密钥长度 40/104 bits.</li><li>提供访问控制和保护隐私的功能.</li></ul></li><li><p>完整性:</p><ul><li>循环冗余校验 CRC32.</li></ul></li><li><p>密钥管理:</p><ul><li>设备与接入点共享默认密钥, 可能泄露.</li><li>设备与设备建立密钥对关系, 人工分发困难.</li></ul></li></ul></li><li><p>加密过程:</p><ul><li><p>计算校验和/加密/传输.</p></li><li><p>明文 P/初始化向量 IV/共享密钥 K0/一次性秘钥 KE/密文 Y.</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301709254.png" alt=""></p></li></ul></li><li><p>解密过程:</p><ul><li><p>计算一次性密钥 KE/解密/认证.</p></li><li><p>密文P/初始化向量 IV/共享密钥 K0/一次性秘钥 KE/明文 P.</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301709255.png" alt=""></p></li></ul></li><li><p>安全性分析:</p><ul><li>同一个 SSID 所有 STA 和 AP 共享密钥, 容易泄露.</li><li>RC4 是序列密码加密算法, 容易被破译.</li><li>RC4 的初始化向量 IV 明文发送.</li><li>24 bits 初始化向量 IV 容易重复.</li><li>CRC32 是非加密线性运算, 用于检测随机错误, 无法实现消息认证.</li><li>WEP 协议不含序列号, 无法确定帧顺序, 无法抵抗重放攻击.</li></ul></li></ul><h4 id="WPA-WiFi-安全存取"><a href="#WPA-WiFi-安全存取" class="headerlink" title="WPA (WiFi 安全存取)"></a>WPA (WiFi 安全存取)</h4><ul><li><p>WPA1:</p><ul><li><p>安全措施:</p><ul><li>认证:<ul><li>802.1x 协议 (WPA 企业版).</li><li>PSK (预先共享密钥) 模式 (WPA 个人版).</li></ul></li><li>保密性:<ul><li>RC4 流密码加密, 密钥长度 128 位.</li></ul></li><li>完整性:<ul><li>更安全的消息认证码 MIC.</li><li>MIC 包含帧计数器, 防范重放攻击.</li></ul></li></ul></li><li><p>核心:</p><ul><li><p>TKIP 协议:</p><ul><li>在 WEP 外围的一层外壳.</li><li>使用同样加密引擎和 RC4 算法, 密钥长度 128 位, 解决短密钥问题.</li><li>动态变化每个数据包的密钥, 通过多种因素混合生成.</li><li>数据包有独有的 48 位序列号, 防范重放攻击.</li></ul></li><li><p>IEEE 802.1x:</p><ul><li>针对以太网提出, 基于端口的网络访问控制, 利用物理层特性对连接到无线端口的设备进行身份认证.</li><li>基于 C/S 模式, 无线终端与 AP 连接前认证用户身份合法性.</li><li>无线终端向 AP 发起连接请求时, AP 要求输入用户名和密码, 送到验证服务器验证, 验证通过允许享用网络资源, 否则禁止设备访问.</li><li><p>与上层认证协议 EAP 配合, 实现用户认证和密钥分发.</p><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301709256.png" alt=""></p></li></ul></li></ul></li></ul></li><li><p>WPA2:</p><ul><li>无线局域网安全标准 IEEE 802.11i 公布, WPA2 随之公布公布.</li><li>安全措施:<ul><li>更安全的 CCMP 消息认证代替 MIC 算法.</li><li>AES 对称加密代替 RC4 流密码.</li><li>支持 802.11g 或以上无线网卡.</li></ul></li></ul></li><li><p>WPA 采用密钥分发机制, 不断转换密钥, 使公共场所、学术环境部署无线网络成为可能.</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301709257.png" alt=""></p></li></ul><h2 id="虚拟专用网-VPN"><a href="#虚拟专用网-VPN" class="headerlink" title="虚拟专用网 VPN"></a>虚拟专用网 VPN</h2><h3 id="VPN-需求背景"><a href="#VPN-需求背景" class="headerlink" title="VPN 需求背景"></a>VPN 需求背景</h3><ul><li>TCP/IP 协议的固有安全缺陷:<ul><li>攻击者通过软件设置 IP 地址, 监听并篡改、重放数据包内容.</li><li>IP 协议支持源路由方式, 源发方可以制定中间路由, 埋下源路由攻击隐患.</li><li>TCP/IP 协议序列号容易被猜测, 不检查参数导致缓冲区溢出.</li></ul></li><li>物理专用网价格高昂, 架设实施难度大.</li><li>高性能、高速度和高安全专用网需求强烈.</li></ul><h3 id="VPN-安全功能"><a href="#VPN-安全功能" class="headerlink" title="VPN 安全功能"></a>VPN 安全功能</h3><ul><li>通过私有通道, 在公共网络上仿真点到点私有连接.</li><li>任意两个节点间的连接没有端到端物理链路, 利用公众网资源动态组成.</li><li>连接远程用户、公司分支机构、业务伙伴.</li><li>安全功能:<ul><li>数据机密性保护.</li><li>数据完整性保护.</li><li>数据源身份认证.</li><li>重放攻击保护.</li></ul></li></ul><h3 id="VPN-解决方案"><a href="#VPN-解决方案" class="headerlink" title="VPN 解决方案"></a>VPN 解决方案</h3><ul><li>数据链路层:<ul><li>L2TP/PPTP/L2F.</li><li>存在认证、完整性、密钥管理等不足, 很少应用.</li><li>L2TP 的缺陷:<ul><li>认证: 仅对通道终端实体进行, 不认证每个数据报文, 无法抵抗插入攻击、地址欺骗攻击.</li><li>完整性: 没有针对每个数据报文进行校验, 可能进行拒绝服务攻击.</li><li>密钥管理: 报文可加密, 不支持密钥自动产生刷新, 可能破解密钥.</li></ul></li></ul></li><li>网络层:<ul><li>IPSec 在 IP 层加密(或)认证所有流量, 在 IPv4 和 IPv6 中都适用.</li><li>保障 IP 级安全:<ul><li>认证: 确保从包头标识源端发出, 传输过程中未被篡改.</li><li>保密: 报文加密后传输, 防止窃听.</li><li>密钥管理: 与密钥的安全交换相关.</li></ul></li></ul></li><li>传输层:<ul><li>SSL 协议的零客户端 (客户端可在没有证书情况下连接服务器)、低成本是最大优势.</li><li>适用于任何基于 B/S 结构的应用.</li><li>像视频会议的非 B/S 结构业务无法通过 SSL VPN 建立.</li><li>实际应用中:<ul><li>SSL VPN 和 IPsec VPN 往往结合实行.</li><li>SSL VPN 网关和 IPsec 网关有时也集成到一个设备.</li></ul></li></ul></li></ul>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;四、CIA-及其应用&quot;&gt;&lt;a href=&quot;#四、CIA-及其应用&quot; class=&quot;headerlink&quot; title=&quot;四、CIA 及其应用&quot;&gt;&lt;/a&gt;四、CIA 及其应用&lt;/h1&gt;&lt;h2 id=&quot;计算机网络安全体系结构&quot;&gt;&lt;a</summary>
        
      
    
    
    
    <category term="CS" scheme="http://chengsx21.github.io/categories/CS/"/>
    
    <category term="Network Security" scheme="http://chengsx21.github.io/categories/CS/Network-Security/"/>
    
    
    <category term="Network Security" scheme="http://chengsx21.github.io/tags/Network-Security/"/>
    
  </entry>
  
  <entry>
    <title>编译原理 实验2</title>
    <link href="http://chengsx21.github.io/2023/10/29/bian-yi-yuan-li-lab-2/"/>
    <id>http://chengsx21.github.io/2023/10/29/bian-yi-yuan-li-lab-2/</id>
    <published>2023-10-29T09:18:57.000Z</published>
    <updated>2024-06-30T09:52:55.509Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Stage-2-报告"><a href="#Stage-2-报告" class="headerlink" title="Stage 2 报告"></a>Stage 2 报告</h1><h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><h3 id="step-5"><a href="#step-5" class="headerlink" title="step 5"></a>step 5</h3><p><strong>语义分析</strong>: 实现了声明语句、赋值语句、标识符的语义分析函数.</p><p>在 <code>visitDeclaration</code> 中检查定义域中是否存在定义冲突, 在 <code>visitIdentifier</code> 中需要检查变量是否存在.</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># frontend/typecheck/namer.py:class Namer</span><span class="token keyword">def</span> <span class="token function">visitDeclaration</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> decl<span class="token punctuation">:</span> Declaration<span class="token punctuation">,</span> ctx<span class="token punctuation">:</span> Scope<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> ctx<span class="token punctuation">.</span>lookup<span class="token punctuation">(</span>decl<span class="token punctuation">.</span>ident<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">raise</span> DecafDeclConflictError<span class="token punctuation">(</span>decl<span class="token punctuation">.</span>ident<span class="token punctuation">.</span>value<span class="token punctuation">)</span>    <span class="token comment"># 构造 VarSymbol 对象, 将其加入符号表, 并设置 decl 的 symbol 属性</span>    symbol <span class="token operator">=</span> VarSymbol<span class="token punctuation">(</span>decl<span class="token punctuation">.</span>ident<span class="token punctuation">.</span>value<span class="token punctuation">,</span> decl<span class="token punctuation">.</span>var_t<span class="token punctuation">.</span><span class="token builtin">type</span><span class="token punctuation">)</span>    ctx<span class="token punctuation">.</span>declare<span class="token punctuation">(</span>symbol<span class="token punctuation">)</span>    decl<span class="token punctuation">.</span><span class="token builtin">setattr</span><span class="token punctuation">(</span><span class="token string">"symbol"</span><span class="token punctuation">,</span> symbol<span class="token punctuation">)</span>    <span class="token keyword">if</span> decl<span class="token punctuation">.</span>init_expr<span class="token punctuation">:</span>        decl<span class="token punctuation">.</span>init_expr<span class="token punctuation">.</span>accept<span class="token punctuation">(</span>self<span class="token punctuation">,</span> ctx<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">visitAssignment</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> expr<span class="token punctuation">:</span> Assignment<span class="token punctuation">,</span> ctx<span class="token punctuation">:</span> Scope<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>    <span class="token comment"># 参考 `visitBinary` 的实现</span>    expr<span class="token punctuation">.</span>lhs<span class="token punctuation">.</span>accept<span class="token punctuation">(</span>self<span class="token punctuation">,</span> ctx<span class="token punctuation">)</span>    expr<span class="token punctuation">.</span>rhs<span class="token punctuation">.</span>accept<span class="token punctuation">(</span>self<span class="token punctuation">,</span> ctx<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">visitIdentifier</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> ident<span class="token punctuation">:</span> Identifier<span class="token punctuation">,</span> ctx<span class="token punctuation">:</span> Scope<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>    symbol <span class="token operator">=</span> ctx<span class="token punctuation">.</span>lookup<span class="token punctuation">(</span>ident<span class="token punctuation">.</span>value<span class="token punctuation">)</span>    <span class="token keyword">if</span> <span class="token keyword">not</span> symbol<span class="token punctuation">:</span>        <span class="token keyword">raise</span> DecafUndefinedVarError<span class="token punctuation">(</span>ident<span class="token punctuation">.</span>value<span class="token punctuation">)</span>    <span class="token comment"># 设置 ident 的 symbol 属性</span>    ident<span class="token punctuation">.</span><span class="token builtin">setattr</span><span class="token punctuation">(</span><span class="token string">"symbol"</span><span class="token punctuation">,</span> symbol<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>中间代码生成</strong>: 为标识符、声明语句、赋值语句实现了中间代码生成函数. 递归访问每个子节点, 为声明的标识符分配临时寄存器, 并为表达式类型设置返回值 <code>val</code>. 需要注意在赋值时, 左端项需要是左值.</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># frontend/tacgen/tacgen.py:class TACGen</span><span class="token keyword">def</span> <span class="token function">visitIdentifier</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> ident<span class="token punctuation">:</span> Identifier<span class="token punctuation">,</span> mv<span class="token punctuation">:</span> TACFuncEmitter<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>    <span class="token comment"># 设置返回值为标识符对应的 temp 寄存器</span>    ident<span class="token punctuation">.</span><span class="token builtin">setattr</span><span class="token punctuation">(</span><span class="token string">"val"</span><span class="token punctuation">,</span> ident<span class="token punctuation">.</span><span class="token builtin">getattr</span><span class="token punctuation">(</span><span class="token string">"symbol"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>temp<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">visitDeclaration</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> decl<span class="token punctuation">:</span> Declaration<span class="token punctuation">,</span> mv<span class="token punctuation">:</span> TACFuncEmitter<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>    decl<span class="token punctuation">.</span><span class="token builtin">getattr</span><span class="token punctuation">(</span><span class="token string">"symbol"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>temp <span class="token operator">=</span> mv<span class="token punctuation">.</span>freshTemp<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> decl<span class="token punctuation">.</span>init_expr<span class="token punctuation">:</span>        <span class="token comment"># 对子节点进行 accept</span>        decl<span class="token punctuation">.</span>init_expr<span class="token punctuation">.</span>accept<span class="token punctuation">(</span>self<span class="token punctuation">,</span> mv<span class="token punctuation">)</span>        <span class="token comment"># 模仿 `visitAssignment` 函数进行赋值</span>        decl<span class="token punctuation">.</span><span class="token builtin">setattr</span><span class="token punctuation">(</span>            <span class="token string">"val"</span><span class="token punctuation">,</span> mv<span class="token punctuation">.</span>visitAssignment<span class="token punctuation">(</span>decl<span class="token punctuation">.</span><span class="token builtin">getattr</span><span class="token punctuation">(</span><span class="token string">"symbol"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>temp<span class="token punctuation">,</span> decl<span class="token punctuation">.</span>init_expr<span class="token punctuation">.</span><span class="token builtin">getattr</span><span class="token punctuation">(</span><span class="token string">"val"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">visitAssignment</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> expr<span class="token punctuation">:</span> Assignment<span class="token punctuation">,</span> mv<span class="token punctuation">:</span> TACFuncEmitter<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>    <span class="token comment"># 对子节点进行 accept</span>    expr<span class="token punctuation">.</span>lhs<span class="token punctuation">.</span>accept<span class="token punctuation">(</span>self<span class="token punctuation">,</span> mv<span class="token punctuation">)</span>    expr<span class="token punctuation">.</span>rhs<span class="token punctuation">.</span>accept<span class="token punctuation">(</span>self<span class="token punctuation">,</span> mv<span class="token punctuation">)</span>    <span class="token comment"># 设置返回值为赋值指令的返回值, 赋值操作更新左值, 左端项是左值 temp</span>    expr<span class="token punctuation">.</span><span class="token builtin">setattr</span><span class="token punctuation">(</span>        <span class="token string">"val"</span><span class="token punctuation">,</span> mv<span class="token punctuation">.</span>visitAssignment<span class="token punctuation">(</span>expr<span class="token punctuation">.</span>lhs<span class="token punctuation">.</span><span class="token builtin">getattr</span><span class="token punctuation">(</span><span class="token string">"symbol"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>temp<span class="token punctuation">,</span> expr<span class="token punctuation">.</span>rhs<span class="token punctuation">.</span><span class="token builtin">getattr</span><span class="token punctuation">(</span><span class="token string">"val"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>目标代码生成</strong>: 为赋值语句实现了 <code>visitAssign</code> 函数进行目标代码生成.</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># backend/riscv/riscvasmemitter.py:class RiscvAsmEmitter</span><span class="token keyword">def</span> <span class="token function">visitAssign</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> instr<span class="token punctuation">:</span> Assign<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>    self<span class="token punctuation">.</span>seq<span class="token punctuation">.</span>append<span class="token punctuation">(</span>Riscv<span class="token punctuation">.</span>Move<span class="token punctuation">(</span>instr<span class="token punctuation">.</span>dst<span class="token punctuation">,</span> instr<span class="token punctuation">.</span>src<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><h3 id="step-5-1"><a href="#step-5-1" class="headerlink" title="step 5"></a>step 5</h3><ol><li><p>我们假定当前栈帧的栈顶地址存储在 sp 寄存器中, 请写出一段 <strong>risc-v 汇编代码</strong>, 将栈帧空间扩大 16 字节 (提示1: 栈帧由高地址向低地址延伸; 提示2: risc-v 汇编中 <code>addi reg0, reg1, &lt;立即数&gt;</code> 表示将 <code>reg1</code> 的值加上立即数存储到 <code>reg0</code> 中).</p><p> <strong>答:</strong> 汇编代码为:</p> <pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">addi sp, sp, -16<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>有些语言允许在同一个作用域中多次定义同名的变量, 例如这是一段合法的 Rust 代码 (你不需要精确了解它的含义, 大致理解即可):</p> <pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token function">g</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 其中 <code>f(a)</code> 中的 <code>a</code> 是上一行的 <code>let a = 0;</code> 定义的, <code>g(a)</code> 中的 <code>a</code> 是上一行的 <code>let a = f(a);</code>.</p><p> 如果 MiniDecaf 也允许多次定义同名变量, 并规定新的定义会覆盖之前的同名定义, 请问在你的实现中, 需要对定义变量和查找变量的逻辑做怎样的修改 (提示: 如何区分一个作用域中<strong>不同位置</strong>的变量定义?).</p><p> <strong>答:</strong> 在语义分析部分 <code>frontend/typecheck/name.py</code> 中:</p><ul><li><code>visitDeclaration</code> 定义变量时, 不查询是否有同名变量并抛出同名异常, 因为顺序执行的程序中, 新的定义会覆盖之前的定义. 先访问初始化语句, 再访问变量声明, 并覆盖原始变量. 这是因为如果存在重名变量定义, 可以先根据变量的初始值计算出其新定义值.</li><li><code>visitIdentifier</code> 查找变量无需修改, 变量被新定义的变量覆盖后, 只需寻找当前作用域中的符号, 即是最新定义的变量.</li></ul></li></ol>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;Stage-2-报告&quot;&gt;&lt;a href=&quot;#Stage-2-报告&quot; class=&quot;headerlink&quot; title=&quot;Stage 2 报告&quot;&gt;&lt;/a&gt;Stage 2 报告&lt;/h1&gt;&lt;h2 id=&quot;实验内容&quot;&gt;&lt;a href=&quot;#实验内容&quot;</summary>
        
      
    
    
    
    <category term="CS" scheme="http://chengsx21.github.io/categories/CS/"/>
    
    <category term="Compiler" scheme="http://chengsx21.github.io/categories/CS/Compiler/"/>
    
    
    <category term="Compiler" scheme="http://chengsx21.github.io/tags/Compiler/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络安全技术 笔记3</title>
    <link href="http://chengsx21.github.io/2023/10/24/ji-suan-ji-wang-luo-an-quan-ji-zhu-bi-ji-3/"/>
    <id>http://chengsx21.github.io/2023/10/24/ji-suan-ji-wang-luo-an-quan-ji-zhu-bi-ji-3/</id>
    <published>2023-10-24T09:18:57.000Z</published>
    <updated>2024-06-30T09:49:13.954Z</updated>
    
    <content type="html"><![CDATA[<h1 id="三、认证技术"><a href="#三、认证技术" class="headerlink" title="三、认证技术"></a>三、认证技术</h1><h2 id="消息认证"><a href="#消息认证" class="headerlink" title="消息认证"></a>消息认证</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li>网络环境中的攻击:<ul><li>对付泄密、传输分析——消息保密性.</li><li>对付伪装、内容修改、顺序修改、计时修改——消息认证.</li><li>对付发送方否认——数字签名.</li><li>对付接收方否认——数字签名和相关协议.</li></ul></li><li>消息认证:<ul><li>认证 = 比较.</li><li>验证收到的消息确实来自真正的发送方且未被修改.</li><li>可以验证消息的顺序和及时性.<ul><li>数字签名是一种认证技术, 用来抗击发送方否认.</li><li>各种认证协议属于认证技术.</li></ul></li><li>消息认证在功能上看作两层:<ul><li>下面有产生认证符的函数, 认证符是用来认证消息的值.</li><li>上面协议将函数作为原语, 使接收方可以验证消息真实性.</li></ul></li></ul></li></ul><h3 id="三种认证函数"><a href="#三种认证函数" class="headerlink" title="三种认证函数"></a>三种认证函数</h3><h4 id="消息加密"><a href="#消息加密" class="headerlink" title="消息加密"></a>消息加密</h4><ul><li><p>对称加密:</p><ul><li><p>要求明文具有易于识别的结构, 不通过加密函数不能重复这种结构.</p></li><li><p>加密前, 每个消息附加一个错误检测码 (帧校验序列 FCS).</p></li><li><p>先计算 FCS, 再加密: 可提供认证.</p></li><li><p>先加密, 再计算FCS: 攻击者可构造具有正确 FCS 的消息造成混淆.</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301707161.png" alt=""></p></li><li><p>例: TCP 协议.</p></li><li><p>特点:</p><ul><li>提供保密性: 只有 A 和 B 共享密钥.</li><li>提供认证: 只能发自 A, 传输中未被改变.</li><li>不能提供数字签名: 接收方可以伪造, 发送方可以否认.</li></ul></li></ul></li><li><p>公钥加密:</p><ul><li>只提供保密性, 不能提供认证.</li><li>既要提供保密性, 又要提供认证, 发送方先用私钥数字签名, 再用公钥加密.</li><li>缺点:<ul><li>执行了四次附加公钥算法运算.</li></ul></li><li>特点:<ul><li>提供保密性: 只有 B 拥有解密 $K_{U_b}$, 但任何人可加密消息假称是 A.</li><li>提供认证和签名: 只有 A 拥有加密 $K_{R_a}$, 传输中未被改变.</li></ul></li></ul></li></ul><h4 id="消息认证码-MAC"><a href="#消息认证码-MAC" class="headerlink" title="消息认证码 MAC"></a>消息认证码 MAC</h4><ul><li><p>与加密的区别: MAC 算法不要求可逆性, 加密算法必须可逆.</p></li><li><p>双方共享密钥, MAC 不能提供数字签名.</p></li><li><p>与明文有关的认证: 先计算 MAC, 再加密.</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301707162.png" alt=""></p></li><li><p>与密文有关的认证: 先加密, 再计算 MAC.</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301707163.png" alt=""></p></li><li><p>认证和保密分开, 使得层次结构更灵活.</p><ul><li>可以在应用层提供认证, 而在传输层提供保密性.</li></ul></li></ul><h4 id="Hash-函数"><a href="#Hash-函数" class="headerlink" title="Hash 函数"></a>Hash 函数</h4><ul><li><p>Hash 码是消息认证码的一种变形, 不使用密钥, 具有错误检测能力.</p></li><li><p>Hash 码用于消息认证:</p><ul><li><p>Hash 码+对称密码: Hash 码提供认证所需的结构或冗余.</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301707164.png" alt=""></p></li><li><p>Hash 码+对称密码: 不要求保密性, 减少处理代价, 相当于 MAC.</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301707165.png" alt=""></p></li><li><p>Hash 码+公钥密码: 提供认证与数字签名.</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301707166.png" alt=""></p></li><li><p>Hash 码+对称密码+公钥密码: 提供认证、数字签名和保密性.</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301707167.png" alt=""></p></li><li><p>Hash 码+秘密值: 提供了认证.</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301707168.png" alt=""></p></li><li><p>Hash 码+秘密值+对称密码: 提供了认证和保密性.</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301707169.png" alt=""></p></li></ul></li><li><p>不要求保密性, 可不使用加密函数, 减少计算代价:</p><ul><li>加密软件速度慢.</li><li>加密硬件成本不容忽视.</li><li>加密硬件优化针对大数据块.</li></ul></li></ul><h3 id="安全-Hash-函数-迭代-Hash-函数-一般结构"><a href="#安全-Hash-函数-迭代-Hash-函数-一般结构" class="headerlink" title="安全 Hash 函数 (迭代 Hash 函数) 一般结构"></a>安全 Hash 函数 (迭代 Hash 函数) 一般结构</h3><ul><li><p>MD5, SHA-1 和 RIPEMD-160 都采用这种结构.</p></li><li><p>Hash 函数将输入分组, 最后分组不足时填充.</p></li><li><p>输入包含长度, 增加了攻击的难度.</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301707170.png" alt=""></p></li><li><p>压缩函数 f:</p><ul><li>输入: 前一步 n 位即连接变量和 b 位分组.</li><li>输出: 一个 n 位分组.</li><li>通常 b&gt;n, 称压缩函数.</li><li>连接变量初始值在算法开始时指定, 终值为 Hash 值.</li><li>设计安全 Hash 函数归纳为设计有抗碰撞能力 (计算不可行) 的压缩函数.</li></ul></li></ul><h3 id="常用-Hash-算法"><a href="#常用-Hash-算法" class="headerlink" title="常用 Hash 算法"></a>常用 Hash 算法</h3><ul><li>MD 族:<ul><li>MD2:<ul><li>数据 16 位补位, 附加 16 位检验和, 计算 128 位散列值.</li><li>如果忽略检验和, 产生 MD2 碰撞.</li></ul></li><li>MD4:<ul><li>利用一部个人电脑几分钟内找到 MD4 完整版本碰撞.</li></ul></li><li>MD5:<ul><li>王小云攻破 MD5 碰撞.</li></ul></li><li>RIPEMD-128/160/320.</li></ul></li><li>SHA 族: 根据 MD4 和 MD5 开发的算法.</li><li>HAVAL: 产生不同长度的哈希值, 允许用户指定轮数.</li></ul><h4 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h4><ul><li><p>算法结构:</p><ul><li>输入长度无限制.</li><li>分组长度 512 bits.</li><li>输出长度 128 bits.</li><li>四轮运算, 每轮 16 步迭代.</li></ul></li><li><p>设计目标:</p><ul><li>安全性: 找到摘要相同的消息计算上不可行.</li><li>速度: 算法有利于快速软件实现.</li><li>简洁性: 算法易于描述且易于编程.</li><li>倾向使用低端结构.</li></ul></li><li><p>算法步骤:</p><ul><li>增加填充位.</li><li>填充长度.</li><li>初始化 MD 缓存:<ul><li>中间结果和最终结果保存于 128 位缓冲区, 4 个 32 位寄存器.</li></ul></li><li>以 512 位分组处理消息:<ul><li>四轮运算组成的压缩函数是算法核心, 标记为 HMD5.</li><li>四轮运算结构相同, 各轮基本逻辑函数不同.</li><li>每轮对缓冲区 ABCD 进行 16 步迭代.</li></ul></li><li>输出.</li></ul></li><li><p>安全性:</p><ul><li>输出每一位都是输入每一位的函数.</li><li>基本逻辑函数复杂迭代使输出对输入依赖性小.</li><li>找到 Hash 码相同消息的代价是 $2^{64}$.</li><li><p>找到具有给定摘要消息的代价是 $2^{128}$.</p><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301707171.png" alt=""></p></li></ul></li></ul><h4 id="SHA"><a href="#SHA" class="headerlink" title="SHA"></a>SHA</h4><ul><li>建立在 MD4 之上:<ul><li>MD4 使用三轮运算, 每轮16步迭代.</li><li>MD4 第一轮运算没有使用加法常量, 第二轮、第三轮运算使用加法常量.</li><li>MD4 使用三个基本逻辑函数, 每轮运算使用一个.</li><li>MD4 没有每步迭代结果与前一步相加.</li></ul></li><li><p>算法结构:</p><ul><li>输入长度 $&lt;2^{64}$ bits.</li><li>分组长度 512 bits.</li><li>输出长度 160 bits.</li><li>四轮运算, 每轮 20 步迭代.</li></ul></li></ul><h4 id="RIPEMD-160"><a href="#RIPEMD-160" class="headerlink" title="RIPEMD-160"></a>RIPEMD-160</h4><ul><li>欧洲 RIPE 计划研究组设计.</li><li><p>算法结构:</p><ul><li>输入长度无限制.</li><li>分组长度 512 bits.</li><li>输出长度 160 bits.</li><li>五轮运算, 每轮 16 步迭代, 运行两次.</li></ul></li></ul><h4 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h4><ul><li><p>MD5 短, 易于受到强碰撞性攻击.</p></li><li><p>SHA-1 和 RIPEMD-160 对强碰撞性攻击安全.</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301707172.png" alt=""></p></li></ul><h3 id="数字签名算法-DSS"><a href="#数字签名算法-DSS" class="headerlink" title="数字签名算法 DSS"></a>数字签名算法 DSS</h3><ul><li><p>消息认证的局限性:</p><ul><li>可以保证通信双方不受第三方的攻击.</li><li>不能处理通信双方自身发生的攻击.</li></ul></li><li><p>数字签名:</p><ul><li>解决收发双方不能完全信任的情况.</li><li>特征:<ul><li>验证签名者、签名日期和时间.</li><li>认证被签的消息内容.</li><li>能由第三方仲裁解决争执.</li></ul></li></ul></li><li><p>直接数字签名:</p><ul><li>只涉及通信双方.</li><li>发送方用私钥对整个消息或 Hash 码加密来产生数字签名, 用接收方公钥和共享密钥对整个消息和签名加密, 获得保密性.</li><li>弱点: 方法有效性依赖于发送方私钥安全性.</li></ul></li><li><p>仲裁数字签名:</p><ul><li>发送方到接收方的已签名消息先发给仲裁者 A, 进行检查以验证消息源及内容, 然后加上日期, 指明该消息通过仲裁检验.</li><li>解决了直接数字签名的问题.</li></ul></li><li><p>数字签名标准 DSS:</p><ul><li>SHA-1 算法: 给出新的数字签名方法, 即数字签名算法 DSA.</li><li>公钥方法: 不能用于加密或密钥分配, 只提供数字签名 (与 RSA 不同).</li><li><p>算法步骤:</p><ul><li>发送方产生 Hash 码和随机数 k, 作为签名函数 Sig 输入.</li><li>签名函数依赖于发送方私钥和全局公钥.</li><li>签名函数保证拥有私钥的发送方才能产生有效签名.</li><li>签名由 s 和 r 两部分构成.</li><li>接收方产生 Hash码, 和签名作为验证函数 Ver 输入.</li><li>验证函数依赖于全局公钥和发送方公钥.</li><li>验证函数输出等于签名 r, 则签名有效.</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301707173.png" alt=""></p></li></ul></li></ul><h2 id="身份认证"><a href="#身份认证" class="headerlink" title="身份认证"></a>身份认证</h2><ul><li>身份认证: 在主客体交互行为过程中确认行为参与者身份.</li></ul><h3 id="电子身份认证概述"><a href="#电子身份认证概述" class="headerlink" title="电子身份认证概述"></a>电子身份认证概述</h3><ul><li><p>常见手段:</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301707174.png" style="zoom:50%;"></p></li></ul><h3 id="网站身份认证技术"><a href="#网站身份认证技术" class="headerlink" title="网站身份认证技术"></a>网站身份认证技术</h3><h4 id="HTTP-的-Basic-认证"><a href="#HTTP-的-Basic-认证" class="headerlink" title="HTTP 的 Basic 认证"></a>HTTP 的 Basic 认证</h4><ul><li>用户身份凭证为账号+静态口令.</li><li>HTTP 协议是面向一次连接的无状态网络协议.</li><li>每次明文发送 HTTP 请求到服务器端, 与存储的用户凭证进行比较.</li><li>优点: 交互简单.</li><li>缺点:<ul><li>明文传递账号和口令, 易被监听盗取.<ul><li>方法 1: 使用加密技术:<ul><li>口令作为密钥, 无法躲避重放攻击.</li></ul></li><li>方法 2: 使用消息认证技术:<ul><li>挑战/响应机制, 进行两次 HTTP 请求.</li><li>第一次: 服务器向客户端返回随机挑战码 M, 避免重放攻击.</li><li>第二次: 客户端发送 MAC 码, 服务器端进行验证.</li></ul></li></ul></li><li>本地长期保存账号和口令, 存在安全隐患.</li><li>服务器每次请求都要进行身份验证, 效率低.<ul><li>方法 3: 使用表单验证的 session 机制.</li></ul></li></ul></li></ul><h4 id="基于表单的身份认证"><a href="#基于表单的身份认证" class="headerlink" title="基于表单的身份认证"></a>基于表单的身份认证</h4><ul><li>Session 包括特定客户端、服务器端及操作时间段.</li><li>Session 工作原理:<ul><li>某个 Session 首次启用时, 服务器产生唯一标识符发到客户端.</li><li>标识符通常是随机字符串, 存于内存或本地文件.</li><li>客户端浏览器通常用 Cookie 技术存储标识符.</li><li>Session 存活期间, 客户端每次发送 HTTP 请求都会包含标识符.</li><li>Session 存活期间, 服务器通过标识符关联前后多次请求.</li><li>Session 结束, 服务器和客户端销毁上述标识符.</li></ul></li><li>基于表单的 Web 身份认证过程:<ul><li>客户端向服务器发送请求, 服务器返回包含表单的页面.</li><li>用户填写表单, 客户端把表单发送到服务器; 服务器进行验证, 通过则启动 Session 返回给客户端.</li><li>客户端后续请求包含 Session 标识符, 服务端验证标识符的合法性.<ul><li>通常基于哈希表数据结构.</li></ul></li></ul></li><li>缺点: 明文传输, 安全性低, 存在监听盗取可能.<ul><li>引入挑战/响应机制, 避免明文传输与重放攻击.</li><li>传输账号口令时, 使用传输层 SSL 协议传输 HTTP 请求.</li></ul></li><li>不安全做法: 把账号口令 (加密后) 以 Cookie 机制存放在浏览器端.<ul><li>口令泄露, 重放攻击.</li><li>存放内容加上时间戳, 服务器每次验证时间戳.</li></ul></li></ul><h4 id="增强认证"><a href="#增强认证" class="headerlink" title="增强认证"></a>增强认证</h4><ul><li>仅靠静态口令认证用户, 安全强度不足, 需要更高强度认证方式.</li><li>在静态口令基础上加上其他因素认证方式, 形成双因素或多因素认证.<ul><li>手机短信口令.</li><li>动态口令:<ul><li>VPN, 网上银行, 电子商务.</li><li>动态口令牌: 客户手持, 生成动态密码的终端.</li><li>基于时间同步方式, 每 n 秒变换一次有效动态口令.</li><li>基于计数器同步方式, 每次触发计数器累进时产生动态口令.</li></ul></li><li>USB KEY:<ul><li>USB 接口硬件设备, 内置单片机或智能芯片, 存储密钥或数字证书.</li><li>用于身份认证、数据加密和数字签名.</li><li>USB KEY 中私钥不可导出, 仅用于内置的加密或签名运算.</li><li>身份认证原理:<ul><li>服务器产生随机消息 M 送到 USB KEY.</li><li>USB KEY 用内部私钥对 M 签名.</li><li>服务器使用用户公钥验证签名.</li></ul></li></ul></li><li>数字证书:<ul><li>权威机构/证书授权中心 CA 数字签名发行的文件.</li><li>包含拥有者公钥、名称和 CA 数字签名.</li></ul></li></ul></li></ul>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;三、认证技术&quot;&gt;&lt;a href=&quot;#三、认证技术&quot; class=&quot;headerlink&quot; title=&quot;三、认证技术&quot;&gt;&lt;/a&gt;三、认证技术&lt;/h1&gt;&lt;h2 id=&quot;消息认证&quot;&gt;&lt;a href=&quot;#消息认证&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    <category term="CS" scheme="http://chengsx21.github.io/categories/CS/"/>
    
    <category term="Network Security" scheme="http://chengsx21.github.io/categories/CS/Network-Security/"/>
    
    
    <category term="Network Security" scheme="http://chengsx21.github.io/tags/Network-Security/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成原理 笔记5</title>
    <link href="http://chengsx21.github.io/2023/10/20/ji-suan-ji-zu-cheng-yuan-li-bi-ji-5/"/>
    <id>http://chengsx21.github.io/2023/10/20/ji-suan-ji-zu-cheng-yuan-li-bi-ji-5/</id>
    <published>2023-10-20T09:18:57.000Z</published>
    <updated>2024-06-30T09:53:39.690Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SRAM-控制器"><a href="#SRAM-控制器" class="headerlink" title="SRAM 控制器"></a>SRAM 控制器</h1><h2 id="SRAM"><a href="#SRAM" class="headerlink" title="SRAM"></a>SRAM</h2><h3 id="SRAM-的结构"><a href="#SRAM-的结构" class="headerlink" title="SRAM 的结构"></a>SRAM 的结构</h3><p>可以把 SRAM 想象成一个数组: <code>uint32_t sram[1048576]</code>, 即 1048576 个 32 位整数, 一共是 <code>32 * 1048576 / 8 = 4 MB</code> 的数据. 我们可以对其进行读和写的操作, 就好像 C 的代码: </p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token class-name">uint32_t</span> sram<span class="token punctuation">[</span><span class="token number">1048576</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">// read</span><span class="token class-name">uint32_t</span> read_data <span class="token operator">=</span> sram<span class="token punctuation">[</span>addr<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">// write</span>sram<span class="token punctuation">[</span>addr<span class="token punctuation">]</span> <span class="token operator">=</span> write_data<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以想象一下 SRAM 的工作流程, 假如有一个二维的矩阵, 一共有 1048576 个行, 每行有 32 列, 每一个矩阵元素就是 0 或者 1, 这样每一行就是一个 32 位整数. </p><p>无论是读还是写, 都有若干个步骤, 需要花费一定的时间, 这意味着在操作 SRAM 时需要按照一定的规则, 否则可能导致读取错误, 或没有成功写入等问题. </p><h3 id="SRAM-的信号"><a href="#SRAM-的信号" class="headerlink" title="SRAM 的信号"></a>SRAM 的信号</h3><p>顶层模块中有如下的信号: </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token comment">//BaseRAM信号</span><span class="token keyword">inout</span> <span class="token keyword">wire</span><span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> base_ram_data<span class="token punctuation">,</span>  <span class="token comment">//BaseRAM 数据</span><span class="token keyword">output</span> <span class="token keyword">wire</span><span class="token punctuation">[</span><span class="token number">19</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> base_ram_addr<span class="token punctuation">,</span> <span class="token comment">//BaseRAM 地址</span><span class="token keyword">output</span> <span class="token keyword">wire</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> base_ram_be_n<span class="token punctuation">,</span>  <span class="token comment">//BaseRAM 字节使能, 低有效, 默认为 0</span><span class="token keyword">output</span> <span class="token keyword">wire</span> base_ram_ce_n<span class="token punctuation">,</span>       <span class="token comment">//BaseRAM 片选, 低有效</span><span class="token keyword">output</span> <span class="token keyword">wire</span> base_ram_oe_n<span class="token punctuation">,</span>       <span class="token comment">//BaseRAM 读使能, 低有效</span><span class="token keyword">output</span> <span class="token keyword">wire</span> base_ram_we_n<span class="token punctuation">,</span>       <span class="token comment">//BaseRAM 写使能, 低有效</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这是 CPU 访问 SRAM 的途径. 实验板上一共有两组 SRAM, 我们称之为 <strong>BaseRAM</strong> 和 <strong>ExtRAM</strong>, 上面的信号是和 BaseRAM 进行连接的信号.</p><ol><li><code>inout wire [31:0] base_ram_data</code>: 读写的 32 位数据, 用的是同一组信号, <strong>同一时间只能进行读写其中一个</strong>.</li><li><code>output wire [19:0] base_ram_addr</code>: 地址线, 正好是 <code>uint32_t sram[1048576]</code> 的数组大小.</li><li><code>output wire [3:0] base_ram_be_n</code>: 字节使能, 目的是实现<strong>部分写入</strong>, 例如只想写入四个字节其中一个, 就把相应位设置为 <code>0</code>.</li><li><code>output wire base_ram_ce_n</code>: 片选使能, 需要保证 <code>base_ram_ce_n=0</code>; 如果 <code>base_ram_ce_n=1</code>, 就进入<strong>省电模式</strong>.</li><li><code>output wire base_ram_oe_n</code>: 输出使能, 读操作需保证 <code>base_ram_oe_n=0</code>, 此时 <code>base_ram_data</code> <strong>由 SRAM 输出</strong>; 写操作需保证 <code>base_ram_oe_n=1</code>, 此时 <code>base_ram_data</code> <strong>由 FPGA 输出</strong>.</li><li><code>output wire base_ram_we_n</code>: 写入使能, 读操作对应 <code>base_ram_we_n=1</code>, 写操作对应 <code>base_ram_we_n=0</code>.</li></ol><p>如果<strong>不考虑 SRAM 操作所需要的时间</strong>, 大概操作思路如下: </p><p>读操作:</p><ol><li>设置 <code>base_ram_addr</code> 为要读取的地址, 设置 <code>base_ram_be_n=0b0000</code>, <code>base_ram_ce_n=0</code>, <code>base_ram_oe_n=0</code>, <code>base_ram_we_n=1</code>.</li><li>等待读取完毕, 在 <code>base_ram_data</code> 上得到读取的数据.</li></ol><p>写操作:</p><ol><li>设置 <code>base_ram_addr</code> 为要写入的地址, 设置 <code>base_ram_ce_n=0</code>, <code>base_ram_oe_n=1</code>, <code>base_ram_we_n=0</code>, 根据要写入的字节数量设置 <code>base_ram_be_n</code>.</li><li>等待写入完毕.</li></ol><h3 id="SRAM-的时序"><a href="#SRAM-的时序" class="headerlink" title="SRAM 的时序"></a>SRAM 的时序</h3><p>SRAM 实际上读写需要经过几个步骤, 这意味着不能简单地直接给出信号, 完成读和写的操作. 接下来分析一下 SRAM 读写需要的具体步骤和相应的波形. </p><h4 id="读时序"><a href="#读时序" class="headerlink" title="读时序"></a>读时序</h4><p>SRAM 读取时, 首先找到相应的行, 再把一行的数据输出到 <code>base_ram_data</code> 上. 这一步需要大约一个周期的时间. 这意味着需要等待一个周期, 在第二个周期才可以得到读取的数据:</p><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301624677.png" alt=""></p><p>观察上面的波形: </p><ol><li>每次读取都需要等待一个周期. 等待的时候, <strong>地址保持不变</strong>.</li><li>读操作需要保持 <code>ce_n=0</code>, <code>oe_n=0</code>, <code>we_n=1</code>.</li><li>四个字节都读取, 于是设置 <code>be_n=0b0000</code>.</li><li>不需要读取的时候, 设置 <code>ce_n=1</code>.</li></ol><h4 id="写时序"><a href="#写时序" class="headerlink" title="写时序"></a>写时序</h4><p>SRAM 写入的过程较为复杂. 可能会只写入部分字节 (如 <code>be_n=0b1100</code>), SRAM 内部操作需要如下三个步骤: </p><ol><li>根据 <code>addr</code> 找到对应的行, 把一行的数据读取出来.</li><li>根据 <code>be_n</code> 计算出新的数据, 如原来保存的数据是 <code>0x12345678</code>, 新写入的数据是 <code>0x87654321</code>, 如果 <code>be_n=0b1100</code>, 则新的数据是 <code>0x12344321</code>.</li><li>把新的数据写入到行中.</li></ol><p>这三个步骤都用一个周期的时间来完成:</p><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301624678.png" alt=""></p><p>观察上面的波形: </p><ol><li>每次写入都需要三个周期, 这三个周期内, <strong>地址和数据保持不变</strong>.</li><li><code>we_n</code> 三个周期取值分别是 <code>1, 0, 1</code>.</li><li>写操作需要保持 <code>ce_n=0, oe_n=1</code>.</li><li>四个字节都写入, 设置 <code>be_n=0b0000</code>, 可以根据实际需要设置.</li><li>不需要写入的时候, 设置 <code>ce_n=1</code>.</li></ol><h2 id="Wishbone-总线协议"><a href="#Wishbone-总线协议" class="headerlink" title="Wishbone 总线协议"></a>Wishbone 总线协议</h2><h3 id="为什么需要总线协议"><a href="#为什么需要总线协议" class="headerlink" title="为什么需要总线协议"></a>为什么需要总线协议</h3><p>日常使用的电脑里有各种各样的部件, 例如键盘, 鼠标, 显示器, 无线网卡等等, 它们在操作系统里都是如何识别和管理的? 一些概念, 如 USB、PCIe 等, 用途是给 CPU 一个<strong>通用接口</strong>. 总线的功能:</p><ol><li>提供一个<strong>统一的硬件接口</strong>, 可以接入不同的<strong>硬件外设</strong>.</li><li>提供一个<strong>统一的软件接口</strong>, <strong>操作系统</strong>可以用同样的方式, 来操作这个总线下的所有外设.</li></ol><p>上面的 USB 总线和 PCIe 总线, 都是属于 <strong>CPU 片外</strong>的总线, 可以在主板上看到. 我们要实现 CPU 片内的总线, 目的是给 <strong>CPU 核心</strong>一个<strong>统一接口</strong>, 来访问内存或者外设.</p><h3 id="总线协议是什么"><a href="#总线协议是什么" class="headerlink" title="总线协议是什么"></a>总线协议是什么</h3><p><strong>从 CPU 到内存</strong>需要传输的信息:</p><ol><li>地址 <code>addr</code>:  按照内存的大小计算地址线的宽度, 例如 4GB 内存是 <code>2^32</code> 字节, 需要 32 位的地址.</li><li>写入的数据 <code>w_data</code>.</li><li>读还是写 <code>we</code>: 高表示写, 低表示读.</li></ol><p><strong>从内存到 CPU</strong> 需要传输的信息: </p><ol><li>读/写操作完成.</li><li>读取的数据 <code>r_data</code>.</li></ol><h3 id="如何设计一个总线协议"><a href="#如何设计一个总线协议" class="headerlink" title="如何设计一个总线协议"></a>如何设计一个总线协议</h3><p>当 CPU 不访问内存的时候, 可以让内存休息, 减少能耗. 因此需要设计一个控制信号 <code>valid</code>, 高表示 CPU 请求一次读写操作, 低表示不请求. </p><p>内存的访问相对 CPU 来说是很慢的, 需要一个机制, 让 CPU 等待内存的访问过程. 当 CPU 要进行读写操作时, 会设置 <code>valid=1</code>, 此时内存进行实际的内存操作, 一段时间后通知 CPU 操作完成, 同时返回结果. 于是添加一个信号 <code>ready</code>, 高表示内存完成一次读写操作, 低表示还没完成或者 CPU 没有请求. 当内存完成读写时, 设置 <code>ready=1</code>, 标志着一次读写操作的完成. </p><p>CPU 进行一次读写操作需要经历的过程: </p><ol><li>CPU 设置 <code>valid=1</code>, 内存开始读写操作.</li><li>内存完成操作以后, 设置 <code>ready=1</code>, 表示操作已经完成.</li><li>CPU 看到内存设置 <code>ready=1</code> 时, 知道操作已完成, 设置 <code>valid=0</code>.</li><li>CPU 下一次进行读写操作, 再从第一步开始.</li></ol><p>这种操作方式也可以用于 CPU 访问外设, 下面用 <strong>master</strong> 表示 <strong>CPU 端</strong>, 也就是发起请求的一端; 用 <strong>slave</strong> 表示<strong>设备端</strong>, 包括内存、外设等, 也就是处理请求的一端. 回到硬件, 综合以上的分析, 可以得到 <strong>master 端的信号</strong>, 约定 <code>_o</code> 表示输出, <code>_i</code> 表示输入:</p><ol><li><code>clock_i</code>: 时钟输入.</li><li><code>valid_o</code>: 高表示 master 想要发送请求.</li><li><code>ready_i</code>: 高表示 slave 完成处理请求.</li><li><code>addr_o</code>: master 想要读写的地址.</li><li><code>we_o</code>: master 想要读还是写.</li><li><code>data_o</code>: master 想要写入的数据.</li><li><code>be_o</code>: master 读写的字节使能, 用于实现单字节写等.</li><li><code>data_i</code>: slave 提供给 master 的读取的数据.</li></ol><p>根据设计的自研总线, 可以绘制出下面的波形图 (以 master 的信号为例): </p><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301624679.png" alt=""></p><ul><li><code>a</code> 周期: 此时 <code>valid_o=1 &amp;&amp; ready_i=1</code> 说明有请求发生, 此时 <code>we_o=1</code> 说明是一个写操作, 写入地址是 <code>addr_o=0x01</code>, 写入数据是 <code>data_o=0x12</code>.</li><li><code>b</code> 周期: 此时 <code>valid_o=0 &amp;&amp; ready_i=0</code> 说明无事发生.</li><li><code>c</code> 周期: 此时 <code>valid_o=1 &amp;&amp; ready_i=0</code> 说明 master 想从 <code>addr_o=0x02</code> 读取数据, 但是 slave 没有完成 <code>ready_i=0</code>.</li><li><code>d</code> 周期: 此时 <code>valid_o=1 &amp;&amp; ready_i=1</code> 说明有请求发生, master 从地址 <code>addr_o=0x02</code> 读取数据 <code>data_i=0x34</code>.</li><li><code>e</code> 周期: 此时 <code>valid_o=0 &amp;&amp; ready_i=0</code> 说明无事发生.</li><li><code>f</code> 周期: 此时 <code>valid_o=1 &amp;&amp; ready_i=1</code> 说明有请求发生, master 向地址 <code>addr_o=0x03</code> 写入数据 <code>data_i=0x56</code>.</li><li><code>g</code> 周期: 此时 <code>valid_o=1 &amp;&amp; ready_i=1</code> 说明有请求发生, master 从地址 <code>addr_o=0x01</code> 读取数据 <code>data_i=0x12</code>.</li><li><code>h</code> 周期: 此时 <code>valid_o=1 &amp;&amp; ready_i=1</code> 说明有请求发生, master 向地址 <code>addr_o=0x02</code> 写入数据 <code>data_i=0x9a</code>.</li></ul><p>从波形中有几点观察: </p><ol><li>master 发起请求时, 设置 <code>valid_o=1</code>; slave 可完成请求时, 设置 <code>ready_i=1</code>; 在 <code>valid_o=1 &amp;&amp; ready_i=1</code> 时请求完成, 进行下一个请求.</li><li>如果 master 发起请求, slave 不能接收请求, 即 <code>valid_o=1 &amp;&amp; ready_i=0</code>, 此时保持 <code>addr_o</code>, <code>we_o</code>, <code>data_o</code> 和 <code>be_o</code> 不变, 直到请求结束.</li><li>master 不发起请求时, 即 <code>valid_o=0</code>, 此时总线信号都视为无效数据, 不应该进行处理; 读操作只有在 <code>valid_o=1 &amp;&amp; ready_i=1</code> 时数据有效.</li><li>可以连续多个周期发生请求, 即 <code>valid_o=1 &amp;&amp; ready_i=1</code> 连续多个周期. 此时是理想情况, 可以达到总线最高的传输速度.</li></ol><h3 id="Wishbone-总线协议-1"><a href="#Wishbone-总线协议-1" class="headerlink" title="Wishbone 总线协议"></a>Wishbone 总线协议</h3><p>实践中很常用的总线协议 Wishbone 和上面自研的总线十分类似, 以 master 端为例: </p><ol><li><code>CLK_I</code>: 时钟输入, 即自研总线中的 <code>clock_i</code>.</li><li><code>STB_O</code>: 高表示 master 要发送请求, 即自研总线中的 <code>valid_o</code>.</li><li><code>ACK_I</code>: 高表示 slave 完成请求, 即自研总线中的 <code>ready_i</code>.</li><li><code>ADR_O</code>: master 想要读写的地址, 即自研总线中的 <code>addr_o</code>.</li><li><code>WE_O</code>: master 想要读还是写, 即自研总线中的 <code>we_o</code>.</li><li><code>DAT_O</code>: master 想要写入的数据, 即自研总线中的 <code>data_o</code>.</li><li><code>SEL_O</code>: master 读写的字节使能, 即自研总线中的 <code>be_o</code>.</li><li><code>DAT_I</code>: master 从 slave 读取的数据, 即自研总线中的 <code>data_i</code>.</li><li><code>CYC_O</code>: 总线的使能信号, 无对应的自研总线信号.</li></ol><p><code>CYC_O</code> 可以认为是 master 想要占用 slave 的总线接口, 在常见的使用场景下, 直接认为 <code>CYC_O=STB_O</code>: </p><ol><li>占用 slave 的总线接口, <strong>不允许其他 master 访问</strong>.</li><li>简化 interconnect 的实现.</li></ol><p>把自研总线的波形图改成 Wishbone: </p><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301624680.png" alt=""></p><p>建议 Wishbone 协议每次请求结束, master 拉低 <code>CYC_O</code> 和 <code>STB_O</code>, 因此不能像上面 <code>f-g-h</code> 连续三个周期发生请求. 好处: </p><ol><li>slave 实现简单, 例如状态机中拉高 <code>ACK</code> 后回到 <code>IDLE</code> 状态即可, 一些简单的 slave 也会默认 master 会在每个请求结束后拉低 <code>CYC_O</code> 和 <code>STB_O</code>.</li><li>防止一个 master 占用总线太长时间.</li><li>波形图上每个请求区分开来, 方便阅读. </li></ol><p>最后得到如下的波形:</p><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301624681.png" alt=""></p><h3 id="Wishbone-总线规范"><a href="#Wishbone-总线规范" class="headerlink" title="Wishbone 总线规范"></a>Wishbone 总线规范</h3><p>一个规范的 Wishbone Master 需要保证:</p><ol><li><strong>不能打断</strong>正在进行的请求: 上个周期 <code>CYC_O=1 &amp;&amp; STB_O=1 &amp;&amp; ACK_I=0</code>, 这个周期维持 <code>CYC_O=1 &amp;&amp; STB_O=1</code>.</li><li><strong>不能修改</strong>正在进行的请求: 上个周期 <code>CYC_O=1 &amp;&amp; STB_O=1 &amp;&amp; ACK_I=0</code>, 这个周期 <code>ADR_O, WE_O, DAT_O, SEL_O</code> 应和上个周期相同.</li><li><strong>仅在</strong> <code>CYC_O=1 &amp;&amp; STB_O=1 &amp;&amp; ACK_I=1</code> 时, Slave 提供的 <code>DAT_I</code> 信号有效, 其他取值不应影 Master 的行为.</li></ol><p>一个规范的 Wishbone Slave 需要保证: </p><ol><li><strong>仅在</strong> <code>CYC_I=1 &amp;&amp; STB_I=1</code> 时, Master 提供的 <code>ADR_I, WE_I, DAT_I, SEL_I</code> 信号有效, 其他取值不应影响 Slave 的行为.</li></ol><h2 id="Wishbone-SRAM-控制器"><a href="#Wishbone-SRAM-控制器" class="headerlink" title="Wishbone SRAM 控制器"></a>Wishbone SRAM 控制器</h2><h3 id="Wishbone-Slave"><a href="#Wishbone-Slave" class="headerlink" title="Wishbone Slave"></a>Wishbone Slave</h3><p>Wishbone 分为 Master 和 Slave 两端, 要实现 SRAM 的控制器处理请求 Slave, 回顾 Wishbone 总线协议 Slave 端的信号, 除时钟信号外, 都是输入变输出, 输出变输入:</p><ol><li><code>CLK_I</code>: 时钟输入, 即自研总线中的 <code>clock_i</code>.</li><li><code>STB_I</code>: 高表示 master 要发送请求, 即自研总线中的 <code>valid_o</code>.</li><li><code>ACK_O</code>: 高表示 slave 完成请求, 即自研总线中的 <code>ready_i</code>.</li><li><code>ADR_I</code>: master 想要读写的地址, 即自研总线中的 <code>addr_o</code>.</li><li><code>WE_I</code>: master 想要读还是写, 即自研总线中的 <code>we_o</code>.</li><li><code>DAT_I</code>: master 想要写入的数据, 即自研总线中的 <code>data_o</code>.</li><li><code>SEL_I</code>: master 读写的字节使能, 即自研总线中的 <code>be_o</code>.</li><li><code>DAT_O</code>: master 从 slave 读取的数据, 即自研总线中的 <code>data_i</code>.</li><li><code>CYC_I</code>: 总线的使能信号, 无对应的自研总线信号.</li></ol><p>Wishbone 要点: </p><ol><li>当 <code>STB_I=1, CYC_I=1</code> 时, 表示 master 正在发起请求.</li><li>当 <code>STB_I=1, CYC_I=1, ACK_O=1</code> 时, 表示 slave 完成了当前的请求.</li></ol><p>采用状态机: </p><ol><li>第一个状态 <code>IDLE</code>, 表示闲置.</li><li>当 <code>STB_I=1, CYC_I=1</code> 时, master 发起请求, 根据请求类型分别处理读和写, 需要状态 <code>READ</code> 和 <code>WRITE</code>.</li><li>读需要两个周期, 写需要三个周期, 添加状态 <code>READ_2</code>, <code>WRITE_2</code> 和 <code>WRITE_3</code>.</li><li>读写完成转移到 <code>DONE</code> 状态, 设置 <code>ACK_O=1</code>, 然后回到 <code>IDLE</code> 状态.</li></ol><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301624683.png" alt=""></p><p>在 SystemVerilog 中定义各个状态: </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">typedef</span> <span class="token keyword">enum</span> <span class="token keyword">logic</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">{</span>    STATE_IDLE <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>    STATE_READ <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span>    STATE_READ_2 <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span>    STATE_WRITE <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">,</span>    STATE_WRITE_2 <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">,</span>    STATE_WRITE_3 <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">,</span>    STATE_DONE <span class="token operator">=</span> <span class="token number">6</span><span class="token operator">}</span> state_t<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>写出状态转移表:</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog">state_t state<span class="token punctuation">;</span><span class="token important">always_ff @</span> <span class="token punctuation">(</span><span class="token keyword">posedge</span> clock<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>reset<span class="token punctuation">)</span> <span class="token keyword">begin</span>        state <span class="token operator">&lt;=</span> STATE_IDLE<span class="token punctuation">;</span>    <span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token keyword">begin</span>        <span class="token keyword">case</span> <span class="token punctuation">(</span>state<span class="token punctuation">)</span>            STATE_IDLE<span class="token punctuation">:</span> <span class="token keyword">begin</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>STB_I <span class="token operator">&amp;&amp;</span> CYC_I<span class="token punctuation">)</span> <span class="token keyword">begin</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>WE_I<span class="token punctuation">)</span> <span class="token keyword">begin</span>                        state <span class="token operator">&lt;=</span> STATE_WRITE<span class="token punctuation">;</span>                    <span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token keyword">begin</span>                        state <span class="token operator">&lt;=</span> STATE_READ<span class="token punctuation">;</span>                    <span class="token keyword">end</span>                <span class="token keyword">end</span>            <span class="token keyword">end</span>            STATE_READ<span class="token punctuation">:</span> <span class="token keyword">begin</span>                state <span class="token operator">&lt;=</span> STATE_READ_2<span class="token punctuation">;</span>            <span class="token keyword">end</span>            <span class="token comment">// ...</span>        <span class="token keyword">endcase</span>    <span class="token keyword">end</span><span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="SRAM-控制器-1"><a href="#SRAM-控制器-1" class="headerlink" title="SRAM 控制器"></a>SRAM 控制器</h3><p>在状态机的基础上实现 SRAM 控制器, 采用两周期读、三周期写的实现方式. </p><p>对于一次<strong>读操作</strong>, 需要经历如下的四个周期:</p><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301624684.png" alt=""></p><ol><li>(a): master 设置 <code>CYC_I=1</code>, <code>STB_I=1</code>, <code>WE_I=0</code>, 状态是 <code>IDLE</code>, 下个状态是 <code>READ</code>.</li><li>(b): 输出 <code>addr</code>, <code>oe_n=0</code>, <code>ce_n=0</code>, <code>we_n=1</code>, 根据 <code>SEL_I=0b1111</code> 可知四个字节都要读取, 输出 <code>be_n=0b0000</code>, 此时状态是 <code>READ</code>, 下一个状态是 <code>READ_2</code>.</li><li>(c): SRAM 返回了数据, 把数据保存到寄存器中, 此时状态是 <code>READ_2</code>, 下一个状态是 <code>DONE</code>.</li><li>(d): 输出 <code>ce_n=1</code>, <code>oe_n=1</code> 让 SRAM 恢复空闲状态, 设置 <code>ACK_O=1</code>, 此时请求完成, 状态是 <code>DONE</code>, 下一个状态是 <code>IDLE</code>.</li></ol><p>对于一次<strong>写操作</strong>, 需要经历如下五个周期: </p><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301624685.png" alt=""></p><ol><li>(a): master 设置 <code>CYC_I=1, STB_I=1, WE_I=1</code>, 此时状态是 <code>IDLE</code>, 下一个状态是 <code>WRITE</code>.</li><li>(b): 输出 <code>addr</code>, <code>data</code>, <code>oe_n=1</code>, <code>ce_n=0</code>, <code>we_n=1</code>, 根据 <code>SEL_I=0b1111</code> 可知四个字节都要写入, 输出 <code>be_n=0b0000</code>, 此时状态是 <code>WRITE</code>, 下一个状态是 <code>WRITE_2</code>.</li><li>(c): 输出 <code>we_n=0</code>, 此时状态是 <code>WRITE_2</code>, 下一个状态是 <code>WRITE_3</code>.</li><li>(d): 输出 <code>we_n=1</code>, 此时状态是 <code>WRITE_3</code>, 下一个状态是 <code>DONE</code>.</li><li>(e): 输出 <code>ce_n=1</code> 让 SRAM 恢复空闲状态, 设置 <code>ACK_O=1</code>, 此时请求完成, 状态是 <code>DONE</code>, 下一个状态是 <code>IDLE</code>.</li></ol><p>需要注意, Wishbone 的地址的单位是字节, 而 SRAM 的地址的单位是 4 字节, 地址有一个四倍的关系.</p><h3 id="状态机实现技巧"><a href="#状态机实现技巧" class="headerlink" title="状态机实现技巧"></a>状态机实现技巧</h3><p>以写操作为例子, 在上图 <code>b</code> 周期的时候, 状态从 <code>IDLE</code> 变成 <code>WRITE</code>, 并且 <code>ram_ce_n</code> 从 1 变为 0. 在时序逻辑 <code>always_ff @ (posedge clock)</code> 中更新 <code>state</code>: </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token important">always_ff @</span> <span class="token punctuation">(</span><span class="token keyword">posedge</span> clock<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token comment">// ...</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>STB_I <span class="token operator">&amp;&amp;</span> CYC_I<span class="token punctuation">)</span> <span class="token keyword">begin</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>WE_I<span class="token punctuation">)</span> <span class="token keyword">begin</span>            state <span class="token operator">&lt;=</span> STATE_WRITE<span class="token punctuation">;</span>        <span class="token keyword">end</span>    <span class="token keyword">end</span><span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如何修改 <code>ram_ce_n</code>? 一种思路是设定一个寄存器 <code>ram_ce_n_reg</code>, 把寄存器输出直接连接到 <code>ram_ce_n</code> 上. 此时需要保证进入 <code>WRITE</code> 状态时修改 <code>ram_ce_n_reg</code>, 保证 <code>ram_ce_n</code> 和 <code>state</code> 同时更新:</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">reg</span> ram_ce_n_reg<span class="token punctuation">;</span><span class="token important">always_ff @</span> <span class="token punctuation">(</span><span class="token keyword">posedge</span> clock<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>reset<span class="token punctuation">)</span> <span class="token keyword">begin</span>        state <span class="token operator">&lt;=</span> STATE_IDLE<span class="token punctuation">;</span>    <span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token keyword">begin</span>        <span class="token comment">// ...</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>STB_I <span class="token operator">&amp;&amp;</span> CYC_I <span class="token operator">&amp;&amp;</span> state <span class="token operator">==</span> STATE_IDLE<span class="token punctuation">)</span> <span class="token keyword">begin</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>WE_I<span class="token punctuation">)</span> <span class="token keyword">begin</span>                ram_ce_n_reg <span class="token operator">&lt;=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span>                state <span class="token operator">&lt;=</span> STATE_WRITE<span class="token punctuation">;</span>            <span class="token keyword">end</span>        <span class="token keyword">end</span>    <span class="token keyword">end</span><span class="token keyword">end</span><span class="token important">always_comb</span> <span class="token keyword">begin</span>  ram_ce_n <span class="token operator">=</span> ram_ce_n_reg<span class="token punctuation">;</span><span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>好处是从寄存器到输出的<strong>延迟很小</strong>, 适合用于<strong>访问外设</strong>的场景; 缺点是实现需要<strong>根据上一个周期的状态进行判断和更新</strong>, 如果状态比较复杂, 在每个转移的地方都需要相应地设置 <code>ram_ce_n_reg</code>.</p><p>另一种方式是用组合逻辑计算出当前的 <code>ram_ce_n</code>: </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token important">always_comb</span> <span class="token keyword">begin</span>    <span class="token comment">// default</span>    ram_ce_n <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>state <span class="token operator">==</span> STATE_WRITE<span class="token punctuation">)</span> <span class="token keyword">begin</span>        ram_ce_n <span class="token operator">=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span>    <span class="token keyword">end</span><span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样的好处是<strong>减少了寄存器的使用</strong>, 并且代码上比较简单; 缺点是把<strong>组合逻辑的延迟</strong>引入了输出的路径上, 可能会使得 SRAM 接口上的<strong>时序变得更长</strong>. </p><h3 id="SRAM-控制信号初始化"><a href="#SRAM-控制信号初始化" class="headerlink" title="SRAM 控制信号初始化"></a>SRAM 控制信号初始化</h3><p>实现 SRAM 控制器时, 在 FPGA 刚烧入 Bitstream 的时候, 状态机还没有初始化, 此时的 SRAM 控制信号 <code>ce_n</code>, <code>we_n</code> 和 <code>oe_n</code> 等可能处于 0, SRAM 就会认为此时的 FPGA 在进行写操作, 导致 SRAM 内的数据被覆盖. </p><p>解决方法是, 在 <code>initial</code> 和 <code>reset</code> 中对 SRAM 控制信号进行设置:</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">initial</span> <span class="token keyword">begin</span>    ram_ce_n_reg <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>    ram_oe_n_reg <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>    ram_we_n_reg <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token keyword">assign</span> ram_ce_n <span class="token operator">=</span> ram_ce_n_reg<span class="token punctuation">;</span><span class="token keyword">assign</span> ram_oe_n <span class="token operator">=</span> ram_oe_n_reg<span class="token punctuation">;</span><span class="token keyword">assign</span> ram_we_n <span class="token operator">=</span> ram_we_n_reg<span class="token punctuation">;</span><span class="token important">always @</span> <span class="token punctuation">(</span><span class="token keyword">posedge</span> clock<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>reset<span class="token punctuation">)</span> <span class="token keyword">begin</span>        ram_ce_n_reg <span class="token operator">&lt;=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>        ram_oe_n_reg <span class="token operator">&lt;=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>        ram_we_n_reg <span class="token operator">&lt;=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>    <span class="token keyword">end</span><span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="三态门"><a href="#三态门" class="headerlink" title="三态门"></a>三态门</h2><p>实现 SRAM 控制器会遇到这样的一个问题: 读写需要经过同样信号 <code>sram_data</code> 传输数据. 在一些接口协议中, 为节省引脚数量, 都出现了同一信号在不同时间传输不同方向数据的现象. 为防止两端设备同时输出, 设备在不输出信号时需要设置高阻态. 在 SystemVerilog 代码中, 通常将三态门 <code>signal_io</code> 拆分成三个信号: <code>signal_i</code>, <code>signal_o</code> 和 <code>signal_t</code>, 分别表示输入、输出和高阻态. 对应的代码如下: </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> tri_state_logic <span class="token punctuation">(</span>    <span class="token keyword">inout</span> signal_io<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">wire</span> signal_i<span class="token punctuation">;</span>    <span class="token keyword">wire</span> signal_o<span class="token punctuation">;</span>    <span class="token keyword">wire</span> signal_t<span class="token punctuation">;</span>    <span class="token keyword">assign</span> signal_io <span class="token operator">=</span> signal_t <span class="token operator">?</span> <span class="token number">1'bz</span> <span class="token punctuation">:</span> signal_o<span class="token punctuation">;</span>    <span class="token keyword">assign</span> signal_i <span class="token operator">=</span> signal_io<span class="token punctuation">;</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>内部可以方便地处理三态逻辑. 以 SRAM 为例, <code>sram_data</code> 需要按如下方式处理: </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> sram_controller <span class="token punctuation">(</span>    <span class="token keyword">inout</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> sram_data<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> sram_data_i_comb<span class="token punctuation">;</span>    <span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> sram_data_o_comb<span class="token punctuation">;</span>    <span class="token keyword">reg</span> sram_data_t_comb<span class="token punctuation">;</span>    <span class="token keyword">assign</span> sram_data <span class="token operator">=</span> sram_data_t_comb <span class="token operator">?</span> <span class="token number">32'bz</span> <span class="token punctuation">:</span> sram_data_o_comb<span class="token punctuation">;</span>    <span class="token keyword">assign</span> sram_data_i_comb <span class="token operator">=</span> sram_data<span class="token punctuation">;</span>    <span class="token important">always_comb</span> <span class="token keyword">begin</span>        sram_data_t_comb <span class="token operator">=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span>        sram_data_o_comb <span class="token operator">=</span> <span class="token number">32'b0</span><span class="token punctuation">;</span>        <span class="token comment">// ...</span>    <span class="token keyword">end</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当 <code>sram_data_t_comb=1</code> 时, 进入高阻态, 对应读操作, 读取的数据在 <code>sram_data_i_comb</code> 信号; 当 <code>sram_data_t_comb=0</code> 时, 进入输出状态, 对应写操作. 对 SRAM 控制器来说, 只需要在相应状态下设置 <code>sram_data_t_comb</code> 即可. </p><p>上面 <code>sram_data_o_comb</code> 和 <code>sram_data_t_comb</code> 也可改用寄存器结合状态机实现: </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> sram_controller <span class="token punctuation">(</span>    <span class="token keyword">inout</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> sram_data<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> sram_data_i_comb<span class="token punctuation">;</span>    <span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> sram_data_o_reg<span class="token punctuation">;</span>    <span class="token keyword">reg</span> sram_data_t_reg<span class="token punctuation">;</span>    <span class="token keyword">assign</span> sram_data <span class="token operator">=</span> sram_data_t_reg <span class="token operator">?</span> <span class="token number">32'bz</span> <span class="token punctuation">:</span> sram_data_o_reg<span class="token punctuation">;</span>    <span class="token keyword">assign</span> sram_data_i_comb <span class="token operator">=</span> sram_data<span class="token punctuation">;</span>    <span class="token important">always_ff @</span> <span class="token punctuation">(</span><span class="token keyword">posedge</span> clock<span class="token punctuation">)</span> <span class="token keyword">begin</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>reset<span class="token punctuation">)</span> <span class="token keyword">begin</span>            <span class="token comment">// high-Z when reset</span>            sram_data_t_reg <span class="token operator">&lt;=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>            sram_data_o_reg <span class="token operator">&lt;=</span> <span class="token number">32'b0</span><span class="token punctuation">;</span>            <span class="token comment">// ...</span>        <span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token keyword">begin</span>            <span class="token comment">// ...</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>STB_I <span class="token operator">&amp;&amp;</span> CYC_I <span class="token operator">&amp;&amp;</span> state <span class="token operator">==</span> STATE_IDLE<span class="token punctuation">)</span> <span class="token keyword">begin</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>WE_I<span class="token punctuation">)</span> <span class="token keyword">begin</span>                    <span class="token comment">// write</span>                    sram_data_t_reg <span class="token operator">&lt;=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span>                    sram_data_o_reg <span class="token operator">&lt;=</span> DAT_I<span class="token punctuation">;</span>                    state <span class="token operator">&lt;=</span> STATE_WRITE<span class="token punctuation">;</span>                <span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token keyword">begin</span>                    <span class="token comment">// read</span>                    sram_data_t_reg <span class="token operator">&lt;=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>                    state <span class="token operator">&lt;=</span> STATE_READ<span class="token punctuation">;</span>                <span class="token keyword">end</span>            <span class="token keyword">end</span>        <span class="token keyword">end</span>    <span class="token keyword">end</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;SRAM-控制器&quot;&gt;&lt;a href=&quot;#SRAM-控制器&quot; class=&quot;headerlink&quot; title=&quot;SRAM 控制器&quot;&gt;&lt;/a&gt;SRAM 控制器&lt;/h1&gt;&lt;h2 id=&quot;SRAM&quot;&gt;&lt;a href=&quot;#SRAM&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    <category term="CS" scheme="http://chengsx21.github.io/categories/CS/"/>
    
    <category term="Organization &amp; Design" scheme="http://chengsx21.github.io/categories/CS/Organization-Design/"/>
    
    
    <category term="Organization &amp; Design" scheme="http://chengsx21.github.io/tags/Organization-Design/"/>
    
    <category term="SV" scheme="http://chengsx21.github.io/tags/SV/"/>
    
  </entry>
  
  <entry>
    <title>编译原理 实验1</title>
    <link href="http://chengsx21.github.io/2023/10/17/bian-yi-yuan-li-lab-1/"/>
    <id>http://chengsx21.github.io/2023/10/17/bian-yi-yuan-li-lab-1/</id>
    <published>2023-10-17T09:18:57.000Z</published>
    <updated>2024-06-30T09:52:55.538Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Stage-1-报告"><a href="#Stage-1-报告" class="headerlink" title="Stage 1 报告"></a>Stage 1 报告</h1><h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><p>在 <code>utils/tac/tacop.py</code>, <code>utils/riscv.py</code> 的 <code>TacXXXOp</code> 和 <code>RvXXXOp</code> 类中添加运算符, 在 <code>frontend/tacgen/tacgen.py</code>, <code>backend/riscv/riscvasmemitter.py</code> 中的 <code>visitUnary</code> 和 <code>visitBinary</code> 方法实现运算符翻译与计算过程.</p><h3 id="step-2"><a href="#step-2" class="headerlink" title="step 2"></a>step 2</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># utils/tac/tacop.py</span><span class="token decorator annotation punctuation">@unique</span><span class="token keyword">class</span> <span class="token class-name">TacUnaryOp</span><span class="token punctuation">(</span>Enum<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    BIT_NOT <span class="token operator">=</span> auto<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># 取反</span>    LOGIC_NOT <span class="token operator">=</span> auto<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># 取非</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># utils/riscv.py</span><span class="token decorator annotation punctuation">@unique</span><span class="token keyword">class</span> <span class="token class-name">RvUnaryOp</span><span class="token punctuation">(</span>Enum<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    NOT <span class="token operator">=</span> auto<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># 取反, 为伪指令</span>    SEQZ <span class="token operator">=</span> auto<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># 取非, 为伪指令</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># frontend/tacgen/tacgen.py</span><span class="token keyword">def</span> <span class="token function">visitUnary</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> expr<span class="token punctuation">:</span> Unary<span class="token punctuation">,</span> mv<span class="token punctuation">:</span> TACFuncEmitter<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>    expr<span class="token punctuation">.</span>operand<span class="token punctuation">.</span>accept<span class="token punctuation">(</span>self<span class="token punctuation">,</span> mv<span class="token punctuation">)</span>    op <span class="token operator">=</span> <span class="token punctuation">{</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        node<span class="token punctuation">.</span>UnaryOp<span class="token punctuation">.</span>BitNot<span class="token punctuation">:</span> tacop<span class="token punctuation">.</span>TacUnaryOp<span class="token punctuation">.</span>BIT_NOT<span class="token punctuation">,</span>        node<span class="token punctuation">.</span>UnaryOp<span class="token punctuation">.</span>LogicNot<span class="token punctuation">:</span> tacop<span class="token punctuation">.</span>TacUnaryOp<span class="token punctuation">.</span>LOGIC_NOT<span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">[</span>expr<span class="token punctuation">.</span>op<span class="token punctuation">]</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># backend/riscv/riscvasmemitter.py</span><span class="token keyword">def</span> <span class="token function">visitUnary</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> instr<span class="token punctuation">:</span> Unary<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>    op <span class="token operator">=</span> <span class="token punctuation">{</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        TacUnaryOp<span class="token punctuation">.</span>BIT_NOT<span class="token punctuation">:</span> RvUnaryOp<span class="token punctuation">.</span>NOT<span class="token punctuation">,</span>        TacUnaryOp<span class="token punctuation">.</span>LOGIC_NOT<span class="token punctuation">:</span> RvUnaryOp<span class="token punctuation">.</span>SEQZ<span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">[</span>instr<span class="token punctuation">.</span>op<span class="token punctuation">]</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="step-3"><a href="#step-3" class="headerlink" title="step 3"></a>step 3</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># utils/tac/tacop.py</span><span class="token decorator annotation punctuation">@unique</span><span class="token keyword">class</span> <span class="token class-name">TacBinaryOp</span><span class="token punctuation">(</span>Enum<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    SUB <span class="token operator">=</span> auto<span class="token punctuation">(</span><span class="token punctuation">)</span>    MUL <span class="token operator">=</span> auto<span class="token punctuation">(</span><span class="token punctuation">)</span>    DIV <span class="token operator">=</span> auto<span class="token punctuation">(</span><span class="token punctuation">)</span>    MOD <span class="token operator">=</span> auto<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># utils/riscv.py</span><span class="token decorator annotation punctuation">@unique</span><span class="token keyword">class</span> <span class="token class-name">RvBinaryOp</span><span class="token punctuation">(</span>Enum<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    SUB <span class="token operator">=</span> auto<span class="token punctuation">(</span><span class="token punctuation">)</span>    MUL <span class="token operator">=</span> auto<span class="token punctuation">(</span><span class="token punctuation">)</span>    DIV <span class="token operator">=</span> auto<span class="token punctuation">(</span><span class="token punctuation">)</span>    REM <span class="token operator">=</span> auto<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># 取模</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># frontend/tacgen/tacgen.py</span><span class="token keyword">def</span> <span class="token function">visitBinary</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> expr<span class="token punctuation">:</span> Binary<span class="token punctuation">,</span> mv<span class="token punctuation">:</span> TACFuncEmitter<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    op <span class="token operator">=</span> <span class="token punctuation">{</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        node<span class="token punctuation">.</span>BinaryOp<span class="token punctuation">.</span>Sub<span class="token punctuation">:</span> tacop<span class="token punctuation">.</span>TacBinaryOp<span class="token punctuation">.</span>SUB<span class="token punctuation">,</span>        node<span class="token punctuation">.</span>BinaryOp<span class="token punctuation">.</span>Mul<span class="token punctuation">:</span> tacop<span class="token punctuation">.</span>TacBinaryOp<span class="token punctuation">.</span>MUL<span class="token punctuation">,</span>        node<span class="token punctuation">.</span>BinaryOp<span class="token punctuation">.</span>Div<span class="token punctuation">:</span> tacop<span class="token punctuation">.</span>TacBinaryOp<span class="token punctuation">.</span>DIV<span class="token punctuation">,</span>        node<span class="token punctuation">.</span>BinaryOp<span class="token punctuation">.</span>Mod<span class="token punctuation">:</span> tacop<span class="token punctuation">.</span>TacBinaryOp<span class="token punctuation">.</span>MOD<span class="token punctuation">,</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span><span class="token punctuation">[</span>expr<span class="token punctuation">.</span>op<span class="token punctuation">]</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># backend/riscv/riscvasmemitter.py</span><span class="token keyword">def</span> <span class="token function">visitBinary</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> instr<span class="token punctuation">:</span> Binary<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    op <span class="token operator">=</span> <span class="token punctuation">{</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        TacBinaryOp<span class="token punctuation">.</span>SUB<span class="token punctuation">:</span> RvBinaryOp<span class="token punctuation">.</span>SUB<span class="token punctuation">,</span>        TacBinaryOp<span class="token punctuation">.</span>MUL<span class="token punctuation">:</span> RvBinaryOp<span class="token punctuation">.</span>MUL<span class="token punctuation">,</span>        TacBinaryOp<span class="token punctuation">.</span>DIV<span class="token punctuation">:</span> RvBinaryOp<span class="token punctuation">.</span>DIV<span class="token punctuation">,</span>        TacBinaryOp<span class="token punctuation">.</span>MOD<span class="token punctuation">:</span> RvBinaryOp<span class="token punctuation">.</span>REM<span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">[</span>instr<span class="token punctuation">.</span>op<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="step-4"><a href="#step-4" class="headerlink" title="step 4"></a>step 4</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># utils/tac/tacop.py</span><span class="token decorator annotation punctuation">@unique</span><span class="token keyword">class</span> <span class="token class-name">TacBinaryOp</span><span class="token punctuation">(</span>Enum<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    LAND <span class="token operator">=</span> auto<span class="token punctuation">(</span><span class="token punctuation">)</span>    EQU <span class="token operator">=</span> auto<span class="token punctuation">(</span><span class="token punctuation">)</span>    NEQ <span class="token operator">=</span> auto<span class="token punctuation">(</span><span class="token punctuation">)</span>    SLT <span class="token operator">=</span> auto<span class="token punctuation">(</span><span class="token punctuation">)</span>    LEQ <span class="token operator">=</span> auto<span class="token punctuation">(</span><span class="token punctuation">)</span>    SGT <span class="token operator">=</span> auto<span class="token punctuation">(</span><span class="token punctuation">)</span>    GEQ <span class="token operator">=</span> auto<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># utils/riscv.py</span><span class="token decorator annotation punctuation">@unique</span><span class="token keyword">class</span> <span class="token class-name">RvUnaryOp</span><span class="token punctuation">(</span>Enum<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    SLTZ <span class="token operator">=</span> auto<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># 小于 0 则置位, 为伪指令</span>    SGTZ <span class="token operator">=</span> auto<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># 大于 0 则置位, 为伪指令</span><span class="token decorator annotation punctuation">@unique</span><span class="token keyword">class</span> <span class="token class-name">RvBinaryOp</span><span class="token punctuation">(</span>Enum<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    AND <span class="token operator">=</span> auto<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># 按位与</span>    SLT <span class="token operator">=</span> auto<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># 小于</span>    SGT <span class="token operator">=</span> auto<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># 大于</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># frontend/tacgen/tacgen.py</span><span class="token keyword">def</span> <span class="token function">visitBinary</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> expr<span class="token punctuation">:</span> Binary<span class="token punctuation">,</span> mv<span class="token punctuation">:</span> TACFuncEmitter<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    op <span class="token operator">=</span> <span class="token punctuation">{</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        node<span class="token punctuation">.</span>BinaryOp<span class="token punctuation">.</span>LogicAnd<span class="token punctuation">:</span> tacop<span class="token punctuation">.</span>TacBinaryOp<span class="token punctuation">.</span>LAND<span class="token punctuation">,</span>        node<span class="token punctuation">.</span>BinaryOp<span class="token punctuation">.</span>EQ<span class="token punctuation">:</span> tacop<span class="token punctuation">.</span>TacBinaryOp<span class="token punctuation">.</span>EQU<span class="token punctuation">,</span>        node<span class="token punctuation">.</span>BinaryOp<span class="token punctuation">.</span>NE<span class="token punctuation">:</span> tacop<span class="token punctuation">.</span>TacBinaryOp<span class="token punctuation">.</span>NEQ<span class="token punctuation">,</span>        node<span class="token punctuation">.</span>BinaryOp<span class="token punctuation">.</span>LT<span class="token punctuation">:</span> tacop<span class="token punctuation">.</span>TacBinaryOp<span class="token punctuation">.</span>SLT<span class="token punctuation">,</span>        node<span class="token punctuation">.</span>BinaryOp<span class="token punctuation">.</span>GT<span class="token punctuation">:</span> tacop<span class="token punctuation">.</span>TacBinaryOp<span class="token punctuation">.</span>SGT<span class="token punctuation">,</span>        node<span class="token punctuation">.</span>BinaryOp<span class="token punctuation">.</span>LE<span class="token punctuation">:</span> tacop<span class="token punctuation">.</span>TacBinaryOp<span class="token punctuation">.</span>LEQ<span class="token punctuation">,</span>        node<span class="token punctuation">.</span>BinaryOp<span class="token punctuation">.</span>GE<span class="token punctuation">:</span> tacop<span class="token punctuation">.</span>TacBinaryOp<span class="token punctuation">.</span>GEQ<span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">[</span>expr<span class="token punctuation">.</span>op<span class="token punctuation">]</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># backend/riscv/riscvasmemitter.py</span><span class="token keyword">def</span> <span class="token function">visitBinary</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> instr<span class="token punctuation">:</span> Binary<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>  <span class="token comment"># 特殊 Tac 操作符与对应操作</span>    <span class="token comment"># 利用了 [https://godbolt.org/] 给出的结果</span>    <span class="token keyword">if</span> instr<span class="token punctuation">.</span>op <span class="token operator">==</span> TacBinaryOp<span class="token punctuation">.</span>LOR<span class="token punctuation">:</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">elif</span> instr<span class="token punctuation">.</span>op <span class="token operator">==</span> TacBinaryOp<span class="token punctuation">.</span>LAND<span class="token punctuation">:</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">elif</span> instr<span class="token punctuation">.</span>op <span class="token operator">==</span> TacBinaryOp<span class="token punctuation">.</span>EQU<span class="token punctuation">:</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">elif</span> instr<span class="token punctuation">.</span>op <span class="token operator">==</span> TacBinaryOp<span class="token punctuation">.</span>NEQ<span class="token punctuation">:</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">elif</span> instr<span class="token punctuation">.</span>op <span class="token operator">==</span> TacBinaryOp<span class="token punctuation">.</span>LEQ<span class="token punctuation">:</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">elif</span> instr<span class="token punctuation">.</span>op <span class="token operator">==</span> TacBinaryOp<span class="token punctuation">.</span>GEQ<span class="token punctuation">:</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        op <span class="token operator">=</span> <span class="token punctuation">{</span>            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>          <span class="token comment"># 只有这两条 Tac 指令无需使用其他 riscv 指令翻译</span>            TacBinaryOp<span class="token punctuation">.</span>SLT<span class="token punctuation">:</span> RvBinaryOp<span class="token punctuation">.</span>SLT<span class="token punctuation">,</span>            TacBinaryOp<span class="token punctuation">.</span>SGT<span class="token punctuation">:</span> RvBinaryOp<span class="token punctuation">.</span>SGT<span class="token punctuation">,</span>        <span class="token punctuation">}</span><span class="token punctuation">[</span>instr<span class="token punctuation">.</span>op<span class="token punctuation">]</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><h3 id="step-1"><a href="#step-1" class="headerlink" title="step 1"></a>step 1</h3><ol><li><p>在我们的框架中, 从 AST 向 TAC 的转换经过了 <code>namer.transform</code>, <code>typer.transform</code>两个步骤, 如果没有这两个步骤, 以下代码能正常编译吗, 为什么?</p> <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p> <strong>答:</strong> 能正常编译. 这两个步骤用于<strong>语义分析</strong>阶段实现<strong>符号表构建</strong>和<strong>类型检查</strong>, 主要作用是解析标识符的声明和引用, 将其存储在符号表中, 验证语句和表达式操作是否符合类型规则. 这段代码并没有涉及函数或变量等标识符的使用, 因此没有这两个步骤这段代码依旧可以<strong>正常编译</strong>.</p></li><li><p>我们的框架现在对于 main 函数没有返回值的情况是在哪一步处理的? 报的是什么错? </p><p> <strong>答:</strong> 在 <code>frontend/parser/ply_parser.py</code> 进行语法分析时处理, 报错为</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Syntax error: line <span class="token number">2</span>, <span class="token function">column</span> <span class="token number">11</span>    <span class="token builtin class-name">return</span><span class="token punctuation">;</span>Syntax error: line <span class="token number">3</span>, <span class="token function">column</span> <span class="token number">1</span><span class="token punctuation">}</span>Syntax error: EOF<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>为什么框架定义了 <code>frontend/ast/tree.py:Unary</code>、<code>utils/tac/tacop.py:TacUnaryOp</code>、<code>utils/riscv.py:RvUnaryOp</code> 三种不同的一元运算符类型?</p><p> <strong>答:</strong> 在编译器框架中, 三种不同的一元运算符类型用于不同的编译器阶段和组件, 以适应不同层次的运算符表示和需求:</p><ul><li><code>Unary</code> 用于 AST 表示, 进行语法分析和语义分析.</li><li><code>TacUnaryOp</code> 用于 TAC 表示, 进行中间代码生成.</li><li><p><code>RvUnaryOp</code> 用于 RISC-V 表示, 进行目标代码生成.</p><p>不同阶段所需的一元运算符类型不完全相同 (如取模运算的 <code>BinaryOp.Mod</code>, <code>TacBinaryOp.MOD</code>, <code>RvUnaryOp.REM</code> ), 需要经过相应的转化翻译过程, 这么分离定义可以实现有助于模块化和灵活性, 使不同阶段独立处理运算符. </p></li></ul></li></ol><h3 id="step-2-1"><a href="#step-2-1" class="headerlink" title="step 2"></a>step 2</h3><ol><li><p>我们在语义规范中规定整数运算越界是未定义行为, 运算越界可以简单理解成理论上的运算结果没有办法保存在 32 位整数的空间中, 必须截断高于32位的内容. 请设计一个 minidecaf 表达式, 只使用 <code>-~!</code> 这三个单目运算符和从 0 到 2147483647 范围内的非负整数, 使得运算过程中发生越界.</p><p> <strong>答:</strong> 设计如下:</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">-~2147483647<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h3 id="step-3-1"><a href="#step-3-1" class="headerlink" title="step 3"></a>step 3</h3><ol><li><p>我们知道 “除数为零的除法是未定义行为”, 但是即使除法的右操作数不是 0, 仍然可能存在未定义行为. 请问这时除法的左操作数和右操作数分别是什么? 请将这时除法的左操作数和右操作数填入下面的代码中, 分别在你的电脑 (请标明你的电脑的架构, 比如 x86-64 或 ARM) 中和 RISCV-32 的 qemu 模拟器中编译运行下面的代码, 并给出运行结果 (编译时请不要开启任何编译优化).</p> <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> a <span class="token operator">=</span> 左操作数<span class="token punctuation">;</span>    <span class="token keyword">int</span> b <span class="token operator">=</span> 右操作数<span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> a <span class="token operator">/</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> <strong>答:</strong> 左操作数为 <code>-2147483648</code>, 右操作数为 <code>-1</code>.</p> <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">2147483648</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> a <span class="token operator">/</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 电脑架构为 Arm64, 使用 clang 编译运行代码, 结果为 <code>-2147483648</code>;</p><p> 使用 RISCV-32 的 qemu 模拟器编译运行代码, 结果为 <code>-2147483648</code>.</p></li></ol><h3 id="step-4-1"><a href="#step-4-1" class="headerlink" title="step 4"></a>step 4</h3><ol><li><p>在 MiniDecaf 中, 我们对于短路求值未做要求, 但在包括 C 语言的大多数流行的语言中, 短路求值都是被支持的. 为何这一特性广受欢迎? 你认为短路求值这一特性会给程序员带来怎样的好处?</p><p> <strong>答:</strong> 短路求值是一种逻辑表达式计算策略, 当第一个运算数无法确定逻辑运算的结果时, 才对第二个运算数进行求值. 这一特性广受欢迎, 有以下好处:</p><ul><li><strong>效率</strong>：使用逻辑运算符连接多个布尔表达式时, 如果第一个表达式确定了结果, 那么后面的表达式不会被计算. 涉及到昂贵的计算或函数调用时, 使用短路求值可以免去表达式执行成本, 提高运行效率.</li><li><strong>安全性</strong>：表达式的计算可能具有副作用, 如修改变量的值或执行其他操作, 短路求值确保这些副作用只在需要时才会发生. 如右表达式需要依赖左表达式的成立, 支持短路求值后可以在左表达式不成立后避免错误计算右表达式.</li><li><strong>自然</strong>：短路求值可以避免深度嵌套的条件语句, 编写更简洁易读的代码, 使得程序员能够更自由地表达各种逻辑关系和条件.</li></ul></li></ol>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;Stage-1-报告&quot;&gt;&lt;a href=&quot;#Stage-1-报告&quot; class=&quot;headerlink&quot; title=&quot;Stage 1 报告&quot;&gt;&lt;/a&gt;Stage 1 报告&lt;/h1&gt;&lt;h2 id=&quot;实验内容&quot;&gt;&lt;a href=&quot;#实验内容&quot;</summary>
        
      
    
    
    
    <category term="CS" scheme="http://chengsx21.github.io/categories/CS/"/>
    
    <category term="Compiler" scheme="http://chengsx21.github.io/categories/CS/Compiler/"/>
    
    
    <category term="Compiler" scheme="http://chengsx21.github.io/tags/Compiler/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络安全技术 笔记2</title>
    <link href="http://chengsx21.github.io/2023/10/04/ji-suan-ji-wang-luo-an-quan-ji-zhu-bi-ji-2/"/>
    <id>http://chengsx21.github.io/2023/10/04/ji-suan-ji-wang-luo-an-quan-ji-zhu-bi-ji-2/</id>
    <published>2023-10-04T09:18:57.000Z</published>
    <updated>2024-06-30T09:49:13.953Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二、密码学基础"><a href="#二、密码学基础" class="headerlink" title="二、密码学基础"></a>二、密码学基础</h1><h2 id="初识密码"><a href="#初识密码" class="headerlink" title="初识密码"></a>初识密码</h2><h3 id="与人类共生"><a href="#与人类共生" class="headerlink" title="与人类共生"></a>与人类共生</h3><ul><li>密码: 用来混淆的技术, 不同于隐藏、访问控制.</li></ul><h3 id="密码基本概念"><a href="#密码基本概念" class="headerlink" title="密码基本概念"></a>密码基本概念</h3><ul><li>传统加密:<ul><li>对称加密、单钥加密.</li><li>代换密码、置换密码及二者组合.</li><li>安全性在于保持算法本身的保密性</li><li>不适合大规模生产, 用户无法了解算法的安全性.</li></ul></li><li>现代加密:<ul><li>非对称加密、公钥加密, 1976 年第一次公开发表.</li><li>密码算法公开，密钥保密.</li><li>安全性在于保持密钥的保密性.</li><li>适于大规模生产.</li></ul></li><li>密码学:<ul><li>密码编码学: 研究加密方案的学科.</li><li>密码分析学: 研究破译密码获得消息.</li><li>统称为密码学.</li></ul></li><li>密码编码学系统的三个独立的特征:<ul><li>转换明文为密文的运算类型:<ul><li>置换和代换, 不允许丢失信息.</li></ul></li><li>所用的密钥数:<ul><li>密钥相同/不同——对称密码/非对称密码.</li></ul></li><li>处理明文的方法:<ul><li>分组密码/块密码: 处理分组.</li><li>流密码/序列密码: 连续处理元素.</li></ul></li></ul></li><li>无条件安全: 无论有多少密文, 都不足以唯一确定对应的明文.</li><li>计算安全:<ul><li>破译代价超过密文的价值.</li><li>破译时间超过密文的生命期.</li></ul></li></ul><h3 id="密码发展历程"><a href="#密码发展历程" class="headerlink" title="密码发展历程"></a>密码发展历程</h3><ul><li>第 1 阶段: 古典密码 (1949 年前)<ul><li>安全基于算法的保密, 密码学不是科学而是艺术.</li><li>算法基本手段是代换和置换, 针对字符.</li><li>简单的密码分析手段.</li></ul></li><li>第 2 阶段: 近代密码<ul><li>计算机——复杂密码计算.</li><li>有线电报——现代密码编码学.</li><li>无线电报——现代密码分析学.</li><li>现代密码学的原理 (Kerchoffs):<ul><li>加密体系安全性依赖于使用的密匙.</li><li>古典密码和现代密码的分界线.</li></ul></li><li>香农发表《保密通信的信息理论》论文, 密码学成为一门科学.</li></ul></li><li>第 3 阶段: 现代密码<ul><li>公钥密码:<ul><li>无密钥传输的保密通信成为可能</li><li>1976年, Diffie &amp; Hellman 提出公钥密码体制.</li><li>1977年, Rivest &amp; Shamir &amp; Adleman 提出 RSA 公钥算法.</li></ul></li><li>对称密码:<ul><li>1977年, 美国实施公开的 DES 对称加密算法.</li></ul></li></ul></li></ul><h2 id="古典密码"><a href="#古典密码" class="headerlink" title="古典密码"></a>古典密码</h2><h3 id="代换技术"><a href="#代换技术" class="headerlink" title="代换技术"></a>代换技术</h3><ul><li><p>单表代换密码:</p><ul><li>Casear 密码, 密钥词密码.</li><li>明文语法模式和结构被保留, 密穷举攻击破译.</li></ul></li><li><p>多表代换密码:</p><ul><li><p>Playfair 密码:</p><ul><li>一次加密两个字母.</li><li>基于由密钥词构成的 5×5 字母矩阵.</li><li>保留了明文语言的结构.</li></ul></li><li><p>Hill 密码:</p><ul><li>加密过程: $C=KP\pmod{26}$.</li><li><p>解密过程: $P=K^{-1}C\pmod{26}$.</p></li><li><p>隐蔽单字母的频率特性.</p></li></ul></li><li><p>Vigenere 密码:</p><ul><li><p>一系列 Casear 密码.</p></li><li><p>隐藏了字母频率信息.</p></li><li><p>并非所有的明文结构都被隐藏.</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301657178.png" alt=""></p></li></ul></li><li><p>Verman 密码和一次一密:</p><ul><li><p>随机密钥与消息一样长且无重复.</p></li><li><p>运算基于二进制数据.</p></li><li><p>无条件安全.</p></li><li><p>局限性: </p><ul><li>产生大规模随机密钥很困难.</li><li><p>密钥的分配和保护很困难.</p><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301657179.png" alt=""></p></li></ul></li></ul></li></ul></li></ul><h3 id="置换技术"><a href="#置换技术" class="headerlink" title="置换技术"></a>置换技术</h3><ul><li>置换形成新的排列.<ul><li>栅栏技术.</li><li>转轮机.</li></ul></li></ul><h3 id="破译举例"><a href="#破译举例" class="headerlink" title="破译举例"></a>破译举例</h3><ul><li>穷举法/频率分析法.</li></ul><h2 id="对称密码算法"><a href="#对称密码算法" class="headerlink" title="对称密码算法"></a>对称密码算法</h2><ul><li>加密解密的密钥相同.</li><li>使用秘密信道分配密钥.</li></ul><h3 id="S-DES-算法"><a href="#S-DES-算法" class="headerlink" title="S-DES 算法"></a>S-DES 算法</h3><ul><li><p>示例:</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301657180.png" style="zoom:50%;"></p></li></ul><h3 id="Feistel-密码结构"><a href="#Feistel-密码结构" class="headerlink" title="Feistel 密码结构"></a>Feistel 密码结构</h3><ul><li><p>流密码:</p><ul><li>每次加密数据流一位或一字节.</li><li>Vigenere 密码和 Verman 密码.</li></ul></li><li><p>分组密码:</p><ul><li>明文组整体加密, 得到等长密文组.</li><li>大多数对称密码使用分组密码.</li><li>现行的对称分组密码基于 Feistel 分组密码结构.</li></ul></li><li><p>Feistel 分组密码结构:</p><ul><li><p>使用乘积密码的概念逼近简单代换密码, 依次使用两个或以上的基本密码.</p></li><li><p>交替使用代换和置换.</p></li><li><p>是香农提出的交替使用混淆和扩散乘积密码的实际应用.</p></li><li><p>几乎所有传统分组密码结构都和 Feistel Cipher 类似.</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301657181.png" style="zoom: 50%;"></p><ul><li>输入: 第 i 轮迭代输入来自上轮迭代输出.</li><li>子密钥: 由密钥 K 推导出来.</li><li>轮函数: 每轮迭代相同, 输入的子密钥不同.</li><li>代换: 数据左半部分, 轮函数 F 作用在右半部分, 与左半部分异或.</li><li>置换: 代换后交换数据左右两半.</li></ul></li><li><p>影响参数: 迭代轮数, 分组和密钥长度, 子密钥产生算法, 轮函数.</p></li></ul></li><li><p>混淆和扩散:</p><ul><li>刻画密码系统的两个基本构件, 现代分组密码设计的里程碑.</li><li>挫败基于统计方法的密码分析.</li><li>扩散: 使明文的统计特征消散在密文中, 每个明文数字影响多个密文数字.</li><li>混淆: 使密文和密钥的统计关系更复杂, 挫败推导密钥的企图</li></ul></li></ul><h3 id="DES-算法"><a href="#DES-算法" class="headerlink" title="DES 算法"></a>DES 算法</h3><ul><li><p>算法结构:</p><ul><li>密钥长度 56 bits, 加上奇偶校验写成 64 bits.</li><li>分组长度 64 bits.</li><li>迭代轮数 16 轮.</li><li>初始置换 $IP$.</li><li>末尾置换 $IP^{-1}$.</li></ul></li><li><p>除初始置换和末尾置换, DES 结构与 Feistel 结构完全相同.</p></li><li><p>子密钥生成:</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301657182.png" style="zoom:50%;"></p></li><li><p>一轮迭代:</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301657183.png" style="zoom:50%;"></p></li><li><p>解密过程: 与加密过程完全相似, 将 16 次迭代的子密钥顺序倒过来.</p></li></ul><h3 id="常用对称密码"><a href="#常用对称密码" class="headerlink" title="常用对称密码"></a>常用对称密码</h3><ul><li><p>3-DES:</p><ul><li><p>两个密钥 $K_1K_2$, 长度为 112 比特, 明文攻击代价为 $2^{112}$ 数量级.</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301657184.png" style="zoom:50%;"></p></li></ul></li><li><p>Blowfish:</p><ul><li><p>算法结构:</p><ul><li>密钥长度 32-448 bits.</li><li>分组长度 64 bits.</li><li>迭代轮数 16 轮.</li><li>基本运算: 模 $2^{23}$ 加法与按位异或.</li></ul></li><li><p>F 映射包含四个 S 盒运算, 子密钥和 S 盒由算法本身生成, 数据不可辨认, 密钥分析困难.</p></li><li><p>与古典 Feistel 结构不同, 每轮运算对左右部分同时进行, 强度增强.</p></li><li><p>密钥长度可抵抗穷举攻击, 安全性未受挑战.</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301657185.png" style="zoom:50%;"></p></li></ul></li><li><p>RC5:</p><ul><li><p>算法结构:</p><ul><li>密钥长度 0-2040 bits.</li><li>分组长度 32/64/128 bits.</li><li>迭代轮数不定.</li><li><p>基本运算: 模 $2^{w}$ 加法, 按位异或与循环左移.</p><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301657186.png" style="zoom:50%;"></p></li></ul></li></ul></li><li><p>AES:</p><ul><li><p>3DES 的缺点: 软件实现速度慢, 分组长度过小.</p></li><li><p>算法结构:</p><ul><li>密钥长度 128 bits.</li><li>分组长度 128 bits.</li><li>迭代轮数 10 轮.</li></ul></li><li><p>不是 Feistel 结构, 每一轮都使用代换和置换并行处理分组.</p></li><li><p>算法过程:</p><ul><li>字节代换: S 盒.</li><li>行移位: 置换.</li><li>列混淆: 代换.</li><li><p>轮密钥加: 按位异或.</p><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301657187.png" style="zoom:50%;"></p></li></ul></li></ul></li><li><p>其他对称密码算法:</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301657188.png" alt=""></p></li></ul><h2 id="非对称密码算法"><a href="#非对称密码算法" class="headerlink" title="非对称密码算法"></a>非对称密码算法</h2><h3 id="公钥密码原理"><a href="#公钥密码原理" class="headerlink" title="公钥密码原理"></a>公钥密码原理</h3><ul><li><p>对称密钥密码的缺陷:</p><ul><li>安全的信道分配密钥.</li><li>无法用于数字签名.</li><li>管理复杂, 密钥的数量 $O(n^2)$.</li></ul></li><li><p>公钥密码:</p><ul><li>密码学历史上唯一一次真正的革命.</li><li>基于数学函数而非代换和置换.</li><li>基于陷门单向函数的概念, 不知陷门信息下求逆困难.</li><li>公钥公开, 存于寄存器或文件, 加密和验证签名.</li><li>私钥保密, 解密和签名.</li><li>系统控制私钥, 通信就是安全的.</li><li>系统可以改变私钥, 公布相应的公钥代替.</li></ul></li><li><p>加密原理/签名原理.</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301657189.png" alt=""></p></li><li><p>用途:</p><ul><li>加密/解密.</li><li>数字签名.</li><li><p>密钥交换: 协商会话密钥, 用于对称密钥加密.</p><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301657190.png" alt=""></p></li><li><p>实际应用中目前局限于数字签名和密钥管理.</p></li></ul></li><li><p>误解:</p><ul><li>密码分析角度看, 公钥密码比传统密码更安全.<ul><li>加密安全性依赖于密钥长度和破译所需计算量.</li></ul></li><li>公钥密码是通用方法, 传统密码已过时.<ul><li>公钥密码需大量计算, 仅限密钥管理和签名, 难以取代传统密码.</li></ul></li><li>传统密码与密钥分配中心的握手很麻烦, 公钥密码实现密钥分配很简单.<ul><li>公钥密码也需协议和中心代理, 处理过程不比传统密码简单有效.</li></ul></li></ul></li></ul><h3 id="RSA-算法"><a href="#RSA-算法" class="headerlink" title="RSA 算法"></a>RSA 算法</h3><ul><li><p>1978 年首次发表.</p></li><li><p>是最早满足要求、广泛接受并实现的通用公钥分组密码算法.</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301707156.png" style="zoom: 50%;"></p></li><li><p>攻击方法:</p><ul><li>蛮力攻击.</li><li>数学攻击: 因子分解.</li><li>计时攻击：记录解密消息所用的时间, 来确定私钥.<ul><li>不仅可以攻击 RSA, 还可攻击其它公钥密码系统.</li><li>完全不可预知性, 仅依赖明文, 有很大的威胁.</li></ul></li></ul></li></ul><h3 id="DH-密钥交换算法"><a href="#DH-密钥交换算法" class="headerlink" title="DH 密钥交换算法"></a>DH 密钥交换算法</h3><ul><li><p>局限性: 只进行密钥交换.</p></li><li><p>有效性: 计算离散对数非常困难.</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301707158.png" alt=""></p></li></ul><h3 id="DSA-算法"><a href="#DSA-算法" class="headerlink" title="DSA 算法"></a>DSA 算法</h3><ul><li>数字签名算法, 用于数字签名标准 DSS.</li><li>安全性: 计算离散对数非常困难.</li><li>局限性:<ul><li>只用于数字签名, 不能加密或密钥分配.</li><li>由 NIST 研制的, 可能有后门.</li><li>选择过程不公开, 提供的分析时间不充分.</li><li>比 RSA 慢 10－40 倍, 512 位密钥长度太小.</li></ul></li></ul><h2 id="密钥分配"><a href="#密钥分配" class="headerlink" title="密钥分配"></a>密钥分配</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul><li><p>加密方法:</p><ul><li>链路加密.</li><li><p>端到端加密.</p><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301707159.png" alt=""></p></li></ul></li><li><p>密钥分配方法:</p><ul><li>将密钥发给数据交换双方, 不让别人知道.</li></ul></li><li><p>密码系统强度与密钥分配方法有关.</p></li></ul><h3 id="三种情况"><a href="#三种情况" class="headerlink" title="三种情况"></a>三种情况</h3><h4 id="传统对称密码分配"><a href="#传统对称密码分配" class="headerlink" title="传统对称密码分配"></a>传统对称密码分配</h4><ul><li>人工传送: 适用于链路加密.</li><li>密钥分配中心: 适用于端到端加密.</li><li>密钥分配中心 KDC 模式:<ul><li>A 向 KDC 请求会话密钥, 消息有 A 和 B 的标识及临时交互号 N1.</li><li>KDC 用 Ka 加密响应, A 可知一次性会话密钥 Ks, 含 N1 原始请求消息, 还有用 Kb 加密的一次性会话密钥 Ks 和 A 的标识符 IDa.</li><li>A 存下会话密钥 Ks, 将响应后两项内容发给 B.</li></ul></li><li>网络规模很大, 密钥分配不限定在单个 KDC 上, 使用层次式 KDC.<ul><li>主密钥分配代价变小, 本地 KDC 出错或被攻击不会影响全局.</li></ul></li></ul><h4 id="公钥分配"><a href="#公钥分配" class="headerlink" title="公钥分配"></a>公钥分配</h4><ul><li>公开发布:<ul><li>通信方将公钥发送给另一通讯方或广播给各方 (电子邮件 PGP 协议).</li><li>方法简便, 但是任何人都可以伪造.</li></ul></li><li>公开可访问目录:<ul><li>可信的实体或组织维护一个动态可访问的公钥目录.</li><li>管理员定期发布或者更新该目录.</li><li>通讯方可以用新密钥替代当前密钥, 也可以从安全认证通道访问目录.</li><li>比公开公钥要安全, 但是一旦攻击者获得目录管理员私钥, 危险很大.</li></ul></li><li>公钥授权:<ul><li>A 发送时间戳消息给公钥管理员, 请求 B 的公钥. 管理员发送用其私钥 KR 加密的消息, A 用管理员公钥解密, 包含 B 的公钥、原始请求、原始时间戳.</li><li>A 保存 B 公钥, 并将 A 的表示和临时交互号 N1 发给 B. B 从管理员得到 A 的公钥. 通过核对临时交互号, 确认各自身份, 安全通信机制就建立了.</li><li>但是只要通信, 公钥管理员就成为系统瓶颈.</li></ul></li><li>公钥证书:<ul><li>不通过管理员, 用证书交换密钥, 与公钥授权安全性相同.</li><li>证书由证书管理员产生, 发给拥有相应私钥的通讯方.</li><li>通信方传递证书以传递密钥信息, 可以验证证书由证书管理员发出.</li></ul></li></ul><h4 id="利用公钥分配传统密码密钥"><a href="#利用公钥分配传统密码密钥" class="headerlink" title="利用公钥分配传统密码密钥"></a>利用公钥分配传统密码密钥</h4><ul><li><p>原因: 公钥密码速度较慢, 更适合在传统密码中实现密钥分配.</p></li><li><p>分配方法:</p><ul><li><p>简单的密钥分配方法:</p><ul><li>A 产生公/私钥对, 将 KUa 和 A 表示发给 B.</li><li>B 产生密钥 Ks, 用 A 公钥加密后传给 A.</li><li>A 计算得到密钥 Ks.</li><li>容易受到主动攻击.</li></ul></li><li><p>具有保密性和真实性的密钥分配方法:</p><ul><li><p>可以抗击主动攻击和被动攻击.</p><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301707160.png" alt=""></p></li></ul></li><li><p>混合方法.</p></li></ul></li></ul>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;二、密码学基础&quot;&gt;&lt;a href=&quot;#二、密码学基础&quot; class=&quot;headerlink&quot; title=&quot;二、密码学基础&quot;&gt;&lt;/a&gt;二、密码学基础&lt;/h1&gt;&lt;h2 id=&quot;初识密码&quot;&gt;&lt;a href=&quot;#初识密码&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    <category term="CS" scheme="http://chengsx21.github.io/categories/CS/"/>
    
    <category term="Network Security" scheme="http://chengsx21.github.io/categories/CS/Network-Security/"/>
    
    
    <category term="Network Security" scheme="http://chengsx21.github.io/tags/Network-Security/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成原理 笔记4</title>
    <link href="http://chengsx21.github.io/2023/10/02/ji-suan-ji-zu-cheng-yuan-li-bi-ji-4/"/>
    <id>http://chengsx21.github.io/2023/10/02/ji-suan-ji-zu-cheng-yuan-li-bi-ji-4/</id>
    <published>2023-10-02T09:18:57.000Z</published>
    <updated>2024-06-30T09:53:39.690Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SystemVerilog实例"><a href="#SystemVerilog实例" class="headerlink" title="SystemVerilog实例"></a>SystemVerilog实例</h1><blockquote><p><span class="github-emoji"><span>❓</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2753.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> A Hard Journey…</p></blockquote><h2 id="加法器"><a href="#加法器" class="headerlink" title="加法器"></a>加法器</h2><h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>实现一个 2 位加法器: 输入两个非负整数, 输出这两个数的和.</p><p>输入: </p><ol><li><code>a</code>: 宽度为 2, 表示输入的第一个非负整数;</li><li><code>b</code>: 宽度为 2, 表示输入的第二个非负整数.</li></ol><p>输出: </p><ol><li><code>c</code>: 宽度为 2, 表示 <code>a + b</code>, 溢出的部分舍弃.</li></ol><h3 id="电路"><a href="#电路" class="headerlink" title="电路"></a>电路</h3><p>对于这一类<strong>输出仅随着输入变化而变化</strong>的信号, 通常使用<strong>组合逻辑</strong>来实现. 特点是输出完全依赖于输入, 没有内部状态, 和时间无关. </p><p>根据真值表, 可以得到输出与输入的关系 (<code>a_0</code> 表示 <code>a</code> 的最低位). 电路图如下: </p><p><img src="/pic/193.svg" alt=""></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>实际上直接写 <code>a + b</code> 就可以了, EDA 工具会自动完成逻辑转换. </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> add2 <span class="token punctuation">(</span>  <span class="token keyword">input</span> <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span>  <span class="token keyword">input</span> <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> b<span class="token punctuation">,</span>  <span class="token keyword">output</span> <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">assign</span> c <span class="token operator">=</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一个很容易犯的错误是在 <code>output wire [1:0] c</code> 后面多写了一个逗号. 不要把这里的 <code>assign c = a + b</code> 理解为赋值, 而是把它看成信号的连接: 通过一系列的逻辑门, 计算得到 <code>a + b</code> 的结果, 再把结果连接到输出信号 <code>c</code> 上.</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>回顾上面的电路, 最大的特点是<strong>输入一变化, 输出就跟着变</strong>, 并且与时间无关, 这种电路称为<strong>组合电路</strong> (<strong>组合逻辑电路</strong>). </p><h2 id="按钮开关"><a href="#按钮开关" class="headerlink" title="按钮开关"></a>按钮开关</h2><h3 id="需求-1"><a href="#需求-1" class="headerlink" title="需求"></a>需求</h3><p>实现一个控制台灯的按钮开关: 按下开关的时候, 灯会亮起来; 再次按下开关的时候, 灯就熄灭了. </p><p>输入: </p><ol><li><code>button</code>: 1 表示按钮被按下, 0 表示按钮处于弹起状态.</li></ol><p>输出: </p><ol><li><code>light</code>: 1 表示灯亮起, 0 表示灯熄灭.</li></ol><h3 id="电路-1"><a href="#电路-1" class="headerlink" title="电路"></a>电路</h3><p><code>light</code> 输出与它本身的历史状态有关, 并且正好是取反的关系. 如果依然采用组合逻辑来实现, 写出形如 <code>light &lt;= ~light;</code> 的代码, 对应的电路就出现了环路, 此时 <code>light</code> 会不断在 <code>0</code> 和 <code>1</code> 之间震荡.</p><p>这一类<strong>输出与历史状态相关</strong>, 并且<strong>输出在某个信号的上升沿变化</strong>的信号, 通常使用<strong>时序逻辑</strong>来实现. 把 <code>button</code> 连接到触发器的 <code>C</code> 端口, 就实现了上升沿触发的目的; 为了实现每次触发, 让输出的结果取反, 可以把触发器的 <code>Q</code> 经过一个非门再连接到触发器的 <code>D</code> 端口: </p><p><img src="/pic/194.svg" alt=""></p><p>这个电路也成了一个环, 引入触发器的作用, 使得只有在时钟上升沿时, 触发器的输入 D 会引发输出 Q 的变化, 而当时钟上升沿结束以后, 输出 Q 也许会导致输入 D 变化, 但是输出 Q 是稳定不变的, 因此不会出现循环振荡. </p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><p>时序逻辑里, 需要显式的声明一个寄存器 (对应电路里的触发器), 并<strong>严格</strong>把信号<strong>连接</strong>到触发器的输入 D 端口. </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> button <span class="token punctuation">(</span>  <span class="token keyword">input</span> <span class="token keyword">wire</span> button<span class="token punctuation">,</span>  <span class="token keyword">output</span> <span class="token keyword">wire</span> light<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">logic</span> light_reg<span class="token punctuation">;</span><span class="token keyword">assign</span> light <span class="token operator">=</span> light_reg<span class="token punctuation">;</span>  <span class="token important">always_ff @</span> <span class="token punctuation">(</span><span class="token keyword">posedge</span> button<span class="token punctuation">)</span> <span class="token keyword">begin</span>  light_reg <span class="token operator">&lt;=</span> <span class="token operator">~</span>light_reg<span class="token punctuation">;</span><span class="token keyword">end</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要显式声明一个触发器, 称为 <code>light_reg</code>, 然后采用 <code>assign light = light_reg</code> 语句把触发器的输出 Q 端口连接到输出信号 <code>light</code> 上. 接下来实现 <code>light_reg</code> 在 <code>button</code> 上升沿时, 将当前的值取反.</p><p>这里把 <code>light_reg</code> 的输出 Q 经过非门连接到 <code>light_reg</code> 的输入 D 中. 换句话说, 出现在 <code>&lt;=</code> 右侧的都是触发器的输出 Q 端口, 而出现在 <code>&lt;=</code> 左侧的都是触发器的输入 D 端口. 这里的 <code>&lt;=</code> 要理解为信号的连接, 而不是软件编程中的赋值.</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>时序逻辑电路和组合逻辑电路最大的区别在于可以<strong>记录历史, 并且在一定的条件 (输入信号 C 的上升沿) 下触发更新</strong> . 根据这个特点, 我们就可以保存状态, 在上升沿事件的“带领”下更新内部状态.</p><h2 id="秒表"><a href="#秒表" class="headerlink" title="秒表"></a>秒表</h2><h3 id="需求-2"><a href="#需求-2" class="headerlink" title="需求"></a>需求</h3><p>设计一个秒表: 输出一个数字, 每秒加一; 按下复位按钮恢复到零. </p><p>输入: </p><ol><li><code>reset</code>: 1 表示复位按钮被按下, 需要清零; 0 表示不需要清零.</li><li><code>clock</code>: 频率为 1MHz 的时钟.</li></ol><p>输出: </p><ol><li><code>timer</code>: 4 位的数字, 表示目前经过的秒数.</li></ol><p>为了实现秒表, 需要外部的时钟连接到电路的输入 <code>clock</code> 中, 可以在内部逻辑中, 每一次时钟上升沿给计数器加一, 当计数器加到 1,000,000 次就知道经过了 1s 时间. </p><h3 id="波形"><a href="#波形" class="headerlink" title="波形"></a>波形</h3><p>秒表每秒输出都会加一, 说明内部需要保存状态, 需要用<strong>时序逻辑</strong>来实现这一部分功能. 可以用一个寄存器 <code>timer_reg</code> 来保存当前的秒数, 把寄存器的输出连接到 <code>timer</code> 输出上, 只要保证每 1s 中让 <code>timer_reg</code> 加一即可. </p><p>如何实现每 1s 让 <code>timer_reg</code> 加一? 上面引入了一个频率为 1MHz 的时钟, 每 1us 都有一次时钟上升沿, 为了记忆经过了多少次上升沿又是一个状态, 用一个寄存器 <code>counter_reg</code> 来保存当前经过了多少次上升沿.</p><p>每次上升沿 <code>counter_reg</code> 加一, 当加到 1,000,000 时给 <code>timer_reg</code> 加一, 同时让 <code>counter_reg</code> 恢复到 0, 这样就实现了秒表的计时功能. </p><p>需求里面的复位按钮有两种实现方法: </p><ol><li>按下按钮, 输出变成 0, 符合输入一变输出立即跟着变的特点, 所以可以用<strong>组合逻辑</strong> 实现: <code>timer = reset ? 0 : timer_reg</code>; 在时钟上升沿, 如果发现 <code>reset == 1</code>, 设置 <code>timer_reg = 0</code> 和 <code>counter_reg = 0</code>, 松开按钮时会从 0 开始计时. </li><li>按下按钮, 在时钟上升沿如果发现 <code>reset == 1</code>, 就设置 <code>timer_reg = 0</code> 和 <code>counter_reg = 0</code>; 从下一个周期开始, 输出的 <code>timer = timer_reg</code> 就变成了 0.</li></ol><h3 id="电路-2"><a href="#电路-2" class="headerlink" title="电路"></a>电路</h3><p>两组寄存器 <code>timer_reg</code> 和 <code>counter_reg</code>. <code>counter_reg</code> 在每个 <code>clock</code> 上升沿进行更新, <code>timer_reg</code> 在每个 <code>clock</code> 的上升沿进行更新, 这些 “可能” 在电路上对应用组合逻辑实现的选择器. 最后把 <code>timer_reg</code> 的输出连接到 <code>timer</code> 输出即可.</p><p><img src="/pic/195.svg" alt=""></p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> timer <span class="token punctuation">(</span>  <span class="token keyword">input</span> <span class="token keyword">wire</span> clock<span class="token punctuation">,</span>  <span class="token keyword">input</span> <span class="token keyword">wire</span> reset<span class="token punctuation">,</span>  <span class="token keyword">output</span> <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> timer<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">logic</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> timer_reg<span class="token punctuation">;</span>  <span class="token keyword">logic</span> <span class="token punctuation">[</span><span class="token number">19</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> counter_reg<span class="token punctuation">;</span>  <span class="token comment">// sequential</span>  <span class="token important">always_ff @</span> <span class="token punctuation">(</span><span class="token keyword">posedge</span> clock<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>reset<span class="token punctuation">)</span> <span class="token keyword">begin</span>      timer_reg <span class="token operator">&lt;=</span> <span class="token number">4'b0</span><span class="token punctuation">;</span>      counter_reg <span class="token operator">&lt;=</span> <span class="token number">20'b0</span><span class="token punctuation">;</span>    <span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token keyword">begin</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>counter_reg <span class="token operator">==</span> <span class="token number">20'd999999</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>        timer_reg <span class="token operator">&lt;=</span> timer_reg <span class="token operator">+</span> <span class="token number">4'b1</span><span class="token punctuation">;</span>        counter_reg <span class="token operator">&lt;=</span> <span class="token number">20'b0</span><span class="token punctuation">;</span>      <span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token keyword">begin</span>        counter_reg <span class="token operator">&lt;=</span> counter_reg <span class="token operator">+</span> <span class="token number">20'b1</span><span class="token punctuation">;</span>      <span class="token keyword">end</span>    <span class="token keyword">end</span>  <span class="token keyword">end</span>  <span class="token comment">// combinatorial</span>  <span class="token keyword">assign</span> timer <span class="token operator">=</span> timer_reg<span class="token punctuation">;</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来按照上面的思路来实现 <code>timer_reg</code> 和 <code>counter_reg</code> 的逻辑. 由于二者的判断是类似的, 可以直接合并起来. 上面的代码中, 语义上是<strong>当 XX 条件发生时, 向 YY 寄存器写入 ZZ</strong>, 实际电路则是 <code>ZZ &lt;= XX ? YY : ZZ</code>, 如果所有写入的条件都不满足, 则保留原来的状态.</p><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>经过这个例子, 我们学会了如何用 <code>if-then-else</code> 的方式更新寄存器, 而不用手动去写 <code>ZZ = XX ? YY : ZZ</code> 的代码.</p><h2 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h2><h3 id="需求-3"><a href="#需求-3" class="headerlink" title="需求"></a>需求</h3><p>设计一个计数器: 一个计数按钮, 每按一次计数加一; 一个复位按钮, 按下时计数恢复到零; 同时输出两位十进制的数, 显示目前按了多少次计数按钮. </p><p>输入信号: </p><ol><li><code>clock</code>: 频率为 1MHz 的时钟.</li><li><code>reset</code>: 1 表示复位按钮被按下, 0 表示没有按下.</li><li><code>button</code>: 1 表示计数按钮被按下, 0 表示没有按下.</li></ol><p>输出信号: </p><ol><li><code>ones</code>: 输出次数的个位数, 4 位.</li><li><code>tens</code>: 输出次数的十位数, 4 位.</li></ol><h3 id="波形-1"><a href="#波形-1" class="headerlink" title="波形"></a>波形</h3><p>能否在 <code>button</code> 的时钟上升沿触发, 让寄存器加一? 由于按钮的本身特性, 按下按钮的几 ms 内是不稳定的, 不断在 <code>0</code> 和 <code>1</code> 之间抖动, 最后才趋向稳定. </p><p>为了消除这个抖动的影响 (Debounce), 可以记录最近若干次 <code>button</code> 的历史值, 如果连续一段时间都处于一个固定的值, 可以认为按钮处于这个状态.</p><p>计数器是一个内部状态, 需要用寄存器来实现. 能否把去抖以后的信号作为时钟信号来驱动? 如果可能的话, 尽量减少用非时钟信号作为上边沿触发, <strong>尽量把相关的时序逻辑都放在同一个时钟域中</strong>. 如果涉及不同时钟域之间的信号处理, 之后会介绍一些用于实现跨时钟域 (CDC) 的正确电路实现方法. <strong>建议只用一个时钟, 让这个时钟驱动所有的寄存器</strong>. </p><p>可以在时钟的上升沿来检测 <code>button_debounced</code> 从 <code>0</code> 变成了 <code>1</code>, 具体思路是: </p><ol><li>设置一个寄存器 <code>button_debounced_delay</code>, 相对 <code>button_debounced</code> 有一个周期的延迟;</li><li>当 <code>button_debounced == 1</code> 且 <code>button_debounced_delay == 0</code> 时, 就检测到了一个从 <code>0</code> 变成 <code>1</code> 的过程, 对计数器加一. </li></ol><h3 id="电路-3"><a href="#电路-3" class="headerlink" title="电路"></a>电路</h3><h4 id="模块化设计"><a href="#模块化设计" class="headerlink" title="模块化设计"></a>模块化设计</h4><p>代码主要有两部分, 一部分是消抖, 一部分是计数和输出逻辑. 消抖逻辑比较独立, 可以拆出来做成一部分电路, 然后连接到计数和输出逻辑部分.</p><p>消抖模块 (Debouncer) : </p><p>输入: </p><ol><li><code>clock</code>: 频率为 1MHz 的时钟.</li><li><code>reset</code>: 1 表示复位按钮被按下, 0 表示没有按下.</li><li><code>button</code>: 1 表示计数按钮被按下, 0 表示没有按下.</li></ol><p>输出: </p><ol><li><code>button_debounced</code>: 消抖后的计数按钮信号, 高有效.</li></ol><p>计数模块 (Counter) : </p><p>输入: </p><ol><li><code>clock</code>: 频率为 1MHz 的时钟.</li><li><code>reset</code>: 1 表示复位按钮被按下, 0 表示没有按下.</li><li><code>button_debounced</code>: 消抖后的计数按钮信号, 高有效.</li></ol><p>输出: </p><ol><li><code>ones</code>: 输出次数的个位数, 4 位.</li><li><code>tens</code>: 输出次数的十位数, 4 位.</li></ol><p><img src="/pic/196.svg" alt=""></p><h4 id="消抖模块"><a href="#消抖模块" class="headerlink" title="消抖模块"></a>消抖模块</h4><p>需要记录下历史输入, 才可以判断是否 10,000 个周期都保持稳定. 用 10,000 个 1 位的寄存器有些浪费, 可以用一个寄存器来记录目前稳定了多少个周期. </p><ol><li>寄存器 <code>last_button_reg</code> 记录上一个周期 <code>button</code>.</li><li>寄存器 <code>counter_reg</code> 用来保存一个计数, 当 <code>button == last_button_reg</code> 时, 说明 <code>button</code> 保持稳定, 那么 <code>counter_reg = counter_reg + 1</code>; 否则清零重新计数</li><li>寄存器 <code>button_debounced_reg</code> 保存当前输出的消抖结果, 当 <code>counter_reg = 10000</code> 的时候, 更新 <code>button_debounced_reg = last_button_reg</code>. </li></ol><p>最后把 <code>button_debounced_reg</code> 连接到 <code>button_debounced</code> 输出. </p><h4 id="计数模块"><a href="#计数模块" class="headerlink" title="计数模块"></a>计数模块</h4><p>接收来自消抖模块的输出 <code>button_debounced</code>, 检测到从 <code>0</code> 变成 <code>1</code> 的时候计数器加一. 能不能用一个完整的寄存器保存计数, 输出设置 <code>ones = counter_reg % 10</code> 和 <code>tens = counter_reg / 10</code>? 不建议, 因为除法和取模运算会耗费大量的逻辑门, 并且延迟比较大. 如果位数更多, 产生的电路复杂度和延迟可能是不可接受的. 考虑到这里每次对 <code>counter_reg</code> 的操作只有加一和清零, 可以添加 <code>ones_reg</code> 和 <code>tens_reg</code> 寄存器, 实现加一和清零的操作, 并且手动处理进位.</p><p>用一个寄存器检测按下的计数按钮, 即 <code>button_debounced</code> 从 <code>0</code> 变成 <code>1</code>: </p><ol><li>寄存器 <code>button_debounced_reg</code> 保存上一周期的 <code>button_debounced</code>.</li><li>如果 <code>button_debounced == 1 &amp;&amp; button_debounced_reg == 0</code>, 说明检测到了从 <code>0</code> 变成了 <code>1</code>.</li></ol><p>最后是 <code>ones_reg</code> 和 <code>tens_reg</code>, 连接到输出的 <code>ones</code> 和 <code>tens</code> 信号即可. </p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><p>首先是消抖电路: </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> debouncer <span class="token punctuation">(</span>  <span class="token keyword">input</span> <span class="token keyword">wire</span> clock<span class="token punctuation">,</span>  <span class="token keyword">input</span> <span class="token keyword">wire</span> reset<span class="token punctuation">,</span>  <span class="token keyword">input</span> <span class="token keyword">wire</span> button<span class="token punctuation">,</span>  <span class="token keyword">output</span> <span class="token keyword">wire</span> button_debounced<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">logic</span> last_button_reg<span class="token punctuation">;</span>  <span class="token keyword">logic</span> <span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> counter_reg<span class="token punctuation">;</span>  <span class="token keyword">logic</span> button_debounced_reg<span class="token punctuation">;</span>  <span class="token important">always_ff @</span> <span class="token punctuation">(</span><span class="token keyword">posedge</span> clock<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>reset<span class="token punctuation">)</span> <span class="token keyword">begin</span>      last_button_reg <span class="token operator">&lt;=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span>      counter_reg <span class="token operator">&lt;=</span> <span class="token number">16'b0</span><span class="token punctuation">;</span>      button_debounced_reg <span class="token operator">&lt;=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span>    <span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token keyword">begin</span>      last_button_reg <span class="token operator">&lt;=</span> button<span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>button <span class="token operator">==</span> last_button_reg<span class="token punctuation">)</span> <span class="token keyword">begin</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>counter_reg <span class="token operator">==</span> <span class="token number">16'd10000</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>          button_debounced_reg <span class="token operator">&lt;=</span> last_button_reg<span class="token punctuation">;</span>        <span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token keyword">begin</span>          counter_reg <span class="token operator">&lt;=</span> counter_reg <span class="token operator">+</span> <span class="token number">16'b1</span><span class="token punctuation">;</span>        <span class="token keyword">end</span>      <span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token keyword">begin</span>        counter_reg <span class="token operator">&lt;=</span> <span class="token number">16'b0</span><span class="token punctuation">;</span>      <span class="token keyword">end</span>    <span class="token keyword">end</span>  <span class="token keyword">end</span>  <span class="token keyword">assign</span> button_debounced <span class="token operator">=</span> button_debounced_reg<span class="token punctuation">;</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接着是计数器部分: </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> counter <span class="token punctuation">(</span>  <span class="token keyword">input</span> <span class="token keyword">wire</span> clock<span class="token punctuation">,</span>  <span class="token keyword">input</span> <span class="token keyword">wire</span> reset<span class="token punctuation">,</span>  <span class="token keyword">input</span> <span class="token keyword">wire</span> button_debounced<span class="token punctuation">,</span>  <span class="token keyword">output</span> <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> ones<span class="token punctuation">,</span>  <span class="token keyword">output</span> <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> tens<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">logic</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> ones_reg<span class="token punctuation">;</span>  <span class="token keyword">logic</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> tens_reg<span class="token punctuation">;</span>  <span class="token keyword">logic</span> button_debounced_reg<span class="token punctuation">;</span>  <span class="token important">always_ff @</span> <span class="token punctuation">(</span><span class="token keyword">posedge</span> clock<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>reset<span class="token punctuation">)</span> <span class="token keyword">begin</span>      ones_reg <span class="token operator">&lt;=</span> <span class="token number">4'b0</span><span class="token punctuation">;</span>      tens_reg <span class="token operator">&lt;=</span> <span class="token number">4'b0</span><span class="token punctuation">;</span>      button_debounced_reg <span class="token operator">&lt;=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span>    <span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token keyword">begin</span>      button_debounced_reg <span class="token operator">&lt;=</span> button_debounced<span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>button_debounced <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>button_debounced_reg<span class="token punctuation">)</span> <span class="token keyword">begin</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>ones_reg <span class="token operator">==</span> <span class="token number">4'd9</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>          ones_reg <span class="token operator">&lt;=</span> <span class="token number">4'b0</span><span class="token punctuation">;</span>          tens_reg <span class="token operator">&lt;=</span> tens_reg <span class="token operator">+</span> <span class="token number">4'b1</span><span class="token punctuation">;</span>        <span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token keyword">begin</span>          ones_reg <span class="token operator">&lt;=</span> ones_reg <span class="token operator">+</span> <span class="token number">4'b1</span><span class="token punctuation">;</span>        <span class="token keyword">end</span>      <span class="token keyword">end</span>    <span class="token keyword">end</span>  <span class="token keyword">end</span>  <span class="token keyword">assign</span> ones <span class="token operator">=</span> ones_reg<span class="token punctuation">;</span>  <span class="token keyword">assign</span> tens <span class="token operator">=</span> tens_reg<span class="token punctuation">;</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后再用一个顶层 <code>module</code> 把两个模块合起来: </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> counter_top <span class="token punctuation">(</span>  <span class="token keyword">input</span> <span class="token keyword">wire</span> clock<span class="token punctuation">,</span>  <span class="token keyword">input</span> <span class="token keyword">wire</span> reset<span class="token punctuation">,</span>  <span class="token keyword">input</span> <span class="token keyword">wire</span> button<span class="token punctuation">,</span>  <span class="token keyword">output</span> <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> ones<span class="token punctuation">,</span>  <span class="token keyword">output</span> <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> tens<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">wire</span> button_debounced<span class="token punctuation">;</span>  debouncer debouncer_component <span class="token punctuation">(</span>    <span class="token punctuation">.</span><span class="token function">clock</span><span class="token punctuation">(</span>clock<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span>reset<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">.</span><span class="token function">button</span><span class="token punctuation">(</span>button<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">.</span><span class="token function">button_debounced</span><span class="token punctuation">(</span>button_debounced<span class="token punctuation">)</span>  <span class="token punctuation">)</span><span class="token punctuation">;</span>  counter counter_component <span class="token punctuation">(</span>    <span class="token punctuation">.</span><span class="token function">clock</span><span class="token punctuation">(</span>clock<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span>reset<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">.</span><span class="token function">button_debounced</span><span class="token punctuation">(</span>button_debounced<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">.</span><span class="token function">ones</span><span class="token punctuation">(</span>ones<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">.</span><span class="token function">tens</span><span class="token punctuation">(</span>tens<span class="token punctuation">)</span>  <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>button_debounced</code> 是两个内部模块之间的, 所以声明了一个 <code>wire</code> 把两个模块的输入输出连起来, 其他信号则是直接连接到顶层模块的输入输出信号. </p><h2 id="无状态仲裁器-优先级编码器"><a href="#无状态仲裁器-优先级编码器" class="headerlink" title="无状态仲裁器 (优先级编码器)"></a>无状态仲裁器 (优先级编码器)</h2><h3 id="需求-4"><a href="#需求-4" class="headerlink" title="需求"></a>需求</h3><p>设计一个仲裁器: 假想多个用户同时访问同一个资源, 但是资源同时只能给一个用户使用, 这时需要使用一个仲裁器, 选择出一个幸运儿, 其他用户则需要等待. 假设资源的访问是 “立即” 完成的, 资源正在使用的时候, 使用权不会被其他用户抢走.</p><p>输入: </p><ol><li><code>request</code>: 宽度为 4, 每一位 1 表示对应的用户请求访问资源, 0 表示不请求.</li></ol><p>输出: </p><ol><li><code>valid</code>: 1 表示有用户请求访问资源, 0 表示无用户请求访问资源.</li><li><code>user</code>: 宽度为 2, 如果有用户请求访问资源时, 输出获得资源的用户的编号.</li></ol><h3 id="电路-4"><a href="#电路-4" class="headerlink" title="电路"></a>电路</h3><p>仲裁器的输出完全由输入决定, 没有内部状态, 所以可以用<strong>组合逻辑</strong>来实现.  <code>valid</code> 信号比较简单, 直接把所有输入用或门连接在一起即可. 如何找到请求的用户里, 编号最小的那一个? 可以分情况讨论: </p><ol><li><code>request=0000</code>, 输出的 <code>user</code> 可以是任意值.</li><li><code>request=???1</code>, 此时 <code>user=0, valid=1</code>.</li><li><code>request=??10</code>, 此时 <code>user=1, valid=1</code>.</li><li><code>request=?100</code>, 此时 <code>user=2, valid=1</code>.</li><li><code>request=1000</code>, 此时 <code>user=3, valid=1</code>.</li></ol><p>上面五个条件遍历了所有可能的情况. 在实现组合逻辑的时候, 一定要<strong>考虑所有情况, 并且每个情况下每个信号都要得到一个结果</strong>, 否则不可避免会引入锁存器.</p><p><img src="/pic/197.svg" alt=""></p><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> priority_encoder <span class="token punctuation">(</span>  <span class="token keyword">input</span> <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> request<span class="token punctuation">,</span>  <span class="token keyword">output</span> <span class="token keyword">wire</span> valid<span class="token punctuation">,</span>  <span class="token keyword">output</span> <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> user<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">logic</span> valid_comb<span class="token punctuation">;</span>  <span class="token keyword">logic</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> user_comb<span class="token punctuation">;</span>  <span class="token important">always_comb</span> <span class="token keyword">begin</span>    valid_comb <span class="token operator">=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span>    user_comb <span class="token operator">=</span> <span class="token number">2'd0</span><span class="token punctuation">;</span>    <span class="token keyword">casez</span> <span class="token punctuation">(</span>request<span class="token punctuation">)</span>      <span class="token number">4'b???1</span><span class="token punctuation">:</span> <span class="token keyword">begin</span>        valid_comb <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>        user_comb <span class="token operator">=</span> <span class="token number">2'd0</span><span class="token punctuation">;</span>      <span class="token keyword">end</span>      <span class="token number">4'b??10</span><span class="token punctuation">:</span> <span class="token keyword">begin</span>        valid_comb <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>        user_comb <span class="token operator">=</span> <span class="token number">2'd1</span><span class="token punctuation">;</span>      <span class="token keyword">end</span>      <span class="token number">4'b?100</span><span class="token punctuation">:</span> <span class="token keyword">begin</span>        valid_comb <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>        user_comb <span class="token operator">=</span> <span class="token number">2'd2</span><span class="token punctuation">;</span>      <span class="token keyword">end</span>      <span class="token number">4'b1000</span><span class="token punctuation">:</span> <span class="token keyword">begin</span>        valid_comb <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>        user_comb <span class="token operator">=</span> <span class="token number">2'd3</span><span class="token punctuation">;</span>      <span class="token keyword">end</span>    <span class="token keyword">endcase</span>  <span class="token keyword">end</span>  <span class="token keyword">assign</span> valid <span class="token operator">=</span> valid_comb<span class="token punctuation">;</span>  <span class="token keyword">assign</span> user <span class="token operator">=</span> user_comb<span class="token punctuation">;</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实现组合逻辑电路的一种方法是用 <code>assign</code>, 如 <code>assign valid = |request</code>; 但是涉及更复杂的组合逻辑时, 会比较复杂. 可以在 <code>always_comb</code> 块中灵活地使用各种条件语句, 包括 <code>casez</code> 语句, 首先设置了一个默认的结果, 这样如果下面所有的 <code>casez</code> 都不满足, 那么输出的就是默认值.</p><h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>总结规律: </p><ol><li>确定输入输出;</li><li>确定需要哪些寄存器;</li><li>实现时序逻辑;</li><li>实现组合逻辑.</li></ol><h2 id="循环优先级仲裁器"><a href="#循环优先级仲裁器" class="headerlink" title="循环优先级仲裁器"></a>循环优先级仲裁器</h2><h3 id="需求-5"><a href="#需求-5" class="headerlink" title="需求"></a>需求</h3><p>实现一个循环优先级仲裁器 (round robin arbiter), 根据最后一次获取资源的用户, 决定下一次获取资源的优先级. 当一个用户 <code>A</code> 不再获取资源 (对应位 <code>request</code> 从 <code>1</code> 变成 <code>0</code>) 时, 重新选择一个可以获取资源的用户, 优先级是从 <code>A</code> 的下一个用户开始为最高优先级, 如果溢出了就绕回.</p><p>输入: </p><ol><li><code>request</code>: 宽度为 4, 每一位 1 表示对应的用户请求访问资源, 0 表示不请求.</li><li><code>clock</code>: 1MHz 的时钟.</li><li><code>reset</code>: 复位信号.</li></ol><p>输出: </p><ol><li><code>valid</code>: 1 表示有用户请求访问资源, 0 表示无用户请求访问资源.</li><li><code>user</code>: 宽度为 2, 如果有用户请求访问资源时, 输出获得资源的用户的编号.</li></ol><h3 id="波形-2"><a href="#波形-2" class="headerlink" title="波形"></a>波形</h3><p>相比上一个例子, 有两个比较大的区别: </p><ol><li>无状态仲裁器中, 如果出现了优先级更高的用户, 资源的访问权立即切换; 循环优先级仲裁器中, 只有用户放弃了请求才会切换;</li><li>仲裁时, 优先级根据最后一次获得访问权的用户来决定.</li></ol><h3 id="电路-5"><a href="#电路-5" class="headerlink" title="电路"></a>电路</h3><p>由于优先级和最后一次获得访问权的用户有关, 需要<strong>时序逻辑</strong>实现. 用 <code>user_reg</code> 记录最后一次获得访问权的用户编号: </p><ol><li>什么时候更新: 上一个周期没有用户获得访问权, 这个周期 <code>request</code> 不等于零; 当前周期获得访问权的用户对应的 <code>request</code> 位由 <code>1</code> 变成了 <code>0</code>.</li><li>更新成什么: 按照优先级顺序在 <code>request</code> 里选出目前优先级最高的用户.</li></ol><p>由此, 在这一类内部具有状态, 又需要在输入变化的同一个周期输出的情况, 需要用时序逻辑来保存状态, 同时用组合逻辑来实现同周期的输出, 把二者结合起来.</p><p>第一部分是修改后的优先级编码器, 额外添加输入 <code>last_user</code> 表示最后一次获得访问权的用户编号. </p><p>第二部分是维护 <code>user_reg</code> 状态. 第一个模块是上面提到的修改后的优先级编码器, 第二个模块是整体的循环优先级仲裁器, 内部例化第一个模块. </p><h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><p>实现第一部分逻辑, 根据最后一次获取资源的用户编号确定优先级的优先级编码器: </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> rr_priority_encoder <span class="token punctuation">(</span>  <span class="token keyword">input</span> <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> request<span class="token punctuation">,</span>  <span class="token keyword">input</span> <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> last_user<span class="token punctuation">,</span>  <span class="token keyword">output</span> <span class="token keyword">wire</span> valid<span class="token punctuation">,</span>  <span class="token keyword">output</span> <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> user<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">logic</span> valid_comb<span class="token punctuation">;</span>  <span class="token keyword">logic</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> user_comb<span class="token punctuation">;</span>  <span class="token important">always_comb</span> <span class="token keyword">begin</span>    valid_comb <span class="token operator">=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span>    user_comb <span class="token operator">=</span> <span class="token number">2'd0</span><span class="token punctuation">;</span>    <span class="token comment">// naive way</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>last_user <span class="token operator">==</span> <span class="token number">2'd3</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>      <span class="token keyword">casez</span> <span class="token punctuation">(</span>request<span class="token punctuation">)</span>        <span class="token number">4'b???1</span><span class="token punctuation">:</span> <span class="token keyword">begin</span>          valid_comb <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>          user_comb <span class="token operator">=</span> <span class="token number">2'd0</span><span class="token punctuation">;</span>        <span class="token keyword">end</span>        <span class="token number">4'b??10</span><span class="token punctuation">:</span> <span class="token keyword">begin</span>          valid_comb <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>          user_comb <span class="token operator">=</span> <span class="token number">2'd1</span><span class="token punctuation">;</span>        <span class="token keyword">end</span>        <span class="token number">4'b?100</span><span class="token punctuation">:</span> <span class="token keyword">begin</span>          valid_comb <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>          user_comb <span class="token operator">=</span> <span class="token number">2'd2</span><span class="token punctuation">;</span>        <span class="token keyword">end</span>        <span class="token number">4'b1000</span><span class="token punctuation">:</span> <span class="token keyword">begin</span>          valid_comb <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>          user_comb <span class="token operator">=</span> <span class="token number">2'd3</span><span class="token punctuation">;</span>        <span class="token keyword">end</span>      <span class="token keyword">endcase</span>    <span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>last_user <span class="token operator">==</span> <span class="token number">2'd0</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>      <span class="token keyword">casez</span> <span class="token punctuation">(</span>request<span class="token punctuation">)</span>        <span class="token number">4'b??1?</span><span class="token punctuation">:</span> <span class="token keyword">begin</span>          valid_comb <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>          user_comb <span class="token operator">=</span> <span class="token number">2'd1</span><span class="token punctuation">;</span>        <span class="token keyword">end</span>        <span class="token number">4'b?10?</span><span class="token punctuation">:</span> <span class="token keyword">begin</span>          valid_comb <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>          user_comb <span class="token operator">=</span> <span class="token number">2'd2</span><span class="token punctuation">;</span>        <span class="token keyword">end</span>        <span class="token number">4'b100?</span><span class="token punctuation">:</span> <span class="token keyword">begin</span>          valid_comb <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>          user_comb <span class="token operator">=</span> <span class="token number">2'd3</span><span class="token punctuation">;</span>        <span class="token keyword">end</span>        <span class="token number">4'b0001</span><span class="token punctuation">:</span> <span class="token keyword">begin</span>          valid_comb <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>          user_comb <span class="token operator">=</span> <span class="token number">2'd0</span><span class="token punctuation">;</span>        <span class="token keyword">end</span>      <span class="token keyword">endcase</span>    <span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>last_user <span class="token operator">==</span> <span class="token number">2'd1</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>      <span class="token keyword">casez</span> <span class="token punctuation">(</span>request<span class="token punctuation">)</span>        <span class="token number">4'b?1??</span><span class="token punctuation">:</span> <span class="token keyword">begin</span>          valid_comb <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>          user_comb <span class="token operator">=</span> <span class="token number">2'd2</span><span class="token punctuation">;</span>        <span class="token keyword">end</span>        <span class="token number">4'b10??</span><span class="token punctuation">:</span> <span class="token keyword">begin</span>          valid_comb <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>          user_comb <span class="token operator">=</span> <span class="token number">2'd3</span><span class="token punctuation">;</span>        <span class="token keyword">end</span>        <span class="token number">4'b00?1</span><span class="token punctuation">:</span> <span class="token keyword">begin</span>          valid_comb <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>          user_comb <span class="token operator">=</span> <span class="token number">2'd0</span><span class="token punctuation">;</span>        <span class="token keyword">end</span>        <span class="token number">4'b0010</span><span class="token punctuation">:</span> <span class="token keyword">begin</span>          valid_comb <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>          user_comb <span class="token operator">=</span> <span class="token number">2'd1</span><span class="token punctuation">;</span>        <span class="token keyword">end</span>      <span class="token keyword">endcase</span>    <span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>last_user <span class="token operator">==</span> <span class="token number">2'd2</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>      <span class="token keyword">casez</span> <span class="token punctuation">(</span>request<span class="token punctuation">)</span>        <span class="token number">4'b1???</span><span class="token punctuation">:</span> <span class="token keyword">begin</span>          valid_comb <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>          user_comb <span class="token operator">=</span> <span class="token number">2'd3</span><span class="token punctuation">;</span>        <span class="token keyword">end</span>        <span class="token number">4'b0??1</span><span class="token punctuation">:</span> <span class="token keyword">begin</span>          valid_comb <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>          user_comb <span class="token operator">=</span> <span class="token number">2'd0</span><span class="token punctuation">;</span>        <span class="token keyword">end</span>        <span class="token number">4'b0?10</span><span class="token punctuation">:</span> <span class="token keyword">begin</span>          valid_comb <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>          user_comb <span class="token operator">=</span> <span class="token number">2'd1</span><span class="token punctuation">;</span>        <span class="token keyword">end</span>        <span class="token number">4'b0100</span><span class="token punctuation">:</span> <span class="token keyword">begin</span>          valid_comb <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>          user_comb <span class="token operator">=</span> <span class="token number">2'd2</span><span class="token punctuation">;</span>        <span class="token keyword">end</span>      <span class="token keyword">endcase</span>    <span class="token keyword">end</span>  <span class="token keyword">end</span>  <span class="token keyword">assign</span> valid <span class="token operator">=</span> valid_comb<span class="token punctuation">;</span>  <span class="token keyword">assign</span> user <span class="token operator">=</span> user_comb<span class="token punctuation">;</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接着是循环优先级仲裁器: </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> rr_arbiter <span class="token punctuation">(</span>  <span class="token keyword">input</span> <span class="token keyword">wire</span> clock<span class="token punctuation">,</span>  <span class="token keyword">input</span> <span class="token keyword">wire</span> reset<span class="token punctuation">,</span>  <span class="token keyword">input</span> <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> request<span class="token punctuation">,</span>  <span class="token keyword">output</span> <span class="token keyword">wire</span> valid<span class="token punctuation">,</span>  <span class="token keyword">output</span> <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> user<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">logic</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> user_reg<span class="token punctuation">;</span>  <span class="token keyword">logic</span> valid_reg<span class="token punctuation">;</span>  <span class="token keyword">logic</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> user_comb<span class="token punctuation">;</span>  <span class="token keyword">logic</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> priority_encoder_user_comb<span class="token punctuation">;</span>  rr_priority_encoder rr_priority_encoder_inst <span class="token punctuation">(</span>    <span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">.</span><span class="token function">last_user</span><span class="token punctuation">(</span>user_reg<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">.</span><span class="token function">valid</span><span class="token punctuation">(</span>valid<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">.</span><span class="token function">user</span><span class="token punctuation">(</span>priority_encoder_user_comb<span class="token punctuation">)</span>  <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// sequential</span>  <span class="token important">always_ff @</span> <span class="token punctuation">(</span><span class="token keyword">posedge</span> clock<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>reset<span class="token punctuation">)</span> <span class="token keyword">begin</span>      user_reg <span class="token operator">&lt;=</span> <span class="token number">2'd0</span><span class="token punctuation">;</span>      valid_reg <span class="token operator">&lt;=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span>    <span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token keyword">begin</span>      valid_reg <span class="token operator">&lt;=</span> valid<span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>valid_reg <span class="token operator">&amp;&amp;</span> valid<span class="token punctuation">)</span> <span class="token keyword">begin</span>        <span class="token comment">// case 1: non valid -&gt; valid</span>        user_reg <span class="token operator">&lt;=</span> priority_encoder_user_comb<span class="token punctuation">;</span>      <span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>valid_reg <span class="token operator">&amp;&amp;</span> valid <span class="token operator">&amp;&amp;</span> request<span class="token punctuation">[</span>user_reg<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>        <span class="token comment">// case 2: persist</span>      <span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>valid_reg <span class="token operator">&amp;&amp;</span> valid <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>request<span class="token punctuation">[</span>user_reg<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>        <span class="token comment">// case 3: next user</span>        user_reg <span class="token operator">&lt;=</span> priority_encoder_user_comb<span class="token punctuation">;</span>      <span class="token keyword">end</span>    <span class="token keyword">end</span>  <span class="token keyword">end</span>  <span class="token comment">// combinatorial</span>  <span class="token important">always_comb</span> <span class="token keyword">begin</span>    <span class="token comment">// default</span>    user_comb <span class="token operator">=</span> <span class="token number">2'b0</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>valid_reg <span class="token operator">&amp;&amp;</span> valid<span class="token punctuation">)</span> <span class="token keyword">begin</span>      <span class="token comment">// case 1: non valid -&gt; valid</span>      user_comb <span class="token operator">=</span> priority_encoder_user_comb<span class="token punctuation">;</span>    <span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>valid_reg <span class="token operator">&amp;&amp;</span> valid <span class="token operator">&amp;&amp;</span> request<span class="token punctuation">[</span>user_reg<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>      <span class="token comment">// case 2: persist</span>      user_comb <span class="token operator">=</span> user_reg<span class="token punctuation">;</span>    <span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>valid_reg <span class="token operator">&amp;&amp;</span> valid <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>request<span class="token punctuation">[</span>user_reg<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>      <span class="token comment">// case 3: next user</span>      user_comb <span class="token operator">=</span> priority_encoder_user_comb<span class="token punctuation">;</span>    <span class="token keyword">end</span>  <span class="token keyword">end</span>  <span class="token keyword">assign</span> user <span class="token operator">=</span> user_comb<span class="token punctuation">;</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="仿真"><a href="#仿真" class="headerlink" title="仿真"></a>仿真</h2><p><strong>描述数字电路的 Verilog 和用来仿真的 Verilog 使用完全不同的编写思路和实现方法.</strong> 前者与电路一一对应, 而后者更像是 C 这种过程式的编程语言.</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> add2 <span class="token punctuation">(</span>  <span class="token keyword">input</span> <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span>  <span class="token keyword">input</span> <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> b<span class="token punctuation">,</span>  <span class="token keyword">output</span> <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">assign</span> c <span class="token operator">=</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>要给这个模块输入数据, 要人为地设置模块的输入: </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token constant">`timescale</span> <span class="token number">1</span>ns<span class="token operator">/</span><span class="token number">1</span>ps<span class="token keyword">module</span> add2_tb <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> a<span class="token punctuation">;</span>  <span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> b<span class="token punctuation">;</span>  <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> c<span class="token punctuation">;</span>  <span class="token keyword">initial</span> <span class="token keyword">begin</span>    a <span class="token operator">=</span> <span class="token number">2'b01</span><span class="token punctuation">;</span>    b <span class="token operator">=</span> <span class="token number">2'b10</span><span class="token punctuation">;</span>    <span class="token number">#1</span><span class="token punctuation">;</span>    <span class="token kernel-function property">$finish</span><span class="token punctuation">;</span>  <span class="token keyword">end</span>  add2 inst <span class="token punctuation">(</span>    <span class="token punctuation">.</span><span class="token function">a</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">.</span><span class="token function">b</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">.</span><span class="token function">c</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span>  <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于 <code>c</code> 连接到 <code>add2</code> 模块的输出, 所以要用 <code>wire</code>; 其他要输入到 <code>add2</code> 模块中, 所以用 <code>reg</code>. 运行 <code>#1;</code> 命令, 表示等待 <code>1ns</code>, 然后再运行 <code>$finish;</code>, 表示仿真结束.</p><h3 id="时钟"><a href="#时钟" class="headerlink" title="时钟"></a>时钟</h3><p>仿真一个带有时序逻辑的模块, 使用前面的秒表的例子: </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> timer <span class="token punctuation">(</span>  <span class="token keyword">input</span> <span class="token keyword">wire</span> clock<span class="token punctuation">,</span>  <span class="token keyword">input</span> <span class="token keyword">wire</span> reset<span class="token punctuation">,</span>  <span class="token keyword">output</span> <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> timer<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> timer_reg<span class="token punctuation">;</span>  <span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">19</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> counter_reg<span class="token punctuation">;</span>  <span class="token comment">// sequential</span>  <span class="token important">always @</span> <span class="token punctuation">(</span><span class="token keyword">posedge</span> clock<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>reset<span class="token punctuation">)</span> <span class="token keyword">begin</span>      timer_reg <span class="token operator">&lt;=</span> <span class="token number">4'b0</span><span class="token punctuation">;</span>      counter_reg <span class="token operator">&lt;=</span> <span class="token number">20'b0</span><span class="token punctuation">;</span>    <span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token keyword">begin</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>counter_reg <span class="token operator">==</span> <span class="token number">20'd999999</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>        timer_reg <span class="token operator">&lt;=</span> timer_reg <span class="token operator">+</span> <span class="token number">4'b1</span><span class="token punctuation">;</span>        counter_reg <span class="token operator">&lt;=</span> <span class="token number">20'b0</span><span class="token punctuation">;</span>      <span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token keyword">begin</span>        counter_reg <span class="token operator">&lt;=</span> counter_reg <span class="token operator">+</span> <span class="token number">20'b1</span><span class="token punctuation">;</span>      <span class="token keyword">end</span>    <span class="token keyword">end</span>  <span class="token keyword">end</span>  <span class="token comment">// combinatorial</span>  <span class="token keyword">assign</span> timer <span class="token operator">=</span> timer_reg<span class="token punctuation">;</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>例化 <code>timer</code> 模块, 连接输入输出信号. 时钟信号以一个固定的频率在 0 和 1 之间变化. 如果频率是 50MHz, 那么一个周期每 10ns 变化一次. 这样下去就可以构造出一个时钟信号:</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">initial</span> <span class="token keyword">begin</span>  reset <span class="token operator">=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span>  clock <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>  <span class="token number">#10</span><span class="token punctuation">;</span>  clock <span class="token operator">=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span>  <span class="token number">#10</span><span class="token punctuation">;</span>  clock <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>  <span class="token number">#10</span><span class="token punctuation">;</span>  clock <span class="token operator">=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span>  <span class="token number">#10</span><span class="token punctuation">;</span><span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>希望仿真更多时钟周期, 自动生成时钟信号:</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">initial</span> <span class="token keyword">begin</span>  reset <span class="token operator">=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span>  clock <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token important">always</span> <span class="token number">#10</span> clock <span class="token operator">=</span> <span class="token operator">~</span>clock<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="复位"><a href="#复位" class="headerlink" title="复位"></a>复位</h3><p>处理好时钟后仿真上面的代码, 会发现 <code>timer</code> 输出一直是 <code>x</code>, 因为 <code>timer</code> 没有被复位. 需要先设置 <code>reset</code> 为 1, 再设置 <code>reset</code> 为 0: </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">initial</span> <span class="token keyword">begin</span>  reset <span class="token operator">=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span>  clock <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>  <span class="token number">#10</span><span class="token punctuation">;</span>  reset <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>  <span class="token number">#10</span><span class="token punctuation">;</span>  reset <span class="token operator">=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token important">always</span> <span class="token number">#10</span> clock <span class="token operator">=</span> <span class="token operator">~</span>clock<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="构造输入"><a href="#构造输入" class="headerlink" title="构造输入"></a>构造输入</h3><p>目前的仿真顶层模块没有提供要测试的模块的其他输入信号, 还需要针对特定的协议人为构造输入.</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">reg</span> ps2_clock<span class="token punctuation">;</span><span class="token keyword">reg</span> ps2_data<span class="token punctuation">;</span>ps2_keyboard dut <span class="token punctuation">(</span>  <span class="token punctuation">.</span><span class="token function">clock</span><span class="token punctuation">(</span>clock<span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span>reset<span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token punctuation">.</span><span class="token function">ps2_clock</span><span class="token punctuation">(</span>ps2_clock<span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token punctuation">.</span><span class="token function">ps2_data</span><span class="token punctuation">(</span>ps2_data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>按照 PS/2 的协议, 按顺序给 ps2_clock 和 ps2_data 赋值, 穿插着延迟语句.</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog">ps2_data <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>ps2_clock <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span><span class="token number">#5</span><span class="token punctuation">;</span><span class="token comment">// start bit</span>ps2_data <span class="token operator">=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span><span class="token number">#5</span><span class="token punctuation">;</span>ps2_clock <span class="token operator">=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span><span class="token number">#5</span><span class="token punctuation">;</span>ps2_clock <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span><span class="token comment">// scancode[0] = 0</span>ps2_data <span class="token operator">=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span><span class="token number">#5</span><span class="token punctuation">;</span>ps2_clock <span class="token operator">=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span><span class="token number">#5</span><span class="token punctuation">;</span>ps2_clock <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span><span class="token comment">// scancode[1] = 0</span>ps2_data <span class="token operator">=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span><span class="token number">#5</span><span class="token punctuation">;</span>ps2_clock <span class="token operator">=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span><span class="token number">#5</span><span class="token punctuation">;</span>ps2_clock <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">// scancode[7] = 1</span>ps2_data <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span><span class="token number">#5</span><span class="token punctuation">;</span>ps2_clock <span class="token operator">=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span><span class="token number">#5</span><span class="token punctuation">;</span>ps2_clock <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span><span class="token comment">// parity = 1</span>ps2_data <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span><span class="token number">#5</span><span class="token punctuation">;</span>ps2_clock <span class="token operator">=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span><span class="token number">#5</span><span class="token punctuation">;</span>ps2_clock <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span><span class="token comment">// stop</span>ps2_data <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span><span class="token number">#5</span><span class="token punctuation">;</span>ps2_clock <span class="token operator">=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span><span class="token number">#5</span><span class="token punctuation">;</span>ps2_clock <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>更进一步, 如果想要重复发送 scancode, 只不过内容会更改, 可以把这一步骤封装成 task, 完整写法见 <a href="https://git.tsinghua.edu.cn/digital-design-lab/project-template/-/blob/2076e9ffc1ff3e923365a9e79d6a944544a3b8e8/src/keyboard_tb.v#L12">Tsinghua GitLab</a>.</p><h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><p>总结一下: </p><ul><li>单独写一个仿真顶层模块, 例化要测试的模块.</li><li>测试模块的输入输出接到 <code>reg</code> 或者 <code>wire</code>.</li><li>时序逻辑在 <code>initial</code> 块初始化时钟信号, 用 <code>always #10 clock = ~clock;</code> 生成时钟信号.</li><li>复位信号在 <code>initial</code> 块内, 仿真信号由 0 变成 1, 再由 1 变成 0.</li><li>输入信号在 <code>initial</code> 块内, 对对应的 <code>reg</code> 信号进行赋值.</li></ul>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;SystemVerilog实例&quot;&gt;&lt;a href=&quot;#SystemVerilog实例&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    <category term="CS" scheme="http://chengsx21.github.io/categories/CS/"/>
    
    <category term="Organization &amp; Design" scheme="http://chengsx21.github.io/categories/CS/Organization-Design/"/>
    
    
    <category term="Organization &amp; Design" scheme="http://chengsx21.github.io/tags/Organization-Design/"/>
    
    <category term="SV" scheme="http://chengsx21.github.io/tags/SV/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成原理 笔记3</title>
    <link href="http://chengsx21.github.io/2023/09/28/ji-suan-ji-zu-cheng-yuan-li-bi-ji-3/"/>
    <id>http://chengsx21.github.io/2023/09/28/ji-suan-ji-zu-cheng-yuan-li-bi-ji-3/</id>
    <published>2023-09-28T09:18:57.000Z</published>
    <updated>2024-06-30T09:53:39.680Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SystemVerilog入门使用"><a href="#SystemVerilog入门使用" class="headerlink" title="SystemVerilog入门使用"></a>SystemVerilog入门使用</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>写硬件和写软件代码是完全不同的——软件代码体现了指令顺序流执行的思想, 这是和冯诺依曼计算机的结构直接相关的; 硬件的特性是信号在各条信号线上并行传播, 硬件描述语言描述的是各个模块之间的连接关系. </p><h2 id="模块结构"><a href="#模块结构" class="headerlink" title="模块结构"></a>模块结构</h2><p>一个 2 输入与门的模块描述: </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> and2x <span class="token punctuation">(</span>    <span class="token keyword">input</span> <span class="token keyword">wire</span> a<span class="token punctuation">,</span>    <span class="token keyword">input</span> <span class="token keyword">wire</span> b<span class="token punctuation">,</span>    <span class="token keyword">output</span> <span class="token keyword">wire</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">assign</span> r <span class="token operator">=</span> a <span class="token operator">&amp;</span> b<span class="token punctuation">;</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要注意的几点是:</p><ul><li>输入和双向端口不能被定义为 <code>reg</code> 类型. </li><li>如果无法确认使用 <code>reg</code> 还是使用 <code>wire</code>, 都可以使用 <code>logic</code> 来代替. </li><li><code>wire</code> 是默认的类型, 所有的 <code>wire</code> 都可以省略. </li><li>通过 <code>assign</code> 语句进行持续赋值, 通常被用来进行组合逻辑的设计.</li></ul><h2 id="语言元素"><a href="#语言元素" class="headerlink" title="语言元素"></a>语言元素</h2><p>硬件描述里面的 “综合” 这个概念非常重要, 类比于将高级语言编译为机器语言, 最终在物理硬件上执行. “综合” 的含义就是将硬件描述语言的功能翻译为能够直接实现的电路, 可以放到 FPGA 或者直接转化为硬件电路, 用以执行所描述的功能. </p><h3 id="SystemVerilog-的语言元素"><a href="#SystemVerilog-的语言元素" class="headerlink" title="SystemVerilog 的语言元素"></a>SystemVerilog 的语言元素</h3><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><p>在 C 语言中, 一个编程习惯是使用符号来代替常数硬编码. 这一点在 SystemVerilog 中也是一样的. 可以使用 <code>parameter</code> 来定义一个符号常量, 便于修改也增加了程序的可读性. 一个最为典型的应用就是来指定信号 (向量) 的宽度, 使用 parameter 的语法形式为: </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">parameter</span> PARAM1<span class="token operator">=</span>EXP1<span class="token punctuation">,</span> PARAM2<span class="token operator">=</span>EXP2<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="编译指导语句"><a href="#编译指导语句" class="headerlink" title="编译指导语句"></a>编译指导语句</h4><p>SystemVerilog 中的编译指导语句与 C 语言 (例如 <code>#include</code>) 类似, 指示编译器的工作. 编译指导语句都是不可综合的, 会在编译的时候进行字符串等替换操作. </p><h5 id="define-宏定义语句"><a href="#define-宏定义语句" class="headerlink" title="`define 宏定义语句"></a><code>`define</code> 宏定义语句</h5><p><code>`define</code> 语句相当于 C 语言中的 <code>#define</code>, 在编译时, <code>`define</code> 的宏名称被替换为后面的字符串. 如: </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token constant">`define</span> WIDTH <span class="token number">16</span><span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token constant">`WIDTH</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> r<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这就与 <code>reg[15:0]</code> 相当. 在每次使用宏名称的时候, 需要加上 <code>` </code>, 在 <code>`define</code> 这一行的行末不需要分号.  <code>`define</code> 的宏替换功能与 C 语言一样强大, 能够用来替换比较复杂的表达式. 例如: </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token constant">`define</span> sum a<span class="token operator">+</span>b<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>定义之后, 可以使用: </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">assign</span> res<span class="token operator">=</span>sum<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>来获得将两个 a 和 b 信号相加的效果.</p><h5 id="include-文件包含语句"><a href="#include-文件包含语句" class="headerlink" title="`include 文件包含语句"></a><code>`include</code> 文件包含语句</h5><p><code>`include</code> 语句相当于 C 语言中的 <code>#include</code> 语句, 用来包含其它的文件. 这里同样也没有行末的分号, 需要设置对应的相对路径, 例如: </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token constant">`include</span> <span class="token string">"../common/adder.v"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="ifdef-else-elsif-endif-条件编译语句"><a href="#ifdef-else-elsif-endif-条件编译语句" class="headerlink" title="`ifdef,  `else, `elsif, `endif 条件编译语句"></a><code>`ifdef</code>,  <code>`else</code>, <code>`elsif</code>, <code>`endif</code> 条件编译语句</h5><p><code>`ifdef</code>, <code>`else</code>, <code>`elsif</code>, <code>`endif</code> 条件编译语句相当于在 C 语言中的 <code>#ifdef</code>, <code>#else</code>, <code>#elif</code>, <code>#endif</code> 语句, 用来设定哪一部分源代码会最终编译, 例如: </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token constant">`define</span> sum a<span class="token operator">+</span>b<span class="token constant">`ifdef</span> sum<span class="token keyword">assign</span> res<span class="token operator">=</span>sum<span class="token punctuation">;</span><span class="token constant">`else</span><span class="token keyword">assign</span> res<span class="token operator">=</span>a<span class="token operator">+</span>b<span class="token punctuation">;</span><span class="token constant">`endif</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以通过控制 <code>sum</code> 是否定义来选择需要编译的源代码, 不需要编译的源代码就被忽略. 需要嵌套更多判断, 可以使用 <code>`elsif</code> 进一步判断. </p><h3 id="SystemVerilog-中的数据"><a href="#SystemVerilog-中的数据" class="headerlink" title="SystemVerilog 中的数据"></a>SystemVerilog 中的数据</h3><h4 id="整数常量"><a href="#整数常量" class="headerlink" title="整数常量"></a>整数常量</h4><p>在硬件开发的过程中, 不能够改变的量被称为是常量 (constants). 在处理器设计中, 最为重要的常量形式为整数, 整数常量按照一定的格式写出: </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token operator">+/-</span> <span class="token operator">&lt;</span>位宽<span class="token operator">&gt;</span>'<span class="token operator">&lt;</span>进制<span class="token operator">&gt;&lt;</span>数字<span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>进制包括了二进制 (<code>b</code> 或者 <code>B</code>), 十进制 (<code>d</code> 或者 <code>D</code>), 八进制 (<code>o</code> 或者 <code>O</code>) 以及十六进制 (<code>h</code> 或者 <code>H</code>).</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token number">8'b01001010</span><span class="token number">16'H45EF</span><span class="token operator">-</span><span class="token number">8'D123</span><span class="token operator">-</span><span class="token number">16'o3333</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="数据取值"><a href="#数据取值" class="headerlink" title="数据取值"></a>数据取值</h4><p>在进行硬件编码的时候, 除了 <code>0</code> 和 <code>1</code> 两个信号取值外, 还有其它的一些逻辑状态. 两个比较重要的是 <code>x</code>/<code>X</code> 和 <code>z</code>/<code>Z</code>.</p><p><code>x</code> 或者 <code>X</code> 的取值表明为不确定, 或者未知逻辑状态, 用于不关心对应信号值的情况.</p><p><code>z</code> 或者 <code>Z</code> 代表高阻态, 典型应用是用于获得内存的输入, 先将处理器引脚的状态置于 <code>z</code>, 经过一定的时间延迟, 可从对应的引脚处获得内存的输入值. </p><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><p>基本数据类型包括了 <code>wire</code> 类型和 <code>reg</code> 类型. <code>wire</code> 类型代表了在硬件电路中的连线, 输出的值紧随着输入值的变化而变化. <code>reg</code> 数据类型会放到过程语句中进行赋值, 不一定必然会对应到硬件的寄存器, 综合时依据实际情况使用连线 (组合逻辑) 或者寄存器 (时序逻辑). </p><p>数据类型还有向量和标量的区别. 没有指定则默认为 1 位的位宽, 是一个标量. 向量使用中括号指定位宽, 形式为 <code>[msb:lsb]</code>. 例如: </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> data<span class="token punctuation">;</span> <span class="token comment">// 这是一个 8 位的连线. </span><span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> res<span class="token punctuation">;</span>  <span class="token comment">// 32 位的数据变量</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在 SystemVerilog 中有非常方便的向量访问方式:</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog">l <span class="token operator">=</span> data<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">// 获取 data 的最高位</span>lob <span class="token operator">=</span> res<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 获取数据 res 中的最低 8 位, 即最低一个字节</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="SystemVerilog-中的运算"><a href="#SystemVerilog-中的运算" class="headerlink" title="SystemVerilog 中的运算"></a>SystemVerilog 中的运算</h3><h4 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h4><p>位运算符是最基本的运算符, 表达了两个操作数对应的位进行位运算的结果.</p><ul><li><code>~</code> 按位取反.</li><li><code>&amp;</code> 按位与.</li><li><code>|</code> 按位或. </li><li><code>^</code> 按位异或.</li><li><code>^~</code> 或 <code>~^</code> 按位同或.</li><li><code>&gt;&gt;</code> 右移.</li><li><code>&lt;&lt;</code> 左移.</li></ul><p>在位运算符中还有一类特殊的运算符, 即缩位运算符. 可以将一个向量按照一定的位运算 “缩” 成 1 位. </p><ul><li><code>&amp;</code> 缩位与.</li><li><code>~&amp;</code> 缩位与非.</li><li><code>|</code> 缩位或.</li><li><code>~\</code> 缩位或非.</li><li><code>^</code> 缩位异或.</li><li><code>^~</code> 或 <code>~^</code> 缩位同或.</li></ul><p>例如 <code>reg [7:0] value;</code> 如果 <code>value = 7'b01010101</code>. 则 <code>&amp;value</code> 结果为 0, <code>|value</code> 结果为 1, <code>~^value</code> 结果为 1.</p><h4 id="关系和逻辑运算符"><a href="#关系和逻辑运算符" class="headerlink" title="关系和逻辑运算符"></a>关系和逻辑运算符</h4><p>这些运算符可用于条件判断, 取值结果为 <code>true</code> 或者 <code>false</code>. 着重解释一下全等运算符和不全等运算符.</p><ul><li><code>===</code> 关系运算符全等. </li><li><code>!==</code> 关系运算符不全等. </li></ul><p>相等运算符 <code>==</code> 在进行比较时, 需要按每位进行比较, 只有所有的位都相等的时候, 最后的结果值才会是 <code>true</code>. 如果其中的某一位是高阻态或者不定值, 最终的结果是不定值. 对于全等 <code>===</code> 来说, 这些高阻态或者不定值也需要进行比较, 完全一致才会获得 <code>true</code> 结果.  </p><div class="table-container"><table><thead><tr><th style="text-align:center">A</th><th style="text-align:center">B</th><th style="text-align:center">A==B</th><th style="text-align:center">A===B</th></tr></thead><tbody><tr><td style="text-align:center">4b1101</td><td style="text-align:center">4b1101</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">4b1100</td><td style="text-align:center">4b1101</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">4b110Z</td><td style="text-align:center">4b110Z</td><td style="text-align:center">X</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">4b11XX</td><td style="text-align:center">4b11XX</td><td style="text-align:center">X</td><td style="text-align:center">1</td></tr></tbody></table></div><h4 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h4><p>算术运算符并不是最基本的运算符, 需要使用对应的门电路组织成的组合逻辑来完成. 这是语言内部提供的高层的逻辑单元功能, 方便在开发的时候直接集成使用, 而不需要采用模块调用的方式. 在处理器的设计中, 算术运算符的最重要的作用是用来构成 ALU.</p><h4 id="位拼接运算符"><a href="#位拼接运算符" class="headerlink" title="位拼接运算符"></a>位拼接运算符</h4><p>位拼接运算符 <code>{ }</code> 能够把多个信号拼接为向量的形式. <code>{a[3:0], b[7:6],c}</code> 代表了将 <code>a</code> 的第 3 至第 0 位, <code>b</code> 的第 7 位和第 6 位, 以及信号 <code>c</code> 拼接在一起, 构成一个新的信号向量. </p><h2 id="SystemVerilog-的行为语句"><a href="#SystemVerilog-的行为语句" class="headerlink" title="SystemVerilog 的行为语句"></a>SystemVerilog 的行为语句</h2><h3 id="关于硬件描述语言功能的讨论"><a href="#关于硬件描述语言功能的讨论" class="headerlink" title="关于硬件描述语言功能的讨论"></a>关于硬件描述语言功能的讨论</h3><p>行为语句是 SystemVerilog 中最为重要的功能语句, 用来定义具体模块的行为. 在术语上一直使用的是硬件<strong>描述语言</strong>这样的叙述方式, 而不是硬件<strong>设计语言</strong>. 因为硬件描述语言大部分没有说明底层的硬件构成, 更多阐述模块对外的功能表现.</p><p>在使用硬件描述语言的时候, 更多的是描述对应的电路模块应具有什么功能. 硬件语言的编译器会翻译为对应的底层硬件的实现, 有一定的中立性, 不依赖于具体的物理实现方式. 因此, 描述完成之后不一定是可以综合的 (可物理实现的). 在开发的时候, 时刻要注意程序最终需要被转化为硬件电路. </p><h3 id="SystemVerilog-的行为语句综述"><a href="#SystemVerilog-的行为语句综述" class="headerlink" title="SystemVerilog 的行为语句综述"></a>SystemVerilog 的行为语句综述</h3><p>SystemVerilog 的行为语句包括赋值语句, 过程语句, 条件语句, 编译指导语句等. 不是所有的行为语句都是可以综合的, 但不可综合的行为语句作用也十分重要, 会被应用到仿真环境中. 在 SystemVerilog 中可综合的行为语句主要包括以下部分: </p><ol><li><code>always</code> 过程语句;</li><li>使用 <code>begin-end</code> 组合的语句块;</li><li>可以进行持续赋值的语句 <code>assign</code>; </li><li>阻塞的过程赋值语句 <code>=</code>, 非阻塞的过程赋值语句 <code>&lt;=</code>;</li><li><code>for</code> 循环语句. </li></ol><h3 id="always-过程语句"><a href="#always-过程语句" class="headerlink" title="always 过程语句"></a>always 过程语句</h3><p>一个模块的多个 <code>always</code> 过程语句是并行执行的. 在实现的时候, 通常会使用两种 <code>always</code> 过程语句: </p><ul><li><code>always_comb</code>: 用来实现<strong>组合逻辑</strong>;</li><li><code>always_ff</code>: 用来实现<strong>时钟边沿触发的时序逻辑</strong>.</li></ul><h4 id="always-comb-过程语句"><a href="#always-comb-过程语句" class="headerlink" title="always_comb 过程语句"></a>always_comb 过程语句</h4><p><code>always_comb</code> 过程语句的使用方法如下: </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token important">always_comb</span>     语句 <span class="token punctuation">(</span>可以是一条语句<span class="token punctuation">,</span> 或者是语句块<span class="token punctuation">)</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果只有一条语句, 不需要加 <code>begin end</code> 构成语句块; 如果超过一条则需要构造成语句块. 更加经常使用的形式是如下形式:</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token important">always_comb</span><span class="token keyword">begin</span>    <span class="token comment">//本过程的功能描述</span><span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>一个四选一数据选择器的模块例子: </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> mux4_1 <span class="token punctuation">(</span>    <span class="token keyword">input</span> din1<span class="token punctuation">,</span>    <span class="token keyword">input</span> din2<span class="token punctuation">,</span>    <span class="token keyword">input</span> din3<span class="token punctuation">,</span>    <span class="token keyword">input</span> din4<span class="token punctuation">,</span>    <span class="token keyword">input</span> se1<span class="token punctuation">,</span>    <span class="token keyword">input</span> se2<span class="token punctuation">,</span>    <span class="token keyword">output</span> <span class="token keyword">reg</span> out<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token important">always_comb</span>        <span class="token keyword">case</span> <span class="token punctuation">(</span><span class="token operator">{</span>se1<span class="token punctuation">,</span>se2<span class="token operator">}</span><span class="token punctuation">)</span>            <span class="token number">2'b00</span> <span class="token punctuation">:</span> out <span class="token operator">=</span> din1<span class="token punctuation">;</span>            <span class="token number">2'b01</span> <span class="token punctuation">:</span> out <span class="token operator">=</span> din2<span class="token punctuation">;</span>            <span class="token number">2'b10</span> <span class="token punctuation">:</span> out <span class="token operator">=</span> din3<span class="token punctuation">;</span>            <span class="token number">2'b11</span> <span class="token punctuation">:</span> out <span class="token operator">=</span> din4<span class="token punctuation">;</span>        <span class="token keyword">endcase</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个 <code>always_comb</code> 过程语句的有四个输入信号以及两个选择信号, 任何一个发生变化, 输出都将发生变化. </p><h4 id="always-ff-过程语句"><a href="#always-ff-过程语句" class="headerlink" title="always_ff 过程语句"></a>always_ff 过程语句</h4><p>在实现时序逻辑的时候, 需要在上升沿或者下降沿事件中触发寄存器的更新. 在 SystemVerilog 中, 使用 <code>posedge</code> 指定上升沿, 使用 <code>negedge</code> 指定下降沿. 可以将边沿敏感类型的信号放置到 <code>always_ff</code>: </p><pre class="line-numbers language-none"><code class="language-none">always_ff @(posedge clk)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里响应的是一个时钟 <code>clk</code> 的上升沿信号, 时钟是驱动处理器执行的基础, 在进行综合的时候会综合出时序电路. </p><h3 id="begin-end-块语句"><a href="#begin-end-块语句" class="headerlink" title="begin/end 块语句"></a>begin/end 块语句</h3><p><code>begin/end</code> 能够将多条语句组合成语句块.</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> decoder2_4 <span class="token punctuation">(</span>    <span class="token keyword">input</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> in<span class="token punctuation">,</span>    <span class="token keyword">output</span> <span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> out<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token important">always_comb</span> <span class="token keyword">begin</span>        out <span class="token operator">=</span> <span class="token number">4'b0000</span><span class="token punctuation">;</span>        <span class="token function">case</span><span class="token punctuation">(</span>in<span class="token punctuation">)</span>            <span class="token number">2'b00</span> <span class="token punctuation">:</span> out <span class="token operator">=</span> <span class="token number">4'b0001</span><span class="token punctuation">;</span>            <span class="token number">2'b01</span> <span class="token punctuation">:</span> out <span class="token operator">=</span> <span class="token number">4'b0010</span><span class="token punctuation">;</span>            <span class="token number">2'b10</span> <span class="token punctuation">:</span> out <span class="token operator">=</span> <span class="token number">4'b0100</span><span class="token punctuation">;</span>            <span class="token number">2'b11</span> <span class="token punctuation">:</span> out <span class="token operator">=</span> <span class="token number">4'b1000</span><span class="token punctuation">;</span>        <span class="token keyword">endcase</span>    <span class="token keyword">end</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为需要一个初值, 在 <code>begin/end</code> 中有两条语句, 必须构造出一个语句块, 也往往被称为是串行块, 其含义就是 “顺序执行” 的. 在硬件综合完成之后, 各个部分的电信号就开始驱动整个硬件电路信号扩散, 并逐步稳定下来, 输出会随着输入的变化而随时变化. </p><h3 id="赋值语句"><a href="#赋值语句" class="headerlink" title="赋值语句"></a>赋值语句</h3><p>赋值语句可以将不同的信号组织起来, 包括了持续赋值语句和过程赋值语句. 持续赋值语句在过程外使用, 与过程语句并行执行. 过程赋值语句在过程内串行执行, 用于描述过程的功能.</p><h4 id="持续赋值语句"><a href="#持续赋值语句" class="headerlink" title="持续赋值语句"></a>持续赋值语句</h4><p>在 SystemVerilog 中使用 <code>assign</code> 作为持续赋值语句使用, 用于对 <code>wire</code> 类型的变量进行赋值. 其对应的硬件即通过对输出进行赋值, 当输入变化时, 经过一定延迟, 输出就会按照 <code>assign</code> 所描述的那样发生变化. 例如: </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">assign</span> res <span class="token operator">=</span> input_a <span class="token operator">&amp;</span> input_b<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在一个模块中, 可以有多个 <code>assign</code> 的持续赋值语句并行执行. 一个模块的持续赋值语句和前面所说的 <code>always</code> 过程语句可以出现多次, 执行关系也是并行的.</p><h4 id="过程赋值语句"><a href="#过程赋值语句" class="headerlink" title="过程赋值语句"></a>过程赋值语句</h4><p>在 <code>always</code> 过程里面的赋值语句被称为过程赋值语句, 一般用来对 <code>reg</code> 类型的变量进行赋值. 一个是非阻塞赋值语句 <code>&lt;=</code>, 一个是阻塞赋值语句 <code>=</code>. 之间的区别是: </p><ul><li>非阻塞赋值语句 <code>&lt;=</code> 不立即更新被赋值的信号, 等到整个过程块结束时才更新. 由于不是立即发生的, 在过程内仿佛这条语句不存在一样. 在这个执行的过程中, 所有的左值会维持不变, 反映了时钟边沿触发的寄存器的行为特征, 在 <code>always_ff</code> 中需要采用非阻塞赋值. </li></ul><ol><li>阻塞赋值语句 <code>=</code> 立即完成赋值操作, 左值立刻发生变化. 一个块语句中存在多条阻塞赋值语句, 会按照先后顺序关系执行. 这种行为模式和网络 IO 编程中的阻塞函数调用方式一样, 完成函数执行之后调用才会退出. 这种特性可以用来直观描述组合逻辑的行为特征, 在 <code>always_comb</code> 中需要采用阻塞赋值.</li></ol><p>非阻塞赋值要比阻塞赋值多加一个触发器, 因为信号的变化不是同步的, 需要进行一个周期的延迟. </p><h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><p>在 SystemVerilog 中, 条件语句包括了 <code>if-else</code> 语句以及 <code>case</code> 语句.</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> decoder2_4 <span class="token punctuation">(</span>    <span class="token keyword">input</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> din<span class="token punctuation">,</span>    <span class="token keyword">output</span> <span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> dout<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token important">always_comb</span> <span class="token keyword">begin</span>        dout <span class="token operator">=</span> <span class="token number">4'b0000</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>din <span class="token operator">==</span> <span class="token number">2'b00</span><span class="token punctuation">)</span>            dout <span class="token operator">=</span> <span class="token number">4'b0001</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>din <span class="token operator">==</span> <span class="token number">2'b01</span><span class="token punctuation">)</span>            dout <span class="token operator">=</span> <span class="token number">4'b0010</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>din <span class="token operator">==</span> <span class="token number">2'b10</span><span class="token punctuation">)</span>            dout <span class="token operator">=</span> <span class="token number">4'b0100</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>din <span class="token operator">==</span> <span class="token number">2'b11</span><span class="token punctuation">)</span>            dout <span class="token operator">=</span> <span class="token number">4'b1000</span><span class="token punctuation">;</span>    <span class="token keyword">end</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 SystemVerilog 中也提供了 <code>case</code> 这样的条件判断语句, 避免使用过多的 if-else 进行编写.</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">case</span> <span class="token punctuation">(</span>敏感表达式<span class="token punctuation">)</span>    条件判断<span class="token number">1</span><span class="token punctuation">:</span> 语句<span class="token number">1</span><span class="token punctuation">;</span>     条件判断<span class="token number">2</span><span class="token punctuation">:</span> 语句<span class="token number">2</span><span class="token punctuation">;</span>     <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    条件判断n<span class="token punctuation">:</span> 语句n<span class="token punctuation">;</span>    <span class="token keyword">default</span><span class="token punctuation">:</span> 语句n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">endcase</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里语句不需要插入 <code>break</code>, 在语句执行完成后, 直接跳出了 case 语句本身, 这样的行为模式对于程序员来说更加友好. </p><h3 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h3><p>SystemVerilog 中也存在循环语句. 可综合的循环语句为 <code>for</code> 语句. 循环语句不容易直观想象得出综合之后的效果, 描述的功能更加高层和抽象, 转化为硬件的难度会更大. 其它三个循环语句分别为 <code>forever</code> 语句, <code>repeat</code> 语句, <code>while</code> 语句. 其中 <code>forever</code> 语句会连续执行语句, 主要在仿真中使用, 生成周期性的波形 (时钟信号). </p><p><code>repeat</code> 语句: </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token function">repeat</span><span class="token punctuation">(</span>循环次数的表达式<span class="token punctuation">)</span><span class="token keyword">begin</span>    语句或者语句块<span class="token keyword">end</span> <span class="token comment">// 单个语句不需要 begin 和 end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><code>while</code> 语句: </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token function">while</span><span class="token punctuation">(</span>循环执行的条件表达式<span class="token punctuation">)</span><span class="token keyword">begin</span>    语句或者语句块<span class="token keyword">end</span> <span class="token comment">// 单个语句不需要 begin 和 end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><code>repeat</code> 和 <code>while</code> 往往不可综合, 编写代码时尽量使用 <code>for</code> 语句来实现循环.</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> for_adder <span class="token punctuation">(</span>    <span class="token keyword">input</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span>    <span class="token keyword">input</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> b<span class="token punctuation">,</span>    <span class="token keyword">input</span> cin<span class="token punctuation">,</span>    <span class="token keyword">output</span> <span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> sum<span class="token punctuation">,</span>    <span class="token keyword">output</span> <span class="token keyword">reg</span> cout<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">reg</span> c<span class="token punctuation">;</span>    <span class="token keyword">integer</span> i<span class="token punctuation">;</span>    <span class="token important">always_comb</span> <span class="token keyword">begin</span>        c <span class="token operator">=</span> cin<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">8</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>            <span class="token operator">{</span>c<span class="token punctuation">,</span>sum<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">}</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> b<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> c<span class="token punctuation">;</span>        <span class="token keyword">end</span>        cout <span class="token operator">=</span> c<span class="token punctuation">;</span>    <span class="token keyword">end</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这是一个功能描述的代码, 描述层次比较抽象, 不是功能设计的代码. </p><h2 id="SystemVerilog-的设计层次与风格"><a href="#SystemVerilog-的设计层次与风格" class="headerlink" title="SystemVerilog 的设计层次与风格"></a>SystemVerilog 的设计层次与风格</h2><p>SystemVerilog 的语言有很大的灵活性, 对于相同的电路可以有不同的设计方法. 一个 1 位全加器的输入包括 1 位的低位进位 <code>cin</code>, 两个 1 位的输入信号 <code>a</code> 和 <code>b</code>, 输出则包括了一个当前位的和 <code>sum</code> 以及向高位的进位 <code>cout</code>. 从 1 位全加器的真值表可以获得逻辑表达式 (这里只使用与或非门的表达): </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">CarryOut</span><span class="token operator">=</span><span class="token punctuation">(</span>¬A*B*CarryIn<span class="token punctuation">)</span>+<span class="token punctuation">(</span>A*¬B*CarryIn<span class="token punctuation">)</span>+<span class="token punctuation">(</span>A*B*¬CarryIn<span class="token punctuation">)</span>+<span class="token punctuation">(</span>A*B*CarryIn<span class="token punctuation">)</span><span class="token operator">=</span><span class="token punctuation">(</span>B*CarryIn<span class="token punctuation">)</span>+<span class="token punctuation">(</span>A*CarryIn<span class="token punctuation">)</span>+<span class="token punctuation">(</span>A*B<span class="token punctuation">)</span><span class="token assign-left variable">Sum</span><span class="token operator">=</span><span class="token punctuation">(</span>¬A*¬B*CarryIn<span class="token punctuation">)</span>+<span class="token punctuation">(</span>¬A*B*¬CarryIn<span class="token punctuation">)</span>+<span class="token punctuation">(</span>A*¬B*¬CarryIn<span class="token punctuation">)</span>+<span class="token punctuation">(</span>A*B*CarryIn<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>很容易获得 1 位全加器的电路表达形式: </p><p><img src="/pic/192.png" alt=""></p><p>在上述的电路中, 使用了三个非门 <code>not</code>, 四个 3 输入的与门 <code>and</code>, 三个 2 输入的与门 <code>and</code>, 一个 4 输入的或门 <code>or</code>, 一个 3 输入的或门 <code>or</code>. 这里的非门, 与门和或门都是 SystemVerilog 中内置的门电路, 可以直接构造出 SystemVerilog 的结构描述. </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> full_adder1 <span class="token punctuation">(</span>    <span class="token keyword">input</span> a<span class="token punctuation">,</span>    <span class="token keyword">input</span> b<span class="token punctuation">,</span>    <span class="token keyword">input</span> cin<span class="token punctuation">,</span>    <span class="token keyword">output</span> sum<span class="token punctuation">,</span>    <span class="token keyword">output</span> cout<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">wire</span> a_n<span class="token punctuation">,</span> b_n<span class="token punctuation">,</span> cin_n<span class="token punctuation">,</span> sum_p1<span class="token punctuation">,</span>sum_p2<span class="token punctuation">,</span>sum_p3<span class="token punctuation">,</span>sum_p4<span class="token punctuation">,</span> cout_p1<span class="token punctuation">,</span> cout_p2<span class="token punctuation">,</span> cout_p3<span class="token punctuation">;</span>    <span class="token function">not</span><span class="token punctuation">(</span>a_n<span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span>b_n<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span>cin_n<span class="token punctuation">,</span>cin<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">and</span><span class="token punctuation">(</span>sum_p1<span class="token punctuation">,</span>a_n<span class="token punctuation">,</span>b_n<span class="token punctuation">,</span>cin<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span>sum_p2<span class="token punctuation">,</span>a_n<span class="token punctuation">,</span>b<span class="token punctuation">,</span>cin_n<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span>sum_p3<span class="token punctuation">,</span>a<span class="token punctuation">,</span>b_n<span class="token punctuation">,</span>cin_n<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span>sum_p4<span class="token punctuation">,</span>a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>cin<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span>cout_p1<span class="token punctuation">,</span>b<span class="token punctuation">,</span>cin<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span>cout_p2<span class="token punctuation">,</span>a<span class="token punctuation">,</span>cin<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span>cout_p3<span class="token punctuation">,</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">or</span><span class="token punctuation">(</span>sum<span class="token punctuation">,</span>sum_p1<span class="token punctuation">,</span>sum_p2<span class="token punctuation">,</span>sum_p3<span class="token punctuation">,</span>sum_p4<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span>cout<span class="token punctuation">,</span>cout_p1<span class="token punctuation">,</span>cout_p2<span class="token punctuation">,</span>cout_p3<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>门级结构描述虽然不是最底层的描述 (晶体管搭建), 但是已经非常接近, 可以使用元件进行直接映射. 这种方法一般用于设计比较简单或者高效的工作电路, 方便综合器直接进行综合.</p><p>门级结构描述虽然方便了底层的综合器, 但是对于编程来说不方便, 希望能够进行更加高层的设计, 一个选择是将上述的逻辑表达式写到程序里, 这是数据流描述方法. </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> full_adder1 <span class="token punctuation">(</span>    <span class="token keyword">input</span> a<span class="token punctuation">,</span>    <span class="token keyword">input</span> b<span class="token punctuation">,</span>    <span class="token keyword">input</span> cin<span class="token punctuation">,</span>    <span class="token keyword">output</span> sum<span class="token punctuation">,</span>    <span class="token keyword">output</span> cout<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">assign</span> sum <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">~</span>a<span class="token operator">&amp;~</span>b<span class="token operator">&amp;</span>cin<span class="token punctuation">)</span><span class="token operator">|</span><span class="token punctuation">(</span><span class="token operator">~</span>a<span class="token operator">&amp;</span>b<span class="token operator">&amp;~</span>cin<span class="token punctuation">)</span><span class="token operator">|</span><span class="token punctuation">(</span>a<span class="token operator">&amp;~</span>b<span class="token operator">&amp;~</span>cin<span class="token punctuation">)</span><span class="token operator">|</span><span class="token punctuation">(</span>a<span class="token operator">&amp;</span>b<span class="token operator">&amp;</span>cin<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">assign</span> cout <span class="token operator">=</span> <span class="token punctuation">(</span>b<span class="token operator">&amp;</span>cin<span class="token punctuation">)</span><span class="token operator">|</span><span class="token punctuation">(</span>a<span class="token operator">&amp;</span>cin<span class="token punctuation">)</span><span class="token operator">|</span><span class="token punctuation">(</span>a<span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>数据流描述方法描述了组合逻辑中, 输出是如何随着输入数据的变化而变化, 使用持续赋值语句 <code>assign</code>. 但是, 数据流描述的抽象层次还不是很高, 对于复杂的硬件逻辑设计来说, 使用行为级描述, 即直接描述出硬件所需要完成的功能更为妥当. </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> full_adder1 <span class="token punctuation">(</span>    <span class="token keyword">input</span> a<span class="token punctuation">,</span>    <span class="token keyword">input</span> b<span class="token punctuation">,</span>    <span class="token keyword">input</span> cin<span class="token punctuation">,</span>    <span class="token keyword">output</span> <span class="token keyword">reg</span> sum<span class="token punctuation">,</span>    <span class="token keyword">output</span> <span class="token keyword">reg</span> cout<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token important">always_comb</span> <span class="token keyword">begin</span>        <span class="token operator">{</span>cout<span class="token punctuation">,</span>sum<span class="token operator">}=</span>a<span class="token operator">+</span>b<span class="token operator">+</span>cin<span class="token punctuation">;</span>    <span class="token keyword">end</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从行为级描述中看不到电路怎样使用元件以及怎样布线, 但是完整描述了一个全加器所需要完成的功能. </p><p>在设计更加大型的硬件电路的时候, 使用结构级描述是必不可少的. 可以设计一些小型电路模块, 通过结构描述设计出规模更大的电路. 通过设计 4 位的加法器来说明: </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> full_adder4 <span class="token punctuation">(</span>    <span class="token keyword">input</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span>    <span class="token keyword">input</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> b<span class="token punctuation">,</span>    <span class="token keyword">input</span> cin<span class="token punctuation">,</span>    <span class="token keyword">output</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> sum<span class="token punctuation">,</span>    <span class="token keyword">output</span> cout<span class="token punctuation">)</span><span class="token punctuation">;</span>    full_adder1 <span class="token function">a0</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>b<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>cin<span class="token punctuation">,</span>sum<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>cin1<span class="token punctuation">)</span><span class="token punctuation">;</span>    full_adder1 <span class="token function">a1</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>b<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>cin1sum<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>cin2<span class="token punctuation">)</span><span class="token punctuation">;</span>    full_adder1 <span class="token function">a2</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span>b<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span>cin2sum<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span>cin3<span class="token punctuation">)</span><span class="token punctuation">;</span>    full_adder1 <span class="token function">a3</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span>b<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span>cin3sum<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span>cout<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在实际进行硬件设计的时候, 出发点还是自顶向下, 对硬件总体先分成多个互相独立的模块, 然后定义之间的连线关系, 连线关系即是它们之间的接口, 最终完成的硬件通过结构描述方式将模块连接在一起. </p><h2 id="一些编程建议与经验"><a href="#一些编程建议与经验" class="headerlink" title="一些编程建议与经验"></a>一些编程建议与经验</h2><h3 id="default-nettype-none"><a href="#default-nettype-none" class="headerlink" title="`default_nettype none"></a><code>`default_nettype none</code></h3><p>SystemVerilog 中没有被定义的标记 label 都被默认为是 <code>wire</code> 类型的, 建议的做法是 <code>`default_nettype none</code>. 这可以防止在信号名字上出现的拼写错误. </p><h3 id="锁相环电路"><a href="#锁相环电路" class="headerlink" title="锁相环电路"></a>锁相环电路</h3><p>PLL 是 FPGA 上专用的时钟生成模块, 内部是模拟电路. PLL 在启动时需要一段时间才能进入稳定状态, <code>locked</code> 信号输出表示稳定. 在锁相环电路稳定输出之后, <code>locked</code> 信号会被置位, 此时可以进行电路寄存器初始化. </p><h3 id="调时序"><a href="#调时序" class="headerlink" title="调时序"></a>调时序</h3><p>硬件编程是仿真驱动的, 比较难的部分是调时序, 使各个部分的时序相互匹配, 同时满足对于外设的时间要求. 不同模块之间由于寄存器的关系有相位差, 需要增加几个空的状态机节拍, 匹配不同路径的信号传播. </p><h3 id="阻塞赋值语句和非阻塞赋值语句"><a href="#阻塞赋值语句和非阻塞赋值语句" class="headerlink" title="阻塞赋值语句和非阻塞赋值语句"></a>阻塞赋值语句和非阻塞赋值语句</h3><p>一般来说, 组合逻辑用 <code>=</code>, 时序逻辑用 <code>&lt;=</code>. <code>wire</code> 和 <code>reg</code> 是语法层面的内容, <code>assign</code> 的左值必须是 <code>wire</code>, <code>always</code> 里的左值必须是 <code>reg</code>, 否则综合会报错. 是否综合成触发器, 根据有没有时钟信号决定. 综合器通过 <code>posedge</code> 的描述方法知道对应的模块里面需要响应 <code>posedge</code> 或是 <code>negedge</code>, 从而综合出触发器. 尽量使用 <code>logic</code> 类型并匹配 <code>always_comb</code> 和 <code>always_ff</code> 来分别描述组合逻辑和时序逻辑.</p><h3 id="程序的可读性"><a href="#程序的可读性" class="headerlink" title="程序的可读性"></a>程序的可读性</h3><p>增加程序的可维护性, 在选择信号名称的时候需要按照名称选择的惯例, 有一些命名方法是常用的.</p><ul><li><code>_i</code>, <code>_o</code>, 分别代表一个模块的输入信号和输出信号. </li><li><code>n</code> 或者 <code>_n</code> 为后缀, 表明这个信号是 0 使能, 0 表示有效. </li><li><code>clk</code>, <code>clock</code> 时钟信号, 后面或者前面接上频率, 可以显示时钟信号的频率. </li><li><code>rst</code>, <code>reset</code> 复位信号, 使得信号可以重置, 一般在重置响应中写入状态机的初值. </li><li><code>we</code>, <code>write enable</code> 信号, 对应于模块的写入使能. </li><li><code>oe</code>, <code>output enable</code> 信号, 对应于模块的输出使能. </li><li><code>ce</code>, <code>chip enable</code>, 对应于模块的总体使能信号. 上述的信号几乎在所有的模块中都会有 (注意信号是正向的还是反向的, 即 1 使能还是 0 使能. 0 使能会在信号名称的上面带有横线).</li><li><code>select</code>, <code>sel</code> 信号, 一般用于对芯片的选择. </li></ul><h3 id="代码检查工具"><a href="#代码检查工具" class="headerlink" title="代码检查工具"></a>代码检查工具</h3><p><a href="https://www.veripool.org/">这个网址</a>中有一些 SystemVerilog 的工具可供参考. 使用</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">verilator --lint-only <span class="token parameter variable">-Wall</span> <span class="token punctuation">[</span>source_files.v<span class="token punctuation">]</span><span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以帮助做一些检查. </p><h3 id="一些特殊的语法点"><a href="#一些特殊的语法点" class="headerlink" title="一些特殊的语法点"></a>一些特殊的语法点</h3><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog">ram_address <span class="token operator">=</span> pc<span class="token punctuation">[</span><span class="token number">2</span><span class="token operator">+</span><span class="token punctuation">:</span><span class="token number">21</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>从第 2 位开始的 21 位, 把最后两位去掉. 也可以写成 <code>pc[22-:21]</code> 或 <code>pc[22:2]</code>. </p><h3 id="case-语句可能出现错误的情况"><a href="#case-语句可能出现错误的情况" class="headerlink" title="case 语句可能出现错误的情况:"></a>case 语句可能出现错误的情况:</h3><p>使用 <code>case</code> 的时候把所有信号在所有情况下写全, 或者灵活使用阻塞赋值语句 <code>=</code>, 在过程最前面的时候先进行赋值. </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token important">always_comb</span> <span class="token keyword">begin</span>    ram_we_n <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>    ram_oe_n <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>    ram_address <span class="token operator">=</span> <span class="token number">21'h0</span><span class="token punctuation">;</span>    <span class="token keyword">case</span> <span class="token punctuation">(</span>state<span class="token punctuation">)</span>        STATE_FETCH<span class="token punctuation">:</span> <span class="token keyword">begin</span>            ram_oe_n <span class="token operator">=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span>            ram_address <span class="token operator">=</span> pc<span class="token punctuation">[</span><span class="token number">22</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">end</span>        STATE_MEM<span class="token punctuation">:</span> <span class="token keyword">begin</span>            ram_oe_n <span class="token operator">=</span> mem_op_write<span class="token punctuation">;</span>            ram_we_n <span class="token operator">=</span> <span class="token operator">~</span>mem_op_write<span class="token punctuation">;</span>            ram_address <span class="token operator">=</span> ex_val_o<span class="token punctuation">[</span><span class="token number">22</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>         <span class="token keyword">end</span>    <span class="token keyword">endcase</span><span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面的 case 语句代码块也是正确的: </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token important">always_comb</span> <span class="token keyword">begin</span>    <span class="token keyword">case</span> <span class="token punctuation">(</span>state<span class="token punctuation">)</span>        STATE_FETCH<span class="token punctuation">:</span> <span class="token keyword">begin</span>            ram_oe_n <span class="token operator">=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span>            ram_we_n <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>            ram_address <span class="token operator">=</span> pc<span class="token punctuation">[</span><span class="token number">22</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">end</span>        STATE_MEM<span class="token punctuation">:</span> <span class="token keyword">begin</span>            ram_oe_n <span class="token operator">=</span> mem_op_write<span class="token punctuation">;</span>            ram_we_n <span class="token operator">=</span> <span class="token operator">~</span>mem_op_write<span class="token punctuation">;</span>            ram_address <span class="token operator">=</span> ex_val_o<span class="token punctuation">[</span><span class="token number">22</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>         <span class="token keyword">end</span>        <span class="token keyword">default</span><span class="token punctuation">:</span> <span class="token keyword">begin</span>            ram_oe_n <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>            ram_we_n <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>            ram_address <span class="token operator">=</span> <span class="token number">21'h0</span><span class="token punctuation">;</span>        <span class="token keyword">end</span>    <span class="token keyword">endcase</span><span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是下面的 case 语句代码块是错误的.</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token important">always_comb</span> <span class="token keyword">begin</span>    <span class="token keyword">case</span> <span class="token punctuation">(</span>state<span class="token punctuation">)</span>        STATE_FETCH<span class="token punctuation">:</span> <span class="token keyword">begin</span>            ram_oe_n <span class="token operator">=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span>            ram_address <span class="token operator">=</span> pc<span class="token punctuation">[</span><span class="token number">22</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">end</span>        STATE_MEM<span class="token punctuation">:</span> <span class="token keyword">begin</span>            ram_oe_n <span class="token operator">=</span> mem_op_write<span class="token punctuation">;</span>            ram_we_n <span class="token operator">=</span> <span class="token operator">~</span>mem_op_write<span class="token punctuation">;</span>            ram_address <span class="token operator">=</span> ex_val_o<span class="token punctuation">[</span><span class="token number">22</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>         <span class="token keyword">end</span>        <span class="token keyword">default</span><span class="token punctuation">:</span> <span class="token keyword">begin</span>            ram_oe_n <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>            ram_we_n <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>            ram_address <span class="token operator">=</span> <span class="token number">21'h0</span><span class="token punctuation">;</span>        <span class="token keyword">end</span>    <span class="token keyword">endcase</span><span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Warning-empty-statement-in-sequential-block"><a href="#Warning-empty-statement-in-sequential-block" class="headerlink" title="Warning: empty statement in sequential block"></a>Warning: empty statement in sequential block</h3><p>两个分号放在一起 <code>;;</code> 就会出现这个警告. 一个容易出现的错误是在信号常数定义 <code>`define</code> 的时候, 在信号后面跟了一个分号, 在模块代码里面直接使用的时候就会出现上面的情况. </p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;SystemVerilog入门使用&quot;&gt;&lt;a href=&quot;#SystemVerilog入门使用&quot; class=&quot;headerlink&quot; title=&quot;SystemVerilog入门使用&quot;&gt;&lt;/a&gt;SystemVerilog入门使用&lt;/h1&gt;&lt;h2</summary>
        
      
    
    
    
    <category term="CS" scheme="http://chengsx21.github.io/categories/CS/"/>
    
    <category term="Organization &amp; Design" scheme="http://chengsx21.github.io/categories/CS/Organization-Design/"/>
    
    
    <category term="Organization &amp; Design" scheme="http://chengsx21.github.io/tags/Organization-Design/"/>
    
    <category term="SV" scheme="http://chengsx21.github.io/tags/SV/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成原理 笔记2</title>
    <link href="http://chengsx21.github.io/2023/09/23/ji-suan-ji-zu-cheng-yuan-li-bi-ji-2/"/>
    <id>http://chengsx21.github.io/2023/09/23/ji-suan-ji-zu-cheng-yuan-li-bi-ji-2/</id>
    <published>2023-09-23T09:18:57.000Z</published>
    <updated>2024-06-30T09:53:39.689Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RISC-V-监控程序"><a href="#RISC-V-监控程序" class="headerlink" title="RISC-V 监控程序"></a>RISC-V 监控程序</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong>Thinpad</strong> 教学计算机搭配了监控程序, 能够接受用户命令, 支持输入汇编指令并运行, 查看寄存器及内存状态. 监控程序可在实现的 32/64 位 <strong>RISC-V</strong> CPU 上运行, 一方面帮助理解、掌握 RISC-V 指令系统及其软件开发, 另一方面作为验证 CPU 功能正确性的标准. </p><p>监控程序分为 <strong>Kernel</strong> 和 <strong>Term</strong> 两个部分. 其中 Kernel 使用 RISC-V 汇编语言编写, 运行在 Thinpad 上学生实现的 <strong>CPU</strong> 中, 用于<strong>管理硬件资源</strong>; Term 是上位机程序, 使用 Python 语言编写, 有基于命令行的用户界面, 达到与<strong>用户交互</strong>的目的. Kernel 和 Term 直接通过串口通信, 即用户在 Term 界面中输入的命令、代码经过 Term 处理后, 通过串口传输给 Kernel 程序; 反过来, Kernel 输出的信息也会通过串口传输到 Term 并展示给用户. </p><h2 id="Kernel"><a href="#Kernel" class="headerlink" title="Kernel"></a>Kernel</h2><p>Kernel 使用汇编语言编写, 使用到的指令有 20 余条, 均符合 RISC-V 规范. Kernel 提供了三种不同的版本, 以适应不同的档次的 CPU 实现: 第一档为<strong>基础版本</strong>, 直接基本的 I/O 和命令执行功能, 不依赖异常、中断、csr 等处理器特征, 适合于最简单的 CPU 实现; 第二档<strong>支持中断</strong>, 使用中断方式完成串口的 I/O 功能, 需要处理器实现中断处理机制, 及相关的 csr 寄存器; 第三档进一步增加了<strong>页表的应用</strong>, 要求处理器支持基于 Sv32 或者 Sv39 的内存映射, 更加接近于操作系统对处理器的需求. </p><p>为了在硬件上运行 Kernel 程序, 我们首先要对 Kernel 的汇编代码进行编译. 在 <code>kernel</code> 文件夹下面, 有汇编代码和 Makefile 文件, 我们可以使用 make 工具编译 Kernel 程序. 假设当前目录为 <code>kernel</code> , 目标版本为基础版本, 在终端中运行命令:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">make</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>即可开始编译流程. 如果顺利结束, 将生成 <code>kernel.elf</code> 和 <code>kernel.bin</code> 文件, 即可执行文件. 要在模拟器中运行它, 可以使用命令:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">make</span> sim<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>它会在 <strong>QEMU</strong> 中启动监控程序, 并等待 Term 程序连接. 本文后续章节介绍了如何使用 Term 连接模拟器. 需要注意的是, 如果需要打开一些开关, 需要在每条命令中传递参数, 比如:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">make</span> <span class="token assign-left variable">EN_INT</span><span class="token operator">=</span>y sim<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>而不是</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">make</span> <span class="token assign-left variable">EN_INT</span><span class="token operator">=</span>y<span class="token function">make</span> sim<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>目前所有可能出现的开关有: </p><ol><li><code>EN_INT</code>: 打开中断、异常和用户态支持, 默认关闭. </li><li><code>EN_PAGING</code>: 打开页表支持, 要求 <code>EN_INT</code> 已打开, 默认关闭. </li><li><code>EN_FENCEI</code>: 如果实现了 L1 Cache 并且分离了 I Cache 和 D Cache 则应当开启, 在写入代码后执行 <code>FENCE.I</code> 指令, 默认关闭. </li><li><code>EN_UART16550</code>: 如果实现了 UART 16550 兼容的串口控制器则要开启, 否则可以关闭, 默认开启. </li></ol><p>若要在硬件上运行, 使用开发板提供的工具, 将 <code>kernel.bin</code> 写入内存 0x80000000 地址位置, 并让处理器复位从 0x80000000 地址处开始执行, Kernel 就运行起来了. </p><p>Kernel 运行后会先通过串口输出版本号, 该功能可作为检验其正常运行的标志. 之后 Kernel 将等待 Term 从串口发来的命令, 关于 Term 的使用将在后续章节描述.  </p><h3 id="基础版本"><a href="#基础版本" class="headerlink" title="基础版本"></a>基础版本</h3><p>基础版本的 Kernel 共使用了 19 条不同的指令, 它们是: </p><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">ADD   0000000SSSSSsssss000ddddd0110011ADDI  iiiiiiiiiiiisssss000ddddd0010011AND   0000000SSSSSsssss111ddddd0110011ANDI  iiiiiiiiiiiisssss111ddddd0010011AUIPC iiiiiiiiiiiiiiiiiiiiddddd0010111BEQ   iiiiiiiSSSSSsssss000iiiii1100011BNE   iiiiiiiSSSSSsssss001iiiii1100011JAL   iiiiiiiiiiiiiiiiiiiiddddd1101111JALR  iiiiiiiiiiiisssss000ddddd1100111LB    iiiiiiiiiiiisssss000ddddd0000011LUI   iiiiiiiiiiiiiiiiiiiiddddd0110111LW    iiiiiiiiiiiisssss010ddddd0000011OR    0000000SSSSSsssss110ddddd0110011ORI   iiiiiiiiiiiisssss110ddddd0010011SB    iiiiiiiSSSSSsssss000iiiii0100011SLLI  0000000iiiiisssss001ddddd0010011SRLI  0000000iiiiisssss101ddddd0010011SW    iiiiiiiSSSSSsssss010iiiii0100011XOR   0000000SSSSSsssss100ddddd0110011<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果实现的是 RISC-V 64 位, 则额外需要实现以下指令: </p><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">ADDIW iiiiiiiiiiiisssss000ddddd0011011LD    iiiiiiiiiiiisssss011ddddd0000011SD    iiiiiiiSSSSSsssss011iiiii0100011<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在以上指令里面, 很多指令的功能是相近的, 分类以后, 实际上只需要实现如下的几种指令, 然后很容易就可以扩展到其它指令:</p><pre class="line-numbers language-none"><code class="language-none">ADD: ADDI, AND, ANDI, OR, ORI, SLLI, SRLI, XOR, ADDIWAUIPC:BEQ: BNEJAL:JALR:LB: LW, LDLUI:SB: SW, SD<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实际上只需要实现上面的八条指令, 简单扩展即可实现需要的所有指令. 根据 RISC-V 规范正确实现这些指令后, 程序才能正常工作. </p><p>监控程序使用了 8 MB 的内存空间, 其中约 1 MB 由 Kernel 使用, 剩下的空间留给用户程序. 此外, 为了支持串口通信, 还设置了一个内存以外的地址区域, 用于串口收发. 具体内存地址的分配方法如下表所示: </p><div class="table-container"><table><thead><tr><th>地址区间</th><th>说明</th></tr></thead><tbody><tr><td>0x80000000-0x800FFFFF</td><td>监控程序代码</td></tr><tr><td>0x80100000-0x803FFFFF</td><td>用户程序代码</td></tr><tr><td>0x80400000-0x807EFFFF</td><td>用户程序数据</td></tr><tr><td>0x807F0000-0x807FFFFF</td><td>监控程序数据</td></tr><tr><td>0x10000000-0x10000007</td><td>串口数据及状态</td></tr></tbody></table></div><p>串口控制器按照 <a href="https://www.lammertbies.nl/comm/info/serial-uart">16550 UART 的寄存器</a> 的子集实现, 访问的代码位于 <code>kern/utils.S</code> , 其部分数据格式为:</p><div class="table-container"><table><thead><tr><th>地址</th><th>位</th><th>说明</th></tr></thead><tbody><tr><td>0x10000000</td><td>[7:0]</td><td>串口数据, 读、写地址分别表示串口接收、发送一个字节</td></tr><tr><td>0x10000005</td><td>[5]</td><td>只读, 为 1 时表示串口空闲, 可发送数据</td></tr><tr><td>0x10000005</td><td>[0]</td><td>只读, 为 1 时表示串口收到数据</td></tr></tbody></table></div><p>默认情况下还会按照 UART 16550 的初始化流程进行一些寄存器的配置. 在 QEMU 中运行的时候, 请保持 <code>EN_UART16550=y</code> 默认行为. 如果采用自定义的实现, 请设置 <code>EN_UART16550=n</code> 以去掉这些寄存器操作, 或者忽略掉这些操作 (但初始化时仍会输出额外字符, 因为 RBR THR 和 DLL 在同一个地址). 如果使用了 AXI UART16550 作为串口控制器, 请参考代码注释并修改 <code>kernel/include/serial.h</code> 中的常量, 并设置 <code>EN_UART16550=y</code>. </p><p>Kernel 的入口地址为 0x80000000, 对应汇编代码 <code>kern/init.S</code> 中的 <code>START:</code> 标签. 在完成必要的初始化流程后, Kernel 输出版本信息, 随后进入 shell 线程, 与用户交互. shell 线程会等待串口输入, 执行输入的命令, 并通过串口返回结果, 如此往复运行. </p><p>当收到启动用户程序的命令后, 用户线程代替 shell 线程的活动. 用户程序的寄存器, 保存在从 0x807F0000 开始的连续 <code>31*XLEN</code> 字节中, 依次对应 x1 到 x31 用户寄存器, 每次启动用户程序时从上述地址装载寄存器值, 用户程序运行结束后保存到上述地址. </p><h3 id="进阶一-中断和异常支持"><a href="#进阶一-中断和异常支持" class="headerlink" title="进阶一: 中断和异常支持"></a>进阶一: 中断和异常支持</h3><p>作为扩展功能之一, Kernel 支持中断方式的 I/O, 和 Syscall 功能. 要启用这一功能, 编译时的命令变为: </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">make</span> <span class="token assign-left variable">EN_INT</span><span class="token operator">=</span>y<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这一编译选项, 会使得代码编译时增加宏定义 <code>ENABLE_INT</code> , 从而使能中断相关的代码. 为支持中断, CPU 要额外实现以下指令</p><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">CSRRC  ccccccccccccsssss011ddddd1110011CSRRS  ccccccccccccsssss010ddddd1110011CSRRW  ccccccccccccsssss001ddddd1110011EBREAK 00000000000100000000000001110011ECALL  00000000000000000000000001110011MRET   00110000001000000000000001110011SLTU   0000000SSSSSsssss011ddddd0110011<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此外还需要实现 CSR 寄存器的这些字段: </p><ol><li><code>mtvec</code>: BASE, MODE</li><li><code>mscratch</code></li><li><code>mepc</code></li><li><code>mcause</code>: Interrupt, Exception Code</li><li><code>mstatus</code>: MPP</li><li><code>mie</code>: MTIE</li><li><code>mip</code>: MTIP</li></ol><p>CSR 寄存器字段功能定义见 RISC-V 特权态规范. 监控程序对于异常、中断的使用方式如下: </p><ul><li>入口函数 <code>EXCEPTION_HANDLER</code>, 根据异常号跳转至相应的异常处理程序. </li><li>初始化时设置 <code>mtvec = EXCEPTION_HANDLER</code>, 使用正常中断模式 (<code>MODE = DIRECT</code>); 如果不支持 <code>MODE = DIRECT</code> (利用 <code>mtvec</code> 的 <code>WARL</code> 判断), 则会使用向量中断模式 (<code>MODE = VECTORED</code>). </li><li>用户程序在 U-mode 中运行 (<code>mret</code> 时 <code>mstatus.MPP = 0</code>), 通过 <code>ebreak</code> 回到 M-mode, 在异常处理中跳回到 SHELL. </li><li>异常帧保存 31 个通用寄存器及 <code>mepc</code> 寄存器. </li><li>禁止发生嵌套异常. </li><li>支持 <code>SYS_putc</code> 系统调用, 调用方法参考 <code>UTEST_PUTC</code> 函数. 写串口忙等待, 与禁止嵌套异常不冲突. </li><li>当发生不能处理的中断时, 表示出现严重错误, 终止当前任务, 自行重启. 并且发送错误信号 0x80 提醒 Term. </li></ul><p>为了支持时钟中断, 还需要实现 CLINT 设备的两个 MMIO 寄存器: </p><div class="table-container"><table><thead><tr><th>地址</th><th>说明</th></tr></thead><tbody><tr><td>0x200BFF8</td><td>mtime, 64 位, 可读写. 表示当前时间</td></tr><tr><td>0x2004000</td><td>mtimecmp, 64 位, 可读写. 表示下次时钟中断时间</td></tr></tbody></table></div><p>在 CLINT 设备的实现中, 需要每隔固定时间将 <code>mtime</code> 的值 +1, 并且当 <code>mtime &gt;= mtimecmp</code> 时拉高时钟中断信号, 然后 CPU 核心将 <code>mip.MTIP</code> 置 1. 当 <code>mip.MTIP</code>, <code>mie.MTIE</code> 同时为 1, 且当前特权态下全局中断启用时, CPU 即触发时钟中断. </p><p>具体参见 RISC-V 特权态手册 <em>3.1.10 Machine Timer Registers (mtime and mtimecmp)</em>. 有了时钟中断以后, Kernel 就可以杀掉运行超时的用户程序. </p><h3 id="进阶二-页表支持"><a href="#进阶二-页表支持" class="headerlink" title="进阶二: 页表支持"></a>进阶二: 页表支持</h3><p>在支持异常处理的基础上, 可以进一步使能页表支持, 从而实现用户态地址映射. 要启用这一功能, 编译时的命令变为: </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">make</span> <span class="token assign-left variable">EN_INT</span><span class="token operator">=</span>y <span class="token assign-left variable">EN_PAGING</span><span class="token operator">=</span>y<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>CPU 需要额外实现以下指令</p><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">SFENCE.VMA  0001001SSSSSsssss000000001110011<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果没有实现 TLB, 可把 <code>SFENCE.VMA</code> 实现为 NOP. 此外还需要实现 csr 寄存器: </p><ol><li><code>satp</code>: MODE, PPN</li></ol><p>以及页表相关的几个异常, RV32 需要实现 Sv32 的页表格式, RV64 需要实现 Sv39 的页表格式. 为了简化, 实际的映射是线性映射, Sv32 映射的方式在下面给出: </p><ul><li>`va[0x00000000, 0x002FFFFF] = pa[0x80100000, 0x803FFFFF] DAGUX-RV 用户态代码</li><li>va[0x7FC10000, 0x7FFFFFFF] = pa[0x80400000, 0x807EFFFF] DAGU-WRV 用户态数据</li><li>va[0x80000000, 0x80000FFF] = pa[0x80000000, 0x80000FFF] DAGUX-RV 用于返回内核态</li><li>va[0x80001000, 0x80001FFF] = pa[0x80001000, 0x80001FFF] DAGUX-RV 用于运行 UTEST 程序 (CRYPTONIGHT 除外)</li><li>va[0x80100000, 0x80100FFF] = pa[0x80100000, 0x80100FFF] DAGUX-RV 方便测试</li></ul><p>Sv39 下为了实现的方便, 映射的地址比以上的地址区域更大一些: </p><ul><li>va[0x00000000, 0x002FFFFF] = pa[0x80100000, 0x803FFFFF] DAGUX-RV 用户态代码</li><li>va[0x7FC10000, 0x7FFFFFFF] = pa[0x80400000, 0x807EFFFF] DAGU-WRV 用户态数据</li><li>va[0x80000000, 0x801FFFFF] = pa[0x80000000, 0x801FFFFF] DAGUX-RV 用于返回内核态、运行 UTEST 程序和方便测试</li></ul><p>其它地址都未经映射, 访问则会引发异常. </p><p>初始化过程: </p><ol><li>根据 RV32 还是 RV64 选择 Sv32 或者 Sv39 的页表进行填写</li><li>将页表的物理地址写入 <code>satp</code> 并配置好模式, 启用 U-mode 下的页表映射机制. </li><li>通过 <code>sfence.vma</code> 指令刷新 TLB. </li><li>将用户栈指针设为 0x80000000. </li></ol><h2 id="Term"><a href="#Term" class="headerlink" title="Term"></a>Term</h2><p>Term 程序运行在实验者电脑上, 提供监控程序交互界面. Term 支持以下命令: </p><ul><li><code>R</code>: 按照 x1 至 x31 的顺序返回用户程序寄存器值. </li><li><code>D</code>: 显示从指定地址开始的一段内存区域中的数据. </li><li><code>A</code>: 用户输入汇编指令, 并放置到指定地址上. </li><li><code>F</code>: 从文件读入汇编指令并放置到指定地址上, 格式与 A 命令相同. </li><li><code>U</code>: 从指定地址读取一定长度的数据, 并显示反汇编结果. </li><li><code>G</code>: 执行指定地址的用户程序. </li><li><code>T</code>: 查看页表内容, 仅在启用页表时有效. </li><li><code>Q</code>: 退出 Term. </li></ul><p>利用这些命令, 实验者可以输入一段汇编程序, 检查数据是否正确写入, 并让程序在处理器上运行验证. Term 程序位于 <code>term</code> 文件夹中, 可执行文件为 <code>term.py</code> . 对于本地的 Thinpad, 运行程序时用 <code>-s</code> 选项指定串口. 例如: </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">python term.py <span class="token parameter variable">-s</span> COM3<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">python term.py <span class="token parameter variable">-s</span> /dev/ttyACM0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>连接远程实验平台 Thinpad 或 QEMU 模拟器时, 使用 -t 选项指定 IP 和端口. 如: </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">python term.py <span class="token parameter variable">-t</span> <span class="token number">127.0</span>.0.1:6666<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="测试程序"><a href="#测试程序" class="headerlink" title="测试程序"></a>测试程序</h3><p>监控程序附带了几个测试程序, 代码见 <code>kern/test.S</code> . 可以通过命令</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">make</span> <span class="token assign-left variable">EN_XXX</span><span class="token operator">=</span>y show-utest<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>来查看测试程序入口地址. 记下这些地址, 并在 Term 中使用 <code>G</code> 命令运行它们. </p><ul><li><p><code>CRYPTONIGHT</code> 测试模仿了 CryptoNight 算法, 它会进行很多次的随机访存, 数据缓存命中率会很低. 运行结束后, 寄存器 <code>t0</code> 保存的是最终结果, 32 位下应该是 <code>a2e31a85</code>, 64 位下应该是 <code>ffffffff861c65d4</code>. </p></li><li><p><code>SPIN</code> 测试是一个死循环, 用来测试时钟中断能否正确杀掉超时程序. </p></li></ul><h3 id="用户程序编写"><a href="#用户程序编写" class="headerlink" title="用户程序编写"></a>用户程序编写</h3><p>根据监控程序设计, 用户程序的代码区为 0x80100000-0x803FFFFF, 实验时需要把用户程序写入这一区域. 用户程序的最后需要以 <code>jr ra</code> 结束, 保证正确返回监控程序. </p><p>在输入用户程序的过程中, 可以用汇编指令, 可以直接写 16 进制的机器码, 还可以写 label (见以下例子中 <code>loop:</code>). 以下是一次输入用户程序并运行的过程演示: </p><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">connecting to 127.0.0.1:6666...connectedrunning in 32bit, xlen = 4&gt;&gt; aaddr: 0x80100000one instruction per line, empty line to end.[0x80100000] li a0, 5[0x80100004] li t0, 0[0x80100008] 00000313[0x8010000c] loop:[0x8010000c] add t1, t1, t0[0x80100010] addi t0, t0, 1[0x80100014] bne a0, t0, loop[0x80100018] jr ra[0x8010001c]&gt;&gt; uaddr: 0x80100000num: 320x80100000:00500513lia0,50x80100004: 00000293lit0,00x80100008: 00000313lit1,00x8010000c: 00530333addt1,t1,t00x80100010: 00128293addit0,t0,10x80100014: fe551ce3bnea0,t0,0x8010000c0x80100018: 00008067ret0x8010001c: 00000000...&gt;&gt; gaddr: 0x80100000elapsed time: 0.000s&gt;&gt; rR1 (ra)    = 0x80000414R2 (sp)    = 0x807fff00R3 (gp)    = 0x00000000R4 (tp)    = 0x00000000R5 (t0)    = 0x00000005R6 (t1)    = 0x0000000aR7 (t2)    = 0x00000000R8 (s0/fp) = 0x80000000R9 (s1)    = 0x00000000R10(a0)    = 0x00000005R11(a1)    = 0x00000000R12(a2)    = 0x00000000R13(a3)    = 0x00000000R14(a4)    = 0x00000000R15(a5)    = 0x00000000R16(a6)    = 0x00000000R17(a7)    = 0x00000000R18(s2)    = 0x00000000R19(s3)    = 0x00000000R20(s4)    = 0x00000000R21(s5)    = 0x00000000R22(s6)    = 0x00000000R23(s7)    = 0x00000000R24(s8)    = 0x00000000R25(s9)    = 0x00000000R26(s10)   = 0x80100000R27(s11)   = 0x00000000R28(t3)    = 0x00000000R29(t4)    = 0x00000000R30(t5)    = 0x00000000R31(t6)    = 0x00000000&gt;&gt; q<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当处理器和 Kernel 支持异常功能时 (即上文所述 <code>EN_INT=y</code>), 用户还可以用 Syscall 的方式打印字符. 打印字符的系统调用号为 30. 使用时, 用户把调用号保存在 s0 寄存器, 打印字符参数保存在 a0 寄存器, 并执行 syscall 指令, a0 寄存器的低八位将作为字符打印. 例如: </p><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">li s0, 30           # 系统调用号li a0, 0x4F         # 'O'ecallli a0, 0x4B         # 'K'ecalljr ra<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>用 <code>A</code> 命令输入的汇编指令支持常见的伪指令 (pseudo instructions), 并且地址也会相应地变化, 如:</p><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">connecting to 127.0.0.1:6666...connectedrunning in 32bit, xlen = 4&gt;&gt; Aaddr: 0x80100000one instruction per line, empty line to end.[0x80100000] li a0, 0x12345678[0x80100008] li t0, 0x23333332[0x80100010] ret[0x80100014]&gt;&gt; Uaddr: 0x80100000num: 200x80100000:     12345537        lui     a0,0x123450x80100004:     67850513        addi    a0,a0,16560x80100008:     233332b7        lui     t0,0x233330x8010000c:     33228293        addi    t0,t0,8180x80100010:     00008067        ret&gt;&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果是 RV64, 上面的 <code>addi</code> 指令会相应地变成 <code>addiw</code> 指令. </p><h2 id="在-QEMU-里调试监控程序"><a href="#在-QEMU-里调试监控程序" class="headerlink" title="在 QEMU 里调试监控程序"></a>在 QEMU 里调试监控程序</h2><p>在 Makefile 中提供了 <code>debug</code> 目标, 它会编译 kernel 并且运行 QEMU: </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">cd</span> kernel$ <span class="token function">make</span> debugqemu-system-riscv32 <span class="token parameter variable">-M</span> virt <span class="token parameter variable">-m</span> 32M <span class="token parameter variable">-kernel</span> kernel.elf <span class="token parameter variable">-nographic</span> <span class="token parameter variable">-monitor</span> stdio <span class="token parameter variable">-serial</span> tcp::6666,server <span class="token parameter variable">-S</span> <span class="token parameter variable">-s</span>QEMU <span class="token number">5.0</span>.0 monitor - <span class="token builtin class-name">type</span> <span class="token string">'help'</span> <span class="token keyword">for</span> <span class="token function">more</span> information<span class="token punctuation">(</span>qemu<span class="token punctuation">)</span> qemu-system-riscv32: <span class="token parameter variable">-serial</span> tcp::6666,server: info: QEMU waiting <span class="token keyword">for</span> connection on: disconnected:tcp::::6666,server<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>之后它会在 6666 端口上等待 term 的连接. 另起一个窗口, 运行 term 连接到 <code>localhost:6666</code>: </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ python3 term/term.py <span class="token parameter variable">-t</span> <span class="token number">127.0</span>.0.1:6666 <span class="token parameter variable">-c</span>connecting to <span class="token number">127.0</span>.0.1:6666<span class="token punctuation">..</span>.connected<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这一步连上以后, 就可以用 gdb 挂载到 qemu 里的 kernel 上了. 采用<strong>比较新</strong>的 gdb 或者 SiFive 的 riscv64-elf-unknown-gdb (Windows 最好用这个) 都是可以的. 命令: </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ riscv64-unknown-elf-gdb kernel/kernel.elfGNU gdb <span class="token punctuation">(</span>SiFive GDB <span class="token number">8.3</span>.0-2019.08.0<span class="token punctuation">)</span> <span class="token number">8.3</span>Copyright <span class="token punctuation">(</span>C<span class="token punctuation">)</span> <span class="token number">2019</span> Free Software Foundation, Inc.License GPLv3+: GNU GPL version <span class="token number">3</span> or later <span class="token operator">&lt;</span>http://gnu.org/licenses/gpl.html<span class="token operator">&gt;</span>This is <span class="token function">free</span> software: you are <span class="token function">free</span> to change and redistribute it.There is NO WARRANTY, to the extent permitted by law.Type <span class="token string">"show copying"</span> and <span class="token string">"show warranty"</span> <span class="token keyword">for</span> details.This GDB was configured as <span class="token string">"--host=x86_64-w64-mingw32 --target=riscv64-unknown-elf"</span><span class="token builtin class-name">.</span>Type <span class="token string">"show configuration"</span> <span class="token keyword">for</span> configuration details.For bug reporting instructions, please see:<span class="token operator">&lt;</span>https://github.com/sifive/freedom-tools/issues<span class="token operator">&gt;</span>.Find the GDB manual and other documentation resources online at:    <span class="token operator">&lt;</span>http://www.gnu.org/software/gdb/documentation/<span class="token operator">&gt;</span>.For help, <span class="token builtin class-name">type</span> <span class="token string">"help"</span><span class="token builtin class-name">.</span>Type <span class="token string">"apropos word"</span> to search <span class="token keyword">for</span> commands related to <span class="token string">"word"</span><span class="token punctuation">..</span>.Reading symbols from kernel/kernel.elf<span class="token punctuation">..</span>.<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> target remote localhost:1234Remote debugging using localhost:12340x00001000 <span class="token keyword">in</span> ?? <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>之后就可以正常进行调试. </p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li>CPU 采用的 RISC-V 指令集标准: The RISC-V Instruction Set Manual Volume I: User-Level ISA Document</li><li>RISC-V 中断及 Sv32/Sv39 等特权态资源: The RISC-V Instruction Set Manual Volume II: Privileged Architecture</li></ul>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;RISC-V-监控程序&quot;&gt;&lt;a href=&quot;#RISC-V-监控程序&quot; class=&quot;headerlink&quot; title=&quot;RISC-V 监控程序&quot;&gt;&lt;/a&gt;RISC-V 监控程序&lt;/h1&gt;&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot;</summary>
        
      
    
    
    
    <category term="CS" scheme="http://chengsx21.github.io/categories/CS/"/>
    
    <category term="Organization &amp; Design" scheme="http://chengsx21.github.io/categories/CS/Organization-Design/"/>
    
    
    <category term="Organization &amp; Design" scheme="http://chengsx21.github.io/tags/Organization-Design/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成原理 笔记1</title>
    <link href="http://chengsx21.github.io/2023/09/19/ji-suan-ji-zu-cheng-yuan-li-bi-ji-1/"/>
    <id>http://chengsx21.github.io/2023/09/19/ji-suan-ji-zu-cheng-yuan-li-bi-ji-1/</id>
    <published>2023-09-19T09:18:57.000Z</published>
    <updated>2024-06-30T09:53:39.689Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机指令系统"><a href="#计算机指令系统" class="headerlink" title="计算机指令系统"></a>计算机指令系统</h1><h2 id="Risc-V-指令"><a href="#Risc-V-指令" class="headerlink" title="Risc-V 指令"></a>Risc-V 指令</h2><h3 id="U-型"><a href="#U-型" class="headerlink" title="U 型"></a>U 型</h3><p><img src="/pic/173.png" alt=""></p><p><img src="/pic/174.png" alt=""></p><ul><li><strong>lui</strong> 和 <strong>auipc</strong> 主要用于构造大的常量数值和链接.</li><li><strong>lui</strong> 设置寄存器高位立即数, 用两条指令便可以任意偏移量转移控制流或者加载任意 32 位数据.<ul><li>将 <strong>lui</strong> 中的 20 位立即数与 <strong>jalr</strong> 中 12 位立即数组合, 可以将执行流转移到任何 32 位绝对地址.</li><li><strong>lui</strong> 加上标准的立即指令, 可构造一个任意 32 位常量.</li></ul></li><li><strong>auipc</strong> 向 PC 高位加上立即数, 仅用两条指令便可以基于当前 PC 以任意偏移量转移控制流或者访问数据.<ul><li>将 <strong>auipc</strong> 中的 20 位立即数与 <strong>jalr</strong> 中 12 位立即数组合, 可以将执行流转移到任何 32 位 PC 相对地址.</li><li><strong>auipc</strong> 加上普通加载或存储指令中的 12 位立即数偏移量, 可以访问任何 32 位 PC 相对地址的数据.</li></ul></li></ul><h3 id="UJ-J-型"><a href="#UJ-J-型" class="headerlink" title="UJ/J 型"></a>UJ/J 型</h3><p><img src="/pic/175.png" alt=""></p><ul><li><strong>J</strong> 类型的直接字段在 <strong>U</strong> 类型的基础上旋转了 12 位. 这可以降低指令信号扇出和立即数多路复用的成本, 并简化低端实现中的数据通路逻辑.</li><li>由于指令长度必须是两个字节的倍数, <strong>J</strong> 格式的分支和跳转地址必须向左移动 1 位以将地址乘以 2, 给予分支和跳转指令更大的跳转范围, 进行符号扩展后再添加到 PC 上, 得到跳转地址.</li><li><strong>jal</strong> 具有双重功能. 若将下一条指令 PC + 4 的地址保存到目标寄存器中.<ul><li>通常是返回地址寄存器 ra, 便可实现过程调用.</li><li>使用零寄存器 x0 替换 ra 作为目标寄存器, 则可实现无条件跳转. </li></ul></li></ul><h3 id="I-型-1"><a href="#I-型-1" class="headerlink" title="I 型 - 1"></a>I 型 - 1</h3><p><img src="/pic/176.png" alt=""></p><ul><li>跳转链接指令的寄存器版本 <strong>jalr</strong> 同样是多用途的.<ul><li>可以调用地址是动态计算出来的函数.</li><li>可以实现调用返回 (ra 作为源寄存器, x0 作为目的寄存器).</li><li>switch 和 case 语句的地址跳转也可使用 <strong>jalr</strong> 指令, 目的寄存器设为 x0.</li></ul></li></ul><p><img src="/pic/177.png" alt=""></p><p><img src="/pic/178.png" alt=""></p><h3 id="I-型-2"><a href="#I-型-2" class="headerlink" title="I 型 - 2"></a>I 型 - 2</h3><p><img src="/pic/179.png" alt=""></p><p><img src="/pic/180.png" alt=""></p><p><img src="/pic/181.png" alt=""></p><p><img src="/pic/182.png" alt=""></p><p><img src="/pic/183.png" alt=""></p><ul><li><strong>slli</strong> 和 <strong>srli</strong> 的 shamt[4:0] 为移动量, 范围都是[4:0], 因为在 RV32I 中最大的移位量是 31 位.</li><li>imm[10] 用来区分移位类型, 其中 <strong>slli</strong> 和 <strong>srli</strong> 指令机器码的 bit 30 为 0, 而 <strong>srai</strong> 指令机器码的 bit 30 为 1.</li></ul><h3 id="R-型"><a href="#R-型" class="headerlink" title="R 型"></a>R 型</h3><p><img src="/pic/184.png" alt=""></p><p><img src="/pic/185.png" alt=""></p><p><img src="/pic/186.png" alt=""></p><p><img src="/pic/187.png" alt=""></p><h3 id="S-型"><a href="#S-型" class="headerlink" title="S 型"></a>S 型</h3><p><img src="/pic/188.png" alt=""></p><p><img src="/pic/189.png" alt=""></p><h3 id="SB-B-型"><a href="#SB-B-型" class="headerlink" title="SB/B 型"></a>SB/B 型</h3><p><img src="/pic/190.png" alt=""></p><p><img src="/pic/191.png" alt=""></p><ul><li><strong>B</strong> 类型的立即数字段在 <strong>S</strong> 类型的基础上旋转了 1 位. 这可以降低指令信号扇出和立即数多路复用的成本, 并简化低端实现中的数据通路逻辑.</li><li>由于指令长度必须是两个字节的倍数, <strong>B</strong> 格式的分支和跳转地址必须向左移动 1 位以将地址乘以 2, 给予分支和跳转指令更大的跳转范围, 进行符号扩展后再添加到 PC 上, 得到跳转地址.</li></ul>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;计算机指令系统&quot;&gt;&lt;a href=&quot;#计算机指令系统&quot; class=&quot;headerlink&quot; title=&quot;计算机指令系统&quot;&gt;&lt;/a&gt;计算机指令系统&lt;/h1&gt;&lt;h2 id=&quot;Risc-V-指令&quot;&gt;&lt;a href=&quot;#Risc-V-指令&quot;</summary>
        
      
    
    
    
    <category term="CS" scheme="http://chengsx21.github.io/categories/CS/"/>
    
    <category term="Organization &amp; Design" scheme="http://chengsx21.github.io/categories/CS/Organization-Design/"/>
    
    
    <category term="Organization &amp; Design" scheme="http://chengsx21.github.io/tags/Organization-Design/"/>
    
  </entry>
  
</feed>
