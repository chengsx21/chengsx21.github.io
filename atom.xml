<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Endeavor</title>
  
  <subtitle>狂歌痛饮 来访雁丘处</subtitle>
  <link href="http://chengsx21.github.io/atom.xml" rel="self"/>
  
  <link href="http://chengsx21.github.io/"/>
  <updated>2024-08-14T08:08:41.836Z</updated>
  <id>http://chengsx21.github.io/</id>
  
  <author>
    <name>Chengsx</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>机器学习-模型微调与部署</title>
    <link href="http://chengsx21.github.io/2024/07/18/ji-qi-xue-xi-mo-xing-wei-diao-yu-bu-shu/"/>
    <id>http://chengsx21.github.io/2024/07/18/ji-qi-xue-xi-mo-xing-wei-diao-yu-bu-shu/</id>
    <published>2024-07-18T08:23:25.000Z</published>
    <updated>2024-08-14T08:08:41.836Z</updated>
    
    <content type="html"><![CDATA[<h2 id="项目架构"><a href="#项目架构" class="headerlink" title="项目架构"></a><strong>项目架构</strong></h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">├── app.py├── Chinese-CLIP├── Data│     ├── datasets│     │     └── Kwai│     │           ├── lmdb│     │           ├── train_imgs.tsv│     │           ├── train_texts.jsonl│     │           ├── valid_imgs.tsv│     │           └── valid_texts.jsonl│     ├── deploy│     ├── experiments│     └── pretrained_weights├── database.py├── model.py├── RawData│     ├── *.csv│     ├── dataset.py│     ├── merged_output.csv│     ├── merge.py│     └── preprocess.py├── requirements.txt├── Scripts│     ├── eval_img_txt_feat.sh│     ├── extract_img_txt_feat.sh│     ├── extract_train_img_feat.sh│     ├── extract_valid_img_feat.sh│     ├── finetune_clip.sh│     ├── onnx_clip.sh│     └── tensor_clip.sh├── static├── templates└── Testcodes      ├── onnx.py      ├── tensor.py      └── version.py<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Anaconda-安装"><a href="#Anaconda-安装" class="headerlink" title="Anaconda 安装"></a><strong>Anaconda 安装</strong></h2><p>使用 arch 命令观察到物理机架构为 x86_64，从 <a href="https://repo.anaconda.com/archive/">Anaconda 官方</a>下载对应版本的安装脚本。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">wget</span> <span class="token parameter variable">-c</span> <span class="token string">"https://repo.anaconda.com/archive/Anaconda3-2024.06-1-Linux-x86_64.sh"</span> --no-check-certificate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="Torch-安装"><a href="#Torch-安装" class="headerlink" title="Torch 安装"></a><strong>Torch 安装</strong></h2><p>使用 <strong>nvidia-smi</strong> 命令查看物理机的 GPU 基础信息：</p><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202408141552529.png" alt=""></p><p>GPU 最高支持 11.4 版本的 CUDA，在 <a href="https://pytorch.org/get-started/previous-versions/">PyTorch 官方网站</a>上查找 CUDA-11.3 对应的 PyTorch 版本安装 (因为 CUDA-11.4 是一个奇怪的版本，没有对应的 PyTorch 版本支持)。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">conda create <span class="token parameter variable">-n</span> clip <span class="token assign-left variable">python</span><span class="token operator">==</span><span class="token number">3.9</span>pip <span class="token function">install</span> <span class="token assign-left variable">torch</span><span class="token operator">==</span><span class="token number">1.12</span>.1+cu113 <span class="token assign-left variable">torchvision</span><span class="token operator">==</span><span class="token number">0.13</span>.1+cu113 <span class="token assign-left variable">torchaudio</span><span class="token operator">==</span><span class="token number">0.12</span>.1 --extra-index-url https://download.pytorch.org/whl/cu113<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="模型下载与依赖安装"><a href="#模型下载与依赖安装" class="headerlink" title="模型下载与依赖安装"></a><strong>模型下载与依赖安装</strong></h2><p>选择使用大规模中文数据预训练的<a href="https://github.com/OFA-Sys/Chinese-CLIP">中文 Clip 模型</a>作为基座模型，进行微调。</p><p>使用 ssh 克隆仓库出现无法连接 GitHub 22 端口的报错，因此使用 https 克隆仓库。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> clone https://github.com/OFA-Sys/Chinese-CLIP.git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>安装如下依赖：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">coremltools</span><span class="token operator">==</span><span class="token number">7.2</span><span class="token assign-left variable">Flask</span><span class="token operator">==</span><span class="token number">3.0</span>.3<span class="token assign-left variable">Flask_Cors</span><span class="token operator">==</span><span class="token number">4.0</span>.1<span class="token assign-left variable">jieba</span><span class="token operator">==</span><span class="token number">0.42</span>.1<span class="token assign-left variable">modelscope</span><span class="token operator">==</span><span class="token number">1.17</span>.1<span class="token assign-left variable">numpy</span><span class="token operator">==</span><span class="token number">1.24</span>.0<span class="token assign-left variable">onnxmltools</span><span class="token operator">==</span><span class="token number">1.11</span>.1<span class="token assign-left variable">onnxruntime_gpu</span><span class="token operator">==</span><span class="token number">1.13</span>.1<span class="token assign-left variable">pandas</span><span class="token operator">==</span><span class="token number">2.2</span>.2<span class="token assign-left variable">Pillow</span><span class="token operator">==</span><span class="token number">10.4</span>.0<span class="token assign-left variable">pinecone</span><span class="token operator">==</span><span class="token number">5.0</span>.1<span class="token assign-left variable">Requests</span><span class="token operator">==</span><span class="token number">2.32</span>.3<span class="token assign-left variable">setuptools</span><span class="token operator">==</span><span class="token number">69.5</span>.1<span class="token assign-left variable">six</span><span class="token operator">==</span><span class="token number">1.16</span>.0<span class="token assign-left variable">tensorrt</span><span class="token operator">==</span><span class="token number">8.2</span>.5.1<span class="token assign-left variable">timm</span><span class="token operator">==</span><span class="token number">1.0</span>.8<span class="token assign-left variable">torch</span><span class="token operator">==</span><span class="token number">1.12</span>.1+cu113<span class="token assign-left variable">torchvision</span><span class="token operator">==</span><span class="token number">0.13</span>.1+cu113<span class="token assign-left variable">tqdm</span><span class="token operator">==</span><span class="token number">4.66</span>.4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="数据集构建-Reference"><a href="#数据集构建-Reference" class="headerlink" title="数据集构建 [Reference]"></a><strong>数据集构建</strong> <a href="https://github.com/OFA-Sys/Chinese-CLIP/blob/master/README.md#数据集格式预处理">[Reference]</a></h2><p>从以 CSV 格式存储的 200w 量级的数据集中过滤出图片 id，标题与 url，格式如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">405482801733,205</span>肥肥佳人时尚胶片百搭鞋,https://u1-203.ecukwai.com/bs2/image-kwaishop-product/item_image-493137733-d2b1fdad3bb94f9a8f2cd7720a9ffcbb.jpg<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 <strong>RawData/dataset.py</strong> 中实现了 <strong>ImageProcessor</strong> 与 <strong>TextProcessor 类</strong>，分别将图片原始文件转换为 base64 格式，标题拆分为关键词组并过滤无关字符，最终构建映射关系，并分别保存在 <strong>Data/datasets/Kwai/*.tsv</strong> 与 <strong>Data/datasets/Kwai/*.jsonl</strong> 中。</p><p>使用如下命令将 tsv 和 jsonl 文件序列化，转换为内存索引的 LMDB 数据库文件，以方便训练时的随机读取：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">python Chinese-CLIP/cn_clip/preprocess/build_lmdb_dataset.py <span class="token punctuation">\</span>    <span class="token parameter variable">--data_dir</span> DATA/datasets/kwai    <span class="token parameter variable">--splits</span> train,valid<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>最终生成的数据集组织如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">└── Data      └── datasets             └── Kwai                   ├── lmdb                   ├── train_imgs.tsv                   ├── train_texts.jsonl                   ├── valid_imgs.tsv                   └── valid_texts.jsonl<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="模型微调-Reference"><a href="#模型微调-Reference" class="headerlink" title="模型微调 [Reference]"></a><strong>模型微调</strong> <a href="https://github.com/OFA-Sys/Chinese-CLIP/blob/master/README.md#模型finetune">[Reference]</a></h2><p>参考 <strong>Scripts/finetune_clip.sh</strong> 进行模型微调。</p><h2 id="Pinecone-向量数据库部署-Reference"><a href="#Pinecone-向量数据库部署-Reference" class="headerlink" title="Pinecone 向量数据库部署 [Reference]"></a><strong>Pinecone 向量数据库部署</strong> <a href="https://docs.pinecone.io/guides/get-started/quickstart">[Reference]</a></h2><p>安装 Pinecone For Python：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pip <span class="token function">install</span> <span class="token string">"pinecone-client[grpc]"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>为将数据集中的图片批量存入数据库，先运行脚本 <strong>Scripts/extract_train_img_feat.sh</strong> 和 <strong>Scripts/extract_valid_img_feat.sh</strong> 将 base64 格式的图片数据向量化。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># Scripts/extract_train_img_feat.sh</span><span class="token assign-left variable">resume</span><span class="token operator">=</span>Data/pretrained_weights/YOUR_MODELpython <span class="token parameter variable">-u</span> Chinese-CLIP/cn_clip/eval/extract_features.py <span class="token punctuation">\</span>    --extract-image-feats <span class="token punctuation">\</span>    --image-data<span class="token operator">=</span><span class="token string">"Data/datasets/Kwai/lmdb/train/imgs"</span> <span class="token punctuation">\</span>    --image-feat-output-path<span class="token operator">=</span><span class="token string">"Data/datasets/Kwai/train_imgs.img_feat.jsonl"</span><span class="token punctuation">\</span>    --img-batch-size<span class="token operator">=</span><span class="token number">32</span> <span class="token punctuation">\</span>    --context-length<span class="token operator">=</span><span class="token number">52</span> <span class="token punctuation">\</span>    <span class="token parameter variable">--resume</span><span class="token operator">=</span><span class="token variable">${resume}</span> <span class="token punctuation">\</span>    --vision-model<span class="token operator">=</span>ViT-B-16<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>参考 Pinecone 官方文档，在 <strong>database.py</strong> 中实现了图片向量写入数据库以及数据库查询功能：</p><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202408141558108.png" alt=""></p><p>打开 Pinecone 网页端，观察到图片数据与 url 已经存入。</p><h2 id="模型部署与格式转换-Reference"><a href="#模型部署与格式转换-Reference" class="headerlink" title="模型部署与格式转换 [Reference]"></a><strong>模型部署与格式转换</strong> <a href="https://github.com/OFA-Sys/Chinese-CLIP/blob/master/deployment.md">[Reference]</a></h2><p>对 PyTorch 模型进行 ONNX &amp; TensorRT 格式的转换，以实现推理加速。首先需要注意 CUDA，ONNX 与 TensorRT 的版本匹配关系。</p><h3 id="ONNX-格式转换"><a href="#ONNX-格式转换" class="headerlink" title="ONNX 格式转换"></a><strong>ONNX 格式转换</strong></h3><p>安装 ONNX 库：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pip <span class="token function">install</span> <span class="token assign-left variable">onnx</span><span class="token operator">==</span><span class="token number">1.13</span>.0 onnxruntime-gpu<span class="token operator">==</span><span class="token number">1.13</span>.1 <span class="token assign-left variable">onnxmltools</span><span class="token operator">==</span><span class="token number">1.11</span>.1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>运行脚本 <strong>Scripts/onnx_clip.sh</strong>，将 PyTorch 模型转换为 ONNX 格式：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">python Chinese-CLIP/cn_clip/deploy/pytorch_to_onnx.py <span class="token punctuation">\</span>       --model-arch ViT-B-16 <span class="token punctuation">\</span>       --pytorch-ckpt-path Data/pretrained_weights/YOUR_MODEL <span class="token punctuation">\</span>       --save-onnx-path Data/deploy/vit-b-16/vit-b-16 <span class="token punctuation">\</span>       --convert-text --convert-vision<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="TensorRT-格式转换"><a href="#TensorRT-格式转换" class="headerlink" title="TensorRT 格式转换"></a><strong>TensorRT 格式转换</strong></h3><p>安装 TensorRT 库：</p><p>运行如下代码得到 CUDA 版本为 11.3，cuDNN 版本为 8.3.2。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> torch<span class="token keyword">print</span><span class="token punctuation">(</span>torch<span class="token punctuation">.</span>version<span class="token punctuation">.</span>cuda<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>torch<span class="token punctuation">.</span>backends<span class="token punctuation">.</span>cudnn<span class="token punctuation">.</span>version<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>TensorRT 的版本选择需要与 CUDA 与 cuDNN 严格兼容，在 <a href="https://developer.nvidia.com/nvidia-tensorrt-8x-download">NVIDIA 官方网站</a>安装相应的 TensorRT-8.2.5.1 版本，在本地下载安装包后使用 sftp 传输到物理机上。</p><p>使用的 Python 虚拟环境为 3.9，在有关目录下依次安装：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pip <span class="token function">install</span> tensorrt-8.2.5.1-cp39-none-linux_x86_64.whlpip <span class="token function">install</span> graphsurgeon-0.4.5-py2.py3-none-any.whlpip <span class="token function">install</span> onnx_graphsurgeon-0.3.12-py2.py3-none-any.whl<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>添加如下环境变量到 .bashrc 中：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">export</span> <span class="token assign-left variable">LD_LIBRARY_PATH</span><span class="token operator">=</span><span class="token variable">$LD_LIBRARY_PATH</span>:~/TensorRT-8.2.5.1/lib<span class="token builtin class-name">export</span> <span class="token assign-left variable">LD_LIBRARY_PATH</span><span class="token operator">=</span><span class="token variable">$LD_LIBRARY_PATH</span>:~/anaconda3/envs/kwai/lib/python3.9/site-packages/torch/lib<span class="token builtin class-name">export</span> <span class="token assign-left variable"><span class="token environment constant">PATH</span></span><span class="token operator">=</span><span class="token environment constant">$PATH</span>:~/TensorRT-8.2.5.1/bin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>运行如下代码得到 TensorRT 版本为 8.2.5.1。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> tensorrt <span class="token keyword">print</span><span class="token punctuation">(</span>tensorrt<span class="token punctuation">.</span>__version__<span class="token punctuation">)</span> <span class="token keyword">assert</span> tensorrt<span class="token punctuation">.</span>Builder<span class="token punctuation">(</span>tensorrt<span class="token punctuation">.</span>Logger<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>运行脚本 <strong>Scripts/tensor_clip.sh</strong>，将 ONNX 模型转换为 TensorRT 格式：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">python Chinese-CLIP/cn_clip/deploy/onnx_to_tensorrt.py <span class="token punctuation">\</span>    --model-arch ViT-B-16 <span class="token punctuation">\</span>    --save-tensorrt-path Data/deploy/vit-b-16/vit-b-16 <span class="token punctuation">\</span>    --convert-text <span class="token punctuation">\</span>    --text-onnx-path Data/deploy/vit-b-16/YOUR_MODEL <span class="token punctuation">\</span>    --convert-vision <span class="token punctuation">\</span>    --vision-onnx-path Data/deploy/vit-b-16/YOUR_MODEL <span class="token punctuation">\</span>    <span class="token parameter variable">--fp16</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>转换时遇到了报错：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token string">'tensorrt.tensorrt.IBuilderConfig'</span> object has no attribute <span class="token string">'set_memory_pool_limit'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 <strong>Chinese-CLIP/cn_clip/deploy/tensorrt_utils.py</strong> 中第 147 行进行如下修改即可：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">-</span> config<span class="token punctuation">.</span>set_memory_pool_limit<span class="token punctuation">(</span>trt<span class="token punctuation">.</span>tensorrt<span class="token punctuation">.</span>MemoryPoolType<span class="token punctuation">.</span>DLA_GLOBAL_DRAM<span class="token punctuation">,</span> workspace_size<span class="token punctuation">)</span><span class="token operator">+</span> config<span class="token punctuation">.</span>max_workspace_size <span class="token operator">=</span> workspace_size<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="系统运行流程"><a href="#系统运行流程" class="headerlink" title="系统运行流程"></a><strong>系统运行流程</strong></h2><ol><li>用户访问<a href="https://kwaipic.corp.kuaishou.com/home">网页</a>，在前端上传一张图片。</li><li>后端对图片进行 resize，并由 TensorRT 模型推理得到特征向量。</li><li>后端通过特征向量查询 Pinecone 数据库，得到相似度较高的图片 id 与 url，并在前端展示。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202408141559904.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202408141559141.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202408141559318.png" alt=""></p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h2 id=&quot;项目架构&quot;&gt;&lt;a href=&quot;#项目架构&quot; class=&quot;headerlink&quot; title=&quot;项目架构&quot;&gt;&lt;/a&gt;&lt;strong&gt;项目架构&lt;/strong&gt;&lt;/h2&gt;&lt;pre class=&quot;line-numbers language-bash&quot;</summary>
        
      
    
    
    
    <category term="CS" scheme="http://chengsx21.github.io/categories/CS/"/>
    
    <category term="AI" scheme="http://chengsx21.github.io/categories/CS/AI/"/>
    
    
    <category term="Machine Learning" scheme="http://chengsx21.github.io/tags/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title>机器学习-模型转换(1)</title>
    <link href="http://chengsx21.github.io/2024/07/12/ji-qi-xue-xi-mo-xing-zhuan-huan/"/>
    <id>http://chengsx21.github.io/2024/07/12/ji-qi-xue-xi-mo-xing-zhuan-huan/</id>
    <published>2024-07-12T08:23:25.000Z</published>
    <updated>2024-08-14T08:02:13.028Z</updated>
    
    <content type="html"><![CDATA[<h2 id=""><a href="#" class="headerlink" title=" "></a> </h2>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h2 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot; &quot;&gt;&lt;/a&gt;</summary>
        
      
    
    
    
    <category term="CS" scheme="http://chengsx21.github.io/categories/CS/"/>
    
    <category term="AI" scheme="http://chengsx21.github.io/categories/CS/AI/"/>
    
    
    <category term="Machine Learning" scheme="http://chengsx21.github.io/tags/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title>机器学习-分类模型指标</title>
    <link href="http://chengsx21.github.io/2024/07/02/ji-qi-xue-xi-fen-lei-mo-xing-zhi-biao/"/>
    <id>http://chengsx21.github.io/2024/07/02/ji-qi-xue-xi-fen-lei-mo-xing-zhi-biao/</id>
    <published>2024-07-02T08:23:25.000Z</published>
    <updated>2024-08-08T03:39:23.662Z</updated>
    
    <content type="html"><![CDATA[<h2 id="分类问题"><a href="#分类问题" class="headerlink" title="分类问题"></a>分类问题</h2><p>有一个判断性别的机器学习模型, 使用它来判断「是否为男性」时, 会出现 4 种情况:</p><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202408021629912.png" alt=""></p><p>这 4 种情况构成了混淆矩阵:</p><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202408021631896.png" alt=""></p><p>其中 T/F 描述机器判断结果的正确性, P/N 描述机器判断分类的正负性.</p><h2 id="基础分类指标"><a href="#基础分类指标" class="headerlink" title="基础分类指标"></a>基础分类指标</h2><h3 id="准确率-Accuracy"><a href="#准确率-Accuracy" class="headerlink" title="准确率 Accuracy"></a>准确率 Accuracy</h3><p><strong>准确率</strong>为预测正确的结果占总样本的百分比:</p><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202408071617941.png" alt=""></p><p>可以判断总的正确率, 但是在<strong>样本不平衡</strong>的情况下, 不能作为指标来衡量结果. 在正样本占 90%, 负样本占 10% 的总样本中, 样本严重不平衡. 这种情况只需将全部样本预测为正即可得到 90% 的准确率, 结果含有水分, 准确率失效.</p><h3 id="查准率-Precision"><a href="#查准率-Precision" class="headerlink" title="查准率 Precision"></a>查准率 Precision</h3><p><strong>查准率</strong>为所有被<u>预测为正</u>的样本中<u>实际为正</u>的样本的概率:</p><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202408071631976.png" alt=""></p><p>查准率代表对<strong>正样本结果</strong>中的预测准确程度, 有多少把握预测正确; 而准确率则代表<strong>整体</strong>的预测准确程度, 包括正样本和负样本.</p><h3 id="查全率-Recall"><a href="#查全率-Recall" class="headerlink" title="查全率 Recall"></a>查全率 Recall</h3><p><strong>查全率</strong>为所有<u>实际为正</u>的样本中被<u>预测为正</u>的样本的概率:</p><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202408081033339.png" alt=""></p><p>查全率越高, 代表实际用户被预测出来的概率越高.</p><h3 id="F1分数-F1-Score"><a href="#F1分数-F1-Score" class="headerlink" title="F1分数 F1$_$Score"></a>F1分数 F1$_$Score</h3><p>Precision 和 Recall 之间的关系用 P-R 曲线来表达:</p><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202408081046768.jpg" alt=""></p><p>以逻辑回归举例, 输出是一个 0 到 1 之间的概率数字, 根据这个概率判断用户好坏, 必须定义一个<strong>阈值</strong>. 为了找到一个最合适的阈值满足我们的要求, 必须遍历 0 到 1 之间所有的阈值, 每个阈值下都对应着一对 Precision 和 Recall, 从而得到了这条曲线.</p><p>想要找到二者之间的<strong>平衡点</strong>, 就需要一个新的指标 <strong>F1$_$Score</strong>. F1$_$Score 同时考虑了 Precision 和 Recall, 让二者同时达到最高, 公式为:</p><script type="math/tex; mode=display">\text{F1\_Score}=\dfrac{2*\text{Precision}*\text{Recall}}{\text{Precision}+\text{Recall}}</script><p>P-R 曲线的两个指标都<strong>聚焦于正样本</strong>, 适合评估在相同的类别分布下正例的预测情况.</p><h2 id="样本不平衡处理"><a href="#样本不平衡处理" class="headerlink" title="样本不平衡处理"></a>样本不平衡处理</h2><h3 id="灵敏度-Sensitivity-特异度-Specificity-真正率-TPR-假正率-FPR"><a href="#灵敏度-Sensitivity-特异度-Specificity-真正率-TPR-假正率-FPR" class="headerlink" title="灵敏度 Sensitivity/特异度 Specificity/真正率 TPR/假正率 FPR"></a>灵敏度 Sensitivity/特异度 Specificity/真正率 TPR/假正率 FPR</h3><p>以下指标能<strong>无视样本不平衡</strong>:</p><script type="math/tex; mode=display">\text{Sensitivity}=\dfrac{\text{TP}}{\text{TP}+\text{FN}},\quad\text{Specificity}=\dfrac{\text{TN}}{\text{FP}+\text{TN}}</script><p>Sensitivity 为实际为正的样本被预测为正的概率, Specificity 为实际为负的样本被预测为负的概率. 由于关心正样本, 所以使用 1 - Specificity, 查看负样本被错误预测为正的概率.</p><script type="math/tex; mode=display">\text{TPR}=\text{Sensitivity}=\dfrac{\text{TP}}{\text{TP}+\text{FN}},\quad\text{FPR}=1-\text{Specificity}=\dfrac{\text{FP}}{\text{FP}+\text{TN}}</script><p>TPR 和 FPR 分别<strong>从实际表现的各个结果角度出发</strong>, 在实际的正样本和负样本中来观察相关概率, <strong>无论样本是否平衡</strong>, 都不会被影响. TPR 只关注正样本中有多少被真正覆盖, FPR 只关注负样本中有多少被错误覆盖的.</p><h3 id="从「条件概率」说起"><a href="#从「条件概率」说起" class="headerlink" title="从「条件概率」说起"></a>从「条件概率」说起</h3><p>假设 X 为预测值, Y 为真实值, 可以将这些指标按条件概率表示:</p><script type="math/tex; mode=display">\begin{aligned}&\text{Precision}=\Pr(Y=1|X=1)\\&\text{Recall}=\text{Sensitivity}=\Pr(X=1|Y=1)\\&\text{Specificity}=\Pr(X=0|Y=0)\end{aligned}</script><p>如果先以实际结果为条件 (Recall/Sensitivity/Specificity), 就只需考虑一种样本; 而先以预测值为条件 (Precision), 需要同时考虑正样本和负样本. 所以<strong>先以实际结果为条件</strong>的指标都<strong>不受样本不平衡的影响</strong>, 相反<strong>以预测结果为条件</strong>就会<strong>受到样本不平衡的影响</strong>.</p><h3 id="接受者操作特征曲线-ROC"><a href="#接受者操作特征曲线-ROC" class="headerlink" title="接受者操作特征曲线 ROC"></a>接受者操作特征曲线 ROC</h3><p><strong>ROC 曲线</strong>的横坐标为假正率 FPR, 纵坐标为真正率 TPR:</p><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202408081120109.jpg" alt=""></p><p>与 P-R 曲线类似, ROC 曲线也通过<strong>遍历所有阈值</strong>来绘制:</p><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202408081122132.gif" alt=""></p><p><strong>改变阈值</strong>只是改变预测的正负样本数, 即 TPR 和 FPR, 但是曲线本身不变. FPR 表示模型虚报的响应程度, 而 TPR 表示模型预测响应的覆盖程度. <strong>TPR 越高</strong>, 同时 <strong>FPR 越低</strong>, 即 ROC 曲线越陡, 那么模型性能越好:</p><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202408081123478.gif" alt=""></p><p>当测试集中的<strong>正负样本的分布变化</strong>时, TPR 和 FPR 能无视样本不平衡, ROC 曲线<strong>聚焦于整体</strong>, 保持不变, 使其成为较均衡的评估方法.</p><h3 id="曲线下面积-AUC"><a href="#曲线下面积-AUC" class="headerlink" title="曲线下面积 AUC"></a>曲线下面积 AUC</h3><p>为了计算 ROC 曲线上的点, 可以使用不同的分类阈值多次评估逻辑回归模型, 但效率非常低. 一种基于排序的高效算法可以提供此类信息, 称为 <strong>AUC</strong>.</p><p>可以断言, AUC 越大, 模型效果越好. <strong>随机判断响应与否</strong>, 正负样本覆盖率都是 50%, 表示随机效果, 对应的 ROC 曲线即对角线. 在最坏情况下总有 TPR=FPR, 即 AUC = 0.5; 如果AUC &lt; 0.5, 只要取反预测类别, 便得到了 AUC &gt; 0.5 的分类器.</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h2 id=&quot;分类问题&quot;&gt;&lt;a href=&quot;#分类问题&quot; class=&quot;headerlink&quot; title=&quot;分类问题&quot;&gt;&lt;/a&gt;分类问题&lt;/h2&gt;&lt;p&gt;有一个判断性别的机器学习模型, 使用它来判断「是否为男性」时, 会出现 4 种情况:&lt;/p&gt;
&lt;p&gt;&lt;img</summary>
        
      
    
    
    
    <category term="CS" scheme="http://chengsx21.github.io/categories/CS/"/>
    
    <category term="AI" scheme="http://chengsx21.github.io/categories/CS/AI/"/>
    
    
    <category term="Machine Learning" scheme="http://chengsx21.github.io/tags/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title>操作系统 Lab 5</title>
    <link href="http://chengsx21.github.io/2024/06/09/cao-zuo-xi-tong-lab-5/"/>
    <id>http://chengsx21.github.io/2024/06/09/cao-zuo-xi-tong-lab-5/</id>
    <published>2024-06-09T09:27:40.000Z</published>
    <updated>2024-08-02T07:44:57.767Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Lab-5"><a href="#Lab-5" class="headerlink" title="Lab 5"></a>Lab 5</h1><h2 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a>功能实现</h2><h3 id="sys-enable-deadlock-detect"><a href="#sys-enable-deadlock-detect" class="headerlink" title="sys_enable_deadlock_detect"></a><code>sys_enable_deadlock_detect</code></h3><ol><li>修改 <code>ProcessControlBlockInner</code> 结构体, 为 <code>mutex</code> 和 <code>semaphore</code> 分别实现死锁检测算法所需的数据结构.</li><li>为 <code>ProcessControlBlockInner</code> 结构体实现 <code>fn deadlock_detect()</code> 进行死锁检测.</li><li><code>sys_thread_create()</code> 创建新线程时, 更新 <code>allocation</code> 与 <code>need</code>.</li><li><code>sys_mutex_create()</code> 和 <code>sys_semaphore_create()</code> 创建资源后, 更新 <code>available</code> 的大小, 扩展 <code>allocation</code> 与 <code>need</code>.</li><li><code>sys_mutex_lock()</code> 和 <code>sys_semaphore_down()</code> 申请资源时, 将 <code>need</code> 增加, 并进行死锁检测, 通过后减少 <code>need</code>, 减少 <code>available</code> 并增加 <code>allocation</code> 以使用资源.</li><li><code>sys_mutex_unlock()</code>和<code>sys_semaphore_up()</code> 归还资源, 将 <code>available</code> 增加, <code>allocation</code> 减少以释放资源.</li></ol><h2 id="实验用时"><a href="#实验用时" class="headerlink" title="实验用时"></a>实验用时</h2><ol><li>阅读文档及代码框架: 2h.</li><li>功能实现与报告: 2.5h.</li></ol><h2 id="问答题"><a href="#问答题" class="headerlink" title="问答题"></a>问答题</h2><ol><li><p><strong>在我们的多线程实现中, 当主线程 (即 0 号线程) 退出时, 视为整个进程退出, 此时需要结束该进程管理的所有线程并回收其资源. 需要回收的资源有哪些? 其他线程的 TaskControlBlock 可能在哪些位置被引用, 分别是否需要回收, 为什么?</strong></p><p> 答: (1) 回收所有子线程的 <code>TaskUserRes</code>, 包括用户栈, Trap 上下文以及进程 <code>pid</code>, 回收子进程列表以及用户空间数据. (2) 其他线程的 TaskControlBlock 可能在调度队列或等待某些同步原语时被引用, 无需回收, 会在主线程回收时一起回收.</p></li></ol><ol><li><p><strong>对比以下两种 <code>Mutex.unlock</code> 的实现, 二者有什么区别? 这些区别可能会导致什么问题?</strong></p> <pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">impl</span> <span class="token class-name">Mutex</span> <span class="token keyword">for</span> <span class="token class-name">Mutex1</span> <span class="token punctuation">{</span>    <span class="token keyword">fn</span> <span class="token function-definition function">unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">let</span> <span class="token keyword">mut</span> mutex_inner <span class="token operator">=</span> <span class="token keyword">self</span><span class="token punctuation">.</span>inner<span class="token punctuation">.</span><span class="token function">exclusive_access</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token macro property">assert!</span><span class="token punctuation">(</span>mutex_inner<span class="token punctuation">.</span>locked<span class="token punctuation">)</span><span class="token punctuation">;</span>        mutex_inner<span class="token punctuation">.</span>locked <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token keyword">let</span> <span class="token class-name">Some</span><span class="token punctuation">(</span>waking_task<span class="token punctuation">)</span> <span class="token operator">=</span> mutex_inner<span class="token punctuation">.</span>wait_queue<span class="token punctuation">.</span><span class="token function">pop_front</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">add_task</span><span class="token punctuation">(</span>waking_task<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">impl</span> <span class="token class-name">Mutex</span> <span class="token keyword">for</span> <span class="token class-name">Mutex2</span> <span class="token punctuation">{</span>    <span class="token keyword">fn</span> <span class="token function-definition function">unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">let</span> <span class="token keyword">mut</span> mutex_inner <span class="token operator">=</span> <span class="token keyword">self</span><span class="token punctuation">.</span>inner<span class="token punctuation">.</span><span class="token function">exclusive_access</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token macro property">assert!</span><span class="token punctuation">(</span>mutex_inner<span class="token punctuation">.</span>locked<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token keyword">let</span> <span class="token class-name">Some</span><span class="token punctuation">(</span>waking_task<span class="token punctuation">)</span> <span class="token operator">=</span> mutex_inner<span class="token punctuation">.</span>wait_queue<span class="token punctuation">.</span><span class="token function">pop_front</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">add_task</span><span class="token punctuation">(</span>waking_task<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            mutex_inner<span class="token punctuation">.</span>locked <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 答: 二者的区别在于对锁的状态修改. 第一种实现的逻辑是错误的.</p><p> 第一种释放锁时, 可能会被其他线程抢占, 任务不一定持有锁; 第二种将任务加入队列时, 同时实现了锁的继承.</p></li></ol>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;Lab-5&quot;&gt;&lt;a href=&quot;#Lab-5&quot; class=&quot;headerlink&quot; title=&quot;Lab 5&quot;&gt;&lt;/a&gt;Lab 5&lt;/h1&gt;&lt;h2 id=&quot;功能实现&quot;&gt;&lt;a href=&quot;#功能实现&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    <category term="CS" scheme="http://chengsx21.github.io/categories/CS/"/>
    
    <category term="OS" scheme="http://chengsx21.github.io/categories/CS/OS/"/>
    
    
    <category term="Operating System" scheme="http://chengsx21.github.io/tags/Operating-System/"/>
    
  </entry>
  
  <entry>
    <title>高性能计算导论 Lab 3</title>
    <link href="http://chengsx21.github.io/2024/06/03/gao-xing-neng-ji-suan-dao-lun-lab-3/"/>
    <id>http://chengsx21.github.io/2024/06/03/gao-xing-neng-ji-suan-dao-lun-lab-3/</id>
    <published>2024-06-03T09:27:40.000Z</published>
    <updated>2024-08-02T07:45:32.733Z</updated>
    
    <content type="html"><![CDATA[<h1 id="稀疏矩阵-矩阵乘-大作业-实验报告"><a href="#稀疏矩阵-矩阵乘-大作业-实验报告" class="headerlink" title="稀疏矩阵-矩阵乘 大作业 实验报告"></a>稀疏矩阵-矩阵乘 大作业 实验报告</h1><h2 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h2><h3 id="preprocess"><a href="#preprocess" class="headerlink" title="preprocess"></a><code>preprocess</code></h3><ul><li>不同矩阵数据集的<strong>稀疏度</strong>不同, 计算稀疏矩阵 $A$ <strong>平均每行非零元的个数</strong>.<ul><li>若平均每行非零元数<strong>较低</strong>:<ul><li>由每个线程块处理 $\mathbf{A}$ 中 64 个非零元.</li><li>利用<strong>共享内存</strong>存储 $\mathbf{A}$ 中非零元素所在行号.</li><li>根据 $K$ 的大小设置为 <code>SPARSE_32</code> 或 <code>SPARSE_256</code> 模式.</li></ul></li><li>若平均每行非零元数<strong>较高</strong>:<ul><li>由每个线程块处理 $\mathbf{A}$ 中 1 行非零元.</li><li>根据 $K$ 的大小设置为 <code>DENSE_32</code> 或 <code>DENSE_256</code> 模式.</li></ul></li></ul></li><li>初始化 <code>vout</code> 为 0, 确保输出结果的正确性.</li></ul><h3 id="run"><a href="#run" class="headerlink" title="run"></a><code>run</code></h3><ul><li><strong>每个线程块</strong>负责计算:<ul><li><code>SPARSE_32</code> 模式: $\mathbf{A}$ 中 64 个非零元与 $\mathbf{B}$ 中 1 列元素的乘积.</li><li><code>SPARSE_256</code> 模式: $\mathbf{A}$ 中 64 个非零元与 $\mathbf{B}$ 中 4 列元素的乘积.</li><li><code>DENSE_32</code> 模式: $\mathbf{A}$ 中 1 行非零元与 $\mathbf{B}$ 中 1 列元素的乘积.</li><li><code>DENSE_256</code> 模式: $\mathbf{A}$ 中 1 行非零元与 $\mathbf{B}$ 中 2 列元素的乘积.</li></ul></li><li><strong>每个线程块</strong>设置 32 个线程, 将上面的计算任务分摊到<strong>每个线程</strong>, 让同一个 Warp 内线程进行相同的工作.</li><li>设置<strong>共享内存</strong>存储稀疏矩阵 $\mathbf{A}$ 的元素, 在线程块内充分利用<strong>寄存器资源</strong>.</li><li>手动展开循环, 并改用<strong>位移运算</strong>实现 $2$ 幂次乘法运算, 提高计算效率.</li></ul><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><ul><li>$K = 32$ 时, 运行时间及加速比如下:</li><li><strong>平均吞吐量</strong>为 $4.52845\times 10^{9}$ nnz/s, 有 13 个达到<strong>加速比</strong>要求.</li></ul><div class="table-container"><table><thead><tr><th>测试集</th><th>spmm_cusparse/us</th><th>spmm_opt/us</th><th>加速比</th></tr></thead><tbody><tr><td><strong>arxiv</strong></td><td>750.658</td><td>462.133</td><td><strong><u>1.624</u></strong></td></tr><tr><td><strong>collab</strong></td><td>1281.46</td><td>651.966</td><td><strong><u>1.966</u></strong></td></tr><tr><td><strong>citation</strong></td><td>16443</td><td>9276.09</td><td><strong><u>1.773</u></strong></td></tr><tr><td><strong>ddi</strong></td><td>641.326</td><td>277.533</td><td><strong><u>2.311</u></strong></td></tr><tr><td><strong>protein</strong></td><td>24664.9</td><td>8190.62</td><td><strong><u>3.011</u></strong></td></tr><tr><td><strong>ppa</strong></td><td>18381.8</td><td>10251.1</td><td><strong><u>1.793</u></strong></td></tr><tr><td><strong>reddit.dgl</strong></td><td>48559</td><td>21516.1</td><td><strong><u>2.257</u></strong></td></tr><tr><td><strong>products</strong></td><td>55819.7</td><td>32036.7</td><td><strong><u>1.742</u></strong></td></tr><tr><td><strong>youtube</strong></td><td>3643.61</td><td>2425.85</td><td><strong><u>1.502</u></strong></td></tr><tr><td><strong>amazon_cogdl</strong></td><td>125240</td><td>53800.3</td><td><strong><u>2.328</u></strong></td></tr><tr><td><strong>yelp</strong></td><td>6574.59</td><td>3602.06</td><td><strong><u>1.825</u></strong></td></tr><tr><td><strong>wikikg2</strong></td><td>7138.26</td><td>3230.56</td><td><strong><u>2.210</u></strong></td></tr><tr><td><strong>am</strong></td><td>3741.58</td><td>2243.36</td><td><strong><u>1.668</u></strong></td></tr></tbody></table></div><ul><li>$K = 256$ 时, 运行时间及加速比如下:</li><li><strong>平均吞吐量</strong>为 $6.44827\times 10^{8}$ nnz/s, 有 10 个达到<strong>加速比</strong>要求.</li></ul><div class="table-container"><table><thead><tr><th>测试集</th><th>spmm_cusparse/us</th><th>spmm_opt/us</th><th>加速比</th></tr></thead><tbody><tr><td><strong>arxiv</strong></td><td>2990.24</td><td>2694.47</td><td><strong><u>1.110</u></strong></td></tr><tr><td><strong>collab</strong></td><td>5204.38</td><td>4437.61</td><td><strong><u>1.173</u></strong></td></tr><tr><td><strong>citation</strong></td><td>78943.5</td><td>69097.1</td><td><strong><u>1.143</u></strong></td></tr><tr><td><strong>ddi</strong></td><td>1562.93</td><td>1587.49</td><td>0.985</td></tr><tr><td><strong>protein</strong></td><td>80862.7</td><td>67908.9</td><td><strong><u>1.191</u></strong></td></tr><tr><td><strong>ppa</strong></td><td>84946.6</td><td>80882.5</td><td><strong><u>1.050</u></strong></td></tr><tr><td><strong>reddit.dgl</strong></td><td>202263</td><td>182988</td><td><strong><u>1.105</u></strong></td></tr><tr><td><strong>products</strong></td><td>258319</td><td>247208</td><td><strong><u>1.045</u></strong></td></tr><tr><td><strong>youtube</strong></td><td>14394.4</td><td>14886.4</td><td>0.967</td></tr><tr><td><strong>amazon_cogdl</strong></td><td>517165</td><td>435827</td><td><strong><u>1.187</u></strong></td></tr><tr><td><strong>yelp</strong></td><td>29985.7</td><td>26834.4</td><td><strong><u>1.117</u></strong></td></tr><tr><td><strong>wikikg2</strong></td><td>16638.8</td><td>19490.7</td><td>0.854</td></tr><tr><td><strong>am</strong></td><td>13388.7</td><td>12281.9</td><td><strong><u>1.090</u></strong></td></tr></tbody></table></div>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;稀疏矩阵-矩阵乘-大作业-实验报告&quot;&gt;&lt;a href=&quot;#稀疏矩阵-矩阵乘-大作业-实验报告&quot; class=&quot;headerlink&quot; title=&quot;稀疏矩阵-矩阵乘 大作业 实验报告&quot;&gt;&lt;/a&gt;稀疏矩阵-矩阵乘 大作业 实验报告&lt;/h1&gt;&lt;h2</summary>
        
      
    
    
    
    <category term="CS" scheme="http://chengsx21.github.io/categories/CS/"/>
    
    <category term="HPC" scheme="http://chengsx21.github.io/categories/CS/HPC/"/>
    
    
    <category term="High Performance Computing" scheme="http://chengsx21.github.io/tags/High-Performance-Computing/"/>
    
  </entry>
  
  <entry>
    <title>数据库专题训练 Lab 5</title>
    <link href="http://chengsx21.github.io/2024/05/21/shu-ju-ku-zhuan-ti-xun-lian-lab-5/"/>
    <id>http://chengsx21.github.io/2024/05/21/shu-ju-ku-zhuan-ti-xun-lian-lab-5/</id>
    <published>2024-05-21T09:18:57.000Z</published>
    <updated>2024-08-02T07:43:00.350Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Lab-5-查询优化"><a href="#Lab-5-查询优化" class="headerlink" title="Lab 5 查询优化"></a>Lab 5 查询优化</h1><h2 id="基础功能"><a href="#基础功能" class="headerlink" title="基础功能"></a>基础功能</h2><h3 id="查询重写"><a href="#查询重写" class="headerlink" title="查询重写"></a>查询重写</h3><p><strong>分解复合的选择谓词</strong>见 <code>Optimizer::SplitPredicates</code>.</p><ul><li>遍历查询计划树, 若查询树的节点为 <code>Filter</code> 类型, 对应的谓词为 <code>LOGIC</code> 类型, 且逻辑表达式为 <code>AND</code> 类型, 则将谓词的左右子表达式作为新的 <code>Filter</code> 节点添加到查询计划树中, 同时维护节点间的父子关系.</li></ul><p><strong>下推选择运算</strong>见 <code>Optimizer::PushDownFilter</code> 与 <code>Optimizer::PushDownSeqScan</code>.</p><ul><li>对于 <code>Filter</code> 类型的节点, 若谓词为 <code>Comparison</code> 且为 <code>ColumnValue</code> 和 <code>ColumnValue</code> 的比较, 则为连接谓词, 将其保存到 <code>Optimizer</code> 类的成员变量 <code>std::vector&lt;FilterOperator&gt; join_filters_</code> 中; 否则为普通谓词, 将其保存到成员变量 <code>std::vector&lt;FilterOperator&gt; simple_filters_</code> 中. 注意对子节点递归调用 <code>PushDown</code>.</li><li>通过 <code>Operator::OutputColumns().GetColumns()</code> 获取当前 <code>SeqScan</code> 节点的全部列名,  判断成员变量保存的普通谓词是否使用这些列, 并在此 <code>SeqScan</code> 节点上方添加 <code>Filter</code> 节点.</li></ul><p><strong>笛卡尔积转连接</strong>见 <code>Optimizer::PushDownJoin</code>.</p><ul><li>对 <code>NestedLoopJoin</code> 节点通过 <code>Operator::OutputColumns().GetColumns()</code> 获取当前 <code>SeqScan</code> 节点的全部列名,  判断成员变量保存的连接谓词是否可以用于该节点, 如果有将连接谓词添加到该节点的 <code>join_condition</code>, 实现笛卡尔积到连接的转换.</li></ul><h3 id="基于贪心算法的连接顺序选择"><a href="#基于贪心算法的连接顺序选择" class="headerlink" title="基于贪心算法的连接顺序选择"></a>基于贪心算法的连接顺序选择</h3><p><strong>基于贪心算法的连接顺序选择</strong>见 <code>Optimizer::ReorderJoin</code>.</p><ul><li><p>使用如下结构体存储当前表的元信息:</p>  <pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct TableInfo { public:  std::string name;  uint32_t cardinality;  std::unordered_set&lt;std::string&gt; columns;  std::unordered_map&lt;std::string, uint32_t&gt; distinct;  SeqScanOperator seq_scan;};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>递归扫描查询计划树, 记录所有 <code>SeqScan</code> 节点和 <code>NestedLoopJoin</code> 节点, 将 <code>SeqScan</code> 节点对应的表格元信息存储在 <code>table_infos</code> 中, 通过贪心算法对 <code>table_infos</code> 进行重排序. 从其中记录的 <code>SeqScan</code> 节点自底向上依次构建 <code>NestedLoopJoin</code> 节点, 并替换原始的以 <code>NestedLoopJoin</code> 节点为根的子树.</p></li></ul><h2 id="实验耗时"><a href="#实验耗时" class="headerlink" title="实验耗时"></a>实验耗时</h2><ol><li>基础功能<ul><li>查询重写: 2h.</li><li>基于贪心算法的连接顺序选择: 3.5h.</li></ul></li></ol>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;Lab-5-查询优化&quot;&gt;&lt;a href=&quot;#Lab-5-查询优化&quot; class=&quot;headerlink&quot; title=&quot;Lab 5 查询优化&quot;&gt;&lt;/a&gt;Lab 5 查询优化&lt;/h1&gt;&lt;h2 id=&quot;基础功能&quot;&gt;&lt;a href=&quot;#基础功能&quot;</summary>
        
      
    
    
    
    <category term="CS" scheme="http://chengsx21.github.io/categories/CS/"/>
    
    <category term="Database" scheme="http://chengsx21.github.io/categories/CS/Database/"/>
    
    
    <category term="Database" scheme="http://chengsx21.github.io/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>操作系统 Lab 4</title>
    <link href="http://chengsx21.github.io/2024/05/19/cao-zuo-xi-tong-lab-4/"/>
    <id>http://chengsx21.github.io/2024/05/19/cao-zuo-xi-tong-lab-4/</id>
    <published>2024-05-19T09:27:40.000Z</published>
    <updated>2024-08-02T07:44:56.981Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Lab-4"><a href="#Lab-4" class="headerlink" title="Lab 4"></a>Lab 4</h1><h2 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a>功能实现</h2><h3 id="sys-linkat"><a href="#sys-linkat" class="headerlink" title="sys_linkat"></a><code>sys_linkat</code></h3><blockquote><p>参考 <code>Inode::create()</code> 的实现.</p></blockquote><ol><li>为 <code>DiskInode</code> 添加 <code>nlink</code> 字段, 初始化时设置为 <code>1</code>.</li><li>为 <code>Inode</code> 实现 <code>linkat()</code> 方法, 保证仅由 <code>ROOT_INODE</code> 调用.</li><li>由 <code>read_disk_inode()</code> 获取 <code>old_name</code> 对应的 <code>inode_id</code>.</li><li>由 <code>EasyFileSystem</code> 解析出 <code>block_id</code> 与 <code>block_offset</code>.</li><li>由 <code>get_block_cache()</code> 建立链接并插入新建的 <code>DirEntry</code>.</li></ol><h3 id="sys-unlinkat"><a href="#sys-unlinkat" class="headerlink" title="sys_unlinkat"></a><code>sys_unlinkat</code></h3><blockquote><p>参考 <code>Inode::clear()</code> 的实现.</p></blockquote><ol><li>为 <code>Inode</code> 实现 <code>unlinkat()</code> 方法, 保证仅由 <code>ROOT_INODE</code> 调用.</li><li>由 <code>read_disk_inode()</code> 遍历根目录获取 <code>name</code> 对应的 <code>inode_id</code>.</li><li>由 <code>modify_disk_inode()</code> 修改 <code>DiskInode</code>, 删除相应目录项.</li><li>由 <code>EasyFileSystem</code> 解析出 <code>block_id</code> 与 <code>block_offset</code>.</li><li>由 <code>get_block_cache()</code> 解除链接, 并判断是否需要释放数据块.</li></ol><h3 id="sys-fstat"><a href="#sys-fstat" class="headerlink" title="sys_fstat"></a><code>sys_fstat</code></h3><ol><li>为 <code>File</code> trait 定义 <code>stat()</code> 方法, 传入 <code>*mut Stat</code> 作为参数.</li><li>仅为 <code>OSInode</code> 实现该方法, 在 <code>Stdin</code> 与 <code>Stdout</code> 中默认 <code>panic</code> 退出.</li><li>手动查询页表, 将传入的 <code>st: *mut Stat</code> 虚拟地址转换为对应的物理地址.</li><li><code>ino</code> 字段由 <code>EasyFileSystem</code> 计算并给出.</li><li><code>mode</code> 与 <code>nlink</code> 字段通过 <code>Inode::read_disk_inode()</code> 获取对应的 <code>DiskInode</code> 并给出.</li></ol><h2 id="问答题"><a href="#问答题" class="headerlink" title="问答题"></a>问答题</h2><ol><li><p><strong>在 easy-fs 中 root inode 起着什么作用? 如果 root inode 中的内容损坏会发生什么?</strong></p><p> 答: (1) 仅支持绝对路径的情况下, root inode 作为根目录所对应的 <code>Inode</code>, 是文件系统的起点, 对任何文件/目录的索引必须从 root inode 开始向下逐级进行, 相关文件方法只能由 root inode 调用. (2) 如果 root inode 中的内容损坏, 那么文件系统将无法实现文件管理.</p></li></ol><ol><li><p><strong>举出使用 pipe 的一个实际应用的例子.</strong></p><p> 答: 以使用如下命令进行文件行数统计为例:</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">cat</span> example.txt <span class="token operator">|</span> <span class="token function">wc</span> <span class="token parameter variable">-l</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> 操作系统捕获第一个命令的输出, 暂存在内存中, 并直接连接到第二个命令的输入, 形成一个管道, 无需将中间结果写入临时文件或手动多次执行命令.</p></li></ol><ol><li><p><strong>如果需要在多个进程间互相通信, 则需要为每一对进程建立一个管道, 非常繁琐, 请设计一个更易用的多进程通信机制.</strong></p><p> 答: 由操作系统设置一个消息队列进行多进程通信, 允许一个进程将数据发送到队列中, 设置发送方标识与期待接收方标识, 另一个进程从队列中读取数据, 通过标识符判断是否可接收. 比较成熟的消息队列中间件有 ActiveMQ, RabbitMQ, RocketMQ 等.</p></li></ol>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;Lab-4&quot;&gt;&lt;a href=&quot;#Lab-4&quot; class=&quot;headerlink&quot; title=&quot;Lab 4&quot;&gt;&lt;/a&gt;Lab 4&lt;/h1&gt;&lt;h2 id=&quot;功能实现&quot;&gt;&lt;a href=&quot;#功能实现&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    <category term="CS" scheme="http://chengsx21.github.io/categories/CS/"/>
    
    <category term="OS" scheme="http://chengsx21.github.io/categories/CS/OS/"/>
    
    
    <category term="Operating System" scheme="http://chengsx21.github.io/tags/Operating-System/"/>
    
  </entry>
  
  <entry>
    <title>高性能计算导论 Lab 2</title>
    <link href="http://chengsx21.github.io/2024/05/08/gao-xing-neng-ji-suan-dao-lun-lab-2/"/>
    <id>http://chengsx21.github.io/2024/05/08/gao-xing-neng-ji-suan-dao-lun-lab-2/</id>
    <published>2024-05-08T09:27:40.000Z</published>
    <updated>2024-08-02T07:45:31.956Z</updated>
    
    <content type="html"><![CDATA[<h1 id="全源最短路-大作业-实验报告"><a href="#全源最短路-大作业-实验报告" class="headerlink" title="全源最短路 大作业 实验报告"></a>全源最短路 大作业 实验报告</h1><h2 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h2><p>实现了实验指导书的<strong>三阶段分块全源最短路算法</strong>, 并实现了<strong>二级分块优化策略</strong>:</p><ul><li><strong>一级分块</strong>以 $48$ 为步长, 将 $n\times n$ 大小的矩阵分为 $48\times 48$ 大小的一级块, 每个一级块由<strong>一个线程块</strong>进行处理, 存储在<strong>共享内存</strong>中.</li><li><strong>二级分块</strong>以 $3$ 为步长, 将 $48\times 48$ 大小的一级块分为 $3\times 3$ 大小的二级块, 每个二级块由<strong>一个线程</strong>进行处理, 存储在<strong>寄存器</strong>中.</li></ul><h3 id="kernel1-lt-lt-lt-blk1-thr-gt-gt-gt"><a href="#kernel1-lt-lt-lt-blk1-thr-gt-gt-gt" class="headerlink" title="kernel1<<<blk1, thr>>>"></a><code>kernel1&lt;&lt;&lt;blk1, thr&gt;&gt;&gt;</code></h3><p>分配 $1$ 个线程块 <code>blk1</code>, 每个线程块包含 $16\times 16$ 个线程 <code>thr</code>.</p><p>设置<strong>共享内存</strong>存储中心块数据, 在中心块内部执行 Floyd-Warshall 算法:</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">__shared__ int cen_block[FIRST_BLOCK_LEN][FIRST_BLOCK_LEN];<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="kernel2-lt-lt-lt-blk2-thr-gt-gt-gt"><a href="#kernel2-lt-lt-lt-blk2-thr-gt-gt-gt" class="headerlink" title="kernel2<<<blk2, thr>>>"></a><code>kernel2&lt;&lt;&lt;blk2, thr&gt;&gt;&gt;</code></h3><p>分配 $N\times 2$ 个线程块 <code>blk2</code>, 每个线程块包含 $16\times 16$ 个线程 <code>thr</code>.</p><p>设置<strong>共享内存</strong>存储中心块、十字块数据, 设置<strong>局部内存</strong>存储二级块数据, 用中心块的结果和十字块中原本的其他结果更新十字块:</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">__shared__ int cen_block[FIRST_BLOCK_LEN][FIRST_BLOCK_LEN];__shared__ int cross_block[FIRST_BLOCK_LEN][FIRST_BLOCK_LEN];           int local_block[SECOND_BLOCK_LEN][SECOND_BLOCK_LEN];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="kernel3-lt-lt-lt-blk3-thr-gt-gt-gt"><a href="#kernel3-lt-lt-lt-blk3-thr-gt-gt-gt" class="headerlink" title="kernel3<<<blk3, thr>>>"></a><code>kernel3&lt;&lt;&lt;blk3, thr&gt;&gt;&gt;</code></h3><p>分配 $N\times N$ 个线程块 <code>blk3</code>, 每个线程块包含 $16\times 16$ 个线程 <code>thr</code>.</p><p>设置<strong>共享内存</strong>存储十字块、剩余块数据, 设置<strong>局部内存</strong>存储二级块数据, 用十字块的结果更新剩余的块:</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">__shared__ int cross_x_block[FIRST_BLOCK_LEN][FIRST_BLOCK_LEN];__shared__ int cross_y_block[FIRST_BLOCK_LEN][FIRST_BLOCK_LEN];__shared__ int rest_block[FIRST_BLOCK_LEN][FIRST_BLOCK_LEN];           int local_block[SECOND_BLOCK_LEN][SECOND_BLOCK_LEN];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><div class="table-container"><table><thead><tr><th>$n$</th><th>1000</th><th>2500</th><th>5000</th><th>7500</th><th>10000</th></tr></thead><tbody><tr><td><code>apsp_ref.cu</code></td><td>15.416 ms</td><td>377.811 ms</td><td>2986.876 ms</td><td>10051.554 ms</td><td>22835.954 ms</td></tr><tr><td><code>apsp.cu</code></td><td>1.400 ms</td><td>11.516 ms</td><td>77.646 ms</td><td>255.279 ms</td><td>556.766 ms</td></tr><tr><td>加速比</td><td>11.01</td><td>32.81</td><td>38.47</td><td>39.37</td><td>41.02</td></tr></tbody></table></div>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;全源最短路-大作业-实验报告&quot;&gt;&lt;a href=&quot;#全源最短路-大作业-实验报告&quot; class=&quot;headerlink&quot; title=&quot;全源最短路 大作业 实验报告&quot;&gt;&lt;/a&gt;全源最短路 大作业 实验报告&lt;/h1&gt;&lt;h2 id=&quot;实现方法&quot;&gt;&lt;a</summary>
        
      
    
    
    
    <category term="CS" scheme="http://chengsx21.github.io/categories/CS/"/>
    
    <category term="HPC" scheme="http://chengsx21.github.io/categories/CS/HPC/"/>
    
    
    <category term="High Performance Computing" scheme="http://chengsx21.github.io/tags/High-Performance-Computing/"/>
    
  </entry>
  
  <entry>
    <title>数据库专题训练 Lab 4</title>
    <link href="http://chengsx21.github.io/2024/05/07/shu-ju-ku-zhuan-ti-xun-lian-lab-4/"/>
    <id>http://chengsx21.github.io/2024/05/07/shu-ju-ku-zhuan-ti-xun-lian-lab-4/</id>
    <published>2024-05-07T09:18:57.000Z</published>
    <updated>2024-08-02T07:42:57.362Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Lab-4-查询处理"><a href="#Lab-4-查询处理" class="headerlink" title="Lab 4 查询处理"></a>Lab 4 查询处理</h1><h2 id="基础功能"><a href="#基础功能" class="headerlink" title="基础功能"></a>基础功能</h2><h3 id="Limit-算子"><a href="#Limit-算子" class="headerlink" title="Limit 算子"></a>Limit 算子</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">/* executors/limit_executor.h */class LimitExecutor : public Executor { private:  uint32_t limit_;  uint32_t offset_;};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">/* executors/limit_executor.cpp */std::shared_ptr&lt;Record&gt; LimitExecutor::Next() {  // 通过 plan_ 获取 limit 语句中的 offset 和 limit 值  auto offset = plan_-&gt;limit_offset_.value_or(0);  auto limit = plan_-&gt;limit_count_.value_or(UINT32_MAX);  while (auto record = children_[0]-&gt;Next()) {    // 设置开始输出的记录位置    if (offset_++ &lt; offset) {      continue;    }    // 限制输出的记录数    if (limit_++ &lt; limit) {      return record;    }    break;  }  return nullptr;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="排序算子"><a href="#排序算子" class="headerlink" title="排序算子"></a>排序算子</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">/* executors/orderby_executor.h */struct order_pair {  std::vector&lt;std::pair&lt;Value, OrderByType&gt;&gt; values_;  std::shared_ptr&lt;Record&gt; record_;};bool compare(const order_pair &amp;a, const order_pair &amp;b);class OrderByExecutor : public Executor { private:  std::vector&lt;order_pair&gt; records_;  bool sorted_ = false;};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">/* executors/orderby_executor.cpp */bool compare(const order_pair &amp;a, const order_pair &amp;b) {  // 根据 OrderByType 进行排序，传入 std::sort 函数  for (size_t i = 0; i &lt; a.values_.size(); i++) {    // 通过 Value 的 Less, Equal, Greater 函数比较 Value 的值    if (a.values_[i].first.Equal(b.values_[i].first)) {      continue;    }    if (a.values_[i].second == OrderByType::DESC) {      return a.values_[i].first.Less(b.values_[i].first);    }    else {      return a.values_[i].first.Greater(b.values_[i].first);    }  }  return false;}std::shared_ptr&lt;Record&gt; OrderByExecutor::Next() {  // 排序阶段  if (!sorted_) {    auto records = std::vector&lt;order_pair&gt;();    while (auto record = children_[0]-&gt;Next()) {      std::vector&lt;std::pair&lt;Value, OrderByType&gt;&gt; values;      for (auto &amp;order_by: plan_-&gt;order_bys_) {        // 通过 OperatorExpression 的 Evaluate 函数获取 Value 的值        auto value = order_by.second-&gt;Evaluate(record);        auto type = order_by.first;        values.push_back(std::make_pair(value, type));      }      records.push_back(order_pair{values, record});    }    // 使用 STL 的 sort 函数    std::sort(records.begin(), records.end(), compare);    records_ = std::move(records);    sorted_ = true;  }  // 输出阶段  if (records_.size() &gt; 0) {    auto record = records_.back().record_;    records_.pop_back();    return record;  }  return nullptr;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="嵌套循环连接算子"><a href="#嵌套循环连接算子" class="headerlink" title="嵌套循环连接算子"></a>嵌套循环连接算子</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">/* executors/nested_loop_join_executor.h */class NestedLoopJoinExecutor : public Executor { private:  std::vector&lt;std::shared_ptr&lt;Record&gt;&gt; first_records_;  std::vector&lt;std::shared_ptr&lt;Record&gt;&gt; second_records_;  std::vector&lt;std::shared_ptr&lt;Record&gt;&gt; records_;  bool joined_ = false;};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">/* executors/nested_loop_join_executor.cpp */std::shared_ptr&lt;Record&gt; NestedLoopJoinExecutor::Next() {  // 连接阶段  if (!joined_) {    while (auto record = children_[0]-&gt;Next()) {      first_records_.push_back(record);    }    while (auto record = children_[1]-&gt;Next()) {      second_records_.push_back(record);    }    // 二重嵌套循环连接    for (auto &amp;first_record : first_records_) {      for (auto &amp;second_record : second_records_) {        // 从 NestedLoopJoinOperator 中获取连接条件        if (plan_-&gt;join_type_ == JoinType::INNER) {          // 使用 EvaluateJoin 函数判断是否满足 join 条件          auto value = plan_-&gt;join_condition_-&gt;EvaluateJoin(first_record, second_record).GetValue&lt;bool&gt;();          if (value) {            // 使用 Record 的 Append 函数进行记录的连接            auto record = std::make_shared&lt;Record&gt;();            record-&gt;Append(*first_record);            record-&gt;Append(*second_record);            // 将连接后的记录加入到 records_ 中            records_.push_back(record);          }        }      }    }    joined_ = true;  }  // 输出阶段  if (records_.size() &gt; 0) {    auto record = records_.back();    records_.pop_back();    return record;  }  return nullptr;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="归并连接算子"><a href="#归并连接算子" class="headerlink" title="归并连接算子"></a>归并连接算子</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">/* executors/merge_join_executor.h */class MergeJoinExecutor : public Executor { private:  std::list&lt;std::shared_ptr&lt;Record&gt;&gt; first_records_;  std::list&lt;std::shared_ptr&lt;Record&gt;&gt; second_records_;  std::list&lt;std::shared_ptr&lt;Record&gt;&gt; records_;  bool joined_ = false;};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">/* executors/merge_join_executor.cpp */std::shared_ptr&lt;Record&gt; MergeJoinExecutor::Next() {  // 连接阶段  if (!joined_) {    while (auto record = children_[0]-&gt;Next()) {      first_records_.push_back(record);    }    while (auto record = children_[1]-&gt;Next()) {      second_records_.push_back(record);    }    if (plan_-&gt;join_type_ == JoinType::INNER) {      auto first_record = first_records_.front();      auto second_record = second_records_.front();      while (first_records_.size() &gt; 0 &amp;&amp; second_records_.size() &gt; 0) {        // 不满足 join 条件，跳过相应记录        if (plan_-&gt;left_key_-&gt;Evaluate(first_record).Less(plan_-&gt;right_key_-&gt;Evaluate(second_record))) {          first_records_.pop_front();          first_record = first_records_.front();          continue;        }        // 不满足 join 条件，跳过相应记录        if (plan_-&gt;left_key_-&gt;Evaluate(first_record).Greater(plan_-&gt;right_key_-&gt;Evaluate(second_record))) {          second_records_.pop_front();          second_record = second_records_.front();          continue;        }        // 满足 join 条件        while (plan_-&gt;left_key_-&gt;Evaluate(first_record).Equal(plan_-&gt;right_key_-&gt;Evaluate(second_record))) {          auto second_record_iter = second_records_.begin();          // 查询重复元组          while (plan_-&gt;left_key_-&gt;Evaluate(first_record).Equal(plan_-&gt;right_key_-&gt;Evaluate(*second_record_iter))) {            // 使用 Record 的 Append 函数进行记录的连接            auto record = std::make_shared&lt;Record&gt;();            record-&gt;Append(*first_record);            record-&gt;Append(**second_record_iter);            // 将连接后的记录加入到 records_ 中            records_.push_back(record);            // 遍历 second_records_ 直到为空            if (++second_record_iter == second_records_.end()) {              break;            }          }          // 遍历 first_records_ 直到为空          first_records_.pop_front();          if (first_records_.size() == 0) {            break;          }          first_record = first_records_.front();        }      }    }    joined_ = true;  }  // 输出阶段  if (records_.size() &gt; 0) {    auto record = records_.back();    records_.pop_back();    return record;  }  return nullptr;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="高级功能"><a href="#高级功能" class="headerlink" title="高级功能"></a>高级功能</h2><h3 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h3><h4 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h4><p>使用 <code>bool</code> 数组标记循环中外表与内表中的每条记录的连接情况. 循环完毕后, 从 <code>NestedLoopJoinOperator</code> 中获取连接条件, 对于外连接情形分别使用 <code>null</code> 补全未被连接的记录.</p><h4 id="新增代码"><a href="#新增代码" class="headerlink" title="新增代码"></a>新增代码</h4><p>文件 <code>src/executors/nested_loop_join_executor.cpp</code>.</p><h4 id="测例展示"><a href="#测例展示" class="headerlink" title="测例展示"></a>测例展示</h4><p>测试用例位于 <code>test/lab4/50-nested-loop-outer-join.test</code>, 设置上完全复用了 <code>test/lab4/30-nested-loop-join.test</code>, 只修改连接条件为 <code>left join</code> / <code>right join</code> / <code>full join</code>.</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token operator">&gt;</span> <span class="token function">make</span> debug <span class="token operator">&amp;&amp;</span> <span class="token function">make</span> lab4/50<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="内存哈希连接"><a href="#内存哈希连接" class="headerlink" title="内存哈希连接"></a>内存哈希连接</h3><h4 id="设计思路-1"><a href="#设计思路-1" class="headerlink" title="设计思路"></a>设计思路</h4><p>在 <code>src/executors/hash_join_executor.h</code> 中添加成员变量:</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class HashJoinExecutor : public Executor { private:  std::shared_ptr&lt;const HashJoinOperator&gt; plan_;  std::hash&lt;Value&gt; hasher;  std::unordered_map&lt;size_t, std::vector&lt;std::shared_ptr&lt;Record&gt;&gt;&gt; first_records_;  std::unordered_map&lt;size_t, std::vector&lt;std::shared_ptr&lt;Record&gt;&gt;&gt; second_records_;  std::vector&lt;std::shared_ptr&lt;Record&gt;&gt; records_;  bool joined_ = false;};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>划分阶段</strong>: 按 <code>hasher</code> 的哈希值对两表的记录进行分组, 哈希值相同的记录被划分到 <code>unordered_map</code> 的一个桶里进行连接.</p><p><strong>探查阶段</strong>: 对记录进行嵌套循环连接, 并输出到 <code>records_</code> 中.</p><h4 id="新增代码-1"><a href="#新增代码-1" class="headerlink" title="新增代码"></a>新增代码</h4><p>文件 <code>src/executors/hash_join_executor.cpp</code>.</p><h4 id="测例展示-1"><a href="#测例展示-1" class="headerlink" title="测例展示"></a>测例展示</h4><p>测试用例位于 <code>test/lab4/60-hash-loop-join.test</code>, 完全复用了 <code>test/lab4/30-nested-loop-join.test</code>, 只修改连接设置为 <code>hash</code>.</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token operator">&gt;</span> <span class="token function">make</span> debug <span class="token operator">&amp;&amp;</span> <span class="token function">make</span> lab4/60<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="分组聚合算子"><a href="#分组聚合算子" class="headerlink" title="分组聚合算子"></a>分组聚合算子</h3><h4 id="设计思路-2"><a href="#设计思路-2" class="headerlink" title="设计思路"></a>设计思路</h4><p>首先对记录进行哈希分组:</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">/* src/executors/aggregate_executor.cpp */while (auto record = children_[0]-&gt;Next()) {  uint64_t hash = 0;  for (auto &amp;group_by : plan_-&gt;group_bys_) {    hash *= 31;    hash += hasher(group_by-&gt;Evaluate(record));    auto col_value = dynamic_cast&lt;ColumnValue *&gt;(group_by.get());  }  hash %= 100000;  hash_records_[hash].push_back(record);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在分组后遍历组内的每条记录以实现 <code>min</code>, <code>max</code>, <code>sum</code>, <code>avg</code> 聚合函数, 依据记录字段是否为空实现 <code>count</code> 聚合函数, <code>count(*)</code> 聚合函数直接返回记录总数.</p><h4 id="新增代码-2"><a href="#新增代码-2" class="headerlink" title="新增代码"></a>新增代码</h4><p>文件 <code>src/executors/aggregate_executor.cpp</code>.</p><h4 id="测例展示-2"><a href="#测例展示-2" class="headerlink" title="测例展示"></a>测例展示</h4><p>测试用例位于 <code>test/lab4/70-aggregate.test</code>.</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token operator">&gt;</span> <span class="token function">make</span> debug <span class="token operator">&amp;&amp;</span> <span class="token function">make</span> lab4/70<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>分别进行了如下测试:</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> id<span class="token punctuation">,</span> room<span class="token punctuation">,</span> <span class="token function">max</span><span class="token punctuation">(</span>score<span class="token punctuation">)</span> <span class="token keyword">from</span> test_group_by <span class="token keyword">group</span> <span class="token keyword">by</span> id<span class="token punctuation">,</span> room<span class="token keyword">select</span> id<span class="token punctuation">,</span> room<span class="token punctuation">,</span> <span class="token function">sum</span><span class="token punctuation">(</span>score<span class="token punctuation">)</span> <span class="token keyword">from</span> test_group_by <span class="token keyword">group</span> <span class="token keyword">by</span> id<span class="token punctuation">,</span> room<span class="token keyword">select</span> id<span class="token punctuation">,</span> room<span class="token punctuation">,</span> <span class="token function">avg</span><span class="token punctuation">(</span>score<span class="token punctuation">)</span> <span class="token keyword">from</span> test_group_by <span class="token keyword">group</span> <span class="token keyword">by</span> id<span class="token punctuation">,</span> room<span class="token keyword">select</span> id<span class="token punctuation">,</span> room<span class="token punctuation">,</span> <span class="token function">count</span><span class="token punctuation">(</span>score<span class="token punctuation">)</span> <span class="token keyword">from</span> test_group_by <span class="token keyword">group</span> <span class="token keyword">by</span> id<span class="token punctuation">,</span> room<span class="token comment">------------------------------------------------------------------</span><span class="token keyword">select</span> <span class="token function">count</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span> <span class="token keyword">from</span> test_count<span class="token keyword">select</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token keyword">distinct</span> id<span class="token punctuation">)</span> <span class="token keyword">from</span> test_count<span class="token keyword">select</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">from</span> test_count<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="实验耗时"><a href="#实验耗时" class="headerlink" title="实验耗时"></a>实验耗时</h2><ol><li>基础功能<ul><li>Limit 算子: 0.5h.</li><li>排序算子: 0.5h.</li><li>嵌套循环连接算子: 0.5h.</li><li>归并连接算子: 1h.</li></ul></li><li>高级功能<ul><li>外连接: 2.5h.</li><li>内存哈希连接与分组聚合算子: 4h.</li></ul></li></ol>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;Lab-4-查询处理&quot;&gt;&lt;a href=&quot;#Lab-4-查询处理&quot; class=&quot;headerlink&quot; title=&quot;Lab 4 查询处理&quot;&gt;&lt;/a&gt;Lab 4 查询处理&lt;/h1&gt;&lt;h2 id=&quot;基础功能&quot;&gt;&lt;a href=&quot;#基础功能&quot;</summary>
        
      
    
    
    
    <category term="CS" scheme="http://chengsx21.github.io/categories/CS/"/>
    
    <category term="Database" scheme="http://chengsx21.github.io/categories/CS/Database/"/>
    
    
    <category term="Database" scheme="http://chengsx21.github.io/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>操作系统 Lab 3</title>
    <link href="http://chengsx21.github.io/2024/05/04/cao-zuo-xi-tong-lab-3/"/>
    <id>http://chengsx21.github.io/2024/05/04/cao-zuo-xi-tong-lab-3/</id>
    <published>2024-05-04T09:27:40.000Z</published>
    <updated>2024-08-02T07:44:56.223Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Lab-3"><a href="#Lab-3" class="headerlink" title="Lab 3"></a>Lab 3</h1><h2 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a>功能实现</h2><h3 id="sys-spawn"><a href="#sys-spawn" class="headerlink" title="sys_spawn"></a><code>sys_spawn</code></h3><blockquote><p>参考 <code>sys_fork</code> 以及 <code>sys_exec</code> 的实现.</p></blockquote><ol><li>通过 <code>MemorySet::from_elf</code> 解析 <code>elf</code> 文件得到 <code>memory_set</code>, <code>user_sp</code>, <code>entry_point</code>, 查询得到 <code>trap_cx_ppn</code>.</li><li>在内核空间进行 <code>pid_handle</code> 与 <code>kernel_stack</code> 分配, 并参考 <code>fork</code> 的实现新建 <code>TaskControlBlock</code>.</li><li>将新建的 <code>TaskControlBlock</code> 设置为当前 <code>TaskControlBlock</code> 的子进程.</li><li>修改新建 <code>TaskControlBlock</code> 的 <code>trap_cx</code> 的值.</li></ol><h3 id="stride-调度算法"><a href="#stride-调度算法" class="headerlink" title="stride 调度算法"></a>stride 调度算法</h3><ol><li>设置进程初始 <code>stride</code> 为 0, 初始 <code>priority</code> 为 16.</li><li><code>TaskManager::add</code> 将 <code>task</code> 加入队列时, 按 <code>stride</code> 递增顺序选择插入位置.</li><li><code>TaskManager::fetch</code> 获得队首 <code>task</code> 时, 按 <code>priority</code> 更新其 <code>stride</code> 值.</li></ol><h2 id="问答题"><a href="#问答题" class="headerlink" title="问答题"></a>问答题</h2><ol><li><p><strong>stride 算法原理非常简单, 但有一个比较大的问题. 例如两个 <code>pass = 10</code> 的进程, 使用 8bit 无符号整型储存 stride, <code>p1.stride = 255</code>, <code>p2.stride = 250</code>, 在 p2 执行一个时间片后, 理论上下一次应该 p1 执行.</strong></p><ol><li><p><strong>实际情况是轮到 p1 执行吗? 为什么?</strong></p><p> 答: 不是, p2 执行并更新 stride 后, 溢出了 8bit 无符号整型的表示范围,  <code>p2.stride = 4</code>, 因此下一次还是 p2 执行.</p></li></ol></li></ol><pre><code>**之前要求进程优先级 $\ge 2$ 其实就是为了解决这个问题. 可以证明, 在不考虑溢出的情况下, 在进程优先级全部 $\ge 2$ 的情况下, 如果严格按照算法执行, 那么 `STRIDE_MAX – STRIDE_MIN` $\le$ `BigStride / 2`.**2. **为什么? 尝试简单说明.**    答: 进程优先级 $\ge 2$ 的情况下, stride 的更新值至多为 `BigStride / 2`. 若某次 stride 更新后 `STRIDE_MAX – STRIDE_MIN &gt; BigStride / 2`, 说明在 stride 更新前被挑选的进程满足  `STRIDE – STRIDE_MIN &gt; 0`, 即并未选择 stride 最小的进程进行调度, 与算法的选取原则矛盾.3. **已知以上结论, 考虑溢出的情况下, 可以为 stride 设计特别的比较器, 让 `BinaryHeap&lt;Stride&gt;` 的 `pop` 方法能返回真正最小的 stride. 补全下列代码中的 `partial_cmp` 函数, 假设两个 stride 永远不会相等.**    <pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">use</span> <span class="token namespace">core<span class="token punctuation">::</span>cmp<span class="token punctuation">::</span></span><span class="token class-name">Ordering</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token type-definition class-name">Stride</span><span class="token punctuation">(</span><span class="token keyword">u64</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">impl</span> <span class="token class-name">PartialOrd</span> <span class="token keyword">for</span> <span class="token class-name">Stride</span> <span class="token punctuation">{</span>    <span class="token keyword">fn</span> <span class="token function-definition function">partial_cmp</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">,</span> other<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">Self</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">Option</span><span class="token operator">&lt;</span><span class="token class-name">Ordering</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>        <span class="token keyword">let</span> cmp<span class="token punctuation">:</span> <span class="token keyword">u64</span> <span class="token operator">=</span> <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token number">0</span> <span class="token operator">-</span> other<span class="token number">.0</span><span class="token punctuation">;</span>         <span class="token keyword">if</span> cmp <span class="token operator">&gt;</span> <span class="token class-name">BigStride</span> <span class="token operator">/</span> <span class="token number">2</span> <span class="token punctuation">{</span>            <span class="token class-name">Some</span><span class="token punctuation">(</span><span class="token class-name">Ordering</span><span class="token punctuation">::</span><span class="token class-name">Less</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token class-name">Some</span><span class="token punctuation">(</span><span class="token class-name">Ordering</span><span class="token punctuation">::</span><span class="token class-name">Greater</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">impl</span> <span class="token class-name">PartialEq</span> <span class="token keyword">for</span> <span class="token class-name">Stride</span> <span class="token punctuation">{</span>    <span class="token keyword">fn</span> <span class="token function-definition function">eq</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">,</span> other<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">Self</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token keyword">bool</span> <span class="token punctuation">{</span>        <span class="token boolean">false</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></code></pre>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;Lab-3&quot;&gt;&lt;a href=&quot;#Lab-3&quot; class=&quot;headerlink&quot; title=&quot;Lab 3&quot;&gt;&lt;/a&gt;Lab 3&lt;/h1&gt;&lt;h2 id=&quot;功能实现&quot;&gt;&lt;a href=&quot;#功能实现&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    <category term="CS" scheme="http://chengsx21.github.io/categories/CS/"/>
    
    <category term="OS" scheme="http://chengsx21.github.io/categories/CS/OS/"/>
    
    
    <category term="Operating System" scheme="http://chengsx21.github.io/tags/Operating-System/"/>
    
  </entry>
  
  <entry>
    <title>数据库专题训练 Lab 3</title>
    <link href="http://chengsx21.github.io/2024/04/23/shu-ju-ku-zhuan-ti-xun-lian-lab-3/"/>
    <id>http://chengsx21.github.io/2024/04/23/shu-ju-ku-zhuan-ti-xun-lian-lab-3/</id>
    <published>2024-04-23T09:18:57.000Z</published>
    <updated>2024-08-02T07:42:51.347Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Lab-3-多版本并发控制"><a href="#Lab-3-多版本并发控制" class="headerlink" title="Lab 3 多版本并发控制"></a>Lab 3 多版本并发控制</h1><h2 id="记录可见性的判断方法"><a href="#记录可见性的判断方法" class="headerlink" title="记录可见性的判断方法"></a>记录可见性的判断方法</h2><p>见 <code>src/table/table_scan.cpp - IsVisible()</code> 中的具体实现.</p><p><strong>可重复读</strong>隔离级别:</p><ul><li>记录<strong>被删除</strong>:<ul><li>默认可见;</li><li>如果对应的事务在当前事务之后, 则记录可见;</li><li>如果对应的事务不是活跃事务, 则记录不可见.</li></ul></li><li>记录<strong>未被删除</strong>:<ul><li>默认可见;</li><li>如果对应的事务是当前事务, 则记录不可见;</li><li>如果对应的事务在当前事务之后, 则记录不可见;</li><li>如果对应的事务是活跃事务, 则记录不可见.</li></ul></li></ul><p><strong>读已提交/串行化</strong>隔离级别:</p><ul><li>记录<strong>被删除</strong>:<ul><li>默认可见;</li><li>如果对应的事务是当前事务, 则记录不可见;</li><li>如果对应的事务不是活跃事务, 则记录不可见.</li></ul></li><li>记录<strong>未被删除</strong>:<ul><li>默认可见;</li><li>如果对应的事务是当前事务, 则记录不可见;</li><li>如果对应的事务是活跃事务但不是当前事务, 则记录不可见.</li></ul></li></ul><h2 id="基础功能"><a href="#基础功能" class="headerlink" title="基础功能"></a>基础功能</h2><h3 id="解决万圣节问题"><a href="#解决万圣节问题" class="headerlink" title="解决万圣节问题"></a>解决万圣节问题</h3><p><strong>添加记录头信息</strong>见 <code>src/table/table_page.cpp</code>.</p><ul><li>通过 <code>record-&gt;SetCid()</code>, <code>record-&gt;SetXmin()</code>, <code>record-&gt;SetXmax()</code> 设置相应的记录头信息.</li></ul><p><strong>修改可见性判断条件</strong>见 <code>src/table/table_scan.cpp</code>.</p><ul><li>满足 <code>record-&gt;GetXmax() == NULL_XID</code> 且 <code>record-&gt;GetXmin() != xid || record-&gt;GetCid() != cid</code> 的记录是可见的, 即记录未被删除且不由当前命令设置.</li></ul><h3 id="实现可重复读隔离-实现读已提交隔离"><a href="#实现可重复读隔离-实现读已提交隔离" class="headerlink" title="实现可重复读隔离 / 实现读已提交隔离"></a>实现可重复读隔离 / 实现读已提交隔离</h3><p><strong>设置活跃事务集合</strong>见 <code>src/executors/seqscan_executor.cpp</code>.</p><ul><li>分别通过 <code>GetSnapshot()</code> 和 <code>GetActiveTransactions()</code> 获取事务开始时的活跃事务集合以及即时的活跃事务集合.</li></ul><p><strong>修改可见性判断条件</strong>见 <code>src/table/table_scan.cpp</code>.</p><ul><li>分已删除记录和未删除记录进行处理, 见报告第一节.</li></ul><h3 id="强两阶段锁"><a href="#强两阶段锁" class="headerlink" title="强两阶段锁"></a>强两阶段锁</h3><p><strong>实现锁管理器 LockManager</strong> 见 <code>src/transaction/lock_manager.cpp</code>.</p><ul><li><p>使用 <code>std::vector</code> 保存表锁和数据行锁信息.</p>  <pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct TableLock {  LockType lock_type;  xid_t xid;  oid_t oid;};struct RowLock {  LockType lock_type;  xid_t xid;  oid_t oid;  Rid rid;};class LockManager {  ...  private:  std::vector&lt;TableLock&gt; table_locks_;  std::vector&lt;RowLock&gt; row_locks_;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>LockTable()</code> 与 <code>LockRow()</code> 先检查是否存在其他事务加的锁, 以及锁的类型相容性, 再检查本事务是否持有锁, 并升级锁的类型, 最后成功获取锁.</p></li><li><p><code>Compatible()</code> 实现参考 PPT 给出的意向锁相容性矩阵.</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202408011832724.png" alt=""></p></li><li><p><code>Upgrade()</code> 实现如下, 需要注意的是特殊判断 SIX 锁的获取.</p>  <pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">LockType LockManager::Upgrade(LockType self, LockType other) const {  if (self == other) {    return self;  }  if (self == LockType::S &amp;&amp; other == LockType::IX) {    return LockType::SIX;  }  return other;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p><strong>为修改操作加锁</strong>见 <code>src/executors/*</code>.</p><ul><li>普通 <code>select</code> 语句对表加 IS 锁; 数据修改操作对表加 IX 锁, 对修改的数据行加 X 锁.</li></ul><h3 id="实现可串行化隔离"><a href="#实现可串行化隔离" class="headerlink" title="实现可串行化隔离"></a>实现可串行化隔离</h3><p><strong>实现 select for update/share 加锁</strong>见 <code>src/executors/lock_rows_executor.cpp</code>.</p><ul><li>根据 <code>plan_</code> 的 <code>lock type</code>, 对表加 IS/ IX 锁, 对相应数据行加 S/X 锁.</li></ul><p><strong>设置活跃事务集合</strong>见 <code>src/executors/seqscan_executor.cpp</code>.</p><ul><li>完全与<strong>读已提交隔离</strong>相同.</li></ul><p><strong>修改可见性判断条件</strong>见 <code>src/table/table_scan.cpp</code>.</p><ul><li>完全与<strong>读已提交隔离</strong>相同.</li></ul><h2 id="实验耗时"><a href="#实验耗时" class="headerlink" title="实验耗时"></a>实验耗时</h2><ol><li>基础功能<ul><li>解决万圣节问题: 1h.</li><li>通过多版本并发控制实现可重复读隔离: 0.5h.</li><li>实现读已提交隔离: 1h.</li><li>强两阶段锁: 1h.</li><li>通过多版本两阶段锁实现可串行化隔离: 0.5h.</li></ul></li></ol>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;Lab-3-多版本并发控制&quot;&gt;&lt;a href=&quot;#Lab-3-多版本并发控制&quot; class=&quot;headerlink&quot; title=&quot;Lab 3 多版本并发控制&quot;&gt;&lt;/a&gt;Lab 3 多版本并发控制&lt;/h1&gt;&lt;h2 id=&quot;记录可见性的判断方法&quot;&gt;&lt;a</summary>
        
      
    
    
    
    <category term="CS" scheme="http://chengsx21.github.io/categories/CS/"/>
    
    <category term="Database" scheme="http://chengsx21.github.io/categories/CS/Database/"/>
    
    
    <category term="Database" scheme="http://chengsx21.github.io/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>高性能计算导论 Lab 1</title>
    <link href="http://chengsx21.github.io/2024/04/17/gao-xing-neng-ji-suan-dao-lun-lab-1/"/>
    <id>http://chengsx21.github.io/2024/04/17/gao-xing-neng-ji-suan-dao-lun-lab-1/</id>
    <published>2024-04-17T09:27:40.000Z</published>
    <updated>2024-08-02T07:45:31.349Z</updated>
    
    <content type="html"><![CDATA[<h1 id="奇偶排序-大作业-实验报告"><a href="#奇偶排序-大作业-实验报告" class="headerlink" title="奇偶排序 大作业 实验报告"></a>奇偶排序 大作业 实验报告</h1><p></p><center>    计 13 班 程思翔 2021010761</center><p></p><h2 id="sort-源代码"><a href="#sort-源代码" class="headerlink" title="sort 源代码"></a><code>sort</code> 源代码</h2><p>实现说明以代码注释的形式给出.</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">const int BIT = 8;const int BYTE_CNT = 4;const int MAX_BYTE = 256;const int MAX_BLOCK_LEN = 512;// 基数排序void better_sort(unsigned *beg, unsigned *end) {    int len = end - beg;    // 统计每个字节出现的次数    int cnt[MAX_BYTE];    // 在排序过程中暂存数据    unsigned *tmp = new unsigned[len];    // 从低位到高位依次取出一个字节进行排序    for (int p = 0; p &lt; BYTE_CNT; p++) {        memset(cnt, 0, sizeof(cnt));        // 对每个元素的当前字节进行计数        for (int q = 0; q &lt; len; q++) {            // 取出第 p 个字节            cnt[(beg[q] &gt;&gt; (p * BIT)) &amp; (MAX_BYTE - 1)]++;        }        // 每个元素表示小于或等于该索引值的元素的数量        for (int r = 1; r &lt; MAX_BYTE; r++) {            cnt[r] += cnt[r - 1];        }        // 在原始数组 beg 和临时数组 tmp 之间进行排序        if (p % 2 == 1) {            for (int s = len - 1; s &gt;= 0; s--) {                beg[--cnt[(tmp[s] &gt;&gt; (p * BIT)) &amp; (MAX_BYTE - 1)]] = tmp[s];            }        }        else {            for (int s = len - 1; s &gt;= 0; s--) {                tmp[--cnt[(beg[s] &gt;&gt; (p * BIT)) &amp; (MAX_BYTE - 1)]] = beg[s];            }        }    }    // 排序后数据从 tmp 复制回 beg    memcpy(tmp, beg, sizeof(unsigned) * len);    // 数组的起始位置    int start = len - 1;    // 当前遍历的位置    int cur = len - 1;    // 将 tmp 中所有负数按顺序放到 beg 的末尾    while ((tmp[cur] &amp; (0x1 &lt;&lt; 31)) &amp;&amp; (cur &gt;= 0)) {        beg[start - cur] = tmp[cur];        cur--;    }    // 将 tmp 中所有非负数复制到 beg 的前面    memcpy(beg + start - cur, tmp, sizeof(unsigned) * (cur + 1));    delete[] tmp;    return;}void Worker::sort() {    // 如果当前进程处于边界位置，直接返回即可    if (out_of_range) {        return;    }    // 根据 block_len 大小使用不同排序算法    if (block_len &gt; MAX_BLOCK_LEN) {        unsigned *n_data = (unsigned *)data;        better_sort(n_data, n_data + block_len);    }    else {        std::sort(data, data + block_len);    }    // 当前进程是否处于失配位置    bool proc_mismatch[2];    proc_mismatch[0] = (nprocs % 2 == 1 &amp;&amp; last_rank) ? 1 : 0;    proc_mismatch[1] = ((nprocs % 2 == 0 &amp;&amp; last_rank) || rank == 0) ? 1 : 0;    // 接收数据、归并结果缓冲区    size_t block_size = ceiling(n, nprocs);    float *n_data = new float[block_size];    float *buffer = new float[block_len];    // 当前进程在进程组中为左进程还是右进程    bool n_proc_direc[2];    n_proc_direc[0] = (rank + 1) % 2;    n_proc_direc[1] = n_proc_direc[0] ^ 1;    // 相邻进程的进程号    int n_proc_idx[2];    n_proc_idx[0] = rank + 2 * n_proc_direc[0] - 1;    n_proc_idx[1] = 2 * rank - n_proc_idx[0];    // 相邻进程的数据长度    int n_block_len[2];    n_block_len[0] = std::min(block_size, n - block_size * n_proc_idx[0]);    n_block_len[1] = std::min(block_size, n - block_size * n_proc_idx[1]);    // MPI 请求    MPI_Request req_send;    MPI_Request req_recv;    // 临时变量    int s, p, q, r;    int stage = -1;    // 进行 nprocs 轮循环，一定能实现稳定排序    while (++stage &lt; nprocs) {        // 当前轮次的奇偶性        s = stage % 2;        // 如果当前进程处于失配位置，直接跳过        if (proc_mismatch[s]) {            continue;        }        // 向相邻进程发送数据        MPI_Isend(data, block_len, MPI_FLOAT, n_proc_idx[s], 0, MPI_COMM_WORLD, &amp;req_send);        MPI_Irecv(n_data, n_block_len[s], MPI_FLOAT, n_proc_idx[s], 0, MPI_COMM_WORLD, &amp;req_recv);        MPI_Wait(&amp;req_recv, nullptr);        // 当前为左进程        if (n_proc_direc[s]) {            // 需要进行归并排序            if (data[block_len - 1] &gt; n_data[0]) {                p = 0;                q = 0;                r = 0;                // 从两个数组的开头开始，选取较小的元素放入 buffer 中                while (r != (int)block_len) {                    if (p &lt; n_block_len[s] &amp;&amp; (q &gt;= (int)block_len || n_data[p] &lt; data[q])) {                        buffer[r++] = n_data[p++];                    } else if (q &lt; (int)block_len) {                        buffer[r++] = data[q++];                    }                }                     // 交换 data 和 buffer                std::swap(data, buffer);            }        }        // 当前为右进程        else {            // 需要进行归并排序            if (data[0] &lt; n_data[n_block_len[s] - 1]) {                p = n_block_len[s] - 1;                q = block_len - 1;                r = block_len - 1;                // 从两个数组的开头开始，选取较小的元素放入 buffer 中                while (r != -1) {                    if (p &gt;= 0 &amp;&amp; (q &lt; 0 || n_data[p] &gt; data[q])) {                        buffer[r--] = n_data[p--];                    } else if (q &gt;= 0) {                        buffer[r--] = data[q--];                    }                }                // 交换 data 和 buffer                std::swap(data, buffer);            }        }        // 尽可能将通信时间与计算时间重叠        MPI_Wait(&amp;req_send, nullptr);    }    delete[] n_data;    delete[] buffer;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><h3 id="基础排序算法"><a href="#基础排序算法" class="headerlink" title="基础排序算法"></a>基础排序算法</h3><p>进程内 <code>block_len</code> 较小时, 使用 <code>std:: sort</code> 进行排序; 进程内 <code>block_len</code> 较大时, 使用基数排序, 对大规模数据效果较好.</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">if (block_len &gt; MAX_BLOCK_LEN) {    unsigned *n_data = (unsigned *)data;    better_sort(n_data, n_data + block_len);}else {    std::sort(data, data + block_len);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="稳定性判断"><a href="#稳定性判断" class="headerlink" title="稳定性判断"></a>稳定性判断</h3><p>奇偶排序是稳定的, 只需要循环 <code>nprocs</code> 轮, 得到的进程间数据必然是有序的, 省略了对全局有序性的判断时间.</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">while (++stage &lt; nprocs) {    s = stage % 2;...}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>让进程对的两个进程互相向对方发送数据, 进行归并排序, 在时间上实现重叠; 相比于设置主进程归并且分发结果到子进程, 减少了进程间通信时间成本.</p><h3 id="计算、通信时间重叠"><a href="#计算、通信时间重叠" class="headerlink" title="计算、通信时间重叠"></a>计算、通信时间重叠</h3><p>进程对的两个进程进行归并排序时, 使用非阻塞通信, 将计算时间和通信时间尽可能地重叠, 通过点对点异步通信实现.</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">MPI_Isend(data, block_len, MPI_FLOAT, n_proc_idx[s], 0, MPI_COMM_WORLD, &amp;req_send);MPI_Irecv(n_data, n_block_len[s], MPI_FLOAT, n_proc_idx[s], 0, MPI_COMM_WORLD, &amp;req_recv);MPI_Wait(&amp;req_recv, nullptr);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><div class="table-container"><table><thead><tr><th>$N\times P$</th><th>1 $\times$ 1</th><th>1 $\times$ 2</th><th>1 $\times$ 4</th><th>1 $\times$ 8</th><th>1 $\times$ 16</th><th>2 $\times$ 16</th></tr></thead><tbody><tr><td>耗费时间/ms</td><td>3443.300</td><td>2027.988</td><td>1311.689</td><td>912.484</td><td>730.631</td><td>644.694</td></tr><tr><td>加速比</td><td>1</td><td>1.698</td><td>2.625</td><td>3.774</td><td>4.713</td><td>5.341</td></tr></tbody></table></div>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;奇偶排序-大作业-实验报告&quot;&gt;&lt;a href=&quot;#奇偶排序-大作业-实验报告&quot; class=&quot;headerlink&quot; title=&quot;奇偶排序 大作业 实验报告&quot;&gt;&lt;/a&gt;奇偶排序 大作业 实验报告&lt;/h1&gt;&lt;p&gt;&lt;/p&gt;&lt;center&gt;
    计 13 班</summary>
        
      
    
    
    
    <category term="CS" scheme="http://chengsx21.github.io/categories/CS/"/>
    
    <category term="HPC" scheme="http://chengsx21.github.io/categories/CS/HPC/"/>
    
    
    <category term="High Performance Computing" scheme="http://chengsx21.github.io/tags/High-Performance-Computing/"/>
    
  </entry>
  
  <entry>
    <title>数据库专题训练 Lab 2</title>
    <link href="http://chengsx21.github.io/2024/04/14/shu-ju-ku-zhuan-ti-xun-lian-lab-2/"/>
    <id>http://chengsx21.github.io/2024/04/14/shu-ju-ku-zhuan-ti-xun-lian-lab-2/</id>
    <published>2024-04-14T09:18:57.000Z</published>
    <updated>2024-08-02T07:42:48.426Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Lab-2-事务处理与故障恢复"><a href="#Lab-2-事务处理与故障恢复" class="headerlink" title="Lab 2 事务处理与故障恢复"></a>Lab 2 事务处理与故障恢复</h1><h2 id="基础功能"><a href="#基础功能" class="headerlink" title="基础功能"></a>基础功能</h2><h3 id="事务回滚"><a href="#事务回滚" class="headerlink" title="事务回滚"></a>事务回滚</h3><p><strong>日志追加</strong>见 <code>src/table/table.cpp</code>.</p><ul><li>插入记录时, 通过 <code>std::make_unique&lt;char[]&gt;(record-&gt;GetSize())</code> 新建一段缓冲区用于记录的反序列化, 在插入记录时增加写 <code>InsertLog</code> 过程, 同时若创建新的页面则增加写 <code>NewPageLog</code> 过程.</li><li>删除记录时, 直接增加写 <code>DeleteLog</code> 过程.</li></ul><p><strong>事务回滚</strong>见 <code>src/log/log_manager.cpp</code> 中的 <code>LogManager::Rollback()</code>.</p><ul><li>通过 <code>log_record-&gt;GetPrevLSN()</code> 实现 <code>lsn</code> 的倒序遍历, 根据 <code>lsn</code> 和 <code>flushed_lsn_</code> 的大小关系判断记录日志在 <code>buffer</code> 还是磁盘中.</li><li>若日志在磁盘中, 通过 <code>std::make_unique&lt;char[]&gt;(MAX_LOG_SIZE)</code> 新建一段缓冲区用于日志的反序列化, 通过 <code>disk_.ReadLog</code> 读取日志.</li><li>若日志在 <code>buffer</code> 中, 从后往前遍历 <code>log_buffer_</code>, 找到 <code>lsn</code> 对应的日志.</li></ul><p><strong>Undo 操作</strong>见 <code>src/log/log_records/*</code>.</p><ul><li>通过 <code>catalog.GetDatabaseOid()</code> 获取数据库 <code>id</code>, 并通过 <code>buffer_pool</code> 获取相应页面进行操作.</li></ul><h3 id="Redo"><a href="#Redo" class="headerlink" title="Redo"></a>Redo</h3><p><strong>Redo 日志读取</strong>见 <code>src/log/log_manager.cpp</code> - <code>LogManager::Redo()</code>.</p><ul><li>从 <code>FIRST_LSN</code> 开始, 通过 <code>lsn += log_record-&gt;GetSize()</code> 实现 <code>lsn</code> 的顺序遍历, 根据 <code>lsn</code> 和 <code>flushed_lsn_</code> 的大小关系判断记录日志在 <code>buffer</code> 还是磁盘中, 其他逻辑与<strong>事务回滚</strong>相同.</li></ul><p><strong>Redo 操作</strong>见 <code>src/log/log_records/*</code>.</p><ul><li>通过 <code>catalog.GetDatabaseOid()</code> 获取数据库 <code>id</code>, 并通过 <code>buffer_pool</code> 获取相应页面进行操作.</li></ul><h3 id="ARIES-恢复算法流程"><a href="#ARIES-恢复算法流程" class="headerlink" title="ARIES 恢复算法流程"></a>ARIES 恢复算法流程</h3><p><strong>ARIES 恢复算法</strong>见 <code>src/log/log_manager.cpp</code> - <code>LogManager::Analyze()</code>.</p><ul><li>从 <code>end_checkpoint</code> 处获取记录点的脏页表 <code>dpt</code> 与活跃事务表 <code>att</code>.</li><li>从 <code>end_checkpoint</code> 开始扫描每一条日志:<ul><li>更新活跃事务表 <code>att</code>:<ul><li>如果 <code>xid</code> 在 <code>att</code> 中:<ul><li>如果是 <code>commit</code> 类型, 把 <code>xid</code> 从 <code>att</code> 删除.</li><li>否则更新 <code>att</code> 中 <code>xid</code> 对应的 <code>last_lsn</code>.</li></ul></li><li>如果 <code>xid</code> 不在 <code>att</code> 中:<ul><li>将 <code>xid</code> 和对应的 <code>last_lsn</code> 加入 <code>att</code>.</li></ul></li></ul></li><li>更新脏页表 <code>dpt</code>:<ul><li>如果 <code>page_id</code> 不在 <code>dpt</code> 中:<ul><li>将 <code>page_id</code> 和对应的 <code>lsn</code> 加入 <code>dpt</code>.</li></ul></li><li>如果 <code>page_id</code> 在 <code>dpt</code> 中:<ul><li>跳过, 无需进行处理.</li></ul></li></ul></li></ul></li><li><code>LogManager::Redo()</code> 选择脏页表 <code>dpt</code> 中最小的 <code>rec_lsn</code> 作为开始位置, 如果 <code>dpt</code> 为, 从开始检查点的位置重做.</li><li><code>LogManager::Undo()</code> 通过活跃事务表 <code>att</code> 记录的未完成事务进行回滚.</li></ul><h2 id="实验耗时"><a href="#实验耗时" class="headerlink" title="实验耗时"></a>实验耗时</h2><ol><li><p>基础功能</p><ul><li><p>事务回滚: 2h.</p></li><li><p>Redo: 3h.</p></li><li><p>ARIES 恢复算法: 3h.</p></li></ul></li></ol>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;Lab-2-事务处理与故障恢复&quot;&gt;&lt;a href=&quot;#Lab-2-事务处理与故障恢复&quot; class=&quot;headerlink&quot; title=&quot;Lab 2 事务处理与故障恢复&quot;&gt;&lt;/a&gt;Lab 2 事务处理与故障恢复&lt;/h1&gt;&lt;h2 id=&quot;基础功能&quot;&gt;&lt;a</summary>
        
      
    
    
    
    <category term="CS" scheme="http://chengsx21.github.io/categories/CS/"/>
    
    <category term="Database" scheme="http://chengsx21.github.io/categories/CS/Database/"/>
    
    
    <category term="Database" scheme="http://chengsx21.github.io/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>操作系统 Lab 2</title>
    <link href="http://chengsx21.github.io/2024/04/07/cao-zuo-xi-tong-lab-2/"/>
    <id>http://chengsx21.github.io/2024/04/07/cao-zuo-xi-tong-lab-2/</id>
    <published>2024-04-07T09:27:40.000Z</published>
    <updated>2024-08-02T07:44:53.839Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Lab-2"><a href="#Lab-2" class="headerlink" title="Lab 2"></a>Lab 2</h1><h2 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a>功能实现</h2><h3 id="sys-get-time-amp-sys-task-info"><a href="#sys-get-time-amp-sys-task-info" class="headerlink" title="sys_get_time &amp; sys_task_info"></a><code>sys_get_time</code> &amp; <code>sys_task_info</code></h3><ol><li>传入的 <code>ts: *mut TimeVal</code> 与 <code>ti: *mut TaskInfo</code> 是虚拟地址, 只需通过 <code>PageTable::from_token(current_user_token())</code> 手动查询页表, 将其转换为对应的物理地址, 其他实现与 <code>ch3</code> 完全相同. </li></ol><h3 id="sys-mmap-amp-sys-munmap"><a href="#sys-mmap-amp-sys-munmap" class="headerlink" title="sys_mmap &amp; sys_munmap"></a><code>sys_mmap</code> &amp; <code>sys_munmap</code></h3><ol><li>为 <code>TASK_MANAGER</code> 实现 <code>set_task_mapping(&amp;self, start: usize, len: usize, port: usize)</code> 与 <code>set_task_unmapping(&amp;self, start: usize, len: usize)</code> 方法分别用于虚存的映射与回收.</li><li><code>set_task_mapping</code> 和 <code>set_task_unmapping</code> 都从需要映射的 <code>vpn</code> 通过 <code>memory_set.translate(vpn)</code> 得到对应页表项 <code>entry</code>, 并分别保证其 <code>V</code> 位为 <code>0</code>/<code>1</code>.</li><li><code>set_task_mapping</code> 根据参数 <code>port</code> 设置相应的 <code>MapPermission</code> 位 (包括 <code>U</code> 位), 调用 <code>memory_set.insert_framed_area(...)</code>.</li><li><code>set_task_unmapping</code> 根据参数 <code>start</code> 找到区域在 <code>memory_set</code> 中对应的 <code>map_area</code>, 调用 <code>map_area.unmap(&amp;mut memory_set.page_table)</code>.</li></ol><h2 id="问答题"><a href="#问答题" class="headerlink" title="问答题"></a>问答题</h2><ol><li><p><strong>请列举 SV39 页表页表项的组成, 描述其中的标志位有何作用?</strong></p><p> 答: 页表项 [53:10] 位是物理页号, [7:0] 位是标志位, 其他为保留位, 由低到高为:</p><ul><li><code>V</code>: 页表项是否合法;</li><li><code>R</code>: 页表项对应的页面是否可读;</li><li><code>W</code>: 页表项对应的页面是否可读写;</li><li><code>X</code>: 页表项对应的页面是否可执行;</li><li><code>U</code>: 页表项对应的页面是否在 U 态下可访问;</li><li><code>G</code>: 页表项对应的页面是否为全局页面;</li><li><code>A</code>: 页表项对应的页面是否被访问过;</li><li><code>D</code>: 页表项对应的页面是否被修改过.</li></ul></li></ol><ol><li><p><strong>缺页指的是进程访问页面时页面不在页表中或在页表中无效的现象, 此时 MMU 将会返回一个中断, 告知 os 进程内存访问出了问题. os 选择填补页表并重新执行异常指令或者杀死进程.</strong></p><ol><li><p><strong>请问哪些异常可能是缺页导致的?</strong></p><p> 答: <code>Instruction page fault</code>, <code>Load/AMO page fault</code>, <code>Store/AMO page fault</code> 都是缺页导致的异常.</p></li><li><p><strong>发生缺页时, 描述相关重要寄存器的值.</strong></p><p> 答: 相关重要寄存器如下:</p><ul><li><code>scause</code>: 缺页异常发生时, 该寄存器的 <code>Interrupt</code> 位记 <code>0</code>, 表示异常发生; <code>Exception Code</code> 记录响应的缺页异常种类.</li></ul></li></ol><ul><li><p><code>stval</code>: 记录导致缺页异常的虚拟地址.</p><ul><li><code>stvec</code>: 记录异常处理程序的入口地址.</li></ul><ul><li><code>sstatus</code>, <code>sepc</code>, <code>sscratch</code> 在 ch3 报告中已描述过.</li></ul><p><strong>缺页有两个常见的原因, 其一是 Lazy 策略, 也就是直到内存页面被访问才实际进行页表操作. 比如, 一个程序被执行时, 进程的代码段理论上需要从磁盘加载到内存. 但是 os 并不会马上这样做, 而是会保存 .text 段在磁盘的位置信息, 在这些代码第一次被执行时才完成从磁盘的加载操作.</strong></p></li></ul><ol><li><p><strong>这样做有哪些好处?</strong></p><p> 答: Lazy 策略避免了页面被加载到内存中但未被访问就被淘汰, 减少了不必要的 I/O 操作.</p><p><strong>其实, 我们的 mmap 也可以采取 Lazy 策略, 比如: 一个用户进程先后申请了 10G 的内存空间, 然后用了其中 1M 就直接退出了. 按照现在的做法, 我们进行了很多没有意义的页表操作. </strong></p></li><li><p><strong>处理 <code>10G</code> 连续的内存页面, 对应的 SV39 页表大致占用多少内存 (估算数量级即可)?</strong></p><p> 答: SV39 分页模式的页面大小为 <code>4KB</code>, 单个页表项大小为 <code>8B</code>, 因此页表占用内存至少为</p><script type="math/tex; mode=display"> \dfrac{10\text{G}}{4\text{KB}}\cdot 8\text{B}=20\text{M}.</script></li></ol></li><li><p><strong>请简单思考如何才能实现 Lazy 策略, 缺页时又如何处理?</strong></p><p> 答: 进程开始时仅分配页表结构, 不分配实际的物理页面; 触发缺页异常时, 由中断处理函数查找磁盘, 分配物理页面, 并更新页表.</p></li></ol><p><strong>缺页的另一个常见原因是 swap 策略, 也就是内存页面可能被换到磁盘上了, 导致对应页面失效.</strong></p><ol><li><p><strong>此时页面失效如何表现在页表项 (PTE) 上?</strong></p><p> 答: 页面失效时, 会将相应页表项的标志位 <code>V</code> 记 <code>0</code>.</p></li></ol><ol><li><p><strong>为了防范侧信道攻击, 我们的 os 使用了双页表. 但是传统的设计一直是单页表的, 也就是说, 用户线程和对应的内核线程共用同一张页表, 只不过内核对应的地址只允许在内核态访问.</strong></p><ol><li><p><strong>在单页表情况下, 如何更换页表?</strong></p><p> 答: 单页表实现在用户进程切换时, 需要更换页表, 加载新地址空间.</p></li><li><p><strong>单页表情况下, 如何控制用户态无法访问内核页面?</strong></p><p> 答: 将内核页表中页表项的 <code>U</code> 置 <code>0</code>.</p></li><li><p><strong>单页表有何优势?</strong></p><p> 答: 在内核态和用户态转换时不需要软件更换页表, 效率更高.</p></li><li><p><strong>双页表实现下, 何时需要更换页表? 假设你写一个单页表操作系统, 你会选择何时更换页表?</strong></p><p> 答: 双页表实现在用户进程切换、自陷时需要切换页表; 我会选择在切换用户进程时更换页表.</p></li></ol></li></ol>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;Lab-2&quot;&gt;&lt;a href=&quot;#Lab-2&quot; class=&quot;headerlink&quot; title=&quot;Lab 2&quot;&gt;&lt;/a&gt;Lab 2&lt;/h1&gt;&lt;h2 id=&quot;功能实现&quot;&gt;&lt;a href=&quot;#功能实现&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    <category term="CS" scheme="http://chengsx21.github.io/categories/CS/"/>
    
    <category term="OS" scheme="http://chengsx21.github.io/categories/CS/OS/"/>
    
    
    <category term="Operating System" scheme="http://chengsx21.github.io/tags/Operating-System/"/>
    
  </entry>
  
  <entry>
    <title>数据库专题训练 Lab 1</title>
    <link href="http://chengsx21.github.io/2024/03/26/shu-ju-ku-zhuan-ti-xun-lian-lab-1/"/>
    <id>http://chengsx21.github.io/2024/03/26/shu-ju-ku-zhuan-ti-xun-lian-lab-1/</id>
    <published>2024-03-26T09:18:57.000Z</published>
    <updated>2024-08-02T07:41:22.252Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Lab-1-页面组织与缓存管理"><a href="#Lab-1-页面组织与缓存管理" class="headerlink" title="Lab 1 页面组织与缓存管理"></a>Lab 1 页面组织与缓存管理</h1><h2 id="基础功能"><a href="#基础功能" class="headerlink" title="基础功能"></a>基础功能</h2><h3 id="寻找记录插入的页面"><a href="#寻找记录插入的页面" class="headerlink" title="寻找记录插入的页面"></a>寻找记录插入的页面</h3><p><strong>寻找页面</strong>见 <code>src/table/table.cpp</code> 中的 <code>Table::InsertRecord()</code>.</p><ul><li>同时记录当前页面的 <code>page_id</code> 与前一页的 <code>prev_page_id</code>, 并遍历表的页面, 如果页面有足够的空间, 通过 <code>BufferPool::GetPage()</code> 获取页面, 并且调用成员函数<code>TablePage::InsertRecord()</code> 插入记录, 返回 <code>rid</code>; 如果没有足够空间, 则通过 <code>BufferPool::NewPage()</code> 创建新页面, 插入记录并返回 <code>rid</code>.</li></ul><h3 id="页面内部记录管理"><a href="#页面内部记录管理" class="headerlink" title="页面内部记录管理"></a>页面内部记录管理</h3><p><strong>插入记录</strong>见 <code>src/table/table_page.cpp</code> - <code>TablePage::InsertRecord()</code>.</p><ul><li>插入记录时先维护 <code>lower</code> 和 <code>upper</code> 指针, 根据当前页面存储的记录数设置 <code>slots</code> 数组. 通过 <code>Record::SerializeTo()</code> 将 <code>record</code> 写入 <code>page_data_</code>, 并将页面标记为 <code>dirty</code>.</li></ul><p><strong>删除记录</strong>见 <code>src/table/table_page.cpp</code> - <code>TablePage::DeleteRecord()</code>.</p><ul><li>使用 <code>Record::DeserializeHeaderFrom()</code> 函数读取记录头, 将 <code>slot_id</code> 对应的 <code>record</code> 标记为删除, 最后使用 <code>Record::SerializeHeaderTo()</code> 将记录头写回 <code>page_data_</code>, 并将页面标记为 <code>dirty</code>.</li></ul><h3 id="记录读取策略"><a href="#记录读取策略" class="headerlink" title="记录读取策略"></a>记录读取策略</h3><p><strong>读取记录</strong>见 <code>src/table/table_scan.cpp</code> - <code>TableScan::GetNextRecord()</code>.</p><ul><li>While 循环中遍历所有 <code>page</code> 的所有 <code>slot</code>, 并通过 <code>BufferPool::GetPage()</code> 获取相应页面, 通过 <code>TablePage::GetRecord()</code> 读取一条记录. 记录不附带删除标记则直接返回, 否则通过 <code>continue</code> 跳过该次循环.</li><li><code>TablePage::GetRecord()</code> 通过 <code>Record::DeserializeFrom()</code> 读取记录数据, 同时需要通过 <code>record-&gt;SetRid(rid)</code> 设置记录对应的 <code>rid</code>.</li></ul><h3 id="LRU-缓存替换算法实现"><a href="#LRU-缓存替换算法实现" class="headerlink" title="LRU 缓存替换算法实现"></a>LRU 缓存替换算法实现</h3><p><strong>缓存替换算法</strong>见 <code>src/storage/lru_buffer_strategy.cpp</code>.</p><ul><li>为 <code>LRUBufferStrategy</code> 新增成员变量 <code>std::list&lt;*size_t*&gt; lru_list_</code>. <code>LRUBufferStrategy::Access()</code> 用于更新页面访问记录, 将访问的页面移到链表头部; <code>LRUBufferStrategy::Evict()</code> 在缓存不足时选择最近最少使用的页面, 默认为链表尾部的页面.</li></ul><h2 id="高级功能"><a href="#高级功能" class="headerlink" title="高级功能"></a>高级功能</h2><h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><h4 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h4><p><code>DatabaseEngine::Vacuum()</code> 对指定的 <code>Table</code> 调用 <code>Table::VacuumRecord()</code>, 其遍历页面, 对每个页面调用 <code>TablePage::VacuumRecord()</code>.</p><p><code>TablePage::VacuumRecord()</code> 创建新页面 <code>shared_ptr&lt;TablePage&gt;</code>, 遍历原页面的所有 <code>record</code>, 将未被标记为删除的 <code>record</code> 插入新页面, 最后拷贝新页面的信息到原页面, 实现单页内的垃圾回收.</p><p><strong>效果:</strong> 将原页面中有效的记录迁移到新页面, <code>page_data_</code> 不再包含死数据, 可用空间扩大.</p><h4 id="新增代码描述"><a href="#新增代码描述" class="headerlink" title="新增代码描述"></a>新增代码描述</h4><p>函数 <code>src/database/database_engine.cpp</code> - <code>DatabaseEngine::Vacuum()</code>:</p><ul><li>判断对所有表还是对特定的表执行 <code>vacuum</code> 操作, 调用 <code>Table</code> 对象的 <code>VacuumRecord()</code> 方法.</li></ul><p>函数 <code>src/table/table.cpp</code> - <code>Table::VacuumRecord()</code>:</p><ul><li>遍历页面, 对每个页面调用 <code>TablePage</code> 对象的 <code>VacuumRecord()</code> 方法.</li></ul><p>函数 <code>src/table/table_page.cpp</code> - <code>TablePage::VacuumRecord()</code>:</p><ul><li>创建新页面 <code>new_page</code>, 使用 <code>Init()</code> 方法初始化, 反序列化遍历原页面中的所有记录, 将所有未删除的记录插入新页面中, 最后将新页面信息拷贝到原页面中, 并输出 <code>vacuum</code> 操作前后的页面信息.</li></ul><h4 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h4><p>测试用例位于 <code>test/lab1/60-vacuum.test</code>, 在单页面内插入 6 条记录, 并删除 3 条记录, 使用 <code>vacuum test_vacuum</code> 回收死数据, 输出 <code>vacuum</code> 前后的页面信息.</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token operator">&gt;</span> <span class="token function">make</span> debug <span class="token operator">&amp;&amp;</span> <span class="token function">make</span> lab1/60 <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202408011832720.png" alt=""></p><h3 id="空闲空间管理"><a href="#空闲空间管理" class="headerlink" title="空闲空间管理"></a>空闲空间管理</h3><h4 id="设计思路-1"><a href="#设计思路-1" class="headerlink" title="设计思路"></a>设计思路</h4><p>将页面空闲空间组织为满二叉树, 使用 <code>Table::bool pages_[TABLE_PAGE_SIZE]</code> 记录页面是否被创建, 使用 <code>Table::FreeSpaceTree fsm_tree_</code> 记录页面空闲空间.</p><p><code>FreeSpaceTree</code> 的叶子节点记录每个页面的空闲空间大小, 内部节点记录其子节点的最大值, 这样根节点就表示所有页面中的最大空闲空间.</p><p><code>insert</code> 记录时, 从 <code>FreeSpaceTree</code> 根节点开始二分查找空闲空间足够的叶子节点, 插入记录后从该叶子节点向上依次更新其所有父节点的空闲空间大小; 对表格进行 <code>vacuum</code> 操作后, 将 <code>FreeSpaceTree</code> 的所有叶子节点更新为对应的空闲空间, 并重新建树, 逐层更新内部节点.</p><p><strong>效果:</strong> 插入记录后无需使用原链表遍历的方式寻找页面, 可以使用树结构收获二分查找的效率.</p><h4 id="新增代码描述-1"><a href="#新增代码描述-1" class="headerlink" title="新增代码描述"></a>新增代码描述</h4><p>常量 <code>src/common/constants.h</code>:</p><ul><li><p>新增 FSMTree 的最大节点数, 表格最大页面数 (为测试效率设为 <code>1 &lt;&lt; 3</code>, 生产中可根据需要进行页面数设置).</p>  <pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">static constexpr size_t FS_TREE_SIZE = (1 &lt;&lt; 3) - 1;static constexpr size_t TB_PAGE_SIZE = (FS_TREE_SIZE + 1) / 2;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><p>类 <code>src/table/free_space_tree.h</code> - <code>class FreeSpaceNode</code>:</p><ul><li>记录该节点是否为叶子节点, 存储对应的空闲空间大小.</li></ul><p>类 <code>src/table/free_space_tree.h</code> - <code>class FreeSpaceTree</code>:</p><ul><li><code>InsertRecord()</code> 从根节点开始二分查找空闲空间足够的叶子节点, 插入记录后向上依次更新所有父节点的空闲空间大小.</li><li><code>VacuumRecord()</code> 在 <code>vacuum</code> 操作回收页面空间后, 将所有叶子节点更新为对应的空闲空间, 并逐层更新内部节点的空闲空间大小.</li></ul><p>类 <code>src/table/table.h</code> - <code>class Table</code>:</p><ul><li>将原来链表遍历查找页面的方式, 改为树结构二分查找方式.</li><li>新增成员变量 <code>bool pages_[TABLE_PAGE_SIZE]</code> 记录页面的创建情况, 新增成员变量 <code>FreeSpaceTree fsm_tree_</code> 记录页面空闲空间.</li></ul><h4 id="效果展示-1"><a href="#效果展示-1" class="headerlink" title="效果展示"></a>效果展示</h4><p>测试用例位于 <code>test/lab1/60-vacuum-and-fsm.test</code>, 插入与删除一系列记录后, 进行 <code>vacuum</code> 操作, 在每次插入记录后输出页面空闲大小信息.</p><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202408011832721.png" style="zoom:40%;"></p><p><code>vacuum</code> 操作后, 再插入一条记录, 观察到记录被插入到垃圾回收后的首页中:</p><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202408011832722.png" style="zoom:25%;"></p><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202408011832723.png" style="zoom:47%;"></p><p>为了便于测试, 设置 <code>src/common/constants.h</code> 中 <code>TABLE_PAGE_SIZE</code> 为 4, 生产中可根据需要修改 <code>FS_TREE_SIZE</code> 进行页面数配置.</p><h2 id="实验耗时"><a href="#实验耗时" class="headerlink" title="实验耗时"></a>实验耗时</h2><ol><li>基础功能<ul><li>变长记录页面组织: 4h.</li><li>LRU 缓存替换: 0.5h.</li></ul></li><li>高级功能<ul><li>垃圾回收: 3h.</li><li>空闲空间管理: 3h.</li></ul></li></ol>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;Lab-1-页面组织与缓存管理&quot;&gt;&lt;a href=&quot;#Lab-1-页面组织与缓存管理&quot; class=&quot;headerlink&quot; title=&quot;Lab 1 页面组织与缓存管理&quot;&gt;&lt;/a&gt;Lab 1 页面组织与缓存管理&lt;/h1&gt;&lt;h2 id=&quot;基础功能&quot;&gt;&lt;a</summary>
        
      
    
    
    
    <category term="CS" scheme="http://chengsx21.github.io/categories/CS/"/>
    
    <category term="Database" scheme="http://chengsx21.github.io/categories/CS/Database/"/>
    
    
    <category term="Database" scheme="http://chengsx21.github.io/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>操作系统 Lab 1</title>
    <link href="http://chengsx21.github.io/2024/03/24/cao-zuo-xi-tong-lab-1/"/>
    <id>http://chengsx21.github.io/2024/03/24/cao-zuo-xi-tong-lab-1/</id>
    <published>2024-03-24T09:27:40.000Z</published>
    <updated>2024-08-02T07:44:51.827Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Lab-1"><a href="#Lab-1" class="headerlink" title="Lab 1"></a>Lab 1</h1><h2 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a>功能实现</h2><ol><li>为每个 <code>TaskControlBlock</code> 维护一个 <code>TaskInfo</code> 对象, 并为 <code>TaskInfo</code> 实现了 <code>init()</code> 默认方法用于初始化.</li><li>为 <code>TASK_MANAGER</code> 实现 <code>get_task_info(&amp;self, ti: *mut TaskInfo)</code> 与 <code>set_syscall_times(&amp;self, syscall_id: usize)</code> 方法分别用于获取当前任务的信息以及计数系统调用, 并对外暴露调用接口.</li><li>进入 <code>syscall</code> 分发函数后先调用 <code>set_syscall_times</code>, 计数当前系统调用.</li><li>在 <code>run_first_task(&amp;self)</code> 中使用 <code>get_time_ms()</code> 初始化任务调度时刻.</li><li>在 <code>TASK_MANAGER::run_next_task(&amp;self)</code> 中依据当前任务调度时刻是否为 0 判断该任务是否被首次调度, 并使用 <code>get_time_ms()</code> 进行初始化.</li></ol><h2 id="问答题"><a href="#问答题" class="headerlink" title="问答题"></a>问答题</h2><ol><li><p><strong>正确进入 U 态后, 程序的特征还应有: 使用 S 态特权指令, 访问 S 态寄存器后会报错. 可以自行测试这些内容 (运行<a href="https://github.com/LearningOS/rCore-Tutorial-Test-2024S/tree/master/src/bin">三个 bad 测例 (<code>ch2b_bad_*.rs</code>)</a>, 注意在编译时至少需要指定 <code>LOG=ERROR</code> 才能观察到内核的报错信息), 描述程序出错行为, 同时注意注明你使用的 sbi 及其版本.</strong></p><p> 答: 我使用的 sbi 版本为 <code>RustSBI 0.3.0-alpha.2</code>. </p><p> 分别报错 <code>[kernel] PageFault in application, bad addr = 0x0, bad instruction = 0x804003ac, kernel killed it</code>, <code>[kernel] Illegal Instruction in application, kernel killed it</code>, <code>[kernel] Illegal Instruction in application, kernel killed it</code>.</p><p> 分别是因为写入非法地址 <code>0x0</code>, 使用 S 态特权指令 <code>sret</code>, 以及使用 S 态指令访问 S 态寄存器 <code>sstatus</code> 导致的.</p></li></ol><ol><li><p><strong>深入理解 <a href="https://github.com/LearningOS/rCore-Tutorial-Code-2024S/blob/ch3/os/src/trap/trap.S"><code>trap.S</code></a> 中两个函数 <code>__alltraps</code> 和 <code>__restore</code> 的作用, 并回答如下问题:</strong></p><ol><li><p><strong>L40: 刚进入 <code>__restore</code> 时, <code>a0</code> 代表了什么值. 请指出 <code>__restore</code> 的两种使用情景.</strong></p><p> 答: <code>a0</code> 是指向 <code>__switch</code> 后被切换任务的 <code>TaskContext</code> 的指针; <code>__restore</code> 封装在 <code>goto_restore</code> 中, 用于任务切换或 Trap 处理这两种使用情景后从 S 态返回 U 态.</p></li></ol></li></ol><pre><code>2. **L43-L48: 这几行汇编代码特殊处理了哪些寄存器? 这些寄存器的的值对于进入用户态有何意义? 请分别解释.**    <pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">ld t0, 32*8(sp)ld t1, 33*8(sp)ld t2, 2*8(sp)csrw sstatus, t0csrw sepc, t1csrw sscratch, t2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>    答: 特殊处理了 `sstatus`, `sepc`, `sscratch` 这三个特权寄存器, 在 `__alltraps` 进入 S 态前将这些特权寄存器的信息存储在了内核栈上.    + `sstatus` 保存了 Trap 发生前 CPU 的特权级等信息, 在 Trap 处理完成后正确恢复特权级.    + `sepc` 保存了 Trap 发生前最后一条指令的地址, 在 Trap 处理完成后恢复到正确的执行位置.    + `sscratch` 保存了 Trap 发生前的栈指针 `sp`, 在 Trap 处理完成后正确恢复到用户栈, 确保用户态程序正确执行.3. **L50-L56: 为何跳过了 `x2` 和 `x4`?**    <pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">ld x1, 1*8(sp)ld x3, 3*8(sp).set n, 5.rept 27   LOAD_GP %n   .set n, n+1.endr<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>    答: `x2` 是栈指针寄存器 `sp`: 用户栈指针已经通过 `csrw sscratch, t2` 读到了特权寄存器 `sscratch` 中, `sp` 指向当前内核栈, 用于恢复其它通用寄存器, 不可直接覆盖为用户栈指针.    `x4` 是线程指针寄存器 `tp`: 在当前情境中不会用到.4. **L60: 该指令之后, `sp` 和 `sscratch` 中的值分别有什么意义?**    <pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">csrrw sp, sscratch, sp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>    答: `csrrw` 交换了 `sp` 与 `sscratch` 的值, 交换后 `sp` 指向用户栈栈顶, `sscratch` 指向内核栈栈顶, 并使用 `sret` 进行状态切换.5. **`__restore` 中发生状态切换在哪一条指令? 为何该指令执行之后会进入用户态?**    答: `sret`. 为了执行这条指令, 硬件会将特权级按 `sstatus` 的 `SPP` 字段设置为 U, 并跳转到 `sepc` 指向的指令恢复程序执行.6. **L13: 该指令之后, `sp` 和 `sscratch` 中的值分别有什么意义?**    <pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">csrrw sp, sscratch, sp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>    答: `csrrw` 交换了 `sp` 与 `sscratch` 的值, 交换后 `sp` 指向内核栈栈顶, `sscratch` 指向用户栈栈顶.7. **从 U 态进入 S 态是哪一条指令发生的?**    答: 通过 `ecall` 指令执行系统调用发生从 U 态到 S 态的状态转换.</code></pre>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;Lab-1&quot;&gt;&lt;a href=&quot;#Lab-1&quot; class=&quot;headerlink&quot; title=&quot;Lab 1&quot;&gt;&lt;/a&gt;Lab 1&lt;/h1&gt;&lt;h2 id=&quot;功能实现&quot;&gt;&lt;a href=&quot;#功能实现&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    <category term="CS" scheme="http://chengsx21.github.io/categories/CS/"/>
    
    <category term="OS" scheme="http://chengsx21.github.io/categories/CS/OS/"/>
    
    
    <category term="Operating System" scheme="http://chengsx21.github.io/tags/Operating-System/"/>
    
  </entry>
  
  <entry>
    <title>编译原理 实验6</title>
    <link href="http://chengsx21.github.io/2024/01/02/bian-yi-yuan-li-lab-6/"/>
    <id>http://chengsx21.github.io/2024/01/02/bian-yi-yuan-li-lab-6/</id>
    <published>2024-01-02T09:18:57.000Z</published>
    <updated>2024-08-02T07:46:22.787Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Stage-6-报告"><a href="#Stage-6-报告" class="headerlink" title="Stage 6 报告"></a>Stage 6 报告</h1><blockquote><p><em>写在前面:</em><br>    这一个 Stage 的实现中对着前中后端的报错疯狂调 Bug, 基本实现过程就是 [构造测例] -&gt; [看报错] -&gt; [调代码], 好在终于是实现地较为完备, 痛并快乐着 (×).<br>    报告或许会较长, 尽管尝试简化对实现思路的叙述, 最后还是保留了如下内容, 以便用尽可能简洁的描述, 将实现过程清晰地展示出来.</p></blockquote><h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><h3 id="step-10"><a href="#step-10" class="headerlink" title="step 10"></a>step 10</h3><p><strong>词法语法分析</strong>: 修改 <code>frontend/ast/tree.py</code> 中 <code>Program</code> 节点的定义, 并添加 <code>globalVars()</code> 方法传递<strong>全局变量</strong>键值对. 在 <code>frontend/parser/ply_parser.py</code> 中参考已有实现, 给出相关 <code>CFG</code> 文法:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># frontend/ast/tree.py</span><span class="token keyword">class</span> <span class="token class-name">Program</span><span class="token punctuation">(</span>ListNode<span class="token punctuation">[</span>Union<span class="token punctuation">[</span><span class="token string">"Function"</span><span class="token punctuation">,</span> <span class="token string">"Declaration"</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">def</span> <span class="token function">globalVars</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">dict</span><span class="token punctuation">[</span><span class="token builtin">str</span><span class="token punctuation">,</span> <span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token punctuation">{</span>decl<span class="token punctuation">.</span><span class="token builtin">getattr</span><span class="token punctuation">(</span><span class="token string">'symbol'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name<span class="token punctuation">:</span> decl<span class="token punctuation">.</span><span class="token builtin">getattr</span><span class="token punctuation">(</span><span class="token string">'symbol'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>initValue <span class="token keyword">for</span> decl <span class="token keyword">in</span> self <span class="token keyword">if</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>decl<span class="token punctuation">,</span> Declaration<span class="token punctuation">)</span><span class="token punctuation">}</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>语义分析</strong>: 只需修改 <code>frontend/typecheck/namer.py</code> 的 <code>visitDeclaration</code> 部分, 如果当前作用域为全局作用域, 修改 <code>symbol.isGlobal = True</code> 即可, 并为<strong>全局变量</strong>设置<strong>初始值</strong> <code>symbol.initValue</code>.</p><p><strong>中间代码生成</strong>: 在 <code>utils/tac/tacinstr.py</code> 中参照已有实现, 添加全局变量地址加载、全局变量加载和存储的 TAC 指令:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># utils/tac/tacinstr.py</span><span class="token keyword">class</span> <span class="token class-name">LoadAddress</span><span class="token punctuation">(</span>TACInstr<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment"># LOAD SYMBOL ADDRESS...</span><span class="token keyword">class</span> <span class="token class-name">LoadIntLiteral</span><span class="token punctuation">(</span>TACInstr<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># LOAD SYMBOL...</span><span class="token keyword">class</span> <span class="token class-name">StoreIntLiteral</span><span class="token punctuation">(</span>TACInstr<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># STORE SYMBOL...</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 <code>utils/tac/tacgen.py</code> 中 <code>TACFuncEmitter</code> 类实现与之有关的 <code>Visitor</code> 模式方法, 修改 <code>TACGen</code> 类的 <code>visitAssignment</code> 及 <code>visitIdentifier</code> 方法, 判断访问标识符和赋值操作是否对<strong>全局变量</strong>进行:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># utils/tac/tacgen.py</span><span class="token keyword">class</span> <span class="token class-name">TACGen</span><span class="token punctuation">(</span>Visitor<span class="token punctuation">[</span>TACFuncEmitter<span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">visitIdentifier</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> ident<span class="token punctuation">:</span> Identifier<span class="token punctuation">,</span> mv<span class="token punctuation">:</span> TACFuncEmitter<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>        <span class="token comment">#! 标识符是全局变量</span>        <span class="token keyword">if</span> ident<span class="token punctuation">.</span><span class="token builtin">getattr</span><span class="token punctuation">(</span><span class="token string">"symbol"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>isGlobal<span class="token punctuation">:</span>            ident<span class="token punctuation">.</span><span class="token builtin">setattr</span><span class="token punctuation">(</span><span class="token string">'val'</span><span class="token punctuation">,</span> mv<span class="token punctuation">.</span>visitLoadIntLiteral<span class="token punctuation">(</span>ident<span class="token punctuation">.</span><span class="token builtin">getattr</span><span class="token punctuation">(</span><span class="token string">'symbol'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token comment">#! 否则</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            ident<span class="token punctuation">.</span><span class="token builtin">setattr</span><span class="token punctuation">(</span><span class="token string">'val'</span><span class="token punctuation">,</span> ident<span class="token punctuation">.</span><span class="token builtin">getattr</span><span class="token punctuation">(</span><span class="token string">'symbol'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>temp<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">visitAssignment</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> expr<span class="token punctuation">:</span> Assignment<span class="token punctuation">,</span> mv<span class="token punctuation">:</span> TACFuncEmitter<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>        expr<span class="token punctuation">.</span>rhs<span class="token punctuation">.</span>accept<span class="token punctuation">(</span>self<span class="token punctuation">,</span> mv<span class="token punctuation">)</span>        <span class="token comment">#! 左值是全局变量</span>        <span class="token keyword">if</span> expr<span class="token punctuation">.</span>lhs<span class="token punctuation">.</span><span class="token builtin">getattr</span><span class="token punctuation">(</span><span class="token string">'symbol'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>isGlobal<span class="token punctuation">:</span>            mv<span class="token punctuation">.</span>visitStoreIntLiteral<span class="token punctuation">(</span>expr<span class="token punctuation">.</span>lhs<span class="token punctuation">.</span><span class="token builtin">getattr</span><span class="token punctuation">(</span><span class="token string">'symbol'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> expr<span class="token punctuation">.</span>rhs<span class="token punctuation">.</span><span class="token builtin">getattr</span><span class="token punctuation">(</span><span class="token string">"val"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token comment">#! 否则</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            expr<span class="token punctuation">.</span>lhs<span class="token punctuation">.</span>accept<span class="token punctuation">(</span>self<span class="token punctuation">,</span> mv<span class="token punctuation">)</span>            expr<span class="token punctuation">.</span><span class="token builtin">setattr</span><span class="token punctuation">(</span>                <span class="token string">"val"</span><span class="token punctuation">,</span> mv<span class="token punctuation">.</span>visitAssignment<span class="token punctuation">(</span>expr<span class="token punctuation">.</span>lhs<span class="token punctuation">.</span><span class="token builtin">getattr</span><span class="token punctuation">(</span><span class="token string">"symbol"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>temp<span class="token punctuation">,</span> expr<span class="token punctuation">.</span>rhs<span class="token punctuation">.</span><span class="token builtin">getattr</span><span class="token punctuation">(</span><span class="token string">"val"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>目标代码生成</strong>: 在 <code>utils/riscv.py</code> 中参照已有实现, 添加<strong>全局变量</strong>地址获取、加载和存储的 RISC-V 指令:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># utils/riscv.py</span><span class="token keyword">class</span> <span class="token class-name">LoadAddress</span><span class="token punctuation">(</span>TACInstr<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment"># LOAD SYMBOL ADDRESS...</span><span class="token keyword">class</span> <span class="token class-name">LoadIntLiteral</span><span class="token punctuation">(</span>TACInstr<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># LOAD SYMBOL...</span><span class="token keyword">class</span> <span class="token class-name">StoreIntLiteral</span><span class="token punctuation">(</span>TACInstr<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># STORE SYMBOL...</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 <code>backend/riscv/riscvasmemitter.py</code> 中, <code>RiscvAsmEmitter</code> 对象初始化时打印全局变量至 <code>.data</code> 区, 并为 <code>RiscvInstrSelector</code> 实现相应全局变量指令访问方法:</p><h3 id="step-11"><a href="#step-11" class="headerlink" title="step 11"></a>step 11</h3><p><strong>词法语法分析</strong>: 修改 <code>frontend/ast/tree.py</code>, 通过 <code>Program</code> 的 <code>globalVars()</code> 方法返回<strong>全局变量</strong>与<strong>全局数组</strong>键值对; 修改 <code>Declaration</code> 节点定义, 添加数组维度声明 <code>init_dim</code>; 同时添加索引运算节点 <code>IndexExpr</code>:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># frontend/ast/tree.py</span><span class="token keyword">class</span> <span class="token class-name">IndexExpr</span><span class="token punctuation">(</span>Expression<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> base<span class="token punctuation">:</span> Expression<span class="token punctuation">,</span> index<span class="token punctuation">:</span> Expression<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>        <span class="token builtin">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token string">"index_expr"</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>base <span class="token operator">=</span> base        self<span class="token punctuation">.</span>index <span class="token operator">=</span> index<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 <code>frontend/parser/ply_parser.py</code> 中参考已有实现, 给出相关 <code>CFG</code> 文法.</p><p><strong>语义分析</strong>: 修改 <code>frontend/typecheck/namer.py</code>, <code>visitFunction</code> 中记录当前函数声明的<strong>局部数组</strong>; 在 <code>visitDeclaration</code> 中依据标识符类型进行初始化, 如果是数组则调用 <code>ArrayType.multidim</code>; 添加 <code>visitIndexExpr</code> 中递归实现数组索引访问.</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># frontend/typecheck/namer.py</span><span class="token keyword">def</span> <span class="token function">visitDeclaration</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> decl<span class="token punctuation">:</span> Declaration<span class="token punctuation">,</span> ctx<span class="token punctuation">:</span> ScopeStack<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token keyword">if</span> decl<span class="token punctuation">.</span>init_dim<span class="token punctuation">:</span>        decl_type <span class="token operator">=</span> ArrayType<span class="token punctuation">.</span>multidim<span class="token punctuation">(</span>decl<span class="token punctuation">.</span>var_t<span class="token punctuation">.</span><span class="token builtin">type</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">[</span>dim<span class="token punctuation">.</span>value <span class="token keyword">for</span> dim <span class="token keyword">in</span> decl<span class="token punctuation">.</span>init_dim<span class="token punctuation">]</span><span class="token punctuation">)</span>        symbol <span class="token operator">=</span> VarSymbol<span class="token punctuation">(</span>decl<span class="token punctuation">.</span>ident<span class="token punctuation">.</span>value<span class="token punctuation">,</span> decl_type<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>arrays<span class="token punctuation">.</span>append<span class="token punctuation">(</span>symbol<span class="token punctuation">)</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        decl_type <span class="token operator">=</span> decl<span class="token punctuation">.</span>var_t<span class="token punctuation">.</span><span class="token builtin">type</span>        symbol <span class="token operator">=</span> VarSymbol<span class="token punctuation">(</span>decl<span class="token punctuation">.</span>ident<span class="token punctuation">.</span>value<span class="token punctuation">,</span> decl_type<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">def</span> <span class="token function">visitIndexExpr</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> expr<span class="token punctuation">:</span> IndexExpr<span class="token punctuation">,</span> ctx<span class="token punctuation">:</span> ScopeStack<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>expr<span class="token punctuation">.</span>base<span class="token punctuation">,</span> Identifier<span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token keyword">not</span> ctx<span class="token punctuation">.</span>lookupOverStack<span class="token punctuation">(</span>expr<span class="token punctuation">.</span>base<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">raise</span> DecafUndefinedVarError<span class="token punctuation">(</span>expr<span class="token punctuation">.</span>base<span class="token punctuation">.</span>value<span class="token punctuation">)</span>    expr<span class="token punctuation">.</span>base<span class="token punctuation">.</span>accept<span class="token punctuation">(</span>self<span class="token punctuation">,</span> ctx<span class="token punctuation">)</span>    expr<span class="token punctuation">.</span>index<span class="token punctuation">.</span>accept<span class="token punctuation">(</span>self<span class="token punctuation">,</span> ctx<span class="token punctuation">)</span>    <span class="token comment">#! 根据 base 类型设置 expr 的类型</span>    <span class="token keyword">if</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>expr<span class="token punctuation">.</span>base<span class="token punctuation">,</span> Identifier<span class="token punctuation">)</span><span class="token punctuation">:</span>        expr<span class="token punctuation">.</span><span class="token builtin">setattr</span><span class="token punctuation">(</span><span class="token string">'type'</span><span class="token punctuation">,</span> expr<span class="token punctuation">.</span>base<span class="token punctuation">.</span><span class="token builtin">getattr</span><span class="token punctuation">(</span><span class="token string">'symbol'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">type</span><span class="token punctuation">.</span>indexed<span class="token punctuation">)</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        expr<span class="token punctuation">.</span><span class="token builtin">setattr</span><span class="token punctuation">(</span><span class="token string">'type'</span><span class="token punctuation">,</span> expr<span class="token punctuation">.</span>base<span class="token punctuation">.</span><span class="token builtin">getattr</span><span class="token punctuation">(</span><span class="token string">'type'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>indexed<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过对节点的 <code>setattr('type')</code> 与 <code>getattr('type')</code> 操作实现类型运算一致性检查, 一共有 <code>INT</code> 与 <code>ArrayType</code> 两种类型, 如果相应运算类型不一致, 则会抛出异常 <code>DecafBadReturnTypeError</code>.</p><p><strong>中间代码生成</strong>: 在 <code>utils/tac/tacgen.py</code> 中 <code>TACFuncEmitter</code> 类实现了依地址的读写数组元素的方法:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># frontend/tacgen/tacgen.py</span><span class="token keyword">class</span> <span class="token class-name">TACFuncEmitter</span><span class="token punctuation">(</span>TACVisitor<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">visitLoadByAddress</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> addr<span class="token punctuation">:</span> Temp<span class="token punctuation">)</span><span class="token punctuation">:</span>        dst <span class="token operator">=</span> self<span class="token punctuation">.</span>freshTemp<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>func<span class="token punctuation">.</span>add<span class="token punctuation">(</span>LoadIntLiteral<span class="token punctuation">(</span>dst<span class="token punctuation">,</span> addr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> dst    <span class="token keyword">def</span> <span class="token function">visitStoreByAddress</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> value<span class="token punctuation">:</span> Temp<span class="token punctuation">,</span> addr<span class="token punctuation">:</span> Temp<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>func<span class="token punctuation">.</span>add<span class="token punctuation">(</span>StoreIntLiteral<span class="token punctuation">(</span>value<span class="token punctuation">,</span> addr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>修改 <code>TACGen</code> 类的 <code>visitIndexExpr</code>, <code>visitAssignment</code> 及 <code>visitIdentifier</code> 方法, 设置数组索引表达式的地址, 并判断访问标识符和赋值操作是否对数组进行:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># utils/tac/tacgen.py</span><span class="token keyword">class</span> <span class="token class-name">TACGen</span><span class="token punctuation">(</span>Visitor<span class="token punctuation">[</span>TACFuncEmitter<span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">visitIdentifier</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> ident<span class="token punctuation">:</span> Identifier<span class="token punctuation">,</span> mv<span class="token punctuation">:</span> TACFuncEmitter<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>    <span class="token comment"># 数组类型 -&gt; 设置数组地址</span>        <span class="token keyword">if</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>ident<span class="token punctuation">.</span><span class="token builtin">getattr</span><span class="token punctuation">(</span><span class="token string">'symbol'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">type</span><span class="token punctuation">,</span> ArrayType<span class="token punctuation">)</span><span class="token punctuation">:</span>            ident<span class="token punctuation">.</span><span class="token builtin">setattr</span><span class="token punctuation">(</span><span class="token string">'addr'</span><span class="token punctuation">,</span> mv<span class="token punctuation">.</span>visitLoadAddress<span class="token punctuation">(</span>ident<span class="token punctuation">.</span><span class="token builtin">getattr</span><span class="token punctuation">(</span><span class="token string">'symbol'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">def</span> <span class="token function">visitIndexExpr</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> expr<span class="token punctuation">:</span> IndexExpr<span class="token punctuation">,</span> mv<span class="token punctuation">:</span> TACFuncEmitter<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>        expr<span class="token punctuation">.</span>base<span class="token punctuation">.</span><span class="token builtin">setattr</span><span class="token punctuation">(</span><span class="token string">'slice'</span><span class="token punctuation">,</span> <span class="token boolean">True</span><span class="token punctuation">)</span>        expr<span class="token punctuation">.</span>base<span class="token punctuation">.</span>accept<span class="token punctuation">(</span>self<span class="token punctuation">,</span> mv<span class="token punctuation">)</span>        expr<span class="token punctuation">.</span>index<span class="token punctuation">.</span>accept<span class="token punctuation">(</span>self<span class="token punctuation">,</span> mv<span class="token punctuation">)</span>        <span class="token comment">#! 递归计算当前索引的偏移量</span>        addr <span class="token operator">=</span> mv<span class="token punctuation">.</span>visitLoad<span class="token punctuation">(</span>expr<span class="token punctuation">.</span><span class="token builtin">getattr</span><span class="token punctuation">(</span><span class="token string">'type'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>size<span class="token punctuation">)</span>        mv<span class="token punctuation">.</span>visitBinarySelf<span class="token punctuation">(</span>tacop<span class="token punctuation">.</span>TacBinaryOp<span class="token punctuation">.</span>MUL<span class="token punctuation">,</span> addr<span class="token punctuation">,</span> expr<span class="token punctuation">.</span>index<span class="token punctuation">.</span><span class="token builtin">getattr</span><span class="token punctuation">(</span><span class="token string">'val'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        mv<span class="token punctuation">.</span>visitBinarySelf<span class="token punctuation">(</span>tacop<span class="token punctuation">.</span>TacBinaryOp<span class="token punctuation">.</span>ADD<span class="token punctuation">,</span> addr<span class="token punctuation">,</span> expr<span class="token punctuation">.</span>base<span class="token punctuation">.</span><span class="token builtin">getattr</span><span class="token punctuation">(</span><span class="token string">'addr'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        expr<span class="token punctuation">.</span><span class="token builtin">setattr</span><span class="token punctuation">(</span><span class="token string">'addr'</span><span class="token punctuation">,</span> addr<span class="token punctuation">)</span>        <span class="token comment">#! 递归完毕, 通过地址获得数组元素值</span>        <span class="token comment">#! `slice` 属性表示为数组切片, 无需获取数据</span>        <span class="token comment">#! 保证递归结束只有完整的索引表达式设置了返回值</span>        <span class="token keyword">if</span> <span class="token keyword">not</span> expr<span class="token punctuation">.</span><span class="token builtin">getattr</span><span class="token punctuation">(</span><span class="token string">'slice'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            expr<span class="token punctuation">.</span><span class="token builtin">setattr</span><span class="token punctuation">(</span><span class="token string">'val'</span><span class="token punctuation">,</span> mv<span class="token punctuation">.</span>visitLoadByAddress<span class="token punctuation">(</span>addr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">visitAssignment</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> expr<span class="token punctuation">:</span> Assignment<span class="token punctuation">,</span> mv<span class="token punctuation">:</span> TACFuncEmitter<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>        <span class="token comment"># 索引类型 -&gt; 访问数组地址</span>        <span class="token keyword">if</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>expr<span class="token punctuation">.</span>lhs<span class="token punctuation">,</span> IndexExpr<span class="token punctuation">)</span><span class="token punctuation">:</span>            expr<span class="token punctuation">.</span>lhs<span class="token punctuation">.</span><span class="token builtin">setattr</span><span class="token punctuation">(</span><span class="token string">'slice'</span><span class="token punctuation">,</span> <span class="token boolean">True</span><span class="token punctuation">)</span>            expr<span class="token punctuation">.</span>lhs<span class="token punctuation">.</span>accept<span class="token punctuation">(</span>self<span class="token punctuation">,</span> mv<span class="token punctuation">)</span>            mv<span class="token punctuation">.</span>visitStoreByAddress<span class="token punctuation">(</span>expr<span class="token punctuation">.</span>rhs<span class="token punctuation">.</span><span class="token builtin">getattr</span><span class="token punctuation">(</span><span class="token string">'val'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> expr<span class="token punctuation">.</span>lhs<span class="token punctuation">.</span><span class="token builtin">getattr</span><span class="token punctuation">(</span><span class="token string">'addr'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            expr<span class="token punctuation">.</span><span class="token builtin">setattr</span><span class="token punctuation">(</span><span class="token string">'val'</span><span class="token punctuation">,</span> expr<span class="token punctuation">.</span>rhs<span class="token punctuation">.</span><span class="token builtin">getattr</span><span class="token punctuation">(</span><span class="token string">"val"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>目标代码生成</strong>: 在 <code>utils/riscv.py</code> 中实现了 <code>addi</code> 的 RISC-V 指令, 用于加载通过 <code>TACFunc.arrays</code> 传递并保存在栈的<strong>局部数组</strong> (仍通过 <code>Program.globalVars</code> 加载<strong>全局数组</strong>地址):</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># utils/riscv.py</span><span class="token keyword">class</span> <span class="token class-name">ImmAdd</span><span class="token punctuation">(</span>TACInstr<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> dst<span class="token punctuation">:</span> Temp<span class="token punctuation">,</span> src<span class="token punctuation">:</span> Temp<span class="token punctuation">,</span> value<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token builtin">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span>InstrKind<span class="token punctuation">.</span>SEQ<span class="token punctuation">,</span> <span class="token punctuation">[</span>dst<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>src<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>value <span class="token operator">=</span> value    <span class="token keyword">def</span> <span class="token function">__str__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">str</span><span class="token punctuation">:</span>        <span class="token keyword">assert</span> <span class="token operator">-</span><span class="token number">2048</span> <span class="token operator">&lt;=</span> self<span class="token punctuation">.</span>value <span class="token operator">&lt;=</span> <span class="token number">2047</span>  <span class="token comment"># Riscv imm [11:0]</span>        <span class="token keyword">return</span> <span class="token string">"addi "</span> <span class="token operator">+</span> Riscv<span class="token punctuation">.</span>FMT3<span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>            <span class="token builtin">str</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>dsts<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token builtin">str</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>srcs<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token builtin">str</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>value<span class="token punctuation">)</span>        <span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>进入一个函数前, 提前将其中的<strong>局部数组压栈</strong>, 在 <code>backend/subroutineinfo.py</code> 中计算得到各数组偏移量及占用栈帧大小:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># backend/subroutineinfo.py</span><span class="token keyword">class</span> <span class="token class-name">SubroutineInfo</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> funcLabel<span class="token punctuation">:</span> FuncLabel<span class="token punctuation">,</span> numArgs<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">,</span> arrays<span class="token punctuation">:</span> Dict<span class="token punctuation">[</span><span class="token builtin">str</span><span class="token punctuation">,</span> VarSymbol<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>offsets<span class="token punctuation">:</span> Dict<span class="token punctuation">[</span><span class="token builtin">str</span><span class="token punctuation">,</span> <span class="token builtin">int</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>        self<span class="token punctuation">.</span>size <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> name<span class="token punctuation">,</span> symbol <span class="token keyword">in</span> self<span class="token punctuation">.</span>arrays<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>offsets<span class="token punctuation">[</span>name<span class="token punctuation">]</span> <span class="token operator">=</span> self<span class="token punctuation">.</span>size            self<span class="token punctuation">.</span>size <span class="token operator">+=</span> symbol<span class="token punctuation">.</span><span class="token builtin">type</span><span class="token punctuation">.</span>size<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 <code>backend/riscv/riscvasmemitter.py</code> 中, <code>RiscvAsmEmitter</code> 对象初始化时打印<strong>全局数组</strong>至 <code>.bss</code> 区, <code>RiscvInstrSelector</code> 中通过偏移量实现<strong>局部数组</strong>访问:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># backend/riscv/riscvasmemitter.py</span><span class="token keyword">class</span> <span class="token class-name">RiscvAsmEmitter</span><span class="token punctuation">(</span>AsmEmitter<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token keyword">class</span> <span class="token class-name">RiscvInstrSelector</span><span class="token punctuation">(</span>TACVisitor<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">visitLoadAddress</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> instr<span class="token punctuation">:</span> LoadAddress<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> instr<span class="token punctuation">.</span>symbol<span class="token punctuation">.</span>isGlobal<span class="token punctuation">:</span>                <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                self<span class="token punctuation">.</span>seq<span class="token punctuation">.</span>append<span class="token punctuation">(</span>Riscv<span class="token punctuation">.</span>ImmAdd<span class="token punctuation">(</span>instr<span class="token punctuation">.</span>dsts<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> Riscv<span class="token punctuation">.</span>SP<span class="token punctuation">,</span> self<span class="token punctuation">.</span>info<span class="token punctuation">.</span>offsets<span class="token punctuation">[</span>instr<span class="token punctuation">.</span>symbol<span class="token punctuation">.</span>name<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此时的 <code>self.nextLocalOffset</code> 及保存 <code>RA</code>, <code>FP</code> 和 <code>Callee-saved</code> 寄存器时需要额外加上 <code>self.info.size</code> 由<strong>局部数组</strong>占用的栈帧大小.</p><h3 id="step-12"><a href="#step-12" class="headerlink" title="step 12"></a>step 12</h3><p><strong>代码流读入</strong>: 在 <code>main.py</code> 中给出 <code>memset</code> 函数 <code>fill_csx</code> 的<strong>字符串表示</strong>, 命名方式是为了防止可能的函数重名 (虽然根据给出的测例, 没有名为 <code>fill_csx</code> 的函数, 但更好的方法是在语法分析后动态命名). 随后直接将代码加入输入的 <code>code</code> 前:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># main.py</span>memsetFunc <span class="token operator">=</span> <span class="token triple-quoted-string string">r"""int fill_csx(int array[], int cnt) {    for (int i = 0; i &lt; cnt; i = i + 1) {        array[i] = 0;    }    return 0;}"""</span><span class="token keyword">def</span> <span class="token function">step_parse</span><span class="token punctuation">(</span>args<span class="token punctuation">:</span> argparse<span class="token punctuation">.</span>Namespace<span class="token punctuation">)</span><span class="token punctuation">:</span>    code <span class="token operator">=</span> memsetFunc <span class="token operator">+</span> <span class="token string">"\n"</span> <span class="token operator">+</span> readCode<span class="token punctuation">(</span>args<span class="token punctuation">.</span><span class="token builtin">input</span><span class="token punctuation">)</span>    r<span class="token punctuation">:</span> Program <span class="token operator">=</span> parser<span class="token punctuation">.</span>parse<span class="token punctuation">(</span>code<span class="token punctuation">,</span> lexer<span class="token operator">=</span>lexer<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>词法语法分析</strong>: 修改 <code>frontend/ast/tree.py</code>, 修改 <code>Parameter</code> 节点定义, 添加维度声明 <code>init_dim</code> 标识<strong>数组传参</strong>; 同时添加<strong>数组初始化列表</strong>节点 <code>InitList</code>.</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># frontend/ast/tree.py</span><span class="token keyword">class</span> <span class="token class-name">InitList</span><span class="token punctuation">(</span>Node<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> init_list<span class="token punctuation">:</span> List<span class="token punctuation">[</span>IntLiteral<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token builtin">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token string">"init_list"</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>init_list <span class="token operator">=</span> init_list        self<span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token punctuation">[</span>item<span class="token punctuation">.</span>value <span class="token keyword">for</span> item <span class="token keyword">in</span> init_list<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 <code>frontend/parser/ply_parser.py</code> 中参考已有实现, 给出相关 <code>CFG</code> 文法.</p><p><strong>语义分析</strong>: 修改 <code>frontend/typecheck/namer.py</code>, 在 <code>visitFunction</code> 中记录函数声明中进行传参的<strong>参数数组</strong>; 在 <code>visitParameter</code> 中依据参数类型进行标识符 <code>symbol</code> 生成, 如果是数组则调用 <code>ArrayType.multidim</code> 生成相应的数据类型.</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># frontend/typecheck/namer.py</span><span class="token keyword">def</span> <span class="token function">visitParameter</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> param<span class="token punctuation">:</span> Parameter<span class="token punctuation">,</span> ctx<span class="token punctuation">:</span> ScopeStack<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">#! 为数组参数, 检查并生成相应的数据类型</span>  <span class="token keyword">if</span> param<span class="token punctuation">.</span>init_dim<span class="token punctuation">:</span>        <span class="token keyword">for</span> index<span class="token punctuation">,</span> dim <span class="token keyword">in</span> <span class="token builtin">enumerate</span><span class="token punctuation">(</span>param<span class="token punctuation">.</span>init_dim<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> index <span class="token operator">==</span> <span class="token number">0</span> <span class="token keyword">and</span> dim <span class="token keyword">is</span> NULL<span class="token punctuation">:</span>                <span class="token keyword">continue</span>            <span class="token keyword">if</span> dim<span class="token punctuation">.</span>value <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">:</span>                <span class="token keyword">raise</span> DecafBadArraySizeError<span class="token punctuation">(</span><span class="token punctuation">)</span>        decl_type <span class="token operator">=</span> ArrayType<span class="token punctuation">.</span>multidim<span class="token punctuation">(</span>param<span class="token punctuation">.</span>var_t<span class="token punctuation">.</span><span class="token builtin">type</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">[</span>dim<span class="token punctuation">.</span>value <span class="token keyword">if</span> dim <span class="token keyword">else</span> <span class="token boolean">None</span> <span class="token keyword">for</span> dim <span class="token keyword">in</span> param<span class="token punctuation">.</span>init_dim<span class="token punctuation">]</span><span class="token punctuation">)</span>        symbol <span class="token operator">=</span> VarSymbol<span class="token punctuation">(</span>param<span class="token punctuation">.</span>ident<span class="token punctuation">.</span>value<span class="token punctuation">,</span> decl_type<span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>中间代码生成</strong>: 在 <code>utils/tac/tacgen.py</code> 中修改 <code>TACGen</code> 类的 <code>visitIdentifier</code> 方法, 对<strong>全局数组与局部数组</strong>直接加载数组地址, 对<strong>参数数组</strong>加载相应虚拟寄存器; 修改 <code>visitDeclaration</code> 方法, 若为<strong>带初始化列表</strong>的<strong>局部数组</strong>声明, 先调用 <code>fill_csx</code> 函数进行内存清零, 然后逐一进行元素初始化:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># utils/tac/tacgen.py</span><span class="token keyword">class</span> <span class="token class-name">TACGen</span><span class="token punctuation">(</span>Visitor<span class="token punctuation">[</span>TACFuncEmitter<span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">visitIdentifier</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> ident<span class="token punctuation">:</span> Identifier<span class="token punctuation">,</span> mv<span class="token punctuation">:</span> TACFuncEmitter<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>ident<span class="token punctuation">.</span><span class="token builtin">getattr</span><span class="token punctuation">(</span><span class="token string">'symbol'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">type</span><span class="token punctuation">,</span> ArrayType<span class="token punctuation">)</span><span class="token punctuation">:</span>          <span class="token comment"># 全局数组与局部数组</span>            <span class="token keyword">if</span> ident<span class="token punctuation">.</span><span class="token builtin">getattr</span><span class="token punctuation">(</span><span class="token string">"symbol"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>isGlobal <span class="token keyword">or</span> ident<span class="token punctuation">.</span><span class="token builtin">getattr</span><span class="token punctuation">(</span><span class="token string">'symbol'</span><span class="token punctuation">)</span> <span class="token keyword">not</span> <span class="token keyword">in</span> mv<span class="token punctuation">.</span>func<span class="token punctuation">.</span>p_arrays<span class="token punctuation">.</span>values<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                ident<span class="token punctuation">.</span><span class="token builtin">setattr</span><span class="token punctuation">(</span><span class="token string">'addr'</span><span class="token punctuation">,</span> mv<span class="token punctuation">.</span>visitLoadAddress<span class="token punctuation">(</span>ident<span class="token punctuation">.</span><span class="token builtin">getattr</span><span class="token punctuation">(</span><span class="token string">'symbol'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                ident<span class="token punctuation">.</span><span class="token builtin">setattr</span><span class="token punctuation">(</span><span class="token string">'val'</span><span class="token punctuation">,</span> ident<span class="token punctuation">.</span><span class="token builtin">getattr</span><span class="token punctuation">(</span><span class="token string">'addr'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token comment"># 参数数组</span>          <span class="token keyword">else</span><span class="token punctuation">:</span>                ident<span class="token punctuation">.</span><span class="token builtin">setattr</span><span class="token punctuation">(</span><span class="token string">'addr'</span><span class="token punctuation">,</span> ident<span class="token punctuation">.</span><span class="token builtin">getattr</span><span class="token punctuation">(</span><span class="token string">'symbol'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>temp<span class="token punctuation">)</span>                ident<span class="token punctuation">.</span><span class="token builtin">setattr</span><span class="token punctuation">(</span><span class="token string">'val'</span><span class="token punctuation">,</span> ident<span class="token punctuation">.</span><span class="token builtin">getattr</span><span class="token punctuation">(</span><span class="token string">'addr'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">visitDeclaration</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> decl<span class="token punctuation">:</span> Declaration<span class="token punctuation">,</span> mv<span class="token punctuation">:</span> TACFuncEmitter<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>decl<span class="token punctuation">.</span>init_expr<span class="token punctuation">,</span> InitList<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment">#! 调用 `fill_csx` 函数进行初始化</span>            symbol <span class="token operator">=</span> decl<span class="token punctuation">.</span><span class="token builtin">getattr</span><span class="token punctuation">(</span><span class="token string">"symbol"</span><span class="token punctuation">)</span>            addr <span class="token operator">=</span> mv<span class="token punctuation">.</span>visitLoadAddress<span class="token punctuation">(</span>symbol<span class="token punctuation">)</span>            <span class="token comment">#! size 为 4 -&gt; int 字长</span>            size <span class="token operator">=</span> symbol<span class="token punctuation">.</span><span class="token builtin">type</span><span class="token punctuation">.</span>full_indexed<span class="token punctuation">.</span>size            interval <span class="token operator">=</span> mv<span class="token punctuation">.</span>visitLoad<span class="token punctuation">(</span>size<span class="token punctuation">)</span>            mv<span class="token punctuation">.</span>visitParam<span class="token punctuation">(</span>addr<span class="token punctuation">)</span>            mv<span class="token punctuation">.</span>visitParam<span class="token punctuation">(</span>mv<span class="token punctuation">.</span>visitLoad<span class="token punctuation">(</span>symbol<span class="token punctuation">.</span><span class="token builtin">type</span><span class="token punctuation">.</span>size <span class="token operator">//</span> size<span class="token punctuation">)</span><span class="token punctuation">)</span>            mv<span class="token punctuation">.</span>visitCall<span class="token punctuation">(</span>FuncLabel<span class="token punctuation">(</span><span class="token string">"fill_csx"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token comment">#! 依次将初始化列表中的值存入数组中</span>            <span class="token keyword">for</span> value <span class="token keyword">in</span> decl<span class="token punctuation">.</span>init_expr<span class="token punctuation">.</span>value<span class="token punctuation">:</span>                mv<span class="token punctuation">.</span>visitStoreByAddress<span class="token punctuation">(</span>mv<span class="token punctuation">.</span>visitLoad<span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">,</span> addr<span class="token punctuation">)</span>                mv<span class="token punctuation">.</span>visitBinarySelf<span class="token punctuation">(</span>tacop<span class="token punctuation">.</span>TacBinaryOp<span class="token punctuation">.</span>ADD<span class="token punctuation">,</span> addr<span class="token punctuation">,</span> interval<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>目标代码生成</strong>: 在 <code>backend/riscv/riscvasmemitter.py</code> 中, <code>RiscvAsmEmitter</code> 对象初始化时打印<strong>带初始化列表</strong>的<strong>全局数组</strong>至 <code>.data</code> 区.</p><p>由于传参和调用分离, 对于<strong>参数数组</strong>的使用与<strong>普通函数参数</strong>并无区别, 这一步沿用 <strong>step 9</strong> 的实现即可, 后端无需进行其他工作.</p><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><h3 id="step-10-1"><a href="#step-10-1" class="headerlink" title="step 10"></a>step 10</h3><ol><li><p>写出 <code>la v0, a</code> 这一 RiscV 伪指令可能会被转换成的指令组合 (两种即可).</p><p> <strong>答:</strong> 查阅 <a href="https://cloud.tsinghua.edu.cn/f/396ace39c8d24411a28f/">The RISC-V Instruction Set Manual</a>.</p><ul><li><p>non-PIC 可能转换为:</p>  <pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">auipc v0, delta[31:12] + delta[11]addi v0, v0, delta[11:0]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>  其中 <code>delta</code> 为 <code>a</code> 相对 <code>PC</code> 的偏移量, 因为地址在编译时已知, 所以使用 <code>addi</code> 加载.</p></li><li><p>PIC 可能转换为:</p>  <pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">auipc v0, delta[31:12] + delta[11]lw v0, v0, delta[11:0]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>  其中 <code>delta</code> 为 <code>a</code> 在 GOT 中的地址相对 <code>PC</code> 的偏移量, 因为 GOT 中的地址可能在运行时进行重定位, 因此需要使用 <code>lw</code> 从内存中加载地址.</p></li><li><p>两种指令组合都存在 <code>+ delta[11]</code>, 这保证了在 <code>delta[11] = 1</code> 时, 低 12 位经过符号扩展, 最终也能够得到正确的结果.</p></li></ul></li></ol><h3 id="step-11-1"><a href="#step-11-1" class="headerlink" title="step 11"></a>step 11</h3><ol><li><p>C 语言规范规定, 允许局部变量是可变长度的数组 (VLA), 在我们的实验中为了简化, 选择不支持它. 请简要回答, 如果支持一维的可变长度的数组 (类似 <code>int n = 5; int a[n];</code>, 但不允许类似 <code>int n = ...; int m = ...; int a[n][m];</code>), 而且要求数组仍保存在栈上 (不允许用堆上动态内存申请), 应该在现有的实现基础上做出那些改动?</p><blockquote><p>提示: 不能再在进入函数时统一给局部变量分配内存, 离开时统一释放内存.</p></blockquote><p> <strong>答:</strong> 不能在进入函数时为 VLA 分配内存. 由于 VLA 的大小在编译期确定, 运行到声明 VLA 时, 将当前 <code>SP</code> 和 VLA 大小 <code>size</code> 保存到栈上 <code>-size(SP)</code> 处, 并移动 <code>SP</code>, 此时先前存储好的 <code>SP</code> 和 <code>size</code> 恰位于栈顶; 访问 VLA 的元素时, 计算偏移量 VLA 元素地址; 当 VLA 离开作用域时, 恢复 SP 即可.</p></li></ol><h3 id="step-12-1"><a href="#step-12-1" class="headerlink" title="step 12"></a>step 12</h3><ol><li><p>作为函数参数的数组类型第一维可以为空. 事实上, 在 C/C++ 中即使标明了第一维的大小, 类型检查依然会当作第一维是空的情况处理. 如何理解这一设计?</p><p> <strong>答:</strong> C/C++ 数组传参时, 数组名对应首元素地址; 函数无需为数组分配内存, 只需要通过首地址和偏移量即可访问到任意数组元素, 根据数组索引计算偏移量不会用到第一维的大小, 因此编译器会将数组参数的第一维视为空.</p></li></ol>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;Stage-6-报告&quot;&gt;&lt;a href=&quot;#Stage-6-报告&quot; class=&quot;headerlink&quot; title=&quot;Stage 6 报告&quot;&gt;&lt;/a&gt;Stage 6 报告&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;写在前面:&lt;/em&gt;&lt;br&gt;   </summary>
        
      
    
    
    
    <category term="CS" scheme="http://chengsx21.github.io/categories/CS/"/>
    
    <category term="Compiler" scheme="http://chengsx21.github.io/categories/CS/Compiler/"/>
    
    
    <category term="Principles of Compiler" scheme="http://chengsx21.github.io/tags/Principles-of-Compiler/"/>
    
  </entry>
  
  <entry>
    <title>编译原理 实验5</title>
    <link href="http://chengsx21.github.io/2023/12/13/bian-yi-yuan-li-lab-5/"/>
    <id>http://chengsx21.github.io/2023/12/13/bian-yi-yuan-li-lab-5/</id>
    <published>2023-12-13T09:18:57.000Z</published>
    <updated>2024-08-02T07:46:21.393Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Stage-5-报告"><a href="#Stage-5-报告" class="headerlink" title="Stage 5 报告"></a>Stage 5 报告</h1><h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><h3 id="step-9"><a href="#step-9" class="headerlink" title="step 9"></a>step 9</h3><p><strong>词法语法分析</strong>: 修改 <code>frontend/ast/tree.py</code>, 定义 <code>Call</code>, <code>Parameter</code>, <code>ParameterList</code>, <code>ExpressionList</code> 节点, 在 <code>frontend/parser/ply_parser.py</code> 中参考已有实现, 给出相关 <code>CFG</code> 文法.</p><p><strong>语义分析</strong>: 修改 <code>frontend/typecheck/namer.py</code>, 完成语义分析. <code>visitFunction</code> 中首先需要检查函数是否重复声明, 同时为了将函数参数与函数体置于同一个作用域, 需要修改 <code>func.body.accept</code>, 避免访问 <code>block</code> 而新开一个作用域:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># frontend/typecheck/namer.py</span><span class="token keyword">def</span> <span class="token function">visitFunction</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> func<span class="token punctuation">:</span> Function<span class="token punctuation">,</span> ctx<span class="token punctuation">:</span> ScopeStack<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> GlobalScope<span class="token punctuation">.</span>lookup<span class="token punctuation">(</span>func<span class="token punctuation">.</span>ident<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">raise</span> DecafDeclConflictError<span class="token punctuation">(</span>func<span class="token punctuation">.</span>ident<span class="token punctuation">.</span>value<span class="token punctuation">)</span>    symbol <span class="token operator">=</span> FuncSymbol<span class="token punctuation">(</span>func<span class="token punctuation">.</span>ident<span class="token punctuation">.</span>value<span class="token punctuation">,</span> func<span class="token punctuation">.</span>ret_t<span class="token punctuation">.</span><span class="token builtin">type</span><span class="token punctuation">,</span> GlobalScope<span class="token punctuation">)</span>    <span class="token keyword">for</span> param <span class="token keyword">in</span> func<span class="token punctuation">.</span>params<span class="token punctuation">.</span>children<span class="token punctuation">:</span>        symbol<span class="token punctuation">.</span>addParaType<span class="token punctuation">(</span>param<span class="token punctuation">.</span>var_t<span class="token punctuation">)</span>    GlobalScope<span class="token punctuation">.</span>declare<span class="token punctuation">(</span>symbol<span class="token punctuation">)</span>    func<span class="token punctuation">.</span><span class="token builtin">setattr</span><span class="token punctuation">(</span><span class="token string">'symbol'</span><span class="token punctuation">,</span> symbol<span class="token punctuation">)</span>    ctx<span class="token punctuation">.</span><span class="token builtin">open</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    func<span class="token punctuation">.</span>params<span class="token punctuation">.</span>accept<span class="token punctuation">(</span>self<span class="token punctuation">,</span> ctx<span class="token punctuation">)</span>    <span class="token keyword">for</span> child <span class="token keyword">in</span> func<span class="token punctuation">.</span>body<span class="token punctuation">.</span>children<span class="token punctuation">:</span>        child<span class="token punctuation">.</span>accept<span class="token punctuation">(</span>self<span class="token punctuation">,</span> ctx<span class="token punctuation">)</span>    ctx<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>visitCall</code> 中首先需要检查函数名是否被同级作用域声明的变量覆盖, 然后检查调用参数是否符合数目:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># frontend/typecheck/namer.py</span><span class="token keyword">def</span> <span class="token function">visitCall</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> call<span class="token punctuation">:</span> Call<span class="token punctuation">,</span> ctx<span class="token punctuation">:</span> ScopeStack<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> ctx<span class="token punctuation">.</span>lookup<span class="token punctuation">(</span>call<span class="token punctuation">.</span>ident<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">:</span>      <span class="token keyword">raise</span> DecafBadFuncCallError<span class="token punctuation">(</span>call<span class="token punctuation">.</span>ident<span class="token punctuation">.</span>value<span class="token punctuation">)</span>    func <span class="token operator">=</span> GlobalScope<span class="token punctuation">.</span>lookup<span class="token punctuation">(</span>call<span class="token punctuation">.</span>ident<span class="token punctuation">.</span>value<span class="token punctuation">)</span>    <span class="token keyword">if</span> <span class="token keyword">not</span> func <span class="token keyword">or</span> <span class="token keyword">not</span> func<span class="token punctuation">.</span>isFunc<span class="token punctuation">:</span>        <span class="token keyword">raise</span> DecafUndefinedFuncError<span class="token punctuation">(</span>call<span class="token punctuation">.</span>ident<span class="token punctuation">.</span>value<span class="token punctuation">)</span>    <span class="token keyword">if</span> func<span class="token punctuation">.</span>parameterNum <span class="token operator">!=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>call<span class="token punctuation">.</span>args<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">raise</span> DecafBadFuncCallError<span class="token punctuation">(</span><span class="token punctuation">)</span>    call<span class="token punctuation">.</span>ident<span class="token punctuation">.</span><span class="token builtin">setattr</span><span class="token punctuation">(</span><span class="token string">'symbol'</span><span class="token punctuation">,</span> func<span class="token punctuation">)</span>    <span class="token keyword">for</span> arg <span class="token keyword">in</span> call<span class="token punctuation">.</span>args<span class="token punctuation">:</span>        arg<span class="token punctuation">.</span>accept<span class="token punctuation">(</span>self<span class="token punctuation">,</span> ctx<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>中间代码生成</strong>: 使用传参和调用分离模式, 在 <code>utils/tac/tacop.py</code> 中添加两类指令类型定义:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># utils/tac/tacop.py</span><span class="token decorator annotation punctuation">@unique</span><span class="token keyword">class</span> <span class="token class-name">InstrKind</span><span class="token punctuation">(</span>Enum<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># Function call.</span>    CALL <span class="token operator">=</span> auto<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment"># Function parameter.</span>    PARAM <span class="token operator">=</span> auto<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 <code>utils/tac/tacinstr.py</code> 中参照已有实现定义了 <code>Call</code> 与 <code>Param</code> 两种 TAC 指令类, 在 <code>utils/tac/tacgen.py</code> 中实现与之有关的 <code>Visitor</code> 模式方法:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># utils/tac/tacgen.py</span><span class="token keyword">class</span> <span class="token class-name">TACFuncEmitter</span><span class="token punctuation">(</span>TACVisitor<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token keyword">def</span> <span class="token function">visitParam</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> value<span class="token punctuation">:</span> Temp<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>func<span class="token punctuation">.</span>add<span class="token punctuation">(</span>Param<span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">visitCall</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> label<span class="token punctuation">:</span> Label<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> Temp<span class="token punctuation">:</span>        temp <span class="token operator">=</span> self<span class="token punctuation">.</span>freshTemp<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>func<span class="token punctuation">.</span>add<span class="token punctuation">(</span>Call<span class="token punctuation">(</span>temp<span class="token punctuation">,</span> label<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> temp<span class="token keyword">class</span> <span class="token class-name">TACGen</span><span class="token punctuation">(</span>Visitor<span class="token punctuation">[</span>TACFuncEmitter<span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">visitParameter</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> param<span class="token punctuation">:</span> Parameter<span class="token punctuation">,</span> mv<span class="token punctuation">:</span> TACFuncEmitter<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>      <span class="token comment"># 分配虚拟寄存器</span>        param<span class="token punctuation">.</span><span class="token builtin">getattr</span><span class="token punctuation">(</span><span class="token string">'symbol'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>temp <span class="token operator">=</span> mv<span class="token punctuation">.</span>freshTemp<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">visitCall</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> call<span class="token punctuation">:</span> Call<span class="token punctuation">,</span> mv<span class="token punctuation">:</span> TACFuncEmitter<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>        <span class="token keyword">for</span> arg <span class="token keyword">in</span> call<span class="token punctuation">.</span>args<span class="token punctuation">.</span>children<span class="token punctuation">:</span>            arg<span class="token punctuation">.</span>accept<span class="token punctuation">(</span>self<span class="token punctuation">,</span> mv<span class="token punctuation">)</span>        <span class="token keyword">for</span> arg <span class="token keyword">in</span> call<span class="token punctuation">.</span>args<span class="token punctuation">.</span>children<span class="token punctuation">:</span>            mv<span class="token punctuation">.</span>visitParam<span class="token punctuation">(</span>arg<span class="token punctuation">.</span><span class="token builtin">getattr</span><span class="token punctuation">(</span><span class="token string">"val"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        call<span class="token punctuation">.</span><span class="token builtin">setattr</span><span class="token punctuation">(</span><span class="token string">'val'</span><span class="token punctuation">,</span> mv<span class="token punctuation">.</span>visitCall<span class="token punctuation">(</span>FuncLabel<span class="token punctuation">(</span>call<span class="token punctuation">.</span>ident<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>目标代码生成</strong>: 在 <code>utils/riscv.py</code> 中定义了 <code>Call</code> 与 <code>Param</code> 类指令用于寄存器分配的标识, 同时仿照 <code>SPAdd</code> 指令实现了 <code>FPAdd</code> 指令用于保存和恢复栈帧.</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># utils/riscv.py</span><span class="token keyword">class</span> <span class="token class-name">Call</span><span class="token punctuation">(</span>TACInstr<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> target<span class="token punctuation">:</span> Label<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>        <span class="token builtin">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span>InstrKind<span class="token punctuation">.</span>CALL<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> target<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>target <span class="token operator">=</span> target    <span class="token keyword">def</span> <span class="token function">__str__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">str</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token string">"call "</span> <span class="token operator">+</span> <span class="token builtin">super</span><span class="token punctuation">(</span>FuncLabel<span class="token punctuation">,</span> self<span class="token punctuation">.</span>target<span class="token punctuation">)</span><span class="token punctuation">.</span>__str__<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">Param</span><span class="token punctuation">(</span>TACInstr<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> src<span class="token punctuation">:</span> Temp<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>        <span class="token builtin">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span>InstrKind<span class="token punctuation">.</span>PARAM<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>src<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>backend/subroutineemitter.py</code> 实现了 <code>emitReg</code>,  <code>emitStoreParamToStack</code>, <code>emitRestoreStackPointer</code> 等方法用于保存参数到寄存器, 保存参数到栈中以及恢复栈指针.</p><p>在 <code>backend/riscv/riscvasmemitter.py</code> 中修改 <code>emitEnd</code> 打印 Riscv 指令的逻辑, 进入函数时将 <code>fp</code>, <code>ra</code> 寄存器存储到栈上, 保存 <code>callee_saved</code> 寄存器; 函数结束时, 从栈上恢复 <code>fp</code>, <code>ra</code> 寄存器和 <code>callee_saved</code> 寄存器:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># backend/riscv/riscvasmemitter.py</span><span class="token keyword">def</span> <span class="token function">emitEnd</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment"># store RA, FP and CalleeSaved regs here</span>    self<span class="token punctuation">.</span>printer<span class="token punctuation">.</span>printInstr<span class="token punctuation">(</span>Riscv<span class="token punctuation">.</span>SPAdd<span class="token punctuation">(</span><span class="token operator">-</span>self<span class="token punctuation">.</span>nextLocalOffset<span class="token punctuation">)</span><span class="token punctuation">)</span>    self<span class="token punctuation">.</span>printer<span class="token punctuation">.</span>printInstr<span class="token punctuation">(</span>Riscv<span class="token punctuation">.</span>NativeStoreWord<span class="token punctuation">(</span>Riscv<span class="token punctuation">.</span>RA<span class="token punctuation">,</span> Riscv<span class="token punctuation">.</span>SP<span class="token punctuation">,</span> <span class="token number">4</span> <span class="token operator">*</span> <span class="token builtin">len</span><span class="token punctuation">(</span>Riscv<span class="token punctuation">.</span>CalleeSaved<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    self<span class="token punctuation">.</span>printer<span class="token punctuation">.</span>printInstr<span class="token punctuation">(</span>Riscv<span class="token punctuation">.</span>NativeStoreWord<span class="token punctuation">(</span>Riscv<span class="token punctuation">.</span>FP<span class="token punctuation">,</span> Riscv<span class="token punctuation">.</span>SP<span class="token punctuation">,</span> <span class="token number">4</span> <span class="token operator">*</span> <span class="token builtin">len</span><span class="token punctuation">(</span>Riscv<span class="token punctuation">.</span>CalleeSaved<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    self<span class="token punctuation">.</span>printer<span class="token punctuation">.</span>printInstr<span class="token punctuation">(</span>Riscv<span class="token punctuation">.</span>FPAdd<span class="token punctuation">(</span>self<span class="token punctuation">.</span>nextLocalOffset<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment"># load RA, FP and CalleeSaved regs here</span>    self<span class="token punctuation">.</span>printer<span class="token punctuation">.</span>printInstr<span class="token punctuation">(</span>Riscv<span class="token punctuation">.</span>NativeLoadWord<span class="token punctuation">(</span>Riscv<span class="token punctuation">.</span>RA<span class="token punctuation">,</span> Riscv<span class="token punctuation">.</span>SP<span class="token punctuation">,</span> <span class="token number">4</span> <span class="token operator">*</span> <span class="token builtin">len</span><span class="token punctuation">(</span>Riscv<span class="token punctuation">.</span>CalleeSaved<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    self<span class="token punctuation">.</span>printer<span class="token punctuation">.</span>printInstr<span class="token punctuation">(</span>Riscv<span class="token punctuation">.</span>NativeLoadWord<span class="token punctuation">(</span>Riscv<span class="token punctuation">.</span>FP<span class="token punctuation">,</span> Riscv<span class="token punctuation">.</span>SP<span class="token punctuation">,</span> <span class="token number">4</span> <span class="token operator">*</span> <span class="token builtin">len</span><span class="token punctuation">(</span>Riscv<span class="token punctuation">.</span>CalleeSaved<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    self<span class="token punctuation">.</span>printer<span class="token punctuation">.</span>printInstr<span class="token punctuation">(</span>Riscv<span class="token punctuation">.</span>SPAdd<span class="token punctuation">(</span>self<span class="token punctuation">.</span>nextLocalOffset<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 <code>backend/reg/bruteregalloc.py</code> 中, 使用 <code>self.numArgs</code> 记录函数自身的参数数量, 使用 <code>self.functionParams</code> 记录子函数所使用的参数对应的虚拟寄存器, 使用 <code>self.callerSavedRegs</code> 保存 <code>caller_saved</code> 寄存器. 在函数开始先将实参绑定到寄存器中, 然后分析语句.</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># backend/reg/bruteregalloc.py</span><span class="token keyword">def</span> <span class="token function">accept</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> graph<span class="token punctuation">:</span> CFG<span class="token punctuation">,</span> info<span class="token punctuation">:</span> SubroutineInfo<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>    self<span class="token punctuation">.</span>numArgs <span class="token operator">=</span> info<span class="token punctuation">.</span>numArgs    self<span class="token punctuation">.</span>functionParams <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    self<span class="token punctuation">.</span>callerSavedRegs <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>allocForLoc</code> 为每行指令分配寄存器时, 若为 <code>Param</code> 类型, 累计参数小于 8 时直接分配参数寄存器; 若为 <code>Call</code> 类型, 先保存 <code>caller_saved</code> 寄存器, 将多余参数插入栈中, 调用后恢复除 <code>A0</code> 外的所有 <code>caller_saved</code> 寄存器, 否则返回值会被覆盖. 同样需要注意的是, 为虚拟寄存器分配实际寄存器时, 需要特殊判断虚拟寄存器是否对应存储在栈上的函数参数:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># backend/reg/bruteregalloc.py</span><span class="token keyword">def</span> <span class="token function">allocRegFor</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> temp<span class="token punctuation">:</span> Temp<span class="token punctuation">,</span> isRead<span class="token punctuation">:</span> <span class="token builtin">bool</span><span class="token punctuation">,</span> live<span class="token punctuation">:</span> <span class="token builtin">set</span><span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">,</span> subEmitter<span class="token punctuation">:</span> SubroutineEmitter<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token keyword">if</span> isRead<span class="token punctuation">:</span>        <span class="token comment"># 如果是存储在栈上的参数, 利用 FP 从栈中加载</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>self<span class="token punctuation">.</span>maxNumParams <span class="token operator">&lt;=</span> temp<span class="token punctuation">.</span>index <span class="token operator">&lt;</span> self<span class="token punctuation">.</span>numArgs<span class="token punctuation">)</span><span class="token punctuation">:</span>            subEmitter<span class="token punctuation">.</span>emitLoadParamFromStack<span class="token punctuation">(</span>reg<span class="token punctuation">,</span> temp<span class="token punctuation">.</span>index<span class="token punctuation">)</span>        <span class="token comment"># 否则, 利用 SP 从栈中加载</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            subEmitter<span class="token punctuation">.</span>emitLoadFromStack<span class="token punctuation">(</span>reg<span class="token punctuation">,</span> temp<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><h3 id="step-9-1"><a href="#step-9-1" class="headerlink" title="step 9"></a>step 9</h3><ol><li><p>你更倾向采纳哪一种中间表示中的函数调用指令的设计 (一整条函数调用 vs 传参和调用分离)? 写一些你认为两种设计方案各自的优劣之处.</p><p> <strong>答:</strong> 我更倾向采纳传参和调用分离, 这与实验文档给出的参考中间风格一致, 更接近目标语言.</p><p> <strong>一整条函数调用</strong>:</p><ul><li><strong>优势</strong>:<ul><li>调用过程封装在一个指令中, 语义清晰, 可读性好.</li><li>更接近高级语言, 有助于保留源代码结构和语义.</li></ul></li><li><p><strong>劣势</strong>:</p><ul><li>整条函数调用指令可能不够精确, 再特定架构下不能满足精细控制的需求.</li></ul><p><strong>传参和调用分离</strong>:</p></li><li><p><strong>优势</strong>:</p><ul><li>与实验文档给出的参考中间风格一致, 更接近目标语言.</li></ul></li><li><strong>劣势</strong>:<ul><li>需要增加 <code>Param</code> 指令描述参数传递, 提高了实现难度.</li><li>中间表示可读性略差.</li></ul></li></ul></li><li><p>为何 RISC-V 标准调用约定中要引入 <code>callee-saved</code> 和 <code>caller-saved</code> 两类寄存器, 而不是要求所有寄存器完全由 <code>caller/callee</code> 中的一方保存? 为何保存返回地址的 <code>ra</code> 寄存器是 <code>caller-saved</code> 寄存器?</p><p> <strong>答:</strong> 如果寄存器都由 <code>caller</code> 保存, <code>callee</code> 可能只使用很少几个, 恢复寄存器开销过大; 如果寄存器都由 <code>callee</code> 保存, 函数调用结束时恢复所有用到的寄存器开销过大. 引入 <code>callee-saved</code> 和 <code>caller-saved</code> 两类寄存器, 编译器可以让 <code>callee</code> 保存函数调用后依然有效的值 (如返回地址), 让 <code>caller</code> 保存函数调用过程后不再使用的值 (如函数参数).</p><p> 调用函数时, <code>ra</code> 中当前返回地址会被调用函数的返回地址替代, 因此需要在进入函数前保存好 <code>ra</code> 的值, 这应当由 <code>caller</code> 来完成.</p></li></ol>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;Stage-5-报告&quot;&gt;&lt;a href=&quot;#Stage-5-报告&quot; class=&quot;headerlink&quot; title=&quot;Stage 5 报告&quot;&gt;&lt;/a&gt;Stage 5 报告&lt;/h1&gt;&lt;h2 id=&quot;实验内容&quot;&gt;&lt;a href=&quot;#实验内容&quot;</summary>
        
      
    
    
    
    <category term="CS" scheme="http://chengsx21.github.io/categories/CS/"/>
    
    <category term="Compiler" scheme="http://chengsx21.github.io/categories/CS/Compiler/"/>
    
    
    <category term="Principles of Compiler" scheme="http://chengsx21.github.io/tags/Principles-of-Compiler/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络安全技术 笔记7</title>
    <link href="http://chengsx21.github.io/2023/12/13/ji-suan-ji-wang-luo-an-quan-ji-zhu-bi-ji-7/"/>
    <id>http://chengsx21.github.io/2023/12/13/ji-suan-ji-wang-luo-an-quan-ji-zhu-bi-ji-7/</id>
    <published>2023-12-13T09:18:57.000Z</published>
    <updated>2024-07-01T17:45:18.409Z</updated>
    
    <content type="html"><![CDATA[<h1 id="七、电子商务与-SET-协议"><a href="#七、电子商务与-SET-协议" class="headerlink" title="七、电子商务与 SET 协议"></a>七、电子商务与 SET 协议</h1><h2 id="电子商务安全"><a href="#电子商务安全" class="headerlink" title="电子商务安全"></a>电子商务安全</h2><ul><li>电子商务安全要求:<ul><li>数据传输的安全性:<ul><li>保证在公网上传送的资金帐号、客户密码、支付金额等网络支付信息数据不被第三方窃取.</li><li>采用对称加密实现, 数字信封利用非对称加密实现.</li></ul></li><li>数据的完整性:<ul><li>数据在传输过程中不被篡改.</li><li>通过安全的散列函数和数字签名实现, 双重数字签名保证多方通信时数据的完整性.</li></ul></li><li>身份验证:<ul><li>交换敏感信息时确认对方真实身份, 支付时确认账户信息真实有效.</li><li>采用口令技术, 非对称密码, 数字签名, 数字证书等技术实现.</li></ul></li><li>交易的不可抵赖:<ul><li>各方在进行数据传输时, 带有自身特有无法复制的信息, 交易双方在支付过程中都无法抵赖, 保证发生纠纷时有所对证.</li><li>通过时间戳, 数字签名, 数字证书等技术实现.</li></ul></li></ul></li><li>电子商务安全包括:<ul><li>基本加密算法.</li><li>以基本加密算法为基础的证书认证体系 CA, 及数字信封、数字签名等基本安全技术.</li><li>以基本加密算法、安全技术、CA 体系为基础的安全应用协议.</li></ul></li><li>CA 认证体系:<ul><li>以基本加密算法为基础, 采用基本安全技术.</li><li>为上层安全应用协议提供证书认证.</li><li>CA 证书标准:<ul><li>各国自行开发并拥有版权的认证体系.</li><li>为用户发放 CA 证书, 包括 SSL 证书.</li><li>CA 证书以 X.509 为基础, 进行扩展, 兼容多种协议证书.</li></ul></li><li>SET CA:<ul><li>符合 SET 标准.</li><li>专为基于银行支付卡的电子商务服务提供者及用户发放 SET 证书.</li></ul></li></ul></li><li>电子商务安全体系:<ul><li>网络系统安全: 针对物理技术系统.<ul><li>保证网络设施的正常运行.</li><li>避免受到外界的恶意攻击.</li></ul></li><li>网络信息安全: 针对商务逻辑系统.<ul><li>信息保密、信息完整.</li><li>身份认证、不可抵赖.</li><li>信息有效.</li></ul></li><li>网络交易安全:<ul><li>参与对象之间交易过程.</li><li>如 SSL, SET, 公钥基础设施 PKI.</li></ul></li></ul></li></ul><h2 id="安全电子交易协议-SET"><a href="#安全电子交易协议-SET" class="headerlink" title="安全电子交易协议 SET"></a>安全电子交易协议 SET</h2><ul><li><p>SET 简介:</p><ul><li>应用于互联网环境, 以信用卡为基础的安全电子交付协议.</li><li>不用信用卡支付的交易方式与 SET 无关.</li><li>给出了电子交易的过程规范.</li><li>实现电子商务交易中的加密、认证、密钥管理机制.</li></ul></li><li><p>SET 目标:</p><ul><li>保密性:<ul><li>防止数据被黑客或被内部人员窃取.</li></ul></li><li>真实性:<ul><li>多方认证问题:<ul><li>对消费者信用卡认证.<ul><li>商家能够验证卡用户是有效卡账号的合法用户.</li></ul></li><li>对网上商店认证.<ul><li>卡用户可以验证商家可以接受支付信用卡.</li></ul></li><li>消费者、商店与银行间的认证.</li></ul></li></ul></li><li>隐私性:<ul><li>保证订单信息和个人账号信息的隔离:<ul><li>客户资料通过商家到达银行, 但商家不能看到客户帐号信息.</li><li>银行不能看到用户订单信息.</li></ul></li></ul></li><li>实时性:<ul><li>网上交易的实时性, 所有支付过程都是在线.</li></ul></li></ul></li><li><p>SET 参与方:</p><ul><li>发卡银行 (issuer):<ul><li>发放信用卡, 交易中处理电子货币的审核和支付.</li><li>交易开始前, 查验持卡人的数据有效, 交易才能成立.</li></ul></li><li>持卡人 (cardholder):<ul><li>包括个人和团体消费者.</li><li>填写网上商店表单, 通过发卡银行的信用卡付费.</li></ul></li><li>网上商家 (merchant):<ul><li>网上符合 SET 规格的电子商店, 提供商品或服务.</li><li>具备相应电子货币使用条件, 从事商业交易的公司组织.</li><li>通常向用户提供 Web 界面, 和收款行建立信任关系.</li></ul></li><li>支付网关 (payment gateway):<ul><li>由银行操作, 将互联网传输数据转为金融机构内部数据.</li><li>或由指派第三方处理商家支付信息和顾客支付指令.</li><li>将 SET 和现有银行卡支付的网络系统作为接口.</li></ul></li><li>收款行 (acquirer):<ul><li>收款行为商家建立账号, 处理每笔交易的支付授权和实际支付.</li><li>代替商家与多个发卡行联系, 验证持卡人信用卡信息的有效性.</li></ul></li><li><p>证书授权 (CA):</p><ul><li>可信赖的公正组织.</li><li>接受持卡人、商店、银行及支付网关的数字认证申请, 签发管理数字证书, 使持卡人、商家和支付网关可通过数字证书进行认证.</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301710233.png" alt=""></p></li></ul></li><li><p>SET 交易过程:</p><ul><li><p>交易前完成认证:</p><ul><li>持卡人证书:<ul><li>持卡人的发卡机构向持卡人发放证书.</li><li>持卡人向支付网关提供帐号信息和秘密值用于验证.</li><li>持卡人证书连同购买请求和加密支付指令传给商家, 商家在最低程度上验证该帐号.</li></ul></li><li>商家证书:<ul><li>网上商家获得证书认证, 表明接受某个银行的支付卡.</li></ul></li><li>支付网关证书:<ul><li>持卡人从支付网关证书获取密钥, 加密账号信息.</li><li>只有支付网关能看到持卡人账号信息.</li></ul></li><li>收款行证书/发卡行证书:<ul><li>收款行/发卡行通过证书, 接收并处理商家证书请求.</li></ul></li></ul></li><li><p>网上支付处理过程——购买请求:</p><ul><li><p>发起请求报文:</p><ul><li>持卡人向商家发送信用卡品牌, ID. </li></ul></li><li><p>发起响应报文:</p><ul><li>商家向持卡人发送用商户私钥签名, Transiaction ID, 证书. </li></ul></li><li><p>持卡人验证商家证书, 生成 PI 和 OI, 将 Transiaction ID 放入.</p></li><li><p>PI 和 OI 必须分开加密和签名, 保证用户隐私不被泄漏.</p></li><li><p>PI 和 OI 必须有联系, 防止商家篡改信息产生纠纷.</p></li><li><p>购买请求报文:</p><ul><li>持卡人向商家发送 PI 和 OI.</li></ul></li><li><p>双签名:</p><ul><li>连接两个发送给不同接收者的报文.</li><li><p>KRc 为顾客私有签名密钥.</p><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301710234.png" alt=""></p></li></ul></li><li><p>客户生成购买请求:</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301710235.png" alt=""></p></li><li><p>商家验证用户的订单:</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301710236.png" alt=""></p></li></ul></li><li><p>网上支付处理过程——支付授权:</p><ul><li>商家通过支付网关、发卡行得到授权, 才能发货.</li><li>授权请求报文:<ul><li>与购买有关的信息: PI, 双签名.</li><li>与授权有关的信息: Es.</li><li>证书: 客户, 商家.</li></ul></li><li>授权响应报文:<ul><li>与授权有关的信息.</li><li>证书.</li></ul></li><li>支付网关处理授权请求:<ul><li>验证证书合法性.</li><li>解密数字信封, 获得会话密钥.</li><li>验证商家数字签名.</li><li>解密支付信息.</li><li>验证双签名.</li><li>验证 Transiaction ID 与 PI 一致.</li><li>从发卡行申请支付.</li></ul></li><li>商家获得授权后, 向用户确认商品清单.</li></ul></li><li><p>网上支付处理过程——支付获取:</p><ul><li>商家向发卡行申请支付.</li><li>商家通过支付获取, 才能完成银行转帐业务.</li><li>获取请求报文:<ul><li>支付的数量, 交易 ID, 获取权标, 商人签名密钥, 证书.</li></ul></li><li>获取响应报文:<ul><li>网关签名, 加密获取相应数据块, 网关签名密钥证书.</li></ul></li></ul></li></ul></li><li><p>SSL 与 SET 的比较:</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301710237.png" alt=""></p></li></ul>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;七、电子商务与-SET-协议&quot;&gt;&lt;a href=&quot;#七、电子商务与-SET-协议&quot; class=&quot;headerlink&quot; title=&quot;七、电子商务与 SET 协议&quot;&gt;&lt;/a&gt;七、电子商务与 SET 协议&lt;/h1&gt;&lt;h2 id=&quot;电子商务安全&quot;&gt;&lt;a</summary>
        
      
    
    
    
    <category term="CS" scheme="http://chengsx21.github.io/categories/CS/"/>
    
    <category term="Network Security" scheme="http://chengsx21.github.io/categories/CS/Network-Security/"/>
    
    
    <category term="Network Security" scheme="http://chengsx21.github.io/tags/Network-Security/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成原理 笔记8</title>
    <link href="http://chengsx21.github.io/2023/12/11/ji-suan-ji-zu-cheng-yuan-li-bi-ji-8/"/>
    <id>http://chengsx21.github.io/2023/12/11/ji-suan-ji-zu-cheng-yuan-li-bi-ji-8/</id>
    <published>2023-12-11T09:18:57.000Z</published>
    <updated>2024-07-01T17:45:18.409Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h1><h2 id="SRAM"><a href="#SRAM" class="headerlink" title="SRAM"></a>SRAM</h2><ul><li>无需刷新: 持续供电即可保持稳态; 掉电数据丢失: 无持久性.</li><li>存储密度低: DRAM 使用 1 个晶体管, SRAM 使用 6 个晶体管.</li></ul><h2 id="Cache-1"><a href="#Cache-1" class="headerlink" title="Cache"></a>Cache</h2><ul><li>目的: 根据程序局部性, 加快程序执行.</li><li>包含信息:<ul><li>地址.</li><li>数据.</li><li>Valid 位.</li></ul></li><li>设计原则:<ul><li>内存物理地址到 Cache 地址的地址映射关系.</li><li>Cache 使用虚拟地址 or 物理地址.<ul><li>CPU 提供虚拟地址, Cache 虚拟地址无需让 MMU 进行 Page Table Walker, 加速查询.</li><li>两个 Cache 虚拟地址对应同一物理地址, 一致性有误.</li><li>一个 Cache 虚拟地址对应两个物理地址, Cache 只能保存一项.</li><li>薛定谔的地址?</li></ul></li><li>控制位.</li><li>数据粒度.</li></ul></li><li><p>Cache Line:</p><ul><li>大小至少 4Byte, 使用一个 Valid 位控制.</li><li>若 Cache Line 过大, 可针对每 4Byte 或 8Byte 再设 Valid 位.</li></ul></li><li><p>不允许 Cache 的内存地址: MMIO 外设, 如串口寄存器, 读写慢. 需要将内存地址分类为 Cached/Uncached.</p></li><li>Cache 分类:<ul><li>L1 Cache: 多核 private, 分 Icache 与 Dcache. </li><li>L2 Cache: 多核 private.</li><li>L3 Cache: 多核 public.</li></ul></li><li><p>内存物理地址到 Cache 地址的映射关系:</p><ul><li>地址只允许被映射到一个位置.</li><li>地址允许被映射到多个位置.</li><li><p>全相联映射: 任何地址允许被映射到任何 Cache 的任何位置.</p><ul><li>Cache Line 大小为 4Byte: 地址前 30 位为 CT, 后 2 位为 CO.</li><li><p>条件:</p><ul><li>Valid 位为 1.</li><li>CT 相同.</li></ul></li><li><p>利用率高; 1024 路比较电路成本大, 硬件复杂, 延迟增加.</p></li><li>需要缓存替换算法.</li></ul></li><li><p>直接映射: 主存按 Cache 大小分块, 地址对应映射.</p><ul><li>Cache 大小为 4KB: 地址前 20 位为 CT, 中 10 位为 CI, 后 2 位为 CO.</li><li><p>条件:</p><ul><li>CI 索引 Cache Line 位置.</li><li>Valid 位为 1.</li><li>CT 相同.</li></ul></li><li><p>单路比较电路, 硬件简单; 利用率低.</p></li><li>无需缓存替换算法.</li></ul></li><li><p>组相联映射: 结合全相联映射与直接映射, 相当于多路直接映射.</p></li></ul></li><li>Cache 写策略:<ul><li>Write back (绝大多数):<ul><li>写分配:<ul><li>先替换, 替换时 Dirty 写回主存, 替换后再写 Cache.</li><li>程序 load/store 仅对 Cache 进行, 程序视角满足一致性.</li></ul></li></ul></li><li>Write through (MMIO 内存 or 多核 CPU 的 TLB 更新):<ul><li>写分配:<ul><li>先替换, 替换后先写 Cache, 再写主存.</li></ul></li><li>非写分配:<ul><li>直接写主存.</li></ul></li></ul></li></ul></li><li><p>Cache 缺失:</p><ul><li>必然缺失: 进程切换/首次访问.</li><li>容量缺失: 全相联映射.</li><li>冲突缺失: 直接映射/组相联映射.</li><li>无效缺失: 其他进程修改.</li></ul></li><li><p>Cache 替换策略:</p><ul><li>RAND.</li><li>FIFO.</li><li>LRU.</li></ul></li></ul>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;Cache&quot;&gt;&lt;a href=&quot;#Cache&quot; class=&quot;headerlink&quot; title=&quot;Cache&quot;&gt;&lt;/a&gt;Cache&lt;/h1&gt;&lt;h2 id=&quot;SRAM&quot;&gt;&lt;a href=&quot;#SRAM&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    <category term="CS" scheme="http://chengsx21.github.io/categories/CS/"/>
    
    <category term="Organization &amp; Design" scheme="http://chengsx21.github.io/categories/CS/Organization-Design/"/>
    
    
    <category term="Organization &amp; Design" scheme="http://chengsx21.github.io/tags/Organization-Design/"/>
    
    <category term="SV" scheme="http://chengsx21.github.io/tags/SV/"/>
    
  </entry>
  
</feed>
