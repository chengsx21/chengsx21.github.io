<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Endeavor</title>
  
  <subtitle>狂歌痛饮 来访雁丘处</subtitle>
  <link href="http://chengsx21.github.io/atom.xml" rel="self"/>
  
  <link href="http://chengsx21.github.io/"/>
  <updated>2023-09-21T17:10:05.472Z</updated>
  <id>http://chengsx21.github.io/</id>
  
  <author>
    <name>Chengsx</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>概率论与数理统计 笔记8</title>
    <link href="http://chengsx21.github.io/2023/04/26/gai-lu-lun-yu-shu-li-tong-ji-bi-ji-8/"/>
    <id>http://chengsx21.github.io/2023/04/26/gai-lu-lun-yu-shu-li-tong-ji-bi-ji-8/</id>
    <published>2023-04-26T09:27:40.000Z</published>
    <updated>2023-09-21T17:10:05.472Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Chap-8-线性回归"><a href="#Chap-8-线性回归" class="headerlink" title="Chap 8 线性回归"></a>Chap 8 线性回归</h1><h2 id="回归问题"><a href="#回归问题" class="headerlink" title="回归问题"></a>回归问题</h2><ul><li><p><strong>定义</strong>  </p><script type="math/tex; mode=display">  Y=f(X_1,\cdots,X_n)+\varepsilon.</script><ul><li>$Y$ — 因变量(响应变量).</li><li>$X_1,\cdots,X_n$ — 自变量(回归变量).</li><li><p>$\varepsilon$ — 随机误差(无法测量或不重要的因素).</p><p>假定 $E(\varepsilon\mid X_1,\cdots,X_n)=0$,</p><script type="math/tex; mode=display">\Rightarrow E(Y\mid X_1,\cdots,X_n)=f(X_1,\cdots,X_n).</script><p>称为 $Y$ 对 $X_1,\cdots,X_n$ 的回归函数. 由样本数据 $X_1,\cdots,X_n,Y$ 获取 $f$ 的过程称为回归(有监督学习).</p></li></ul></li><li><p><strong>注</strong>  </p><ul><li>$X_1,\cdots,X_n$ 可以是随机的(<strong>e.g.</strong> 随机抽取一人的身高、体重等).</li><li>$X_1,\cdots,X_n$ 也可以是非随机的控制变量(<strong>e.g.</strong> 施肥量、药品使用剂量).</li><li>在应用中, 自变量一律视为非随机的.</li></ul></li><li><p><strong>假设</strong>  $E(\varepsilon)=0$, $Var(\varepsilon)=\sigma^2$ (未知).</p></li><li><p><strong>注</strong>  要素是否完全、$f$ 的形式是否准确关乎 $\sigma^2$ 的大小.</p></li></ul><h2 id="简单线性回归"><a href="#简单线性回归" class="headerlink" title="简单线性回归"></a>简单线性回归</h2><ul><li><p><strong>定义</strong></p><script type="math/tex; mode=display">  Y=\beta_0+\beta_1 X+\varepsilon.</script><p>  这是<strong>理论模型</strong>, 提供背景作用. 其中回归参数(未知待定):</p><ul><li>$\beta_0$ — 截距.</li><li><p>$\beta_1$ — 斜率(回归系数).</p><p>对 $(X,Y)$ 进行 $n$ 次独立观测, 得到样本观测值 $(x_1,y_1),\cdots,(x_n,y_n)$. 则</p><script type="math/tex; mode=display">y_i=\beta_0+\beta_1 x_i+\varepsilon_i\,(1\le i\le n).</script><p>其中 $\varepsilon_i$ 作为第 $i$ 次观测的随机误差, 无法直接观测得到. 不妨认为</p><script type="math/tex; mode=display">\begin{cases}E(\varepsilon_i)=0,\\\\Var(\varepsilon_i)=\sigma^2.\end{cases}</script><p>这是<strong>简单线性回归模型</strong>. 其中:</p></li><li><p>$E(y_i)=\beta_0+\beta_1 x_i$.</p></li><li>$Var(y_i)=\sigma^2$.</li></ul></li><li><p><strong>注</strong></p><ul><li><strong>简单</strong>: $n=1$.</li><li><strong>线性</strong>: $f$ 关于参数 $\beta_0$, $\beta_1$ 线性.</li></ul></li></ul><h2 id="最小二乘法-LS-估计参数"><a href="#最小二乘法-LS-估计参数" class="headerlink" title="最小二乘法 (LS) 估计参数"></a>最小二乘法 (LS) 估计参数</h2><ul><li><p><strong>定义</strong></p><script type="math/tex; mode=display">  S(\beta_0,\beta_1)=\sum_{i=1}^{n}(y_i-(\beta_0+\beta_1 x_i))^2.</script><p>  最小化 $S(\beta_0,\beta_1)$, 得</p><ul><li>$\hat\beta_1=\dfrac{\sum\limits_{i=1}^{n}(x_i-\overline{x})(y_i-\overline{y})}{\sum\limits_{i=1}^{n}(x_i-\overline{x})^2}=\dfrac{\sum\limits_{i=1}^{n}(x_i-\overline{x})y_i}{S_{xx}}$ ($y_i$ 的线性组合).</li><li>$\hat\beta_0=\overline{y}-\hat\beta_1\overline{x}=\sum\limits_{i=1}^{n}(\dfrac{1}{n}-\dfrac{(x_i-\overline{x})\overline{x}}{S_{xx}})y_i$ ($y_i$ 的线性组合).</li><li>$y=\hat\beta_0+\hat\beta_1 x$ (拟合直线).</li></ul></li><li><p><strong>注</strong></p><ul><li>损失函数: $(y-(\beta_0+\beta_1 x))^2$.</li><li>线性模型是否合理.</li></ul></li><li><p><strong>命题</strong>  $\hat\beta_0$, $\hat\beta_1$ 分别为 $\beta_0$, $\beta_1$ 的无偏估计.</p></li><li><p><strong>证明</strong>  </p><script type="math/tex; mode=display">  \begin{aligned}  E(\hat\beta_1)&=\dfrac{\sum_{i=1}^{n}(x_i-\overline{x})E(y_i)}{S_{xx}}\\  &=\dfrac{\sum_{i=1}^{n}(x_i-\overline{x})(\beta_0+\beta_1 x_i)}{S_{xx}}\\  &=\beta_1\dfrac{\sum_{i=1}^{n}(x_i-\overline{x})x_i}{S_{xx}}\\  &=\beta_1\dfrac{\sum_{i=1}^{n}(x_i-\overline{x})^2}{S_{xx}}\\  &=\beta_1.  \end{aligned}</script><script type="math/tex; mode=display">  \begin{aligned}  E(\hat\beta_0)&=E(\overline{y}-\hat\beta_1\overline{x})\\  &=\dfrac{1}{n}\sum_{i=1}^{n}E(y_i)-E(\hat\beta_1)\overline{x}\\  &=\dfrac{1}{n}\sum_{i=1}^{n}(\beta_0+\beta_1 x_i)-\beta_1\overline{x}\\  &=\beta_0.  \end{aligned}</script><script type="math/tex; mode=display">  \begin{aligned}  Var(\hat\beta_1)&=Var\Big(\dfrac{\sum_{i=1}^{n}(x_i-\overline{x})y_i}{S_{xx}}\Big)\\  &=\dfrac{\sum_{i=1}^{n}(x_i-\overline{x})^2}{S_{xx}^2}Var(y_i)\\  &=\dfrac{\sigma^2}{S_{xx}}.  \end{aligned}</script><script type="math/tex; mode=display">  \begin{aligned}  Var(\hat\beta_0)&=Var\Big(\sum\limits_{i=1}^{n}(\dfrac{1}{n}-\dfrac{(x_i-\overline{x})\overline{x}}{S_{xx}})y_i\Big)\\  &=\sum\limits_{i=1}^{n}(\dfrac{1}{n}-\dfrac{(x_i-\overline{x})\overline{x}}{S_{xx}})^2 Var(y_i)\\  &=(\dfrac{1}{n}+\dfrac{\overline{x}^2}{S_{xx}})\sigma^2\\  &=\dfrac{\sigma^2}{S_{xx}}\cdot\dfrac{\sum_{i=1}^{n}x_i^2}{n}.  \end{aligned}</script></li><li><p><strong>注</strong>  中心化处理:</p><script type="math/tex; mode=display">  y_i=\beta_0+\beta_1\overline{x}+\beta_1(x_i-\overline{x})+\varepsilon_i.</script><p>  此时常数项 $\beta_0+\beta_1\overline{x}$ 的估计 $=\hat\beta_0+\hat\beta_1\overline{x}=\overline{y}$.</p></li><li><p><strong>定义(残差)</strong>  当 $X=x_i$ 时, 拟合直线上相应点为 $(x_i,\hat\beta_0+\hat\beta_1 x_i)$.</p><p>  记 $\hat{y}_i=\hat\beta_0+\hat\beta_1 x_i$, 称为 $x_i$ 处的拟合值. 定义残差 $y_i-\hat{y}_i$. 考虑残差平方和</p><script type="math/tex; mode=display">  SSE:=\sum_{i=1}^{n}(y_i-\hat y_i)^2=\sum_{i=1}^{n}(y_i-(\hat\beta_0+\hat\beta_1 x_i))^2.</script></li><li><p><strong>命题</strong>  $\hat\sigma^2:=\dfrac{SSE}{n-2}$ 为 $\sigma^2$ 的无偏估计. 此时</p><ul><li>$\hat{se}(\hat\beta_1)=\dfrac{\hat\sigma}{\sqrt{S_{xx}}}$.</li><li>$\hat{se}(\hat\beta_0)=\hat\sigma\sqrt{\dfrac{1}{n}+\dfrac{\overline{x}^2}{S_{xx}}}$.</li></ul></li></ul><h2 id="回归参数推断"><a href="#回归参数推断" class="headerlink" title="回归参数推断"></a>回归参数推断</h2><ul><li><p><strong>追加假设</strong>  $\varepsilon_i\sim N(0,\sigma^2)$, $1\le i\le n$.</p></li><li><p><strong>注</strong></p><ul><li><p>$y_i\sim N(\beta_0+\beta_1 x_i,\sigma^2)$ 独立, $1\le i\le n$.</p></li><li><p><strong>MLE</strong>$(\beta_0^<em>,\beta_1^</em>)=(\hat\beta_0,\hat\beta_1)$ (<strong>习题课 5</strong>).</p><p>  $L(\beta_0,\beta_1,\sigma^2)=\prod\limits_{i=1}^{n}\dfrac{1}{\sqrt{2\pi}\sigma}e^{-\tfrac{(y_i-(\beta_0+\beta_1 x_i))^2}{2\sigma^2}}$.</p><p>  $(\sigma^2)^*=\dfrac{SSE}{n}$.</p></li></ul></li><li><p><strong>定义(假设检验)</strong>  $H_0:\beta_1=0$ <strong>v.s.</strong> $H_1:\beta_1\ne 0$. 因为 $\hat\beta_1$ 为 $y_i$ 的线性组合. 得到</p><script type="math/tex; mode=display">  \dfrac{\hat\beta_1-\beta_1}{\tfrac{\sigma}{\sqrt{S_{xx}}}}\sim N(0,1)</script><p>  可证明</p><script type="math/tex; mode=display">  \dfrac{SSE}{\sigma^2}=\dfrac{(n-2)\hat\sigma^2}{\sigma^2}\sim\chi^2(n-2).</script><p>  从而</p><script type="math/tex; mode=display">  \dfrac{\hat\beta_1-\beta_1}{\hat{se}(\hat\beta_1)}=\dfrac{\hat\beta_1-\beta_1}{\tfrac{\hat\sigma}{\sqrt{S_{xx}}}}=\dfrac{\hat\beta_1-\beta_1}{\tfrac{\sigma}{\sqrt{S_{xx}}}}/\sqrt{\dfrac{(n-2)\hat\sigma^2}{(n-2)\sigma^2}}\sim t(n-2).</script><p>  检验统计量:</p><script type="math/tex; mode=display">  T=\dfrac{\hat\beta_1}{\hat{se}(\hat\beta_1)}.</script><p>  当 $H_0$ 为真时, $T\sim t(n-2)$. 检验准则为: 当 $\vert T\vert\ge t_{\tfrac{\alpha}{2}}(n-2)$ 时拒绝 $H_0$.</p></li><li><p><strong>注</strong></p><ul><li>可以对其他的 $\beta_1$ 可能值进行检验.</li><li>可以对 $\beta_1$ 进行区间估计.</li><li>可以对 $\beta_0$ 进行相应推断, 过程类似.</li></ul></li></ul><h2 id="预测"><a href="#预测" class="headerlink" title="预测"></a>预测</h2><ul><li><p><strong>例</strong>  当 $X=x_0$ 时, $y_0=\beta_0+\beta_1 x_0+\varepsilon_0$, 其中 $\varepsilon\sim N(0,\sigma^2)$. 令</p><script type="math/tex; mode=display">  \mu_0=E(y_0)=\beta_0+\beta_1 x_0,</script><p>  给出对 $\mu_0$ 的预测.</p></li><li><p><strong>解答</strong>  用拟合直线上 $x_0$ 处的取值 $\hat y_0$ 给出 $\mu_0$ 的点估计:</p><script type="math/tex; mode=display">  \hat y_0=\hat\beta_0+\hat\beta_1x_0=\overline{y}-\hat\beta_1(x_0-\overline{x})=\sum_{i=1}^{n}(\dfrac{1}{n}+\dfrac{(x_i-\overline{x})(x_0-\overline{x})}{S_{xx}})y_i</script><p>  分别给出</p><ul><li>$E(\hat y_0)=E(\hat\beta_0+\hat\beta_1x_0)=\beta_0+\beta_1x_0=\mu_0$.</li><li><p>$Var(\hat y_0)=\sum_{i=1}^{n}\Big(\dfrac{1}{n}+\dfrac{(x_i-\overline{x})(x_0-\overline{x})}{S_{xx}}\Big)^2\sigma^2=\Big(\dfrac{1}{n}+\dfrac{(x_0-\overline{x})^2}{S_{xx}}\Big)\sigma^2$.</p><p>从而</p><script type="math/tex; mode=display">\dfrac{\hat y_0-\mu_0}{se(\hat y_0)}\sim N(0,1).</script><p>使用 $\hat{se}(\hat y_0)=\hat\sigma\sqrt{\dfrac{1}{n}+\dfrac{(x_0-\overline{x})^2}{S_{xx}}}$ 估计 $se(\hat y_0)$, 我们有</p><script type="math/tex; mode=display">\dfrac{\hat y_0-\mu_0}{\hat{se}(\hat y_0)}\sim t(n-2).</script><p>从而 $\mu_0$ 的 $(1-\alpha)-$ 置信的双侧区间估计为</p><script type="math/tex; mode=display">\Big(\hat y_0-t_{\tfrac{\alpha}{2}}\hat\sigma\sqrt{\dfrac{1}{n}+\dfrac{(x_0-\overline{x})^2}{S_{xx}}},\hat y_0+t_{\tfrac{\alpha}{2}}\hat\sigma\sqrt{\dfrac{1}{n}+\dfrac{(x_0-\overline{x})^2}{S_{xx}}}\Big).</script></li></ul></li><li><p><strong>例</strong>  当 $X=x_0$ 时, $y_0=\beta_0+\beta_1 x_0+\varepsilon_0$, 其中 $\varepsilon\sim N(0,\sigma^2)$. 给出对 $y_0$ 的预测.</p></li><li><p><strong>解答</strong>  $y_0\sim N(\mu_0,\sigma^2)$. 若 $\mu_0$ 已知, 则 $y_0$ 的(均方意义下最优)估计为 $\mu_0$.</p><p>  一般情况下, $y_0$ 的良好点估计为 $\hat y_0=\hat\beta_0+\hat\beta_1x_0$.</p><p>  注意到 $y_0$ 与 $\hat y_0$ 相互独立, 从而 $\hat y_0- y_0$ 服从正态分布.</p><p>  分别给出</p><ul><li>$E(\hat y_0-y_0)=E(\hat y_0)-E(y_0)=\mu_0-\mu_0=0$.</li><li><p>$Var(\hat y_0-y_0)=Var(\hat y_0)+Var(y_0)=\sigma^2(1+\dfrac{1}{n}+\dfrac{(x_0-\overline{x})^2}{S_{xx}})$.</p><p>从而</p><script type="math/tex; mode=display">\dfrac{\hat y_0-y_0}{\sigma\sqrt{1+\dfrac{1}{n}+\dfrac{(x_0-\overline{x})^2}{S_{xx}}}}\sim N(0,1).</script><p>进而</p><script type="math/tex; mode=display">\dfrac{\hat y_0-y_0}{\hat\sigma\sqrt{1+\dfrac{1}{n}+\dfrac{(x_0-\overline{x})^2}{S_{xx}}}}\sim t(n-2).</script></li></ul></li></ul><pre><code>从而 $y_0$ 的 $(1-\alpha)-$ 置信的双侧区间估计为$$\Big(\hat y_0-t_{\tfrac{\alpha}{2}}\hat\sigma\sqrt{1+\dfrac{1}{n}+\dfrac{(x_0-\overline{x})^2}{S_{xx}}},\hat y_0+t_{\tfrac{\alpha}{2}}\hat\sigma\sqrt{1+\dfrac{1}{n}+\dfrac{(x_0-\overline{x})^2}{S_{xx}}}\Big).$$</code></pre><ul><li><p><strong>注</strong>  当 $x_0$ 与 $\overline{x}$ 距离增加时, 估计误差增大.</p></li><li><p><strong>注</strong></p><ul><li>结合实际理解 $\beta$.</li><li>外推需谨慎.</li><li>截距为 0 的回归复杂度 $n-2\rightarrow n-1$.</li><li>回归方程不可逆转使用.</li><li>常见应用:<ul><li>描述趋势.</li><li>预测均值\取值.</li><li>实验控制.</li></ul></li></ul></li></ul>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;Chap-8-线性回归&quot;&gt;&lt;a href=&quot;#Chap-8-线性回归&quot; class=&quot;headerlink&quot; title=&quot;Chap 8 线性回归&quot;&gt;&lt;/a&gt;Chap 8 线性回归&lt;/h1&gt;&lt;h2 id=&quot;回归问题&quot;&gt;&lt;a href=&quot;#回归问题&quot;</summary>
        
      
    
    
    
    <category term="Math" scheme="http://chengsx21.github.io/categories/Math/"/>
    
    <category term="Probability Theory" scheme="http://chengsx21.github.io/categories/Math/Probability-Theory/"/>
    
    
    <category term="Probability Theory" scheme="http://chengsx21.github.io/tags/Probability-Theory/"/>
    
  </entry>
  
  <entry>
    <title>概率论与数理统计 笔记7</title>
    <link href="http://chengsx21.github.io/2023/04/14/gai-lu-lun-yu-shu-li-tong-ji-bi-ji-7/"/>
    <id>http://chengsx21.github.io/2023/04/14/gai-lu-lun-yu-shu-li-tong-ji-bi-ji-7/</id>
    <published>2023-04-14T09:27:40.000Z</published>
    <updated>2023-09-21T17:10:00.560Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Chap-7-假设检验"><a href="#Chap-7-假设检验" class="headerlink" title="Chap 7 假设检验"></a>Chap 7 假设检验</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li><p><strong>例(女士品茶)</strong>  某女士声称可区分奶茶是先加牛奶还是先加茶. <strong>R.Fisher</strong> 设计实验: 各有 4 杯奶茶随机排成一排, 将这一信息告知女士. 考虑假设 $H$: 该女士没有区分能力. 当 $H$ 正确的情况下, 4 杯全对的概率为</p><script type="math/tex; mode=display">  \dfrac{C_4^4\cdot C_4^0}{C_8^4}=\dfrac{1}{70}.</script><p>  下述两种情况之一必发生:</p><ul><li>$H$ 不正确 (<strong>i.e.</strong>该女士有区分能力);</li><li><p>$H$ 正确 (发生了一件概率为 $\dfrac{1}{70}$ 的事情).</p><p>通常选择阈值 $\alpha=0.05,0.01,0.1$ (预先给定的显著性水平). 若女士选对了三杯, 则在 $H$ 正确的前提下, 挑对三杯及以上的概率为</p><script type="math/tex; mode=display">\dfrac{C_4^4\cdot C_4^0}{C_8^4}+\dfrac{C_4^3\cdot C_4^1}{C_8^4}=\dfrac{17}{70}\approx 0.243.</script></li></ul></li><li><p><strong>注</strong></p><ul><li><p><strong>Fisher</strong> 显著性检验;</p></li><li><p>若认可某组观测(样本), 则用它来证实或证伪某个理论(断言)具有天然的不对等;</p></li><li><p>$H$ 可以模型化:</p><script type="math/tex; mode=display">  P(X=k)\dfrac{C_4^k\cdot C_4^{4-k}}{C_8^4}.</script></li><li><p>历史注记:</p><ul><li><strong>Fisher</strong> 显著性检验;</li><li><strong>Neyman-Pearson</strong> 检验;</li><li>零假设显著性检验 (<strong>MHST</strong>).</li></ul></li></ul></li><li><p><strong>定义(统计假设)</strong>  对一个或多个总体的某种断言或猜测.</p><ul><li>原假设: 被检验的假设 $H_0$;</li><li>备择假设: 拒绝 $H_0$ 后可供选择的假设 $H_1$.</li><li>若假设可表为参数形式, 那么 $H_0: \theta\in\Theta_0$, $H_1: \theta\in\Theta_1$, 且 $\Theta_0\cap\Theta_1=\varnothing$, $\Theta_0\cup\Theta_1=\theta$ 的所有可能取值之集.</li></ul></li><li><p><strong>例</strong>  假设 $X\sim N(\mu,\sigma^2)$, 其中 $\sigma^2$ 已知.</p><ul><li>$H_0:\mu=\mu_0,\quad H_1:\mu\ne\mu_0$. (双侧假设)</li><li>$H_0:\mu=\mu_0,\quad H_1:\mu&gt;\mu_0$. (单侧假设)</li><li>$H_0:\mu\le\mu_0,\quad H_1:\mu&gt;\mu_0$. (单侧假设)</li><li>$H_0:\mu_1=\mu_2,\quad H_1:\mu_1\ne\mu_2$. (双侧假设)</li></ul></li><li><p><strong>注</strong></p><ul><li>简单假设: 只对应一个总体;</li><li>复合假设: 对应多个总体;</li><li>若 $\sigma^2$ 未知, 则 $H_0: \mu=\mu_0\Leftrightarrow H_0: \mu=\mu_0,\sigma^2$ 任意, 是一个复合假设.</li></ul></li><li><p><strong>定义(假设检验)</strong>  依据样本(观测)的决策(拒绝或不拒绝 $H_0$)过程.</p></li><li><p><strong>定义(检验准则)</strong>  做出决策的一个具体法则.</p></li><li><p><strong>定义(拒绝)</strong>  在原假设 $H_0$ 为真的前提下, 所观测的样本出现的概率如果是很小的, 意味着样本提供的概率拒绝 $H_0$.</p></li><li><p><strong>定义(拒绝域/临界域)</strong>  形式上可抽象为</p><script type="math/tex; mode=display">  R=\{(X_1,\cdots,X_n)\mid T(X_1,\cdots,X_n)\ge c\}.</script><p>  其中 $c$ 被定义为临界值. 此时检验准则为, 若样本 $(X_1,\cdots,X_n)\in R$, 则拒绝假设 $H_0$.</p></li><li><p><strong>定义(显著性检验)</strong>  对事先给定的 $\alpha\in(0,1)$, 若 $P_{\theta}(T(X_1,\cdots,X_n)\ge c)\le\alpha$, $\forall\,\theta\in\Theta_0$, 则称这是一个水平为 $\alpha$ 的显著性检验.</p></li><li><p><strong>例</strong>  假设 $X\sim N(\mu,\sigma^2)$, 其中 $\sigma^2$ 已知, 给定检验水平 $\alpha\in(0,1)$ 和已观测样本 $X_i(1\le i\le n)$. $H_0:\mu=\mu_0$, $H_1:\mu\ne\mu_0$. 对原假设进行检验.</p></li><li><p><strong>解答</strong>  拒绝域为双侧拒绝, 当 $H_0$ 为真时, 控制 $P(\vert\overline{X}-\mu_0\vert\ge c)\le\alpha$. </p><p>  根据 <strong>CLT</strong>, 注意到</p><script type="math/tex; mode=display">  \overline{X}-\mu_0\sim N(0,\dfrac{\sigma^2}{n})\Leftrightarrow\dfrac{\overline{X}-\mu_0}{\tfrac{\sigma}{\sqrt{n}}}\sim N(0,1).</script><p>  取 $\dfrac{c}{\tfrac{\sigma}{\sqrt{n}}}=Z_{\tfrac{\alpha}{2}}\Rightarrow c=\dfrac{\sigma}{\sqrt{n}}\cdot Z_{\tfrac{\alpha}{2}}$. </p><p>  给出在 $\alpha$ 的检验水平下拒绝 $H_0$ 的条件: 若 $\vert\overline{X}-\mu_0\vert\ge\dfrac{\sigma}{\sqrt{n}}\cdot Z_{\tfrac{\alpha}{2}}$, 则拒绝 $H_0$.</p></li><li><p><strong>例</strong>  假设 $X\sim N(\mu,\sigma^2)$, 其中 $\sigma^2$ 已知, 给定检验水平 $\alpha\in(0,1)$ 和已观测样本 $X_i(1\le i\le n)$. $H_0:\mu\ge\mu_0$, $H_1:\mu&lt;\mu_0$. 对原假设进行检验.</p></li><li><p><strong>解答</strong>  拒绝域为单侧拒绝, 当 $H_0$ 为真时, 控制 $P(\overline{X}\le c)\le\alpha$.</p><p>  根据 <strong>CLT</strong>, 注意到</p><script type="math/tex; mode=display">  \overline{X}-\mu\sim N(0,\dfrac{\sigma^2}{n})\Leftrightarrow\dfrac{\overline{X}-\mu}{\tfrac{\sigma}{\sqrt{n}}}\sim N(0,1).</script><p>  因此</p><script type="math/tex; mode=display">  \begin{aligned}  P(\overline{X}\le c)&=P(\dfrac{\overline{X}-\mu}{\tfrac{\sigma}{\sqrt{n}}}\le \dfrac{c-\mu}{\tfrac{\sigma}{\sqrt{n}}})\\  &=P(Z\le\dfrac{c-\mu}{\tfrac{\sigma}{\sqrt{n}}})\\  &=\varPhi(\dfrac{c-\mu}{\tfrac{\sigma}{\sqrt{n}}}),\forall\,\mu\ge\mu_0.  \end{aligned}</script></li></ul><pre><code>取 $\dfrac{c-\mu_0}{\tfrac{\sigma}{\sqrt{n}}}=-Z_{\alpha}\Rightarrow c=\mu_0-\dfrac{\sigma}{\sqrt{n}}\cdot Z_{\alpha}$. 给出在 $\alpha$ 的检验水平下拒绝 $H_0$ 的条件: 若 $\overline{X}\le\mu_0-\dfrac{\sigma}{\sqrt{n}}\cdot Z_{\alpha}$, 则拒绝 $H_0$.</code></pre><ul><li><p><strong>注</strong></p><ul><li><p>这种方法称为 $Z$-检验.</p></li><li><p>若 $\sigma^2$ 未知, 考虑</p><script type="math/tex; mode=display">  \dfrac{\overline{X}-\mu}{\tfrac{S}{\sqrt{n}}}\sim t(n-1).</script><p>  这种方法称为 $t$-检验.</p></li></ul></li></ul><h2 id="Neyman-Pearson-假设检验"><a href="#Neyman-Pearson-假设检验" class="headerlink" title="Neyman-Pearson 假设检验"></a>Neyman-Pearson 假设检验</h2><ul><li><p><strong>定义(错误)</strong>  Ⅰ类错误: 在 $H_0$ 为真时拒绝 $H_0$; Ⅱ类错误: 在 $H_0$ 为假时不拒绝 $H_0$. 对应的概率分别为:</p><script type="math/tex; mode=display">  \begin{aligned}  \alpha(R)&:=P_{\theta}(Ⅰ)=P_{\theta}((X_1,\cdots,X_n)\in R),\theta\in\Theta_0;\\  \beta(R)&:=P_{\theta}(Ⅱ)=P_{\theta}((X_1,\cdots,X_n)\in R^c),\theta\in\Theta_1.  \end{aligned}</script><p>  对于已划分的 $R$ 来说, 是定义域不同的 $\theta$ 的函数.</p></li><li><p><strong>注</strong></p><ul><li>依据样本做决策, 错误不能根本避免;</li><li>一次决策不能同时犯两种错误;</li><li>$n$ 固定, 两种错误发生的概率此消彼长.</li></ul></li><li><p><strong>例(直觉)</strong></p><ul><li>都不拒绝 $H_0$, 那么 $P_{\theta}(Ⅰ)=0$, $P_{\theta}(Ⅱ)=1$.</li><li>考虑事件 $H_0:$ 合格, 事件 $H_1:$ 不合格, 当 $P_{\theta}(Ⅰ)$ 变小时, 不容易拒绝事件, 不合格不容易被检出, 从而 $P_{\theta}(Ⅱ)$ 变大.</li></ul></li><li><p><strong>定义(功效函数)</strong>    给定 $\theta$ 与临界域 $R$, 拒绝原假设 $H_0$ 的概率为:</p><script type="math/tex; mode=display">  P_{\theta}((X_1,\cdots,X_n)\in R)=1-\beta(R),\,\theta\in\Theta_1.</script></li><li><p><strong>定义(Neyman-Pearson 范式)</strong>  $n$ 固定, 控制 $P_{\theta}(Ⅰ)\le\alpha$, 其中 $\alpha$ 为预先给定的检验水平, 再在这个限制下使 $P_{\theta}(Ⅱ)(\theta\in\Theta_1)$ 尽可能小.</p></li><li><p><strong>注</strong></p><ul><li>$\alpha$ 固定时, 使 $P_{\theta}(Ⅱ)(\theta\in\Theta_1)$ 最小的检验称为水平 $\alpha$ 下的一致最优检验;</li><li>原假设 $H_0$ 和备择假设 $H_1$ 一般是地位不对等的:<ul><li>原假设通常是受到保护的, 证据不充分不能拒绝;</li><li>备择假设通常是真正感兴趣的.</li></ul></li><li>一致最优检验不一定存在, 一般也不易求解;</li><li>$\mu_0\in$ 置信区间 $\Leftrightarrow$ 假设检验 $(H_0: \mu=\mu_0, H_1: \mu\ne\mu_0)$ 不拒绝 $H_0$.</li></ul></li></ul><h2 id="假设检验与置信区间"><a href="#假设检验与置信区间" class="headerlink" title="假设检验与置信区间"></a>假设检验与置信区间</h2><ul><li><p><strong>例</strong>  $X\sim N(\mu,\sigma^2)$, $\sigma^2$ 已知, $\alpha&gt;0$ 给定, $X_1,\cdots,X_n$ 为随机样本.</p></li><li><p><strong>解答 </strong> 其双侧置信区间为</p><script type="math/tex; mode=display">  P=(\overline{X}-Z_{\tfrac{\alpha}{2}}\dfrac{\sigma}{\sqrt{n}},\overline{X}+Z_{\tfrac{\alpha}{2}}\dfrac{\sigma}{\sqrt{n}}).</script><p>  考虑假设检验 $H_0:\mu=\mu_0$, $H_1:\mu\ne\mu_0$. 需要控制</p><script type="math/tex; mode=display">  P_{H_0}(\vert\overline{X}-\mu_0\vert\ge c)\le\alpha.</script><p>  检验准则为 $\vert\overline{X}-\mu_0\vert\ge Z_{\tfrac{\alpha}{2}}\dfrac{\sigma}{\sqrt{n}}$ 时拒绝 $H_0$. 我们给出接受域</p><script type="math/tex; mode=display">  R^c=\{(X_1,\cdots,X_n)\mid \vert\overline{X}-\mu_0\vert<Z_{\tfrac{\alpha}{2}}\dfrac{\sigma}{\sqrt{n}}\}\\  =\{(X_1,\cdots,X_n)\mid \mu_0\in P\}.</script><p>  由此可见, $\mu_0\in P\Leftrightarrow$ 用 $\overline{X}$ 为检验统计量, 假设检验不拒绝 $H_0$.(<strong>对偶关系</strong>)</p></li></ul><h2 id="检验的-P-值"><a href="#检验的-P-值" class="headerlink" title="检验的 P 值"></a>检验的 P 值</h2><ul><li><p><strong>定义</strong>  当原假设 $H_0$ 为真时, 检验统计量的观测值以及更极端观测出现的概率. </p></li><li><p><strong>例(选举问题)</strong>  $n=1200$, 调查到的支持比例为 $\tfrac{684}{1200}\approx 0.57$ (观测值).</p></li><li><p><strong>解答</strong>  (1) $H_0:p=p_0$ v.s. $H_1:p&gt;p_0$ ($p_0$ 预先给定).</p><p>  考虑检验统计量 $P_n$, 则由 <strong>CLT</strong>:</p><script type="math/tex; mode=display">  \dfrac{P_n-p}{\sqrt{\tfrac{p(1-p)}{n}}}\stackrel{近似}{\sim}N(0,1).</script><p>  当 $H_0$ 为真时, $p=p_0$, 此时 $se(P_n)=\sqrt{\dfrac{p_0(1-p_0)}{n}}$. 因此 <strong>P</strong> 值</p><script type="math/tex; mode=display">  P_{H_0}(P_n\ge p_n)=P(\dfrac{P_n-p_0}{se(P_n)}\ge\dfrac{p_n-p_0}{se(P_n)})\approx P(Z\ge z_0).</script><p>  其中</p><script type="math/tex; mode=display">  Z\stackrel{近似}{\sim}N(0,1),z_0=\dfrac{p_n-p_0}{se(P_n)}=\dfrac{p_n-p_0}{\sqrt{\tfrac{p_0(1-p_0)}{n}}}.</script><p>  因此</p><script type="math/tex; mode=display">  P_{H_0}(P_n\ge p_n)=1-\varPhi(\dfrac{p_n-p_0}{\sqrt{\tfrac{p_0(1-p_0)}{n}}}).</script><p>  若 $p_0=0.55$, 则 <strong>P</strong> 值 $\approx 0.081$; 若 $p_0=0.5$, 则 <strong>P</strong> 值 $\ll 0.001$.</p><p>  在水平 $\alpha$ 下拒绝 $H_0\Leftrightarrow$ <strong>P</strong> 值 $\le\alpha$.</p></li><li><p><strong>注</strong></p><ul><li><strong>P</strong> 值作为数据 (观测) 拒绝 $H_0$ 的证据.</li><li>强弱的度量: <strong>P</strong> 值越小, 拒绝 $H_0$ 的证据越强 (非正式的).</li><li><strong>P</strong> 值 $\ne$ $P(H_0\mid $ 观测$)$.</li><li>若 <strong>P</strong> 值不小, 则不拒绝 $H_0$, 原因可能为 $H_0$ 真 / $H_0$ 不真, 但检验功效不大.</li></ul></li><li><p><strong>定义</strong>  若拒绝 $H_0:\theta\in\Theta_0\Leftrightarrow T(X_1,\cdots,X_n)\ge C$, 则检验的 <strong>P</strong> 值 $:=$</p><script type="math/tex; mode=display">  \sup_{\theta\in\Theta_0}P_{\theta}(T(X_1,\cdots,X_n)\ge T(x_1,\cdots,x_n)).</script><p>  其中 $T(x_1,\cdots,x_n)$ 为检验统计量的观测值.</p></li><li><p><strong>解答</strong>  (2) $H_0:p\le p_0$ v.s. $H_1:p&gt;p_0$ ($p_0$ 预先给定).</p><p>  考虑检验统计量 $P_n$, 则由 <strong>CLT</strong>:</p><script type="math/tex; mode=display">  \dfrac{P_n-p}{\sqrt{\tfrac{p(1-p)}{n}}}\stackrel{近似}{\sim}N(0,1).</script><p>  当 $H_0$ 为真时, 此时 $se(P_n)\approx \hat{se}(P_n)=\sqrt{\dfrac{p_n(1-p_n)}{n}}$. 因此 <strong>P</strong> 值</p><script type="math/tex; mode=display">  P_{H_0}(P_n\ge p_n)=P(\dfrac{P_n-p}{\hat{se}(P_n)}\ge\dfrac{p_n-p}{\hat{se}(P_n)})\approx P(Z\ge z_0).</script><p>  其中</p><script type="math/tex; mode=display">  Z\stackrel{近似}{\sim}N(0,1),z_0=\dfrac{p_n-p}{\hat{se}(P_n)}=\dfrac{p_n-p}{\sqrt{\tfrac{p_n(1-p_n)}{n}}}.</script><p>  因此</p><script type="math/tex; mode=display">  P_{H_0}(P_n\ge p_n)=1-\varPhi(\dfrac{p_n-p}{\sqrt{\tfrac{p_n(1-p_n)}{n}}}),\forall\,p\le p_0.</script><p>  因此 <strong>P</strong> 值</p><script type="math/tex; mode=display">  \sup_{p\le p_0}\Big(1-\varPhi(\dfrac{p_n-p}{\sqrt{\tfrac{p_n(1-p_n)}{n}}})\Big)=1-\varPhi(\dfrac{p_n-p_0}{\sqrt{\tfrac{p_n(1-p_n)}{n}}}).</script><p>  若 $p_0=0.55$, 则 <strong>P</strong> 值 $\approx 0.081$; 若 $p_0=0.5$, 则 <strong>P</strong> 值 $\ll 0.001$.</p></li></ul><h2 id="拟合优度检验"><a href="#拟合优度检验" class="headerlink" title="拟合优度检验"></a>拟合优度检验</h2><ul><li><p><strong>定义(Pearson 卡方统计量)</strong></p><script type="math/tex; mode=display">  \chi^2:=\sum_{i=1}^{k}\dfrac{(O_i-E_i)^2}{E_i}\stackrel{近似}{\sim}\chi^2(k-1).</script><p>  其中 $O_i$ 为观测频数, $E_i$ 为期望频数 ($H_0$ 真的条件下).</p></li><li><p><strong>定理</strong>  $H_0: P(X\in$ 第 $i$ 单元$)=p_i(1\le i\le k)$. 若 $H_0$ 为真, 当 $n\rightarrow\infty$ 时, 有</p><script type="math/tex; mode=display">  \chi^2\rightarrow\chi^2(k-1).</script></li><li><p><strong>例</strong>  投掷一枚骰子 60 次.</p><p>  | 点数     | 1    | 2    | 3    | 4    | 5    | 6    | 总计 |<br>  | ———— | —— | —— | —— | —— | —— | —— | —— |<br>  | 观测频数 | 4    | 6    | 17   | 16   | 8    | 9    | 60   |<br>  | 期望频数 | 10   | 10   | 10   | 10   | 10   | 10   | 60   |</p><p>  $H_0:$ 分布均匀, $H_1:$ 分布不均匀.</p></li><li><p><strong>解答</strong>  检验统计量的观测值:</p><script type="math/tex; mode=display">  \dfrac{(4-10)^2}{10}+\dfrac{(6-10)^2}{10}+\cdots+\dfrac{(9-10)^2}{10}=14.2.</script><p>  自由度为 $6-1=5$. <strong>P</strong> 值 $=P_{H_0}(\chi^2\ge 14.2)\approx 0.014$.</p></li><li><p><strong>注</strong>  在实际应用中, 需要满足 $E_i=nP_i\ge 5$, 才能较好使用 <strong>Pearson</strong> 定理.</p></li><li><p><strong>例(列联表独立性检验)</strong>  对某项议题态度与年龄段是否独立.</p><p>  |      | 青年 | 中年 | 老年 |      |<br>  | —— | —— | —— | —— | —— |<br>  | 支持 | 20   | 40   | 20   | 80   |<br>  | 反对 | 30   | 30   | 10   | 70   |<br>  |      | 50   | 70   | 30   | 150  |</p><p>  $H_0:$ 独立, $H_1:$ 不独立.</p></li><li><p><strong>解答</strong>  $P_{ij}=P_{i+}P_{+j}$, 其中 $P_{i+}$, $P_{+j}$ 称为边际概率.</p><p>  在 $H_0$ 为真前提下估计 $P_{ij}$. <strong>MLE</strong>:</p><script type="math/tex; mode=display">  P_{ij}^*=(P_{i+}P_{+j})^*=P_{i+}^*P_{+j}^*=\dfrac{sum(row_i)}{n}\times\dfrac{sum(column_j)}{n}.</script><p>  得到</p><script type="math/tex; mode=display">  E_{ij}=nP_{ij}\approx nP_{ij}^*=\dfrac{1}{n}sum(row_i)\times sum(column_j).</script><p>  计算得检验统计量观测值为 6.12, 自由度为 $(a-1)(b-1)=2$.</p><p>  得到 <strong>P</strong> 值 $=P_{H_0}(\chi^2\ge 6.12)\approx 0.0469$.</p></li><li><p><strong>注</strong>  对于 $a$ 行 $b$ 列, 当 $H_0$ 成立时, 其未知参数个数为 $s=(a-1)+(b-1)$.</p><p>  因此卡方自由度为:</p><script type="math/tex; mode=display">  ab-1-s=ab-1-(a-1)-(b-1)=(a-1)(b-1).</script></li></ul><h2 id="似然比检验"><a href="#似然比检验" class="headerlink" title="似然比检验"></a>似然比检验</h2><ul><li><p><strong>例</strong>  两种硬币 ($p=0.5$, $p=0.7$) 投掷 $n=10$ 次, 正面向上 $X=x$ 次. 提出假设 $H_0:p=0.5$ v.s. $p=0.7$. 考虑</p><script type="math/tex; mode=display">  \dfrac{P_{H_0}(X=x)}{P_{H_1}(X=x)}\le c\leftrightarrow x 的范围</script><p>  我们需要控制</p><script type="math/tex; mode=display">  P_{H_0}\Big(似然比\le c\Big)\le\alpha.</script></li><li><p><strong>注</strong></p><ul><li>当 $H_0$, $H_1$ 均为简单假设时 (<strong>N-P</strong>), 证明: 似然比检验最优 (功效最大).</li><li>当 $H_0$, $H_1$ 不全为简单假设时, 似然比检验一般不最优, 但通常表现不错.</li></ul></li><li><p><strong>定义(广义似然比)</strong>  $H_0:\theta\in\Theta_0$ v.s. $H_1:\theta\in\Theta_1$, $X_1,\cdots,X_n$ 为随机样本.</p><p>  考虑广义似然比</p><script type="math/tex; mode=display">  \Lambda^*:=\dfrac{\sup_{\theta\in\Theta_0}L(\theta)}{\sup_{\theta\in\Theta_1}L(\theta)}</script><p>  基于技术原因, 检验统计量选为</p><script type="math/tex; mode=display">  \Lambda:=\dfrac{\sup_{\theta\in\Theta_0}L(\theta)}{\sup_{\theta\in\Theta_0\cup\Theta_1}L(\theta)}=\min\{\Lambda^*,1\}=\Lambda(X_1,\cdots,X_n).</script><p>  $\Lambda$ 越小则越反对 $H_0$ (拒绝域的形状). 选择 $\lambda_0$ 使</p><script type="math/tex; mode=display">  P_{H_0}(\Lambda\le\lambda_0)\le\alpha.</script><p>  至此得到了检验准则.</p></li><li><p><strong>定理</strong>  在一定(光滑性)条件下, 当 $n\rightarrow\infty$ 时, 在 $H_0$ 为真前提下:</p><script type="math/tex; mode=display">  -2\log\Lambda\rightarrow\chi^2(d).</script><p>  其中自由度 $d=\dim(\Theta_0\cup\Theta_1)-\dim(\Theta_0)$. 这里的 $\dim$ 指自由参数的个数.</p></li><li><p><strong>例(多项分布检验)</strong>  $H_0:p_1=p_1^<em>$, $\cdots$, $p_k=p_k^</em>$, 观测频数分别为 $n_1,\cdots,n_k$.</p></li><li><p><strong>解答</strong>  得到</p><script type="math/tex; mode=display">  L(p_1,\cdots,p_k)=C_n^{n_1,\cdots,c_k}p_1^{n_1}\cdots p_k^{n_k}.</script><p>  因此</p><script type="math/tex; mode=display">  \Lambda=\dfrac{\sup_{\theta\in\Theta_0}L(\theta)}{\sup_{\theta\in\Theta_0\cup\Theta_1}L(\theta)}=\dfrac{L(p_1^0,\cdots,p_k^0)}{L(p_1^*,\cdots,p_k^*)}.</script><p>  已知</p><script type="math/tex; mode=display">  n_i=np_i^*,E_i=np_i^0,O_i=n_i.</script><p>  且</p><script type="math/tex; mode=display">  x\log\dfrac{x}{x_0}\stackrel{Taylor}{=}0+(x-x_0)+\dfrac{1}{2}\dfrac{(x-x_0)^2}{x_0}+\cdots</script><p>  计算得</p><script type="math/tex; mode=display">  \begin{aligned}  -2\log\Lambda&=-2\sum_{i=1}^{k}\log\big(\dfrac{p_i^0}{p_i^*}\big)^{n_i}\\  &=-2\sum_{i=1}^{k}n_i\log\dfrac{p_i^0}{p_i^*}\\  &=2\sum_{i=1}^{k}O_i\log\dfrac{O_i}{E_i}\\  &=\sum_{i=1}^{k}\dfrac{(O_i-E_i)^2}{E_i}+\cdots.  \end{aligned}</script><p>  考虑到 $\dim(\Theta_0)=0$, $\dim(\Theta_0\cup\Theta_1)=k-1$, 因此给出</p><script type="math/tex; mode=display">  \sum_{i=1}^{k}\dfrac{(O_i-E_i)^2}{E_i}\stackrel{近似}{\sim}\chi^2(k-1).</script></li></ul><h2 id="两独立总体比较"><a href="#两独立总体比较" class="headerlink" title="两独立总体比较"></a>两独立总体比较</h2><ul><li><p>两独立总体:</p><p>  | 总体 | 均值    | 方差         | 样本 (iid)       |<br>  | —— | ———- | —————— | ———————— |<br>  | $X$  | $\mu_1$ | $\sigma_1^2$ | $X_1,\cdots,X_n$ |<br>  | $Y$  | $\mu_2$ | $\sigma_2^2$ | $Y_1,\cdots,Y_m$ |</p></li><li><p><strong>定义(比较均值)</strong>:</p><p>  给出 $E(\overline{X}-\overline{Y})=\mu_1-\mu_2$, $Var(\overline{X}-\overline{Y})=\dfrac{\sigma_1^2}{n}+\dfrac{\sigma_2^2}{m}=se^2$. 参考置信区间部分.</p></li><li><p><strong>定理</strong>  给出 $W_1\sim\chi^2(k_1)$, $W_2\sim\chi^2(k_2)$, 且 $W_1,W_2$ 独立, 我们有</p><script type="math/tex; mode=display">  \dfrac{W_1/k_1}{W_2/k_2}\sim F(k_1,k_2).</script></li><li><p><strong>定义(比较方差)</strong>: 假设 $X$, $Y$ 均为正态. 提出假设 $H_0:\sigma_1^2=\sigma_2^2$ v.s. $H_1:\sigma_1^2\ne\sigma_2^2$.</p><script type="math/tex; mode=display">  \dfrac{(n-1)S_1^2}{\sigma_1^2}\sim\chi^2(n-1), \dfrac{(m-1)S_2^2}{\sigma_2^2}\sim\chi^2(m-1).</script><p>  考虑检验统计量(依赖于<strong>样本</strong>或<strong>已知参数</strong>)</p><script type="math/tex; mode=display">  \dfrac{S_1^2}{S_2^2}.</script><p>  当 $H_0$ 为真时, 有</p><script type="math/tex; mode=display">  \dfrac{S_1^2}{S_2^2}\sim F(n-1,m-1).</script><p>  检验准则为当</p><script type="math/tex; mode=display">  \dfrac{S_1^2}{S_2^2}\ge F_{\tfrac{\alpha}{2}}(n-1,m-1)\,或\,\dfrac{S_1^2}{S_2^2}\le F_{1-\tfrac{\alpha}{2}}(n-1,m-1)</script><p>  时拒绝原假设.</p></li><li><p><strong>注</strong>  由定义 $F_{1-\tfrac{\alpha}{2}}(n-1,m-1)=\dfrac{1}{F_{\tfrac{\alpha}{2}}(m-1,n-1)}$.</p></li><li><p><strong>例(比较成功率/失败率)</strong>  阿司匹林对降低心脏病发病率的有效性.</p><p>  |          | 心脏病发作 | 心脏病未发作 | 合计  | 发作率 |<br>  | ———— | ————— | —————— | ——- | ——— |<br>  | 阿司匹林 | 139        | 10898        | 11037 | 0.0126 |<br>  | 安慰剂   | 239        | 10795        | 11034 | 0.0217 |</p><p>  提出假设 $H_0:p_1=p_2$ (无效) v.s. $H_1:p_1&lt;p_2$ (有效), 检验统计量为 $P_1-P_2$.</p><p>  容易得到 $E(P_1-P_2)=p_1-p_2$, $Var(P_1-P_2)=\dfrac{p_1(1-p_1)}{n_1}+\dfrac{p_2(1-p_2)}{n_2}$.</p><p>  那么</p><script type="math/tex; mode=display">  \dfrac{(P_1-P_2)-(p_1-p_2)}{se}\stackrel{近似}{\sim}N(0,1).</script><p>  在 $H_0$ 为真前提下, 有</p><script type="math/tex; mode=display">  se^2=p(1-p)(\dfrac{1}{n_1}+\dfrac{1}{n_2})\approx p^*(1-p^*)(\dfrac{1}{n_1}+\dfrac{1}{n_2}).</script><p>  其中 $p^<em>=\dfrac{k_1+k_2}{n_1+n_2}$, 得 $se^2\approx\hat{se}^2=0.00175^2$. 结合 $\dfrac{P_1-P_2}{\hat{se}}\stackrel{近似}{\sim}N(0,1)$, 得 <em>*P</em></em> 值</p><script type="math/tex; mode=display">  P\Big(\dfrac{P_1-P_2}{\hat{se}}\le\dfrac{0.0126-0.0217}{0.00175}\Big)\approx P(Z\le -5.20)\approx 10^{-7}.</script><p>  因此有理由拒绝 $H_0$.</p></li><li><p><strong>注</strong></p><ul><li>随机分组.</li><li>双盲实验.</li><li>$n$ 充分大.</li></ul></li><li><p><strong>例(行驶里程)</strong>  比较两种油 <strong>A</strong> 与 <strong>B</strong> 的行驶里程.</p><p>  |          | 样本容量 | 平均里程 | 样本标准差 |<br>  | ———— | ———— | ———— | ————— |<br>  | 油 <strong>A</strong> | 50       | 25       | 5.00       |<br>  | 油 <strong>B</strong> | 50       | 26       | 4.00       |</p><p>  提出假设 $H_0:\mu_A=\mu_B$ v.s. $H_1:\mu_A\ne\mu_B$, 检验统计量为 $\overline{X}_A-\overline{X}_B$.</p><p>  在 $H_0$ 为真前提下, 有</p><script type="math/tex; mode=display">  \dfrac{\overline{X}_A-\overline{X}_B}{\sqrt{\tfrac{S_1^2}{n_1}+\tfrac{S_2^2}{n_2}}}\sim N(0,1).</script><p>  其中 $\hat{se}\approx 0.905$. 得 <strong>P</strong> 值</p><script type="math/tex; mode=display">  P\Big(\vert\dfrac{\overline{X}_A-\overline{X}_B}{\hat{se}}\vert\ge\vert\dfrac{25-26}{0.905}\vert\Big)\approx P(\vert Z\vert\ge 1.1)\approx 0.2714.</script><p>  认为哪种油行驶里程更长的理由均不充分.</p></li></ul><h2 id="两相关总体比较"><a href="#两相关总体比较" class="headerlink" title="两相关总体比较"></a>两相关总体比较</h2><ul><li><p><strong>例(行驶里程-改进)</strong>  同一辆车不同日子加不同油, 记录行驶里程.</p><p>  | 车号     | 油 A     | 油 B     | 差异 ($d_i$) |<br>  | ———— | ———— | ———— | —————— |<br>  | 1        | 27.01    | 26.95    | 0.06         |<br>  | 2        | 20.00    | 20.44    | -0.44        |<br>  | $\cdots$ | $\cdots$ | $\cdots$ | $\cdots$     |<br>  | 10       | 25.22    | 26.01    | -0.79        |<br>  | 均值     | 25.20    | 25.80    | -0.60        |<br>  | 标准差   | 4.27     | 4.10     | 0.61         |</p><p>  提出假设 $H_0:\mu_d=0$ v.s. $H_1:\mu_d\ne 0$, 检验统计量为 $\overline{d}$.</p><p>  假设 $d_i$ 服从正态分布. 在 $H_0$ 为真前提下, 有</p><script type="math/tex; mode=display">  \dfrac{\overline{d}}{\tfrac{S_d}{\sqrt{n}}}\sim t(n-1).</script><p>  得 <strong>P</strong> 值</p><script type="math/tex; mode=display">  P\Big(\vert t(9)\vert\ge\vert\dfrac{-0.60}{\tfrac{0.61}{\sqrt{10}}}\vert\Big)\approx 0.012.</script><p>  有理由拒绝 $H_0$, 两种油的行驶里程有差距.</p></li><li><p><strong>注</strong>  假设检验不能检验试验设计, 仅对数据负责; 功能有限, 作为决策辅助.</p></li></ul><h2 id="Bayes-假设检验"><a href="#Bayes-假设检验" class="headerlink" title="Bayes 假设检验"></a>Bayes 假设检验</h2><ul><li><p><strong>例</strong>  两种硬币 ($p=0.5$, $p=0.7$) 投掷 $n=10$ 次, 正面向上 $X=x$ 次. 提出假设 $H_0:p=0.5$ v.s. $p=0.7$​. 考虑</p><script type="math/tex; mode=display">  \dfrac{P(H_0\mid x)}{P(H_1\mid x)}=\dfrac{P(H_0)P(x\mid H_0)}{P(H_1)P(x\mid H_1)}<1</script><p>  则拒绝 $H_0$.</p></li><li><p><strong>注</strong>  给出一个特别的例子, $H_0:\theta=\theta_0$, $\Theta$ 连续. 则 $P(H_0\mid x)=0$, 此时似乎总是会拒绝 $H_0$? (陈书 <strong>Chap 5.28</strong>)</p></li></ul><h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><h3 id="决策"><a href="#决策" class="headerlink" title="决策"></a>决策</h3><ul><li>拒绝 $H_0$ 或不拒绝 $H_0$.</li><li>检验=决策准则 $\Leftrightarrow$ 拒绝域 $R$ 的划分.</li><li>关键:<ul><li>选择合适的检验统计量.</li><li>确定拒绝域的形状 (由 $H_1$ 决定).</li></ul></li><li>拒绝 $H_0$ 有时也称观测值是显著的.</li></ul><h3 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h3><ul><li><p>统计学中没有绝对的证实或证伪.</p><script type="math/tex; mode=display">  \alpha(R):=P_{\theta}((X_1,\cdots,X_n)\in R\mid H_0).\\  \beta(R):=P_{\theta}((X_1,\cdots,X_n)\in R^c\mid H_1).</script></li><li><p>检验程序的属性, 不是样本的属性. 样本做决策要么正确要么错误.</p><script type="math/tex; mode=display">  \alpha(R)\le\alpha.\\  \beta(R)\le\beta.</script><p>  预先指定的可接受的长期错误率.</p></li></ul><h3 id="显著性检验-v-s-Neyman-Pearson-检验"><a href="#显著性检验-v-s-Neyman-Pearson-检验" class="headerlink" title="显著性检验 v.s. Neyman-Pearson 检验"></a>显著性检验 v.s. Neyman-Pearson 检验</h3><ul><li><p>显著性检验: 只控制 $\alpha(R)\le\alpha$.</p></li><li><p><strong>Neyman-Pearson</strong> 假设检验: 强调两类错误、功效, $H_0,H_1$ 地位不均等.</p></li><li><p>不拒绝 $H_0$ $\ne$ 接受 $H_0$.</p></li><li><p>$\beta(R)$ 越小 (功效越大), 当 $H_0$ 不真时, 越有可能拒绝 $H_0$; 当观测支持 $H_0$, 则可以接受 $H_0$.</p></li><li><p>若忽略了对 $\beta(R)$ 的系统控制 (常见情形), 将导致对结果及下一步工作方向的误判.</p></li><li><p><strong>例</strong>  $H_0:\mu\ge 5$, $H_1:\mu&lt;5$. $n=10$, $\sigma=0.01$, $\alpha=0.01$.</p></li><li><p><strong>解答</strong>  临界值</p><script type="math/tex; mode=display">  c=\mu_0-Z_{\alpha}\dfrac{\sigma}{\sqrt{n}}\approx 4.993.</script></li></ul><h3 id="P-值"><a href="#P-值" class="headerlink" title="P 值"></a>P 值</h3><ul><li>一次具体的观测值没有概率可言, <strong>P</strong> 不能衡量决策错误的概率. (<strong>ASA</strong> 文章)</li></ul><h3 id="卡方检验-——-多项分布的检验"><a href="#卡方检验-——-多项分布的检验" class="headerlink" title="卡方检验 —— 多项分布的检验"></a>卡方检验 —— 多项分布的检验</h3><ul><li><strong>例</strong>  $H_0: p_1=p$, $p_2=1-p$. 此时<script type="math/tex; mode=display">  \begin{aligned}  \chi^2&=\dfrac{(O_1-np_1)^2}{np_1}+\dfrac{(O_2-np_2)^2}{np_2}\\  &=\dfrac{(O_1-np)^2}{np}+\dfrac{(O_1-np)^2}{n(1-p)}\\  &=\dfrac{(O_1-np)^2}{np(1-p)}\\  &\stackrel{近似}{\sim} N^2(0,1)=\chi^2(1).  \end{aligned}</script></li></ul><h3 id="统计显著-ne-实际显著"><a href="#统计显著-ne-实际显著" class="headerlink" title="统计显著 $\ne$ 实际显著"></a>统计显著 $\ne$ 实际显著</h3><ul><li><p><strong>例</strong>  投掷骰子 $n=6\times 10^{10}$ 次​.</p><p>  | 点数               | 1         | 2                  | 3                 | 4                | 5                 | 6                  | 总计              |<br>  | ————————— | ————- | ————————— | ————————- | ———————— | ————————- | ————————— | ————————- |<br>  | 观测频数 $10^{10}$ | $-10^{6}$ | $1.5\times 10^{6}$ | $-2\times 10^{6}$ | $4\times 10^{6}$ | $-3\times 10^{6}$ | $0.5\times 10^{6}$ | $6\times 10^{10}$ |</p><p>  $H_0:$ 分布均匀, $H_1:$ 分布不均匀. </p></li><li><p>计算得到 $\chi^2=3250$, 此时 <strong>P</strong> 值 $\ll 0.0001$. 因此拒绝 $H_0$, 统计显著. </p></li><li><p>实际上 $\vert\hat p_i-\dfrac{1}{6}\vert\sim 10^{-4}$, 实际角度视为无差异, 实际不显著.</p></li><li><p>$n$ 过大, 明察秋毫; $\chi^2$ 统计量关于 $n$ 是非齐次的.</p></li></ul>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;Chap-7-假设检验&quot;&gt;&lt;a href=&quot;#Chap-7-假设检验&quot; class=&quot;headerlink&quot; title=&quot;Chap 7 假设检验&quot;&gt;&lt;/a&gt;Chap 7 假设检验&lt;/h1&gt;&lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot;</summary>
        
      
    
    
    
    <category term="Math" scheme="http://chengsx21.github.io/categories/Math/"/>
    
    <category term="Probability Theory" scheme="http://chengsx21.github.io/categories/Math/Probability-Theory/"/>
    
    
    <category term="Probability Theory" scheme="http://chengsx21.github.io/tags/Probability-Theory/"/>
    
  </entry>
  
  <entry>
    <title>概率论与数理统计 笔记6</title>
    <link href="http://chengsx21.github.io/2023/04/05/gai-lu-lun-yu-shu-li-tong-ji-bi-ji-6/"/>
    <id>http://chengsx21.github.io/2023/04/05/gai-lu-lun-yu-shu-li-tong-ji-bi-ji-6/</id>
    <published>2023-04-05T09:27:40.000Z</published>
    <updated>2023-09-21T17:09:54.248Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Chap-6-参数估计"><a href="#Chap-6-参数估计" class="headerlink" title="Chap 6 参数估计"></a>Chap 6 参数估计</h1><ul><li><p><strong>引入</strong>  检测某厂一大批电子元件寿命指标是否合格.</p></li><li><p><strong>总体</strong></p><ul><li>所需检测的电子元件寿命;</li><li>统计分析问题中研究的对象全体的某个数字特征 $X$.</li><li>元件寿命的分布;</li><li>变量 $X$ 的分布.</li></ul></li><li><p><strong>统计总体</strong>  一个概率分布.</p></li><li><p><strong>注</strong></p><ul><li>有限总体;</li><li>无限总体.</li></ul></li><li><p><strong>统计模型</strong></p><ul><li>一族概率分布;</li><li>参数模型 (正态模型);</li><li>非参数模型.</li></ul></li><li><p><strong>样本</strong></p><ul><li>$(X_1,\cdots,X_n)$, 其中 $X_i$ 来自总体 $X$, $n$ 为样本容量;</li><li>获取方式:<ul><li>试验;</li><li>观察 (完全 / 不完全).</li></ul></li></ul></li><li><p><strong>简单随机抽样</strong></p><ul><li>总体个数 $N$ 有限;</li><li>无放回;</li><li>容量为 $n$ 的样本抽取出来的概率为 $p=\dfrac{1}{C_N^n}$.</li></ul></li><li><p><strong>随机样本</strong></p><ul><li>$X_1,\cdots,X_n$ 独立同分布, 例: 有放回 / 近似有放回 ($n&lt;&lt;N$).</li></ul></li><li><p><strong>统计量</strong></p><ul><li><p>$T(X_1,\cdots,X_n)$ - 完全由样本决定, 是一种数据简化方式.</p></li><li><p>样本均值</p><script type="math/tex; mode=display">  \overline{X}=\dfrac{1}{n}\sum_{i=1}^{n}X_i.</script></li><li><p>样本方差 </p><script type="math/tex; mode=display">  S^2=\dfrac{1}{n-1}\sum_{i=1}^{n}(X_i-\overline{X})^2.</script></li></ul></li><li><p><strong>统计推断</strong></p><ul><li>总体为因, 样本为果;</li><li>总体决定样本, 样本推断总体;</li><li>经典方法 (频率) v.s. <strong>Bayes</strong>方法.</li><li><strong>例</strong>  $Y_i=aX_i+\varepsilon_i$.<ul><li>求 $a$. $(X_i,Y_i)(1\le i\le n)\rightarrow a\approx\hat{a}$ (模型推断 参数估计)</li><li>已知 $a=\hat{a}$, 观测到 $Y_i$, 求 $X_i$ (变量推断)</li></ul></li><li><strong>例</strong>  元件寿命.<ul><li>假设 $X\sim Exp(\lambda)$, 求 $\lambda$ (参数估计)</li><li>假设合格标准 $E(X)\ge L$, 需建立可操作的检验标准: $X\ge l$, $\mu$ 未知, 求 $l$ (假设检验)</li></ul></li></ul></li></ul><h2 id="矩估计"><a href="#矩估计" class="headerlink" title="矩估计"></a>矩估计</h2><ul><li><p><strong>定义(样本矩)</strong>  $X_1,\cdots,X_n$ 独立同分布, 定义其 $k$ 阶<strong>原点矩</strong>:</p><script type="math/tex; mode=display">  a_k=\dfrac{1}{n}\sum_{i=1}^{n}X_i^k\stackrel{\textbf{LLN}}{\longrightarrow}E(X^k).</script><p>  其 $k$ 阶<strong>中心矩</strong>:</p><script type="math/tex; mode=display">  m_k=\dfrac{1}{n}\sum_{i=1}^{n}(X_i-\overline{X})^k\stackrel{\textbf{LLN}}{\longrightarrow}E\Big[(X-\mu)^k\Big].</script></li><li><p><strong>例</strong>  $X\sim N(\mu,\sigma^2)$. 考虑其均值、方差对应的样本矩.</p></li><li><p><strong>解答</strong></p><script type="math/tex; mode=display">  \mu=E(X)\approx\overline{X}=a_1;\\  \sigma^2=E\Big[(X-\mu)^2\Big]\approx\dfrac{1}{n}\sum_{i=1}^{n}(X_i-\overline{X})^2=m_2.</script></li><li><p><strong>例</strong>  $X\sim Exp(\lambda)$. 考虑其均值、方差对应的样本矩, 并给出 $\lambda$ 的矩估计.</p></li><li><p><strong>解答</strong></p><script type="math/tex; mode=display">  \dfrac{1}{\lambda}=E(X)\approx\overline{X}=a_1\Rightarrow\lambda=\dfrac{1}{a_1};\\  \dfrac{1}{\lambda^2}=E\Big[(X-E(X))^2\Big]\approx\dfrac{1}{n}\sum_{i=1}^{n}(X_i-\overline{X})^2=m_2\Rightarrow\lambda=\Big(\dfrac{1}{m_2}\Big)^{\tfrac{1}{2}}.</script><p>  我们通常使用<strong>低阶矩</strong>进行估计.</p></li></ul><h2 id="极大似然估计-MLE"><a href="#极大似然估计-MLE" class="headerlink" title="极大似然估计 (MLE)"></a>极大似然估计 (MLE)</h2><ul><li><p><strong>定义(似然函数)</strong>  假设 $X_1,\cdots,X_n$ 的联合分布 $f(x_1,\cdots,x_n;\theta)$ (<strong>PMF\\PDF</strong>), 其中 $\theta$ 为参数. 对于观测 $(X_1,\cdots,X_n)$ 的似然函数为</p><script type="math/tex; mode=display">  L(\theta):=f(X_1,\cdots,X_n;\theta).</script></li><li><p><strong>注</strong></p><ul><li><p>具体观测数据通常记为 $(x_1,\cdots,x_n)$, 视为 $(X_1,\cdots,X_n)$ 的具体的实现值;</p></li><li><p>离散情形下, $L(\theta)$ 为出现 $(X_1,\cdots,X_n)$ 的概率;</p></li><li><p>若 $X_1,\cdots,X_n$ 独立同分布, 总体分布为 $f_1(x;\theta)$ (<strong>PMF\\PDF</strong>), 那么</p><script type="math/tex; mode=display">  L(\theta)=f_1(X_1;\theta)f_1(X_2;\theta)\cdots f_1(X_n;\theta).</script></li></ul></li><li><p><strong>例</strong>  $X_i\sim N(\mu,\sigma^2)$ 独立同分布, 其中 $\mu$,$\sigma^2$ 未知. 考虑观测的似然函数.</p></li><li><p><strong>解答</strong></p><script type="math/tex; mode=display">  L(\mu,\sigma^2)=\prod_{i=1}^{n}\Big(\dfrac{1}{\sqrt{2\pi}\sigma}e^{-\tfrac{(X_i-\mu)^2}{2\sigma^2}}\Big).</script></li><li><p><strong>定义(MLE)</strong>  定义 $\theta$ 的 <strong>MLE</strong> 为</p><script type="math/tex; mode=display">  \theta^{*}=\arg\max_{\theta}L(\theta).</script><p>  其中 $\theta^{<em>}=\theta^{</em>}(X_1,\cdots,X_n)$.</p></li><li><p><strong>解答续</strong>  考虑方程组</p><script type="math/tex; mode=display">  \begin{cases}  \dfrac{\partial\log L(\mu,\sigma^2)}{\partial\mu}=0;\\  \dfrac{\partial\log L(\mu,\sigma^2)}{\partial\sigma^2}=0.  \end{cases}</script><p>  解得</p><script type="math/tex; mode=display">  \begin{cases}  \mu^{*}=\overline{X},\\  (\sigma^2)^{*}=\sum\limits_{i=1}^{n}(X_i-\overline{X})^2.  \end{cases}</script><p>  经验证 $(\mu^{<em>},(\sigma^2)^{</em>})$ 为 $(\mu,\sigma^2)$ 的 <strong>MLE</strong>.</p></li><li><p><strong>注</strong>  $(\sigma^2)^{<em>}=(\sigma^{</em>})^2$ (<strong>MLE</strong> 的不变性).</p></li><li><p><strong>例</strong>  随机变量 $X_i\sim U(0,\theta)$ 独立同分布, $\theta$ 未知. 求 $\theta$ 的 <strong>MLE</strong>.</p></li><li><p><strong>解答</strong></p><script type="math/tex; mode=display">  L(\theta)=  \begin{cases}  \cfrac{1}{\theta^n}, &X_i\in(0,\theta), \theta\ge\max\{X_1,\cdots,X_n\}\\  0, &其他.  \end{cases}</script><p>  我们得到</p><script type="math/tex; mode=display">  \theta^{*}=\max\{X_1,\cdots,X_n\}.</script></li><li><p><strong>例</strong>  总体 <strong>PDF</strong> 为 $f(x;\theta)=\dfrac{1}{\pi(1+(x-\theta)^2)}$, $x\in\mathbb{R}$ (<strong>Cauchy</strong> 分布).</p></li><li><p><strong>解答</strong></p><ul><li>无矩 $\Rightarrow$ 无矩估计;</li><li>似然方程 $\sum\limits_{i=1}^{n}\dfrac{X_i-\theta}{1+(X_i-\theta)^2}=0$, 不易求解;</li><li>合理估计, $\hat{\theta}$ 为样本中位数.</li></ul></li></ul><h2 id="优良性准则"><a href="#优良性准则" class="headerlink" title="优良性准则"></a>优良性准则</h2><ul><li><p><strong>定义(无偏性)</strong>  定义 $\hat{\theta}=\hat{\theta}(X_1,\cdots,X_n)$ 为 $\theta$ 的估计量 (随机变量). 我们称一个估计 $\hat\theta$ 的偏差 (<strong>Bias</strong>):</p><script type="math/tex; mode=display">E_{\theta}(\hat\theta-\theta)=E_{\theta}(\hat\theta)-\theta.</script><p>若 $E_{\theta}(\hat\theta-\theta)=0$, $\forall\,\theta$, 则称 $\hat\theta$ 为 $\theta$ 的一个无偏估计量.</p></li><li><p><strong>注</strong></p><ul><li>一般地, $E_{\theta}(\hat g(X_1,\cdots,X_n)-g(\theta))=0$, $\forall\,\theta\,\Leftrightarrow$ $\hat{g}$ 为 $g(\theta)$ 的无偏估计;</li><li>无偏 $\Leftrightarrow$ 无系统偏差;</li><li>$\dfrac{1}{N}\sum\limits_{m=1}^{N}\hat{\theta}(X_1^{(m)},\cdots,X_n^{(m)})\stackrel{a.s.}{\longrightarrow}E(\hat\theta)\stackrel{无偏}{=}\theta$;</li><li>无偏性的重要性视情形而定.</li></ul></li><li><p><strong>例</strong>  $E(X)=\mu$, $Var(X)=\sigma^2$.</p></li><li><p><strong>解答</strong></p><ul><li>$E(\overline{X})=\mu\Rightarrow \overline{X}$ 为 $\mu$ 的无偏估计;</li><li>$E(m_2)=E\Big(\dfrac{1}{n}\sum\limits_{i=1}^{n}(X_i-\overline{X})^2\Big)=\dfrac{n-1}{n}\sigma^2$;</li><li>$E(S^2)=E\Big(\dfrac{1}{n-1}\sum\limits_{i=1}^{n}(X_i-\overline{X})^2\Big)=\sigma^2$.</li></ul></li><li><p><strong>例</strong>  $X_i\stackrel{iid}{\sim}U(0,\theta)$.</p></li><li><p><strong>解答</strong></p><ul><li>矩估计 $\hat\theta=2\overline{X}$;</li><li><strong>MLE</strong> $\theta^{*}=\max\{X_1,\cdots, X_n\}$;</li><li>计算可得 $E(\hat\theta)=\theta,\,E(\theta^{*})=\dfrac{n}{n+1}\theta$.</li></ul></li><li><p><strong>注</strong>  <strong>MLE</strong> 可也能是有偏的 (本例中即为系统偏小).</p></li><li><p><strong>定义(均方误差准则)</strong>  定义一个估计 $\hat\theta$ 的均方误差 (<strong>MSE</strong>):</p><script type="math/tex; mode=display">  E_{\theta}\Big[(\hat\theta-\theta)^2\Big]=Var(\hat\theta)+E_{\theta}^2(\hat\theta-\theta).</script><p>  其中 $Var(\hat\theta)$ 代表着精确度, $E_{\theta}^2(\hat\theta-\theta)$ 代表着准确度.</p></li><li><p><strong>定义</strong>  假定 $\hat\theta_1$, $\hat\theta_2$ 均为 $\theta$ 的无偏估计, 若</p><script type="math/tex; mode=display">  \forall\,\theta,\,Var(\hat\theta_1)\le Var(\hat\theta_2)</script><p>  且</p><script type="math/tex; mode=display">  \exists\,\theta_0,\,Var_{\theta_0}(\hat\theta_2)<Var_{\theta_0}(\hat\theta_1).</script><p>  则称在均方误差意义下 $\hat\theta_1$ 优于 $\hat\theta_2$.</p></li><li><p><strong>例</strong>  $E(X)=\mu$.</p></li><li><p><strong>解答</strong>  </p><script type="math/tex; mode=display">  E(\overline{X})=E(X_1)=E\Big(\dfrac{1}{2}X_1+\dfrac{1}{2}X_2\Big)=\mu.</script><script type="math/tex; mode=display">  Var(\overline{X})=\dfrac{1}{n}\sigma^2,\,Var(X_1)=\sigma^2,\,Var\Big(\dfrac{1}{2}X_1+\dfrac{1}{2}X_2\Big)=\dfrac{1}{2}\sigma^2.</script></li><li><p><strong>注</strong>  有时也可称为“有效性准则”.</p></li><li><p><strong>定义</strong>  假定 $\hat\theta_0$ 为 $\theta$ 的无偏估计, 若对任意 $\theta$ 与 $\theta$ 的无偏估计 $\hat\theta$</p><script type="math/tex; mode=display">  Var(\hat\theta_0)\le Var(\hat\theta)</script><p>  则称 $\hat\theta_0$ 为最小方差无偏估计 (<strong>MVUE</strong>).</p></li><li><p><strong>例</strong>  $X\sim N(\mu,\sigma^2)$.</p></li><li><p><strong>解答</strong>  由于</p><script type="math/tex; mode=display">E(m_2)=\dfrac{n-1}{n}\sigma^2,\,E(S^2)=\sigma^2.</script><p>因此计算可得</p><script type="math/tex; mode=display">E\Big[(m_2-\sigma^2)^2\Big]=\cdots<E\Big[(S^2-\sigma^2)^2\Big]=\cdots</script><p>这是用低偏差换了方差.</p></li><li><p><strong>定义</strong></p><ul><li>$\hat\theta=\hat\theta(X_1,\cdots,X_n)$ 的分布称为抽样分布;</li><li>$\hat\theta=\hat\theta(X_1,\cdots,X_n)$ 的标准差称为标准误差, 记为 $se(\hat\theta)$.</li></ul></li><li><p><strong>定义(大样本性质)</strong>  估计量 $\hat\theta$ 当 $n\rightarrow\theta$ 时的性质.</p></li><li><p><strong>定义(渐进无偏性)</strong>  有 $\lim\limits_{n\rightarrow\infty} E(\hat\theta-\theta)=0$;</p></li><li><p><strong>定义(相合性)</strong>  若 $\forall\,\varepsilon&gt;0$, 有 $\lim\limits_{n\rightarrow\infty}P(\left|\hat\theta-\theta\right|\ge\varepsilon)=0$, 则称 $\hat\theta$ 为 $\theta$ 的一个相合估计, 即 $\hat\theta\stackrel{P}{\longrightarrow}\theta$.</p><ul><li><strong>WLLN</strong> $\Rightarrow$ $\overline{X}$ 是 $\mu$ 的一个相合估计;</li><li>相合性是良好点估计的自然要求.</li></ul></li><li><p><strong>例</strong>  我们得到</p><script type="math/tex; mode=display">  \begin{aligned}  m_2&=\dfrac{1}{n}\sum\limits_{i=1}^{n}(X_i-\overline{X})^2\\  &=\dfrac{1}{n}\sum\limits_{i=1}^{n}(X_i-\mu-\overline{X}+\mu)^2\\  &=\dfrac{1}{n}\sum\limits_{i=1}^{n}(X_i-\mu)^2-(\overline{X}-\mu)^2\\  &\stackrel{P}{\rightarrow}E\Big[(X-\mu)^2\Big]\\  &=\sigma^2.  \end{aligned}</script><p>  进而有</p><script type="math/tex; mode=display">  S^2=\dfrac{n}{n-1}m_2\stackrel{P}{\rightarrow}\sigma^2.</script></li><li><p><strong>定义(渐进正态性)</strong>  $\dfrac{\hat\theta-\theta}{se(\hat\theta)}\stackrel{d}{\rightarrow}Z\sim(0,1)$ (渐进正态估计).</p><ul><li><p>$\hat\theta\stackrel{近似}{\sim}N(0,se^2(\hat\theta))$;</p></li><li><p><strong>CLT</strong> $\Rightarrow\overline{X}$ 为 $\mu$ 的一个渐进正态估计, $se(\overline{X})=\dfrac{\sigma}{\sqrt{n}}$.</p></li></ul></li></ul><h2 id="置信区间-Condifence-Interval"><a href="#置信区间-Condifence-Interval" class="headerlink" title="置信区间 (Condifence Interval)"></a>置信区间 (Condifence Interval)</h2><ul><li><p><strong>定义(置信区间)</strong>  $\forall\,\alpha\in(0,1)$, $\forall\,\theta$, 有 $\hat\theta_i=\hat\theta_i(X_1,\cdots,X_n)$, 其中 $i=1,2$, 使得</p><script type="math/tex; mode=display">  P(\hat\theta_1<\theta<\hat\theta_2)\ge 1-\alpha.</script><p>  则称 $(\hat\theta_1,\hat\theta_2)$ 为 $\theta$ 的 $(1-\alpha)$ 置信的区间估计 (双侧).</p></li><li><p><strong>注</strong></p><ul><li>$\alpha$ 通常取为 $0.05$, $0.01$, $0.1$;</li><li>置信 (水平、系数、度) 是针对方法的;</li><li>可靠性优先原则 (先保证 $P(\hat\theta_1&lt;\theta&lt;\hat\theta_2)\ge 1-\alpha$), 再尽量提升精度 (通常用 $E(\hat\theta_2-\hat\theta_1)$ 刻画).</li></ul></li><li><p><strong>例</strong>  $X\sim N(\mu,\sigma^2)$, <strong>已知</strong> $\sigma^2$, 给出 $\mu$ 的 $(1-\alpha)$ 置信区间估计.</p></li><li><p><strong>解答</strong>  注意到</p><script type="math/tex; mode=display">  \begin{aligned}  &\overline{X}-\mu\sim N(0,\dfrac{\sigma^2}{n})\\  \Longleftrightarrow&\dfrac{\overline{X}-\mu}{\frac{\sigma}{\sqrt{n}}}\sim N(0,1)\\  \Longrightarrow&P\Big(\left|\dfrac{\overline{X}-\mu}{\frac{\sigma}{\sqrt{n}}}\right|<Z_{\tfrac{\alpha}{2}}\Big)=1-\alpha.  \end{aligned}</script><p>  其中 $Z_{\tfrac{\alpha}{2}}$ 为 $N(0,1)$ 的上侧 $\dfrac{\alpha}{2}$ 分位数. 因此所求 $(1-\alpha)$ 置信的区间估计为</p><script type="math/tex; mode=display">  (\overline{X}-\frac{\sigma}{\sqrt{n}}Z_{\tfrac{\alpha}{2}},\overline{X}+\frac{\sigma}{\sqrt{n}}Z_{\tfrac{\alpha}{2}}).</script></li><li><p><strong>注</strong></p><ul><li>若 $\alpha=0.05$, 则 $Z_{\tfrac{\alpha}{2}}=Z_{0.025}\approx 1.96\approx 2$;</li><li>若用 $\overline{X}$ 估计 $\mu$, 则有 $(1-\alpha)$ 置信, 误差绝对值 $\vert\overline{X}-\mu\vert\le\frac{\sigma}{\sqrt{n}}Z_{\tfrac{\alpha}{2}}$;</li><li>给定 $\varepsilon&gt;0$, 则 $n\ge\Big(\dfrac{Z_{\frac{\alpha}{2}}\sigma}{\varepsilon}\Big)^2$ 时, 有 $(1-\alpha)$ 置信, 误差绝对值 $\le\varepsilon$.</li></ul></li><li><p><strong>例</strong>  $X\sim N(\mu,\sigma^2)$, <strong>未知</strong> $\sigma^2$, 给出 $\mu$ 的 $(1-\alpha)$ 置信区间估计.</p></li><li><p><strong>解答</strong>  注意到</p><script type="math/tex; mode=display">  \dfrac{\overline{X}-\mu}{\frac{\sigma}{\sqrt{n}}}\sim N(0,1),\\  \dfrac{(n-1)S^2}{\sigma^2}\sim\chi^2(n-1).</script><p>  注意到 $\overline{X}$, $S^2$ 相互独立, 由<strong>陈书 $P_{93-94}$</strong>可得</p><script type="math/tex; mode=display">  \dfrac{\overline{X}-\mu}{\frac{\sigma}{\sqrt{n}}}/\dfrac{S}{\sigma}\sim t(n-1).</script><p>  即</p><script type="math/tex; mode=display">  \dfrac{\overline{X}-\mu}{\frac{S}{\sqrt{n}}}\sim t(n-1).</script><p>  因此</p><script type="math/tex; mode=display">  P\Big(\left|\dfrac{\overline{X}-\mu}{\frac{S}{\sqrt{n}}}\right|<t_{\tfrac{\alpha}{2}}(n-1)\Big)=1-\alpha.</script><p>  其中 $t_{\tfrac{\alpha}{2}}(n-1)$ 为 $t(n-1)$ 分布上侧 $\dfrac{\alpha}{2}$ 分位数, 所求 $(1-\alpha)$ 置信区间估计为</p><script type="math/tex; mode=display">  (\overline{X}-\frac{S}{\sqrt{n}}t_{\tfrac{\alpha}{2}}(n-1),\overline{X}+\frac{S}{\sqrt{n}}t_{\tfrac{\alpha}{2}}(n-1)).</script></li><li><p><strong>注</strong>  $\dfrac{\overline{X}-\mu}{\frac{\sigma}{\sqrt{n}}}$, $\dfrac{\overline{X}-\mu}{\frac{S}{\sqrt{n}}}$ 成为枢轴变量.</p></li><li><p><strong>例</strong>  $X\sim N(\mu,\sigma^2)$, <strong>未知</strong> $\mu$, 给出 $\sigma^2$ 的 $(1-\alpha)$ 置信区间估计.</p></li><li><p><strong>解答</strong>  注意到</p><script type="math/tex; mode=display">  \dfrac{(n-1)S^2}{\sigma^2}\sim\chi^2(n-1).</script><p>  因此所求 $(1-\alpha)$ 置信区间估计为</p><script type="math/tex; mode=display">  \Big(\frac{(n-1)S^2}{\chi^2_{\tfrac{\alpha}{2}}(n-1)},\frac{(n-1)S^2}{\chi^2_{1-\tfrac{\alpha}{2}}(n-1)}\Big).</script></li><li><p><strong>注</strong>  我们有</p><script type="math/tex; mode=display">  \begin{aligned}  \dfrac{(n-1)S^2}{\sigma^2}&=\dfrac{\sum_{i=1}^{n}(X_i-\overline{X})^2}{\sigma^2}\\  &=\sum\limits_{i=1}^{n}\Big(\dfrac{X_i-\mu}{\sigma}\Big)^2-\Big(\dfrac{\overline{X}-\mu}{\tfrac{\sigma}{\sqrt{n}}}\Big)^2\\  &\sim\chi^2(n-1).  \end{aligned}</script></li><li><p><strong>例</strong>  $X\sim N(\mu_1,\sigma^2)$, $Y\sim N(\mu_2,\sigma^2)$ 相互独立, <strong>未知</strong> $\mu_1$, $\mu_2$, $\sigma^2$, 给出 $\mu_1-\mu_2$ 的 $(1-\alpha)$ 置信区间估计.</p></li><li><p><strong>解答</strong>  设 $X_1,\cdots,X_n$, $Y_1,\cdots,Y_m$ 为随机样本, $S_1^2$ 为 $X$ 的样本方差, $S_2^2$ 为 $Y$ 的样本方差, 则</p><script type="math/tex; mode=display">  (\overline{X}-\overline{Y})-(\mu_1-\mu_2)\sim N(0,\dfrac{\sigma^2}{n}+\dfrac{\sigma^2}{m}).</script><p>  因为</p><script type="math/tex; mode=display">  \dfrac{(n-1)S_1^2}{\sigma^2}+\dfrac{(m-1)S_2^2}{\sigma^2}\sim\chi^2(n+m-2).</script><p>  记</p><script type="math/tex; mode=display">  S^2=\dfrac{n-1}{n+m-2}S_1^2+\dfrac{m-1}{n+m-2}S_2^2.</script><p>  从而得到</p><script type="math/tex; mode=display">  \dfrac{(\overline{X}-\overline{Y})-(\mu_1-\mu_2)}{\sqrt{\dfrac{\sigma^2}{n}+\dfrac{\sigma^2}{m}}}/\dfrac{S}{\sigma}\sim t(n+m-2).</script><p>  也即</p><script type="math/tex; mode=display">  \dfrac{(\overline{X}-\overline{Y})-(\mu_1-\mu_2)}{S\sqrt{\dfrac{1}{n}+\dfrac{1}{m}}}\sim t(n+m-2).</script><p>  这是我们用到的枢轴变量, 所求 $(1-\alpha)$ 置信区间估计为</p><script type="math/tex; mode=display">  \Big(\overline{X}-\overline{Y}-t_{\tfrac{\alpha}{2}}(l)S\sqrt{\dfrac{m+n}{mn}},\overline{X}-\overline{Y}+t_{\tfrac{\alpha}{2}}(l)S\sqrt{\dfrac{m+n}{mn}}\Big).</script><p>  其中 $l=n+m-2$.</p></li><li><p><strong>定义(渐进置信区间)</strong>  通过大样本方法进行区间估计.</p></li><li><p><strong>例(选举问题)</strong>  真实支持率 $p$ 未知, $n=1200$, 观测比例 $\dfrac{684}{1200}\approx 0.57$. 给出 $p$ 的一个 $95\%$ 置信的区间估计.</p></li><li><p><strong>解答</strong>  $X_i\sim B(p)\,(1\le i\le n)$ <strong>iid</strong> (近似有放回, $n&lt;&lt;N$). 我们有</p><script type="math/tex; mode=display">  P_n=P_n(X_1,\cdots,X_n)=\dfrac{1}{n}\sum\limits_{i=1}^{n}X_i=\overline{X}.</script><p>  因此</p><script type="math/tex; mode=display">  E(P_n)=p,\,Var(P_n)=\dfrac{p(1-p)}{n}.</script><p>  由 <strong>CLT</strong>, 得到</p><script type="math/tex; mode=display">  \dfrac{P_n-p}{\sqrt{\tfrac{p(1-p)}{n}}}\sim N(0,1)\Rightarrow P\Big(|\dfrac{P_n-p}{\sqrt{\tfrac{p(1-p)}{n}}}|<Z_{\tfrac{\alpha}{2}}\Big)\approx 1-\alpha.</script><p>  $[1]$ 用 $S^2=\dfrac{1}{n-1}\sum\limits_{i=1}^{n}(X_i-\overline{X})^2$ 来估计 $\sigma^2=p(1-p)$. 由 <strong>CLT</strong>, 得到</p><script type="math/tex; mode=display">  \dfrac{P_n-p}{\sqrt{\tfrac{S^2}{n}}}\stackrel{近似} {\sim} N(0,1)\Rightarrow P\Big(|\dfrac{P_n-p}{\sqrt{\tfrac{S^2}{n}}}|<Z_{\tfrac{\alpha}{2}}\Big)\approx 1-\alpha.</script><p>  其中 $S^2\approx 0.2475$, 区间估计为 $(0.542,0.598)$.</p><p>  $[2]$ 用 $m_2=\dfrac{1}{n}\sum\limits_{i=1}^{n}(X_i-\overline{X})^2$ 来估计 $\sigma^2=p(1-p)$. </p><p>  实际上, 我们有</p><script type="math/tex; mode=display">  m_2=\dfrac{1}{n}[(1-P_n)^2nP_n+(0-P_n)^2(n-nP_n)]=P_n(1-P_n).</script><p>  由 <strong>CLT</strong>, 得到</p><script type="math/tex; mode=display">  \dfrac{P_n-p}{\sqrt{\tfrac{P_n(1-P_n)}{n}}}\stackrel{近似} {\sim} N(0,1)\Rightarrow p\in(0.542,0.598).</script><p>  $[3]$ 用 $p(1-p)$ 的最大值来估计 $\sigma^2=p(1-p)$. 由 <strong>CLT</strong>, 得到</p><script type="math/tex; mode=display">  \dfrac{P_n-p}{\sqrt{\tfrac{1}{4n}}}\stackrel{近似} {\sim} N(0,1)\Rightarrow p\in(0.542,0.599).</script></li><li><p><strong>注</strong>  近似分布情况下, 置信度 $\approx 1-\alpha$, 近似程度取决于 $n$ 及总体分布.</p></li><li><p><strong>定义(利用 MLE 构建置信区间)</strong></p><p>  总体分布 $f$ 满足一定的光滑性条件, 存在 $\sigma_n&gt;0$, 使 $\dfrac{\theta^{*}-\theta}{\sigma_n}\rightarrow N(0,1)$.</p></li><li><p><strong>定义(Fisher 信息量)</strong>  $X_1,\cdots,X_n$ <strong>iid</strong>, 其 <strong>PDF</strong> 为 $f(x;\theta)$. 定义对数似然函数</p><script type="math/tex; mode=display">  l(\theta)=\log L(\theta)=\sum_{i=1}^{n}\log f(x_i;\theta).</script><p>  定义</p><script type="math/tex; mode=display">  I_n(\theta)=E\Big[\big(\dfrac{\partial l(\theta)}{\partial\theta}\big)^2\Big]=E\Big[\big(\sum_{i=1}^{n}\dfrac{\partial\log f(X_i;\theta)}{\partial\theta}\big)^2\Big].</script><p>  注意到</p><script type="math/tex; mode=display">  \begin{aligned}  E\Big(\dfrac{\partial\log f(X_i;\theta)}{\partial\theta}\Big)&=E\Big(\dfrac{f_{\theta}(X_i;\theta)}{f(X_i;\theta)}\Big)\\  &=\int\dfrac{f_{\theta}(X_i;\theta)}{f(X_i;\theta)}f(X_i;\theta)dx\\  &=\int f_{\theta}(X_i;\theta)dx\\  &=\dfrac{d}{d\theta}\int f(X_i;\theta)dx=0.  \end{aligned}</script><p>  因此</p><script type="math/tex; mode=display">  \begin{aligned}  \end{aligned}\begin{aligned}  I_n(\theta)&=E\Big[\big(\sum_{i=1}^{n}\dfrac{\partial\log f(X_i;\theta)}{\partial\theta}\big)^2\Big]\\  &=\sum_{i=1}^{n}E\Big[\big(\dfrac{\partial\log f(X_i;\theta)}{\partial\theta}\big)^2\Big]\\  &:=nI(\theta).  \end{aligned}</script><p>  由极大似然估计的定义, 我们有</p><script type="math/tex; mode=display">  0=l'(\theta^*)\approx l'(\theta)+(\theta^*-\theta)l''(\theta)\Rightarrow\theta^*-\theta\approx \dfrac{l'(\theta)}{-l''(\theta)}\\  \Rightarrow\sqrt{n}(\theta^*-\theta)\approx \dfrac{\tfrac{1}{\sqrt{n}}l'(\theta)}{-\tfrac{1}{n}l''(\theta)}.</script><p>  研究上式<strong>分子</strong>: 设随机变量 $Y_i=\dfrac{\partial\log f(X_i;\theta)}{\partial\theta}=\dfrac{f_{\theta}(X_i;\theta)}{f(X_i;\theta)}$, 那么</p><script type="math/tex; mode=display">  E(Y_i)=0,\,Var(Y_i)=E(Y_i^2)-E^2(Y_i)=I(\theta).</script><p>  从而</p><script type="math/tex; mode=display">  \dfrac{1}{\sqrt{n}}l'(\theta)=\dfrac{1}{\sqrt{n}}\sum_{i=1}^{n}Y_i=\dfrac{\overline{Y}}{\tfrac{1}{\sqrt{n}}}\stackrel{CLT}{\longrightarrow}N(0,I(\theta)).</script><p>  研究上式<strong>分母</strong>: </p><script type="math/tex; mode=display">  -\dfrac{1}{n}l''(\theta)=-\dfrac{1}{n}\sum_{i=1}^{n}\Big[\dfrac{f_{\theta\theta}(X_i;\theta)}{f(X_i;\theta)}-\big(\dfrac{f_{\theta}(X_i;\theta)}{f(X_i;\theta)}\big)^2\Big].</script><p>  注意到</p><script type="math/tex; mode=display">  E\Big(\dfrac{f_{\theta\theta}(X_i;\theta)}{f(X_i;\theta)}\Big)=0.</script><p>  因此</p><script type="math/tex; mode=display">  -\dfrac{1}{n}l''(\theta)\stackrel{WLLN}{\longrightarrow}E\Big[\dfrac{1}{n}\sum_{i=1}^{n}\big(\dfrac{f_{\theta}(X_i;\theta)}{f(X_i;\theta)}\big)^2\Big]=\dfrac{1}{n}\sum_{i=1}^{n}E(Y_i^2)=I(\theta).</script><p>  结合上述讨论可得</p><script type="math/tex; mode=display">  \sqrt{n}(\theta^*-\theta)\rightarrow N(0,\dfrac{1}{I(\theta)})\\  \Leftrightarrow\dfrac{\theta^*-\theta}{\tfrac{1}{\sqrt{nI(\theta)}}}\stackrel{近似}{\sim}N(0,1)\\  \Rightarrow\dfrac{\theta^*-\theta}{\tfrac{1}{\sqrt{nI(\theta^*)}}}\stackrel{近似}{\sim}N(0,1).</script><p>  这说明可以取 $\sigma_n=\dfrac{1}{\sqrt{nI(\theta)}}$ 或 $\dfrac{1}{\sqrt{nI(\theta^*)}}$.</p></li><li><p><strong>例(选举问题)</strong>  真实支持率 $p$ 未知, $n=1200$, 观测比例 $\dfrac{684}{1200}\approx 0.57$. 给出 $p$ 的一个 $95\%$ 置信的区间估计.</p></li><li><p><strong>解答续</strong>  注意到 $X_i\stackrel{iid}{\sim}B(p)$, $p$ 的 <strong>MLE</strong> 为 $p^{*}=P_n$. 有似然函数</p><script type="math/tex; mode=display">  f(X;p)=p^{X}(1-p)^{1-X}\Rightarrow \dfrac{\partial\log f}{\partial p}=\dfrac{X-p}{p(1-p)}.</script><p>  <strong>Fisher</strong> 信息量为:</p><script type="math/tex; mode=display">  I(p)=E\Big[\big(\dfrac{X-p}{p(1-p)}\big)^2\Big]=\dfrac{1}{p(1-p)}.</script><p>  得到 $\sigma_n=\dfrac{1}{\sqrt{p(1-p)}}$ 或 $\dfrac{1}{\sqrt{p^{<em>}(1-p^{</em>})}}$. 这与前例 $[2]$ 完全一致.</p></li><li><p><strong>例(两总体)</strong>  $X\sim N(\mu_1,\sigma_1^2)$, $Y\sim N(\mu_2,\sigma_2^2)$ 独立, 参数未知. 估计 $\mu_1-\mu_2$.</p></li><li><p><strong>解答</strong>  得到</p><script type="math/tex; mode=display">  \dfrac{(\overline{X}-\overline{Y})-(\mu_1-\mu_2)}{\sqrt{\dfrac{\sigma_1^2}{n}+\dfrac{\sigma_2^2}{m}}}\sim N(0,1).</script><p>  因此</p><script type="math/tex; mode=display">  \dfrac{(\overline{X}-\overline{Y})-(\mu_1-\mu_2)}{\sqrt{\dfrac{S_1^2}{n}+\dfrac{S_2^2}{m}}}\stackrel{近似}{\sim} N(0,1).</script></li></ul><h2 id="Bayes-估计"><a href="#Bayes-估计" class="headerlink" title="Bayes 估计"></a>Bayes 估计</h2><ul><li><p><strong>定义(Bayes 估计)</strong></p><ul><li><p>在搜集数据之前, 对参数 $\theta$ 有先验知识, 可用一个概率分布来刻画 (先验分布).</p></li><li><p>$\Theta$ — 随机变量, $\theta$ —  $\Theta$ 的实现值.</p></li><li><p>$X$ — 试验观测, $x$ — 具体观测结果.</p></li><li><p>$f_{\Theta}(\theta)$ — 先验分布, $f_{X\mid\Theta}(x\mid\theta)=f_X(x,\theta)$ — 搜集的样本分布.</p></li><li><p>更新先验分布为后验分布:</p><script type="math/tex; mode=display">  f_{\Theta\mid X}(\theta\mid x)=\dfrac{f(x,\theta)}{f_X(x)}=\dfrac{f_{X\mid\Theta}(x\mid\theta)f_{\Theta}(\theta)}{f_X(x)}.</script><p>  其中</p><script type="math/tex; mode=display">  f_X(x)=\int_{\mathbb{R}}f(x,\theta)d\theta.</script><p>  可通过后验期望或后验众数得到 <strong>Bayes</strong> 估计值.</p></li></ul></li><li><p><strong>例</strong>  投掷硬币, 正面向上的概率为 $\theta$ (未知). 抛 $n$ 次观测到 $x$ 次正面向上.</p></li><li><p><strong>解答</strong>  对 $\theta$ 的先验认知: $\theta\sim U(0,1)$ (<strong>Bayes</strong> 法则). 此时有 $f_{\Theta}(\theta)=1$, $\theta\in(0,1)$.</p><p>  令 $X=n$ 次试验正面向上的次数, 给定 $\theta$ 时, $X\sim B(n,\theta)$. 即</p><script type="math/tex; mode=display">  f_{X\mid\Theta}(x\mid\theta)=P(X=x\mid \Theta=\theta)=C_n^x\theta^x(1-\theta)^{n-x},x=0,1,\cdots, n.</script><p>  故 $(X,\Theta)$ 的联合分布为 </p><script type="math/tex; mode=display">  f(x,\theta)=C_n^x\theta^x(1-\theta)^{n-x},\theta\in(0,1),x=0,1,\cdots, n.</script><p>  得到</p><script type="math/tex; mode=display">  f_X(x)=\int_0^1f(x,\theta)d\theta=C_n^x\int_0^1\theta^x(1-\theta)^{n-x}d\theta\\  =\dfrac{n!}{x!(n-x)!}\cdot\dfrac{\Gamma(x+1)\Gamma(n-x+1)}{\Gamma(n+2)}=\dfrac{1}{n+1}</script><p>  进而</p><script type="math/tex; mode=display">  f_{\Theta\mid X}(\theta\mid x)=\dfrac{f(x,\theta)}{f_X(x)}=\dfrac{\Gamma(n+2)}{\Gamma(x+1)\Gamma(n-x+1)}\cdot\theta^x(1-\theta)^{n-x}.</script><p>  注意到这恰好为 $\beta(x+1,n-x+1)$ 的 <strong>PDF</strong>.</p><p>  <strong>后验均值</strong>估计值为</p><script type="math/tex; mode=display">  \hat\theta=E(\Theta\mid X)=\int_0^1\theta f_{\Theta\mid X}(\theta\mid x)d\theta=\dfrac{x+1}{n+2}.</script><p>  <strong>后验众数</strong>估计值为 $f_{\Theta\mid X}(\theta\mid x)$ 的最大值点</p><script type="math/tex; mode=display">  \theta^{*}=\dfrac{x}{n}.</script></li><li><p><strong>注</strong>  </p><ul><li>若 $n=20$, $x=13$, 后验分布服从 $\beta(14,8)$.</li><li>此时 $P(\Theta&gt;\dfrac{1}{2})\approx 0.91$, 而 $\Theta&lt;\dfrac{1}{4}$ 基本不可能.</li></ul></li><li><p><strong>注(合理的点估计)</strong></p><ul><li>后验众数;</li><li>后验均值.</li></ul></li><li><p><strong>注(先验分布选取)</strong> </p><ul><li>本问题先验分布服从 $U(0,1)=\beta(1,1)$, 后验分布服从 $\beta(x+1,n-x+1)$;</li><li>一般地, 先验分布服从 $\beta(a,b)$, 后验分布服从 $\beta(a+x,b+n-x)$.</li></ul></li><li><p><strong>定义(Bayes 区间估计)</strong>  得到参数 $\theta$ 的后验分布 $f_{\Theta}(\theta\mid x)$, 给定观测值 $x$ 和实数 $\alpha\in(0,1)$, 若对参数 $\theta$ 的任意可能取值, 都成立</p><script type="math/tex; mode=display">  P(a<\Theta<b\mid x)\ge 1-\alpha.</script><p>  则称 $(a,b)$ 为 $\theta$ 的 $(1−\alpha)$ 置信的 <strong>Bayes</strong> 区间估计.</p></li><li><p><strong>注</strong></p><ul><li>最大后验区间 (一般单峰);</li><li>等尾可信区间.</li></ul></li><li><p><strong>例</strong>  $X\sim N(\mu,\sigma^2)$, $\sigma^2$ 已知, 给出 $\mu$ 的 $(1-\alpha)$ 置信的 <strong>Bayes</strong> 区间估计.</p></li><li><p><strong>解答</strong>  取 $\mu$ 的先验分布 $f(\mu)\propto 1$, 有后验分布为 $N(\overline{X},\dfrac{\sigma^2}{n})$.</p><p>  进一步可得</p><script type="math/tex; mode=display">  \dfrac{\mu-\overline{X}}{\tfrac{\sigma}{\sqrt{n}}}\sim N(0,1).</script><p>  得到所求 <strong>Bayes</strong> 估计区间为</p><script type="math/tex; mode=display">  (\overline{X}-\frac{\sigma}{\sqrt{n}}Z_{\tfrac{\alpha}{2}},\overline{X}+\frac{\sigma}{\sqrt{n}}Z_{\tfrac{\alpha}{2}}).</script></li></ul><h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><h3 id="样本"><a href="#样本" class="headerlink" title="样本"></a>样本</h3><ul><li>$X_1,\cdots,X_n$ 为样本, 通常为 <strong>iid</strong>.</li><li>$\hat\theta=\hat\theta(X_1,\cdots,X_n)$ 为统计量.</li><li>样本分布: $f(x_1,\cdots,x_n;\theta)$ (<strong>PDF</strong>\*<em>PMF*</em>).</li><li>抽样分布: $\hat\theta$ 的分布.</li><li>标准误差: $se=se(\hat\theta)=\sqrt{Var(\hat\theta)}$.</li></ul><h3 id="经典估计的优良性"><a href="#经典估计的优良性" class="headerlink" title="经典估计的优良性"></a>经典估计的优良性</h3><ul><li>$n$ 固定: 无偏性 &amp; 有效性 (<strong>MSE</strong> 的分解)</li><li>$n\rightarrow\infty$: 渐近无偏 &amp; 相合性 (<strong>WLLN</strong> 一致性) &amp; 渐近正态性 (<strong>CLT</strong>)</li></ul><h3 id="置信区间"><a href="#置信区间" class="headerlink" title="置信区间"></a>置信区间</h3><ul><li>$\hat\theta_i=\hat\theta_i(X_1,\cdots,X_n)\,(i=1,2)$.</li><li>$P(\hat\theta_1&lt;\theta&lt;\hat\theta_2)\ge 1-\alpha$.</li><li>置信 (水平、系数、度) 是针对方法.</li><li>枢轴变量: $H(\hat\theta,\theta)$ 表示分布可用.</li></ul><h3 id="置信区间-v-s-Bayes-区间"><a href="#置信区间-v-s-Bayes-区间" class="headerlink" title="置信区间 v.s. Bayes 区间"></a>置信区间 v.s. Bayes 区间</h3><ul><li><p>(置信区间) 对具体的样本观测值 $(x_1,\cdots,x_n)$, 代入 $\hat\theta_1, \hat\theta_2$ 得到具体区间.</p><script type="math/tex; mode=display">  P(\hat\theta_1<\theta<\hat\theta_2)\ge 1-\alpha.</script></li><li><p>(<strong>Bayes</strong> 区间) 对具体的样本观测值 $(x_1,\cdots,x_n)$, 代入 $a, b$ 得到具体区间.</p><script type="math/tex; mode=display">  P(a<\Theta<b\mid x_1,\cdots,x_n)\ge 1-\alpha.</script></li></ul><h3 id="小样本方法-v-s-大样本方法"><a href="#小样本方法-v-s-大样本方法" class="headerlink" title="小样本方法 v.s. 大样本方法"></a>小样本方法 v.s. 大样本方法</h3><ul><li>精确分布 <strong>v.s.</strong> 近似分布</li></ul><h3 id="Fisher-信息量"><a href="#Fisher-信息量" class="headerlink" title="Fisher 信息量"></a>Fisher 信息量</h3><script type="math/tex; mode=display">\dfrac{\theta^*-\theta}{\sigma_n}\stackrel{近似}{\sim}N(0,1).</script><script type="math/tex; mode=display">\sigma_n=\sqrt{\dfrac{1}{nI(\theta)}}或\sqrt{\dfrac{1}{nI(\theta^*)}}.</script>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;Chap-6-参数估计&quot;&gt;&lt;a href=&quot;#Chap-6-参数估计&quot; class=&quot;headerlink&quot; title=&quot;Chap 6 参数估计&quot;&gt;&lt;/a&gt;Chap 6 参数估计&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;引入&lt;/strong&gt; </summary>
        
      
    
    
    
    <category term="Math" scheme="http://chengsx21.github.io/categories/Math/"/>
    
    <category term="Probability Theory" scheme="http://chengsx21.github.io/categories/Math/Probability-Theory/"/>
    
    
    <category term="Probability Theory" scheme="http://chengsx21.github.io/tags/Probability-Theory/"/>
    
  </entry>
  
  <entry>
    <title>概率论与数理统计 笔记5</title>
    <link href="http://chengsx21.github.io/2023/03/27/gai-lu-lun-yu-shu-li-tong-ji-bi-ji-5/"/>
    <id>http://chengsx21.github.io/2023/03/27/gai-lu-lun-yu-shu-li-tong-ji-bi-ji-5/</id>
    <published>2023-03-27T09:27:40.000Z</published>
    <updated>2023-09-21T17:09:49.955Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Chap-5-不等式与极限定理"><a href="#Chap-5-不等式与极限定理" class="headerlink" title="Chap 5 不等式与极限定理"></a>Chap 5 不等式与极限定理</h1><h2 id="概率不等式"><a href="#概率不等式" class="headerlink" title="概率不等式"></a>概率不等式</h2><ul><li><p><strong>定义(Markov 不等式)</strong>  $Y\ge 0$, $\forall\,a&gt;0$, 有</p><script type="math/tex; mode=display">P(Y\ge a)\le \dfrac{E(Y)}{a}.</script></li><li><p><strong>证明</strong>  令示性变量</p><script type="math/tex; mode=display">I=\begin{cases}1,Y\ge a;\\0,Y<a.\end{cases}</script><p>从而有 $I\le \dfrac{Y}{a}$, 两边取期望, 即得</p><script type="math/tex; mode=display">P(Y\ge a)\le \dfrac{E(Y)}{a}.</script></li><li><p><strong>定义(Chebyshev 不等式)</strong>  $Var(Y)$ 存在, $\forall\,a&gt;0$, 有</p><script type="math/tex; mode=display">P(\vert Y-E(Y)\vert\ge a)\le \dfrac{Var(Y)}{a^2}.</script></li><li><p><strong>证明</strong>  注意到</p><script type="math/tex; mode=display">  \begin{aligned}  P(\vert Y-E(Y)\vert\ge a)&=P((Y-E(Y))^2\ge a^2)\\  &\le\dfrac{E[(Y-E(Y))^2]}{a^2}\\  &=\dfrac{Var(Y)}{a^2}.  \end{aligned}</script></li><li><p><strong>注</strong>  若 $Var(Y)=0$, 则 $P(Y=E(Y))=1$. ($Y=E(Y)$ $a.s.$)</p></li><li><p><strong>定义(Chernoff 不等式)</strong>  $\forall\,a&gt;0$, $t&gt;0$, 有</p><script type="math/tex; mode=display">P(Y\ge a)\le \dfrac{E(e^{tY})}{e^{ta}}.</script></li><li><p><strong>证明</strong>  注意到</p><script type="math/tex; mode=display">  \begin{aligned}  P(Y\ge a)&=P(e^{tY}\ge e^{ta})\,(保证\,e^{tY}>0)\\  &\le\dfrac{E(e^{tY})}{e^{ta}}.  \end{aligned}</script></li><li><p><strong>例</strong>  $X\sim N(0,1)$, 估计 $P(\vert X\vert\ge 3)$.</p></li><li><p><strong>解答</strong>  我们有</p><script type="math/tex; mode=display">  P(\vert X\vert\ge 3)\le   \begin{cases}  \dfrac{E(\vert X\vert)}{3}=\dfrac{1}{3}\sqrt{\dfrac{2}{\pi}}\approx 0.27;\quad(Markov)\\  \dfrac{Var(X)}{3^2}=\dfrac{1}{9}\approx 0.11;\quad(Chebyshev)\\  \dfrac{2E(e^{tX})}{e^{3t}}=2e^{\tfrac{t^2}{2}-3t}\le 2e^{-\tfrac{9}{2}}\approx 0.02.\quad(Chernoff)  \end{cases}</script></li></ul><h2 id="大数定律-LLN"><a href="#大数定律-LLN" class="headerlink" title="大数定律 (LLN)"></a>大数定律 (LLN)</h2><ul><li><p><strong>定义</strong>  $X_1,X_2,\cdots$ <strong>iid</strong> (独立同分布), $E(X_i)=\mu$, $Var(X_i)=\sigma^2&gt;0$. 定义:</p><script type="math/tex; mode=display">\overline{X}=\dfrac{1}{n}\sum_{i=1}^{n}X_i,\, E(\overline{X})=\mu,\,Var(\overline{X})=\dfrac{\sigma^2}{n}\rightarrow 0.</script></li><li><p><strong>定义(Khinchin 弱大数定律)(WLLN)</strong> </p><p>  若 $X_1,X_2,\cdots$ <strong>iid</strong>, $E(X_i)=\mu$, $Var(X_i)=\sigma^2&gt;0$. 则 $\forall\varepsilon&gt;0$, 有</p><script type="math/tex; mode=display">  \lim_{n\rightarrow\infty}P(\vert \overline{X}-\mu\vert\ge \varepsilon)=0.</script></li><li><p><strong>证明</strong>  我们有</p><script type="math/tex; mode=display">  P(\vert \overline{X}-\mu\vert\ge \varepsilon)\le\dfrac{Var(\overline{X})}{\varepsilon^2}=\dfrac{\sigma^2}{n\varepsilon^2}\rightarrow 0, 当\,n\rightarrow 0.</script></li><li><p><strong>注</strong></p><ul><li><p>$\mu\approx\overline{X}$ (在很大概率意义下可以用作样本均值估计);</p></li><li><p>$\forall\,\varepsilon&gt;0$, $\forall\,\alpha&gt;0$, $\exists N&gt;0$ 使得当 $n\ge N$ 时</p><script type="math/tex; mode=display">P(\vert \overline{X}-\mu\vert\ge \varepsilon)\le\alpha.</script><p>其中 $\varepsilon$ 体现了精度，$\alpha$ 体现了置信度.</p></li><li><p><strong>Bernoulli LLN</strong>: $X_i\sim B(p)$, 则特殊地得到 <strong>Bernoulli</strong> 大数定律。</p></li><li><p>方差有限条件可去掉, 结论依然成立;</p></li><li><p>可推广至不同的条件:</p><ul><li>$X_i$ 两两不相关,  $Var(X_i)$ 一致有界 (<strong>Chebyshev</strong>);</li><li>$Var(\overline{X})\rightarrow 0$ (<strong>Markov</strong>).</li></ul></li></ul></li><li><p><strong>定义(依概率收敛)</strong></p><script type="math/tex; mode=display">Y_n\stackrel{P}{\longrightarrow}Y\Longleftrightarrow\forall\varepsilon>0, \lim_{n\rightarrow\infty}P(\vert Y_n-Y\vert\ge\varepsilon)=0.</script></li><li><p><strong>注</strong>  <strong>WLLN</strong> $\Rightarrow\overline{X}\stackrel{P} {\longrightarrow}\mu$ (考虑偏差).</p></li><li><p><strong>定义(Kolmogov 强大数定律)(SLLN)</strong></p><p>  若 $X_1,X_2,\cdots$ <strong>iid</strong>, $E(X_i)=\mu$. 则有</p><script type="math/tex; mode=display">  P(\omega\in\Omega\mid \lim_{n\rightarrow\infty}\overline{X_n}(\omega)=\mu)=P(\lim_{n\rightarrow\infty}\overline{X}=\mu)=1.</script></li><li><p><strong>注</strong>  若 $X_i\sim B(p)$ 则 $\overline{X}$ 为频率,从而概率的频率解释是合理的.</p></li><li><p><strong>定义(以概率 1 收敛)</strong></p><script type="math/tex; mode=display">Y_n\stackrel{a.s.}{\longrightarrow}Y\Longleftrightarrow P(\lim_{n\rightarrow\infty}Y_n=Y)=1.</script></li><li><p><strong>注</strong>  <strong>SLLN</strong> $\Rightarrow\overline{X}\stackrel{a.s.} {\longrightarrow}\mu$ (逐点考虑).</p></li><li><p><strong>例</strong>  (<strong>Monte Carlo</strong> 积分)</p></li><li><p><strong>解答</strong>  在 $[a,b]\times [0,c]$ 上取点 $(X_i,Y_i)$ <strong>iid</strong> 在矩形内均匀分布. 定义</p><script type="math/tex; mode=display">  I_i=  \begin{cases}  1,(X_i,Y_i)\in D;\\  0,(X_i,Y_i)\notin D.  \end{cases}</script><p>  则 $I_i\stackrel{iid} {\longrightarrow}B(p)$. 我们有</p><script type="math/tex; mode=display">  P=\dfrac{1}{(b-a)c}\int_a^bg(x)dx\approx\dfrac{1}{n}\sum_{i=1}^{n}I_i.</script></li><li><p><strong>例</strong>  两种收敛有什么差别?</p></li><li><p><strong>解答</strong>  考虑 $\Omega=[0,1]$ 均匀分布 (从而有 ($\Omega,\mathscr{F},P$)). 我们构造</p><script type="math/tex; mode=display">Y_1(\omega)=\omega+I_{[0,1]}(\omega)\\Y_2(\omega)=\omega+I_{[0,\frac{1}{2}]}(\omega)\\Y_3(\omega)=\omega+I_{[\frac{1}{2},1]}(\omega)\\Y_4(\omega)=\omega+I_{[0,\frac{1}{3}]}(\omega)\\Y_5(\omega)=\omega+I_{[\frac{1}{3},\frac{2}{3}]}(\omega)\\Y_6(\omega)=\omega+I_{[\frac{2}{3},1]}(\omega)\\\cdots\\Y(\omega)=\omega.</script><p>因此有 $Y_n\stackrel{P} {\longrightarrow}Y$, 但是 $Y_n\stackrel{a.s.} {\longrightarrow}Y$ 不成立.</p><p>这是因为 $\forall\,\omega_0\in(0,1)$, $Y_n(\omega_0)$ 是振荡的, 它的极限不存在.</p></li></ul><h2 id="中心极限定理-CLT"><a href="#中心极限定理-CLT" class="headerlink" title="中心极限定理 (CLT)"></a>中心极限定理 (CLT)</h2><ul><li><p><strong>定义(中心极限定理)(CLT)</strong></p><p>若 $X_1,X_2,\cdots$ <strong>iid</strong>, $E(X_i)=\mu$, $Var(X_i)=\sigma^2&gt;0$. 我们有</p><script type="math/tex; mode=display">\lim_{n\rightarrow\infty}P\left(\dfrac{X_1+\cdots+X_n-n\mu}{\sqrt{n}\sigma}\le x\right)=\Phi(x),\,\forall\,x\in\mathbb{R}.</script><p>其中 $\Phi(x)$ 为 $N(0,1)$ 的 <strong>CDF</strong>. 也即</p><script type="math/tex; mode=display">\lim_{n\rightarrow\infty}P\left(\dfrac{\overline{X}-\mu}{\tfrac{\sigma}{\sqrt{n}}}\le x\right)=\Phi(x),\,\forall\,x\in\mathbb{R}.</script></li><li><p><strong>证明</strong>  只在 $X_i$ 的 <strong>MGF</strong> 存在情形下证明, 记 $M(t)=M_{X_i}(t)$.</p><p>  不失一般性地, 令 $\mu=0$, $\sigma^2=1$. 因此</p><script type="math/tex; mode=display">  M(0)=E(1)=1,\\  M'(0)=E(X_i)=\mu=0,\\  M''(0)=E(X_i^2)=\sigma^2=1.</script><p>  我们得到</p><script type="math/tex; mode=display">  \begin{aligned}  E(e^{t\frac{X_1+\cdots+X_n}{\sqrt{n}}})&=M^n(\tfrac{t}{\sqrt{n}})\\  &=\left(1+\tfrac{t^2}{2n}+o(\tfrac{t^2}{n})\right)^n\\  &\rightarrow e^{\tfrac{t^2}{2}}.  \end{aligned}</script></li></ul><ul><li><p><strong>注</strong></p><ul><li><p>上述 <strong>CLT</strong> 通常称为 <strong>Lindeberg-Levy CLT</strong>;</p></li><li><p><strong>CLT</strong> $\Rightarrow X_1+\cdots+X_n\sim N(n\mu,n\sigma^2)$, $\overline{X}\sim N(\mu,\dfrac{\sigma^2}{n})$;</p></li><li><p><strong>(DeMoivre-Laplace CLT)</strong>  </p><p>  若 $X_i\sim B(p)$, 则 $\sum\limits_{i=1}^{n}X_i\sim B(n,p)\stackrel{CLT} {\longrightarrow}$ 正态分布.</p></li></ul></li><li><p><strong>定义(二项分布下 CLT 的连续性修正)</strong></p><p>我们有 $P(t_1\le\sum\limits_{i=1}^{n}X_i\le t_2)\approx\Phi(y_2)-\Phi(y_1)$. 其中</p><script type="math/tex; mode=display">\begin{cases}y_1=\dfrac{t_1-np-\tfrac{1}{2}}{\sqrt{np(1-p)}},\\y_2=\dfrac{t_2-np+\tfrac{1}{2}}{\sqrt{np(1-p)}}.\end{cases}</script><p>修正形式可计算单点 $P(S_n=k)$ 的概率, 对其他离散变量也同样适用.</p></li><li><p><strong>定义(依分布收敛)</strong></p><script type="math/tex; mode=display">Y_n\stackrel{d}{\longrightarrow}Y\Longleftrightarrow \lim_{n\rightarrow\infty}F_n(x)=F(x).</script></li></ul><ul><li><p><strong>注</strong>  <strong>CLT</strong> $\Rightarrow Z_n=\dfrac{X_1+\cdots+X_n-n\mu}{\sqrt{n}\sigma}=\dfrac{\overline{X}-\mu}{\tfrac{\sigma}{\sqrt{n}}}$ (标准化).</p></li><li><p><strong>例(选举问题)</strong>  设 $p$ 为选民支持率(未知), 随机调查 $n$ 个人, 支持比例为 $p_n=\dfrac{1}{n}\sum\limits_{i=1}^{n}X_i$, 其中 $X_i\sim B(p)$. 若 $\varepsilon=0.03$, $1-\alpha=0.95$, 求 $n$ 的取值.</p></li><li><p><strong>解答</strong>  有</p><script type="math/tex; mode=display">  P(\left|p_n-p\right|\ge\varepsilon)\le \alpha.</script><p>  由 <strong>CLT</strong> 可得</p><script type="math/tex; mode=display">  \begin{aligned}  P(\left|p_n-p\right|\ge\varepsilon)&=1-P\Big(-\dfrac{\sqrt{n}\varepsilon}{\sigma}\le\dfrac{p_n-p}{\tfrac{\sigma}{\sqrt{n}}}\le\dfrac{\sqrt{n}\varepsilon}{\sigma}\Big)\\  &=1-\Phi\Big(\dfrac{\sqrt{n}\varepsilon}{\sqrt{p(1-p)}}\Big)+\Phi\Big(-\dfrac{\sqrt{n}\varepsilon}{\sqrt{p(1-p)}}\Big)\\  &=2-2\Phi\Big(\dfrac{\sqrt{n}\varepsilon}{\sqrt{p(1-p)}}\Big)\le\alpha.  \end{aligned}</script><p>  即得</p><script type="math/tex; mode=display">  \Phi\Big(\dfrac{\sqrt{n}\varepsilon}{\sqrt{p(1-p)}}\Big)\ge 1-\dfrac{\alpha}{2}.</script><p>  为使得对任意 $p$ 成立, 取 $p=\dfrac{1}{2}$, 即有</p><script type="math/tex; mode=display">  \Phi\Big(2\sqrt{n}\varepsilon\Big)\ge 1-\dfrac{\alpha}{2}.</script><p>  注意到 $\Phi(1.96)\approx 0.975=1-\dfrac{\alpha}{2}$, 因此取 $n\ge 1068$ 即可 (与 $N$ 无关).</p></li></ul><h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><h3 id="尾部概率控制"><a href="#尾部概率控制" class="headerlink" title="尾部概率控制"></a>尾部概率控制</h3><h3 id="极限定理"><a href="#极限定理" class="headerlink" title="极限定理"></a>极限定理</h3><ul><li><strong>LLN</strong>: 弱 or 强</li><li><strong>CLT</strong></li></ul><h3 id="三种收敛"><a href="#三种收敛" class="headerlink" title="三种收敛"></a>三种收敛</h3><h3 id="CLT-应用"><a href="#CLT-应用" class="headerlink" title="CLT 应用"></a><strong>CLT</strong> 应用</h3><script type="math/tex; mode=display">\begin{cases}X_1+\cdots+X_n\sim N(n\mu,n\sigma^2);\\\overline{X}\sim N(\mu,\dfrac{\sigma^2}{n}).\end{cases}</script>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;Chap-5-不等式与极限定理&quot;&gt;&lt;a href=&quot;#Chap-5-不等式与极限定理&quot; class=&quot;headerlink&quot; title=&quot;Chap 5 不等式与极限定理&quot;&gt;&lt;/a&gt;Chap 5 不等式与极限定理&lt;/h1&gt;&lt;h2 id=&quot;概率不等式&quot;&gt;&lt;a</summary>
        
      
    
    
    
    <category term="Math" scheme="http://chengsx21.github.io/categories/Math/"/>
    
    <category term="Probability Theory" scheme="http://chengsx21.github.io/categories/Math/Probability-Theory/"/>
    
    
    <category term="Probability Theory" scheme="http://chengsx21.github.io/tags/Probability-Theory/"/>
    
  </entry>
  
  <entry>
    <title>概率论与数理统计 笔记4</title>
    <link href="http://chengsx21.github.io/2023/03/18/gai-lu-lun-yu-shu-li-tong-ji-bi-ji-4/"/>
    <id>http://chengsx21.github.io/2023/03/18/gai-lu-lun-yu-shu-li-tong-ji-bi-ji-4/</id>
    <published>2023-03-18T09:27:40.000Z</published>
    <updated>2023-09-21T17:09:40.415Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Chap-4-随机变量的数字特征"><a href="#Chap-4-随机变量的数字特征" class="headerlink" title="Chap 4 随机变量的数字特征"></a>Chap 4 随机变量的数字特征</h1><h2 id="期望"><a href="#期望" class="headerlink" title="期望"></a>期望</h2><ul><li><p><strong>定义(期望)</strong> </p><script type="math/tex; mode=display">  E(X)=  \begin{cases}  \sum\limits_{i}x_if(x_i)\\  \int\limits_{-\infty}^{\infty}xf(x)dx\\  \end{cases}</script></li><li><p><strong>注</strong></p><ul><li>存在 $\Leftrightarrow$ 绝对收敛;</li><li><strong>(Lebesque-Stieltjes 积分)</strong>  一般定义: $E(X)=\int\limits_{-\infty}^{\infty}xdF$;</li><li>集中趋势的一种刻画;</li><li>$E((X_1,\cdots,X_n)):=(E(X_1),\cdots,E(X_n))$.</li></ul></li><li><p><strong>性质</strong></p><ul><li><script type="math/tex; mode=display">E(g(X_1,\cdots,X_n))=\begin{cases}\sum\limits_{(x_1,\cdots,x_n)\in\mathbb{R}^n} g(x_1,\cdots,x_n)f(x_1,\cdots,x_n)\\\int\limits_{\mathbb{R}^n} g(x_1,\cdots,x_n)f(x_1,\cdots,x_n)dx_1\cdots dx_n\end{cases}</script></li><li><p><strong>(线性性质)</strong>  $E(aX+bY)=aE(X)+bE(Y)$;</p></li><li><p>若 $X_1,\cdots,X_n$ 独立, 则 $E(X_1\cdots X_n)=E(X_1)\cdots E(X_n)$.</p></li></ul></li></ul><h2 id="分位数"><a href="#分位数" class="headerlink" title="分位数"></a>分位数</h2><ul><li><p><strong>定义(中位数)</strong>  $X$ 连续, 若 $P(X\le m)=\dfrac{1}{2}$, 则称 $m$ 为 $X$ 的中位数.</p></li><li><p><strong>注</strong></p><ul><li>$F(m)=\dfrac{1}{2}$;</li><li>$P(X<m)=\dfrac{1}{2}=p(x>m)$;</m)=\dfrac{1}{2}=p(x></li><li>中位数不一定唯一.</li></ul></li><li><p><strong>定义(中位数)</strong>  若 $P(X<m)\le\dfrac{1}{2}$ 且="" $p(x="">m)\le\dfrac{1}{2}$, 则称 $m$ 为 $X$ 的中位数.</m)\le\dfrac{1}{2}$></p></li><li><p><strong>定义(下侧 $\alpha-$分位数)</strong></p><p>  $\forall\alpha\in(0,1)$, 若 $P(X<a)\le\alpha$ 且="" $p(x="">a)\le 1-\alpha$, 称 $a$ 为 $X$ 的下侧 $\alpha-$分位数.</a)\le\alpha$></p></li><li><p><strong>注</strong></p><ul><li>若 $X$ 连续, 则 $P(X&lt;a)=\alpha$;</li><li>$F^{-1}(\alpha)=\inf\{x\mid F(x)\ge\alpha\}$ 为一个 $\alpha$ 分位数.</li></ul></li><li><p><strong>注</strong></p><ul><li>中位数也是集中趋势的一种刻画;</li><li>众数 (方便定义: $f(x)$ 的最大值点).</li></ul></li></ul><h2 id="方差"><a href="#方差" class="headerlink" title="方差"></a>方差</h2><ul><li><strong>定义(方差与标准差)</strong>  给出定义:<script type="math/tex; mode=display">Var(X):=E((X-E(X))^2)=E(X^2)-E^2(X);\\SD(X):=\sqrt{Var(X)}.</script></li></ul><ul><li><strong>注</strong>  刻画了数据的集中程度.</li><li><strong>性质</strong><ul><li>$Var(c)\equiv 0$;</li><li>$Var(X+c)\equiv Var(x)$;</li><li>$Var(cX)\equiv c^2Var(X)$;</li><li>$Var(X+Y)=Var(X)+Var(Y)+2E((X-E(X))(Y-E(Y)))$.</li></ul></li><li><strong>注</strong>  定义变异系数 $\dfrac{\sigma}{\mu}$.</li></ul><h2 id="协方差与相关系数"><a href="#协方差与相关系数" class="headerlink" title="协方差与相关系数"></a>协方差与相关系数</h2><ul><li><strong>定义(协方差)</strong> <script type="math/tex; mode=display">Cov(X,Y):=E((X-\mu_1)(Y-\mu_2)).</script></li></ul><ul><li><p><strong>注</strong></p><ul><li><p>$Cov(X,X)=Var(X)$;</p></li><li><p>$Cov(X,Y)=Cov(Y,X)$;</p></li><li><p>$Cov(X,Y)=E(XY)-\mu_1\mu_2=E(XY)-E(X)E(Y)$;</p></li><li><p>$Cov(aX_1+bX_2+c,Y)=aCov(X_1,Y)+bCov(X_2,Y)$.</p></li></ul></li><li><p><strong>定义(协方差矩阵)</strong>  对 $\overline{X}=(X_1,\cdots,X_n), \overline{Y}=(Y_1,\cdots,Y_n).$ 我们有协方差矩阵</p><script type="math/tex; mode=display">  \begin{aligned}  Cov(\overline{X},\overline{Y})&=(Cov(\overline{X}_i,\overline{Y}_j))_{n\times n}\\  &=E((\overline{X}-E(\overline{X}))^{T}(\overline{Y}-E(\overline{Y}))).  \end{aligned}</script></li><li><p><strong>注</strong>  方差矩阵: </p><script type="math/tex; mode=display">\begin{aligned}Var(\overline{X})&=Cov(\overline{X},\overline{Y})\\&=(Cov(\overline{X}_i,\overline{X}_j))_{n\times n}\\&=(\sigma_{ij})_{n\times n}.\end{aligned}</script></li><li><p><strong>定义(相关系数)</strong></p><script type="math/tex; mode=display">  Corr(X,Y)=\dfrac{Cov(X,Y)}{\sigma_1\sigma_2}=E(\dfrac{X-\mu_1}{\sigma_1}\cdot\dfrac{Y-\mu_2}{\sigma_2}).</script></li><li><p><strong>定理</strong></p><ul><li>若 $X,Y$ 独立, 则 $Corr(X,Y)=0$, 称为 $X,Y$ 不相关.</li><li>联合正态的特殊情况, 不相关可推出独立.</li><li>$\vert Corr(X,Y)\vert\le 1$, 等号成立当且仅当 $\exist\,a,b$ 使得 $P(Y=aX+b)=1$.</li></ul></li><li><p><strong>证明</strong>  给出引理 <strong>Schwartz 不等式</strong>: </p><script type="math/tex; mode=display">E^2(UV)\le E(U^2)E(V^2).</script><p>取等当且仅当 $\exist\,c\in\mathbb{R}$ 使得 $U=cV$. 取 $U=\dfrac{X-\mu_1}{\sigma_1},V=\dfrac{Y-\mu_2}{\sigma_2}$.</p></li><li><p><strong>注</strong></p><ul><li>$\rho:=Corr(X,Y)=\pm 1$, 则 $a=\pm\dfrac{\sigma_2}{\sigma_1}$;</li><li><p>$\rho:=Corr(X,Y)=0$ (不相关) $\not\Rightarrow$ 独立;</p><p>如 $X\sim N(0,1)$, $Y=X^2$ 不相关但是不独立.</p></li><li>相关系数为线性相关系数.</li></ul></li><li><p><strong>例</strong>  $(X_1,X_2)\sim N(\mu_1,\mu_2,\sigma_1^2,\sigma_2^2,\rho)$, 则</p><script type="math/tex; mode=display">\rho=Corr(X_1,X_2).</script></li></ul><h2 id="矩"><a href="#矩" class="headerlink" title="矩"></a>矩</h2><ul><li><p><strong>定义(矩)</strong>  称</p><script type="math/tex; mode=display">  E((X-c)^k)(k=1,2,\cdots)</script><p>  为 $X$ 关于 $c$ 点的 $k$ 阶矩. 特别地, $c=0$ 对应原点矩, $c=\mu$ 对应中心矩.</p></li><li><p><strong>注</strong></p><ul><li>$E(X)=$ 1 阶原点矩, 0 $\equiv$ 1 阶中心矩;</li><li>$Var(X)=$ 2 阶中心矩;</li></ul></li><li><p><strong>定义(偏度系数)</strong></p><script type="math/tex; mode=display">  Skew(X)=\dfrac{E((X-\mu)^3)}{\sigma^3}=E\left(\left(\dfrac{X-\mu}{\sigma}\right)^3\right).</script><p>  称为 3 阶标准矩.</p></li><li><p><strong>注</strong></p><ul><li>0 $\equiv$ 1 阶标准矩, 1 $\equiv$ 2 阶标准矩.</li><li>$Skew(X)&lt;0$ 表示负偏, $Skew(X)&gt;0$ 表示正偏, 刻画非对称程度;</li><li>相比于 5 阶及以上的奇数阶矩, 3 阶矩的计算相对简单, 噪声影响较小;</li><li>不是唯一的刻画偏度的特征数.</li></ul></li><li><p><strong>定义(峰度系数)</strong></p><script type="math/tex; mode=display">  Kurt(X)=\dfrac{E((X-\mu)^4)}{\sigma^4}=E\left(\left(\dfrac{X-\mu}{\sigma}\right)^4\right).</script><p>  称为 4 阶标准矩.</p></li><li><p><strong>注</strong></p><ul><li>正态分布的峰度 $\equiv$ 3, 超额峰度 $:=Kurt(X)-3$;</li><li>$Kurt(X)&gt;3\leftrightarrow$ 尖峰厚尾;</li><li>没有一个数字特征能完美刻画尾部形.</li></ul></li></ul><h2 id="矩母函数"><a href="#矩母函数" class="headerlink" title="矩母函数"></a>矩母函数</h2><ul><li><p><strong>定义(矩母函数)</strong></p><p>若 $M_X(t)=E(e^{tX})$ 在 $t=0$ 的某个邻域内存在, 则称 $M_X(t)$ 为 $X$ 的矩母函数. 否则称 $X$ 的矩母函数 <strong>MGF</strong> 不存在.</p></li><li><p><strong>例</strong>  $X\sim Exp(\lambda)$.</p></li><li><p><strong>解答</strong></p><script type="math/tex; mode=display">\begin{aligned}M_X(t)&=E(e^{tX})\\&=\int_{0}^{\infty}e^{tx}\lambda e^{-\lambda x}dx\\&=\dfrac{\lambda}{\lambda - t},\,t<\lambda.\end{aligned}</script></li><li><p><strong>例</strong>  $X\sim N(0,1)$.</p></li><li><p><strong>解答</strong></p><script type="math/tex; mode=display">\begin{aligned}M_X(t)&=E(e^{tX})\\&=\dfrac{1}{\sqrt{2\pi}}\int_{0}^{\infty}e^{tx}e^{-\tfrac{1}{2}x^2}dx\\&=e^{\tfrac{t^2}{2}},\,t\in\mathbb{R}.\end{aligned}</script></li><li><p><strong>性质</strong></p><ul><li>$M_X(0)\equiv 1$;</li><li>$Y=aX+b$, 则 $M_Y(t)=E(e^{t(aX+b)})=e^{tb}M_X(at)$.</li></ul></li><li><p><strong>例</strong>  $Y\sim N(\mu,\sigma^2)$.</p></li><li><p><strong>解答</strong></p><script type="math/tex; mode=display">\begin{aligned}M_Y(t)&=e^{t\mu}M_X(\sigma t)\\&=e^{\tfrac{\sigma^2t^2}{2}+\mu t},\,t\in\mathbb{R}.\end{aligned}</script></li><li><p><strong>性质(矩母函数确定矩)</strong></p><script type="math/tex; mode=display">E(X^n)=M_X^{(n)}(0).</script></li><li><p><strong>证明</strong></p><script type="math/tex; mode=display">  \begin{aligned}  M_X^{(n)}(t)&=\sum_{n=0}^{\infty}\dfrac{M_X^{(n)}(0)}{n!}t^n.  \end{aligned}</script><p>  又因为</p><script type="math/tex; mode=display">  \begin{aligned}  M_X(t)&=E(e^{tX})\\  &=E\left(\sum_{n=0}^{\infty}\dfrac{X^n}{n!}t^n\right)\\  &=\sum_{n=0}^{\infty}\dfrac{E(X^n)}{n!}t^n.\\  \end{aligned}</script><p>  比较系数即得.</p></li><li><p><strong>例</strong>  $X\sim N(0,1)$.</p></li><li><p><strong>解答</strong></p><script type="math/tex; mode=display">\begin{aligned}M_X(t)&=E(e^{tX})\\&=e^{\tfrac{t^2}{2}},\,t\in\mathbb{R}\\&=\sum_{n=0}^{\infty}\dfrac{(\tfrac{t^2}{2})^n}{n!}\\&=\sum_{n=0}^{\infty}\dfrac{(2n)!}{2^nn!}\cdot\dfrac{t^{2n}}{(2n)!}\end{aligned}</script><p>可得</p><script type="math/tex; mode=display">\begin{cases}E(X^{2n+1})\equiv 0,\\E(X^{2n})=\dfrac{(2n)!}{2^nn!}.\end{cases}</script></li><li><p><strong>性质(矩母函数确定分布)</strong></p><p>若 $\exists$ $a&gt;0$, 使得 $M_X(t)=M_Y(t)$, $\forall\,t\in(-a,a)$, 则 $X$, $Y$ 同分布.</p></li><li><p><strong>例</strong>  $M_X(t)=\dfrac{1}{4}e^{-t}+\dfrac{1}{2}+\dfrac{1}{8}e^{4t}+\dfrac{1}{8}e^{5t}$.</p></li><li><p><strong>解答</strong>  $X$ 离散, 设 $P(X=k)=p_k$, 我们有</p><script type="math/tex; mode=display">M_X(t)=E(e^{tX})=\sum_ke^{tk}p_k.</script><p>可得分布</p><script type="math/tex; mode=display">P(X=-1)=\dfrac{1}{4};\\P(X=0)=\dfrac{1}{2};\\P(X=4)=\dfrac{1}{8};\\P(X=5)=\dfrac{1}{8}.</script></li><li><p><strong>例</strong>  $f_1(x)=\dfrac{1}{\sqrt{2\pi}x}e^{-\tfrac{(\ln x)^2}{2}}, x&gt;0$, $f_2(x)=f_1(x)+f_1(x)\sin(2\pi\ln x)$.</p></li><li><p><strong>解答</strong>  注意到</p><script type="math/tex; mode=display">\begin{aligned}E(X_2^n)&=E(X_1^n)+\int_{0}^{\infty}x^nf_1(x)\sin(2\pi\ln x)dx\\&=0\,(令 \,y=\ln x-n)\\\end{aligned}</script><p>这是一个同矩不同分布的例子.</p></li><li><p><strong>性质(独立随机变量和的分布)</strong></p><p>若 $X$, $Y$ 独立, 则 $M_{X+Y}(t)=M_X(t)M_Y(t)$.</p></li><li><p><strong>证明</strong>  注意到</p><script type="math/tex; mode=display">  \begin{aligned}  M_{X+Y}(t)&=E(e^{t(X+Y)})\\  &=E(e^{tX}e^{tY})\\  &=E(e^{tX})E(e^{tY})\\  &=M_X(t)M_Y(t).  \end{aligned}</script></li><li><p><strong>例</strong>  $X_1,X_2,\cdots,X_n$ 独立正态, 则 $X_1+X_2+\cdots+X_n$ 正态.</p></li><li><p><strong>解答</strong>  考察 $X_i\sim N(\mu_i,\sigma_i^2)$, 其中 $i=1,2$. 那么</p><script type="math/tex; mode=display">M_{X+Y}(t)=M_X(t)M_Y(t)=e^{\tfrac{1}{2}(\sigma_1^2+\sigma_2^2)+(\mu_1+\mu_2)t}.</script><p>进而得到</p><script type="math/tex; mode=display">X_1+X_2\sim N(\mu_1+\mu_2,\sigma_1^2+\sigma_2^2).</script></li><li><p><strong>注</strong></p><ul><li>若 $N$ 为有限数;</li><li>若 $N$ 为随机变量, 与 $X_i$ 独立.</li></ul></li><li><p><strong>注</strong></p><ul><li><p>$(X_1,X_2,\cdots,X_n)$ 的 <strong>MGF</strong> 为:</p><script type="math/tex; mode=display">M_{(X_1,X_2,\cdots,X_n)}(t_1,t_2,\cdots,t_n)=E(e^{t_1X_1+t_2X_2+\cdots+t_nX_n}).</script></li><li><p>特征函数 </p><script type="math/tex; mode=display">E(e^{itX}), i^2=-1.</script></li></ul></li></ul><h2 id="条件期望"><a href="#条件期望" class="headerlink" title="条件期望"></a>条件期望</h2><ul><li><p><strong>定义(条件期望)</strong></p><script type="math/tex; mode=display">E(Y\mid X\in A)=\begin{cases}\sum\limits_iy_iP(Y=y_i\mid X\in A)\\\int\limits_{-\infty}^{\infty}yf(y\mid X\in A)dy\\\end{cases}</script><script type="math/tex; mode=display">E(Y\mid x)=\begin{cases}\sum\limits_iy_iP(Y=y_i\mid X=x)\\\int\limits_{-\infty}^{\infty}yf_{Y\mid X}(y\mid x)dy\\\end{cases}</script><p>我们称 $E(Y\mid X)$ 为新的随机变量 $h(X)$, 是 $Y$ 对 $X$ 的回归函数.</p></li><li><p><strong>例</strong>  $(X,Y)\sim N(\mu_1,\mu_2,\sigma_1^2,\sigma_2^2,\rho)$, 则 $E(Y\mid X)=\mu_2+\rho\dfrac{\sigma_2}{\sigma_1}(X-\mu_1)$.</p></li><li><p><strong>例</strong>  甲乙两种同类产品, 评价使用寿命为 10 年, 15 年, 市场占有率为 60%, 40%. 随机购买一件产品, 求期望寿命?</p></li><li><p><strong>解答</strong>  为 $10\times 60\%+15\times 40\%=12$ 年.</p><p>若记 $X$ 为产品类型, $Y$ 为产品寿命, 则上式可写成</p><script type="math/tex; mode=display">\begin{aligned}E(Y)&=12\\&=10\times 60\%+15\times 40\%\\&=E(Y\mid X=1)P(X=1)+E(Y\mid X=2)P(X=2)\\&=E[E(Y\mid X)].\end{aligned}</script><p>不同取值分层平均并加权.</p></li><li><p><strong>定义(全期望公式)</strong></p><script type="math/tex; mode=display">  E(Y)=E[E(Y\mid X)].</script></li><li><p><strong>证明</strong>  以连续型为例:</p><script type="math/tex; mode=display">  \begin{aligned}  E(Y\mid x)&=\int_{-\infty}^{\infty}yf_{Y\mid X}(y\mid x)dy\\  &=\int_{-\infty}^{\infty}y\dfrac{f(x,y)}{f_X(x)}dy  \end{aligned}</script><p>  从而有</p><script type="math/tex; mode=display">  \begin{aligned}  E[E(Y\mid X)]&=\int_{-\infty}^{\infty}E(Y\mid x)f_X(x)dx\\  &=\int_{-\infty}^{\infty}\int_{-\infty}^{\infty}yf(x,y)dydx\\  &=E(Y).  \end{aligned}</script></li><li><p><strong>注</strong>  一般地, $E[g(X,Y)]=E[E(g(X,Y)\mid X)]$.</p></li><li><p><strong>定理(均方最优预测)</strong></p><script type="math/tex; mode=display">E[(Y-g(X))^2]\ge E[(Y-h(X))^2]=E[(Y-E(Y\mid X))^2]</script><p>称为均方误差 <strong>MSE</strong> 下的最优预测.</p></li><li><p><strong>证明</strong></p><script type="math/tex; mode=display">  E[(Y-c)^2]\ge E[(Y-E(Y))^2].</script><p>  因此</p><script type="math/tex; mode=display">  E[(Y-g(X))^2\mid X]\ge E[(Y-E(Y\mid X))^2\mid X].</script><p>   两边对 $X$ 取均值, 可得</p><script type="math/tex; mode=display">  E[(Y-g(X))^2]\ge E[(Y-E(Y\mid X))^2].</script></li><li><p><strong>注</strong></p><ul><li><p>$E(Y\mid X)$ 依赖 $(X,Y)$ 的联合分布 (不易获取);</p></li><li><p>转而求最优线性预测:</p><script type="math/tex; mode=display">\min_{a,b}E[(Y-(aX+b))^2]\,(最小二乘法)</script></li></ul></li></ul>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;Chap-4-随机变量的数字特征&quot;&gt;&lt;a href=&quot;#Chap-4-随机变量的数字特征&quot; class=&quot;headerlink&quot; title=&quot;Chap 4 随机变量的数字特征&quot;&gt;&lt;/a&gt;Chap 4 随机变量的数字特征&lt;/h1&gt;&lt;h2 id=&quot;期望&quot;&gt;&lt;a</summary>
        
      
    
    
    
    <category term="Math" scheme="http://chengsx21.github.io/categories/Math/"/>
    
    <category term="Probability Theory" scheme="http://chengsx21.github.io/categories/Math/Probability-Theory/"/>
    
    
    <category term="Probability Theory" scheme="http://chengsx21.github.io/tags/Probability-Theory/"/>
    
  </entry>
  
  <entry>
    <title>概率论与数理统计 笔记3</title>
    <link href="http://chengsx21.github.io/2023/03/08/gai-lu-lun-yu-shu-li-tong-ji-bi-ji-3/"/>
    <id>http://chengsx21.github.io/2023/03/08/gai-lu-lun-yu-shu-li-tong-ji-bi-ji-3/</id>
    <published>2023-03-08T09:27:40.000Z</published>
    <updated>2023-09-21T17:09:36.672Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Chap-3-联合分布"><a href="#Chap-3-联合分布" class="headerlink" title="Chap 3 联合分布"></a>Chap 3 联合分布</h1><h2 id="随机向量"><a href="#随机向量" class="headerlink" title="随机向量"></a>随机向量</h2><ul><li><p><strong>定义(随机向量)</strong>  我们称</p><script type="math/tex; mode=display">(X_1,\cdots,X_n):\Omega\rightarrow\mathbb{R}^n</script><p>为随机向量, 当 $X_i(1\le i\le n)$ 均为随机变量.</p></li><li><p><strong>定义(联合 CDF)</strong></p><script type="math/tex; mode=display">  F(x_1,\cdots,x_n):=F(X_1\le x_1,\cdots,X_n\le x_n),\forall\,(x_1,\cdots,x_n)\in\mathbb{R}^n.</script></li><li><p><strong>注</strong>  若 $X_i:\Omega_i\rightarrow\mathbb{R}$, 需扩充 $\Omega=\Omega_1\times\cdots\Omega_n$.</p></li></ul><h2 id="离散分布"><a href="#离散分布" class="headerlink" title="离散分布"></a>离散分布</h2><ul><li><p><strong>定义(离散型随机向量)</strong> </p><script type="math/tex; mode=display">(X_1,X_2,\cdots,X_n)为离散型\Leftrightarrow X_i(1\le i\le n)为离散型.</script></li><li><p><strong>定义(概率质量函数)(PMF)</strong></p><script type="math/tex; mode=display">  \begin{aligned}  f(x_1,x_2,\cdots,x_n):&=P((X_1,X_2,\cdots,X_n)=(x_1,x_2,\cdots,x_n))\\  &= P(X_1= x_1,X_2=x_2,\cdots,X_n=x_n).  \end{aligned}</script></li></ul><ul><li><p><strong>注</strong>  $\sum\limits_{(x_1,\cdots,x_n)\in\mathbb{R}}f(x_1,\cdots,x_n)\equiv 1$.</p></li><li><p><strong>定义(多项分布)</strong>  若 $B_1, B_2\cdots,B_n$ 为互斥事件, 且 $\sum\limits_{i=1}^{n}B_i=\Omega$. 其发生的概率为 $p_1,\cdots,p_n$, 且 $\sum\limits_{i=1}^{n}p_i\equiv 1$. 满足</p><script type="math/tex; mode=display">P(X_1=k_1,\cdots,X_n=k_n)=\dfrac{N!}{k_1!\cdots k_n!}p_1^{k_1}\cdots p_n^{k_n},\,k_i\ge 0,\,\sum_{i=1}^{n}k_i=N.</script><p>其中 $\dfrac{N!}{k_1!\cdots k_n!}$ 为多项式系数.</p></li></ul><h2 id="连续分布"><a href="#连续分布" class="headerlink" title="连续分布"></a>连续分布</h2><ul><li><p><strong>定义(联合 PDF)</strong>  若存在 $f(x_1,\cdots,x_n)\ge 0$, 使得 $\forall\,Q\subset\mathbb{R}^n$ 可测, 都有</p><script type="math/tex; mode=display">P((X_1,\cdots,X_n)\in Q)=\int_Qf(x_1,\cdots,x_n)dx_1\cdots dx_n</script><p>则称 $(X_1,\cdots,X_n)$ 为连续型, $f$ 为 $(X_1,\cdots,X_n)$ 的概率密度函数 <strong>(PDF)</strong>.</p></li><li><p><strong>注</strong></p><ul><li>$\int_{\mathbb{R}}f\equiv 1$;</li><li>以 $n=2$ 为例, $F(a,b)=\int_{-\infty}^{a}(\int_{-\infty}^{b}f(s,t)dt)ds$;</li><li>$f(a,b)=\dfrac{\partial^2 F}{\partial y\partial x}(a,b),\,a.e$.</li></ul></li><li><p><strong>定义(连续分布)(矩形域)</strong></p><script type="math/tex; mode=display">  f(x,y)=  \begin{cases}  \dfrac{1}{(b-a)(d-c)}, &(x,y)\in(a,b)\times(c,d) \\  0, &otherwise \\  \end{cases}</script></li><li><p><strong>定义(二元正态分布)</strong></p><script type="math/tex; mode=display">  f(x,y)=\dfrac{1}{2\pi\sigma_1\sigma_2}\cdot\dfrac{1}{\sqrt{1-\rho^2}}e^{-\frac{1}{2(1-\rho^2)}[(\frac{x-\mu_1}{\sigma_1})^2+(\frac{y-\mu_2}{\sigma_2})^2-2\rho\frac{x-\mu_1}{\sigma_1}\frac{y-\mu_2}{\sigma_2}]},\\</script><p>  其中 $(x,y)\in\mathbb{R}^2, \vert\rho\vert&lt;1$. </p><p>  上式中 $\exp$ 的指数可视为 $-\dfrac{1}{2}\overline{X}^TW\overline{X}=-\dfrac{1}{2}\overline{AX}^T\overline{AX}$, 其 <strong>Cholesky</strong> 分解为</p><script type="math/tex; mode=display">  \overline{X}=\left(  \begin{matrix}  \dfrac{x-\mu_1}{\sigma_1}\\  \dfrac{y-\mu_2}{\sigma_2}  \end{matrix}\right),  W=\dfrac{1}{1-\rho^2}\left(  \begin{matrix}  1 &-\rho\\  -\rho &1  \end{matrix}\right)\\  \Rightarrow  A=\dfrac{1}{\sqrt{1-\rho^2}}\left(  \begin{matrix}  \pm 1 &\mp\rho\\  0 &\pm\sqrt{1-\rho^2}  \end{matrix}\right).</script></li><li><p><strong>注</strong></p><ul><li>$f(x,y)$ 的等值线图像为椭圆;</li><li>$\rho$ 的意义?</li></ul></li></ul><h2 id="边际分布"><a href="#边际分布" class="headerlink" title="边际分布"></a>边际分布</h2><ul><li><p><strong>定义(边际 CDF)</strong></p><script type="math/tex; mode=display">  F_i(x) := P(X_i\le x) = P(X_i\le x,-\infty<X_j<\infty\,(j\ne i)).</script></li><li><p><strong>连续型</strong></p><p>  $n=2$ 时</p><script type="math/tex; mode=display">  F_X(x)=P(X\le x)=P(X\le x,-\infty<Y<\infty)=\lim_{y\rightarrow\infty}F(x,y).</script><p>  $n=3$ 时</p><script type="math/tex; mode=display">  F_X(x)=P(X\le x,-\infty<Y, Z<\infty)=\lim_{y\rightarrow\infty,z\rightarrow\infty}F(x,y,z).</script><script type="math/tex; mode=display">  F_{X,Y}(x,y)=P(X\le x,Y\le y,-\infty<Z<\infty)=\lim_{z\rightarrow\infty}F(x,y,z).</script></li><li><p><strong>离散型</strong></p><p>$n=2$ 时</p><script type="math/tex; mode=display">F_X(x)=P(X\le x)=\sum\limits_{a\le x}P(X=a)=\sum\limits_{y}\sum\limits_{a\le x}P(X=a,Y=y).</script></li><li><p><strong>例(容斥原理)</strong></p><script type="math/tex; mode=display">  P(X>a,Y>b)=1-F_X(a)-F_Y(b)+F_{X,Y}(a,b).</script></li><li><p><strong>定义(边际 PDF)</strong></p><script type="math/tex; mode=display">  F_X(x) := P(X\le x) = \lim_{y\rightarrow\infty}F(x,y) = \int_{-\infty}^{x}(\int_{-\infty}^{\infty}f(s,t)dt)ds\\</script><p>  $\Rightarrow X$ 的边际 <strong>PDF</strong> 为</p><script type="math/tex; mode=display">  f_X(x)=\int_{-\infty}^{\infty}f(x,y)dy.</script></li><li><p><strong>例</strong>  二元正态分布 $N(\mu_1,\mu_2,\sigma_1^2,\sigma_2^2,\rho)$.</p></li><li><p><strong>解答</strong></p><script type="math/tex; mode=display">\begin{aligned}f_X(x)=\int_{-\infty}^{+\infty}f(x,y)dy=\dfrac{1}{\sqrt{2\pi}\sigma_1}e^{-\frac{(x-\mu_1)^2}{2\sigma_1^2}},\,x\in\mathbb{R}.\end{aligned}</script><p>因此 $X\sim N(\mu_1,\sigma_1^2)$. 同理 $Y\sim N(\mu_2,\sigma_2^2)$.</p></li><li><p><strong>注</strong>  联合分布可确定边际分布, 边际分布不可确定联合分布.</p></li></ul><h2 id="条件分布-以-n-2-为例"><a href="#条件分布-以-n-2-为例" class="headerlink" title="条件分布 (以 $n=2$ 为例)"></a>条件分布 (以 $n=2$ 为例)</h2><ul><li><p><strong>定义(离散型条件分布)</strong>  $P(X=a_i,Y=b_j)=p_{ij}\ge 0$, $\sum\limits_{i,j}p_{ij}\equiv 1$.</p><script type="math/tex; mode=display">P(X=a_i\mid Y=b_j)=\dfrac{P(X=a_i,Y=b_j)}{P(Y=b_j)}=\dfrac{p_{ij}}{\sum\limits_{k}p_{kj}}.</script></li><li><p><strong>注</strong>  $\sum\limits_{i}P(X=a_i\mid Y=b_j)\equiv 1$.</p></li><li><p><strong>定义(连续型条件分布)</strong>  $(X,Y)$ 的 <strong>PDF</strong> 为 $f(x,y)$.</p><script type="math/tex; mode=display">\begin{aligned}P(X\le x\mid y\le Y\le y+dy)&=\dfrac{P(X\le x, y\le Y\le y+dy)}{P(y\le Y\le y+dy)}\\&=\dfrac{\int_{-\infty}^{x}(\int_{y}^{y+dy}f(s,t)dt)ds}{\int_{y}^{y+dy}f_Y(t)dt}.\end{aligned}</script></li><li><p><strong>定义(条件密度函数)</strong></p><script type="math/tex; mode=display">  f_{X\mid Y}(x\mid y\le Y\le y+dy)=\dfrac{\int_{y}^{y+dy}f(x,t)dt}{\int_{y}^{y+dy}f_Y(t)dt}.</script><p>  令 $dy\rightarrow 0$, 定义条件密度函数:</p><script type="math/tex; mode=display">  f_{X\mid Y}(x\mid y)=\dfrac{f(x,y)}{f_Y(y)}.</script><p>   条件密度函数 $f_{X\mid Y}(x\mid y)$ 为 <strong>PDF</strong>.</p></li><li><p><strong>注</strong></p><ul><li>$F(a\mid y)=P(X\le a\mid Y=y)=\int_{-\infty}^{a}f_{X\mid Y}(x\mid y)dx$;</li><li><strong>(乘法法则)</strong>  $f(x,y)=f_{X\mid Y}(x\mid y)f_Y(y)$;</li><li><strong>(全概率公式)</strong>  $f_X(x)=\int_{-\infty}^{\infty}f(x,y)dy=\int_{-\infty}^{\infty}f_{X\mid Y}(x\mid y)f_Y(y)dy$;</li><li><strong>(Bayes 公式)</strong>  $f_{Y\mid X}(y\mid x)=\dfrac{f(x,y)}{f_X(x)}=\dfrac{f_{X\mid Y}(x\mid y)f_Y(y)}{\int_{-\infty}^{\infty}f_{X\mid Y}(x\mid y)f_Y(y)dy}$.</li></ul></li><li><p><strong>例</strong>  二元正态分布.</p></li><li><p><strong>解答</strong>  注意到</p><script type="math/tex; mode=display">\begin{aligned}f_{Y\mid X}(y\mid x)&=\dfrac{f(x,y)}{f_X(x)}\\&=\dfrac{1}{\sqrt{2\pi}\sigma_2}\cdot\dfrac{1}{\sqrt{1-\rho^2}}\cdot\exp\{-\dfrac{[y-(\mu_2+\rho\dfrac{\sigma_2}{\sigma_1}(x-\mu_1))]^2}{2(1-\rho^2)\sigma_2^2}\}.\end{aligned}</script><p>即当 $X=x$ 时, $Y\sim N(\mu_2+\rho\dfrac{\sigma_2}{\sigma_1}(x-\mu_1),(1-\rho^2)\sigma_2^2)$.</p></li></ul><h2 id="独立性"><a href="#独立性" class="headerlink" title="独立性"></a>独立性</h2><ul><li><p><strong>定义(独立性)</strong>  $(X,Y)$ 的 <strong>CDF</strong> 为 $F(x,y)$, 边际 <strong>CDF</strong> $F_X(x)$, $F_Y(y)$. 若</p><script type="math/tex; mode=display">F(x,y)=F_X(x)F_Y(y),\,\forall\,x,y\in\mathbb{R}.</script><p>则称 $X,Y$ 相互独立.</p></li><li><p><strong>注</strong>  $X$, $Y$ 独立 $\Leftrightarrow f(x,y)=f_X(x)f_Y(y),\,\forall\,x,y\in\mathbb{R}$, 其中 $f$ 为 <strong>PDF/PMF</strong>.</p></li><li><p><strong>定义</strong>  $X_1,\cdots,X_n$ 相互独立 $\Leftrightarrow F(x_1,\cdots,x_n)=F_1(x_1)\cdots F_n(x_n),\,\forall\,x_1,\cdots,x_n\in\mathbb{R}.$</p></li><li><p><strong>注</strong>  $X_1,\cdots,X_n$ 独立 $\Leftrightarrow f(x_1,\cdots,x_n)=f_1(x_1)\cdots f_n(x_n),\,\forall\,x_1,\cdots,x_n\in\mathbb{R}$, 其中 $f$ 为 <strong>PDF/PMF</strong>.</p></li><li><p><strong>定理</strong></p><ul><li>$f(x_1,\cdots,x_n)=g_1(x_1)\cdots g_n(x_n),\,\forall\,x_1,\cdots,x_n\in\mathbb{R}$, 则 $X_1,\cdots,X_n$ 独立.</li><li>$X_1,\cdots,X_n$ 独立, $Y_1=g_1(X_1,\cdots,X_n), Y_2=g_2(X_1,\cdots,X_n)$, 则 $Y_1$, $Y_2$ 独立.</li></ul></li></ul><h2 id="随机向量的函数"><a href="#随机向量的函数" class="headerlink" title="随机向量的函数"></a>随机向量的函数</h2><ul><li><p><strong>定义</strong>  $Y=g(X_1,\cdots,X_n)$ </p></li><li><p><strong>例</strong>  $X_i\sim B(n_i, p),i=1,2$ 独立, $Y=X_1+X_2$.</p></li><li><p><strong>解答</strong></p><script type="math/tex; mode=display">\begin{aligned}P(Y=k)&=P(X_1+X_2=k)=\sum_{j=0}^{k}P(X=j,X_2=k-j)\\&=\sum_{j=0}^{k}P(X=j)P(X_2=k-j)\\&=\sum_{j=0}^{k}C_{n_1}^{j}C_{n_2}^{k-j}p^k(1-p)^{n_1+n_2-k}\\&=C_{n_1+n_2}^{k}p^k(1-p)^{n_1+n_2-k}.\end{aligned}</script><p>那么有 $Y\sim B(n_1+n_2,p).$</p></li><li><p><strong>例</strong>  $X_1,X_2$ 连续, $X_1&gt;0$, 其联合 <strong>PDF</strong> 为 $f(x_1,x_2)$, 且 $Y=\dfrac{X_2}{X_1}$.</p></li><li><p><strong>解答</strong>  注意到 $\forall\,y&gt;0$,</p><script type="math/tex; mode=display">\begin{aligned}P(Y\le y)&=P(\dfrac{X_2}{X_1}\le y)\\&=P(X_2\le yX_1)\\&=\int_{D}f(x_1,x_2)dx_1dx_2\\&=\int_{0}^{\infty}(\int_{-\infty}^{yx_1}f(x_1,x_2)dx_2)dx_1\\&=\int_{0}^{\infty}(\int_{-\infty}^{y}f(x_1,x_1t)x_1dt)dx_1.\end{aligned}</script><p>故 $Y$ 的 <strong>PDF</strong> 为</p><script type="math/tex; mode=display">l(y)=\int_{0}^{\infty}x_1f(x_1,x_1y)dx_1.</script></li><li><p><strong>定义(密度函数变换法)</strong>  $X_1,X_2$ 的联合 <strong>PDF</strong> 为 $f(x_1,x_2)$, $g_1,g_2$ 可微可逆, 满足</p><script type="math/tex; mode=display">  \begin{cases}  Y_1=g_1(X_1,X_2)\\  Y_2=g_2(X_1,X_2)  \end{cases}\Rightarrow  \begin{cases}  X_1=h_1(Y_1,Y_2)\\  X_2=h_2(Y_1,Y_2)  \end{cases}</script><p>  那么</p><script type="math/tex; mode=display">  \begin{aligned}  P((Y_1,Y_2)\in A)&=P((X_1,X_2)\in B)\\  &=\int_{B}f(x_1,x_2)dx_1dx_2\\  &=\int_{A}f(h_1(y_1,y_2),h_2(y_1,y_2))\vert J\vert dy_1dy_2.  \end{aligned}</script><p>  其中</p><script type="math/tex; mode=display">  J=det\begin{pmatrix}  \dfrac{\partial h_1}{\partial y_1},\dfrac{\partial h_1}{\partial y_2}\\  \dfrac{\partial h_2}{\partial y_1},\dfrac{\partial h_2}{\partial y_2}  \end{pmatrix}</script><p>  故 $Y_1,Y_2$ 的 <strong>PDF</strong> 为</p><script type="math/tex; mode=display">  l(y_1,y_2)=f(h_1(y_1,y_2),h_2(y_1,y_2))\vert J\vert.</script></li><li><p><strong>例</strong>  $X_1,X_2$ 连续, $X_1&gt;0$, 其联合 <strong>PDF</strong> 为 $f(x_1,x_2)$, 且 $Y=X_1+X_2$.</p></li><li><p><strong>解答</strong></p><p>令 $Z=X_1$, 则 $X_1=Z, X_2=Y-Z$. 故 $Y,Z$ 的 <strong>PDF</strong> 为</p><script type="math/tex; mode=display">l(y,z)=f(z,y-z)\vert J\vert=f(z,y-z).</script><p>其中</p><script type="math/tex; mode=display">J=det\begin{pmatrix}0,&1\\1,&-1\end{pmatrix}</script><p>那么 $Y$ 的 <strong>PDF</strong> 为</p><script type="math/tex; mode=display">l_Y(y)=\int_{-\infty}^{\infty}f(z,y-z)dz</script></li><li><p><strong>注</strong></p><ul><li><p>若 $X_1,X_2$ 独立, 则</p><script type="math/tex; mode=display">l_Y(y)=\int_{-\infty}^{\infty}f_1(z)f_2(y-z)dz=f_1*f_2(y).</script></li><li><p>若 $(X_1,X_2)\sim N(\mu_1,\mu_2,\sigma_1^2,\sigma_2^2,\rho)$, 则 </p><script type="math/tex; mode=display">Y=X_1+X_2\sim N(\mu_1+\mu_2,\sigma_1^2+\sigma_2^2+2\rho\sigma_1\sigma_2).</script></li></ul></li><li><p><strong>注</strong>  三大分布: <strong>Chi-Square</strong> 分布 $\chi^2(n)$, $t_n$, $F$.</p></li></ul>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;Chap-3-联合分布&quot;&gt;&lt;a href=&quot;#Chap-3-联合分布&quot; class=&quot;headerlink&quot; title=&quot;Chap 3 联合分布&quot;&gt;&lt;/a&gt;Chap 3 联合分布&lt;/h1&gt;&lt;h2 id=&quot;随机向量&quot;&gt;&lt;a href=&quot;#随机向量&quot;</summary>
        
      
    
    
    
    <category term="Math" scheme="http://chengsx21.github.io/categories/Math/"/>
    
    <category term="Probability Theory" scheme="http://chengsx21.github.io/categories/Math/Probability-Theory/"/>
    
    
    <category term="Probability Theory" scheme="http://chengsx21.github.io/tags/Probability-Theory/"/>
    
  </entry>
  
  <entry>
    <title>概率论与数理统计 笔记2</title>
    <link href="http://chengsx21.github.io/2023/03/02/gai-lu-lun-yu-shu-li-tong-ji-bi-ji-2/"/>
    <id>http://chengsx21.github.io/2023/03/02/gai-lu-lun-yu-shu-li-tong-ji-bi-ji-2/</id>
    <published>2023-03-02T09:27:40.000Z</published>
    <updated>2023-09-21T17:09:31.856Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Chap-2-随机变量"><a href="#Chap-2-随机变量" class="headerlink" title="Chap 2 随机变量"></a>Chap 2 随机变量</h1><h2 id="1-维随机变量"><a href="#1-维随机变量" class="headerlink" title="1 维随机变量"></a>1 维随机变量</h2><ul><li><p><strong>定义(随机变量)</strong>  样本空间上的实值函数.</p><script type="math/tex; mode=display">X: \Omega\rightarrow\mathbb{R},\,\omega\rightarrow X(\omega).</script></li><li><p><strong>例</strong></p></li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">试验</th><th style="text-align:center">样本空间</th><th style="text-align:center">随机变量</th><th style="text-align:center">像集 (新样本空间)</th></tr></thead><tbody><tr><td style="text-align:center">随机调查 $50$ 人对某议题支持与否</td><td style="text-align:center">$\{(1, 0, \cdots), \cdots\}$</td><td style="text-align:center">$X_1= 1$ 的个数</td><td style="text-align:center">$\{0, 1, 2, \cdots, 50\}$</td></tr><tr><td style="text-align:center">随机抽取一个北京市成年公民</td><td style="text-align:center">所有北京市成年公民之集</td><td style="text-align:center">$X_2=$ 其 $2022$ 年的收入</td><td style="text-align:center">$(-\infty, +\infty)$</td></tr></tbody></table></div><ul><li><p><strong>定义(事件)</strong>  $X_1 = 30$, $X_2&gt;100,000$.</p></li><li><p><strong>注</strong></p><ul><li>概括作用: 提供了试验结果的数值摘要;</li><li>事件 <strong>v.s.</strong> 变量, 静态 <strong>v.s.</strong> 动态.</li></ul></li><li><p><strong>分类</strong></p><ul><li>离散型: 至多可数个取值;</li><li>连续型: 区间型取值 (定义不严格);</li><li>其他.</li></ul></li><li><p><strong>定义</strong>  $\forall I\subset\mathbb{R}$, 令 $X^{-1}(I)$ 表示 $I$ 在 $X$ 下的原像集, $X^{-1}(I)\subset\Omega$, 例如</p><script type="math/tex; mode=display">X^{-1}((a, b)) = \{\omega\in\Omega\mid a<X(\omega)<b\}.</script></li><li><p><strong>定义</strong> </p><script type="math/tex; mode=display">  P_{X}(X\in I) = P(X^{-1}(I)), \,\forall I\subset\mathbb{R}\,可测.</script><p>  需要 $X^{-1}(I)\in\mathscr{F}$, 一般记 $P_X$ 为 $P$.</p></li><li><p><strong>定义(累积分布函数)(CDF)</strong> </p><script type="math/tex; mode=display">  F(x) := P(X\le x), \,\forall x\in\mathbb{R}.</script><p>  我们有</p><script type="math/tex; mode=display">  P(a<X\le b)=F(b)-F(a).</script></li><li><p><strong>性质</strong></p><ul><li>$0\le F(x)\le 1$, 单调增(未必严格);</li><li>$\lim\limits_{x\rightarrow+\infty}F(x) = 1$, $\lim\limits_{x\rightarrow-\infty}F(x) = 0$;</li><li>右连续 ($PS.$ 若定义 $F(x) := P(X&lt;x)$, $\forall x\in\mathbb{R}$, 则有 $F(x)$ 左连续).</li></ul></li><li><p><strong>注</strong></p><ul><li><p>随机要素体现在样本点 $\omega$ 的不确定性;</p></li><li><p>随机变量的直观意义往往出现在样本空间的直观意义之前;</p></li></ul></li></ul><ul><li><p><strong>辨析</strong> </p><script type="math/tex; mode=display">  X_i=  \begin{cases}  1,\,第i次抛硬币正面向上; \\  0,\,第i次抛硬币正面向下. \\  \end{cases}</script><p>  其中 $i=1, 2$. 那么 $X_1 + X_2$ 的样本空间为</p><script type="math/tex; mode=display">  \{正正, 正反, 反正, 反反\}.</script><p>  因为随机变量可视作函数, 需要满足定义域相同, 因此 $X_1$, $X_2$ 的定义域同上.</p></li><li><p><strong>注</strong></p><ul><li>$aX+bY$, $XY$, $\dfrac{X}{Y}(Y\ne 0)$, $g(X,Y)$ 为随机变量, 其中 $X$, $Y$ 样本空间相同;</li><li>需要有 $X^{-1}(I)\in\mathscr{F}$, 从而 $P(X^{-1}(I))$ 有意义.</li></ul></li><li><p><strong>定义(同分布)</strong>  $X_1, X_2$ 的 <strong>CDF</strong> 分别为 $F_1(x), F_2(x)$, 那么</p><script type="math/tex; mode=display">  X_1, X_2 同分布\Leftrightarrow P(X_1^{-1}(I)) = P(X_2^{-1}(I)),\forall\,I\subset\mathbb{R}\,可测\\  \Leftrightarrow F_1(x) = F_2(x),\,\forall\,x\in\mathbb{R}.</script></li><li><p><strong>注</strong></p><ul><li>$X_1, X_2$ 同分布 $\nRightarrow X_1 = X_2$.</li><li>考虑掷一次硬币,  $X_1=$ 正面向上的次数, $X_2=$ 反面向上的次数, 这两个随机变量是同分布的.</li><li>随机变量是函数!</li></ul></li></ul><h2 id="离散型随机变量"><a href="#离散型随机变量" class="headerlink" title="离散型随机变量"></a>离散型随机变量</h2><ul><li><p><strong>定义(概率质量函数)(PMF)</strong> </p><script type="math/tex; mode=display">f(x) = P(X = x),\,\forall\,x\in\,\mathbb{R}.</script></li><li><p><strong>注</strong></p><ul><li>$f(x_i)=p_i, \sum\limits_{i}P_i = 1$;</li><li><strong>CDF</strong> 为阶梯函数.</li></ul></li><li><p><strong>定义(期望与方差)</strong> </p><script type="math/tex; mode=display">  E(X) = \sum\limits_{i}x_ip_i = \sum\limits_{i}x_if(x_i) = \mu\\  Var(X) = \sum\limits_{i}(x_i-\mu)^2p_i = \sum\limits_{i}(x_i-\mu)^2f(x_i) = \sigma^2</script><p>  我们有</p><script type="math/tex; mode=display">  Var(X) = E((X-E(X))^2) = E(X^2) - E^2(X).</script></li><li><p><strong>注</strong></p><ul><li>算数均值即期望:</li></ul><script type="math/tex; mode=display">\dfrac{1}{n}\sum_{i = 1}^na_i=\dfrac{1}{n}\sum_{i = 1}^nk_ix_i=\sum_{i = 1}^np_ix_i=\mu;</script><ul><li>期望存在 $\Leftrightarrow$ $\sum\limits_{i}\vert x_i\vert p_i&lt;+\infty$;</li><li>$E(g(X)) = \sum\limits_{i}g(x_i)p_i$;</li><li>$E(X), Var(X)$ 为随机变量 $X$ 的分布的特征, 分别刻画了随机变量的集中趋势和分散程度.</li></ul></li></ul><h2 id="常见离散分布"><a href="#常见离散分布" class="headerlink" title="常见离散分布"></a>常见离散分布</h2><ul><li><p><strong>定义(Bernoulli 分布)</strong></p><script type="math/tex; mode=display">X=\begin{cases}1,\,事件成功,\,p \\0,\,事件不成功,\,1-p \\\end{cases}</script><p>记为 $X\sim B(p)$. 我们有</p><script type="math/tex; mode=display">E(X)=p, Var(X)=p(1-p).</script></li><li><p><strong>定义(二项分布)</strong></p><p>  记 $X$ 为 $n$ 次独立 <strong>Bernoulli</strong> 试验的成功次数. 满足</p><script type="math/tex; mode=display">  P(X=k)=C_n^kp^k(1-p)^{n-k},\,k=0,1,\cdots,n.</script><p>  记为 $X\sim B(n,p)$. 我们有</p><script type="math/tex; mode=display">  E(X)=np, Var(X)=np(1-p).</script></li><li><p><strong>定义(Poisson 分布)</strong></p><p>  满足</p><script type="math/tex; mode=display">  P(X=k)=\dfrac{\lambda^k}{k!}e^{-\lambda},\,k=0,1,2,\cdots.</script><p>  记为 $X\sim P(\lambda)$. 我们有</p><script type="math/tex; mode=display">  E(X)=\lambda, Var(X)=\lambda.</script></li><li><p><strong>例</strong>  观察时间 $[0,1)$ 某路口发生的交通事故数 $X$.</p><ul><li><p>$l_i=[\dfrac{i-1}{n},\dfrac{i}{n}), i=1,2,\cdots,n$.</p></li><li><p>$n$ 充分大.</p></li><li><p>假设:</p><ul><li>$l_i$ 上至多发生一起事故;</li><li>$l_i$ 上恰发生一次事故的概率 $p=\dfrac{\lambda}{n}$, 与时长成正比;</li><li>$l_i$ 各段相互独立.</li></ul></li><li><p>此时</p><script type="math/tex; mode=display">  \begin{aligned}  P(X=k)&=C_n^kp^k(1-p)^{n-k}\\  &=\dfrac{n!}{k!(n-k)!}(\dfrac{\lambda}{n})^k(1-\dfrac{\lambda}{n})^{n-k}\\  &\rightarrow\dfrac{\lambda^k}{k!}e^{-\lambda}, 当\,n\to\infty.  \end{aligned}</script></li></ul></li><li><p><strong>注</strong></p><ul><li>若 $X\sim B(n,p)$, $p$ 很小, $n$ 很大, $np$ 不太大, 则 $X\sim P(\lambda)$, $\lambda=np$.</li><li>误差最多为 $\min(p,np^2)$.</li><li><strong>Poisson</strong> 分布多用于一定时间或空间内小概率事件发生次数的场景.</li></ul></li><li><p><strong>例</strong>  某医院平均每小时出生婴儿 $\lambda$ 名, 接下来 $t$ 小时出生婴儿数的分布.</p></li><li><p><strong>解答</strong>  我们有</p><script type="math/tex; mode=display">P(N(t)=k)=\dfrac{(\lambda t)^k}{k!}e^{-\lambda t},\,k=0,1,2,\cdots.</script><p>其中 $\lambda$ 为均值.</p></li><li><p><strong>注</strong>  <strong>Bernoulli</strong> 试验不独立, 但弱相依条件下仍为较好近似.</p></li><li><p><strong>例(配对问题)</strong></p></li><li><p><strong>解答</strong>  弱相依条件下:</p><script type="math/tex; mode=display">P(A_i)=\dfrac{1}{n}\simeq P(A_i\mid A_j)=\dfrac{1}{n-1}</script><p>恰有 $k$ 个人拿到自己的帽子的概率:</p><script type="math/tex; mode=display">P(X=k)=\dfrac{\lambda^k}{k!}e^{-\lambda}=\dfrac{e^{-1}}{k!}</script></li><li><p><strong>常规解答</strong></p><p>  设 $E=$ 指定的 $k$ 个人拿到了自己的帽子.</p><p>  设 $F=$ 其余的 $n-k$ 个人未拿到自己的帽子.</p><p>  我们有:</p><script type="math/tex; mode=display">  P(EF)=P(F\mid E)P(E)=P_{n-k}\dfrac{(n-k)!}{n!}</script><p>  进而有:</p><script type="math/tex; mode=display">  P(X=k)=C_n^kP(EF)=\dfrac{1}{k!}P_{n-k}\rightarrow\dfrac{e^{-1}}{k!}.</script></li></ul><h2 id="连续随机变量"><a href="#连续随机变量" class="headerlink" title="连续随机变量"></a>连续随机变量</h2><ul><li><p><strong>定义(概率密度函数)(PDF)</strong>  若存在 $f\ge 0$, 使得 $\forall I\subset\mathbb{R}$ 可测, 都有</p><script type="math/tex; mode=display">P(X\in I)=\int_If(x)dx</script><p>则称 $X$ 为连续型随机变量, $f$ 为 $X$ 的概率密度函数 <strong>(PDF)</strong>.</p></li><li><p><strong>性质</strong></p><ul><li>$\int_{-\infty}^{\infty}f(x)dx\equiv 1$;</li><li>$P(a&lt;X\le b)=\int_a^bf(x)dx=P(a\le X\le b)=P(a\le X&lt;b)=P(a&lt;X&lt;b)$;</li><li>$P(X=a)=0,\forall a\in\mathbb{R}$;</li><li>$P(x_0-\delta&lt;X\le x_0+\delta)=\int_{x_0-\delta}^{x_0+\delta}f(x)dx=2\delta f(x_0)$, 要求 $f$ 在 $x_0$ 处连续;</li><li>$F(x)=P(X\le x)=\int_{-\infty}^xf(t)dt$ 连续, $F’(x)=f(x)$ ($f$ 在 $x$ 处连续);</li><li><strong>PDF</strong> 与 <strong>PMF</strong> 实质上可以统一; <strong>PDF</strong> 若存在, 则不唯一.</li></ul></li><li><p><strong>定义(期望与方差)</strong></p><script type="math/tex; mode=display">  E(X) = \int_{-\infty}^{\infty}xf(x)dx = \mu\\  Var(X) = \int_{-\infty}^{\infty}(x-\mu)^2f(x)dx = \sigma^2</script><p>  我们有</p><script type="math/tex; mode=display">  Var(X) = E((X-E(X))^2) = E(X^2) - E^2(X).</script></li><li><p><strong>约定</strong>  $E(X)$ 存在 $\Leftrightarrow$ $E(X)&lt;\infty$.</p></li><li><p><strong>注</strong></p><ul><li>$E(X)$ 存在 $\Leftrightarrow$ $\int\limits_{-\infty}^{\infty}\vert x\vert f(x)dx&lt;\infty$;</li><li>一般地, $E(g(X))=\int\limits_{-\infty}^{\infty}g(x)f(x)dx$.</li></ul></li></ul><h2 id="常见连续分布"><a href="#常见连续分布" class="headerlink" title="常见连续分布"></a>常见连续分布</h2><ul><li><p><strong>定义(连续分布)</strong></p><script type="math/tex; mode=display">f(x)=\begin{cases}\dfrac{1}{b-a},\,a<x<b \\0,\,其他情况 \\\end{cases}</script><p>记为 $X\sim U(a,b)$. 我们有</p><script type="math/tex; mode=display">E(X)=\dfrac{a+b}{2}, Var(X)=?.</script></li><li><p><strong>注</strong>  $X\sim U(0,1)$ 称为随机数.</p></li><li><p><strong>定义(正态分布)</strong></p><script type="math/tex; mode=display">  f(x)=\dfrac{1}{\sqrt{2\pi}\sigma}e^{-\dfrac{(x-\mu)^2}{2\sigma^2}},\,x\in\mathbb{R}.</script><p>  记为 $X\sim N(\mu,\sigma^2)$. 我们有</p><script type="math/tex; mode=display">  E(X)=\mu, Var(X)=\sigma^2.</script></li><li><p><strong>注</strong></p><ul><li>$X\sim N(\mu,\sigma^2)\Leftrightarrow Y=\dfrac{X-\mu}{\sigma}\sim N(0,1)$;</li><li>$N(0,1)$ 标准正态;</li><li>经验法则.</li></ul></li><li><p><strong>定义(指数分布)</strong></p><script type="math/tex; mode=display">  f(x)=  \begin{cases}  \lambda e^{-\lambda x},\,x>0 \\  0,\,x\le 0 \\  \end{cases}</script><p>  记为 $X\sim Exp(\lambda)$. 我们有</p><script type="math/tex; mode=display">  E(X)=\dfrac{1}{\lambda}, Var(X)=\dfrac{1}{\lambda^2}.</script></li><li><p><strong>注</strong></p><ul><li>有的软件取参数为 $\beta=\dfrac{1}{\lambda}$;</li><li>通常刻画寿命或等待时间.</li></ul></li><li><p><strong>例</strong>  观察到有婴儿出生, 接下来 $t$ 小时有婴儿出生的概率为?</p></li><li><p><strong>解答</strong></p><script type="math/tex; mode=display">\begin{aligned}P(X\le t)&=1-P(X>t)\\&=1-P(N(t)=0)\\&=1-\dfrac{(\lambda t)^0}{0!}e^{-\lambda t}\\&=1-e^{-\lambda t}.\end{aligned}</script><p>这是一个 <strong>Poisson</strong> 过程, 数量是 <strong>Poisson</strong> 分布, 间隔是指数分布.</p></li><li><p><strong>定义</strong>  假设 $X&gt;0$ 连续, 其 <strong>CDF</strong> 为 $F(x)$, 满足 $F(0)=0$. 考虑</p><script type="math/tex; mode=display">\begin{aligned}&P(x<X<x+dx\mid X>x)\\=&\dfrac{P(x<X<x+dx)}{P(X>x)}\\=&\dfrac{F(x+dx)-F(x)}{1-F(x)}\\\approx&\dfrac{F'(x)}{1-F(x)}dx.\end{aligned}</script><p>视为年龄为 $x$ 的元件失效的条件概率密度 (瞬时失效率/危险率).</p></li><li><p><strong>注</strong></p><ul><li><p>令 $\dfrac{F’(x)}{1-F(x)}=\lambda(x)\Rightarrow F(x)=1-e^{-\int_0^x\lambda(t)dt},x&gt;0$;</p></li><li><p>若 $\lambda(x)\equiv\lambda\,(无老化假设)$, 则 $F(x)=1-e^{-\lambda x}$,</p><p>$\Rightarrow P(X&gt;t+s\mid X&gt;s)=\dfrac{P(X&gt;t+s)}{P(X&gt;s)}=\dfrac{1-F(s+t)}{1-F(s)}=e^{-\lambda t}$  $(无记忆性)$;</p></li><li><p>改进 $\lambda(x)=\alpha\dfrac{x^{\alpha-1}}{\beta^\alpha},\alpha,\beta&gt;0$, 则 $F(x)=1-e^{-(\dfrac{x}{\beta})^{\alpha}}\Rightarrow$ <strong>Weibull</strong> 分布.</p></li></ul></li></ul><h2 id="随机变量的函数"><a href="#随机变量的函数" class="headerlink" title="随机变量的函数"></a>随机变量的函数</h2><ul><li><p><strong>定义</strong>  $Y=g(X)$ </p></li><li><p><strong>例</strong>  $X\sim Exp(\lambda)$.</p></li><li><p><strong>解答</strong></p><script type="math/tex; mode=display">Y=\begin{cases}1,\,x>t_0 \\0,\,x\le t_0 \\\end{cases}    \quad t_0>0\,给定.</script><p>那么有 $P(Y=0)=1-e^{-\lambda t_0}$, $P(Y=1)=e^{-\lambda t_0}$.</p></li><li><p><strong>例</strong>  $X$ 连续, 其 <strong>PDF</strong> 为 $f(x)$, 且 $Y=X^2$.</p></li><li><p><strong>解答</strong>   $\forall y&gt;0$, 我们有</p><script type="math/tex; mode=display">\begin{aligned}P(Y\le y)&=P(X^2\le y)\\&=P(-\sqrt{y}\le X\le\sqrt{y})\\&=\int_{-\sqrt{y}}^{\sqrt{y}}f(x)dx\\&=\int_0^yl(t)dt.\end{aligned}</script><p>其中 $Y$  的 <strong>PDF</strong> 为 $l(y)=\dfrac{1}{2\sqrt{y}}(f(\sqrt{y})+f(-\sqrt{y}))$.</p></li><li><p><strong>例</strong>  $X\sim N(0,1)$, 且 $Y=X^2$.</p></li><li><p><strong>解答</strong>  $Y$  的 <strong>PDF</strong> 为</p><script type="math/tex; mode=display">l(y)=\dfrac{1}{\sqrt{2\pi}}\dfrac{1}{\sqrt{y}}e^{-\dfrac{y}{2}}</script><p>这是自由度为 $1$ 的 <strong>Chi-Square</strong> 分布 $\chi^2(1)$.</p></li></ul>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;Chap-2-随机变量&quot;&gt;&lt;a href=&quot;#Chap-2-随机变量&quot; class=&quot;headerlink&quot; title=&quot;Chap 2 随机变量&quot;&gt;&lt;/a&gt;Chap 2 随机变量&lt;/h1&gt;&lt;h2 id=&quot;1-维随机变量&quot;&gt;&lt;a href=&quot;#1-维随机变量&quot;</summary>
        
      
    
    
    
    <category term="Math" scheme="http://chengsx21.github.io/categories/Math/"/>
    
    <category term="Probability Theory" scheme="http://chengsx21.github.io/categories/Math/Probability-Theory/"/>
    
    
    <category term="Probability Theory" scheme="http://chengsx21.github.io/tags/Probability-Theory/"/>
    
  </entry>
  
  <entry>
    <title>概率论与数理统计 笔记1</title>
    <link href="http://chengsx21.github.io/2023/02/23/gai-lu-lun-yu-shu-li-tong-ji-bi-ji-1/"/>
    <id>http://chengsx21.github.io/2023/02/23/gai-lu-lun-yu-shu-li-tong-ji-bi-ji-1/</id>
    <published>2023-02-23T09:27:40.000Z</published>
    <updated>2023-09-21T17:09:28.499Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Chap-1-概率"><a href="#Chap-1-概率" class="headerlink" title="Chap 1 概率"></a>Chap 1 概率</h1><h2 id="试验与事件"><a href="#试验与事件" class="headerlink" title="试验与事件"></a>试验与事件</h2><ul><li><p><strong>定义(随机试验)</strong></p><ul><li>不能预先确知结果;</li><li>试验之前可预测所有可能结果.</li></ul></li><li><p><strong>定义(样本空间)</strong>  一个试验所有可能结果之集 $(\Omega)$.</p></li><li><strong>定义(随机事件)</strong>  $a$ $well$ $defined$ $subset$ $A\in\Omega$.<ul><li>全事件 $\Omega$ (必然事件);</li><li>空事件 $\varPhi$ (不可能事件);</li><li>单一试验结果 (基本事件).</li></ul></li></ul><h2 id="事件的运算"><a href="#事件的运算" class="headerlink" title="事件的运算"></a>事件的运算</h2><ul><li><p>借助集合的语言 $or$ $Venn$ 图.</p><ul><li>余: $A^c-(\Omega\backslash A)$;</li><li>和: $A+B-(A\cup B)$;</li><li>差: $A-B-(A\backslash B)$;</li><li>积: $AB-(A\cap B)$;</li><li>互斥: $AB = \varnothing$;</li><li>对立: $AB = \varnothing, A + B = \Omega$;</li><li><strong>De Morgan</strong> 定律: $(A + B)^c = A^cB^c$ $(\sum_n A_n)^c = \prod_n A_n^c$.</li></ul></li></ul><h2 id="概率的几种解释"><a href="#概率的几种解释" class="headerlink" title="概率的几种解释"></a>概率的几种解释</h2><ul><li>古典解释 - 基于等可能性;</li><li>频率解释;</li><li>主观解释.</li></ul><h2 id="公理化定义"><a href="#公理化定义" class="headerlink" title="公理化定义"></a>公理化定义</h2><ul><li><p>$2^{\Omega}\Rightarrow\Omega$ 的所有子集构成的集合.</p></li><li><p>事件集类 $\mathscr{F}\subset\Omega\Rightarrow\sigma{-}$代数: 事件运算的封闭性.</p></li><li><p>特别地, </p><script type="math/tex; mode=display">\sum_{i = 1}^{\infty}A_i\in\mathscr{F}, \forall A_i\in\mathscr{F}.</script></li><li><p><strong>定义(Kolmogorov)</strong></p><script type="math/tex; mode=display">  P: \mathscr{F}\rightarrow\mathbb{R} \\</script><p>  满足以下三条公理:</p><ul><li>$P(A)\ge 0, \forall A\in\mathscr{F}$</li><li>$P(\Omega) = 1$</li><li><p>$P(\sum_{i = 1}^{\infty}A_i) = \sum_{i = 1}^{\infty}P(A_i), A_iA_j = \varnothing, \forall i\ne j$</p><p>则称 $P$ 为概率函数, $(\Omega, \mathscr{F}, P)$ 为概率空间.</p></li></ul></li><li><p><strong>命题</strong></p><ul><li>$P(A)\le1, \forall A\in\mathscr{F}$;</li><li>$P(\varPhi) = 0$;</li><li>$P(A^c) = 1 - P(A)$;</li><li>$P(\sum_{i = 1}^{n}A_i) = \sum_{i = 1}^{n}P(A_i), A_iA_j = \varnothing, \forall i\ne j$;</li><li>$P(A)\le P(B), \forall A\subset B$;</li><li>$P(A + B) = P(A) + P(B) - P(AB)$.</li></ul></li><li><p><strong>推广</strong></p><p>$P(\sum_\limits{i = 1}^{n}A_i) = \sum_\limits{i = 1}^{n}P(A_i) - \sum_\limits{i_1&lt;i_2}P(A_{i_1}A_{i_2}) + \cdots + (-1)^{r - 1}\sum_\limits{i_1 &lt; \cdots &lt; i_r}P(A_{i_1}\cdots A_{i_r}) + \cdots$</p></li><li><p><strong>例</strong>  $n$ 个人, 每人一顶帽子, 随机挑选一顶帽子. 无人拿到自己帽子的概率为? 恰有 $k$ 人拿到自己帽子的概率为?</p></li><li><p><strong>解答</strong>  令 $A_i = $ 第 $i$ 个人拿到自己帽子. 注意到</p><script type="math/tex; mode=display">P(A_i) = \cfrac{1}{n}.</script><p>运用排列组合知识可得</p><script type="math/tex; mode=display">P(A_{i_1}\cdots A_{i_r}) = \cfrac{(n - r)!}{n!},\\\sum_\limits{i_1 < \cdots < i_r}P(A_{i_1}\cdots A_{i_r}) = \cfrac{(n - r)!}{n!}C_n^r = \cfrac{1}{r!}.</script><p>故至少有一个人拿到自己帽子的概率为</p><script type="math/tex; mode=display">\begin{equation*}    \begin{aligned}    P(\sum_\limits{i = 1}^{n}A_i) &= \sum_\limits{r = 1}^{n}(-1)^{r - 1}\sum_\limits{i_1 < \cdots < i_r}P(A_{i_1}\cdots A_{i_r}) \\    &= \sum_\limits{r = 1}^{n}(-1)^{r - 1}\cfrac{1}{r!}.    \end{aligned}\end{equation*}</script><p>无人拿到自己帽子的概率为</p><script type="math/tex; mode=display">\begin{equation*}    \begin{aligned}    P_n &= 1 - P(\sum_\limits{i = 1}^{n}A_i) \\    &= 1 - \sum_\limits{r = 1}^{n}(-1)^{r - 1}\sum_\limits{i_1 < \cdots < i_r}P(A_{i_1}\cdots A_{i_r}) \\    &= \sum_\limits{r = 0}^{n}(-1)^{r}\cfrac{1}{r!} \\    &= \cfrac{1}{e}.    \end{aligned}\end{equation*}</script></li></ul><h2 id="条件概率"><a href="#条件概率" class="headerlink" title="条件概率"></a>条件概率</h2><ul><li><p><strong>定义(条件概率)</strong>  $P(A\mid B) := \cfrac{P(AB)}{P(B)}\,( 需\,P(B) &gt; 0)$.</p></li><li><p>$A\mid B$ 不是事件.</p></li><li><p><strong>计算</strong>  $(1)$ 缩小样本空间; $(2)$ 定义.</p></li><li><p><strong>定义(乘法法则)</strong>  $P(AB) = P(A\mid B)P(B) = P(B\mid A)P(A).$</p></li><li><p><strong>例</strong>  $8$ 个红球, $4$ 个白球, 等可能无放回地取出 $2$ 红球的概率为?</p></li><li><p><strong>解答</strong>  无放回地取出 $2$ 红球的概率为</p><script type="math/tex; mode=display">P(R_1R_2) = P(R_1)P(R_2\mid R_1) = \cfrac{8}{12}\times\cfrac{7}{11} = \cfrac{14}{33}.</script></li><li><p><strong>推广</strong></p><p>$P(A_1A_2\cdots A_n) = P(A_1)P(A_2\mid A_1)P(A_3\mid A_1A_2)\cdots P(A_n\mid A_1A_2\cdots A_{n - 1}).$</p></li><li><p><strong>解答续</strong>  在配对问题中, 注意到</p><script type="math/tex; mode=display">  \begin{equation*}      \begin{aligned}    P(A_{i_1}\cdots A_{i_r}) &= P(A_{i_1})P(A_{i_2}\mid A_{i_1})\cdots P(A_{i_r}\mid A_{i_1}A_{i_2}\cdots A_{i_{r - 1}}) \\    &= \cfrac{1}{n}\cdot\cfrac{1}{n - 1}\cdot\cfrac{1}{n - 2}\cdots\cfrac{1}{n - (r - 1)} \\    &= \cfrac{(n - r)!}{n!}.      \end{aligned}  \end{equation*}</script></li><li><p><strong>定义</strong></p><script type="math/tex; mode=display">  P(\cdot\mid B): \mathscr{F}\rightarrow\mathbb{R}</script><p>  令 $\widetilde{P} = P(\cdot\mid B)$, 则 $\widetilde{P}$ 满足以下三条公理:</p><ul><li>$\widetilde{P}(A)\ge 0, \forall A\in\mathscr{R}$</li><li>$\widetilde{P}(\Omega) = 1$</li><li><p>$\widetilde{P}(\sum_{i = 1}^{\infty}A_i) = \sum_{i = 1}^{\infty}\widetilde{P}(A_i), A_iA_j = \varnothing, \forall i\ne j$</p><p>故 $\widetilde{P}$ 为概率函数, $(\Omega, \mathscr{F}, \widetilde{P})$ 为新概率空间.</p></li></ul></li><li><p><strong>注</strong></p><ul><li>$P(A)\,\textbf{v.s.}\,\widetilde{P}(A) = P(A\mid B)$;</li><li>“已观测到 $A$ 发生, 则 $P(A) = 1$” 这句话是错误的, 因为 $P(A\mid A) = 1$.</li></ul></li></ul><h2 id="独立事件"><a href="#独立事件" class="headerlink" title="独立事件"></a>独立事件</h2><ul><li><p><strong>定义(独立事件)</strong>  若 $P(AB) = P(A)P(B)$, 则称事件 $A, B$ 相互独立.</p></li><li><p><strong>注</strong></p><ul><li>此时 $P(A\mid B) = P(A)$, 即 $\cfrac{P(AB)}{P(B)} = \cfrac{P(A\Omega)}{P(\Omega)}$;</li><li>事件 $B$ 的发生未改变 $A$ 发生的概率;</li><li>从实际角度判断可应用定义中的关系式; 一般利用定义判断独立性.</li></ul></li><li><p><strong>例</strong>  中奖率为 $10^{-5}$ 的彩票每周开奖, 不累积, 一个人购彩十年未中奖的概率为?</p></li><li><p><strong>解答</strong></p><p>每次购彩事件都是独立的.</p><p>设事件 $A_i = $ 第 $i$ 周未中奖, 那么 $P(A_i) = 1 - 10^{-5}$.</p><p>故 $P = P(A_1A_2\cdots A_{520}) = (1 - 10^{-5})^520 = 99.48\%$. </p></li><li><p>事件 $A, B$ 相互独立, 则事件 $A^c, B$ 相互独立.</p></li><li><p><strong>推广</strong></p><ul><li><p>$A, B, C\,相互独立\Leftrightarrow P(ABC) = P(A)P(B)P(C)\,且\,A, B, C\,两两独立$;</p></li><li><p>$A, B, C\,两两独立\nRightarrow A, B, C\,相互独立$</p><p>  (反例) 甲乙两人抛掷 $2$ 枚硬币. $A =$ 甲正, $B =$ 乙正, $C =$ 甲乙同.</p></li></ul></li><li><p><strong>定义(相互独立)</strong></p><p>  $A_1, A_2, \cdots, A_n\,相互独立\Leftrightarrow 任\,m\,个事件\,A_{i_1},\cdots, A_{i_m}, 有 P(A_{i_1}\cdots A_{i_m}) = P(A_{i_1})\cdots P(A_{i_m}).$</p></li><li><p><strong>定义(条件独立)</strong></p><p>  $A, B$ 关于事件 $E$ 条件独立 $\Leftrightarrow P(AB\mid E) = P(A\mid E)P(B\mid E)$.</p></li><li><p><strong>注</strong>  条件独立与独立不可互推.</p></li></ul><h2 id="textbf-Bayes-公式"><a href="#textbf-Bayes-公式" class="headerlink" title="$\textbf{Bayes}$ 公式"></a>$\textbf{Bayes}$ 公式</h2><ul><li><p><strong>定义(全概率公式)</strong>  给出 $\Omega$ 的一个分割</p><ul><li>$\sum_iB_i = \Omega$;</li><li>$B_iB_j = \varnothing, \forall\,i\ne j$;</li><li>$P(B_i) &gt; 0, \forall\,i$.</li></ul><p>则有</p><script type="math/tex; mode=display">P(A) = P(\sum_i(AB_i)) = \sum_iP(AB_i) = \sum_iP(A\mid B_i)P(B_i).</script></li><li><p><strong>定义(Bayes 公式)</strong></p><script type="math/tex; mode=display">  P(B_i\mid A) = \dfrac{P(A\mid B_i)P(B_i)}{\sum_jP(A\mid B_j)P(B_j)}</script><p>  其中 $P(B_i)$ 为先验概率, $P(B_i\mid A)$ 为后验概率.</p></li></ul><ul><li><p><strong>例</strong>  $A =$ 阳性, $B =$ 患病, $P(B) = 10^{-4}$, $P(A\mid B) = 0.99$, $P(A\mid B^c) = 10^{-3}$. 求 $P(B\mid A)$, $P(B\mid A_1A_2)$.</p></li><li><p><strong>解答</strong>  由 <strong>Bayes</strong> 公式, 容易得到</p><script type="math/tex; mode=display">  \begin{equation*}      \begin{aligned}          P(B\mid A)&= \dfrac{P(AB)}{P(A)} \\          &= \dfrac{P(A\mid B)P(B)}{P(A)} \\          &= \dfrac{P(A\mid B)P(B)}{P(A\mid B)P(B) + P(A\mid B^c)P(B^c)} \\          &= 9.01\%.      \end{aligned}  \end{equation*}</script><script type="math/tex; mode=display">  \begin{equation*}      \begin{aligned}          P(B\mid A_1A_2)&= \dfrac{P(A_1A_2B)}{P(A_1A_2)} \\          &= \dfrac{P(A_1A_2\mid B)P(B)}{P(A_1A_2)} \\          &= \dfrac{P(A_1A_2\mid B)P(B)}{P(A_1A_2\mid B)P(B) + P(A_1A_2\mid B^c)P(B^c)} \\          &= \dfrac{P(A\mid B)^2P(B)}{P(A\mid B)^2P(B) + P(A\mid B^c)^2P(B^c)} \\          &= 98.99\%.      \end{aligned}  \end{equation*}</script></li></ul><h2 id="一些讨论"><a href="#一些讨论" class="headerlink" title="一些讨论"></a>一些讨论</h2><ul><li>什么是概率?<ul><li>不确定性的一种度量;</li><li>具有不同的解释;</li><li>公理化定义.</li></ul></li><li>为什么用概率?<ul><li>不确定性的来源<ul><li>被建模系统的内在随机性;</li><li>不完全观测 (<strong>Monty Hall</strong> 中的参与者);</li><li>不完全建模.</li></ul></li><li>很多情况下, 简单而不确定的规则好于复杂而确定的规则</li><li>应用、维护、沟通</li></ul></li><li>怎么用概率?<ul><li>计算正确的概率;</li><li>正确计算概率;</li><li>正确使用概率.</li></ul></li></ul>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;Chap-1-概率&quot;&gt;&lt;a href=&quot;#Chap-1-概率&quot; class=&quot;headerlink&quot; title=&quot;Chap 1 概率&quot;&gt;&lt;/a&gt;Chap 1 概率&lt;/h1&gt;&lt;h2 id=&quot;试验与事件&quot;&gt;&lt;a href=&quot;#试验与事件&quot;</summary>
        
      
    
    
    
    <category term="Math" scheme="http://chengsx21.github.io/categories/Math/"/>
    
    <category term="Probability Theory" scheme="http://chengsx21.github.io/categories/Math/Probability-Theory/"/>
    
    
    <category term="Probability Theory" scheme="http://chengsx21.github.io/tags/Probability-Theory/"/>
    
  </entry>
  
  <entry>
    <title>复变函数</title>
    <link href="http://chengsx21.github.io/2022/12/31/fu-bian-han-shu/"/>
    <id>http://chengsx21.github.io/2022/12/31/fu-bian-han-shu/</id>
    <published>2022-12-31T12:31:59.000Z</published>
    <updated>2023-09-21T17:09:05.195Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-解析函数"><a href="#1-解析函数" class="headerlink" title="1. 解析函数"></a>1. 解析函数</h3><p>$\textbf{Example:}$<br>对于 $x, y\in\mathbb{R}$, 求 $\cos(x + iy)$ 的实, 虚部, 并说明方程</p><script type="math/tex; mode=display">\cos(x + iy) = A + iB\thinspace(A, B\in\mathbb{R})</script><p>有无穷多组解. ◻</p><p>$\textbf{Solution:}$<br>由于 <script type="math/tex">\cos z = \frac{1}{2}\left(e^{iz} + e^{-iz}\right),</script></p><p>得到 <script type="math/tex">\begin{aligned}            \cos(x + iy) &= \frac{1}{2}\left(e^{-y + ix} + e^{y - ix}\right) \\            &= \frac{1}{2}\left[e^{-y}\left(\cos x + i\sin x\right) + e^y\left(\cos x - i\sin x\right)\right] \\            &= \frac{1}{2}\cos x\left(e^y + e^{-y}\right) + \frac{1}{2}\sin x\left(e^{-y} - e^y\right)i.        \end{aligned}</script></p><p>于是 <script type="math/tex">\Re\cos(x + iy) = \frac{1}{2}\cos x\left(e^y + e^{-y}\right),</script></p><script type="math/tex; mode=display">\Im\cos(x + iy) = \frac{1}{2}\sin x\left(e^{-y} - e^y\right).</script><p>考虑方程组 <script type="math/tex">\begin{cases}            \frac{1}{2}\cos x\left(e^y + e^{-y}\right) = A, \\            \frac{1}{2}\sin x\left(e^{-y} - e^y\right) = B.        \end{cases}</script></p><p>$(1)$ 若$B = 0$:</p><p>$(a)$ $A &gt; 1$ 时,</p><p>取 $x = 2k\pi, \thinspace k\in\mathbb{Z}$, 考虑</p><script type="math/tex; mode=display">f(y) = e^y + e^{-y} - 2A.</script><p>因为 <script type="math/tex">f(0) = 2 - 2A < 0, \thinspace f(+\infty) = +\infty,</script></p><p>由介值定理得 <script type="math/tex">\exists\thinspace y_1 > 0, \thinspace f(y_1) = 0.</script></p><p>那么 <script type="math/tex">\begin{cases}            x = 2k\pi, \\            y = y_1,        \end{cases}</script></p><p>为原方程的解, $\forall k\in\mathbb{Z}$.</p><p>$(b)$ $A &lt; -1$ 时,</p><p>取 $x = 2k\pi + \pi, \thinspace k\in\mathbb{Z}$, 考虑</p><script type="math/tex; mode=display">g(y) = e^y + e^{-y} + 2A.</script><p>因为 <script type="math/tex">g(0) = 2 + 2A < 0, \thinspace g(+\infty) = +\infty,</script></p><p>由介值定理得 <script type="math/tex">\exists\thinspace y_2 > 0, \thinspace g(y_2) = 0.</script></p><p>那么 <script type="math/tex">\begin{cases}            x = 2k\pi + \pi, \\            y = y_2,        \end{cases}</script></p><p>为原方程的解, $\forall k\in\mathbb{Z}$.</p><p>$(c)$ $-1\le A\le 1$ 时,</p><p>取 $y = 0$, 考虑 <script type="math/tex">\cos x = A.</script></p><p>那么 <script type="math/tex">\begin{cases}            x = \arccos A + 2k\pi, \\            y = 0,        \end{cases}</script></p><p>为原方程的解, $\forall k\in\mathbb{Z}$.</p><p>$(2)$ 若$B \ne 0$:</p><p>可得</p><script type="math/tex; mode=display">\left(\frac{2A}{e^y + e^{-y}}\right)^2 + \left(\frac{2B}{e^{-y} - e^y}\right)^2 = 1.</script><p>令</p><script type="math/tex; mode=display">h(y) = \left(\frac{2A}{e^y + e^{-y}}\right)^2 + \left(\frac{2B}{e^{-y} - e^y}\right)^2 - 1,</script><p>因为 <script type="math/tex">h(0^{+}) = +\infty, \thinspace h(+\infty) = -1 < 0,</script></p><p>由介值定理得 <script type="math/tex">\exists\thinspace y_{AB} > 0, \thinspace h(y_{AB}) = 0.</script></p><p>那么 <script type="math/tex">\begin{cases}            x = \arccos\cfrac{2A}{e^{y_{AB}} + e^{-y_{AB}}} + 2k\pi, \\            y = y_{AB},        \end{cases}</script></p><p>为原方程的解, $\forall k\in\mathbb{Z}$. ◻</p><h3 id="2-Cauchy高阶导数公式"><a href="#2-Cauchy高阶导数公式" class="headerlink" title="2. Cauchy高阶导数公式"></a>2. Cauchy高阶导数公式</h3><p>$\textbf{Example:}$<br>$f(z)$ 在 $D$ 内解析, 则对 $z_0\in D$, 有</p><script type="math/tex; mode=display">f^{(n)}(z_0) = \frac{n!}{2\pi i}\oint_{\left|{z - z_0}\right| = r}\limits\frac{f(z)dz}{(z - z_0)^{n + 1}}.$$ ◻$\textbf{Solution:}$由于 $f(z)$ 在 $z_0$ 处解析, 可以认为$$f(z) = \sum_{k = 0}^{\infty}\limits\frac{1}{k!}f^{(k)}(z_0)(z - z_0)^k</script><p>在 $\left|{z - z_0}\right|\le r$ 内处处成立.</p><p>两边同时除以 $(z - z_0)^{n + 1}$, 再对 $\left|{z - z_0}\right| = r$<br>积分可得</p><script type="math/tex; mode=display">\oint_{\left|{z - z_0}\right| = r}\limits\frac{f(z)dz}{(z - z_0)^{n + 1}} = \frac{2\pi i}{n!}f^{(n)}(z_0).$$ ◻$\textbf{Example:}$求积分$$\oint_{\left|{z}\right| = 1}\limits\cfrac{1 - \cos 4z^5}{z^n}dz.$$ ◻$\textbf{Solution:}$当 $n = 0$ 时,由于 $f(z) = 1 - \cos 4z^5$ 在复平面上处处解析,得 $$\oint_{\left|{z}\right| = 1}\limits (1 - \cos 4z^5)dz = 0.</script><p>当 $n\ge 1$ 时,</p><script type="math/tex; mode=display">\cfrac{1 - \cos 4z^5}{z^n} = \sum_{k = 1}^{\infty}\limits\cfrac{1}{z^n}\cdot(-1)^k\cfrac{(4z^5)^{2k}}{(2k)!} = \sum_{k = 1}^{\infty}\limits\cfrac{(-1)^{k + 1}4^{2k}z^{10k - n}}{(2k)!}.</script><p>进而</p><script type="math/tex; mode=display">\oint_{\left|{z}\right| = 1}\limits\cfrac{1 - \cos 4z^5}{z^n}dz = \begin{cases}            2\pi i\cdot\cfrac{(-1)^{k + 1}16^k}{(2k)!}, n = 10k + 1 \\            0, n\ne 10k + 1 \\        \end{cases}        (\mbox{其中}k\in\mathbb{N})$$ ◻### 3. 最大模原理$\textbf{Example:}$$f(z)$ 非常函数, 在有界域 $D$ 内可导, 在边界 $\partial D$ 上连续, 则$$\max_{z\in D\cup\partial D}\limits\left|{f(z)}\right| = \max_{z\in \partial D}\limits\left|{f(z)}\right|,</script><p>并且满足 $f’(z_0)\ne 0$. ◻</p><p>$\textbf{Solution:}$<br>设 $z_0\in D\cup\partial D$ 使得<br>$f(z_0) = \max_{z\in D\cup\partial D}\limits\left|{f(z)}\right|$.</p><p>若 $z_0\in D$, 由平均值公式, $\exists\thinspace r_0 &gt; 0$,</p><p>当 $0 &lt; r\le r_0$ 时, $\left|{z - z_0}\right|$ 位于 $D$ 内. 那么</p><script type="math/tex; mode=display">\begin{aligned}            \left|{f(z_0)}\right| &= \frac{1}{2\pi}\left|{\int_0^{2\pi}\limits f(z_0 + re^{i\theta})d\theta}\right| \\            &\le \frac{1}{2\pi}\int_0^{2\pi}\limits \left|{f(z_0 + re^{i\theta})}\right|d\theta \\            &\le \frac{1}{2\pi}\int_0^{2\pi}\limits \left|{f(z_0)}\right|d\theta \\            &= \left|{f(z_0)}\right|,        \end{aligned}</script><p>即<br>$\left|{f(z)}\right|\equiv \left|{f(z_0)}\right|, \thinspace\forall \left|{z - z_0}\right| &lt; r$.</p><p>进而<br>$\left|{f(z)}\right|\equiv \left|{f(z_0)}\right|, \thinspace\forall z\in D$,<br>这与 $f(z)$ 为连续非常函数矛盾.</p><p>故若<br>$\left|{f(z_0)}\right| = \max_{z\in D\cup\partial D}\limits\left|{f(z)}\right|$,<br>则有 $z_0\in\partial D$. ◻</p><h3 id="4-最小模原理"><a href="#4-最小模原理" class="headerlink" title="4. 最小模原理"></a>4. 最小模原理</h3><p>$\textbf{Example:}$<br>$f(z)$ 非常函数, 在有界域 $D$ 内可导且非零, 在边界 $\partial D$<br>上连续, 则</p><script type="math/tex; mode=display">\min_{z\in D\cup\partial D}\limits\left|{f(z)}\right| = \min_{z\in \partial D}\limits\left|{f(z)}\right|,</script><p>并且满足 $f’(z_0)\ne 0$. ◻</p><p>$\textbf{Solution:}$<br>注意到 $\frac{1}{f(z)}$ 是解析的, 再使用最大模原理即可. ◻</p><h3 id="5-调和函数最大值原理"><a href="#5-调和函数最大值原理" class="headerlink" title="5. 调和函数最大值原理"></a>5. 调和函数最大值原理</h3><p>$\textbf{Example:}$<br>$u(x, y)\in C^2(D)$ 为调和函数, 在边界 $\partial D$ 上连续, 则</p><script type="math/tex; mode=display">\max_{(x, y)\in D\cup\partial D}\limits\left|{u(x, y)}\right| = \max_{(x, y)\in \partial D}\limits\left|{u(x, y)}\right|.$$ ◻$\textbf{Solution:}$由于 $u$ 为调和函数, 故存在调和函数 $v$,其中 $u, v$ 满足 $Cauchy-Riemann$ 条件, 使得 $f(z) = u + iv$ 为解析函数.令 $g(z) = e^{f(z)}\thinspace(z\in D\cup\partial D)$, 那么$g'(z) = f'(z)e^{f(z)}$ 处处存在.由最大模原理,$$\max_{z\in D\cup\partial D}\limits\left|{g(z)}\right| = \max_{z\in \partial D}\limits\left|{g(z)}\right|.</script><p>又因为</p><script type="math/tex; mode=display">\left|{g(z)}\right| = \left|{e^{f(z)}}\right| = \left|{e^{u + iv}}\right| = \left|{e^u}\right|\cdot \left|{e^{iv}}\right| = e^u,</script><p>故</p><script type="math/tex; mode=display">\max_{z\in D\cup\partial D}\limits e^{u(x, y)} = \max_{z\in \partial D}\limits e^{u(x, y)}.</script><p>即得</p><script type="math/tex; mode=display">\max_{z\in D\cup\partial D}\limits u(x, y) = \max_{z\in \partial D}\limits u(x, y).$$ ◻### 6. 调和函数最小值原理$\textbf{Example:}$$u(x, y)\in C^2(D)$ 为调和函数, 在边界 $\partial D$ 上连续, 则$$\min_{(x, y)\in D\cup\partial D}\limits\left|{u(x, y)}\right| = \min_{(x, y)\in \partial D}\limits\left|{u(x, y)}\right|.$$ ◻$\textbf{Solution:}$注意到 $u_0(x, y) = -u(x, y)$ 也为 $D$ 上的调和函数,对其使用调和函数最大值原理即可. ◻### 7. $M(r)$的应用$\textbf{Example:}$定义$$M(r) = \max_{\left|{z}\right| = r}\limits\left|{f(z)}\right|.$$ ◻$\textbf{Example:}$$f(z)$ 为整函数, 则$$\left|{f^{(n)}(0)}\right|\le \frac{n!M(r)}{r^n}.$$ ◻$\textbf{Solution:}$注意到$$f^{(n)}(0) = \frac{n!}{2\pi i}\oint_{\left|{z}\right| = r}\limits\frac{f(z)dz}{z^{n + 1}},</script><p>那么 <script type="math/tex">\begin{aligned}            \left|{f^{(n)}(0)}\right| &= \frac{n!}{2\pi}\left|{\thinspace\oint_{\left|{z}\right| = r}\limits\frac{f(z)dz}{z^{n + 1}}}\right| \\            &\le \frac{n!}{2\pi}\oint_{\left|{z}\right| = r}\limits\left|{\frac{f(z)}{z^{n + 1}}}\right|\left|{dz}\right| \\            &= \frac{n!}{2\pi}\oint_{\left|{z}\right| = r}\limits\frac{\left|{f(z)}\right|}{r^{n + 1}}\left|{d(re^{i\theta})}\right| \\            &\le \frac{n!}{2\pi}\int_{0}^{2\pi}\frac{M(r)}{r^n}d\theta \\            &= \frac{n!M(r)}{r^n}.        \end{aligned}</script> ◻</p><p>$\textbf{Example:}$<br>有界的整函数为常数<strong>(Liouville定理)</strong>. ◻</p><p>$\textbf{Solution:}$<br>易得 $f(z)$ 在原点处的 $Taylor$ 展开:</p><script type="math/tex; mode=display">f(z) = \sum_{n = 0}^{\infty}\limits\frac{1}{n!}f^{(n)}(0)z^n.</script><p>只需要证明 <script type="math/tex">f^{(n)}(0)\equiv 0, \thinspace\forall\thinspace n\ge 1.</script></p><p>由 $f(z)$ 有界, 故 $\exists\thinspace M_0\in\mathbb{R}$, 使</p><script type="math/tex; mode=display">\left|{f(z)}\right|\le M_0, \thinspace\forall z\in\mathbb{C}.</script><p>由</p><script type="math/tex; mode=display">f^{(n)}(0) = \frac{n!}{2\pi i}\oint_{\left|{z}\right| = r}\limits\frac{f(z)dz}{z^{n + 1}},</script><p>可得</p><script type="math/tex; mode=display">\left|{f^{(n)}(0)}\right|\le \frac{n!M(r)}{r^n}\le \frac{n!M_0}{r^n}.</script><p>注意到当 $r\rightarrow\infty$, 有 <script type="math/tex">\left|{f^{(n)}(0)}\right| = 0,</script></p><p>即 <script type="math/tex">f^{(n)}(0) = 0\thinspace, \thinspace\forall\thinspace n\ge 1.</script></p><p>从而 $f(z)\equiv f(0)$ 为常数. ◻</p><p>$\textbf{Example:}$<br>$f(z)$ 为整函数, 且存在 $M_0 &gt; 0$, 使</p><script type="math/tex; mode=display">\left|{f(z)}\right|\le M\sum_{k = 0}^{n}\limits\left|{z}\right|^k.</script><p>则 $f(z)$ 是一个次数不高于 $n$ 的多项式. ◻</p><p>$\textbf{Solution:}$<br>易得 $f(z)$ 在原点处的 $Taylor$ 展开:</p><script type="math/tex; mode=display">f(z) = \sum_{n = 0}^{\infty}\limits\frac{1}{n!}f^{(n)}(0)z^n.</script><p>只需要证明</p><script type="math/tex; mode=display">f^{(n + i)}(0)\equiv 0, \thinspace\forall\thinspace i\ge 1.</script><p>可得</p><script type="math/tex; mode=display">\left|{f^{(n + i)}(0)}\right|\le \frac{(n + i)!M(r)}{r^{n + i}}\le \frac{(n + i)!M_0}{r^{n + i}}\sum_{k = 0}^{n}\limits r^k.</script><p>注意到当 $r\rightarrow\infty$ 时, 有</p><script type="math/tex; mode=display">\left|{f^{(n + i)}(0)}\right| = 0,</script><p>即 <script type="math/tex">f^{(n + i)}(0) = 0, \thinspace\forall\thinspace i\ge 1.</script></p><p>从而 <script type="math/tex">f(z)\equiv \sum_{k = 0}^{n}\limits\frac{1}{k!}f^{(k)}(0)z^k</script></p><p>为一个次数不高于 $n$ 的多项式. ◻</p><h3 id="8-代数学基本定理"><a href="#8-代数学基本定理" class="headerlink" title="8. 代数学基本定理"></a>8. 代数学基本定理</h3><p>$\textbf{Example:}$<br>设<br>$P_n(z) = \sum_{k = 0}^{n}\limits C_kz^k\thinspace(C_n\ne 0, n\ge 1)$,<br>则 <script type="math/tex">P_n(z) = C_n\prod_{k = 0}^{n}(z - z_k),</script></p><p>即 <script type="math/tex">\exists z_1\in \mathbb{C}, P_n(z_1) = 0.</script> ◻</p><p>$\textbf{Solution:}$<br>设 $\forall z\in\mathbb{C}$, 有 $P_n(z)\ne 0$.</p><p>令 $f(z) = \cfrac{1}{P_n(z)}$, 则 <script type="math/tex">f'(z) = -\cfrac{P'_n(z)}{P_n^2(z)}</script></p><p>处处存在, 那么 $f(z)$ 满足最大模原理, 有</p><script type="math/tex; mode=display">\max_{\left|{z}\right|\le r}\limits\left|{f(z)}\right| = \max_{\left|{z}\right| = r}\limits\left|{f(z)}\right|\rightarrow 0, \mbox{当}r\rightarrow\infty.</script><p>但结合 $f(0) = \cfrac{1}{C_0}\ne 0$, 显然矛盾.</p><p>故 $\exists\thinspace z_1\in \mathbb{C}$, 使得</p><script type="math/tex; mode=display">P_n(z_1) = 0\thinspace\Longleftrightarrow P_n(z) = (z - z_1)P_{n - 1}(z).</script><p>重复可得 <script type="math/tex">P_n(z) = C_n\prod_{k = 0}^{n}(z - z_k).</script> ◻</p><p>$\textbf{Solution:}$<br>设 $\forall z\in\mathbb{C}$, 有 $P_n(z)\ne 0$.</p><p>令 $g(z) = \cfrac{1}{P_n(z)}$, 则 <script type="math/tex">g'(z) = -\cfrac{P'_n(z)}{P_n^2(z)}</script></p><p>处处存在, 那么 $g(z)$ 在 $\mathbb{C}$ 内解析. 由于</p><script type="math/tex; mode=display">P_n(z)\rightarrow\infty, \mbox{当}r\rightarrow\infty,</script><p>故 <script type="math/tex">g(z)\rightarrow 0, \mbox{当}r\rightarrow\infty,</script></p><p>即 $g(z)$ 有界.</p><p>由 $Liouville$ 定理, 得 $g(z)$ 为常数, 进而 $P_n(z)$ 为常数.</p><p>这与 $C_n\ne 0$ 矛盾. 以下同 $\textit{Proof 1}$. ◻</p><h3 id="9-幂级数的收敛半径"><a href="#9-幂级数的收敛半径" class="headerlink" title="9. 幂级数的收敛半径"></a>9. 幂级数的收敛半径</h3><p>$\textbf{Example:}$<br>对幂级数 $f(z) = \sum_{k = 0}^{\infty}\limits c_kz^k$, 若存在<br>$R &gt; 0$, 使得</p><p>当 $\left|{z}\right| &gt; R$ 时 $f(z)$ 发散, 当 $\left|{z}\right| &lt; R$ 时<br>$f(z)$ 绝对收敛,</p><p>那么称 $R$ 为 $f(z)$ 的收敛半径. ◻</p><p>$\textbf{Example:}$<br>$\textbf{(Abel定理)}$ 对幂级数<br>$f(z) = \sum_{k = 0}^{\infty}\limits c_kz^k$, 若</p><p>$f(z)$ 在 $z = z_1\ne 0$ 处收敛, 则在<br>$\left|{z}\right| &lt; \left|{z_1}\right|$ 绝对收敛;</p><p>$f(z)$ 在 $z = z_2\ne 0$ 处发散, 则在<br>$\left|{z}\right| &gt; \left|{z_2}\right|$ 发散. ◻</p><p>$\textbf{Example:}$<br>若幂级数 $f(z) = \sum_{k = 0}^{\infty}\limits c_kz^k$ 在 $z_0$<br>处条件收敛, 则收敛半径 $R = \left|{z_0}\right|$. ◻</p><p>$\textbf{Solution:}$<br>由收敛半径的定义:</p><p>若 $\left|{z_o}\right| &gt; R$ $\Longrightarrow$ $f(z_0)$ 发散, 与题设矛盾,<br>故 $f(z_0)$ 收敛, $\left|{z_0}\right|\le R$.</p><p>若 $\left|{z_0}\right| &lt; R$ $\Longrightarrow$ $f(z_0)$ 绝对收敛,<br>与题设矛盾, 故 $\left|{z_0}\right|\ge R$.</p><p>综上, 得 $\left|{z_0}\right| = R$. ◻</p><p>$\textbf{Example:}$<br>对幂级数</p><script type="math/tex; mode=display">f(z) = \sum_{k = 0}^{\infty}\limits c_kz^k, g(z) = \sum_{k = 0}^{\infty}\limits d_kz^k</script><p>当 $n$ 充分大时, 有 $\left|{d_n}\right| \le \left|{c_n}\right|$,<br>则收敛半径 $R_1\le R_2$. ◻</p><p>$\textbf{Example:}$<br>若 $c_n = a_n + ib_n, a_n, b_n\in\mathbb{R}$, 对幂级数</p><script type="math/tex; mode=display">f(z) = \sum_{n = 0}^{\infty}\limits c_nz^n = \sum_{n = 0}^{\infty}\limits a_nz^n + i\sum_{n = 0}^{\infty}\limits b_nz^n</script><p>其中<br>$\sum_{n = 0}^{\infty}\limits a_nz^n, \sum_{n = 0}^{\infty}\limits b_nz^n$<br>的收敛半径分别为 $R_1, R_2$, 那么 $\sum_{n = 0}^{\infty}\limits c_nz^n$<br>的收敛半径 $R = \min\left\{R_1, R_2\right\}$. ◻</p><p>$\textbf{Solution:}$<br>不妨设 $R_1\le R_2$, 此时 $\min\left\{R_1, R_2\right\} = R_1$.</p><p>下证 $R = R_1$. 先证 $R_1\ge R$.</p><p>由 $c_n = a_n + ib_n$, 有 $\left|{c_n}\right| \ge \left|{a_n}\right|$,<br>进而</p><script type="math/tex; mode=display">\sum_{n = 0}^{\infty}\limits \left|{c_nz^n}\right| \ge \sum_{n = 0}^{\infty}\limits \left|{a_nz^n}\right|.</script><p>那么当 $\left|{z}\right| &lt; R$ 时, 由收敛半径定义,</p><script type="math/tex; mode=display">\sum_{n = 0}^{\infty}\limits \left|{c_nz^n}\right| \ge \sum_{n = 0}^{\infty}\limits \left|{a_nz^n}\right| < \infty.</script><p>此时 $\sum_{n = 0}^{\infty}\limits a_nz^n$ 绝对收敛, 那么 $R_1 \ge R$.</p><p>再证 $R_1\le R$.</p><p>若 $R_1 &gt; R$, 取<br>$z = \cfrac{1}{2}\left(R + R_1\right)\in\left(R, R_1\right)$ 由</p><script type="math/tex; mode=display">\sum_{n = 0}^{\infty}\limits c_nz^n = \sum_{n = 0}^{\infty}\limits a_nz^n + i\sum_{n = 0}^{\infty}\limits b_nz^n</script><p>那么此时 $\sum_{n = 0}^{\infty}\limits a_nz^n$,<br>$\sum_{n = 0}^{\infty}\limits b_nz^n$ 均收敛,</p><p>进而 $\sum_{n = 0}^{\infty}\limits c_nz^n$ 收敛, 且 $z &gt; R$,<br>与收敛半径定义矛盾. 故 $R_1\le R$.</p><p>综上, 有 $R = \min\left\{R_1, R_2\right\}$ 成立. ◻</p><p>$\textbf{Example:}$<br>若 $f(z)$ 在 $R$ 上无奇点, 则收敛半径 $R = +\infty$;</p><p>若 $f(z)$ 在 $R$ 上有奇点 $z_1, z_2, \cdots, z_n$, 则收敛半径<br>$R = \min_{1\le k\le n}\limits \left|{z_k}\right|$. ◻</p><h3 id="10-幂级数的敛散性"><a href="#10-幂级数的敛散性" class="headerlink" title="10. 幂级数的敛散性"></a>10. 幂级数的敛散性</h3><p>$\textbf{Example:}$</p><script type="math/tex; mode=display">f_1(z) = \sum_{n = 1}^{\infty}\limits z^n</script><p>在收敛圆周上处处发散. ◻</p><p>$\textbf{Solution:}$<br>收敛半径 $R = 1$. 当 $\left|{z}\right| = 1$ 时,<br>$z = e^{i\theta}\thinspace(\theta\in\left[0, 2\pi\right))$,</p><p>那么</p><script type="math/tex; mode=display">\left|{z^n}\right| = \left|{e^{in\theta}}\right| = 1\nrightarrow 0, \mbox{当}\thinspace n\rightarrow \infty.</script><p>由 $Cauchy$ 收敛准则, <script type="math/tex">f_1(z) = \sum_{n = 1}^{\infty}\limits z^n</script></p><p>在收敛圆周上处处发散. ◻</p><p>$\textbf{Example:}$</p><script type="math/tex; mode=display">f_2(z) = \sum_{n = 1}^{\infty}\limits \frac{z^n}{n}</script><p>在收敛圆周上部分发散, 部分收敛. ◻</p><p>$\textbf{Solution:}$<br>注意到</p><script type="math/tex; mode=display">f_2(z) = \sum_{n = 1}^{\infty}\limits\int_{0}^{z} t^{n - 1}dt = \int_{0}^{z}\sum_{n = 1}^{\infty}\limits t^{n - 1}dt = -\ln(1 - z), \left|{z}\right| < 1 = R.</script><p>且 $f_2(1) = \sum_{n = 1}^{\infty}\limits\cfrac{1}{n}$ 发散,<br>$f_2(-1) = \sum_{n = 1}^{\infty}\limits\cfrac{(-1)^n}{n} = -\ln2$ 收敛.</p><p>那么 <script type="math/tex">f_2(z) = \sum_{n = 1}^{\infty}\limits\frac{z^n}{n}</script></p><p>在收敛圆周上部分发散, 部分收敛. ◻</p><p>$\textbf{Example:}$<br>给出</p><script type="math/tex; mode=display">\sum_{n = 1}^{\infty}\limits\frac{\cos{n\theta}}{n}, \sum_{n = 1}^{\infty}\limits\frac{\sin{n\theta}}{n}</script><p>的和函数, 其中 $\theta\in\left(0, 2\pi\right)$. ◻</p><p>$\textbf{Solution:}$<br>注意到对于<br>$z = x + iy\in\mathbb{C}, \mbox{其中}\thinspace x, y\in\mathbb{R}$, 有</p><script type="math/tex; mode=display">\ln(x + iy) = \ln\left|{x + iy}\right| + i\theta = \frac{1}{2}\ln(x^2 + y^2) + i\arctan\frac{y}{x}.</script><p>对于 $z = re^{i\theta}, 0\le r &lt; 1, 0\le\theta &lt; 2\pi$, 有</p><script type="math/tex; mode=display">\sum_{n = 1}^{\infty}\limits\frac{r^ne^{in\theta}}{n} = -\ln(1-re^{i\theta}) = -\ln(1-r\cos\theta - i\sin\theta),</script><p>展开得</p><script type="math/tex; mode=display">\sum_{n = 1}^{\infty}\limits\frac{r^n\cos{n\theta}}{n} + i\sum_{n = 1}^{\infty}\limits\frac{r^n\sin{n\theta}}{n} = -\frac{1}{2}\ln(1 - 2r\cos\theta + r^2) + i\arctan\frac{r\sin\theta}{1 - r\cos\theta}.</script><p>当 $\theta\in\left(0, 2\pi\right)$ 时, 令 $r\rightarrow 1^{-}$, 即得</p><script type="math/tex; mode=display">\sum_{n = 1}^{\infty}\limits\frac{\cos{n\theta}}{n} = -\frac{1}{2}\ln(2 - 2\cos\theta) = -\ln\left(2\sin\frac{\theta}{2}\right),</script><script type="math/tex; mode=display">\sum_{n = 1}^{\infty}\limits\frac{\sin{n\theta}}{n} = \arctan\frac{\sin\theta}{1 - \cos\theta} = \arctan\left(\cot\frac{\theta}{2}\right) = \frac{\pi - \theta}{2}.$$ ◻$\textbf{Example:}$给出$$\sum_{n = 1}^{\infty}\limits\frac{\cos{n\theta}}{n^2}, \sum_{n = 1}^{\infty}\limits\frac{\sin{n\theta}}{n^2}</script><p>的和函数, 其中 $\theta\in\left[0, 2\pi\right)$. ◻</p><p>$\textbf{Solution:}$<br>注意到</p><script type="math/tex; mode=display">\sum_{n = 1}^{\infty}\limits\frac{\cos{n\theta}}{n^2} = \sum_{n = 1}^{\infty}\frac{1}{n^2} - \sum_{n = 1}^{\infty}\limits\int_{0}^{\theta}\frac{\sin{nt}}{n}dt = \frac{\pi^2}{6} - \frac{\theta\left(2\pi - \theta\right)}{4}.</script><script type="math/tex; mode=display">\sum_{n = 1}^{\infty}\limits\frac{\sin{n\theta}}{n^2} = \sum_{n = 1}^{\infty}\limits\int_{0}^{\theta}\frac{\cos{nt}}{n}dt = \int_{0}^{\theta}\sum_{n = 1}^{\infty}\limits\frac{\cos{nt}}{n}dt = -\int_{0}^{\theta}\ln\left(2\sin\frac{t}{2}\right)dt.$$ ◻$\textbf{Example:}$$$f_3(z) = \sum_{n = 1}^{\infty}\limits \frac{z^n}{n^2}</script><p>在收敛圆周上处处收敛. ◻</p><p>$\textbf{Solution:}$<br>注意到当 $\left|{z}\right| = 1$ 时,</p><script type="math/tex; mode=display">\sum_{n = 1}^{\infty}\left|{\frac{z^n}{n^2}}\right| = \sum_{n = 1}^{\infty}\frac{1}{n^2} = \frac{\pi^2}{6},</script><p>那么 <script type="math/tex">f_3(z) = \sum_{n = 1}^{\infty}\limits \frac{z^n}{n^2}</script></p><p>在收敛圆周上处处收敛. ◻</p><p>$\textbf{Example:}$<br>幂级数收敛圆周上的点都是其奇点. ◻</p><h3 id="11-Laurent-级数"><a href="#11-Laurent-级数" class="headerlink" title="11. Laurent 级数"></a>11. Laurent 级数</h3><p>$\textbf{Example:}$<br>$\mathbb{C}^2$ 上的分片函数: <script type="math/tex">f(z) = \cfrac{1}{1 + z^2} =         \begin{cases}            \sum_{n = 0}^{\infty}\limits(-1)^nz^{2n}, \left|{z}\right| < 1 \\            \cfrac{1}{1 + z^2}, \left|{z}\right| = 1, z\ne\pm i \\            \sum_{n = 0}^{\infty}\limits\cfrac{(-1)^n}{z^{2(n + 1)}}, \left|{z}\right| > 1         \end{cases}</script> ◻</p><h3 id="12-留数-A"><a href="#12-留数-A" class="headerlink" title="12. 留数 A"></a>12. 留数 A</h3><p>$\textbf{Example:}$<br>求复积分</p><script type="math/tex; mode=display">I = \oint_{\left|{z}\right| = \varepsilon > 1}e^{\frac{1}{z}}dz.$$ ◻$\textbf{Solution:}$令 $t = \cfrac{1}{z}$, $dz = -\cfrac{dt}{t^2}$. 记$z = \varepsilon e^{i\theta}$, 那么$t = \cfrac{1}{\varepsilon}e^{-i\theta}$,$\theta\in\left[0, 2\pi\right)$.那么$$I = -\oint_{\left|{t}\right| = \frac{1}{\varepsilon}}{e^t\left(-\frac{dt}{t^2}\right)} = \oint_{\left|{t}\right| = \frac{1}{\varepsilon}}\frac{e^t}{t^2}dt = 2\pi i\left(e^t\right)'|_{t = 0} = 2\pi i.$$ ◻$\textbf{Solution:}$注意到$$I = \oint_{\left|{z}\right| = \varepsilon}\limits e^{\frac{1}{z}}dz = \sum_{n = 0}^{+\infty}\cfrac{1}{n!}\oint_{\left|{z}\right| = \varepsilon}\cfrac{dz}{z^n} = \sum_{n = 0}^{+\infty}\limits\cfrac{1}{n!}I_n = I_1 = 2\pi i.$$ ◻$\textbf{Example:}$求复积分$$J_n = \oint_{\left|{z}\right| = r > 1}\cfrac{dz}{1 + z^n}, n\in\mathbb{N}.$$ ◻$\textbf{Solution:}$令 $t = \cfrac{1}{z}$, $dz = -\cfrac{dt}{t^2}$. 那么$$\begin{aligned}            J_n &= -\oint_{\left|{t}\right| = \frac{1}{r}}\cfrac{1}{1 + \frac{1}{t^n}}\left(-\frac{dt}{t^2}\right) \\            &= \oint_{\left|{t}\right| = \frac{1}{r}}\cfrac{t^{n - 2}}{1 + t^n}dt \\            &= \begin{cases}                2\pi i, n = 1; \\                0, n\ge 2.            \end{cases}        \end{aligned}$$ ◻$\textbf{Solution:}$$$\begin{aligned}            J_n &= 2\pi i\sum_{k = 1}^{n}\limits Res\left[\frac{1}{1 + z^n}, z_k\right] \\            &= 2\pi i\sum_{k = 1}^{n}\limits\cfrac{1}{nz_k^{n - 1}} \\            &= \cfrac{2\pi i}{n}\sum_{k = 1}^{n}(-z_k) \\            &= -\cfrac{2\pi i}{n}\sum_{k = 1}^{n}z_k \\            &= \begin{cases}                2\pi i, n = 1; \\                0, n\ge 2.            \end{cases}        \end{aligned}$$ ◻$\textbf{Example:}$给出$$K_n = \oint_{\left|{z}\right| = r > 1}\cfrac{z^{2n}dz}{1 + z^n} = \oint_{\left|{z}\right| = r}\cfrac{dz}{1 + z^n} + \oint_{\left|{z}\right| = r}(z^n - 1) = J_n, n\in\mathbb{N}.$$ ◻$\textbf{Example:}$求复积分$$J = \oint_{\left|{z}\right| = r > 1}\frac{z^3e^{\frac{1}{z}}}{1 + z}dz.$$ ◻$\textbf{Solution:}$令 $t = \cfrac{1}{z}$, $dz = -\cfrac{dt}{t^2}$. 从而$$J = \oint_{\left|{t}\right| = \frac{1}{r}}\frac{e^t}{t^4(1 + t)}dt = \cfrac{2\pi i}{3!}\left(\frac{e^t}{1 + t}\right)^{(3)}|_{t = 0} = -\frac{2}{3}\pi i.$$ ◻$\textbf{Solution:}$令 $t = \cfrac{1}{z}$, $dz = -\cfrac{dt}{t^2}$. 从而$$\begin{aligned}            J &= \oint_{\left|{t}\right| = \frac{1}{r}}\frac{e^t}{t^4(1 + t)}dt \\            &= \oint_{\left|{t}\right| = \frac{1}{r}}\frac{e^t(1 - t^4 + t^4)}{t^4(1 + t)}dt \\            &= \oint_{\left|{t}\right| = \frac{1}{r}}\frac{e^t(1 - t^4)}{t^4(1 + t)}dt + \oint_{\left|{t}\right| = \frac{1}{r}}\frac{e^tt^4}{1 + t}dt \\            &= \oint\frac{e^t}{t^4}dt - \oint\frac{e^t}{t^3}dt + \oint\frac{e^t}{t^2}dt - \oint\frac{e^t}{t}dt \\            &= 2\pi i\left(\frac{1}{3!} - \frac{1}{2!} + \frac{1}{1!} - \frac{1}{0!}\right) \\            &= -\frac{2}{3}\pi i.        \end{aligned}$$ ◻$\textbf{Solution:}$令 $t = \cfrac{1}{z}$, $dz = -\cfrac{dt}{t^2}$. 从而$$J = \oint_{\left|{t}\right| = \frac{1}{r}}\frac{e^t}{t^4(1 + t)}dt,</script><p>注意到 <script type="math/tex">\begin{aligned}            \frac{e^t}{t^4(1 + t)} &= \frac{1}{t^4}\left(1 + t + \frac{t^2}{2!} + \frac{t^3}{3!} + \cdots\right)\left(1 - t + t^2 - t^3 + \cdots\right) \\            &= \frac{1}{t^4}\left(1 + \frac{1}{2}t^2 - \frac{1}{3}t^3 + O(t^3)\right),        \end{aligned}</script></p><p>故 <script type="math/tex">\begin{aligned}            J &= \oint_{\left|{t}\right| = \frac{1}{r}}\frac{1}{t^4}\left(1 + \frac{1}{2}t^2 - \frac{1}{3}t^3 + O(t^3)\right) \\            &= I_4 + \frac{1}{2}I_2 - \frac{1}{3}I_1 \\            &= -\frac{1}{3}I_1 \\            &= -\frac{2}{3}\pi i.        \end{aligned}</script> ◻</p><p>$\textbf{Solution:}$</p><script type="math/tex; mode=display">\begin{aligned}            J &= \oint_{\left|{z}\right| = r > 1}\frac{z^3e^{\frac{1}{z}}}{1 + z}dz \\            &= 2\pi i\left\{Res\left[f, 0\right] + Res\left[f, -1\right]\right\}.        \end{aligned}</script><p>注意到 <script type="math/tex">\begin{aligned}            Res\left[f, -1\right] = \frac{(-1)^3e^{-1}}{1} = -e^{-1},        \end{aligned}</script></p><p>而 $Res\left[f, 0\right]$ 为 $f$ 在 $z_0 = 0$ 处 $Larent$ 级数中的系数<br>$C_{-1}$.</p><p>注意到 <script type="math/tex">\begin{aligned}            \frac{z^3e^{\frac{1}{z}}}{1 + z} = z^3\left(1 + \frac{1}{z} + \frac{1}{2!z^2} + \frac{1}{3!z^3} + \cdots\right)\left(1 - z + z^2 - z^3 + \cdots\right),        \end{aligned}</script></p><p>那么</p><script type="math/tex; mode=display">C_{-1} = \frac{1}{4!} - \frac{1}{5!} + \frac{1}{6!} - \frac{1}{7!} + \cdots = e^{-1} - \frac{1}{3}.</script><p>进而 <script type="math/tex">\begin{aligned}            J &= \oint_{\left|{z}\right| = r > 1}\frac{z^3e^{\frac{1}{z}}}{1 + z}dz \\            &= 2\pi i\left\{Res\left[f, 0\right] + Res\left[f, -1\right]\right\} \\            &= 2\pi i\left(-e^{-1} + e^{-1} - \frac{1}{3}\right) \\            &= -\frac{2}{3}\pi i.        \end{aligned}</script> ◻</p><p>$\textbf{Example:}$<br>求复积分</p><script type="math/tex; mode=display">I_{a, b} = \int_{0}^{2\pi}\cfrac{d\theta}{a + b\cos\theta},</script><p>其中 $a &gt; \left|{b}\right|$, $a, b\in\mathbb{R}$. ◻</p><p>$\textbf{Solution:}$<br>令</p><script type="math/tex; mode=display">z = e^{i\theta}\Longrightarrow \cos\theta = \cfrac{z + z^{-1}}{2}.</script><p>那么</p><script type="math/tex; mode=display">dz = ie^{i\theta}d\theta = izd\theta\Longrightarrow d\theta = \cfrac{dz}{iz}.</script><p>进而</p><script type="math/tex; mode=display">I_{a, b} = \int_{0}^{2\pi}\cfrac{d\theta}{a + b\frac{z + z^{-1}}{2}} = \cfrac{2}{i}\oint_{\left|{z}\right| = 1}\cfrac{dz}{bz^2 + 2az + b}.</script><p>$\circ$ 若 $b = 0$, 得 <script type="math/tex">I_{a, b} = \frac{2\pi}{a}.</script></p><p>$\circ$ 若 $b &gt; 0$, 考虑方程 $z^2 + 2\cfrac{a}{b}z + 1 = 0$. 解得</p><script type="math/tex; mode=display">\begin{aligned}            \begin{cases}                z_1 = -\cfrac{a}{b} + \cfrac{\sqrt{a^2 - b^2}}{b},\\                z_2 = -\cfrac{a}{b} - \cfrac{\sqrt{a^2 - b^2}}{b} < -\cfrac{a}{b} < -1.                    \end{cases}        \end{aligned}</script><p>故</p><script type="math/tex; mode=display">I_{a, b} = \cfrac{2}{i}\cdot 2\pi i\cdot Res\left[f(z), z_1\right] = \cfrac{2}{i}\cdot 2\pi i\cdot\cfrac{1}{2bz_1 + 2a} = \cfrac{2\pi}{\sqrt{a^2 - b^2}}.</script><p>$\circ$ 若 $b &lt; 0$, 同理有</p><script type="math/tex; mode=display">I_{a, b} = \cfrac{2\pi}{\sqrt{a^2 - b^2}}.</script><p>综上, 有</p><script type="math/tex; mode=display">I_{a, b} = \int_{0}^{2\pi}\cfrac{d\theta}{a + b\cos\theta} = \cfrac{2\pi}{\sqrt{a^2 - b^2}}.$$ ◻$\textbf{Example:}$求复积分$$I_p = \int_{0}^{2\pi}\cfrac{d\theta}{1 + p^2 - 2p\cos\theta},</script><p>其中 $p\in(-1, 1).$ ◻</p><p>$\textbf{Solution:}$<br>在 $I_{a, b}$ 中取 $a = 1 + p^2$, $b = -2p$, 得</p><script type="math/tex; mode=display">I_p = \cfrac{2\pi}{\sqrt{(1 + p^2)^2 - (-2p)^2}} = \cfrac{2\pi}{1 - p^2}.$$ ◻$\textbf{Example:}$求复积分$$J_{a, b} = \int_{0}^{2\pi}\cfrac{d\theta}{a^2\cos^2\theta + b^2\sin^2\theta},</script><p>其中 $a &gt; 0$, $b &gt; 0$. ◻</p><p>$\textbf{Solution:}$</p><script type="math/tex; mode=display">J_{a, b} = \int_{0}^{2\pi}\cfrac{2d\theta}{(a^2 + b^2) + (a^2 - b^2)\cos 2\theta} = \int_{0}^{4\pi}\cfrac{dt}{(a^2 + b^2) + (a^2 - b^2)\cos t},</script><p>在 $I_{A, B}$ 中取 $A = a^2 + b^2$, $B = a^2 - b^2$, 得</p><script type="math/tex; mode=display">J_{a, b} = 2\cfrac{2\pi}{\sqrt{(a^2 + b^2)^2 - (a^2 - b^2)^2}} = \cfrac{2\pi}{ab}.$$ ◻### 13. 留数 B$\textbf{Example:}$$C_R: Re^{i\theta}$, $0\le\theta\le\pi$, 多项式 $P$, $Q$ 满足$\deg Q\ge\deg P + 2$, 则$$\lim_{R\rightarrow +\infty}\limits\int_{C_R}\frac{P(z)}{Q(z)}dz = 0.$$ ◻$\textbf{Example:}$求积分$$I_{a, b} = \int_{0}^{+\infty}\cfrac{dx}{(x^2 + a^2)(x^2 + b^2)},</script><p>其中 $a &gt; 0$, $b &gt; 0$ 为常数. ◻</p><p>$\textbf{Solution:}$<br>注意到</p><script type="math/tex; mode=display">I_{a, b} = \frac{1}{2}\lim_{R\rightarrow +\infty}\int_{-R}^{R}\cfrac{dx}{(x^2 + a^2)(x^2 + b^2)}.</script><p>作 $\Gamma_R: \left[-R, R\right]\cup C_R$,</p><p>那么根据复合闭路定理, 得</p><script type="math/tex; mode=display">\oint_{\Gamma_R}f(z)dz = \int_{-R}^{R}f(x)dx + \int_{C_R}f(z)dz.</script><p>令 $R\rightarrow +\infty$, 由于</p><script type="math/tex; mode=display">\lim_{R\rightarrow +\infty}\int_{C_R}f(z)dz = 0,</script><p>那么 <script type="math/tex">\begin{aligned}            I_{a, b} &= \frac{1}{2}\lim_{R\rightarrow +\infty}\oint_{\Gamma_R}f(z)dz \\            &= \pi i\left(Res\left[f(z), ai\right], Res\left[f(z), bi\right]\right) \\            &= \pi i\left(\frac{1}{2ai(a^2 + b^2 +2(ai)^2)} + \frac{1}{2bi(a^2 + b^2 +2(bi)^2)}\right) \\            &= \frac{\pi}{2ab(a + b)}.        \end{aligned}</script> ◻</p><p>$\textbf{Example:}$<br>求复积分 <script type="math/tex">I_n = \int_{0}^{+\infty}\cfrac{dx}{1 + x^{2n}}.</script> ◻</p><p>$\textbf{Solution:}$<br>注意到</p><script type="math/tex; mode=display">I_n = \frac{1}{2}\lim_{R\rightarrow +\infty}\int_{-R}^{R}\cfrac{dx}{1 + x^{2n}}.</script><p>作 $\Gamma_R: \left[-R, R\right]\cup C_R$,</p><p>那么根据复合闭路定理, 得</p><script type="math/tex; mode=display">\oint_{\Gamma_R}f(z)dz = \int_{-R}^{R}f(x)dx + \int_{C_R}f(z)dz.</script><p>令 $R\rightarrow +\infty$, 由于</p><script type="math/tex; mode=display">\lim_{R\rightarrow +\infty}\int_{C_R}f(z)dz = 0,</script><p>那么 <script type="math/tex">\begin{aligned}            I_n &= \frac{1}{2}\lim_{R\rightarrow +\infty}\oint_{\Gamma_R}f(z)dz \\            &= \pi i\sum_{k = 1}^{n}Res\left[\frac{1}{1 + z^{2n}}, z_k\right] = \pi i\sum_{k = 1}^{n}\frac{1}{2nz_k^{2n - 1}} \\            &= \frac{\pi i}{2n}\sum_{k = 1}^{n}z_k^{2n - 1} = -\frac{\pi i}{2n}\sum_{k = 1}^{n}z_k \\            &= -\frac{\pi i}{2n}\sum_{k = 1}^{n}e^{\frac{(2k - 1)\pi i}{2n}} = -\frac{\pi i}{2n}e^{-\frac{\pi i}{2n}}\sum_{k = 1}^{n}e^{\frac{k\pi i}{n}} \\            &= -\frac{\pi i}{2n}e^{-\frac{\pi i}{2n}}\frac{2}{1 - e^{\frac{\pi i}{n}}} = \frac{\pi i}{n}\frac{1}{e^{\frac{\pi i}{2n}} - e^{-\frac{\pi i}{2n}}} \\            &= \frac{\pi i}{n}\frac{1}{2i\sin\frac{\pi}{2n}} = \frac{\frac{\pi}{2n}}{\sin\frac{\pi}{2n}}.        \end{aligned}</script> ◻</p><p>$\textbf{Example:}$<br>求复积分</p><script type="math/tex; mode=display">I_{r, n} = \int_{0}^{+\infty}\cfrac{dx}{r^{2n} + x^{2n}}.</script><p>其中 $r &gt; 0$. ◻</p><p>$\textbf{Solution:}$</p><script type="math/tex; mode=display">\begin{aligned}            I_{r, n} &= \cfrac{1}{r^{2n - 1}}\int_{0}^{+\infty}\cfrac{d\left(\frac{x}{r}\right)}{1 + \left(\frac{x}{r}\right)^{2n}} \\            &= \cfrac{1}{r^{2n - 1}}I_n \\            &= \frac{\frac{\pi}{2n}}{r^{2n - 1}\sin\frac{\pi}{2n}}.        \end{aligned}$$ ◻$\textbf{Example:}$求积分 $$J_n = \int_{0}^{+\infty}\cfrac{dx}{1 + x^n},</script><p>其中 $n \ge 2$. ◻</p><p>$\textbf{Solution:}$<br>注意到</p><script type="math/tex; mode=display">J_n = \lim_{R\rightarrow +\infty}\int_{0}^{R}\cfrac{dx}{1 + x^n}.</script><p>作<br>$\Gamma_R: \left[0, R\right]\cup C_R\cup \left[Re^{i\theta}, 0\right]$,</p><p>那么根据复合闭路定理, 得</p><script type="math/tex; mode=display">\oint_{\Gamma_R}f(z)dz = \int_{0}^{R}f(x)dx + \int_{C_R}f(z)dz + \int_{R}^{0}f(xe^{i\theta})d(xe^{i\theta}).</script><p>令 $R\rightarrow +\infty$, 由于</p><script type="math/tex; mode=display">\lim_{R\rightarrow +\infty}\int_{C_R}f(z)dz = 0,</script><p>取 $\theta = \cfrac{2\pi}{n}, \varphi = \cfrac{\pi}{n}$, 那么</p><script type="math/tex; mode=display">\begin{aligned}            \lim_{R\rightarrow +\infty}\oint_{\Gamma_R}f(z)dz &= \lim_{R\rightarrow +\infty}\int_{0}^{R}f(x)dx + \lim_{R\rightarrow +\infty}\int_{R}^{0}f(xe^{i\theta})d(xe^{i\theta}) \\            &= \lim_{R\rightarrow +\infty}\left(\int_{0}^{R}\cfrac{dx}{1 + x^n}dx - \int_{0}^{R}\cfrac{e^{i\theta}dx}{1 + e^{ni\theta}x^n}\right) \\            &= \lim_{R\rightarrow +\infty}\left(\int_{0}^{R}\cfrac{dx}{1 + x^n}dx - e^{\frac{2\pi i}{n}}\int_{0}^{R}\cfrac{dx}{1 + x^n}\right) \\            &= \left(1 - e^{\frac{2\pi i}{n}}\right)\lim_{R\rightarrow +\infty}\int_{0}^{R}\cfrac{dx}{1 + x^n}dx \\            &= \left(1 - e^{\frac{2\pi i}{n}}\right)J_n.        \end{aligned}</script><p>又注意到 <script type="math/tex">\begin{aligned}            \lim_{R\rightarrow +\infty}\oint_{\Gamma_R}f(z)dz = 2\pi i\frac{1}{ne^{(n - 1)\frac{\pi i}{n}}},        \end{aligned}</script></p><p>故 <script type="math/tex">\begin{aligned}            J_n &= \frac{2\pi i}{ne^{(n - 1)\frac{\pi i}{n}}\left(1 - e^{\frac{2\pi i}{n}}\right)} \\            &= \frac{2\pi i}{ne^{(\pi - \varphi)i}\left(1 - e^{2\varphi i}\right)} \\            &= \frac{\pi i}{n(-\cos\varphi + i\sin\varphi)\sin\varphi(\sin\varphi - i\cos\varphi)} \\            &= \frac{\pi}{n\sin\varphi} = \frac{\frac{\pi}{n}}{\sin\frac{\pi}{n}}.        \end{aligned}</script> ◻</p><p>$\textbf{Example:}$</p><script type="math/tex; mode=display">\frac{1}{(1 + z)^n} = \sum_{k = 0}^{+\infty}(-1)^k C_{n + k - 1}^{n - 1}z^k,</script><p>其中 $\left|{z}\right| &lt; 1$. 特别地, 其中 $z^{n - 1}$ 项的系数为</p><script type="math/tex; mode=display">(-1)^{n - 1}C_{2n - 2}^{n - 1} = (-1)^{n - 1}\cfrac{(2n - 2)!}{(n - 1)!(n - 1)!}.$$ ◻$\textbf{Example:}$求积分 $$J_n = \int_{0}^{+\infty}\cfrac{dx}{(1 + x^2)^n}.$$ ◻$\textbf{Solution:}$注意到$$J_n = \frac{1}{2}\lim_{R\rightarrow +\infty}\int_{-R}^{R}\cfrac{dx}{(1 + x^2)^n}.</script><p>作 $\Gamma_R: \left[-R, R\right]\cup C_R$,</p><p>那么根据复合闭路定理, 得</p><script type="math/tex; mode=display">\oint_{\Gamma_R}f(z)dz = \int_{-R}^{R}f(x)dx + \int_{C_R}f(z)dz.</script><p>令 $R\rightarrow +\infty$, 由于</p><script type="math/tex; mode=display">\lim_{R\rightarrow +\infty}\int_{C_R}f(z)dz = 0,</script><p>因为 <script type="math/tex">\begin{aligned}            \cfrac{1}{(1 + z^2)^n} &= \cfrac{1}{(z + i)^n(z - i)^n} \\            &= \cfrac{1}{(2i)^n(1 + \frac{z - i}{2i})^n(z - i)^n} \\            &= \cfrac{1}{(2i)^n(z - i)^n}\sum_{k = 0}^{+\infty}(-1)^k C_{n + k - 1}^{n - 1}(\frac{z - i}{2i})^k.        \end{aligned}</script></p><p>其中 $\cfrac{1}{z - i}$ 的系数<br>$c_{-1} = \cfrac{(-1)^{n - 1}C_{2n - 2}^{n - 1}}{(2i)^{2n - 1}} = \cfrac{-iC_{2n - 2}^{n - 1}}{2^{2n - 1}}$.</p><p>那么 <script type="math/tex">\begin{aligned}            J_n &= \pi i Res[f, i] \\            &= \pi ic_{-1} \\            &= \cfrac{\pi C_{2n - 2}^{n - 1}}{2^{2n - 1}}.        \end{aligned}</script> ◻</p><p>$\textbf{Example:}$<br>求复积分 <script type="math/tex">J_{r, n} = \int_{0}^{+\infty}\cfrac{dx}{(r^2 + x^2)^n}.</script></p><p>其中 $r &gt; 0$. ◻</p><p>$\textbf{Solution:}$</p><script type="math/tex; mode=display">\begin{aligned}            J_{r, n} &= \cfrac{1}{r^{2n - 1}}\int_{0}^{+\infty}\cfrac{d\left(\frac{x}{r}\right)}{\left(1 + \left(\frac{x}{r}\right)^{2}\right)^n} \\            &= \cfrac{1}{r^{2n - 1}}J_n \\            &= \cfrac{\pi C_{2n - 2}^{n - 1}}{(2r)^{2n - 1}}.        \end{aligned}$$ ◻### 14. 留数 C$\textbf{Example:}$$C_R: Re^{i\theta}$, $0\le\theta\le\pi$, 多项式 $P$, $Q$ 满足$\deg Q\ge\deg P + 1$, 则$$\lim_{R\rightarrow +\infty}\limits\int_{C_R}\frac{P(z)e^{ikz}}{Q(z)}dz = 0.$$ ◻$\textbf{Example:}$求积分 $$I = \int_{0}^{+\infty}\cfrac{x\sin kx}{x^2 + a^2}dx,</script><p>其中 $a &gt; 0$, $k &gt; 0$ 为常数. ◻</p><p>$\textbf{Solution:}$<br>记 $f(z) = \cfrac{z\sin kz}{z^2 + a^2}$,<br>$h(z) = \cfrac{ze^{ikx}}{z^2 + a^2}$.</p><p>那么</p><script type="math/tex; mode=display">\int_{-\infty}^{+\infty}\limits h(z)dz = \int_{-\infty}^{+\infty}\limits\cfrac{z\cos kz}{z^2 + a^2}dz + i\int_{-\infty}^{+\infty}\limits f(z)dz = 2iI.</script><p>作 $\Gamma_R: \left[-R, R\right]\cup C_R$, 那么根据复合闭路定理, 得</p><script type="math/tex; mode=display">\oint_{\Gamma_R}h(z)dz = \int_{-R}^{R}h(x)dx + \int_{C_R}h(z)dz.</script><p>令 $R\rightarrow +\infty$, 由于</p><script type="math/tex; mode=display">\lim_{R\rightarrow +\infty}\int_{C_R}h(z)dz = 0,</script><p>那么 <script type="math/tex">\begin{aligned}            \int_{-\infty}^{+\infty}\cfrac{ze^{ikz}}{z^2 + a^2}dz &= \lim_{R\rightarrow +\infty}\oint_{\Gamma_R}h(z)dz \\            &= 2\pi i Res\left[f(z), ai\right] \\            &= 2\pi i\cdot\cfrac{e^{-ka}}{2} \\            &= \cfrac{\pi i}{e^{ka}}.        \end{aligned}</script></p><p>两边取虚部, 得 <script type="math/tex">\begin{aligned}            I = \cfrac{\pi}{2e^{ka}}.        \end{aligned}</script> ◻</p><p>$\textbf{Example:}$<br>求积分</p><script type="math/tex; mode=display">I_n = \int_{0}^{+\infty}\cfrac{x\sin kx}{(x^2 + a^2)^n}dx,</script><p>其中 $a &gt; 0$, $k &gt; 0$ 为常数. ◻</p><p>$\textbf{Solution:}$<br>注意到</p><script type="math/tex; mode=display">\frac{\partial I_n}{\partial a} = -2na\int_{0}^{+\infty}\cfrac{x\sin kx}{(x^2 + a^2)^{n + 1}}dx = -2naI_{n + 1}.</script><p>即 <script type="math/tex">I_{n + 1} = -\cfrac{1}{2na}\frac{\partial I_n}{\partial a}.</script></p><p>依次递归求解即可. ◻</p><p>$\textbf{Example:}$<br>求积分</p><script type="math/tex; mode=display">I_{a, b, k} = \int_{0}^{+\infty}\cfrac{x^3\sin kx}{(x^2 + a^2)(x^2 + b^2)}dx,</script><p>其中 $a&gt;0$, $b &gt; 0$, $k &gt; 0$ 为常数. ◻</p><p>$\textbf{Solution:}$<br>记 $f(z) = \cfrac{z^3\sin kz}{(z^2 + a^2)(z^2 + b^2)}$,<br>$h(z) = \cfrac{z^3e^{ikx}}{(z^2 + a^2)(z^2 + b^2)}$.</p><p>那么</p><script type="math/tex; mode=display">\int_{-\infty}^{+\infty}\limits h(z)dz = \int_{-\infty}^{+\infty}\limits\cfrac{z^3\cos kz}{(z^2 + a^2)(z^2 + b^2)}dz + i\int_{-\infty}^{+\infty}\limits f(z)dz = 2iI_{a, b, k}.</script><p>作 $\Gamma_R: \left[-R, R\right]\cup C_R$, 那么根据复合闭路定理, 得</p><script type="math/tex; mode=display">\oint_{\Gamma_R}h(z)dz = \int_{-R}^{R}h(x)dx + \int_{C_R}h(z)dz.</script><p>令 $R\rightarrow +\infty$, 由于</p><script type="math/tex; mode=display">\lim_{R\rightarrow +\infty}\int_{C_R}h(z)dz = 0,</script><p>那么 <script type="math/tex">\begin{aligned}            \int_{-\infty}^{+\infty}\cfrac{z^3e^{ikz}}{(z^2 + a^2)(z^2 + b^2)}dz &= \lim_{R\rightarrow +\infty}\oint_{\Gamma_R}h(z)dz \\            &= 2\pi i\left(Res\left[f(z), ai\right] + Res\left[f(z), bi\right]\right) \\            &= \pi i\cdot\cfrac{b^2e^{-kb} - a^2e^{-ka}}{b^2 - a^2}.        \end{aligned}</script></p><p>两边取虚部, 得 <script type="math/tex">\begin{aligned}            \int_{0}^{+\infty}\cfrac{x^3\sin kx}{(x^2 + a^2)(x^2 + b^2)}dx = \cfrac{\pi}{2}\cdot\cfrac{b^2e^{-kb} - a^2e^{-ka}}{b^2 - a^2}.        \end{aligned}</script> ◻</p><p>$\textbf{Example:}$<br>求积分</p><script type="math/tex; mode=display">I_{a, k} = \int_{0}^{+\infty}\cfrac{x^3\sin kx}{(x^2 + a^2)^2}dx,</script><p>其中 $a &gt; 0$, $k &gt; 0$ 为常数. ◻</p><p>$\textbf{Solution:}$<br>在 <script type="math/tex">\begin{aligned}            \int_{0}^{+\infty}\cfrac{x^3\sin kx}{(x^2 + a^2)(x^2 + b^2)}dx = \cfrac{\pi}{2}\cdot\cfrac{b^2e^{-kb} - a^2e^{-ka}}{b^2 - a^2}.        \end{aligned}</script></p><p>中, 令 $b\rightarrow a$, 得 <script type="math/tex">\begin{aligned}            \int_{0}^{+\infty}\cfrac{x^3\sin kx}{(x^2 + a^2)^2}dx = \cfrac{\pi}{2}\cdot\cfrac{(2 - ka)e^{-ka}}{2}.        \end{aligned}</script> ◻</p><p>$\textbf{Example:}$<br>求复积分 <script type="math/tex">I_k = \int_{0}^{+\infty}\cfrac{\sin kx}{x}dx.</script></p><p>其中 $k &gt; 0$. ◻</p><p>$\textbf{Solution:}$<br>在 <script type="math/tex">\begin{aligned}            \int_{0}^{+\infty}\cfrac{x^3\sin kx}{(x^2 + a^2)^2}dx = \cfrac{\pi}{2}\cdot\cfrac{(2 - ka)e^{-ka}}{2}.        \end{aligned}</script></p><p>中, 令 $a\rightarrow 0^{+}$, 得 <script type="math/tex">\begin{aligned}            \int_{0}^{+\infty}\cfrac{\sin kx}{x}dx = \cfrac{\pi}{2}.        \end{aligned}</script> ◻</p><h3 id="15-解析映射"><a href="#15-解析映射" class="headerlink" title="15. 解析映射"></a>15. 解析映射</h3><p>$\textbf{Example:}$<br>求分式线性映射 $w(z)$ 将 $z_k = -1, 0, 1$ 映射到 $w_k = -1, 1, i$. ◻</p><p>$\textbf{Solution:}$<br>利用不变式</p><script type="math/tex; mode=display">\cfrac{w - w_1}{w - w_2}\bigg/\cfrac{w_3 - w_1}{w_3 - w_2} = \cfrac{z - z_1}{z - z_2}\bigg/\cfrac{z_3 - z_1}{z_3 - z_2}.</script><p>那么</p><script type="math/tex; mode=display">\cfrac{w + 1}{w - 1}\bigg/\cfrac{i + 1}{i - 1} = \cfrac{z + 1}{z}\bigg/\cfrac{2}{1}.</script><p>从中解得 <script type="math/tex">w = \cfrac{(1 + 2i)z + 1}{(1 - 2i)z + 1}.</script> ◻</p><p>$\textbf{Example:}$<br>求分式线性映射 $w(z)$ 将单位圆周映射到直线. ◻</p><p>$\textbf{Solution:}$<br>一方面, 容易知道存在 $\left|{z_0}\right| = 1$, 使得<br>$cz_0 + d = 0$.</p><p>注意到 <script type="math/tex">\begin{aligned}            &\hspace{1.8em} cz_0 + d = 0 \\            &\Rightarrow \left|{cz_0}\right| = \left|{d}\right| \\            &\Leftrightarrow \left|{c}\right| = \left|{d}\right| \\            &\Leftrightarrow c = de^{i\theta}.        \end{aligned}</script></p><p>另一方面, 当 $c = de^{i\theta}$ 时, 该分式线性映射满足条件. ◻</p><p>$\textbf{Example:}$<br>求分式线性映射 $w(z)$ 满足:</p><ul><li>将单位圆盘 $\left|{z}\right| &lt; 1$ 映射到单位圆盘<br>$\left|{w}\right| &lt; 1$;</li><li>将点 $z = z_1\thinspace(\left|{z_1}\right| &lt; 1)$ 映射到点 $w = 0$. ◻</li></ul><p>$\textbf{Solution:}$<br>由于分式线性映射保对称点的性质,</p><p>映射前 $z_1$ 的对称点为 $\cfrac{1}{\overline{z_1}}$, 映射后为 $0$<br>的对称点 $+\infty$. 故</p><script type="math/tex; mode=display">w = \alpha\cfrac{z - z_1}{z - \frac{1}{\overline{z_1}}} = (-\alpha z_1)\cfrac{z - z_1}{1 - z\overline{z_1}} = \beta\cfrac{z - z_1}{1 - z\overline{z_1}}.</script><p>由最大模原理:</p><script type="math/tex; mode=display">\left|{z}\right| = 1\Leftrightarrow\left|{w}\right| = 1.</script><p>注意到 $\left|{z_1}\right| &lt; 1$, 从而有 <script type="math/tex">\begin{aligned}            1 &= \left|{\beta}\right|\left|{\cfrac{z - z_1}{1 - z\overline{z_1}}}\right|_{\left|{z}\right| = 1} \\            &= \left|{\beta}\right|\left|{\cfrac{z - z_1}{z\overline{z} - z\overline{z_1}}}\right|_{\left|{z}\right| = 1} \\            &= \cfrac{\left|{\beta}\right|}{\left|{z}\right|}\left|{\cfrac{z - z_1}{\overline{z  - z_1}}}\right|_{\left|{z}\right| = 1} \\            &= \left|{\beta}\right|.        \end{aligned}</script></p><p>即 <script type="math/tex">\beta = e^{i\theta}, \theta\in[0, 2\pi).</script></p><p>那么有</p><script type="math/tex; mode=display">w = e^{i\theta}\cfrac{z - z_1}{1 - z\overline{z_1}}, \thinspace\left|{z_1}\right| < 1, \thinspace\theta\in[0, 2\pi).$$ ◻$\textbf{Example:}$求分式线性映射 $w(z)$ 满足:- 将单位圆盘 $\left|{z - z_0}\right| < r$ 映射到单位圆盘  $\left|{w - w_0}\right| < R$;- 将点 $z = z_1\thinspace(\left|{z_1 - z_0}\right| < r)$ 映射到点  $w = w_0$. ◻$\textbf{Solution:}$考虑 $$z' = \cfrac{z - z_0}{r}, w' = \cfrac{w - w_0}{R}.</script><p>则 $z’(z)$, $w’(w)$ 均将原区域映射为单位圆盘. 那么有</p><script type="math/tex; mode=display">w' = e^{i\theta}\cfrac{z' - z_1'}{1 - z'\overline{z_1'}}, \thinspace\left|{z_1'}\right| < 1, \thinspace\theta\in[0, 2\pi).</script><p>代入 $w’$, $z’$ 可得</p><script type="math/tex; mode=display">w = w_0 + rRe^{i\theta}\cfrac{z - z_1}{r^2 - (z - z_0)(\overline{z_1} - \overline{z_0})}, \thinspace\left|{z_1 - z_0}\right| < r, \thinspace\theta\in[0, 2\pi).$$ ◻$\textbf{Example:}$对于 中的映射, 证明不变式:$$\cfrac{\left|{dw}\right|}{1 - \left|{w}\right|^2} = \cfrac{\left|{dz}\right|}{1 - \left|{z}\right|^2}.$$ ◻$\textbf{Solution:}$即证:$$\left|{\cfrac{dw}{dz}}\right| = \cfrac{1 - \left|{w}\right|^2}{1 - \left|{z}\right|^2}.</script><p>注意到 <script type="math/tex">w = e^{i\theta}\cfrac{z - z_1}{1 - z\overline{z_1}},</script></p><p>其中 <script type="math/tex">\left|{z_1}\right| < 1, \thinspace\theta\in[0, 2\pi)</script></p><p>那么 <script type="math/tex">\begin{aligned}            LHS = \left|{e^{i\theta}\cfrac{1 - z_1\overline{z_1}}{(1 - z\overline{z_1})^2}}\right| = \cfrac{1 - z_1\overline{z_1}}{\left|{1 - z\overline{z_1}}\right|^2}.        \end{aligned}</script></p><script type="math/tex; mode=display">\begin{aligned}            RHS &= \cfrac{1 - w\overline{w}}{1 - z\overline{z}} \\            &= \cfrac{\left|{1 - z\overline{z_1}}\right|^2 - \left|{z - z_1}\right|^2}{(1 - z\overline{z})\left|{1 - z\overline{z_1}}\right|^2} \\            &= \cfrac{(1 - z\overline{z_1})(1 - z_1\overline{z}) - (z - z_1)(\overline{z} - \overline{z_1})}{(1 - z\overline{z})\left|{1 - z\overline{z_1}}\right|^2} \\            &= \cfrac{1 - z\overline{z} - z_1\overline{z_1} + z\overline{z}z_1\overline{z_1}}{(1 - z\overline{z})\left|{1 - z\overline{z_1}}\right|^2} \\            &= \cfrac{(1 - z\overline{z})(1 - z_1\overline{z_1})}{(1 - z\overline{z})\left|{1 - z\overline{z_1}}\right|^2} \\            &= \cfrac{1 - z_1\overline{z_1}}{\left|{1 - z\overline{z_1}}\right|^2} = LHS.        \end{aligned}</script><p>至此证毕.  ◻</p><p>$\textbf{Example:}$<br>对于 中的映射, 证明不变式:</p><script type="math/tex; mode=display">\cfrac{R\left|{dw}\right|}{R^2 - \left|{w - w_0}\right|^2} = \cfrac{r\left|{dz}\right|}{r^2 - \left|{z - z^0}\right|^2}.$$ ◻$\textbf{Solution:}$考虑 $$z' = \cfrac{z - z_0}{r}, w' = \cfrac{w - w_0}{R}.</script><p>则 $z’(z)$, $w’(w)$ 均将原区域映射为单位圆盘. 那么有</p><script type="math/tex; mode=display">\cfrac{\left|{dw’}\right|}{1 - \left|{w'}\right|^2} = \cfrac{\left|{dz'}\right|}{1 - \left|{z'}\right|^2}.</script><p>代入 $w’$, $z’$ 可得</p><script type="math/tex; mode=display">\cfrac{R\left|{dw}\right|}{R^2 - \left|{w - w_0}\right|^2} = \cfrac{r\left|{dz}\right|}{r^2 - \left|{z - z^0}\right|^2}.$$ ◻$\textbf{Example:}$求分式线性映射 $w(z)$ 满足:- 将上半复平面 $Im{z} > 0$ 映射到单位圆盘 $\left|{w}\right| < 1$;- 将点 $z = z_1\thinspace(Im{z_1} > 0)$ 映射到点 $w = 0$. ◻ $\textbf{Solution:}$将上半平面看作半径无穷的圆, $z_1$ 关于圆周的对称点为$\overline{z_1}$.由于分式线性映射保对称点的性质,映射前 $z_1$ 的对称点为 $\overline{z_1}$, 映射后为 $0$ 的对称点$+\infty$. 故 $$w = \alpha\cfrac{z - z_1}{z - \overline{z_1}}.</script><p>由最大模原理: <script type="math/tex">z = x\in\mathbb{R}\Leftrightarrow\left|{w}\right| = 1.</script></p><p>注意到 $Im{z_1} &gt; 0$, 从而有 <script type="math/tex">\begin{aligned}            1 &= \left|{\alpha}\right|\left|{\cfrac{x - z_1}{x - \overline{z_1}}}\right| \\            &= \left|{\alpha}\right|\left|{\cfrac{x - z_1}{\overline{x} - \overline{z_1}}}\right| \\            &= \left|{\alpha}\right|.        \end{aligned}</script></p><p>即 <script type="math/tex">\alpha = e^{i\theta}, \theta\in[0, 2\pi).</script></p><p>那么有</p><script type="math/tex; mode=display">w = e^{i\theta}\cfrac{z - z_1}{z - \overline{z_1}}, \thinspace Im{z_1} > 0, \thinspace\theta\in[0, 2\pi).</script><p>特别地, 取 $\theta = 0, z_1 = i$, 可得 <script type="math/tex">w = \cfrac{z - i}{z + i}.</script> ◻</p><p>$\textbf{Example:}$<br>求分式线性映射 $w(z)$ 满足:</p><ul><li>将过点 $x_0\in\mathbb{R}$, 旋转角为 $\theta_0$<br>的半平面映射到单位圆盘 $\left|{w - w_0}\right| &lt; R$;</li><li>将点 $z = z_1\thinspace(Im{[(z_1 - x_0)e^{-i\theta_0}]} &gt; 0)$<br>映射到点 $w = w_0$. ◻</li></ul><p>$\textbf{Solution:}$<br>考虑</p><script type="math/tex; mode=display">z' = (z - x_0)e^{-i\theta_0}, w' = \cfrac{w - w_0}{R}.</script><p>则 $z’(z)$, $w’(w)$ 均将原区域映射为上半复平面与单位圆盘. 那么有</p><script type="math/tex; mode=display">w' = e^{i\theta}\cfrac{z' - z_1'}{z' - \overline{z_1'}}, \thinspace Im{z_1'} > 0, \thinspace\theta\in[0, 2\pi).</script><p>代入 $w’$, $z’$ 可得</p><script type="math/tex; mode=display">w = w_0 + Re^{i\theta}\cfrac{z - z_1}{z - x_0 - (\overline{z_1} - x_0)e^{2i\theta_0}},</script><p>其中</p><script type="math/tex; mode=display">Im{[(z_1 - x_0)e^{-i\theta_0}]} > 0, \thinspace\theta\in[0, 2\pi).$$ ◻$\textbf{Example:}$映射 $w = \cfrac{az + b}{cz + d}$, 若 $a, b, c, d\in\mathbb{R}$, 则$$Im{z} > 0\leftrightarrow Im{w} > 0 \Longleftrightarrow ad - bc > 0.$$ ◻$\textbf{Solution:}$将 $z = x + iy$ 待入 $$w = \cfrac{az + b}{cz + d},</script><p>得 <script type="math/tex">w = u + iv = \cfrac{(ax + b) + iay}{(cx + d) + icy},</script></p><p>那么 <script type="math/tex">v = \cfrac{(ad - bc)y}{(cx + d)^2 + (cy)^2}.</script></p><p>从而 <script type="math/tex">\begin{aligned}            &\hspace{2em} Im{z} > 0\leftrightarrow Im{w} > 0 \\            &\Longleftrightarrow y > 0\leftrightarrow v > 0 \\            &\Longleftrightarrow yv > 0 \\            &\Longleftrightarrow \cfrac{(ad - bc)y^2}{(cx + d)^2 + (cy)^2} > 0 \\            &\Longleftrightarrow ad - bc > 0.        \end{aligned}</script></p><p>根据最大模原理可知,</p><p>该映射将上半复平面映到上半复平面, 实轴映到实轴.</p><p>又当 $z\in\mathbb{R}$ 时,</p><script type="math/tex; mode=display">\cfrac{dw}{dz} = \cfrac{ad - bc}{(cz + d)^2} > 0.</script><p>即 <script type="math/tex">\arg\left(\frac{dw}{dz}\right) = 0.</script></p><p>故该映射将上半复平面映到上半复平面, 实轴正向映到实轴正向. ◻</p><p>$\textbf{Example:}$<br>求分式线性映射 $w(z)$ 满足:</p><ul><li>将过点 $a, b\in\mathbb{R}$, 旋转角为 $\alpha\in(0, \pi)$<br>的长条映射到单位圆盘 $\left|{w}\right| &lt; 1$. ◻</li></ul><p>$\textbf{Solution:}$<br>分为四步</p><ol><li>$z_1 = e^{-i\alpha}(z - b)$</li><li>$z_2 = \cfrac{\pi}{h}z_1$</li><li>$z_3 = e^{z_2}$</li><li>$w = \cfrac{z_3 - i}{z_3 + i}$</li></ol><p>整理得</p><script type="math/tex; mode=display">w = \cfrac{e^{\frac{e^{-i\alpha}(z - b)\pi}{(b - a)\sin\alpha}} - i}{e^{\frac{e^{-i\alpha}(z - b)\pi}{(b - a)\sin\alpha}} + i}.</script><p>特别地, 当 $\alpha = \cfrac{\pi}{2}$ 时,</p><script type="math/tex; mode=display">w = \cfrac{e^{\frac{b - z}{b - a}\pi i} - i}{e^{\frac{b - z}{b - a}\pi i} + i}.$$ ◻$\textbf{Example:}$求分式线性映射 $w(z)$ 满足:/- 将区域  $0 < r < R, \thinspace 0 < \theta < \alpha \thinspace(\alpha\in[0, 2\pi))$  映射到单位圆盘 $\left|{w}\right| < 1$. ◻ $\textbf{Solution:}$分为四步1. $z_1 = z^{\frac{\pi}{\alpha}}$2. $z_2 = \cfrac{R^{\frac{\pi}{\alpha}} + z_1}{R^{\frac{\pi}{\alpha}} - z_1}$   (上半圆 $\longrightarrow$ 第一象限)3. $z_3 = z_2^2$4. $w = \cfrac{z_3 - i}{z_3 + i}$整理得$$w = \cfrac{\left(\frac{R^{\frac{\pi}{\alpha}} + z^{\frac{\pi}{\alpha}}}{R^{\frac{\pi}{\alpha}} - z^{\frac{\pi}{\alpha}}}\right)^2 - i}{\left(\frac{R^{\frac{\pi}{\alpha}} + z^{\frac{\pi}{\alpha}}}{R^{\frac{\pi}{\alpha}} - z^{\frac{\pi}{\alpha}}}\right)^2 + i}.</script><p>特别地, 当 $\alpha = \cfrac{\pi}{8}$ 时,</p><p><script type="math/tex">w = \cfrac{\left(\frac{R^8 + z^8}{R^8 - z^8}\right)^2 - i}{\left(\frac{R^8 + z^8}{R^8 - z^8}\right)^2 + i}.</script> ◻</p><p>$\textbf{Example:}$<br>求分式线性映射 $w(z)$ 满足:</p><ul><li>将<br>$\left|{z - a}\right| &gt; a, \left|{z - b}\right| &lt; b\thinspace(0 &lt; a &lt; b)$<br>所围区域映到单位圆盘 $\left|{w}\right| &lt; 1$. ◻</li></ul><p>$\textbf{Solution:}$<br>分为五步</p><ol><li>$z_1 = \cfrac{z - 2a}{z}$ ($0 &lt; x &lt; \cfrac{b - a}{a}$ 的竖直长条)</li><li>$z_2 = iz_1$</li><li>$z_3 = \cfrac{\pi}{\frac{b - a}{a}}z_2$</li><li>$z_4 = e^{z_3}$</li><li>$w = \cfrac{z_4 - i}{z_4 + i}$</li></ol><p>整理得</p><p><script type="math/tex">w = \cfrac{e^{\frac{ib(z - 2a)\pi}{(b - a)z}} - i}{e^{\frac{ib(z - 2a)\pi}{(b - a)z}} + i}.</script> ◻</p><p>$\textbf{Example:}$<br>求分式线性映射 $w(z)$ 满足:</p><ul><li><p>将以 $A, B$ 为端点, $\theta_0\in(0, 2\pi)$<br>为弦切角的弓形映到单位圆盘 $\left|{w}\right| &lt; 1$. ◻</p><p>$\textbf{Solution:}$<br>分为三步</p></li></ul><ol><li>$z_1 = \cfrac{z - A}{B - z}$ (弓形 $\longrightarrow$ 第一象限角域)</li><li>$z_2 = z_1^{\frac{\pi}{\theta_0}}$</li><li>$w = \cfrac{z_2 - i}{z_2 + i}$</li></ol><p>整理得</p><p><script type="math/tex">w = \cfrac{\left(\frac{z - A}{B - z}\right)^{\frac{\pi}{\theta_0}} - i}{\left(\frac{z - A}{B - z}\right)^{\frac{\pi}{\theta_0}} + i}.</script> ◻</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h3 id=&quot;1-解析函数&quot;&gt;&lt;a href=&quot;#1-解析函数&quot; class=&quot;headerlink&quot; title=&quot;1. 解析函数&quot;&gt;&lt;/a&gt;1. 解析函数&lt;/h3&gt;&lt;p&gt;$&#92;textbf{Example:}$&lt;br&gt;对于 $x, y&#92;in&#92;mathbb{R}$, 求</summary>
        
      
    
    
    
    <category term="Maths" scheme="http://chengsx21.github.io/categories/Maths/"/>
    
    <category term="Algebra" scheme="http://chengsx21.github.io/categories/Maths/Algebra/"/>
    
    
    <category term="Maths" scheme="http://chengsx21.github.io/tags/Maths/"/>
    
  </entry>
  
  <entry>
    <title>Russian End-of-term Revision</title>
    <link href="http://chengsx21.github.io/2022/12/28/russian-end-of-term-revision/"/>
    <id>http://chengsx21.github.io/2022/12/28/russian-end-of-term-revision/</id>
    <published>2022-12-28T07:00:13.000Z</published>
    <updated>2023-09-21T17:13:39.413Z</updated>
    
    <content type="html"><![CDATA[<h4 id="及物动词"><a href="#及物动词" class="headerlink" title="及物动词"></a>及物动词</h4><ul><li>(第四课) есть; </li><li>(第五课) делать, читать, считать, искать, знать, слушать; </li><li>(第六课) смотреть, писать, учить;</li><li>(第七课) любить, изучать;</li><li>(第九课) рассказывать, видеть, ждать, петь, вспоминать;</li><li>(第十课) звать;</li><li>(常用) покупать.</li></ul><ol><li><p>делать (做):</p><p>делать урок; делать упражнения (练习);</p></li><li><p>читать (读):</p><p>читать книгу (书); читать текст; читать диалог; читать стихи (诗歌); </p></li><li><p>считать (数):</p><p>считать бананы; </p></li><li><p>искать (寻找):</p><p>искать часы (时间); искать плащ; искать счастье (幸福); </p></li><li><p>знать (了解, 认识):</p><p>знать это; знать тебя; знать русский язык; </p></li><li><p>слушать (听):</p><p>слушать музыку; слушать текст; слушать диалог; слушать стихи;</p></li><li><p>смотреть (看):</p><p>смотреть телевизор (电视); смотреть фильм; </p></li><li><p>писать (写):</p><p>писать письмо; писать новые слова; писать диалог; писать стихи;</p></li><li><p>любить (热爱):</p><p>любить весну и зиму; любить русский язык; Я тебя люблю (我爱你);</p></li><li><p>изучать (研究): </p><p>изучать русский язык; изучать математику; изучать стихи; изучать Пушкина;</p></li><li><p>видеть (看见):</p><p>Вчера мы видели тебя в библиотеке.</p></li><li><p>ждать (等待):</p><p>Мы тебя ждали вчера в аудитории.</p></li><li><p>петь (唱歌):</p><p>Мы поём русскую песню «Подмосковные вечера».</p></li><li><p>звать (招呼; 叫做)</p><p>Как тебя зовут? </p></li></ol><h4 id="非及物动词"><a href="#非及物动词" class="headerlink" title="非及物动词"></a>非及物动词</h4><ul><li>(第五课) работать, отдыхать, ужинать, играть, жить; </li><li>(第六课) говорить, хотеть, обедать, учиться;</li><li>(第七课) идти, ехать, разговаривать, мечтать, отвечать, заниматься;</li><li>(第八课) вставать, завтракать;</li><li>(第九课) лежать, быть, гулять, фотографироваться, собраться;</li><li>(第十课) сидеть, родиться;</li><li>(常用) стоять, лететь.</li></ul><ol><li><p>работать (工作):</p><p>работать на заводе; работать в Пекине; работать в Москве; работать на юге;</p></li><li><p>отдыхать (休息):</p><p>отдыхать дома; отдыхать на юге;</p></li><li><p>завтракать, обедать, ужинать (吃早 / 午 / 晚饭):</p><p>завтракать дома; обедать в кафе; ужинать  в институте; ужинать  в буфете (小吃部);</p></li><li><p>жить (居住):</p><p>жить дома; жить в институте; жить в Санкт-Петербурге;</p></li><li><p>играть (玩):</p><p>играть в футбол; играть в шахматы;</p></li><li><p>говорить (说):</p><p>говорить по-русски; говорить по-китайски;</p></li><li><p>хотеть (想):</p><p>хотеть читать стихи; хотеть смотреть телевизор; хотеть слушать музыку.</p></li><li><p>идти (步行): </p><p>Я иду на урок.</p></li><li><p>ехать (乘车):</p><p>Я еду на работу.</p></li><li><p>разговаривать (交谈):</p><p>Они разговаривают об учебе и о работе. Вы разговариваете о Москве?</p></li><li><p>мечтать (渴望):</p><p>мечтать учиться в России;  мечтать работать на юге;</p></li><li><p>отвечать (回答):</p><p>отвечать на вопросы;</p></li><li><p>стоять (站立):</p><p>На столе стоит красивая ваза.</p></li><li><p>лежать (放置):</p><p>На столе лежат книги и словари.</p></li><li><p>быть (曾经在):</p><p>Вчера вечером Антон и Нина были в театре.</p></li><li><p>гулять (散步):</p><p>Виктор и Анна гуляют в саду.</p></li><li><p>фотографироваться (摄像):</p><p>Они фотографируются в парке.</p></li><li><p>собраться (聚集):</p><p>Вчера мои товарищи собрались вместе. </p></li><li><p>сидеть (坐着):</p><p>Мы сидим в своей красивой аудитории. </p></li><li><p>родиться (出生):</p><p>Он родился в Пекине.</p></li></ol><h4 id="第一变位法"><a href="#第一变位法" class="headerlink" title="第一变位法"></a>第一变位法</h4><p><strong>正常变位</strong></p><ul><li>разговаривать, мечтать, отвечать, изучать, заниматься, покупать (购买), гулять.</li></ul><p><strong>特殊变位</strong></p><ul><li>писать: я пишу, ты пишешь, они пишут;</li><li>жить: я живу, ты живёшь, они живут;</li><li>звать: я зову, ты зовёшь, они зовут;</li><li>искать: я ищу, ты ищешь, они ищут;</li><li>идти: я иду, ты идёшь, они идут; </li><li>ехать: я еду, ты едешь, они едут;</li><li>вставать: я встаю, ты встаёшь, они встают.</li><li>танцевать: я танцую, ты танцуешь, они танцуют.  </li></ul><h4 id="第二变位法"><a href="#第二变位法" class="headerlink" title="第二变位法"></a>第二变位法</h4><p><strong>正常变位</strong></p><ul><li>говорить: я говорю, ты говоришь, они говорят;</li><li>стоять: я стою, ты стоишь, они стоят; </li><li>учить: я учу, ты учишь, они учат;</li><li>учиться: я учусь, ты учишься, они учатся;</li><li>смотреть: я смотрю, ты смотришь, они смотрят;</li></ul><p><strong>特殊变位</strong></p><ul><li>любить: я люблю, ты любишь, они любят.</li><li>лететь (飞行): я лечу, ты летишь, они летят.</li><li>сидеть: я сижу, ты сидишь, они сидят.</li></ul><h4 id="语言"><a href="#语言" class="headerlink" title="语言"></a>语言</h4><ul><li>говорить по-русски 俄语</li><li>говорить по-китайски 汉语</li><li>говорить по-английски 英语</li></ul><h4 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h4><ul><li>один час;</li><li>два / три / четыре часа;</li><li>пять / шесть / семь / восемь / девять / десять / одиннадцать / двенадцать часов.</li></ul><h4 id="星期"><a href="#星期" class="headerlink" title="星期"></a>星期</h4><ul><li>понедельник, вторник, среда, четверг, пятница, суббота, воскресенье.</li></ul><h4 id="月份"><a href="#月份" class="headerlink" title="月份"></a>月份</h4><ul><li>январь, февраль, март, апрель;</li><li>май, июнь, июль, август;</li><li>сентябрь, октябрь, ноябрь, декабрь.</li></ul><h4 id="第一至六课词组"><a href="#第一至六课词组" class="headerlink" title="第一至六课词组"></a>第一至六课词组</h4><ul><li>我 / 你 / 您 / 他 / 她叫… меня / тебя / вас / его / её зовут…</li><li>在喷泉旁 у фонтана</li><li>您的儿子 ваш сын</li><li>我的朋友 мой друг; моя подруга</li><li>你们的新房子 ваш новый дом</li><li>我的旧作业本 моя старая тетрадь</li><li>他的新车 его новая машина</li><li>我们的旧桌子 наш старый стол</li><li>你们的旧花园 ваш старый сад</li><li>他们的新护照 их новые паспорта</li><li>在工厂工作 работать на заводе</li><li>在学院里工作 работать в институте</li><li>在剧院里工作 работать в театре</li><li>懂俄语 знать русский язык</li><li>了解你 знать тебя</li><li>听音乐 слушать музыку</li><li>在南方休息  отдыхать на юге</li><li>在疗养院休息 отдыхать в санатории</li><li>在家休息 отдыхать дома</li><li>在家吃早餐 завтракать дома</li><li>在咖啡厅吃午餐 обедать в кафе</li><li>在小吃部吃晚餐 ужинать в буфете</li><li>在教室里做功课 делать урок в аудитории</li><li>在宿舍里做练习 делать упражнение в общежитии</li><li>踢足球 играть в футбол</li><li>下象棋 играть в шахматы</li><li>数香蕉 считать бананы</li><li>写生词 писать новые слова</li><li>住在莫斯科 жить в Москве</li><li>住在上海 жить в Шанхае</li><li>背单词 учить новые слова</li><li>渴望上大学 хотеть учиться в университете</li><li>渴望在俄罗斯留学 хотеть учиться в России</li><li>关于我 обо мне</li><li>3点钟 три часа</li><li>5点钟 пять часов</li><li>看电视 смотреть телевизор</li><li>看书 читать книгу</li><li>寻找教科书 искать учебник</li><li>请问 скажите пожалуйста</li><li>几点钟 который час</li><li>很好 очень хорошо</li></ul><h4 id="第七课词组"><a href="#第七课词组" class="headerlink" title="第七课词组"></a>第七课词组</h4><ol><li>俄语学院 Институт русского языка</li><li>学习研究俄语 изучать русский язык</li><li>在课堂上 на уроке </li><li>回答问题 отвечать на вопросы</li><li>做很多练习 делать упражнения</li><li>懂俄语 знать русский язык</li><li>谈论有关学习和生活的事情 разговаривать об учёбе и о жизни</li><li>学院里的生活 жизнь в институте</li><li>向往着留学俄罗斯 мечтать учиться в России</li><li>去上班 идти на работу </li><li>乘车去莫斯科 ехать в Москву</li><li>喜欢春天 любить весну</li><li>报刊和杂志 газета и журнал</li></ol><h4 id="第九课词组"><a href="#第九课词组" class="headerlink" title="第九课词组"></a>第九课词组</h4><ol><li>写生词 писать новые слова</li><li>看电视 смотреть телевизор</li><li>在教室里上自习 заниматься в аудитории</li><li>在宿舍休息 отдыхать в общежитии</li><li>好朋友  большие друзья (хорошие друзья)</li><li>喜欢数学 любить математику</li><li>做家庭作业 делать домашние задания</li><li>出行日 выходной день</li><li>弹吉他  играть на гитаре</li><li>乘车去听音乐会  ехать на концерт</li><li>看电影  смотреть фильм</li><li>好久没见到你 давно тебя не видеть</li><li>在学院里等你 ждать тебя в институте</li><li>上大学 учиться в университете</li><li>唱俄语歌 петь русские песни</li><li>在莫大学习 учиться в МГУ</li><li>中小学同学 школьные товарищи</li></ol><h4 id="第十课词组"><a href="#第十课词组" class="headerlink" title="第十课词组"></a>第十课词组</h4><ol><li>出生在莫斯科 родиться в Москве</li><li>在中学工作 работать в средней школе</li><li>大而美丽的城市 большой и красивый город</li><li>长江 река Янцзы</li><li>在童年 в детстве</li><li>在北大上学 учиться в Пекинском университете</li><li>俄罗斯语言与文学 русский язык и литература</li><li>每天 каждый день</li><li>除此以外 кроме того</li><li>听俄语诗歌 слушать русские стихи</li><li>好教师 хороший преподаватель</li><li>令人愉悦的和善良的人 весёлый и добрый человек</li><li>熟知故乡的城市 хорошо знать свой родной город</li><li>喜欢听他的故事 любить слушать его рассказы</li><li>著名的地方 знаменитые места</li><li>红场 Красная площадь</li><li>历史博物馆 Исторический музей</li><li>大剧院 Большой театр</li><li>冬宫 Зимний дворец</li><li>晚报 вечерняя газета</li><li>我的父母双亲 мои родители</li></ol><h4 id="重点词组"><a href="#重点词组" class="headerlink" title="重点词组"></a>重点词组</h4><ol><li>吃新鲜的菠萝 есть свежие ананасы</li><li>吃热汤 есть горячий суп</li><li>读书和报刊杂志 читать книгу, газету и журнал</li><li>听音乐 слушать музыку</li><li>在美丽的花园里散步 гулять в красивом саду</li><li>在周六  в субботу</li><li>谈论关于我的情况  разговаривать обо мне</li><li>乘公共汽车  ехать на автобусе</li><li>乘坐地铁  ехать на метро</li><li>谈论关于我的生活和工作  разговаривать о моей жизни и работе</li><li>飞往莫斯科 лететь в Москву</li><li>师范学院  педагогический институт</li><li>医学院  медицинский институт</li><li>历史系  исторический факультет</li><li>一年四季  времена года</li><li>站在喷泉旁 стоять у фонтана</li><li>背单词 учить новые слова</li><li>6点钟 шесть часов</li><li>唱歌跳舞 петь и танцевать</li><li>回忆起学校和老师同学 вспоминать о школе, об учителях и товарищах</li><li>高楼  большие дома</li><li>起床很早 вставать рано</li><li>他有课 у него уроки</li><li>购买蔬菜和苹果 покупать овощи и яблоки</li><li>回答问题 отвечать на вопросы</li><li>去上班 идти на работу</li><li>梦想在俄罗斯学习 мечтать учиться в России</li><li>美丽的花朵 красивые цветы</li><li>写信 писать письмо</li><li>在小吃部吃午饭 обедать в буфете</li></ol><h4 id="形容词"><a href="#形容词" class="headerlink" title="形容词"></a>形容词</h4><p><strong>硬变化</strong></p><ul><li>新的 новый, новая, новое, новые;</li><li>旧的 старый, старая, старое, старые;</li><li>美丽的 красивый, красивая, красивое, красивые;</li><li>美味的 вкусный, вкусная, вкусное, вкусные;</li><li>时尚的 модный, модная, модное, модные;</li><li>红色的 красный, красная, красное, красные;</li><li>学校的 школьный, школьная, школьное, школьные;</li><li>年青的 молодой, молодая, молодое, молодые; </li><li>大的 большой, большая, большое, большие; </li><li>不好的 плохой，плохая, плохое, плохие; </li><li>英国的  английский, английская, английское, английские; </li></ul><p><strong>软变化</strong></p><ul><li>家庭的 домашний, домашняя, домашнее, домашние; </li><li>蓝色的 синий, синяя, синее, синие; </li><li>晚上的 вечерний，вечерняя, вечернее, вечерние; </li><li>冬日的 зимний, зимняя, зимнее, зимние; </li><li>好的 хороший，хорошая, хорошее, хорошие; </li><li>新鲜的 свежий，свежая, свежее, свежие; </li><li>滚烫的 горячий, горячая, горячее, горячие. </li></ul><h4 id="на-固定词组-第四格"><a href="#на-固定词组-第四格" class="headerlink" title="на 固定词组 (第四格)"></a>на 固定词组 (第四格)</h4><p>на завод, на рынок, на мост, на работу, на урок, на лекцию, на выставку, на концерт, на почту, на кухню, на фирму, на улицу, на проспект, на стадион, на остановку автобуса, на обед, на ужин, на завтрак, на собрание, на юг, на вокзал, на футбол, на гору, на занятия, на факультет, на реку, на озеро, на поле, на море.</p><h4 id="об-固定词组-第六格"><a href="#об-固定词组-第六格" class="headerlink" title="об 固定词组 (第六格)"></a>об 固定词组 (第六格)</h4><p>обо мне, об учёбе, об аудитории, об общежитии, об уксусе, об автобусе, об остановке, об ухе, об яйце, об языке, об ужине, об Европе, об Азии, об имени, об Интернете, об отце, об юге, об овощах, об обуви, об обеде, об осени, об озере, об июле, об июне, об улице, об учителе, об учительнице, об январе, об апреле, об августе, об октябре.</p><h4 id="问答题"><a href="#问答题" class="headerlink" title="问答题"></a>问答题</h4><ol><li><p>Кто твой отец? </p><p>Мой отец инженер. Он работает на заводе.</p></li><li><p>Что стоит на столе? </p><p>На столе стоят красивые цветы.</p></li><li><p>Что ты читаешь? </p><p>Я читаю книгу и газету.</p></li><li><p>Что делала Инна вчера вечером? </p><p>Вчера вечером она смотрела телевизор.</p></li><li><p>Какой язык ты знаешь? </p><p>Я знаю китайский и русский языки.</p></li><li><p>Который час сейчас?</p><p>Сейчас два часа.</p></li><li><p>Куда они едут?</p><p>Они едут в Москву.</p></li><li><p>Когда ты встаёшь утром каждый день? </p><p>Каждый день утром я встаю в шесть часов.</p></li><li><p>Где Миша учился раньше? </p><p>Раньше он учился в Санкт-Петербурге.</p></li><li><p>Где Виктор был вчера? </p><p>Вчера он был в институте.</p></li><li><p>Чья это машина? </p><p>Это моя машина.</p></li><li><p>Какой сегодня день? </p><p>Сегодня понедельник.</p></li><li><p>Почему Анна много работает? </p><p>Она хочет учиться в России.</p></li><li><p>Какое время года ты любишь? </p><p>Я люблю весну и зиму.</p></li><li><p>Где учится твой брат? </p><p>Мой брат учится в МГУ.</p></li><li><p>Ребята хорошо знают о тебе? </p><p>Да, они хорошо знают обо мне.</p></li><li><p>О чём вы разговариваете? </p><p>Мы разговариваем об учёбе и о жизни в университете.</p></li><li><p>О ком рассказывал ваш преподаватель сегодня на уроке? </p><p>Сегодня на уроке он рассказывал о великом русском поэте Пушкине.</p></li><li><p>В каком городе ты живёшь? </p><p>Я живу в большом и красивом городе Шанхае.</p></li><li><p>Где вы родились?</p><p>Я родился в Москве.</p></li><li><p>Где вы учились раньше? </p><p>Раньше мы учились в школе.</p></li><li><p>Какой язык они учили в школе? </p><p>В школе они учили английский язык.</p></li><li><p>Как вы говорите по-русски? </p><p>Мы говорим по-русски очень хорошо.</p></li><li><p>Где обычно занимаются студенты? </p><p>Они обычно занимаются в аудиториях и библиотеках.</p></li><li><p>Какой язык изучает Виктор? </p><p>Он изучает китайский язык.</p></li><li><p>Что ты делал вчера вечером? </p><p>Вчера вечером я писал новые слова.</p></li><li><p>Кто такой Антон? </p><p>Антон хороший преподаватель, весёлый и добрый человек.</p></li><li><p>Какой ваш родной город?</p><p>Мой родной город — Пекин.</p></li><li><p>Ты любишь изучать русский язык? </p><p>Да, я люблю изучать русский язык.</p></li><li><p>Когда у вас уроки русского языка? </p><p>У нас уроки русского языка во вторник и в пятницу. </p></li></ol>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h4 id=&quot;及物动词&quot;&gt;&lt;a href=&quot;#及物动词&quot; class=&quot;headerlink&quot; title=&quot;及物动词&quot;&gt;&lt;/a&gt;及物动词&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;(第四课) есть; &lt;/li&gt;
&lt;li&gt;(第五课) делать, читать, считать,</summary>
        
      
    
    
    
    <category term="Russian" scheme="http://chengsx21.github.io/categories/Russian/"/>
    
    
    <category term="Russian" scheme="http://chengsx21.github.io/tags/Russian/"/>
    
  </entry>
  
  <entry>
    <title>计算机系统概论 Lab 3</title>
    <link href="http://chengsx21.github.io/2022/12/25/ji-suan-ji-xi-tong-gai-lun-lab-3/"/>
    <id>http://chengsx21.github.io/2022/12/25/ji-suan-ji-xi-tong-gai-lun-lab-3/</id>
    <published>2022-12-25T09:27:55.000Z</published>
    <updated>2023-09-21T17:11:23.432Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Lab-3-Malloc-Lab-实验报告"><a href="#Lab-3-Malloc-Lab-实验报告" class="headerlink" title="Lab 3 Malloc Lab 实验报告"></a>Lab 3 Malloc Lab 实验报告</h1><h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><ul><li>使用 $C$ 语言实现一个 $Dynamic$ $Storage$ $Allocater$.</li><li>实现并优化 $malloc$, $free$, $realloc$ 等功能.</li><li>熟练 $gdb$ 调试技巧.</li></ul><h2 id="最终性能"><a href="#最终性能" class="headerlink" title="最终性能"></a>最终性能</h2><p>在最终提交的版本中, 我对 $mm.c$ 的相关实现策略如下:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Data Structure -------- Explicit Free List <span class="token punctuation">(</span>Double Linked List<span class="token punctuation">)</span>  / Allocated Block --- Header, Payload and Footer  <span class="token punctuation">\</span> Free Block -------- Header, Pred_ptr, Succ_ptr and FooterFit Strategy ---------- First FitCoalesce Strategy ----- Immediate CoalesceRealloc Strategy ------ First Try to Coalesce, Then Try to Malloc and Free<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最终实现的性能如下:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Results <span class="token keyword">for</span> mm malloc:Score <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">46</span> <span class="token punctuation">(</span>util<span class="token punctuation">)</span> + <span class="token number">40</span> <span class="token punctuation">(</span>thru<span class="token punctuation">))</span> * <span class="token number">11</span>/11 <span class="token punctuation">(</span>testcase<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">86</span>/100<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="Version-0"><a href="#Version-0" class="headerlink" title="Version 0"></a>Version 0</h2><p>$Version$ $0$ 为未作任何修改的原始 $mm.c$ 文件, 直接进行测试的结果.</p><h3 id="Block-Structure"><a href="#Block-Structure" class="headerlink" title="Block Structure"></a>Block Structure</h3><p>在原始 $mm.c$ 文件中, 一个 $block$ 没有 $header$ 或 $footer$ 标记, 也不会被 $coalesce$ 或 $reuse$.</p><h3 id="Helper-Functions"><a href="#Helper-Functions" class="headerlink" title="Helper Functions"></a>Helper Functions</h3><ul><li>没有实现任何 $helper$ $function$ 以辅助进行内存块的分配.</li><li>所有内存块不进行 $coalesce$, 经过 $free$ 后不会被 $malloc$ 或 $realloc$ 复用.</li></ul><h3 id="Malloc-Functions"><a href="#Malloc-Functions" class="headerlink" title="Malloc Functions"></a>Malloc Functions</h3><h4 id="mm-init"><a href="#mm-init" class="headerlink" title="mm_init"></a>mm_init</h4><ul><li>不进行 $init$, 直接返回.</li></ul><h4 id="mm-malloc"><a href="#mm-malloc" class="headerlink" title="mm_malloc"></a>mm_malloc</h4><ul><li>将 $size$ 对齐至 $16$ 字节, 直接调用 $mem_sbrk$ 申请新的堆区域, 并返回一个指向连续内存块的指针.</li></ul><h4 id="mm-free"><a href="#mm-free" class="headerlink" title="mm_free"></a>mm_free</h4><ul><li>不进行 $free$, 直接返回.</li></ul><h4 id="mm-realloc"><a href="#mm-realloc" class="headerlink" title="mm_realloc"></a>mm_realloc</h4><ul><li>直接调用 $mm_malloc$ 分配 $newptr$. </li><li>如果 $newptr$ 为 $NULL$, 此时堆可扩展内存不足, 直接返回 $NULL$.</li><li>否则, 依据大小关系将 $ptr$ 指向的旧内存块内容复制到 $newptr$ 指向的新块.</li></ul><h3 id="Performance"><a href="#Performance" class="headerlink" title="Performance"></a>Performance</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Results <span class="token keyword">for</span> mm malloc:trace            name     valid  util     ops      secs   Kops <span class="token number">1</span>     amptjp-bal.rep       <span class="token function">yes</span>   <span class="token number">23</span>%    <span class="token number">5694</span>  <span class="token number">0.000070</span>  <span class="token number">81459</span> <span class="token number">2</span>       cccp-bal.rep       <span class="token function">yes</span>   <span class="token number">19</span>%    <span class="token number">5848</span>  <span class="token number">0.000072</span>  <span class="token number">81110</span> <span class="token number">3</span>    cp-decl-bal.rep       <span class="token function">yes</span>   <span class="token number">30</span>%    <span class="token number">6648</span>  <span class="token number">0.000084</span>  <span class="token number">78768</span> <span class="token number">4</span>       expr-bal.rep       <span class="token function">yes</span>   <span class="token number">40</span>%    <span class="token number">5380</span>  <span class="token number">0.000066</span>  <span class="token number">82137</span> <span class="token number">5</span> coalescing-bal.rep        no     -       -         -      - <span class="token number">6</span>     random-bal.rep        no     -       -         -      - <span class="token number">7</span>    random2-bal.rep        no     -       -         -      - <span class="token number">8</span>     binary-bal.rep       <span class="token function">yes</span>   <span class="token number">54</span>%   <span class="token number">12000</span>  <span class="token number">0.000144</span>  <span class="token number">83624</span> <span class="token number">9</span>    binary2-bal.rep       <span class="token function">yes</span>   <span class="token number">47</span>%   <span class="token number">24000</span>  <span class="token number">0.000186</span> <span class="token number">128755</span><span class="token number">10</span>    realloc-bal.rep        no     -       -         -      -<span class="token number">11</span>   realloc2-bal.rep        no     -       -         -      -Total                               -       -         -      -Score <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">12</span> <span class="token punctuation">(</span>util<span class="token punctuation">)</span> + <span class="token number">40</span> <span class="token punctuation">(</span>thru<span class="token punctuation">))</span> * <span class="token number">6</span>/11 <span class="token punctuation">(</span>testcase<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">28</span>/100<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>此时实现的分配器尚不能正确实现所有任务.</p><p>$Kops$ 满足要求, 但 $Memory$ $Utilization$ 过低.</p></blockquote><h2 id="Version-1"><a href="#Version-1" class="headerlink" title="Version 1"></a>Version 1</h2><p>参考 $CSAPP3e$ : $9.9.12$ 中的实现, 采用 $Implicit$ $Free$ $List$ 组织空闲块.</p><h3 id="Block-Structure-1"><a href="#Block-Structure-1" class="headerlink" title="Block Structure"></a>Block Structure</h3><p>一个 $block$ 的结构被组织为:</p><p><img src="/pic/46.png" alt=""></p><p>考虑 $Boundary$ $Tags$ 与 $Alignment$ 条件, 此时 $minimum$ $block$ $size$ 为 $4 * WSIZE\,(32\,Bytes)$.</p><p>$Implicit$ $Free$ $List$ 被组织为:</p><p><img src="/pic/47.png" alt=""></p><p>其中 $heap_listp$ 初始默认指向 $Prologue$ $Block$, 而 $Epilogue$ $Block$ 在进行 $coalesce$ 时可以用于消除边界条件.</p><h3 id="Macros"><a href="#Macros" class="headerlink" title="Macros"></a>Macros</h3><p>相关 $Macro$ $Definition$ 完全参考了 $CSAPP3e$ : $9.9.12$ 中的实现.</p><h3 id="Helper-Functions-1"><a href="#Helper-Functions-1" class="headerlink" title="Helper Functions"></a>Helper Functions</h3><h4 id="first-fit"><a href="#first-fit" class="headerlink" title="first_fit"></a>first_fit</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">first_fit</span><span class="token punctuation">(</span>size_t asize<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span>bp <span class="token operator">=</span> heap_lo<span class="token punctuation">;</span> <span class="token function">GET_SIZE</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span> bp <span class="token operator">=</span> <span class="token function">NEXT_BLKP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">GET_ALLOC</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token function">GET_SIZE</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&gt;=</span> asize<span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token keyword">return</span> bp<span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>采用 $first$ $fit$ 查询 $free$ $block$, 其中 $heap_lo$ 为定义的 $Implicit$ $Free$ $List$ 的起始地址.</li><li>若 $no$ $fit$, 则返回 $NULL$.</li></ul><h4 id="place"><a href="#place" class="headerlink" title="place"></a>place</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">place</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>bp<span class="token punctuation">,</span> size_t asize<span class="token punctuation">)</span> <span class="token punctuation">{</span>  size_t size <span class="token operator">=</span> <span class="token function">GET_SIZE</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>size <span class="token operator">-</span> asize<span class="token punctuation">)</span> <span class="token operator">&gt;=</span> <span class="token punctuation">(</span><span class="token number">4</span> <span class="token operator">*</span> WSIZE<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>asize<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">FTRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>asize<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span><span class="token function">NEXT_BLKP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>size <span class="token operator">-</span> asize<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">FTRP</span><span class="token punctuation">(</span><span class="token function">NEXT_BLKP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>size <span class="token operator">-</span> asize<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>   <span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">FTRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>将大小为 $asize$ 的块放置在 $bp$ 指向的 $free$ $block$ 处. </li><li>由于 $minimum$ $block$ $size$ 为 $4 * WSIZE$, 若剩余 $payloader$ 的 $size$ 过大, 则进行 $split$ 操作产生一个新的 $free$ $block$.</li></ul><h4 id="coalesce"><a href="#coalesce" class="headerlink" title="coalesce"></a>coalesce</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">coalesce</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>bp<span class="token punctuation">)</span> <span class="token punctuation">{</span>  size_t prev_alloc <span class="token operator">=</span> <span class="token function">GET_ALLOC</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span><span class="token function">PREV_BLKP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  size_t next_alloc <span class="token operator">=</span> <span class="token function">GET_ALLOC</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span><span class="token function">NEXT_BLKP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  size_t size <span class="token operator">=</span> <span class="token function">GET_SIZE</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>prev_alloc <span class="token operator">&amp;&amp;</span> next_alloc<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">/* Case 1 */</span>    <span class="token keyword">return</span> bp<span class="token punctuation">;</span>  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>prev_alloc <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>next_alloc<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment">/* Case 2 */</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>prev_alloc <span class="token operator">&amp;&amp;</span> next_alloc<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment">/* Case 3 */</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>  <span class="token comment">/* Case 4 */</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> bp<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>采用 $immediate$ $coalesce$ 策略.</li><li>使用 $header$, $footer$ 作为 $boundary$ $tag$ 进行标记, 根据前后块的 $alloc$ $bit$ 位进行 $free$ $block$ 的合并.</li></ul><h4 id="extend-heap"><a href="#extend-heap" class="headerlink" title="extend_heap"></a>extend_heap</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">extend_heap</span><span class="token punctuation">(</span>size_t words<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">char</span> <span class="token operator">*</span>bp<span class="token punctuation">;</span>  size_t size<span class="token punctuation">;</span>  size <span class="token operator">=</span> <span class="token punctuation">(</span>words <span class="token operator">%</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">(</span>words <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> WSIZE <span class="token operator">:</span> words <span class="token operator">*</span> WSIZE<span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span><span class="token punctuation">(</span>bp <span class="token operator">=</span> <span class="token function">mem_sbrk</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>  <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* Free block header */</span>  <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">FTRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* Free block footer */</span>  <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span><span class="token function">NEXT_BLKP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* New epilogue header */</span>  <span class="token keyword">return</span> <span class="token function">coalesce</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>用大小为 $size$ 的双字对齐的 $free$ $block$ 扩展堆.</li><li>$epilogue$ $block$ 的 $size$ 为 $0$, $alloc$ $bit$ 位置为 $1$.</li><li>使用 $mem_sbrk$ 分配一个双字对齐块后, $epilogue$ $block$ 变成了 $new$ $free$ $block$ $header$, 下一 $block$ $header$ 特殊化为 $new$ $epilogue$ $block$.</li></ul><h3 id="Malloc-Functions-1"><a href="#Malloc-Functions-1" class="headerlink" title="Malloc Functions"></a>Malloc Functions</h3><h4 id="mm-init-1"><a href="#mm-init-1" class="headerlink" title="mm_init"></a>mm_init</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">mm_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>heap_lo <span class="token operator">=</span> <span class="token function">mem_sbrk</span><span class="token punctuation">(</span><span class="token number">4</span> <span class="token operator">*</span> WSIZE<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token function">PUT</span><span class="token punctuation">(</span>heap_lo<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">PUT</span><span class="token punctuation">(</span>heap_lo <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">*</span> WSIZE<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>DSIZE<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">PUT</span><span class="token punctuation">(</span>heap_lo <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> WSIZE<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>DSIZE<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">PUT</span><span class="token punctuation">(</span>heap_lo <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token number">3</span> <span class="token operator">*</span> WSIZE<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  heap_lo <span class="token operator">+=</span> <span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> WSIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">extend_heap</span><span class="token punctuation">(</span>CHUNKSIZE <span class="token operator">/</span> WSIZE<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>设置  $prologue$ $block$, $epilogue$ $block$.</li><li>用 $CHUNKSIZE$ 大小的 $free$ $block$ 扩展空堆, 若扩展失败则返回 $NULL$.</li></ul><h4 id="mm-malloc-1"><a href="#mm-malloc-1" class="headerlink" title="mm_malloc"></a>mm_malloc</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">mm_malloc</span><span class="token punctuation">(</span>size_t size<span class="token punctuation">)</span> <span class="token punctuation">{</span>  size_t asize<span class="token punctuation">;</span>  <span class="token keyword">char</span> <span class="token operator">*</span>bp<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>  <span class="token comment">/* Adjust block size to include overhead and alignment reqs. */</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">&lt;=</span> DSIZE<span class="token punctuation">)</span> asize <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> DSIZE<span class="token punctuation">;</span>  <span class="token keyword">else</span> asize <span class="token operator">=</span> DSIZE <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>size <span class="token operator">+</span> <span class="token punctuation">(</span>DSIZE<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>DSIZE <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">/</span> DSIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">/* Search the free list for a fit */</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>bp <span class="token operator">=</span> <span class="token function">first_fit</span><span class="token punctuation">(</span>asize<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">place</span><span class="token punctuation">(</span>bp<span class="token punctuation">,</span> asize<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> bp<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment">/* No fit found. Get more memory and place the block */</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>bp <span class="token operator">=</span> <span class="token function">extend_heap</span><span class="token punctuation">(</span><span class="token function">MAX</span><span class="token punctuation">(</span>asize<span class="token punctuation">,</span> CHUNKSIZE<span class="token punctuation">)</span> <span class="token operator">/</span> WSIZE<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>  <span class="token function">place</span><span class="token punctuation">(</span>bp<span class="token punctuation">,</span> asize<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> bp<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>将 $size$ 对齐至 $16$ 字节, 并扩展加上 $header$, $footer$.</li><li>首先使用 $first$ $fit$ 策略查询 $free$ $list$, 返回一个指向连续内存块的指针.</li><li>若返回为 $NULL$, 则在该处进行 $extend_heap$.</li></ul><h4 id="mm-free-1"><a href="#mm-free-1" class="headerlink" title="mm_free"></a>mm_free</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">mm_free</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">)</span> <span class="token punctuation">{</span>  size_t size <span class="token operator">=</span> <span class="token function">GET_SIZE</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">FTRP</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">coalesce</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>将 $alloc$ $bit$ 位置 $0$, 并进行 $free$ $block$ 的合并.</li></ul><h4 id="mm-realloc-1"><a href="#mm-realloc-1" class="headerlink" title="mm_realloc"></a>mm_realloc</h4><ul><li>如果 $ptr$ 为 $NULL$, 直接调用 $mm_malloc$. </li><li>如果 $size$ 为 $0$, 直接调用 $mm_free$. </li><li>否则, 直接调用 $mm_malloc$ 分配 $newptr$, 以下同 $Version$ $0$. </li></ul><h3 id="Performance-1"><a href="#Performance-1" class="headerlink" title="Performance"></a>Performance</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Results <span class="token keyword">for</span> mm malloc:trace            name     valid  util     ops      secs   Kops <span class="token number">1</span>     amptjp-bal.rep       <span class="token function">yes</span>   <span class="token number">90</span>%    <span class="token number">5694</span>  <span class="token number">0.001877</span>   <span class="token number">3033</span> <span class="token number">2</span>       cccp-bal.rep       <span class="token function">yes</span>   <span class="token number">92</span>%    <span class="token number">5848</span>  <span class="token number">0.001071</span>   <span class="token number">5459</span> <span class="token number">3</span>    cp-decl-bal.rep       <span class="token function">yes</span>   <span class="token number">94</span>%    <span class="token number">6648</span>  <span class="token number">0.004788</span>   <span class="token number">1389</span> <span class="token number">4</span>       expr-bal.rep       <span class="token function">yes</span>   <span class="token number">96</span>%    <span class="token number">5380</span>  <span class="token number">0.005364</span>   <span class="token number">1003</span> <span class="token number">5</span> coalescing-bal.rep       <span class="token function">yes</span>   <span class="token number">50</span>%   <span class="token number">14400</span>  <span class="token number">0.000173</span>  <span class="token number">83189</span> <span class="token number">6</span>     random-bal.rep       <span class="token function">yes</span>   <span class="token number">90</span>%    <span class="token number">4800</span>  <span class="token number">0.006984</span>    <span class="token number">687</span> <span class="token number">7</span>    random2-bal.rep       <span class="token function">yes</span>   <span class="token number">87</span>%    <span class="token number">4800</span>  <span class="token number">0.006384</span>    <span class="token number">752</span> <span class="token number">8</span>     binary-bal.rep       <span class="token function">yes</span>   <span class="token number">54</span>%   <span class="token number">12000</span>  <span class="token number">0.015309</span>    <span class="token number">784</span> <span class="token number">9</span>    binary2-bal.rep       <span class="token function">yes</span>   <span class="token number">47</span>%   <span class="token number">24000</span>  <span class="token number">0.007432</span>   <span class="token number">3229</span><span class="token number">10</span>    realloc-bal.rep       <span class="token function">yes</span>   <span class="token number">32</span>%   <span class="token number">14401</span>  <span class="token number">0.141429</span>    <span class="token number">102</span><span class="token number">11</span>   realloc2-bal.rep       <span class="token function">yes</span>   <span class="token number">34</span>%   <span class="token number">14401</span>  <span class="token number">0.003931</span>   <span class="token number">3663</span>Total                             <span class="token number">70</span>%  <span class="token number">112372</span>  <span class="token number">0.194743</span>    <span class="token number">577</span>Score <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">42</span> <span class="token punctuation">(</span>util<span class="token punctuation">)</span> + <span class="token number">2</span> <span class="token punctuation">(</span>thru<span class="token punctuation">))</span> * <span class="token number">11</span>/11 <span class="token punctuation">(</span>testcase<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">44</span>/100<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>通过了所有测试文件.</p><p>几乎所有测试点的 $Kops$ 均需进行优化, 最后两个测试 $mm_realloc$ 功能点的 $Memory$ $Utilization$ 过低.</p></blockquote><h2 id="Version-2"><a href="#Version-2" class="headerlink" title="Version 2"></a>Version 2</h2><p>采用 $Explicit$ $Free$ $List$ 组织空闲块, 使用的数据结构为 $Double$ $Linked$ $List$.</p><h3 id="Block-Structure-2"><a href="#Block-Structure-2" class="headerlink" title="Block Structure"></a>Block Structure</h3><p>一个 $block$ 的结构被组织为:</p><p><img src="/pic/48.png" alt=""></p><p>考虑 $Boundary$ $Tags$ 与 $Alignment$ 条件, 此时 $minimum$ $block$ $size$ 为 $4 * WSIZE\,(32\,Bytes)$.</p><h3 id="Macros-1"><a href="#Macros-1" class="headerlink" title="Macros"></a>Macros</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/* 前/后 block 中 payloader 的起始地址 */</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">PREV_BLK</span><span class="token expression"><span class="token punctuation">(</span>bp<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token function">GET_SIZE</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span> <span class="token operator">-</span> DSIZE<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">NEXT_BLK</span><span class="token expression"><span class="token punctuation">(</span>bp<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">GET_SIZE</span><span class="token punctuation">(</span><span class="token function">HEADER</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span></span><span class="token comment">/* 前/后 free block 中 payloader 的起始地址 */</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">PRED_BLK</span><span class="token expression"><span class="token punctuation">(</span>bp<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">SUCC_BLK</span><span class="token expression"><span class="token punctuation">(</span>bp<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>bp <span class="token operator">+</span> WSIZE<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>模拟了 $Double$ $Linked$ $List$ 的实现.</li><li>$PRED_BLK$, $SUCC_BLK$ 区别于先前定义的 $PREV_BLK$, $NEXT_BLK$, 用于在 $Explicit$ $Free$ $List$ 中进行前后 $free$ $block$ 的标记.</li></ul><h3 id="Helper-Functions-2"><a href="#Helper-Functions-2" class="headerlink" title="Helper Functions"></a>Helper Functions</h3><h4 id="insert-free-block"><a href="#insert-free-block" class="headerlink" title="insert_free_block"></a>insert_free_block</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">insert_free_block</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>bp<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token function">PRED_BLK</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>  <span class="token function">SUCC_BLK</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span> <span class="token operator">=</span> heap_lo<span class="token punctuation">;</span>  <span class="token function">PRED_BLK</span><span class="token punctuation">(</span>sentinel<span class="token punctuation">)</span> <span class="token operator">=</span> bp<span class="token punctuation">;</span>   heap_lo <span class="token operator">=</span> bp<span class="token punctuation">;</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>将 $bp$ ( 指向一个 $free$ $block$ ) 插入 $Explicit$ $Free$ $List$ 的尾部作为 $sentinel$.</li></ul><h4 id="remove-free-block"><a href="#remove-free-block" class="headerlink" title="remove_free_block"></a>remove_free_block</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">remove_free_block</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>bp<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token function">PRED_BLK</span><span class="token punctuation">(</span><span class="token function">SUCC_BLK</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">PRED_BLK</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">PRED_BLK</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token function">SUCC_BLK</span><span class="token punctuation">(</span><span class="token function">PRED_BLK</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">SUCC_BLK</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">else</span>    heap_lo <span class="token operator">=</span> <span class="token function">SUCC_BLK</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>将 $bp$ ( 指向一个被分配的 $block$ ) 从 $Explicit$ $Free$ $List$ 中删除.</li><li>需要检查 $bp$ 是否为 $sentinel$.</li></ul><h4 id="first-fit-1"><a href="#first-fit-1" class="headerlink" title="first_fit"></a>first_fit</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">first_fit</span><span class="token punctuation">(</span>size_t asize<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>malloced <span class="token operator">!=</span> asize<span class="token punctuation">)</span> counter <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>counter <span class="token operator">&gt;=</span> <span class="token number">48</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    bp <span class="token operator">=</span> <span class="token function">extend_heap</span><span class="token punctuation">(</span><span class="token function">MAX</span><span class="token punctuation">(</span>asize <span class="token operator">/</span> WSIZE<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> bp<span class="token punctuation">;</span>  <span class="token punctuation">}</span> <span class="token keyword">else</span> counter<span class="token operator">++</span><span class="token punctuation">;</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>在 $binary{-}bal.rep$ 与 $binary2{-}bal.rep$ 测试文件中进行了大量相同 $size$ 的 $malloc$ 操作.</p><p>如果重复使用 $first_fit$ 进行检索, 会使 $Kops$ 显著过低.</p></blockquote><ul><li>定义 $malloced$ 为上一次调用 $mm_malloc$ 分配的 $size$ 大小.</li><li>如果重复分配同样 $size$ 的块超过 $48$ 次 ( $48$ 为反复调节获得的最佳参数 ), 则直接调用 $extend_heap$ 将堆扩展相应大小, 不再通过 $first_fit$ 进行检索.</li></ul><h4 id="place-1"><a href="#place-1" class="headerlink" title="place"></a>place</h4><ul><li>若剩余 $payloader$ 需要进行 $split$ 操作, 则先进行 $remove_free_block$, 最后对剩余 $free$ $block$ 进行 $insert_free_block$.</li><li>否则, 直接进行 $remove_free_block$ 并设置 $alloc$ $bit$.</li></ul><h4 id="coalesce-1"><a href="#coalesce-1" class="headerlink" title="coalesce"></a>coalesce</h4><ul><li>仍采用 $immediate$ $coalesce$ 策略.</li><li>在设置 $alloc$ $bit$ 前进行 $remove_free_block$, 最后对合并的 $free$ $block$ 进行 $insert_free_block$.</li></ul><h4 id="extend-heap-1"><a href="#extend-heap-1" class="headerlink" title="extend_heap"></a>extend_heap</h4><ul><li>由于此时 $minimum$ $block$ $size$ 为 $4 <em> WSIZE$, 将 $size$ 双字对齐后, 若其为 $2 </em> WSIZE$, 则置为 $4 * WSIZE$.</li></ul><h3 id="Malloc-Functions-2"><a href="#Malloc-Functions-2" class="headerlink" title="Malloc Functions"></a>Malloc Functions</h3><h4 id="mm-init-2"><a href="#mm-init-2" class="headerlink" title="mm_init"></a>mm_init</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">mm_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">extend_heap</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>$mm_init$ 会调用 $extend_heap$ 预分配一块 $4096\,Bytes$ 大小的空间做为起始 $free$ $block$, $mm_malloc$ 在 $List$ 中没有合适 $free$ $block$ 的情况下总会调用 $extend_heap$ 扩展空间, 其大小取 $4096\,Bytes$ 与待分配大小中较大者.</p><p>在 $coalescing{-}bal.rep$ 中, 起始分配 $4095\,Bytes$ 大小的空间, 经过 $16$ 字节对齐和 $Tag$ 扩展后大于 $4096\,Bytes$, 初始的 $4096\,Bytes$ 空间永远不会被利用.</p><p>只需修改 $mm_init$ 中 $extend_heap$ 初始扩展大小为 $minimun$ $block$ $size$ 即可.</p></blockquote><ul><li>用 $minimun$ $block$ $size$ ( $4$ ) 大小的 $free$ $block$ 扩展空堆, 若扩展失败则返回 $NULL$.</li></ul><h4 id="mm-realloc-2"><a href="#mm-realloc-2" class="headerlink" title="mm_realloc"></a>mm_realloc</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">mm_realloc</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>bp<span class="token punctuation">,</span> size_t size<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">mm_free</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>   size_t oldsize <span class="token operator">=</span> <span class="token function">GET_SIZE</span><span class="token punctuation">(</span><span class="token function">HEADER</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  size_t newsize <span class="token operator">=</span> size <span class="token operator">+</span> <span class="token number">2</span> <span class="token operator">*</span> WSIZE<span class="token punctuation">;</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>newsize <span class="token operator">&lt;=</span> oldsize<span class="token punctuation">)</span> <span class="token keyword">return</span> bp<span class="token punctuation">;</span>   size_t next_alloc <span class="token operator">=</span> <span class="token function">GET_ALLOC</span><span class="token punctuation">(</span><span class="token function">HEADER</span><span class="token punctuation">(</span><span class="token function">NEXT_BLK</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   size_t asize <span class="token operator">=</span> oldsize <span class="token operator">+</span> <span class="token function">GET_SIZE</span><span class="token punctuation">(</span><span class="token function">HEADER</span><span class="token punctuation">(</span><span class="token function">NEXT_BLK</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>next_alloc <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>asize <span class="token operator">&gt;=</span> newsize<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token function">remove_free_block</span><span class="token punctuation">(</span><span class="token function">NEXT_BLK</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">HEADER</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>asize<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">FOOTER</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>asize<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">return</span> bp<span class="token punctuation">;</span>   <span class="token punctuation">}</span>  <span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token operator">*</span>newbp <span class="token operator">=</span> <span class="token function">mm_malloc</span><span class="token punctuation">(</span>newsize<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">place</span><span class="token punctuation">(</span>newbp<span class="token punctuation">,</span> newsize<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">memcpy</span><span class="token punctuation">(</span>newbp<span class="token punctuation">,</span> bp<span class="token punctuation">,</span> newsize<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token function">mm_free</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">return</span> newbp<span class="token punctuation">;</span>   <span class="token punctuation">}</span>   <span class="token punctuation">}</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>原始的 $mm_realloc$ 没有考虑被分配块前后 $free$ $block$ 的情况, 以及 $new$ $block$ $size$ 和 $old$ $block$ $size$ 的比较, 需对此进行优化.</p></blockquote><ul><li>如果 $size$ 为 $0$, 直接调用 $mm_free$. </li><li>如果 $new$ $block$ $size$ 不大于 $old$ $block$ $size$, 直接返回原指针 $bp$ 即可.</li><li>否则, 需要考察后面邻块.<ul><li>若其未分配, 且 $size$ 和不小于 $newsize$, 则直接合并两个 $free$ $block$ 即可.</li><li>否则, 需通过 $mm_malloc$ 分配 $new$ $block$, 并进行内存 $memcpy$.</li></ul></li></ul><h3 id="Performance-2"><a href="#Performance-2" class="headerlink" title="Performance"></a>Performance</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Results <span class="token keyword">for</span> mm malloc:trace            name     valid  util     ops      secs   Kops <span class="token number">1</span>     amptjp-bal.rep       <span class="token function">yes</span>   <span class="token number">88</span>%    <span class="token number">5694</span>  <span class="token number">0.000291</span>  <span class="token number">19594</span> <span class="token number">2</span>       cccp-bal.rep       <span class="token function">yes</span>   <span class="token number">86</span>%    <span class="token number">5848</span>  <span class="token number">0.000208</span>  <span class="token number">28142</span> <span class="token number">3</span>    cp-decl-bal.rep       <span class="token function">yes</span>   <span class="token number">94</span>%    <span class="token number">6648</span>  <span class="token number">0.000386</span>  <span class="token number">17214</span> <span class="token number">4</span>       expr-bal.rep       <span class="token function">yes</span>   <span class="token number">96</span>%    <span class="token number">5380</span>  <span class="token number">0.000287</span>  <span class="token number">18739</span> <span class="token number">5</span> coalescing-bal.rep       <span class="token function">yes</span>   <span class="token number">98</span>%   <span class="token number">14400</span>  <span class="token number">0.000202</span>  <span class="token number">71111</span> <span class="token number">6</span>     random-bal.rep       <span class="token function">yes</span>   <span class="token number">88</span>%    <span class="token number">4800</span>  <span class="token number">0.000645</span>   <span class="token number">7442</span> <span class="token number">7</span>    random2-bal.rep       <span class="token function">yes</span>   <span class="token number">85</span>%    <span class="token number">4800</span>  <span class="token number">0.000747</span>   <span class="token number">6429</span> <span class="token number">8</span>     binary-bal.rep       <span class="token function">yes</span>   <span class="token number">54</span>%   <span class="token number">12000</span>  <span class="token number">0.000393</span>  <span class="token number">30519</span> <span class="token number">9</span>    binary2-bal.rep       <span class="token function">yes</span>   <span class="token number">47</span>%   <span class="token number">24000</span>  <span class="token number">0.000480</span>  <span class="token number">50042</span><span class="token number">10</span>    realloc-bal.rep       <span class="token function">yes</span>   <span class="token number">86</span>%   <span class="token number">14401</span>  <span class="token number">0.000233</span>  <span class="token number">61754</span><span class="token number">11</span>   realloc2-bal.rep       <span class="token function">yes</span>   <span class="token number">17</span>%   <span class="token number">14401</span>  <span class="token number">0.000186</span>  <span class="token number">77383</span>Total                             <span class="token number">76</span>%  <span class="token number">112372</span>  <span class="token number">0.004058</span>  <span class="token number">27692</span>Score <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">46</span> <span class="token punctuation">(</span>util<span class="token punctuation">)</span> + <span class="token number">40</span> <span class="token punctuation">(</span>thru<span class="token punctuation">))</span> * <span class="token number">11</span>/11 <span class="token punctuation">(</span>testcase<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">86</span>/100<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h2><ul><li>$Malloc$ $Lab$ 需要用心 $DEBUG$, 并考验 $gdb$ 的使用掌握. </li><li>我从最简单的实现 —— $Implicit$ $Free$ $List$ 开始, 最后选择了 $Explicit$ $Free$ $List$ 进行实现. </li><li>根据不同 $trace$ 的组成, 我进行了分析与优化, 与 $Segmentation$ $Fault$ 日夜作战. </li><li>这次 $Lab$ 确实是对我的一次难得的体验!</li></ul>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;Lab-3-Malloc-Lab-实验报告&quot;&gt;&lt;a href=&quot;#Lab-3-Malloc-Lab-实验报告&quot; class=&quot;headerlink&quot; title=&quot;Lab 3 Malloc Lab 实验报告&quot;&gt;&lt;/a&gt;Lab 3 Malloc Lab</summary>
        
      
    
    
    
    <category term="CS" scheme="http://chengsx21.github.io/categories/CS/"/>
    
    <category term="CSAPP" scheme="http://chengsx21.github.io/categories/CS/CSAPP/"/>
    
    
    <category term="CSAPP" scheme="http://chengsx21.github.io/tags/CSAPP/"/>
    
  </entry>
  
  <entry>
    <title>形式语言与自动机 作业11</title>
    <link href="http://chengsx21.github.io/2022/12/22/xing-shi-yu-yan-yu-zi-dong-ji-zuo-ye-11/"/>
    <id>http://chengsx21.github.io/2022/12/22/xing-shi-yu-yan-yu-zi-dong-ji-zuo-ye-11/</id>
    <published>2022-12-22T09:27:40.000Z</published>
    <updated>2023-09-21T17:12:16.064Z</updated>
    
    <content type="html"><![CDATA[<h2 id="必做题"><a href="#必做题" class="headerlink" title="必做题"></a>必做题</h2><h3 id="Ex-8-2-2-c"><a href="#Ex-8-2-2-c" class="headerlink" title="Ex.8.2.2(c)"></a>Ex.8.2.2(c)</h3><p>​    一个满足条件的 $TM$ 为:<br><img src="/pic/45.png" alt=""></p><h3 id="Ex-8-2-3"><a href="#Ex-8-2-3" class="headerlink" title="Ex.8.2.3"></a>Ex.8.2.3</h3><p>​    $(a)$ 构造图灵机<br>​    <script type="math/tex">M = \left(\{q_0, q_1, q_2, q_3, q_4, q_f\}, \{0, 1, {\$}\}, \{0, 1, {\$}, B\}, \delta, q_0, B, \{q_f\}\right).</script><br>​    转移函数 $\delta$ 为:</p><script type="math/tex; mode=display">\begin{aligned}\delta(q_0, \$) &= (q_1, \$, R) \\\delta(q_1, 0) &= (q_1, 0, R) \\\delta(q_1, 1) &= (q_1, 1, R) \\\delta(q_1, B) &= (q_2, B, L) \\\delta(q_2, 0) &= (q_3, 1, L) \\\delta(q_2, 1) &= (q_4, 0, L) \\\delta(q_3, 0) &= (q_3, 0 , L) \\\delta(q_3, 1) &= (q_3, 1 , L) \\\delta(q_3, \$) &= (q_f, \$ , R) \\\delta(q_4, 0) &= (q_3, 1 , L) \\\delta(q_4, 1) &= (q_4, 0 , L) \\\delta(q_4, \$) &= (q_f, 1 , L)\end{aligned}</script><p>​    各状态的含义:</p><p>​    $q0$: 初态, 带头所扫描的符号必为 $$$;</p><p>​    $q1$: 右移状态, 当前带头所扫描的符号若为 $0$ 和 $1$ 则一直右移, 直至遇到空白带符为止；</p><p>​    $q2$: 处于二进制数的末位态, 带头所扫描的符号必为 $0$ 和 $1$, 否则无动作;</p><p>​    $q3$: 非进位左移状态, 当前带头所扫描的符号若为 $0$ 和 $1$ 则一直左移, 直至遇到 $$$为止;</p><p>​    $q4$: 进位左移状态, 带头扫描符号若为 $0$ 则将其变为 $1$, 并转 $q3$; 带头扫描符号若为 $1$ 则将其变为 $0$, 产生新的进位; 带头扫描符号若为 $$$, 产生一个新的进位.</p><p>​    $(b)$ 该 $TM$ 的 $ID$ 序列为:</p><script type="math/tex; mode=display">\begin{aligned}q_0\$111 &\vdash \$q_1111\vdash \$1q_111\vdash \$11q_11\vdash \$111q_1B\vdash \$11q_21 \\&\vdash \$1q_410\vdash \$q_4100\vdash q_4\$000\vdash q_fB1000\vdash q_f1000\end{aligned}</script><h3 id="Ex-8-2-5-b"><a href="#Ex-8-2-5-b" class="headerlink" title="Ex.8.2.5(b)"></a>Ex.8.2.5(b)</h3><p>​    这个图灵机接受的语言:<br>​    <script type="math/tex">L(M) = L(0^*11^*).</script><br>​    即语言 $L(M)$ 中的串至少包含一个 $1$, 第一个 $1$ 之前只可能出现 $0$, 每个 $1$ 之后只可能跟随 $1$.</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h2 id=&quot;必做题&quot;&gt;&lt;a href=&quot;#必做题&quot; class=&quot;headerlink&quot; title=&quot;必做题&quot;&gt;&lt;/a&gt;必做题&lt;/h2&gt;&lt;h3 id=&quot;Ex-8-2-2-c&quot;&gt;&lt;a href=&quot;#Ex-8-2-2-c&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    <category term="CS" scheme="http://chengsx21.github.io/categories/CS/"/>
    
    <category term="FL&amp;A" scheme="http://chengsx21.github.io/categories/CS/FL-A/"/>
    
    
    <category term="FL&amp;A" scheme="http://chengsx21.github.io/tags/FL-A/"/>
    
  </entry>
  
  <entry>
    <title>BBST</title>
    <link href="http://chengsx21.github.io/2022/12/20/bbst/"/>
    <id>http://chengsx21.github.io/2022/12/20/bbst/</id>
    <published>2022-12-20T09:27:28.000Z</published>
    <updated>2023-09-21T17:12:26.730Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CST-LAB3"><a href="#CST-LAB3" class="headerlink" title="CST LAB3"></a>CST LAB3</h1><h2 id="BBST"><a href="#BBST" class="headerlink" title="BBST"></a>BBST</h2><h3 id="一、数据结构"><a href="#一、数据结构" class="headerlink" title="一、数据结构"></a>一、数据结构</h3><p>我所实现的数据结构为 <code>AVLTree</code> 与 <code>SplayTree</code>, 现说明两个数据结构的核心接口与公共接口实现方法.</p><h4 id="1-AVLTree"><a href="#1-AVLTree" class="headerlink" title="1. AVLTree"></a>1. AVLTree</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">AvlNode</span> <span class="token punctuation">{</span>    AvlNode<span class="token operator">*</span> l<span class="token punctuation">;</span> <span class="token comment">// 左孩子.</span>    AvlNode<span class="token operator">*</span> r<span class="token punctuation">;</span> <span class="token comment">// 右孩子.</span>    <span class="token keyword">int</span> v<span class="token punctuation">;</span>      <span class="token comment">// 节点值.</span>    <span class="token keyword">int</span> h<span class="token punctuation">;</span>      <span class="token comment">// 节点高度.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">AvlTree</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> cnt<span class="token punctuation">;</span>       <span class="token comment">// 节点计数器.</span>    AvlNode<span class="token operator">*</span> Root<span class="token punctuation">;</span> <span class="token comment">// 根节点.</span>    AvlNode f<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 节点数组.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>参考了<a href="https://www.luogu.com.cn/blog/Just-monika/solution-p3369">这篇文章</a>实现了 <code>AvlNode</code> 结构体, 并以数组形式给出 <code>AvlTree</code> 结构.</p><h5 id="1-1-Maintain"><a href="#1-1-Maintain" class="headerlink" title="1.1 Maintain()"></a>1.1 Maintain()</h5><p><code>Maintain(current)</code> 首先根据当前节点的平衡因子 <code>BanlanceFactor(current)</code> 判断是否需要调用 <code>LeftRotate()</code> 与 <code>RightRotate()</code> 接口进行左旋、右旋重构, 同时利用这两个接口实现了 <code>LeftAdjust()</code> 与 <code>RightAdjust()</code> 接口进行双旋重构.</p><h5 id="1-2-Insert-与-Remove"><a href="#1-2-Insert-与-Remove" class="headerlink" title="1.2 Insert() 与 Remove()"></a>1.2 Insert() 与 Remove()</h5><p><code>AVLTree</code> 在 <code>Insert()</code> 与 <code>Remove()</code> 后首先通过 <code>PushUp(current)</code> 进行高度更新, 将当前节点高度更新为子节点的最大高度加 $1$.</p><p><code>AVLTree</code> 在 <code>Insert()</code> 与 <code>Remove()</code> 中 <code>PushUp(current)</code>后通过 <code>Maintain(current)</code> 进行重平衡.</p><h5 id="1-3-Search"><a href="#1-3-Search" class="headerlink" title="1.3 Search()"></a>1.3 Search()</h5><p><code>AVLTree</code> 在 <code>Search()</code> 中依次判断查询值与当前节点值的大小关系, 若不相等则决定深入搜索左或右子树. 在搜索时使用 <code>AvlNode* tmp</code> 记录数值不大于查询值的最大节点. 若查询得到目标节点, 直接返回; 否则到达叶节点, 若节点值小于查询值, 根据查询方法必为数值小于查询值的最大节点, 直接返回; 若节点值大于查询值, 则返回 <code>tmp</code> 节点.</p><h5 id="1-4-复杂度分析"><a href="#1-4-复杂度分析" class="headerlink" title="1.4 复杂度分析"></a>1.4 复杂度分析</h5><p>一高度为 $h$ 的 <code>AVLTree</code> 至少有 $S(h) = fib(h) = \varPhi^h$ 个节点, 故大小为 $n$ 的 <code>AVLTree</code> 的高度为 $O(\log n)$.</p><p>每次 <code>Search()</code> 操作的复杂度正相关于树高, 为 $O(\log n)$;</p><p>每次 <code>Insert()</code> 导致的失衡通过至多一次单旋或者双旋调整即可解决, 复杂度为 $O(1)$, 总复杂度取决于搜索高度, 为 $O(\log n)$;</p><p>每次 <code>Remove()</code> 导致的失衡可能从删除节点到根节点均需进行旋转调整, 旋转次数至多为 $O(\log n)$, 总体复杂度仍为 $O(\log n)$;</p><p>综上所述, <code>AVLTree</code> 的基本操作接口的时间复杂度均为 $O(\log n)$, 共计 $n$ 次操作, 总体时间复杂度为 $O(n\log n)$.</p><h4 id="2-SplayTree"><a href="#2-SplayTree" class="headerlink" title="2. SplayTree"></a>2. SplayTree</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">SplayNode</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> son<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 孩子.</span>    <span class="token keyword">int</span> father<span class="token punctuation">;</span> <span class="token comment">// 父亲.</span>    <span class="token keyword">int</span> val<span class="token punctuation">;</span>    <span class="token comment">// 节点值.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">SplayTree</span> <span class="token punctuation">{</span>    SplayNode t<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 节点数组.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>参考了<a href="https://www.luogu.com.cn/blog/cjyyb/solution-p3369">这篇文章</a>实现了 <code>SplayNode</code> 结构体, 并以数组形式给出 <code>SplayTree</code> 结构.</p><h5 id="2-1-Splay"><a href="#2-1-Splay" class="headerlink" title="2.1 Splay()"></a>2.1 Splay()</h5><p>首先实现了 <code>Rotate()</code> 接口进行单旋操作, 接着利用 <code>Rotate()</code> 接口实现了 <code>Splay()</code> 接口进行双旋操作.</p><h5 id="2-2-Insert"><a href="#2-2-Insert" class="headerlink" title="2.2 Insert()"></a>2.2 Insert()</h5><p><code>SplayTree</code> 在 <code>Insert()</code> 时逐层查询需要插入节点的位置, 直到到达叶节点. 插入节点后执行 <code>Splay(pointer, 0)</code> 将其伸展至根节点即可.</p><h5 id="2-3-Remove"><a href="#2-3-Remove" class="headerlink" title="2.3 Remove()"></a>2.3 Remove()</h5><p><code>SplayTree</code> 在 <code>Remove()</code> 中首先得到待删除节点的前驱与后继 <code>pred</code>与 <code>succ</code>. 因为预先插入了最小与最大节点, 这样的前驱与后继总是存在的. 通过 <code>Splay(pred, 0); Splay(succ, pred);</code> 将 <code>pred</code> 旋转至根节点, 并将 <code>succ</code> 旋转为其右孩子. 根据 <code>BBST</code> 的定义, 此时待删除节点必为 <code>succ</code> 的左孩子, 将其置零即可.</p><h5 id="2-4-Search"><a href="#2-4-Search" class="headerlink" title="2.4 Search()"></a>2.4 Search()</h5><p><code>SplayTree</code> 在 <code>Search()</code> 中依次判断查询值与当前节点值的大小关系, 若不相等则决定深入搜索左或右子树. 在搜索时使用 <code>int tmp</code> 记录数值不大于查询值的最大节点值. 若查询得到目标节点, 直接返回; 否则到达叶节点, 若节点值小于查询值, 根据查询方法必为数值小于查询值的最大节点, 直接返回; 若节点值大于查询值, 则返回 <code>tmp</code> 即可.</p><p>同时, <code>SplayTree</code> 对于搜索到的节点需要进行 <code>Splay()</code> 操作, 将其伸展至根节点.</p><h5 id="2-5-复杂度分析"><a href="#2-5-复杂度分析" class="headerlink" title="2.5 复杂度分析"></a>2.5 复杂度分析</h5><p>根据讲义 $P664-P668$ 对 <code>SplayTree</code> 的势能分析, 对于 <code>SplayTree</code> 的连续 $m\gg n$ 次 <code>Insert()</code>, <code>Remove()</code>, <code>Search()</code> 操作的均摊时间复杂度为 <code>O(logn)</code>.</p><h3 id="二、测例设计"><a href="#二、测例设计" class="headerlink" title="二、测例设计"></a>二、测例设计</h3><h4 id="1-测试环境"><a href="#1-测试环境" class="headerlink" title="1. 测试环境"></a>1. 测试环境</h4><p>操作系统: <code>Linux version 4.4.0-22621-Microsoft</code>.</p><p>编译器: <code>gcc version 5.4.0 (GCC)</code>.</p><h4 id="2-设计思路"><a href="#2-设计思路" class="headerlink" title="2. 设计思路"></a>2. 设计思路</h4><p>一共设计了四类测例, 存放在本地 <code>/Data</code> 路径中, 其相应生成器文件存放在本地 <code>/Generator</code> 路径中：</p><ul><li>第一类测例模拟完全随机进行插入、删除、查找操作. 操作数分别为 <code>100</code>, <code>10000</code>, <code>1000000</code> 次. 对应生成器文件为 <code>generator_1.cpp</code>, 测例文件为 <code>01.in</code> ~ <code>03.in</code>.</li><li>第二类测例模拟先插入后删除操作, 分为两组进行, 第一组 <code>80%</code> 次操作进行插入操作, <code>20%</code> 次操作进行删除操作; 第二组 <code>60%</code> 次操作进行插入操作, <code>40%</code> 操作进行删除操作. 操作数分别为 <code>100</code>, <code>10000</code>, <code>1000000</code> 次. 对应生成器文件为 <code>generator_2.cpp</code>, 测例文件为 <code>04.in</code> ~ <code>09.in</code>.</li><li>第三类测例模拟先插入后查找操作, 且查找范围为全局数值, 分为两组进行, 第一组 <code>80%</code> 次操作进行插入操作, <code>20%</code> 次操作进行全局查找操作; 第二组 <code>20%</code> 次操作进行插入操作, <code>80%</code> 操作进行全局查找操作. 操作数分别为 <code>100</code>, <code>10000</code>, <code>1000000</code> 次. 对应生成器文件为 <code>generator_3.cpp</code>, 测例文件为 <code>10.in</code> ~ <code>15.in</code>.</li><li>第四类测例模拟先插入后查找操作, 且查找范围为局部数值, 数值极差不超过总操作数的平方根, 分为两组进行, 第一组 <code>80%</code> 次操作进行插入操作, <code>20%</code> 次操作进行局部查找操作; 第二组 <code>20%</code> 次操作进行插入操作, <code>80%</code> 操作进行局部查找操作. 操作数分别为 <code>100</code>, <code>10000</code>, <code>1000000</code> 次. 对应生成器文件为 <code>generator_4.cpp</code>, 测例文件为 <code>16.in</code> ~ <code>21.in</code>.</li></ul><h4 id="3-测例生成"><a href="#3-测例生成" class="headerlink" title="3. 测例生成"></a>3. 测例生成</h4><p>使用 <code>bitmap</code> 数据结构记录 <code>Tree</code> 中数据的存在情况. 如果 <code>bitmap</code> 某一位设置为 <code>1</code>, 则相应值的节点存在于树中, 只能进行删除操作; 如果 <code>bitmap</code> 某一位设置为 <code>0</code>, 则相应值的节点不存在于树中, 只能进行插入操作。</p><pre class="line-numbers language-cpp++" data-language="cpp++"><code class="language-cpp++">// 随机数种子.srand((int)time(0));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>使用当前时间作为随机数种子, 充分保证了生成数据的随机性. 尝试生成一个 <code>Insert()</code> 数据点时, 随机访问一个位置, 若 <code>bitmap-&gt;test(rand_num) == 0</code>, 则可以在该处进行插入操作, 否则随机查询下一个位置; 尝试生成一个 <code>Remove()</code> 数据点时, 随机访问一个位置, 若 <code>bitmap-&gt;test(rand_num) == 1</code>, 则可以在该处进行插入操作, 否则遍历查询其之后的位置, 直到找到一个可以删除的数据点; 尝试生成一个全局 <code>Search()</code> 数据点时, 随机访问一个位置即可; 尝试生成一个局部 <code>Search()</code> 数据点时, 首先随机访问一个位置, 并在一定范围内随机生成数据即可.</p><h4 id="4-测试脚本"><a href="#4-测试脚本" class="headerlink" title="4. 测试脚本"></a>4. 测试脚本</h4><p>编写了 <code>avl.sh</code> 脚本对 <code>AVLTree</code> 数据结构进行测试.</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#avl.sh</span><span class="token comment">#!/bin/bash</span><span class="token keyword">for</span> <span class="token for-or-select variable">i</span> <span class="token keyword">in</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">..</span><span class="token number">21</span><span class="token punctuation">}</span><span class="token keyword">do</span>    <span class="token builtin class-name">echo</span> <span class="token string">"Test Case <span class="token variable">$i</span>:"</span> <span class="token operator">&gt;&gt;</span> avl.out    <span class="token punctuation">{</span> <span class="token function">time</span> ./avl <span class="token operator">&lt;</span>Data/<span class="token variable">$i</span>.in <span class="token operator">&gt;</span>Data/<span class="token variable">$i</span>.out<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token operator"><span class="token file-descriptor important">2</span>&gt;&gt;</span> avl.out<span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编写了 <code>splay.sh</code> 脚本对 <code>SplayTree</code> 数据结构进行测试.</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#splay.sh</span><span class="token comment">#!/bin/bash</span><span class="token keyword">for</span> <span class="token for-or-select variable">i</span> <span class="token keyword">in</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">..</span><span class="token number">21</span><span class="token punctuation">}</span><span class="token keyword">do</span>    <span class="token builtin class-name">echo</span> <span class="token string">"Test Case <span class="token variable">$i</span>:"</span> <span class="token operator">&gt;&gt;</span> splay.out    <span class="token punctuation">{</span> <span class="token function">time</span> ./splay <span class="token operator">&lt;</span>Data/<span class="token variable">$i</span>.in <span class="token operator">&gt;</span>Data/<span class="token variable">$i</span>.out<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token operator"><span class="token file-descriptor important">2</span>&gt;&gt;</span> splay.out<span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="三、性能分析"><a href="#三、性能分析" class="headerlink" title="三、性能分析"></a>三、性能分析</h3><h4 id="1-generator-1-cpp-数据"><a href="#1-generator-1-cpp-数据" class="headerlink" title="1. generator_1.cpp 数据"></a>1. <code>generator_1.cpp</code> 数据</h4><p>对应于 <code>01.in</code> ~ <code>03.in</code>.</p><div class="table-container"><table><thead><tr><th style="text-align:center">数据规模</th><th style="text-align:center">AVL</th><th style="text-align:center">Splay</th></tr></thead><tbody><tr><td style="text-align:center">1e2</td><td style="text-align:center">time:0.027s</td><td style="text-align:center">time:0.028s</td></tr><tr><td style="text-align:center">1e4</td><td style="text-align:center">time:0.026s</td><td style="text-align:center">time:0.153s</td></tr><tr><td style="text-align:center">1e6</td><td style="text-align:center">time:0.540s</td><td style="text-align:center">time:0.737s</td></tr></tbody></table></div><ul><li>在完全随机数据下, <code>AVLTree</code> 性能优于 <code>SplayTree</code>.</li><li>由于数据的随机性, <code>SplayTree</code> 数据访问的局部性差, 缓存策略效果不大, 其每次操作都需进行 $O(\log n)$ 次的旋转, 性能不如 <code>AVLTree</code>. 随着数据规模的增大, <code>AVLTree</code> 的性能优势逐渐扩大.</li></ul><h4 id="2-generator-2-cpp-数据"><a href="#2-generator-2-cpp-数据" class="headerlink" title="2. generator_2.cpp 数据"></a>2. <code>generator_2.cpp</code> 数据</h4><p>对应于 <code>04.in</code> ~ <code>09.in</code>.</p><div class="table-container"><table><thead><tr><th style="text-align:center">数据规模</th><th style="text-align:center">AVL</th><th style="text-align:center">Splay</th></tr></thead><tbody><tr><td style="text-align:center">1e2(8:2)</td><td style="text-align:center">time:0.022s</td><td style="text-align:center">time:0.015s</td></tr><tr><td style="text-align:center">1e2(6:4)</td><td style="text-align:center">time:0.021s</td><td style="text-align:center">time:0.015s</td></tr><tr><td style="text-align:center">1e4(8:2)</td><td style="text-align:center">time:0.026s</td><td style="text-align:center">time:0.023s</td></tr><tr><td style="text-align:center">1e4(6:4)</td><td style="text-align:center">time:0.025s</td><td style="text-align:center">time:0.020s</td></tr><tr><td style="text-align:center">1e6(8:2)</td><td style="text-align:center">time:1.455s</td><td style="text-align:center">time:1.730s</td></tr><tr><td style="text-align:center">1e6(6:4)</td><td style="text-align:center">time:1.273s</td><td style="text-align:center">time:2.057s</td></tr></tbody></table></div><ul><li>在先插入后删除数据下, 数据规模较小时 <code>SplayTree</code> 性能占优, 数据规模较大时 <code>AVLTree</code> 性能占优.</li><li>数据规模较小时, 两种数据结构插入与删除操作的效率相近, <code>SplayTree</code> 性能略占优; 数据规模较大时, <code>AVLTree</code> 相较 <code>SplayTree</code> 在删除操作的优势体现的更为明显.</li></ul><h4 id="3-generator-3-cpp-数据"><a href="#3-generator-3-cpp-数据" class="headerlink" title="3. generator_3.cpp 数据"></a>3. <code>generator_3.cpp</code> 数据</h4><p>对应于 <code>10.in</code> ~ <code>15.in</code>.</p><div class="table-container"><table><thead><tr><th style="text-align:center">数据规模</th><th style="text-align:center">AVL</th><th style="text-align:center">Splay</th></tr></thead><tbody><tr><td style="text-align:center">1e2(8:2)</td><td style="text-align:center">time:0.021s</td><td style="text-align:center">time:0.023s</td></tr><tr><td style="text-align:center">1e2(2:8)</td><td style="text-align:center">time:0.027s</td><td style="text-align:center">time:0.026s</td></tr><tr><td style="text-align:center">1e4(8:2)</td><td style="text-align:center">time:0.025s</td><td style="text-align:center">time:0.024s</td></tr><tr><td style="text-align:center">1e4(2:8)</td><td style="text-align:center">time:0.025s</td><td style="text-align:center">time:0.026s</td></tr><tr><td style="text-align:center">1e6(8:2)</td><td style="text-align:center">time:1.232s</td><td style="text-align:center">time:1.512s</td></tr><tr><td style="text-align:center">1e6(2:8)</td><td style="text-align:center">time:0.739s</td><td style="text-align:center">time:1.288s</td></tr></tbody></table></div><ul><li>在先插入后删除数据下, 数据规模较小时 <code>AVLTree</code> 性能略占优, 数据规模较大时 <code>AVLTree</code> 性能明显占优.</li><li>数据规模较小时, <code>AVLTree</code> 的性能略微优于 <code>SplayTree</code>. 随着数据规模的增大, 数据访问的局部性下降, <code>AVLTree</code> 和 <code>SplayTree</code> 性能均略微下降; 由于 <code>SplayTree</code> 每次操作都需进行 $O(\log n)$ 次的旋转, 受到的影响较大, 因此 <code>AVLTree</code> 性能明显占优.</li></ul><h4 id="4-generator-4-cpp-数据"><a href="#4-generator-4-cpp-数据" class="headerlink" title="4. generator_4.cpp 数据"></a>4. <code>generator_4.cpp</code> 数据</h4><p>对应于 <code>16.in</code> ~ <code>21.in</code>.</p><div class="table-container"><table><thead><tr><th style="text-align:center">数据规模</th><th style="text-align:center">AVL</th><th style="text-align:center">Splay</th></tr></thead><tbody><tr><td style="text-align:center">1e2(8:2)</td><td style="text-align:center">time:0.021s</td><td style="text-align:center">time:0.020s</td></tr><tr><td style="text-align:center">1e2(2:8)</td><td style="text-align:center">time:0.021s</td><td style="text-align:center">time:0.022s</td></tr><tr><td style="text-align:center">1e4(8:2)</td><td style="text-align:center">time:0.026s</td><td style="text-align:center">time:0.023s</td></tr><tr><td style="text-align:center">1e4(2:8)</td><td style="text-align:center">time:0.025s</td><td style="text-align:center">time:0.024s</td></tr><tr><td style="text-align:center">1e6(8:2)</td><td style="text-align:center">time:1.094s</td><td style="text-align:center">time:1.073s</td></tr><tr><td style="text-align:center">1e6(2:8)</td><td style="text-align:center">time:0.358s</td><td style="text-align:center">time:0.276s</td></tr></tbody></table></div><ul><li>在先插入后局部查找数据下, 数据规模较小时两种数据结构性能相近, 数据规模较大时 <code>SplayTree</code> 性能略占优.</li><li><code>SplayTree</code> 的理想优势在于数据访问的局部性, 在连续局部查找下, 搜索的数据越发集中, 随着数据规模的增大与查找操作比例的提高, <code>SplayTree</code> 的优势逐渐体现.</li></ul><h3 id="四、小结"><a href="#四、小结" class="headerlink" title="四、小结"></a>四、小结</h3><p>在数据较为随机或无法确定数据局部性时, 应选用 <code>AVLTree</code>, 它的时间常数小, 单次时间复杂度较为稳定. 在数据访问的局部性较强时, 应选用 <code>SplayTree</code>, 可以实现较优的性能.</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;CST-LAB3&quot;&gt;&lt;a href=&quot;#CST-LAB3&quot; class=&quot;headerlink&quot; title=&quot;CST LAB3&quot;&gt;&lt;/a&gt;CST LAB3&lt;/h1&gt;&lt;h2 id=&quot;BBST&quot;&gt;&lt;a href=&quot;#BBST&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    <category term="CS" scheme="http://chengsx21.github.io/categories/CS/"/>
    
    <category term="DSA" scheme="http://chengsx21.github.io/categories/CS/DSA/"/>
    
    
    <category term="DSA" scheme="http://chengsx21.github.io/tags/DSA/"/>
    
  </entry>
  
  <entry>
    <title>形式语言与自动机 作业10</title>
    <link href="http://chengsx21.github.io/2022/12/17/xing-shi-yu-yan-yu-zi-dong-ji-zuo-ye-10/"/>
    <id>http://chengsx21.github.io/2022/12/17/xing-shi-yu-yan-yu-zi-dong-ji-zuo-ye-10/</id>
    <published>2022-12-17T09:25:29.000Z</published>
    <updated>2023-09-21T17:12:12.303Z</updated>
    
    <content type="html"><![CDATA[<h2 id="必做题"><a href="#必做题" class="headerlink" title="必做题"></a>必做题</h2><h3 id="Ex-7-2-1-b"><a href="#Ex-7-2-1-b" class="headerlink" title="Ex.7.2.1(b)"></a>Ex.7.2.1(b)</h3><p>​    对于任意的 $n \ge 1$, 存在 $z = a^nb^nc^n\in\left\{a^nb^nc^i\mid i\le n\right\}$.</p><p>​    考虑任意 $u, v, w, x, y$ 满足 $z = uvwxy$, $\vert vwx\vert &lt; n$, 且 $vx\ne\varepsilon$.</p><p>​    $(a)$ 若 $vwx$ 不包含 $c$, 取 $k = 0$, </p><p>​    此时易知 $\vert uv^kwx^ky\vert = \vert uwy\vert &lt; 3n$, 且其中 $c$ 的数目为 $n$,</p><p>​    那么 $c$ 的数目至少多于 $a, b$ 中的一个, 即<br>​    <script type="math/tex">uv^kwx^ky = uwy\notin\left\{a^nb^nc^i\mid i\le n\right\}.</script><br>​    $(b)$ 若 $vwx$ 包含 $c$, 那么必有 $x$ 包含 $c$. 取 $k = 2$, </p><p>​    由于 $\vert vwx\vert &lt; n$, 易知 $vwx$ 不包含 $a$,</p><p>​    此时 $uv^kwx^ky = uv^2wx^2y$, 且其中 $a$ 的数目为 $n$, $c$ 的数目 $&gt; n$,</p><p>​    那么 $c$ 的数目多于 $a$, 即<br>​    <script type="math/tex">uv^kwx^ky = uv^2wx^2y\notin\left\{a^nb^nc^i\mid i\le n\right\}.</script></p><p>​    综上所述, $z$ 不满足 $CFL$ 的 $Pumping$ 引理, 不是上下文无关语言.</p><h3 id="Ex-7-2-1-d"><a href="#Ex-7-2-1-d" class="headerlink" title="Ex.7.2.1(d)"></a>Ex.7.2.1(d)</h3><p>​    对于任意的 $n \ge 1$, 存在 $z = 0^n1^{n^2}\in\left\{0^i1^j\mid j = i^2\right\}$.</p><p>​    考虑任意 $u, v, w, x, y$ 满足 $z = uvwxy$, $\vert vwx\vert &lt; n$, 且 $vx\ne\varepsilon$.</p><p>​    $(A)$ 若 $vwx$ 仅包含 $0$, 取 $k = 0$, </p><p>​    此时 $uv^kwx^ky = uwy$, 其中 $0$ 的数目 $&lt; n$, $1$ 的数目为 $n^2$, 即<br>​    <script type="math/tex">uv^kwx^ky = uwy\notin\left\{0^i1^j\mid j = i^2\right\}.</script><br>​    $(B)$ 若 $vwx$ 仅包含 $1$, 取 $k = 0$, </p><p>​    此时 $uv^kwx^ky = uwy$, 其中 $1$ 的数目 $&lt; n^2$, $0$ 的数目为 $n$, 即<br>​    <script type="math/tex">uv^kwx^ky = uwy\notin\left\{0^i1^j\mid j = i^2\right\}.</script><br>​    $(C)$ 若 $vwx$ 同时包含 $0$ 和 $1$:</p><p>​    $(c.1)$ 若 $v$ 同时包含 $0$ 和 $1$, 取 $k = 2$, </p><p>​    不妨设<br>​    <script type="math/tex">v = 0^p1^q, x = 1^r,</script><br>​    其中<br>​    <script type="math/tex">p\ge 1, q\ge 1, p + q + r < n.</script><br>​    此时<br>​    <script type="math/tex">uv^kwx^ky = uv^2wx^2y = 0^{n + p}1^{n^2 + q + r},</script><br>​    其中<br>​    <script type="math/tex">(n + p)^2 > n^2 + 2np > n^2 + n > n^2 + q + r,</script><br>​    故有<br>​    <script type="math/tex">uv^kwx^ky = uv^2wx^2y\notin\left\{0^i1^j\mid j = i^2\right\}.</script><br>​    $(c.2)$ 若 $v$ 仅包含 $0$, 取 $k = 2$, </p><p>​    不妨设<br>​    <script type="math/tex">v = 0^p, x = 0^q1^r,</script><br>​    其中<br>​    <script type="math/tex">p\ge 1, p + q + r < n.</script><br>​    此时<br>​    <script type="math/tex">uv^kwx^ky = uv^2wx^2y = 0^{n + p + q}1^{n^2 + r},</script><br>​    其中<br>​    <script type="math/tex">(n + p + q)^2 > n^2 + 2np > n^2 + n > n^2 + r,</script><br>​    故有<br>​    <script type="math/tex">uv^kwx^ky = uv^2wx^2y\notin\left\{0^i1^j\mid j = i^2\right\}.</script><br>​    综上所述, $z$ 不满足 $CFL$ 的 $Pumping$ 引理, 不是上下文无关语言.    </p><h3 id="Ex-7-3-1-b"><a href="#Ex-7-3-1-b" class="headerlink" title="Ex.7.3.1(b)"></a>Ex.7.3.1(b)</h3><p>​    考虑上下文无关语言 $L$ 的一个 $CNF$ 文法 $G = (V, T, P, S)$. </p><p>​    我们构造 $G’ = (V’, T, P’, S)$.</p><p>​    其中 $\forall\thinspace A\in V$, 我们令 $A\in V’, \thinspace A’\in V’$.</p><p>​    $\circ$ 若 $A\rightarrow BC\in P$, 我们令 $A\rightarrow BC\in P’, \thinspace A’\rightarrow BC’\in P’$.</p><p>​    $\circ$ 若 $A\rightarrow b\in P$, 我们令 $A\rightarrow b\in P’$.</p><p>​    若 $b\ne a$, 再令 $A’\rightarrow b\in P’$; 若 $b = a$, 则令 $A’\rightarrow\varepsilon\in P’$.</p><p>​    如此得到了一个文法 $G’$, $L/a = L(G’)$ 为上下文无关语言.</p><p>​    也即 $CFL$ 对 $L/a$ 运算封闭.</p><h3 id="Ex-7-3-2"><a href="#Ex-7-3-2" class="headerlink" title="Ex.7.3.2"></a>Ex.7.3.2</h3><p>​    $(a)$</p><p>​    满足 $L_1$ 的一个可行的上下文无关文法 $G_1$ 是:</p><script type="math/tex; mode=display">\begin{aligned}S &\rightarrow AB \\A &\rightarrow aAbb \mid \varepsilon \\B &\rightarrow cB \mid \varepsilon\end{aligned}</script><p>​    满足 $L_2$ 的一个可行的上下文无关文法 $G_2$ 是:</p><script type="math/tex; mode=display">\begin{aligned}S &\rightarrow AB \\A &\rightarrow aA \mid \varepsilon \\B &\rightarrow bBcc \mid \varepsilon\end{aligned}</script><p>​    易知 $L_1 = L(G_1)$, $L_2 = L(G_2)$.</p><p>​    $(b)$ 记<br>​    <script type="math/tex">L = L_1\cap L_2 = \left\{a^nb^{2n}c^{4n}\mid n\ge 0\right\}.</script><br>​    $L$ 不是 $CFG$, 使用 $Pumping$ 引理证明之.</p><p>​    对于任意的 $n \ge 1$, 存在 $z = a^nb^{2n}c^{4n}\in L$.</p><p>​    考虑任意 $u, v, w, x, y$ 满足 $z = uvwxy$, $\vert vwx\vert &lt; n$, 且 $vx\ne\varepsilon$.</p><p>​    $(a)$ 若 $vwx$ 不包含 $c$, 取 $k = 0$, </p><p>​    此时易知 $\vert uv^kwx^ky\vert = \vert uwy\vert &lt; 7n$, 且其中 $c$ 的数目为 $4n$,</p><p>​    那么 $c$ 的数目要么多于 $a$ 的 $4$ 倍, 要么多于 $b$ 的 $2$ 倍, 即<br>​    <script type="math/tex">uv^kwx^ky = uwy\notin L.</script><br>​    $(b)$ 若 $vwx$ 包含 $c$, 那么必有 $x$ 包含 $c$. 取 $k = 2$, </p><p>​    由于 $\vert vwx\vert &lt; n$, 易知 $vwx$ 不包含 $a$,</p><p>​    此时 $uv^kwx^ky = uv^2wx^2y$, 且其中 $a$ 的数目为 $n$, $c$ 的数目 $&gt; 4n$, 即<br>​    <script type="math/tex">uv^kwx^ky = uv^2wx^2y\notin L.</script><br>​    综上所述, $z$ 不满足 $CFL$ 的 $Pumping$ 引理, 不是上下文无关语言.</p><h3 id="Ex-7-3-6"><a href="#Ex-7-3-6" class="headerlink" title="Ex.7.3.6"></a>Ex.7.3.6</h3><p>​    作 $L = L(G)$, $G = (V, T, P, S)$. 构造 $G^R = (V, T, P^R, S)$.</p><p>​    其中 $P^R$ 的产生式是 $P$ 中的产生式的反向, 即<br>​    <script type="math/tex">A\rightarrow \alpha^R\in P^R\Leftrightarrow A\rightarrow\alpha\in P.</script></p><p>​    下证:<br>​    <script type="math/tex">\forall\thinspace w\in T^*, S\mathop{\Longrightarrow}\limits_G^* w\Longleftrightarrow S\mathop{\Longrightarrow}\limits_{G_R}^* w^R.</script><br>​    假设 $S\mathop{\Longrightarrow}\limits_G^* w$, 归纳于该推导的长度 $n$.</p><p>​    $\circ$ $n = 1$ 时, $S\rightarrow w$ 为 $G$ 中的一个产生式, </p><p>​    因而 $S\rightarrow w^R$ 为 $G^R$ 的一个产生式, 所以 $S\mathop{\Longrightarrow}\limits_{G_R}^* w^R$.</p><p>​    $\circ$ $n &gt; 1$ 时, 设第一步推导使用了产生式 $S\rightarrow X_1X_2\cdots X_k$,</p><p>​    其中 $X_i\in V\cup T (1\le i\le k)$. 可以将 $w$ 打断为 $w = w_1w_2\cdots w_k$,</p><p>​    若 $X_i\in V$, 则存在 $w_i\in T^<em>$, 使得在少于 $n$ 步内 $X_i\mathop{\Longrightarrow}\limits_G^</em> w_i$,</p><p>​    由归纳假设, $X_i\mathop{\Longrightarrow}\limits^*_{G^R} w_i^R$.</p><p>​    若 $X_i\in T$, 则令 $w_i= X_i$, 亦有 $X_i\mathop{\Longrightarrow}\limits^*_{G^R} w_i^R$.</p><p>​    由构造方法, $G^R$ 中包含产生式 $S\rightarrow X_kX_{k - 1}\cdots X_1$. 故</p><script type="math/tex; mode=display">\begin{aligned}S &{\mathop{\Longrightarrow}\limits_{G^R}} X_kX_{k - 1}\cdots X_1 \\&{\mathop{\Longrightarrow}\limits^*_{G^R}} w_k^RX_{k - 1}\cdots X_1 \\&{\mathop{\Longrightarrow}\limits^*_{G^R}} w_k^Rw_{k - 1}^R\cdots X_1 \\&{\mathop{\Longrightarrow}\limits^*_{G^R}} w_k^Rw_{k - 1}^R\cdots w_1^R \\&= (w_1w_2\cdots w_k)^R \\&= w^R.\end{aligned}</script><p>​    同理可证, 若 $S\mathop{\Longrightarrow}\limits_{G_R}^<em> w^R$, 则有 $S\mathop{\Longrightarrow}\limits_G^</em> w$.</p><p>​    由此可知 $L^R = L(G^R)$, $L^R$ 是上下文无关语言.</p><p>​    也即 $CFL$ 在反转运算下是封闭的.</p><h3 id="Ex-7-4-3-c"><a href="#Ex-7-4-3-c" class="headerlink" title="Ex.7.4.3(c)"></a>Ex.7.4.3(c)</h3><p>​    由 $CYK$ 算法构造的针对 $aabab$ 的表如下:</p><p> <img src="/pic/44.png" alt=""></p><p>​    由于 $S\in X_{15}$, 所以 $aabab\in L(G)$.</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h2 id=&quot;必做题&quot;&gt;&lt;a href=&quot;#必做题&quot; class=&quot;headerlink&quot; title=&quot;必做题&quot;&gt;&lt;/a&gt;必做题&lt;/h2&gt;&lt;h3 id=&quot;Ex-7-2-1-b&quot;&gt;&lt;a href=&quot;#Ex-7-2-1-b&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    <category term="CS" scheme="http://chengsx21.github.io/categories/CS/"/>
    
    <category term="FL&amp;A" scheme="http://chengsx21.github.io/categories/CS/FL-A/"/>
    
    
    <category term="FL&amp;A" scheme="http://chengsx21.github.io/tags/FL-A/"/>
    
  </entry>
  
  <entry>
    <title>形式语言与自动机 作业9</title>
    <link href="http://chengsx21.github.io/2022/12/15/xing-shi-yu-yan-yu-zi-dong-ji-zuo-ye-9/"/>
    <id>http://chengsx21.github.io/2022/12/15/xing-shi-yu-yan-yu-zi-dong-ji-zuo-ye-9/</id>
    <published>2022-12-15T09:25:29.000Z</published>
    <updated>2023-09-21T17:12:05.302Z</updated>
    
    <content type="html"><![CDATA[<h2 id="必做题"><a href="#必做题" class="headerlink" title="必做题"></a>必做题</h2><h3 id="Ex-7-1-3"><a href="#Ex-7-1-3" class="headerlink" title="Ex 7.1.3"></a>Ex 7.1.3</h3><p>​    (a) 符号 $S$, $A$, $B$, $C$ 是可致空的.<br>​    消去 $\varepsilon$-产生式后得到新的产生式:</p><script type="math/tex; mode=display">\begin{aligned}S &\rightarrow 0A0 \mid 1B1 \mid 00 \mid 11 \mid BB \mid B \\A &\rightarrow C \\B &\rightarrow S \mid A \\C &\rightarrow S                 \end{aligned}</script><p>​    (b) 单位偶对有 $(A,A)$, $(B,B)$, $(C,C)$, $(S,S)$, $(A,C)$, $(A,S)$, $(A,B)$,<br>​    $(B,A)$, $(B,C)$, $(B,S)$, $(C,A)$, $(C,B)$, $(C,S)$, $(S,A)$, $(S,B)$, $(S,C)$.<br>​    消去单位产生式后得到新的产生式:</p><script type="math/tex; mode=display">\begin{aligned}S &\rightarrow 0A0 \mid 1B1 \mid BB \mid 00 \mid 11 \\A &\rightarrow 0A0 \mid 1B1 \mid BB \mid 00 \mid 11 \\B &\rightarrow 0A0 \mid 1B1 \mid BB \mid 00 \mid 11 \\C &\rightarrow 0A0 \mid 1B1 \mid BB \mid 00 \mid 11\end{aligned}</script><p>​    (c) $C$ 为无用符号.<br>​    (d) 消去无用符号 $C$ 得到新的产生式:</p><script type="math/tex; mode=display">\begin{aligned}S &\rightarrow 0A0 \mid 1B1 \mid BB \mid 00 \mid 11 \\A &\rightarrow 0A0 \mid 1B1 \mid BB \mid 00 \mid 11 \\B &\rightarrow 0A0 \mid 1B1 \mid BB \mid 00 \mid 11\end{aligned}</script><p>​    引入非终结符 $D$, $E$, 增加产生式 $D \rightarrow 0$ 和 $E \rightarrow 1$, 得产生式:</p><script type="math/tex; mode=display">\begin{aligned}S &\rightarrow DAD \mid EBE \mid BB \mid DD \mid EE \\A &\rightarrow DAD \mid EBE \mid BB \mid DD \mid EE \\B &\rightarrow DAD \mid EBE \mid BB \mid DD \mid EE \\D &\rightarrow 0 \\E &\rightarrow 1\end{aligned}</script><p>​    引入非终结符 $F$, $G$, 增加产生式 $F \rightarrow DA$ 和 $G \rightarrow EB$, 得到 $Chomsky$ 范式:</p><script type="math/tex; mode=display">\begin{aligned}S &\rightarrow FD \mid GE \mid BB \mid DD \mid EE \\A &\rightarrow FD \mid GE \mid BB \mid DD \mid EE \\B &\rightarrow FD \mid GE \mid BB \mid DD \mid EE \\D &\rightarrow 0 \\E &\rightarrow 1 \\F &\rightarrow DA \\G &\rightarrow EB\end{aligned}</script><h3 id="Ex-7-1-9-b"><a href="#Ex-7-1-9-b" class="headerlink" title="Ex 7.1.9 (b)"></a>Ex 7.1.9 (b)</h3><p>​    首先证明所得符号是可达符号, 对推导使用结构归纳:</p><p>​    $\circ$ 注意到 $S\in V\cup T$, 且 $S\Rightarrow^{*}S$，所以 $S$ 为可达符号;</p><p>​    $\circ$ 设 $A$ 为可达符号, 且有产生式 $A\rightarrow\alpha$, $X$ 是 $\alpha$ 中的符号.</p><p>​    $\circ$ 则 $X\in V\cup T$. 即存在 $\beta, \gamma\in(V\cup T)^{*}$, 使得 $\alpha = \beta X\gamma$, </p><p>​    即 $A\rightarrow\beta X\gamma$ 是一个产生式. 因 $A$ 是可达符号, 由归纳假设, </p><p>​    存在 $\beta’, \gamma’\in(V\cup T)^{<em>}$, 使得 $S\Rightarrow^{</em>} \beta’ A\gamma’$, 进而 $S\Rightarrow^{*} \beta’\beta X\gamma\gamma’$, 所以 $X$ 是可达符号.</p><p>​    再证所有的可达符号都可由上述步骤得到:</p><p>​    $\circ$ 设 $X$ 是可达符号, 即存在 $\beta, \gamma\in(V\cup T)^{<em>}$, 使得 $S\Rightarrow^{</em>} \beta X\gamma$.</p><p>​    归纳于该推导的步数 $n$:</p><p>​    $\circ$ 若 $n = 0$, 一定有 $\beta X\gamma = S$, 只有 $X = S$ 可由上述步骤产生;</p><p>​    $\circ$ 若 $n &gt; 0$, 假设最后一步推导是 $\beta’ A\gamma’\Rightarrow^{*}\beta X\gamma$, </p><p>​    并使用了产生式 $A\rightarrow\beta^{‘’}X\gamma^{‘’}$. 因为 $S\Rightarrow^{*}\beta’ A\gamma’$ 的步数小于 $n$,<br>​    根据归纳假设，符号 $A$ 可由上述步骤产生. 结合产生式 $A\rightarrow\beta^{‘’}X\gamma^{‘’}$, 知 $X$ 也可由上述步骤产生.</p><p> 证毕。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h2 id=&quot;必做题&quot;&gt;&lt;a href=&quot;#必做题&quot; class=&quot;headerlink&quot; title=&quot;必做题&quot;&gt;&lt;/a&gt;必做题&lt;/h2&gt;&lt;h3 id=&quot;Ex-7-1-3&quot;&gt;&lt;a href=&quot;#Ex-7-1-3&quot; class=&quot;headerlink&quot; title=&quot;Ex</summary>
        
      
    
    
    
    <category term="CS" scheme="http://chengsx21.github.io/categories/CS/"/>
    
    <category term="FL&amp;A" scheme="http://chengsx21.github.io/categories/CS/FL-A/"/>
    
    
    <category term="FL&amp;A" scheme="http://chengsx21.github.io/tags/FL-A/"/>
    
  </entry>
  
  <entry>
    <title>kth</title>
    <link href="http://chengsx21.github.io/2022/12/13/kth/"/>
    <id>http://chengsx21.github.io/2022/12/13/kth/</id>
    <published>2022-12-13T09:25:17.000Z</published>
    <updated>2023-09-21T17:13:18.367Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CST-PA4"><a href="#CST-PA4" class="headerlink" title="CST PA4"></a>CST PA4</h1><h2 id="4-3-Kth"><a href="#4-3-Kth" class="headerlink" title="4-3 Kth"></a>4-3 Kth</h2><h3 id="算法构思"><a href="#算法构思" class="headerlink" title="算法构思"></a>算法构思</h3><p>因为不能直接访问数组 <code>a</code>, <code>b</code>, <code>c</code> 中的元素, 我们定义数组 <code>u</code>, <code>v</code>, <code>w</code>, 将其初始化为 $\{1, 2, …, n\}$, 用于记录数组 <code>a</code>, <code>b</code>, <code>c</code> 中元素的 <code>index</code>.</p><p>将三元组视为三维空间中的点集, 我们需要返回点集之中坐标和第 <code>k</code> 小的三元组. 在 <code>compare</code> 接口中固定两维度 <code>index</code> 为 <code>1</code>, 我们可以比较单一维度的元素大小. 借此对三个数组分别进行快排, 排序结果反应在数组 <code>u</code>, <code>v</code>, <code>w</code> 中.</p><p>一般地, 若排序前数组 <code>u</code> 为 $\{1, 2, …, n\}$, 排序后为 $\{u[1], u[2], …, u[n]\}$, 即意味着数组 <code>a</code> 元素按大小升序排列为 $\{a[u[1]], a[u[2]], …, a[u[n]]\}$.</p><p>此时点集中坐标和最小的三元组即为 $a[u[1]], b[v[1]], c[w[1]]$. 我们维护一个最小堆 <code>MinHeap</code>, 将 $(1, 1, 1)$ 插入. 随后依次删除堆顶最小元组, 并插入坐标和恰好不小于删去堆顶坐标和的三元组.</p><p>第 <code>k</code> 次 <code>Delete</code> 得到的三元组 $(x, y, z)$ 对应的即是坐标和第 <code>k</code> 小的三元组 $a[u[x]], b[v[y]], c[w[z]]$.</p><p>对这个三维点集, 坐标和恰不小于 $(x, y, z)$ 的三元组必是 $(x, y, z + 1)$, $(x, y + 1, z)$, $(x + 1, y, z)$ 之一, 将其插入 <code>MinHeap</code> 即可. 考虑到同一个点可能会被压入多次, 调用 <code>k</code> 次 <code>Delete()</code> 后得到不是坐标和第 <code>k</code> 小的三元组, 特约定:</p><p>对于堆顶三元组 $(x, y, z)$, 我们插入 $(x, y, z + 1)$; 若 $z = 1$, 再插入 $(x, y + 1, z)$; 若 $y = z = 1$, 再插入 $(x + 1, y, z)$.</p><h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3><ul><li>在每次插入 $(x, y, z)$ 应该检查坐标是否合理, 否则会因非法插入, 使得 <code>compare</code> 函数报错.</li></ul><h3 id="复杂度估计"><a href="#复杂度估计" class="headerlink" title="复杂度估计"></a>复杂度估计</h3><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>对数组 <code>a</code>, <code>b</code>, <code>c</code> 进行快速排序, 时间复杂度为 $O(nlogn)$;</p><p>在维护 <code>MinHeap</code> 的过程中, 进行 <code>k</code> 次 <code>Delete</code>, 至多进行 <code>3k</code> 次 <code>Insert</code>, 时间复杂度为 $O(klogk)$.</p><p>综上, 算法总体时间复杂度为 $O(nlogn + klogk)$.</p><h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>数组 <code>u</code>, <code>v</code>, <code>w</code> 动态分配的空间为 $O(n)$, 堆 <code>MinHeap</code> 消耗的空间为 $O(k)$, 因此算法总体空间复杂度为 $O(n + k)$.</p><p>本题中直接在堆内开辟了相关大小的数组存储信息,</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// Line 13</span><span class="token keyword">class</span> <span class="token class-name">MinHeap</span> <span class="token punctuation">{</span> <span class="token comment">// 实现一个三元之和最小堆.</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">int</span> elem<span class="token punctuation">[</span><span class="token number">4000100</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>空间消耗最坏情况约为: $3\times 5\times 10^5 \times 4B + 1.2\times 10^7 \times 4B = 52MB &lt; 256MB$, 符合题目要求范围.</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;CST-PA4&quot;&gt;&lt;a href=&quot;#CST-PA4&quot; class=&quot;headerlink&quot; title=&quot;CST PA4&quot;&gt;&lt;/a&gt;CST PA4&lt;/h1&gt;&lt;h2 id=&quot;4-3-Kth&quot;&gt;&lt;a href=&quot;#4-3-Kth&quot;</summary>
        
      
    
    
    
    <category term="CS" scheme="http://chengsx21.github.io/categories/CS/"/>
    
    <category term="DSA" scheme="http://chengsx21.github.io/categories/CS/DSA/"/>
    
    
    <category term="DSA" scheme="http://chengsx21.github.io/tags/DSA/"/>
    
  </entry>
  
  <entry>
    <title>计算机系统概论 作业5</title>
    <link href="http://chengsx21.github.io/2022/12/10/ji-suan-ji-xi-tong-gai-lun-zuo-ye-5/"/>
    <id>http://chengsx21.github.io/2022/12/10/ji-suan-ji-xi-tong-gai-lun-zuo-ye-5/</id>
    <published>2022-12-10T09:25:01.000Z</published>
    <updated>2023-09-21T17:11:01.284Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hw-5"><a href="#Hw-5" class="headerlink" title="Hw 5"></a>Hw 5</h1><ol><li><p>对于如下代码: 请回答以下问题  </p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstdlib&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstdio&gt;</span></span><span class="token keyword">int</span> counter <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        counter<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"counter = %d\n"</span><span class="token punctuation">,</span> counter<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 注意: 这里没有 counter++;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"counter = %d\n"</span><span class="token punctuation">,</span> counter<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>1) 程序会输出多少行? (空行不计算在内)</p><p><strong>答:</strong> 会输出 10 行.</p><p>2) 程序第一行和最后一行分别会输出什么?</p><p><strong>答:</strong> 第一行输出 <code>counter = 1</code>; 最后一行输出 <code>counter = 2</code>.</p><p>3) 根据系统对进程的调度情况, 程序一共有多少种可能的输出结果? (如果同一时间有若干进程在同时运行, 他们运行的先后顺序的不同可能导致输出结果不同) </p><p><strong>答:</strong> 程序一共有 5 种可能的输出结果.</p><p>分别对应第一次 <code>fork</code> 的子线程在父线程 <code>4</code> 次 <code>counter = 2</code> 的输出之间.</p></li><li><p>对于如下代码:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;signal.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/wait.h&gt;</span></span><span class="token keyword">int</span> pid<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">handler</span><span class="token punctuation">(</span><span class="token keyword">int</span> sig<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span>sig <span class="token operator">==</span> SIGINT <span class="token operator">&amp;&amp;</span> pid <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Killing Child process\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">fflush</span><span class="token punctuation">(</span><span class="token constant">stdout</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">kill</span><span class="token punctuation">(</span>pid<span class="token punctuation">,</span> SIGKILL<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Child process receiving Kill\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">fflush</span><span class="token punctuation">(</span><span class="token constant">stdout</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">signal</span><span class="token punctuation">(</span>SIGINT<span class="token punctuation">,</span> handler<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">signal</span><span class="token punctuation">(</span>SIGKILL<span class="token punctuation">,</span> handler<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>pid<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> status<span class="token punctuation">;</span>        <span class="token function">waitpid</span><span class="token punctuation">(</span>pid<span class="token punctuation">,</span> <span class="token operator">&amp;</span>status<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">WEXITSTATUS</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"child's exit status=%d\n"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Waiting...!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">fflush</span><span class="token punctuation">(</span><span class="token constant">stdout</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在执行过程中, 如果用户按下 <code>Ctrl+C</code>, 请问程序在一串 <code>Waiting…!</code> 之后会输出什么内容, 为什么? </p><p><strong>答:</strong> 会输出:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Child process receiving KillKilling Child processchild's <span class="token builtin class-name">exit</span> <span class="token assign-left variable">status</span><span class="token operator">=</span><span class="token number">255</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><code>fork</code> 后在父进程内调用 <code>waitpid</code>, 父进程自身被挂起.</p><p>按下 <code>Ctrl+C</code> 后, 系统内核发送 <code>SIGINT</code> 信号至父进程与子进程, 子进程接收 <code>SIGINT</code> 信号, 其信号处理函数输出 <code>Child process receiving Kill</code>, 子进程退出. </p><p>随后父进程恢复, 接受 <code>SIGINT</code> 信号, 其信号处理函数输出 <code>Killing Child process</code>, 最后通过 <code>WEXITSTATUS</code> 获取子进程退出状态, 输出 <code>child's exit status=255</code>.</p></li><li><p>对于如下代码, 程序将输出什么内容, 为什么? (<code>foo.txt</code> 和 <code>bar.txt</code> 文件存在)</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> fd1<span class="token punctuation">,</span> fd2<span class="token punctuation">;</span>    fd1 <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"foo.txt"</span><span class="token punctuation">,</span> O_RDONLY<span class="token punctuation">)</span><span class="token punctuation">;</span>    fd2 <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"bar.txt"</span><span class="token punctuation">,</span> O_RDONLY<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">close</span><span class="token punctuation">(</span>fd2<span class="token punctuation">)</span><span class="token punctuation">;</span>    fd2 <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"bar.txt"</span><span class="token punctuation">,</span> O_RDONLY<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"fd2=%d\n"</span><span class="token punctuation">,</span> fd2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>答:</strong> 会输出 <code>fd2=4</code>.</p><p>进程创建时, <code>标准输入</code>, <code>标准输出</code>, <code>标准错误</code>已分别占用了描述符 <code>0</code>, <code>1</code>, <code>2</code>; 以只读方式打开文件 <code>foo.txt</code> 和 <code>bar.txt</code>, 可用描述符池分配 <code>fd1 = 3</code>, <code>fd2 = 4</code>; 关闭 <code>bar.txt</code> 后, 描述符 <code>4</code> 恢复到描述符池; 打开 <code>bar.txt</code> 后, 仍有 <code>fd2 = 4</code>.</p></li><li><p>在以下情形中, 分别需要使用什么 IO 方式来进行处理:</p><p>1) 编译器读取源文件  <strong>Standard IO.</strong></p><p>2) 编译器生成可执行文件  <strong>Standard IO.</strong></p><p>3) 处理图像文件  <strong>Standard  IO.</strong></p><p>4) 程序需要读写超大规模的文件，运行过程中可能需要处理外部信号  <strong>Unix IO.</strong></p><p>5) 访问网络内容  <strong>RIO.</strong></p></li></ol>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;Hw-5&quot;&gt;&lt;a href=&quot;#Hw-5&quot; class=&quot;headerlink&quot; title=&quot;Hw 5&quot;&gt;&lt;/a&gt;Hw 5&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;对于如下代码: 请回答以下问题  &lt;/p&gt;
&lt;pre class=&quot;line-numbers</summary>
        
      
    
    
    
    <category term="CS" scheme="http://chengsx21.github.io/categories/CS/"/>
    
    <category term="CSAPP" scheme="http://chengsx21.github.io/categories/CS/CSAPP/"/>
    
    
    <category term="CSAPP" scheme="http://chengsx21.github.io/tags/CSAPP/"/>
    
  </entry>
  
  <entry>
    <title>计算机系统概论 作业4</title>
    <link href="http://chengsx21.github.io/2022/12/08/ji-suan-ji-xi-tong-gai-lun-zuo-ye-4/"/>
    <id>http://chengsx21.github.io/2022/12/08/ji-suan-ji-xi-tong-gai-lun-zuo-ye-4/</id>
    <published>2022-12-08T09:24:55.000Z</published>
    <updated>2023-09-21T17:10:53.001Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hw4"><a href="#Hw4" class="headerlink" title="Hw4"></a>Hw4</h1><ol><li><p>某代码由 <code>foo.c</code> 与 <code>bar.c</code> 构成. 内容如下: </p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/* foo.c */</span> <span class="token keyword">void</span> <span class="token function">p2</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token function">p2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/* bar.c */</span> <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span> </span><span class="token keyword">extern</span> <span class="token keyword">char</span> main<span class="token punctuation">;</span> <span class="token keyword">void</span> <span class="token function">p2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"0x%x\n"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>main<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>( 具体取决于编译器实现 )</p><p>1) 请问能否正常联合编译? 如果可以联合编译则运行结果如何? 请说明你给出的回答的理由.</p><p><strong>答:</strong> 可以正常联合编译. 运行结果为编译后 <code>main()</code> 函数的地址. 因为 <code>main</code> 函数在 <code>bar.c</code> 中声明, 联合编译后 <code>p2()</code> 函数会输出变量 <code>main</code> 存储的值, 即编译后 <code>main()</code> 函数的地址.</p><p>2) 如果去掉 <code>bar.c</code> 中的 <code>extern</code> 关键字, 能否正常联合编译? 如果可以联合编译则运行结果如何? 请说明你给出的回答的理由. </p><p><strong>答:</strong> 可以正常联合编译. 运行结果为编译后 <code>main()</code> 函数的地址. (因为 <code>main</code> 为强定义, 会覆盖未初始化的弱定义 <code>char main</code>, 链接时不在乎类型.) 删去之后联合编译, 会在 <code>foo.c</code> 中得到其定义, 联合编译后 <code>p2()</code> 函数会输出 <code>main()</code> 函数的地址.</p></li><li><p>对于如下代码 <code>foo.c</code>, 如果编译为 <code>foo.o</code>, 那么在 <code>elf</code> 文件的以下段中, 会出现哪些符号? (如果有多种合法分布情况, 则任意给出一种即可).</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token number">3</span>   <span class="token keyword">extern</span> <span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token number">4</span><span class="token number">5</span>   <span class="token keyword">inline</span> <span class="token keyword">int</span> <span class="token function">process</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>v1<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>v2<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>v3<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token number">6</span>       <span class="token operator">*</span>v3 <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token operator">*</span>v1<span class="token punctuation">,</span> <span class="token operator">*</span>v2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token number">7</span>   <span class="token punctuation">}</span> <span class="token number">8</span> <span class="token number">9</span>   <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token number">10</span>  <span class="token keyword">extern</span> <span class="token keyword">int</span> b<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token number">11</span>  <span class="token keyword">static</span> <span class="token keyword">int</span> c<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token number">12</span> <span class="token number">13</span>  <span class="token keyword">int</span> <span class="token function">total_process</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token number">14</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token number">15</span>          <span class="token function">process</span><span class="token punctuation">(</span>a<span class="token operator">+</span>i<span class="token punctuation">,</span> b<span class="token operator">+</span>i<span class="token punctuation">,</span> c<span class="token operator">+</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token number">16</span>      <span class="token punctuation">}</span> <span class="token number">17</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>( <code>gcc</code> 的内联函数需为 <code>static inline</code>. )</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">.bss: a, b, c..data: 无. .text: total_process..symtab: add, process, a, b, c.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>其中对于 <code>total_process</code> 函数中用到的符号, 哪些会在编译期被定位, 哪些会在链接期被定位?</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">编译期定位的符号: i, total_process.链接期定位的符号: a, b, c.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>下面的问题涉及虚拟地址转换为物理地址</p><ul><li>内存是字节可寻址的  </li><li>内存访问是针对 <strong><code>1</code> 字节的字</strong>(即本题的 <code>word</code> 就是 <code>1</code> 个 <code>byte</code>)</li><li>虚拟地址 <code>16</code> 位宽 / 物理地址 <code>14</code> 位  </li><li>页面大小为 <code>1024</code> 字节  </li><li><code>TLB</code> 是 <code>4</code> 路组相联 (<code>4-way set associative</code>), 共有 <code>16</code> 个表项  </li></ul><p>在下表中, 所有数字都是十六进制的. 前 <code>32</code> 页的 <code>TLB</code> 和页表内容如下：</p><p><img src="D:/Shortcut/Class/22%20%E7%A7%8B/CSAPP/Homework/Hw/pic/4.png" alt=""></p><p>1) 下面的框显示了虚拟地址的格式. 指出字段用于确定以下内容: VPO / VPN / TLBI / TLBT/</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">VPN: <span class="token number">15</span> - <span class="token number">10</span>VPO: <span class="token number">9</span> - <span class="token number">0</span>TLBI: <span class="token number">11</span> - <span class="token number">10</span>TLBT: <span class="token number">15</span> - <span class="token number">12</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>类似的标注出物理地址的格式: PPO / PPN </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">PPN: <span class="token number">13</span> - <span class="token number">10</span>PPO: <span class="token number">9</span> - <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>2) 对于给定的两个虚拟地址 (<code>0x2F09</code>、<code>0x0C53</code>), 请分别表示出相应的 <code>TLB</code> 表项和物理地址, 并指出 <code>TLB</code> 是否命中、是否发生 <code>page fault</code>. 如 <code>page fault</code>, 请在 <code>PPN</code> 中输入 <code>-</code>, <code>C</code> 部分留白.</p><p><strong>答:</strong></p><p><strong>0x2F09:</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">A:    Virtual Address:    0010 <span class="token number">1111</span> 0000 <span class="token number">1001</span>B:    VPN: 0x0B    TLB Index: 0x3    TLB Tag:0x2    TLB Hit: No <span class="token punctuation">(</span>注意这个 Hit<span class="token operator">!</span><span class="token punctuation">)</span>    Page Fault: Yes    PPN: -C:    Physical Address:    留白.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>0x0C53:</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">A:    Virtual Address:    0000 <span class="token number">1100</span> 0101 0011B:    VPN: 0x03    TLB Index: 0x3    TLB Tag:0x0    TLB Hit: Yes    Page Fault: No    PPN: 0xDC:    Physical Address:    <span class="token number">11</span> 0100 0101 0011<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>程序运行之前需要为程序分配对应的内存空间, 并为内存空间赋予一定的初始值和属性, 下表为 <code>x86</code> 架构下用户空间的内存映射关系. 请填写下表, 并说明可执行文件对应的段 (<code>.data</code>, <code>.bss</code>, <code>.init</code>, <code>.rodata</code>, <code>.text</code>) 段分别会被以什么属性映射到哪部分内存空间中.</p><p>|     内存起始地址     |       内存类型       |                内存初始值                 |   内存属性   |<br>| :—————————: | :—————————: | :———————————————————-: | :—————: |<br>|      0xFFFFFFFF      |       内核地址       |                 系统决定                  | 不可读不可写 |<br>|      0xC0000000      |          栈          |                <strong>0(默认)</strong>                | <strong>可读可写</strong> |<br>| <strong>由可执行文件决定</strong> | <strong>共享库内存映射区</strong> |      <strong>共享库文件与可执行文件决定</strong>       |   <strong>只读</strong>   |<br>|      0x40000000      |     运行时堆空间     |             <strong>操作系统决定</strong>              | <strong>可读可写</strong> |<br>|   由可执行文件决定   |   <strong>可读写数据段</strong>   | .<strong>data由可执行文件决定, <br>.bss为 0</strong> |   可读可写   |<br>| <strong>由可执行文件决定</strong> |     <strong>只读数据</strong>     |            <strong>可执行文件决定</strong>             |   <strong>只读</strong>   |<br>|      0x08048000      |     保留内存地址     |                                           |              |</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">.data:  可读可写  映射到可读写数据段..bss:  可读可写  映射到可读写数据段..text:  只读  映射到只读数据.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ol>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;Hw4&quot;&gt;&lt;a href=&quot;#Hw4&quot; class=&quot;headerlink&quot; title=&quot;Hw4&quot;&gt;&lt;/a&gt;Hw4&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;某代码由 &lt;code&gt;foo.c&lt;/code&gt; 与 &lt;code&gt;bar.c&lt;/code&gt; 构成. 内容如下:</summary>
        
      
    
    
    
    <category term="CS" scheme="http://chengsx21.github.io/categories/CS/"/>
    
    <category term="CSAPP" scheme="http://chengsx21.github.io/categories/CS/CSAPP/"/>
    
    
    <category term="CSAPP" scheme="http://chengsx21.github.io/tags/CSAPP/"/>
    
  </entry>
  
  <entry>
    <title>Circuit</title>
    <link href="http://chengsx21.github.io/2022/12/05/circuit/"/>
    <id>http://chengsx21.github.io/2022/12/05/circuit/</id>
    <published>2022-12-05T09:24:09.000Z</published>
    <updated>2023-09-21T17:12:38.961Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CST-PA4"><a href="#CST-PA4" class="headerlink" title="CST PA4"></a>CST PA4</h1><h2 id="4-1-Circuit"><a href="#4-1-Circuit" class="headerlink" title="4-1 Circuit"></a>4-1 Circuit</h2><h3 id="算法构思"><a href="#算法构思" class="headerlink" title="算法构思"></a>算法构思</h3><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p>本题需使用 <code>Trie Tree</code> 数据结构, 关于 <code>Trie Tree</code> 的介绍可参考<a href="https://zh.wikipedia.org/zh-hans/Trie">此篇文章</a>. 因为涉及的字符仅为 <code>0</code>, <code>1</code>, 因此实质上相当于一棵 <code>Binary Tree</code>.</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// Line 7</span>ull str<span class="token punctuation">[</span><span class="token number">500500</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> ans<span class="token punctuation">[</span><span class="token number">500500</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>使用 <code>unsigned long long str[]</code> 数组储存 <code>01</code> 串, 不断更改当前的查询串编号, 将超出区间的串从 <code>Trie Tree</code> 中删去, 进入区间的串添加到 <code>Trie Tree</code> 中, 得到的结果存储在 <code>int ans[]</code> 中.</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// Line 14</span><span class="token keyword">class</span> <span class="token class-name">node</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> son<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span> trie<span class="token punctuation">[</span><span class="token number">32001000</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因此 <code>Trie Tree</code> 中的串至多为 <code>500000</code> 个, <code>Trie Tree</code> 中的节点至多为 <code>500000 * 64 = 32000000</code> 个. 在节点内部维护其左右子节点 <code>son[0]</code>, <code>son[1]</code>, 并记录经过该节点的 <code>01</code> 串数 <code>cnt</code>.</p><h4 id="void-ReadAll"><a href="#void-ReadAll" class="headerlink" title="void ReadAll()"></a>void ReadAll()</h4><p>使用 <code>getchar()</code> 逐字符读入所给串, 计算其二进制值并存储为 <code>unsigned long long</code>.</p><h4 id="void-Insert"><a href="#void-Insert" class="headerlink" title="void Insert()"></a>void Insert()</h4><p>定义全局变量 <code>pointer</code> 记录下一个将被利用的节点编号.</p><p>对于一个 <code>unsigned long long</code> 存储的 <code>01</code> 串, 从根节点 <code>trie[0]</code> 开始从高到低逐位读取其各位数值, 为 <code>0</code> 则转向当前节点左孩子, 为 <code>1</code> 则转向当前节点右孩子. 若子节点存在, 则相应 <code>cnt++</code>; 若子节点为空, 则用 <code>trie[pointer]</code> 对其初始化, 并 <code>cnt++</code>.</p><p>当读入 <code>01</code> 串最后一位, 到达叶节点时, 直接将对应 <code>01</code> 串的编号存储在叶节点的 <code>cnt</code> 中.</p><h4 id="void-Remove"><a href="#void-Remove" class="headerlink" title="void Remove()"></a>void Remove()</h4><p>对于一个 <code>unsigned long long</code> 存储的 <code>01</code> 串, 按照同样过程在 <code>Trie Tree</code> 中访问其各个节点, 对应 <code>cnt--</code>. 若 <code>cnt</code> 减少到 <code>0</code>, 直接将其父节点的子节点标记置为 <code>0</code>, 以该节点为根的子树在之后都不会被访问.</p><h4 id="int-Query"><a href="#int-Query" class="headerlink" title="int Query()"></a>int Query()</h4><p>为了获得最大异或和, 在树上的每一步向下移动都尝试向着与所给串相反的方向进行即可.</p><h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3><ul><li>按照编号从下往上扫描序列, 向 <code>Trie Tree</code> 中插入字符串, 靠前字符串编号会覆盖靠后字符串编号, 查询时即可输出最靠前序列编号.</li><li>特别地, 若所有 <code>01</code> 串均相同, 那么 <code>Trie Tree</code> 退化为一条单链. 此时唯一叶节点会在最后被串 <code>0</code> 标记覆盖, <code>Query(0)</code> 返回 <code>0</code>, 只需将其单独改为 <code>1</code> 即可.</li></ul><h3 id="复杂度估计"><a href="#复杂度估计" class="headerlink" title="复杂度估计"></a>复杂度估计</h3><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>对每个 <code>01</code> 串进行 <code>Insert</code>, <code>Remove</code>, <code>Query</code> 的时间复杂度均为 $O(1)$, 而每个串至多进行 <code>Insert</code>, <code>Remove</code>, <code>Query</code> 各一次.</p><p>综上, 算法总体时间复杂度为 $O(64n)$.</p><h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>插入的串至多产生64n个节点，而每个节点只维护了左节点、右节点、经过次数（叶节点单位值）这三个信息，因此空间复杂度为O(64n)，常数上限为3倍。</p><p>其他数组均为500050大小，相对花销较小。</p><p>本体空间复杂度取决于 <code>01</code>串数 <code>n</code>, 最多在 <code>Trie Tree</code> 中产生 $64n$ 个节点. 题解中使用 <code>trie[]</code>, <code>str[]</code> 与 <code>ans[]</code> 数组模拟了一棵 <code>Trie Tree</code>, 最坏情况下整体需要的空间为 $O(64n)$.</p><p>本题中直接开辟了相关大小的数组存储信息,</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">// Line 7</span>ull str<span class="token punctuation">[</span><span class="token number">500500</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> ans<span class="token punctuation">[</span><span class="token number">500500</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">// Line 14</span><span class="token keyword">class</span> <span class="token class-name">node</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> son<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span> trie<span class="token punctuation">[</span><span class="token number">32001000</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>空间消耗最坏情况约为: $5\times 10^5 \times 8B + 5\times 10^5 \times 4B + 3.2\times 10^7 \times 12B = 372MB &lt; 512MB$, 符合题目要求范围.</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;CST-PA4&quot;&gt;&lt;a href=&quot;#CST-PA4&quot; class=&quot;headerlink&quot; title=&quot;CST PA4&quot;&gt;&lt;/a&gt;CST PA4&lt;/h1&gt;&lt;h2 id=&quot;4-1-Circuit&quot;&gt;&lt;a href=&quot;#4-1-Circuit&quot;</summary>
        
      
    
    
    
    <category term="CS" scheme="http://chengsx21.github.io/categories/CS/"/>
    
    <category term="DSA" scheme="http://chengsx21.github.io/categories/CS/DSA/"/>
    
    
    <category term="DSA" scheme="http://chengsx21.github.io/tags/DSA/"/>
    
  </entry>
  
  <entry>
    <title>形式语言与自动机 作业8</title>
    <link href="http://chengsx21.github.io/2022/12/02/xing-shi-yu-yan-yu-zi-dong-ji-zuo-ye-8/"/>
    <id>http://chengsx21.github.io/2022/12/02/xing-shi-yu-yan-yu-zi-dong-ji-zuo-ye-8/</id>
    <published>2022-12-02T09:22:38.000Z</published>
    <updated>2023-09-21T17:12:01.029Z</updated>
    
    <content type="html"><![CDATA[<h2 id="必做题"><a href="#必做题" class="headerlink" title="必做题"></a>必做题</h2><h3 id="Ex-6-4-2-c"><a href="#Ex-6-4-2-c" class="headerlink" title="Ex 6.4.2 (c)"></a>Ex 6.4.2 (c)</h3><p>​    构造以终态方式接受的 $DPDA$ </p><p><img src="/pic/43.png" alt=""></p><h3 id="Ex-6-4-3-a"><a href="#Ex-6-4-3-a" class="headerlink" title="Ex 6.4.3 (a)"></a>Ex 6.4.3 (a)</h3><p>​    假设以空栈方式接受的 $DPDA$ $P$ 接受串 $w\in L$, 考虑 $x\ne\varepsilon$.</p><p>​    那么我们存在状态 $q$,<br>​    <script type="math/tex">(q_0, wx, Z_0)\vdash^{*}(q, x, \varepsilon).</script><br>​    此时栈已空, 即 $DPDA$ 不能继续转移, 从而 $P$ 不能接受 $wx$.</p><p>​    即 $DPDA$ $P$ 接受的语言 $L$ 具有前缀性质.</p><h3 id="Ex-6-4-3-b"><a href="#Ex-6-4-3-b" class="headerlink" title="Ex 6.4.3 (b)"></a>Ex 6.4.3 (b)</h3><p>​    从 $P$ 构造以终态方式接受的 $DPDA$ $P’$:</p><p>​    (1) 增加初始状态 $q_0’$ 和初始栈符 $Z_0’$, 增加转移<br>​    <script type="math/tex">\delta(q_0', \varepsilon, Z_0') = \{(q_0, Z_0Z_0')\}.</script><br>​    其中 $q_0$, $Z_0$ 为 $P$ 的初始状态和初始栈符.</p><p>​    (2) 增加终止状态 $q_f’$, 对 $P$ 中每一状态 $q$ 增加转移<br>​    <script type="math/tex">\delta(q, \varepsilon, Z_0') = \{(q_f', Z_0')\}.</script><br>​    由于 $P’$ 经过一步推导进入 $P$, $P$ 是确定的, </p><p>​    并且 $P’$ 进行推导的第一步和最后一步是确定的,</p><p>​    从而 $P’$ 是一个以终态方式接受的 $DPDA$.</p><h3 id="Ex-6-4-3-c"><a href="#Ex-6-4-3-c" class="headerlink" title="Ex 6.4.3 (c)"></a>Ex 6.4.3 (c)</h3><p>​    从 $P’$ 构造以空栈方式接受的 $DPDA$ $P$:</p><p>​    (1) 增加初始状态 $q_0$ 和初始栈符 $Z_0$, 增加转移<br>​    <script type="math/tex">\delta(q_0, \varepsilon, Z_0) = \{(q_0', Z_0'Z_0)\}.</script><br>​    其中 $q_0’$, $Z_0’$ 为 $P’$ 的初始状态和初始栈符.</p><p>​    (2) 增加状态 $q$, 对 $P’$ 中所有接受状态 $q’$ 和栈符号 $Z’$, 增加转移</p><script type="math/tex; mode=display">\begin{aligned}\delta(q', \varepsilon, Z') &= \{(q, \varepsilon)\}, \\\delta(q, \varepsilon, Z') &= \{(q, \varepsilon)\}.\end{aligned}</script><p>​    从而 $P$ 是一个以空栈方式接受的 $PDA$, $L(P) = L$.</p><p>​    由于 $L$ 具有前缀性质, 因此 $P$ 具有确定性.</p><p>​    从而 $P$ 是一个以空栈方式接受的 $DPDA$.</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h2 id=&quot;必做题&quot;&gt;&lt;a href=&quot;#必做题&quot; class=&quot;headerlink&quot; title=&quot;必做题&quot;&gt;&lt;/a&gt;必做题&lt;/h2&gt;&lt;h3 id=&quot;Ex-6-4-2-c&quot;&gt;&lt;a href=&quot;#Ex-6-4-2-c&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    <category term="CS" scheme="http://chengsx21.github.io/categories/CS/"/>
    
    <category term="FL&amp;A" scheme="http://chengsx21.github.io/categories/CS/FL-A/"/>
    
    
    <category term="FL&amp;A" scheme="http://chengsx21.github.io/tags/FL-A/"/>
    
  </entry>
  
</feed>
