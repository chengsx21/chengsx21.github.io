<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Endeavor</title>
  
  <subtitle>狂歌痛饮 来访雁丘处</subtitle>
  <link href="http://chengsx21.github.io/atom.xml" rel="self"/>
  
  <link href="http://chengsx21.github.io/"/>
  <updated>2023-09-27T13:13:25.610Z</updated>
  <id>http://chengsx21.github.io/</id>
  
  <author>
    <name>Chengsx</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>计算机组成原理 笔记4</title>
    <link href="http://chengsx21.github.io/2023/10/02/systemverilog-shi-li/"/>
    <id>http://chengsx21.github.io/2023/10/02/systemverilog-shi-li/</id>
    <published>2023-10-02T09:18:57.000Z</published>
    <updated>2023-09-27T13:13:25.610Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SystemVerilog实例"><a href="#SystemVerilog实例" class="headerlink" title="SystemVerilog实例"></a>SystemVerilog实例</h1><blockquote><p><span class="github-emoji"><span>❓</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2753.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> A Hard Journey…</p></blockquote><h2 id="加法器"><a href="#加法器" class="headerlink" title="加法器"></a>加法器</h2><h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>实现一个 2 位加法器: 输入两个非负整数, 输出这两个数的和.</p><p>输入: </p><ol><li><code>a</code>: 宽度为 2, 表示输入的第一个非负整数;</li><li><code>b</code>: 宽度为 2, 表示输入的第二个非负整数.</li></ol><p>输出: </p><ol><li><code>c</code>: 宽度为 2, 表示 <code>a + b</code>, 溢出的部分舍弃.</li></ol><h3 id="电路"><a href="#电路" class="headerlink" title="电路"></a>电路</h3><p>对于这一类<strong>输出仅随着输入变化而变化</strong>的信号, 通常使用<strong>组合逻辑</strong>来实现. 特点是输出完全依赖于输入, 没有内部状态, 和时间无关. </p><p>根据真值表, 可以得到输出与输入的关系 (<code>a_0</code> 表示 <code>a</code> 的最低位). 电路图如下: </p><p><img src="/pic/193.svg" alt=""></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>实际上直接写 <code>a + b</code> 就可以了, EDA 工具会自动完成逻辑转换. </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> add2 <span class="token punctuation">(</span>  <span class="token keyword">input</span> <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span>  <span class="token keyword">input</span> <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> b<span class="token punctuation">,</span>  <span class="token keyword">output</span> <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">assign</span> c <span class="token operator">=</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一个很容易犯的错误是在 <code>output wire [1:0] c</code> 后面多写了一个逗号. 不要把这里的 <code>assign c = a + b</code> 理解为赋值, 而是把它看成信号的连接: 通过一系列的逻辑门, 计算得到 <code>a + b</code> 的结果, 再把结果连接到输出信号 <code>c</code> 上.</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>回顾上面的电路, 最大的特点是<strong>输入一变化, 输出就跟着变</strong>, 并且与时间无关, 这种电路称为<strong>组合电路</strong> (<strong>组合逻辑电路</strong>). </p><h2 id="按钮开关"><a href="#按钮开关" class="headerlink" title="按钮开关"></a>按钮开关</h2><h3 id="需求-1"><a href="#需求-1" class="headerlink" title="需求"></a>需求</h3><p>实现一个控制台灯的按钮开关: 按下开关的时候, 灯会亮起来; 再次按下开关的时候, 灯就熄灭了. </p><p>输入: </p><ol><li><code>button</code>: 1 表示按钮被按下, 0 表示按钮处于弹起状态.</li></ol><p>输出: </p><ol><li><code>light</code>: 1 表示灯亮起, 0 表示灯熄灭.</li></ol><h3 id="电路-1"><a href="#电路-1" class="headerlink" title="电路"></a>电路</h3><p><code>light</code> 输出与它本身的历史状态有关, 并且正好是取反的关系. 如果依然采用组合逻辑来实现, 写出形如 <code>light &lt;= ~light;</code> 的代码, 对应的电路就出现了环路, 此时 <code>light</code> 会不断在 <code>0</code> 和 <code>1</code> 之间震荡.</p><p>这一类<strong>输出与历史状态相关</strong>, 并且<strong>输出在某个信号的上升沿变化</strong>的信号, 通常使用<strong>时序逻辑</strong>来实现. 把 <code>button</code> 连接到触发器的 <code>C</code> 端口, 就实现了上升沿触发的目的; 为了实现每次触发, 让输出的结果取反, 可以把触发器的 <code>Q</code> 经过一个非门再连接到触发器的 <code>D</code> 端口: </p><p><img src="/pic/194.svg" alt=""></p><p>这个电路也成了一个环, 引入触发器的作用, 使得只有在时钟上升沿时, 触发器的输入 D 会引发输出 Q 的变化, 而当时钟上升沿结束以后, 输出 Q 也许会导致输入 D 变化, 但是输出 Q 是稳定不变的, 因此不会出现循环振荡. </p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><p>时序逻辑里, 需要显式的声明一个寄存器 (对应电路里的触发器), 并<strong>严格</strong>把信号<strong>连接</strong>到触发器的输入 D 端口. </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> button <span class="token punctuation">(</span>  <span class="token keyword">input</span> <span class="token keyword">wire</span> button<span class="token punctuation">,</span>  <span class="token keyword">output</span> <span class="token keyword">wire</span> light<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">logic</span> light_reg<span class="token punctuation">;</span><span class="token keyword">assign</span> light <span class="token operator">=</span> light_reg<span class="token punctuation">;</span>  <span class="token important">always_ff @</span> <span class="token punctuation">(</span><span class="token keyword">posedge</span> button<span class="token punctuation">)</span> <span class="token keyword">begin</span>  light_reg <span class="token operator">&lt;=</span> <span class="token operator">~</span>light_reg<span class="token punctuation">;</span><span class="token keyword">end</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要显式声明一个触发器, 称为 <code>light_reg</code>, 然后采用 <code>assign light = light_reg</code> 语句把触发器的输出 Q 端口连接到输出信号 <code>light</code> 上. 接下来实现 <code>light_reg</code> 在 <code>button</code> 上升沿时, 将当前的值取反.</p><p>这里把 <code>light_reg</code> 的输出 Q 经过非门连接到 <code>light_reg</code> 的输入 D 中. 换句话说, 出现在 <code>&lt;=</code> 右侧的都是触发器的输出 Q 端口, 而出现在 <code>&lt;=</code> 左侧的都是触发器的输入 D 端口. 这里的 <code>&lt;=</code> 要理解为信号的连接, 而不是软件编程中的赋值.</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>时序逻辑电路和组合逻辑电路最大的区别在于可以<strong>记录历史, 并且在一定的条件 (输入信号 C 的上升沿) 下触发更新</strong> . 根据这个特点, 我们就可以保存状态, 在上升沿事件的“带领”下更新内部状态.</p><h2 id="秒表"><a href="#秒表" class="headerlink" title="秒表"></a>秒表</h2><h3 id="需求-2"><a href="#需求-2" class="headerlink" title="需求"></a>需求</h3><p>设计一个秒表: 输出一个数字, 每秒加一; 按下复位按钮恢复到零. </p><p>输入: </p><ol><li><code>reset</code>: 1 表示复位按钮被按下, 需要清零; 0 表示不需要清零.</li><li><code>clock</code>: 频率为 1MHz 的时钟.</li></ol><p>输出: </p><ol><li><code>timer</code>: 4 位的数字, 表示目前经过的秒数.</li></ol><p>为了实现秒表, 需要外部的时钟连接到电路的输入 <code>clock</code> 中, 可以在内部逻辑中, 每一次时钟上升沿给计数器加一, 当计数器加到 1,000,000 次就知道经过了 1s 时间. </p><h3 id="波形"><a href="#波形" class="headerlink" title="波形"></a>波形</h3><p>秒表每秒输出都会加一, 说明内部需要保存状态, 需要用<strong>时序逻辑</strong>来实现这一部分功能. 可以用一个寄存器 <code>timer_reg</code> 来保存当前的秒数, 把寄存器的输出连接到 <code>timer</code> 输出上, 只要保证每 1s 中让 <code>timer_reg</code> 加一即可. </p><p>如何实现每 1s 让 <code>timer_reg</code> 加一? 上面引入了一个频率为 1MHz 的时钟, 每 1us 都有一次时钟上升沿, 为了记忆经过了多少次上升沿又是一个状态, 用一个寄存器 <code>counter_reg</code> 来保存当前经过了多少次上升沿.</p><p>每次上升沿 <code>counter_reg</code> 加一, 当加到 1,000,000 时给 <code>timer_reg</code> 加一, 同时让 <code>counter_reg</code> 恢复到 0, 这样就实现了秒表的计时功能. </p><p>需求里面的复位按钮有两种实现方法: </p><ol><li>按下按钮, 输出变成 0, 符合输入一变输出立即跟着变的特点, 所以可以用<strong>组合逻辑</strong> 实现: <code>timer = reset ? 0 : timer_reg</code>; 在时钟上升沿, 如果发现 <code>reset == 1</code>, 设置 <code>timer_reg = 0</code> 和 <code>counter_reg = 0</code>, 松开按钮时会从 0 开始计时. </li><li>按下按钮, 在时钟上升沿如果发现 <code>reset == 1</code>, 就设置 <code>timer_reg = 0</code> 和 <code>counter_reg = 0</code>; 从下一个周期开始, 输出的 <code>timer = timer_reg</code> 就变成了 0.</li></ol><h3 id="电路-2"><a href="#电路-2" class="headerlink" title="电路"></a>电路</h3><p>两组寄存器 <code>timer_reg</code> 和 <code>counter_reg</code>. <code>counter_reg</code> 在每个 <code>clock</code> 上升沿进行更新, <code>timer_reg</code> 在每个 <code>clock</code> 的上升沿进行更新, 这些 “可能” 在电路上对应用组合逻辑实现的选择器. 最后把 <code>timer_reg</code> 的输出连接到 <code>timer</code> 输出即可.</p><p><img src="/pic/195.svg" alt=""></p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> timer <span class="token punctuation">(</span>  <span class="token keyword">input</span> <span class="token keyword">wire</span> clock<span class="token punctuation">,</span>  <span class="token keyword">input</span> <span class="token keyword">wire</span> reset<span class="token punctuation">,</span>  <span class="token keyword">output</span> <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> timer<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">logic</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> timer_reg<span class="token punctuation">;</span>  <span class="token keyword">logic</span> <span class="token punctuation">[</span><span class="token number">19</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> counter_reg<span class="token punctuation">;</span>  <span class="token comment">// sequential</span>  <span class="token important">always_ff @</span> <span class="token punctuation">(</span><span class="token keyword">posedge</span> clock<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>reset<span class="token punctuation">)</span> <span class="token keyword">begin</span>      timer_reg <span class="token operator">&lt;=</span> <span class="token number">4'b0</span><span class="token punctuation">;</span>      counter_reg <span class="token operator">&lt;=</span> <span class="token number">20'b0</span><span class="token punctuation">;</span>    <span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token keyword">begin</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>counter_reg <span class="token operator">==</span> <span class="token number">20'd999999</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>        timer_reg <span class="token operator">&lt;=</span> timer_reg <span class="token operator">+</span> <span class="token number">4'b1</span><span class="token punctuation">;</span>        counter_reg <span class="token operator">&lt;=</span> <span class="token number">20'b0</span><span class="token punctuation">;</span>      <span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token keyword">begin</span>        counter_reg <span class="token operator">&lt;=</span> counter_reg <span class="token operator">+</span> <span class="token number">20'b1</span><span class="token punctuation">;</span>      <span class="token keyword">end</span>    <span class="token keyword">end</span>  <span class="token keyword">end</span>  <span class="token comment">// combinatorial</span>  <span class="token keyword">assign</span> timer <span class="token operator">=</span> timer_reg<span class="token punctuation">;</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来按照上面的思路来实现 <code>timer_reg</code> 和 <code>counter_reg</code> 的逻辑. 由于二者的判断是类似的, 可以直接合并起来. 上面的代码中, 语义上是<strong>当 XX 条件发生时, 向 YY 寄存器写入 ZZ</strong>, 实际电路则是 <code>ZZ &lt;= XX ? YY : ZZ</code>, 如果所有写入的条件都不满足, 则保留原来的状态.</p><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>经过这个例子, 我们学会了如何用 <code>if-then-else</code> 的方式更新寄存器, 而不用手动去写 <code>ZZ = XX ? YY : ZZ</code> 的代码.</p><h2 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h2><h3 id="需求-3"><a href="#需求-3" class="headerlink" title="需求"></a>需求</h3><p>设计一个计数器: 一个计数按钮, 每按一次计数加一; 一个复位按钮, 按下时计数恢复到零; 同时输出两位十进制的数, 显示目前按了多少次计数按钮. </p><p>输入信号: </p><ol><li><code>clock</code>: 频率为 1MHz 的时钟.</li><li><code>reset</code>: 1 表示复位按钮被按下, 0 表示没有按下.</li><li><code>button</code>: 1 表示计数按钮被按下, 0 表示没有按下.</li></ol><p>输出信号: </p><ol><li><code>ones</code>: 输出次数的个位数, 4 位.</li><li><code>tens</code>: 输出次数的十位数, 4 位.</li></ol><h3 id="波形-1"><a href="#波形-1" class="headerlink" title="波形"></a>波形</h3><p>能否在 <code>button</code> 的时钟上升沿触发, 让寄存器加一? 由于按钮的本身特性, 按下按钮的几 ms 内是不稳定的, 不断在 <code>0</code> 和 <code>1</code> 之间抖动, 最后才趋向稳定. </p><p>为了消除这个抖动的影响 (Debounce), 可以记录最近若干次 <code>button</code> 的历史值, 如果连续一段时间都处于一个固定的值, 可以认为按钮处于这个状态.</p><p>计数器是一个内部状态, 需要用寄存器来实现. 能否把去抖以后的信号作为时钟信号来驱动? 如果可能的话, 尽量减少用非时钟信号作为上边沿触发, <strong>尽量把相关的时序逻辑都放在同一个时钟域中</strong>. 如果涉及不同时钟域之间的信号处理, 之后会介绍一些用于实现跨时钟域 (CDC) 的正确电路实现方法. <strong>建议只用一个时钟, 让这个时钟驱动所有的寄存器</strong>. </p><p>可以在时钟的上升沿来检测 <code>button_debounced</code> 从 <code>0</code> 变成了 <code>1</code>, 具体思路是: </p><ol><li>设置一个寄存器 <code>button_debounced_delay</code>, 相对 <code>button_debounced</code> 有一个周期的延迟;</li><li>当 <code>button_debounced == 1</code> 且 <code>button_debounced_delay == 0</code> 时, 就检测到了一个从 <code>0</code> 变成 <code>1</code> 的过程, 对计数器加一. </li></ol><h3 id="电路-3"><a href="#电路-3" class="headerlink" title="电路"></a>电路</h3><h4 id="模块化设计"><a href="#模块化设计" class="headerlink" title="模块化设计"></a>模块化设计</h4><p>代码主要有两部分, 一部分是消抖, 一部分是计数和输出逻辑. 消抖逻辑比较独立, 可以拆出来做成一部分电路, 然后连接到计数和输出逻辑部分.</p><p>消抖模块 (Debouncer) : </p><p>输入: </p><ol><li><code>clock</code>: 频率为 1MHz 的时钟.</li><li><code>reset</code>: 1 表示复位按钮被按下, 0 表示没有按下.</li><li><code>button</code>: 1 表示计数按钮被按下, 0 表示没有按下.</li></ol><p>输出: </p><ol><li><code>button_debounced</code>: 消抖后的计数按钮信号, 高有效.</li></ol><p>计数模块 (Counter) : </p><p>输入: </p><ol><li><code>clock</code>: 频率为 1MHz 的时钟.</li><li><code>reset</code>: 1 表示复位按钮被按下, 0 表示没有按下.</li><li><code>button_debounced</code>: 消抖后的计数按钮信号, 高有效.</li></ol><p>输出: </p><ol><li><code>ones</code>: 输出次数的个位数, 4 位.</li><li><code>tens</code>: 输出次数的十位数, 4 位.</li></ol><p><img src="/pic/196.svg" alt=""></p><h4 id="消抖模块"><a href="#消抖模块" class="headerlink" title="消抖模块"></a>消抖模块</h4><p>需要记录下历史输入, 才可以判断是否 10,000 个周期都保持稳定. 用 10,000 个 1 位的寄存器有些浪费, 可以用一个寄存器来记录目前稳定了多少个周期. </p><ol><li>寄存器 <code>last_button_reg</code> 记录上一个周期 <code>button</code>.</li><li>寄存器 <code>counter_reg</code> 用来保存一个计数, 当 <code>button == last_button_reg</code> 时, 说明 <code>button</code> 保持稳定, 那么 <code>counter_reg = counter_reg + 1</code>; 否则清零重新计数</li><li>寄存器 <code>button_debounced_reg</code> 保存当前输出的消抖结果, 当 <code>counter_reg = 10000</code> 的时候, 更新 <code>button_debounced_reg = last_button_reg</code>. </li></ol><p>最后把 <code>button_debounced_reg</code> 连接到 <code>button_debounced</code> 输出. </p><h4 id="计数模块"><a href="#计数模块" class="headerlink" title="计数模块"></a>计数模块</h4><p>接收来自消抖模块的输出 <code>button_debounced</code>, 检测到从 <code>0</code> 变成 <code>1</code> 的时候计数器加一. 能不能用一个完整的寄存器保存计数, 输出设置 <code>ones = counter_reg % 10</code> 和 <code>tens = counter_reg / 10</code>? 不建议, 因为除法和取模运算会耗费大量的逻辑门, 并且延迟比较大. 如果位数更多, 产生的电路复杂度和延迟可能是不可接受的. 考虑到这里每次对 <code>counter_reg</code> 的操作只有加一和清零, 可以添加 <code>ones_reg</code> 和 <code>tens_reg</code> 寄存器, 实现加一和清零的操作, 并且手动处理进位.</p><p>用一个寄存器检测按下的计数按钮, 即 <code>button_debounced</code> 从 <code>0</code> 变成 <code>1</code>: </p><ol><li>寄存器 <code>button_debounced_reg</code> 保存上一周期的 <code>button_debounced</code>.</li><li>如果 <code>button_debounced == 1 &amp;&amp; button_debounced_reg == 0</code>, 说明检测到了从 <code>0</code> 变成了 <code>1</code>.</li></ol><p>最后是 <code>ones_reg</code> 和 <code>tens_reg</code>, 连接到输出的 <code>ones</code> 和 <code>tens</code> 信号即可. </p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><p>首先是消抖电路: </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> debouncer <span class="token punctuation">(</span>  <span class="token keyword">input</span> <span class="token keyword">wire</span> clock<span class="token punctuation">,</span>  <span class="token keyword">input</span> <span class="token keyword">wire</span> reset<span class="token punctuation">,</span>  <span class="token keyword">input</span> <span class="token keyword">wire</span> button<span class="token punctuation">,</span>  <span class="token keyword">output</span> <span class="token keyword">wire</span> button_debounced<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">logic</span> last_button_reg<span class="token punctuation">;</span>  <span class="token keyword">logic</span> <span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> counter_reg<span class="token punctuation">;</span>  <span class="token keyword">logic</span> button_debounced_reg<span class="token punctuation">;</span>  <span class="token important">always_ff @</span> <span class="token punctuation">(</span><span class="token keyword">posedge</span> clock<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>reset<span class="token punctuation">)</span> <span class="token keyword">begin</span>      last_button_reg <span class="token operator">&lt;=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span>      counter_reg <span class="token operator">&lt;=</span> <span class="token number">16'b0</span><span class="token punctuation">;</span>      button_debounced_reg <span class="token operator">&lt;=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span>    <span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token keyword">begin</span>      last_button_reg <span class="token operator">&lt;=</span> button<span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>button <span class="token operator">==</span> last_button_reg<span class="token punctuation">)</span> <span class="token keyword">begin</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>counter_reg <span class="token operator">==</span> <span class="token number">16'd10000</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>          button_debounced_reg <span class="token operator">&lt;=</span> last_button_reg<span class="token punctuation">;</span>        <span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token keyword">begin</span>          counter_reg <span class="token operator">&lt;=</span> counter_reg <span class="token operator">+</span> <span class="token number">16'b1</span><span class="token punctuation">;</span>        <span class="token keyword">end</span>      <span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token keyword">begin</span>        counter_reg <span class="token operator">&lt;=</span> <span class="token number">16'b0</span><span class="token punctuation">;</span>      <span class="token keyword">end</span>    <span class="token keyword">end</span>  <span class="token keyword">end</span>  <span class="token keyword">assign</span> button_debounced <span class="token operator">=</span> button_debounced_reg<span class="token punctuation">;</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接着是计数器部分: </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> counter <span class="token punctuation">(</span>  <span class="token keyword">input</span> <span class="token keyword">wire</span> clock<span class="token punctuation">,</span>  <span class="token keyword">input</span> <span class="token keyword">wire</span> reset<span class="token punctuation">,</span>  <span class="token keyword">input</span> <span class="token keyword">wire</span> button_debounced<span class="token punctuation">,</span>  <span class="token keyword">output</span> <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> ones<span class="token punctuation">,</span>  <span class="token keyword">output</span> <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> tens<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">logic</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> ones_reg<span class="token punctuation">;</span>  <span class="token keyword">logic</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> tens_reg<span class="token punctuation">;</span>  <span class="token keyword">logic</span> button_debounced_reg<span class="token punctuation">;</span>  <span class="token important">always_ff @</span> <span class="token punctuation">(</span><span class="token keyword">posedge</span> clock<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>reset<span class="token punctuation">)</span> <span class="token keyword">begin</span>      ones_reg <span class="token operator">&lt;=</span> <span class="token number">4'b0</span><span class="token punctuation">;</span>      tens_reg <span class="token operator">&lt;=</span> <span class="token number">4'b0</span><span class="token punctuation">;</span>      button_debounced_reg <span class="token operator">&lt;=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span>    <span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token keyword">begin</span>      button_debounced_reg <span class="token operator">&lt;=</span> button_debounced<span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>button_debounced <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>button_debounced_reg<span class="token punctuation">)</span> <span class="token keyword">begin</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>ones_reg <span class="token operator">==</span> <span class="token number">4'd9</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>          ones_reg <span class="token operator">&lt;=</span> <span class="token number">4'b0</span><span class="token punctuation">;</span>          tens_reg <span class="token operator">&lt;=</span> tens_reg <span class="token operator">+</span> <span class="token number">4'b1</span><span class="token punctuation">;</span>        <span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token keyword">begin</span>          ones_reg <span class="token operator">&lt;=</span> ones_reg <span class="token operator">+</span> <span class="token number">4'b1</span><span class="token punctuation">;</span>        <span class="token keyword">end</span>      <span class="token keyword">end</span>    <span class="token keyword">end</span>  <span class="token keyword">end</span>  <span class="token keyword">assign</span> ones <span class="token operator">=</span> ones_reg<span class="token punctuation">;</span>  <span class="token keyword">assign</span> tens <span class="token operator">=</span> tens_reg<span class="token punctuation">;</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后再用一个顶层 <code>module</code> 把两个模块合起来: </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> counter_top <span class="token punctuation">(</span>  <span class="token keyword">input</span> <span class="token keyword">wire</span> clock<span class="token punctuation">,</span>  <span class="token keyword">input</span> <span class="token keyword">wire</span> reset<span class="token punctuation">,</span>  <span class="token keyword">input</span> <span class="token keyword">wire</span> button<span class="token punctuation">,</span>  <span class="token keyword">output</span> <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> ones<span class="token punctuation">,</span>  <span class="token keyword">output</span> <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> tens<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">wire</span> button_debounced<span class="token punctuation">;</span>  debouncer debouncer_component <span class="token punctuation">(</span>    <span class="token punctuation">.</span><span class="token function">clock</span><span class="token punctuation">(</span>clock<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span>reset<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">.</span><span class="token function">button</span><span class="token punctuation">(</span>button<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">.</span><span class="token function">button_debounced</span><span class="token punctuation">(</span>button_debounced<span class="token punctuation">)</span>  <span class="token punctuation">)</span><span class="token punctuation">;</span>  counter counter_component <span class="token punctuation">(</span>    <span class="token punctuation">.</span><span class="token function">clock</span><span class="token punctuation">(</span>clock<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span>reset<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">.</span><span class="token function">button_debounced</span><span class="token punctuation">(</span>button_debounced<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">.</span><span class="token function">ones</span><span class="token punctuation">(</span>ones<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">.</span><span class="token function">tens</span><span class="token punctuation">(</span>tens<span class="token punctuation">)</span>  <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>button_debounced</code> 是两个内部模块之间的, 所以声明了一个 <code>wire</code> 把两个模块的输入输出连起来, 其他信号则是直接连接到顶层模块的输入输出信号. </p><h2 id="无状态仲裁器-优先级编码器"><a href="#无状态仲裁器-优先级编码器" class="headerlink" title="无状态仲裁器 (优先级编码器)"></a>无状态仲裁器 (优先级编码器)</h2><h3 id="需求-4"><a href="#需求-4" class="headerlink" title="需求"></a>需求</h3><p>设计一个仲裁器: 假想多个用户同时访问同一个资源, 但是资源同时只能给一个用户使用, 这时需要使用一个仲裁器, 选择出一个幸运儿, 其他用户则需要等待. 假设资源的访问是 “立即” 完成的, 资源正在使用的时候, 使用权不会被其他用户抢走.</p><p>输入: </p><ol><li><code>request</code>: 宽度为 4, 每一位 1 表示对应的用户请求访问资源, 0 表示不请求.</li></ol><p>输出: </p><ol><li><code>valid</code>: 1 表示有用户请求访问资源, 0 表示无用户请求访问资源.</li><li><code>user</code>: 宽度为 2, 如果有用户请求访问资源时, 输出获得资源的用户的编号.</li></ol><h3 id="电路-4"><a href="#电路-4" class="headerlink" title="电路"></a>电路</h3><p>仲裁器的输出完全由输入决定, 没有内部状态, 所以可以用<strong>组合逻辑</strong>来实现.  <code>valid</code> 信号比较简单, 直接把所有输入用或门连接在一起即可. 如何找到请求的用户里, 编号最小的那一个? 可以分情况讨论: </p><ol><li><code>request=0000</code>, 输出的 <code>user</code> 可以是任意值.</li><li><code>request=???1</code>, 此时 <code>user=0, valid=1</code>.</li><li><code>request=??10</code>, 此时 <code>user=1, valid=1</code>.</li><li><code>request=?100</code>, 此时 <code>user=2, valid=1</code>.</li><li><code>request=1000</code>, 此时 <code>user=3, valid=1</code>.</li></ol><p>上面五个条件遍历了所有可能的情况. 在实现组合逻辑的时候, 一定要<strong>考虑所有情况, 并且每个情况下每个信号都要得到一个结果</strong>, 否则不可避免会引入锁存器.</p><p><img src="/pic/197.svg" alt=""></p><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> priority_encoder <span class="token punctuation">(</span>  <span class="token keyword">input</span> <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> request<span class="token punctuation">,</span>  <span class="token keyword">output</span> <span class="token keyword">wire</span> valid<span class="token punctuation">,</span>  <span class="token keyword">output</span> <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> user<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">logic</span> valid_comb<span class="token punctuation">;</span>  <span class="token keyword">logic</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> user_comb<span class="token punctuation">;</span>  <span class="token important">always_comb</span> <span class="token keyword">begin</span>    valid_comb <span class="token operator">=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span>    user_comb <span class="token operator">=</span> <span class="token number">2'd0</span><span class="token punctuation">;</span>    <span class="token keyword">casez</span> <span class="token punctuation">(</span>request<span class="token punctuation">)</span>      <span class="token number">4'b???1</span><span class="token punctuation">:</span> <span class="token keyword">begin</span>        valid_comb <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>        user_comb <span class="token operator">=</span> <span class="token number">2'd0</span><span class="token punctuation">;</span>      <span class="token keyword">end</span>      <span class="token number">4'b??10</span><span class="token punctuation">:</span> <span class="token keyword">begin</span>        valid_comb <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>        user_comb <span class="token operator">=</span> <span class="token number">2'd1</span><span class="token punctuation">;</span>      <span class="token keyword">end</span>      <span class="token number">4'b?100</span><span class="token punctuation">:</span> <span class="token keyword">begin</span>        valid_comb <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>        user_comb <span class="token operator">=</span> <span class="token number">2'd2</span><span class="token punctuation">;</span>      <span class="token keyword">end</span>      <span class="token number">4'b1000</span><span class="token punctuation">:</span> <span class="token keyword">begin</span>        valid_comb <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>        user_comb <span class="token operator">=</span> <span class="token number">2'd3</span><span class="token punctuation">;</span>      <span class="token keyword">end</span>    <span class="token keyword">endcase</span>  <span class="token keyword">end</span>  <span class="token keyword">assign</span> valid <span class="token operator">=</span> valid_comb<span class="token punctuation">;</span>  <span class="token keyword">assign</span> user <span class="token operator">=</span> user_comb<span class="token punctuation">;</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实现组合逻辑电路的一种方法是用 <code>assign</code>, 如 <code>assign valid = |request</code>; 但是涉及更复杂的组合逻辑时, 会比较复杂. 可以在 <code>always_comb</code> 块中灵活地使用各种条件语句, 包括 <code>casez</code> 语句, 首先设置了一个默认的结果, 这样如果下面所有的 <code>casez</code> 都不满足, 那么输出的就是默认值.</p><h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>总结规律: </p><ol><li>确定输入输出;</li><li>确定需要哪些寄存器;</li><li>实现时序逻辑;</li><li>实现组合逻辑.</li></ol><h2 id="循环优先级仲裁器"><a href="#循环优先级仲裁器" class="headerlink" title="循环优先级仲裁器"></a>循环优先级仲裁器</h2><h3 id="需求-5"><a href="#需求-5" class="headerlink" title="需求"></a>需求</h3><p>实现一个循环优先级仲裁器 (round robin arbiter), 根据最后一次获取资源的用户, 决定下一次获取资源的优先级. 当一个用户 <code>A</code> 不再获取资源 (对应位 <code>request</code> 从 <code>1</code> 变成 <code>0</code>) 时, 重新选择一个可以获取资源的用户, 优先级是从 <code>A</code> 的下一个用户开始为最高优先级, 如果溢出了就绕回.</p><p>输入: </p><ol><li><code>request</code>: 宽度为 4, 每一位 1 表示对应的用户请求访问资源, 0 表示不请求.</li><li><code>clock</code>: 1MHz 的时钟.</li><li><code>reset</code>: 复位信号.</li></ol><p>输出: </p><ol><li><code>valid</code>: 1 表示有用户请求访问资源, 0 表示无用户请求访问资源.</li><li><code>user</code>: 宽度为 2, 如果有用户请求访问资源时, 输出获得资源的用户的编号.</li></ol><h3 id="波形-2"><a href="#波形-2" class="headerlink" title="波形"></a>波形</h3><p>相比上一个例子, 有两个比较大的区别: </p><ol><li>无状态仲裁器中, 如果出现了优先级更高的用户, 资源的访问权立即切换; 循环优先级仲裁器中, 只有用户放弃了请求才会切换;</li><li>仲裁时, 优先级根据最后一次获得访问权的用户来决定.</li></ol><h3 id="电路-5"><a href="#电路-5" class="headerlink" title="电路"></a>电路</h3><p>由于优先级和最后一次获得访问权的用户有关, 需要<strong>时序逻辑</strong>实现. 用 <code>user_reg</code> 记录最后一次获得访问权的用户编号: </p><ol><li>什么时候更新: 上一个周期没有用户获得访问权, 这个周期 <code>request</code> 不等于零; 当前周期获得访问权的用户对应的 <code>request</code> 位由 <code>1</code> 变成了 <code>0</code>.</li><li>更新成什么: 按照优先级顺序在 <code>request</code> 里选出目前优先级最高的用户.</li></ol><p>由此, 在这一类内部具有状态, 又需要在输入变化的同一个周期输出的情况, 需要用时序逻辑来保存状态, 同时用组合逻辑来实现同周期的输出, 把二者结合起来.</p><p>第一部分是修改后的优先级编码器, 额外添加输入 <code>last_user</code> 表示最后一次获得访问权的用户编号. </p><p>第二部分是维护 <code>user_reg</code> 状态. 第一个模块是上面提到的修改后的优先级编码器, 第二个模块是整体的循环优先级仲裁器, 内部例化第一个模块. </p><h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><p>实现第一部分逻辑, 根据最后一次获取资源的用户编号确定优先级的优先级编码器: </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> rr_priority_encoder <span class="token punctuation">(</span>  <span class="token keyword">input</span> <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> request<span class="token punctuation">,</span>  <span class="token keyword">input</span> <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> last_user<span class="token punctuation">,</span>  <span class="token keyword">output</span> <span class="token keyword">wire</span> valid<span class="token punctuation">,</span>  <span class="token keyword">output</span> <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> user<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">logic</span> valid_comb<span class="token punctuation">;</span>  <span class="token keyword">logic</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> user_comb<span class="token punctuation">;</span>  <span class="token important">always_comb</span> <span class="token keyword">begin</span>    valid_comb <span class="token operator">=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span>    user_comb <span class="token operator">=</span> <span class="token number">2'd0</span><span class="token punctuation">;</span>    <span class="token comment">// naive way</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>last_user <span class="token operator">==</span> <span class="token number">2'd3</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>      <span class="token keyword">casez</span> <span class="token punctuation">(</span>request<span class="token punctuation">)</span>        <span class="token number">4'b???1</span><span class="token punctuation">:</span> <span class="token keyword">begin</span>          valid_comb <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>          user_comb <span class="token operator">=</span> <span class="token number">2'd0</span><span class="token punctuation">;</span>        <span class="token keyword">end</span>        <span class="token number">4'b??10</span><span class="token punctuation">:</span> <span class="token keyword">begin</span>          valid_comb <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>          user_comb <span class="token operator">=</span> <span class="token number">2'd1</span><span class="token punctuation">;</span>        <span class="token keyword">end</span>        <span class="token number">4'b?100</span><span class="token punctuation">:</span> <span class="token keyword">begin</span>          valid_comb <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>          user_comb <span class="token operator">=</span> <span class="token number">2'd2</span><span class="token punctuation">;</span>        <span class="token keyword">end</span>        <span class="token number">4'b1000</span><span class="token punctuation">:</span> <span class="token keyword">begin</span>          valid_comb <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>          user_comb <span class="token operator">=</span> <span class="token number">2'd3</span><span class="token punctuation">;</span>        <span class="token keyword">end</span>      <span class="token keyword">endcase</span>    <span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>last_user <span class="token operator">==</span> <span class="token number">2'd0</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>      <span class="token keyword">casez</span> <span class="token punctuation">(</span>request<span class="token punctuation">)</span>        <span class="token number">4'b??1?</span><span class="token punctuation">:</span> <span class="token keyword">begin</span>          valid_comb <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>          user_comb <span class="token operator">=</span> <span class="token number">2'd1</span><span class="token punctuation">;</span>        <span class="token keyword">end</span>        <span class="token number">4'b?10?</span><span class="token punctuation">:</span> <span class="token keyword">begin</span>          valid_comb <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>          user_comb <span class="token operator">=</span> <span class="token number">2'd2</span><span class="token punctuation">;</span>        <span class="token keyword">end</span>        <span class="token number">4'b100?</span><span class="token punctuation">:</span> <span class="token keyword">begin</span>          valid_comb <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>          user_comb <span class="token operator">=</span> <span class="token number">2'd3</span><span class="token punctuation">;</span>        <span class="token keyword">end</span>        <span class="token number">4'b0001</span><span class="token punctuation">:</span> <span class="token keyword">begin</span>          valid_comb <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>          user_comb <span class="token operator">=</span> <span class="token number">2'd0</span><span class="token punctuation">;</span>        <span class="token keyword">end</span>      <span class="token keyword">endcase</span>    <span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>last_user <span class="token operator">==</span> <span class="token number">2'd1</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>      <span class="token keyword">casez</span> <span class="token punctuation">(</span>request<span class="token punctuation">)</span>        <span class="token number">4'b?1??</span><span class="token punctuation">:</span> <span class="token keyword">begin</span>          valid_comb <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>          user_comb <span class="token operator">=</span> <span class="token number">2'd2</span><span class="token punctuation">;</span>        <span class="token keyword">end</span>        <span class="token number">4'b10??</span><span class="token punctuation">:</span> <span class="token keyword">begin</span>          valid_comb <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>          user_comb <span class="token operator">=</span> <span class="token number">2'd3</span><span class="token punctuation">;</span>        <span class="token keyword">end</span>        <span class="token number">4'b00?1</span><span class="token punctuation">:</span> <span class="token keyword">begin</span>          valid_comb <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>          user_comb <span class="token operator">=</span> <span class="token number">2'd0</span><span class="token punctuation">;</span>        <span class="token keyword">end</span>        <span class="token number">4'b0010</span><span class="token punctuation">:</span> <span class="token keyword">begin</span>          valid_comb <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>          user_comb <span class="token operator">=</span> <span class="token number">2'd1</span><span class="token punctuation">;</span>        <span class="token keyword">end</span>      <span class="token keyword">endcase</span>    <span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>last_user <span class="token operator">==</span> <span class="token number">2'd2</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>      <span class="token keyword">casez</span> <span class="token punctuation">(</span>request<span class="token punctuation">)</span>        <span class="token number">4'b1???</span><span class="token punctuation">:</span> <span class="token keyword">begin</span>          valid_comb <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>          user_comb <span class="token operator">=</span> <span class="token number">2'd3</span><span class="token punctuation">;</span>        <span class="token keyword">end</span>        <span class="token number">4'b0??1</span><span class="token punctuation">:</span> <span class="token keyword">begin</span>          valid_comb <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>          user_comb <span class="token operator">=</span> <span class="token number">2'd0</span><span class="token punctuation">;</span>        <span class="token keyword">end</span>        <span class="token number">4'b0?10</span><span class="token punctuation">:</span> <span class="token keyword">begin</span>          valid_comb <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>          user_comb <span class="token operator">=</span> <span class="token number">2'd1</span><span class="token punctuation">;</span>        <span class="token keyword">end</span>        <span class="token number">4'b0100</span><span class="token punctuation">:</span> <span class="token keyword">begin</span>          valid_comb <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>          user_comb <span class="token operator">=</span> <span class="token number">2'd2</span><span class="token punctuation">;</span>        <span class="token keyword">end</span>      <span class="token keyword">endcase</span>    <span class="token keyword">end</span>  <span class="token keyword">end</span>  <span class="token keyword">assign</span> valid <span class="token operator">=</span> valid_comb<span class="token punctuation">;</span>  <span class="token keyword">assign</span> user <span class="token operator">=</span> user_comb<span class="token punctuation">;</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接着是循环优先级仲裁器: </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> rr_arbiter <span class="token punctuation">(</span>  <span class="token keyword">input</span> <span class="token keyword">wire</span> clock<span class="token punctuation">,</span>  <span class="token keyword">input</span> <span class="token keyword">wire</span> reset<span class="token punctuation">,</span>  <span class="token keyword">input</span> <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> request<span class="token punctuation">,</span>  <span class="token keyword">output</span> <span class="token keyword">wire</span> valid<span class="token punctuation">,</span>  <span class="token keyword">output</span> <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> user<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">logic</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> user_reg<span class="token punctuation">;</span>  <span class="token keyword">logic</span> valid_reg<span class="token punctuation">;</span>  <span class="token keyword">logic</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> user_comb<span class="token punctuation">;</span>  <span class="token keyword">logic</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> priority_encoder_user_comb<span class="token punctuation">;</span>  rr_priority_encoder rr_priority_encoder_inst <span class="token punctuation">(</span>    <span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">.</span><span class="token function">last_user</span><span class="token punctuation">(</span>user_reg<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">.</span><span class="token function">valid</span><span class="token punctuation">(</span>valid<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">.</span><span class="token function">user</span><span class="token punctuation">(</span>priority_encoder_user_comb<span class="token punctuation">)</span>  <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// sequential</span>  <span class="token important">always_ff @</span> <span class="token punctuation">(</span><span class="token keyword">posedge</span> clock<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>reset<span class="token punctuation">)</span> <span class="token keyword">begin</span>      user_reg <span class="token operator">&lt;=</span> <span class="token number">2'd0</span><span class="token punctuation">;</span>      valid_reg <span class="token operator">&lt;=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span>    <span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token keyword">begin</span>      valid_reg <span class="token operator">&lt;=</span> valid<span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>valid_reg <span class="token operator">&amp;&amp;</span> valid<span class="token punctuation">)</span> <span class="token keyword">begin</span>        <span class="token comment">// case 1: non valid -&gt; valid</span>        user_reg <span class="token operator">&lt;=</span> priority_encoder_user_comb<span class="token punctuation">;</span>      <span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>valid_reg <span class="token operator">&amp;&amp;</span> valid <span class="token operator">&amp;&amp;</span> request<span class="token punctuation">[</span>user_reg<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>        <span class="token comment">// case 2: persist</span>      <span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>valid_reg <span class="token operator">&amp;&amp;</span> valid <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>request<span class="token punctuation">[</span>user_reg<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>        <span class="token comment">// case 3: next user</span>        user_reg <span class="token operator">&lt;=</span> priority_encoder_user_comb<span class="token punctuation">;</span>      <span class="token keyword">end</span>    <span class="token keyword">end</span>  <span class="token keyword">end</span>  <span class="token comment">// combinatorial</span>  <span class="token important">always_comb</span> <span class="token keyword">begin</span>    <span class="token comment">// default</span>    user_comb <span class="token operator">=</span> <span class="token number">2'b0</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>valid_reg <span class="token operator">&amp;&amp;</span> valid<span class="token punctuation">)</span> <span class="token keyword">begin</span>      <span class="token comment">// case 1: non valid -&gt; valid</span>      user_comb <span class="token operator">=</span> priority_encoder_user_comb<span class="token punctuation">;</span>    <span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>valid_reg <span class="token operator">&amp;&amp;</span> valid <span class="token operator">&amp;&amp;</span> request<span class="token punctuation">[</span>user_reg<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>      <span class="token comment">// case 2: persist</span>      user_comb <span class="token operator">=</span> user_reg<span class="token punctuation">;</span>    <span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>valid_reg <span class="token operator">&amp;&amp;</span> valid <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>request<span class="token punctuation">[</span>user_reg<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>      <span class="token comment">// case 3: next user</span>      user_comb <span class="token operator">=</span> priority_encoder_user_comb<span class="token punctuation">;</span>    <span class="token keyword">end</span>  <span class="token keyword">end</span>  <span class="token keyword">assign</span> user <span class="token operator">=</span> user_comb<span class="token punctuation">;</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="仿真"><a href="#仿真" class="headerlink" title="仿真"></a>仿真</h2><p><strong>描述数字电路的 Verilog 和用来仿真的 Verilog 使用完全不同的编写思路和实现方法.</strong> 前者与电路一一对应, 而后者更像是 C 这种过程式的编程语言.</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> add2 <span class="token punctuation">(</span>  <span class="token keyword">input</span> <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span>  <span class="token keyword">input</span> <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> b<span class="token punctuation">,</span>  <span class="token keyword">output</span> <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">assign</span> c <span class="token operator">=</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>要给这个模块输入数据, 要人为地设置模块的输入: </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token constant">`timescale</span> <span class="token number">1</span>ns<span class="token operator">/</span><span class="token number">1</span>ps<span class="token keyword">module</span> add2_tb <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> a<span class="token punctuation">;</span>  <span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> b<span class="token punctuation">;</span>  <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> c<span class="token punctuation">;</span>  <span class="token keyword">initial</span> <span class="token keyword">begin</span>    a <span class="token operator">=</span> <span class="token number">2'b01</span><span class="token punctuation">;</span>    b <span class="token operator">=</span> <span class="token number">2'b10</span><span class="token punctuation">;</span>    <span class="token number">#1</span><span class="token punctuation">;</span>    <span class="token kernel-function property">$finish</span><span class="token punctuation">;</span>  <span class="token keyword">end</span>  add2 inst <span class="token punctuation">(</span>    <span class="token punctuation">.</span><span class="token function">a</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">.</span><span class="token function">b</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">.</span><span class="token function">c</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span>  <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于 <code>c</code> 连接到 <code>add2</code> 模块的输出, 所以要用 <code>wire</code>; 其他要输入到 <code>add2</code> 模块中, 所以用 <code>reg</code>. 运行 <code>#1;</code> 命令, 表示等待 <code>1ns</code>, 然后再运行 <code>$finish;</code>, 表示仿真结束.</p><h3 id="时钟"><a href="#时钟" class="headerlink" title="时钟"></a>时钟</h3><p>仿真一个带有时序逻辑的模块, 使用前面的秒表的例子: </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> timer <span class="token punctuation">(</span>  <span class="token keyword">input</span> <span class="token keyword">wire</span> clock<span class="token punctuation">,</span>  <span class="token keyword">input</span> <span class="token keyword">wire</span> reset<span class="token punctuation">,</span>  <span class="token keyword">output</span> <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> timer<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> timer_reg<span class="token punctuation">;</span>  <span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">19</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> counter_reg<span class="token punctuation">;</span>  <span class="token comment">// sequential</span>  <span class="token important">always @</span> <span class="token punctuation">(</span><span class="token keyword">posedge</span> clock<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>reset<span class="token punctuation">)</span> <span class="token keyword">begin</span>      timer_reg <span class="token operator">&lt;=</span> <span class="token number">4'b0</span><span class="token punctuation">;</span>      counter_reg <span class="token operator">&lt;=</span> <span class="token number">20'b0</span><span class="token punctuation">;</span>    <span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token keyword">begin</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>counter_reg <span class="token operator">==</span> <span class="token number">20'd999999</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>        timer_reg <span class="token operator">&lt;=</span> timer_reg <span class="token operator">+</span> <span class="token number">4'b1</span><span class="token punctuation">;</span>        counter_reg <span class="token operator">&lt;=</span> <span class="token number">20'b0</span><span class="token punctuation">;</span>      <span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token keyword">begin</span>        counter_reg <span class="token operator">&lt;=</span> counter_reg <span class="token operator">+</span> <span class="token number">20'b1</span><span class="token punctuation">;</span>      <span class="token keyword">end</span>    <span class="token keyword">end</span>  <span class="token keyword">end</span>  <span class="token comment">// combinatorial</span>  <span class="token keyword">assign</span> timer <span class="token operator">=</span> timer_reg<span class="token punctuation">;</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>例化 <code>timer</code> 模块, 连接输入输出信号. 时钟信号以一个固定的频率在 0 和 1 之间变化. 如果频率是 50MHz, 那么一个周期每 10ns 变化一次. 这样下去就可以构造出一个时钟信号:</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">initial</span> <span class="token keyword">begin</span>  reset <span class="token operator">=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span>  clock <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>  <span class="token number">#10</span><span class="token punctuation">;</span>  clock <span class="token operator">=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span>  <span class="token number">#10</span><span class="token punctuation">;</span>  clock <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>  <span class="token number">#10</span><span class="token punctuation">;</span>  clock <span class="token operator">=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span>  <span class="token number">#10</span><span class="token punctuation">;</span><span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>希望仿真更多时钟周期, 自动生成时钟信号:</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">initial</span> <span class="token keyword">begin</span>  reset <span class="token operator">=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span>  clock <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token important">always</span> <span class="token number">#10</span> clock <span class="token operator">=</span> <span class="token operator">~</span>clock<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="复位"><a href="#复位" class="headerlink" title="复位"></a>复位</h3><p>处理好时钟后仿真上面的代码, 会发现 <code>timer</code> 输出一直是 <code>x</code>, 因为 <code>timer</code> 没有被复位. 需要先设置 <code>reset</code> 为 1, 再设置 <code>reset</code> 为 0: </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">initial</span> <span class="token keyword">begin</span>  reset <span class="token operator">=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span>  clock <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>  <span class="token number">#10</span><span class="token punctuation">;</span>  reset <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>  <span class="token number">#10</span><span class="token punctuation">;</span>  reset <span class="token operator">=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token important">always</span> <span class="token number">#10</span> clock <span class="token operator">=</span> <span class="token operator">~</span>clock<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="构造输入"><a href="#构造输入" class="headerlink" title="构造输入"></a>构造输入</h3><p>目前的仿真顶层模块没有提供要测试的模块的其他输入信号, 还需要针对特定的协议人为构造输入.</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">reg</span> ps2_clock<span class="token punctuation">;</span><span class="token keyword">reg</span> ps2_data<span class="token punctuation">;</span>ps2_keyboard dut <span class="token punctuation">(</span>  <span class="token punctuation">.</span><span class="token function">clock</span><span class="token punctuation">(</span>clock<span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span>reset<span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token punctuation">.</span><span class="token function">ps2_clock</span><span class="token punctuation">(</span>ps2_clock<span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token punctuation">.</span><span class="token function">ps2_data</span><span class="token punctuation">(</span>ps2_data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>按照 PS/2 的协议, 按顺序给 ps2_clock 和 ps2_data 赋值, 穿插着延迟语句.</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog">ps2_data <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>ps2_clock <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span><span class="token number">#5</span><span class="token punctuation">;</span><span class="token comment">// start bit</span>ps2_data <span class="token operator">=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span><span class="token number">#5</span><span class="token punctuation">;</span>ps2_clock <span class="token operator">=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span><span class="token number">#5</span><span class="token punctuation">;</span>ps2_clock <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span><span class="token comment">// scancode[0] = 0</span>ps2_data <span class="token operator">=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span><span class="token number">#5</span><span class="token punctuation">;</span>ps2_clock <span class="token operator">=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span><span class="token number">#5</span><span class="token punctuation">;</span>ps2_clock <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span><span class="token comment">// scancode[1] = 0</span>ps2_data <span class="token operator">=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span><span class="token number">#5</span><span class="token punctuation">;</span>ps2_clock <span class="token operator">=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span><span class="token number">#5</span><span class="token punctuation">;</span>ps2_clock <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">// scancode[7] = 1</span>ps2_data <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span><span class="token number">#5</span><span class="token punctuation">;</span>ps2_clock <span class="token operator">=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span><span class="token number">#5</span><span class="token punctuation">;</span>ps2_clock <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span><span class="token comment">// parity = 1</span>ps2_data <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span><span class="token number">#5</span><span class="token punctuation">;</span>ps2_clock <span class="token operator">=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span><span class="token number">#5</span><span class="token punctuation">;</span>ps2_clock <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span><span class="token comment">// stop</span>ps2_data <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span><span class="token number">#5</span><span class="token punctuation">;</span>ps2_clock <span class="token operator">=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span><span class="token number">#5</span><span class="token punctuation">;</span>ps2_clock <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>更进一步, 如果想要重复发送 scancode, 只不过内容会更改, 可以把这一步骤封装成 task, 完整写法见 <a href="https://git.tsinghua.edu.cn/digital-design-lab/project-template/-/blob/2076e9ffc1ff3e923365a9e79d6a944544a3b8e8/src/keyboard_tb.v#L12">Tsinghua GitLab</a>.</p><h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><p>总结一下: </p><ul><li>单独写一个仿真顶层模块, 例化要测试的模块.</li><li>测试模块的输入输出接到 <code>reg</code> 或者 <code>wire</code>.</li><li>时序逻辑在 <code>initial</code> 块初始化时钟信号, 用 <code>always #10 clock = ~clock;</code> 生成时钟信号.</li><li>复位信号在 <code>initial</code> 块内, 仿真信号由 0 变成 1, 再由 1 变成 0.</li><li>输入信号在 <code>initial</code> 块内, 对对应的 <code>reg</code> 信号进行赋值.</li></ul>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;SystemVerilog实例&quot;&gt;&lt;a href=&quot;#SystemVerilog实例&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    <category term="CS" scheme="http://chengsx21.github.io/categories/CS/"/>
    
    <category term="COD" scheme="http://chengsx21.github.io/categories/CS/COD/"/>
    
    
    <category term="COD" scheme="http://chengsx21.github.io/tags/COD/"/>
    
    <category term="SV" scheme="http://chengsx21.github.io/tags/SV/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成原理 笔记3</title>
    <link href="http://chengsx21.github.io/2023/09/28/systemverilog-ru-men-shi-yong/"/>
    <id>http://chengsx21.github.io/2023/09/28/systemverilog-ru-men-shi-yong/</id>
    <published>2023-09-28T09:18:57.000Z</published>
    <updated>2023-09-27T13:13:26.597Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SystemVerilog入门使用"><a href="#SystemVerilog入门使用" class="headerlink" title="SystemVerilog入门使用"></a>SystemVerilog入门使用</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>写硬件和写软件代码是完全不同的——软件代码体现了指令顺序流执行的思想, 这是和冯诺依曼计算机的结构直接相关的; 硬件的特性是信号在各条信号线上并行传播, 硬件描述语言描述的是各个模块之间的连接关系. </p><h2 id="模块结构"><a href="#模块结构" class="headerlink" title="模块结构"></a>模块结构</h2><p>一个 2 输入与门的模块描述: </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> and2x <span class="token punctuation">(</span>    <span class="token keyword">input</span> <span class="token keyword">wire</span> a<span class="token punctuation">,</span>    <span class="token keyword">input</span> <span class="token keyword">wire</span> b<span class="token punctuation">,</span>    <span class="token keyword">output</span> <span class="token keyword">wire</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">assign</span> r <span class="token operator">=</span> a <span class="token operator">&amp;</span> b<span class="token punctuation">;</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要注意的几点是:</p><ul><li>输入和双向端口不能被定义为 <code>reg</code> 类型. </li><li>如果无法确认使用 <code>reg</code> 还是使用 <code>wire</code>, 都可以使用 <code>logic</code> 来代替. </li><li><code>wire</code> 是默认的类型, 所有的 <code>wire</code> 都可以省略. </li><li>通过 <code>assign</code> 语句进行持续赋值, 通常被用来进行组合逻辑的设计.</li></ul><h2 id="语言元素"><a href="#语言元素" class="headerlink" title="语言元素"></a>语言元素</h2><p>硬件描述里面的 “综合” 这个概念非常重要, 类比于将高级语言编译为机器语言, 最终在物理硬件上执行. “综合” 的含义就是将硬件描述语言的功能翻译为能够直接实现的电路, 可以放到 FPGA 或者直接转化为硬件电路, 用以执行所描述的功能. </p><h3 id="SystemVerilog-的语言元素"><a href="#SystemVerilog-的语言元素" class="headerlink" title="SystemVerilog 的语言元素"></a>SystemVerilog 的语言元素</h3><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><p>在 C 语言中, 一个编程习惯是使用符号来代替常数硬编码. 这一点在 SystemVerilog 中也是一样的. 可以使用 <code>parameter</code> 来定义一个符号常量, 便于修改也增加了程序的可读性. 一个最为典型的应用就是来指定信号 (向量) 的宽度, 使用 parameter 的语法形式为: </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">parameter</span> PARAM1<span class="token operator">=</span>EXP1<span class="token punctuation">,</span> PARAM2<span class="token operator">=</span>EXP2<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="编译指导语句"><a href="#编译指导语句" class="headerlink" title="编译指导语句"></a>编译指导语句</h4><p>SystemVerilog 中的编译指导语句与 C 语言 (例如 <code>#include</code>) 类似, 指示编译器的工作. 编译指导语句都是不可综合的, 会在编译的时候进行字符串等替换操作. </p><h5 id="define-宏定义语句"><a href="#define-宏定义语句" class="headerlink" title="`define 宏定义语句"></a><code>`define</code> 宏定义语句</h5><p><code>`define</code> 语句相当于 C 语言中的 <code>#define</code>, 在编译时, <code>`define</code> 的宏名称被替换为后面的字符串. 如: </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token constant">`define</span> WIDTH <span class="token number">16</span><span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token constant">`WIDTH</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> r<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这就与 <code>reg[15:0]</code> 相当. 在每次使用宏名称的时候, 需要加上 <code>` </code>, 在 <code>`define</code> 这一行的行末不需要分号.  <code>`define</code> 的宏替换功能与 C 语言一样强大, 能够用来替换比较复杂的表达式. 例如: </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token constant">`define</span> sum a<span class="token operator">+</span>b<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>定义之后, 可以使用: </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">assign</span> res<span class="token operator">=</span>sum<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>来获得将两个 a 和 b 信号相加的效果.</p><h5 id="include-文件包含语句"><a href="#include-文件包含语句" class="headerlink" title="`include 文件包含语句"></a><code>`include</code> 文件包含语句</h5><p><code>`include</code> 语句相当于 C 语言中的 <code>#include</code> 语句, 用来包含其它的文件. 这里同样也没有行末的分号, 需要设置对应的相对路径, 例如: </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token constant">`include</span> <span class="token string">"../common/adder.v"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="ifdef-else-elsif-endif-条件编译语句"><a href="#ifdef-else-elsif-endif-条件编译语句" class="headerlink" title="`ifdef,  `else, `elsif, `endif 条件编译语句"></a><code>`ifdef</code>,  <code>`else</code>, <code>`elsif</code>, <code>`endif</code> 条件编译语句</h5><p><code>`ifdef</code>, <code>`else</code>, <code>`elsif</code>, <code>`endif</code> 条件编译语句相当于在 C 语言中的 <code>#ifdef</code>, <code>#else</code>, <code>#elif</code>, <code>#endif</code> 语句, 用来设定哪一部分源代码会最终编译, 例如: </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token constant">`define</span> sum a<span class="token operator">+</span>b<span class="token constant">`ifdef</span> sum<span class="token keyword">assign</span> res<span class="token operator">=</span>sum<span class="token punctuation">;</span><span class="token constant">`else</span><span class="token keyword">assign</span> res<span class="token operator">=</span>a<span class="token operator">+</span>b<span class="token punctuation">;</span><span class="token constant">`endif</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以通过控制 <code>sum</code> 是否定义来选择需要编译的源代码, 不需要编译的源代码就被忽略. 需要嵌套更多判断, 可以使用 <code>`elsif</code> 进一步判断. </p><h3 id="SystemVerilog-中的数据"><a href="#SystemVerilog-中的数据" class="headerlink" title="SystemVerilog 中的数据"></a>SystemVerilog 中的数据</h3><h4 id="整数常量"><a href="#整数常量" class="headerlink" title="整数常量"></a>整数常量</h4><p>在硬件开发的过程中, 不能够改变的量被称为是常量 (constants). 在处理器设计中, 最为重要的常量形式为整数, 整数常量按照一定的格式写出: </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token operator">+/-</span> <span class="token operator">&lt;</span>位宽<span class="token operator">&gt;</span>'<span class="token operator">&lt;</span>进制<span class="token operator">&gt;&lt;</span>数字<span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>进制包括了二进制 (<code>b</code> 或者 <code>B</code>), 十进制 (<code>d</code> 或者 <code>D</code>), 八进制 (<code>o</code> 或者 <code>O</code>) 以及十六进制 (<code>h</code> 或者 <code>H</code>).</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token number">8'b01001010</span><span class="token number">16'H45EF</span><span class="token operator">-</span><span class="token number">8'D123</span><span class="token operator">-</span><span class="token number">16'o3333</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="数据取值"><a href="#数据取值" class="headerlink" title="数据取值"></a>数据取值</h4><p>在进行硬件编码的时候, 除了 <code>0</code> 和 <code>1</code> 两个信号取值外, 还有其它的一些逻辑状态. 两个比较重要的是 <code>x</code>/<code>X</code> 和 <code>z</code>/<code>Z</code>.</p><p><code>x</code> 或者 <code>X</code> 的取值表明为不确定, 或者未知逻辑状态, 用于不关心对应信号值的情况.</p><p><code>z</code> 或者 <code>Z</code> 代表高阻态, 典型应用是用于获得内存的输入, 先将处理器引脚的状态置于 <code>z</code>, 经过一定的时间延迟, 可从对应的引脚处获得内存的输入值. </p><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><p>基本数据类型包括了 <code>wire</code> 类型和 <code>reg</code> 类型. <code>wire</code> 类型代表了在硬件电路中的连线, 输出的值紧随着输入值的变化而变化. <code>reg</code> 数据类型会放到过程语句中进行赋值, 不一定必然会对应到硬件的寄存器, 综合时依据实际情况使用连线 (组合逻辑) 或者寄存器 (时序逻辑). </p><p>数据类型还有向量和标量的区别. 没有指定则默认为 1 位的位宽, 是一个标量. 向量使用中括号指定位宽, 形式为 <code>[msb:lsb]</code>. 例如: </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> data<span class="token punctuation">;</span> <span class="token comment">// 这是一个 8 位的连线. </span><span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> res<span class="token punctuation">;</span>  <span class="token comment">// 32 位的数据变量</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在 SystemVerilog 中有非常方便的向量访问方式:</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog">l <span class="token operator">=</span> data<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">// 获取 data 的最高位</span>lob <span class="token operator">=</span> res<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 获取数据 res 中的最低 8 位, 即最低一个字节</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="SystemVerilog-中的运算"><a href="#SystemVerilog-中的运算" class="headerlink" title="SystemVerilog 中的运算"></a>SystemVerilog 中的运算</h3><h4 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h4><p>位运算符是最基本的运算符, 表达了两个操作数对应的位进行位运算的结果.</p><ul><li><code>~</code> 按位取反.</li><li><code>&amp;</code> 按位与.</li><li><code>|</code> 按位或. </li><li><code>^</code> 按位异或.</li><li><code>^~</code> 或 <code>~^</code> 按位同或.</li><li><code>&gt;&gt;</code> 右移.</li><li><code>&lt;&lt;</code> 左移.</li></ul><p>在位运算符中还有一类特殊的运算符, 即缩位运算符. 可以将一个向量按照一定的位运算 “缩” 成 1 位. </p><ul><li><code>&amp;</code> 缩位与.</li><li><code>~&amp;</code> 缩位与非.</li><li><code>|</code> 缩位或.</li><li><code>~\</code> 缩位或非.</li><li><code>^</code> 缩位异或.</li><li><code>^~</code> 或 <code>~^</code> 缩位同或.</li></ul><p>例如 <code>reg [7:0] value;</code> 如果 <code>value = 7'b01010101</code>. 则 <code>&amp;value</code> 结果为 0, <code>|value</code> 结果为 1, <code>~^value</code> 结果为 1.</p><h4 id="关系和逻辑运算符"><a href="#关系和逻辑运算符" class="headerlink" title="关系和逻辑运算符"></a>关系和逻辑运算符</h4><p>这些运算符可用于条件判断, 取值结果为 <code>true</code> 或者 <code>false</code>. 着重解释一下全等运算符和不全等运算符.</p><ul><li><code>===</code> 关系运算符全等. </li><li><code>!==</code> 关系运算符不全等. </li></ul><p>相等运算符 <code>==</code> 在进行比较时, 需要按每位进行比较, 只有所有的位都相等的时候, 最后的结果值才会是 <code>true</code>. 如果其中的某一位是高阻态或者不定值, 最终的结果是不定值. 对于全等 <code>===</code> 来说, 这些高阻态或者不定值也需要进行比较, 完全一致才会获得 <code>true</code> 结果.  </p><div class="table-container"><table><thead><tr><th style="text-align:center">A</th><th style="text-align:center">B</th><th style="text-align:center">A==B</th><th style="text-align:center">A===B</th></tr></thead><tbody><tr><td style="text-align:center">4b1101</td><td style="text-align:center">4b1101</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">4b1100</td><td style="text-align:center">4b1101</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">4b110Z</td><td style="text-align:center">4b110Z</td><td style="text-align:center">X</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">4b11XX</td><td style="text-align:center">4b11XX</td><td style="text-align:center">X</td><td style="text-align:center">1</td></tr></tbody></table></div><h4 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h4><p>算术运算符并不是最基本的运算符, 需要使用对应的门电路组织成的组合逻辑来完成. 这是语言内部提供的高层的逻辑单元功能, 方便在开发的时候直接集成使用, 而不需要采用模块调用的方式. 在处理器的设计中, 算术运算符的最重要的作用是用来构成 ALU.</p><h4 id="位拼接运算符"><a href="#位拼接运算符" class="headerlink" title="位拼接运算符"></a>位拼接运算符</h4><p>位拼接运算符 <code>{ }</code> 能够把多个信号拼接为向量的形式. <code>{a[3:0], b[7:6],c}</code> 代表了将 <code>a</code> 的第 3 至第 0 位, <code>b</code> 的第 7 位和第 6 位, 以及信号 <code>c</code> 拼接在一起, 构成一个新的信号向量. </p><h2 id="SystemVerilog-的行为语句"><a href="#SystemVerilog-的行为语句" class="headerlink" title="SystemVerilog 的行为语句"></a>SystemVerilog 的行为语句</h2><h3 id="关于硬件描述语言功能的讨论"><a href="#关于硬件描述语言功能的讨论" class="headerlink" title="关于硬件描述语言功能的讨论"></a>关于硬件描述语言功能的讨论</h3><p>行为语句是 SystemVerilog 中最为重要的功能语句, 用来定义具体模块的行为. 在术语上一直使用的是硬件<strong>描述语言</strong>这样的叙述方式, 而不是硬件<strong>设计语言</strong>. 因为硬件描述语言大部分没有说明底层的硬件构成, 更多阐述模块对外的功能表现.</p><p>在使用硬件描述语言的时候, 更多的是描述对应的电路模块应具有什么功能. 硬件语言的编译器会翻译为对应的底层硬件的实现, 有一定的中立性, 不依赖于具体的物理实现方式. 因此, 描述完成之后不一定是可以综合的 (可物理实现的). 在开发的时候, 时刻要注意程序最终需要被转化为硬件电路. </p><h3 id="SystemVerilog-的行为语句综述"><a href="#SystemVerilog-的行为语句综述" class="headerlink" title="SystemVerilog 的行为语句综述"></a>SystemVerilog 的行为语句综述</h3><p>SystemVerilog 的行为语句包括赋值语句, 过程语句, 条件语句, 编译指导语句等. 不是所有的行为语句都是可以综合的, 但不可综合的行为语句作用也十分重要, 会被应用到仿真环境中. 在 SystemVerilog 中可综合的行为语句主要包括以下部分: </p><ol><li><code>always</code> 过程语句;</li><li>使用 <code>begin-end</code> 组合的语句块;</li><li>可以进行持续赋值的语句 <code>assign</code>; </li><li>阻塞的过程赋值语句 <code>=</code>, 非阻塞的过程赋值语句 <code>&lt;=</code>;</li><li><code>for</code> 循环语句. </li></ol><h3 id="always-过程语句"><a href="#always-过程语句" class="headerlink" title="always 过程语句"></a>always 过程语句</h3><p>一个模块的多个 <code>always</code> 过程语句是并行执行的. 在实现的时候, 通常会使用两种 <code>always</code> 过程语句: </p><ul><li><code>always_comb</code>: 用来实现<strong>组合逻辑</strong>;</li><li><code>always_ff</code>: 用来实现<strong>时钟边沿触发的时序逻辑</strong>.</li></ul><h4 id="always-comb-过程语句"><a href="#always-comb-过程语句" class="headerlink" title="always_comb 过程语句"></a>always_comb 过程语句</h4><p><code>always_comb</code> 过程语句的使用方法如下: </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token important">always_comb</span>     语句 <span class="token punctuation">(</span>可以是一条语句<span class="token punctuation">,</span> 或者是语句块<span class="token punctuation">)</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果只有一条语句, 不需要加 <code>begin end</code> 构成语句块; 如果超过一条则需要构造成语句块. 更加经常使用的形式是如下形式:</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token important">always_comb</span><span class="token keyword">begin</span>    <span class="token comment">//本过程的功能描述</span><span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>一个四选一数据选择器的模块例子: </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> mux4_1 <span class="token punctuation">(</span>    <span class="token keyword">input</span> din1<span class="token punctuation">,</span>    <span class="token keyword">input</span> din2<span class="token punctuation">,</span>    <span class="token keyword">input</span> din3<span class="token punctuation">,</span>    <span class="token keyword">input</span> din4<span class="token punctuation">,</span>    <span class="token keyword">input</span> se1<span class="token punctuation">,</span>    <span class="token keyword">input</span> se2<span class="token punctuation">,</span>    <span class="token keyword">output</span> <span class="token keyword">reg</span> out<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token important">always_comb</span>        <span class="token keyword">case</span> <span class="token punctuation">(</span><span class="token operator">{</span>se1<span class="token punctuation">,</span>se2<span class="token operator">}</span><span class="token punctuation">)</span>            <span class="token number">2'b00</span> <span class="token punctuation">:</span> out <span class="token operator">=</span> din1<span class="token punctuation">;</span>            <span class="token number">2'b01</span> <span class="token punctuation">:</span> out <span class="token operator">=</span> din2<span class="token punctuation">;</span>            <span class="token number">2'b10</span> <span class="token punctuation">:</span> out <span class="token operator">=</span> din3<span class="token punctuation">;</span>            <span class="token number">2'b11</span> <span class="token punctuation">:</span> out <span class="token operator">=</span> din4<span class="token punctuation">;</span>        <span class="token keyword">endcase</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个 <code>always_comb</code> 过程语句的有四个输入信号以及两个选择信号, 任何一个发生变化, 输出都将发生变化. </p><h4 id="always-ff-过程语句"><a href="#always-ff-过程语句" class="headerlink" title="always_ff 过程语句"></a>always_ff 过程语句</h4><p>在实现时序逻辑的时候, 需要在上升沿或者下降沿事件中触发寄存器的更新. 在 SystemVerilog 中, 使用 <code>posedge</code> 指定上升沿, 使用 <code>negedge</code> 指定下降沿. 可以将边沿敏感类型的信号放置到 <code>always_ff</code>: </p><pre class="line-numbers language-none"><code class="language-none">always_ff @(posedge clk)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里响应的是一个时钟 <code>clk</code> 的上升沿信号, 时钟是驱动处理器执行的基础, 在进行综合的时候会综合出时序电路. </p><h3 id="begin-end-块语句"><a href="#begin-end-块语句" class="headerlink" title="begin/end 块语句"></a>begin/end 块语句</h3><p><code>begin/end</code> 能够将多条语句组合成语句块.</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> decoder2_4 <span class="token punctuation">(</span>    <span class="token keyword">input</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> in<span class="token punctuation">,</span>    <span class="token keyword">output</span> <span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> out<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token important">always_comb</span> <span class="token keyword">begin</span>        out <span class="token operator">=</span> <span class="token number">4'b0000</span><span class="token punctuation">;</span>        <span class="token function">case</span><span class="token punctuation">(</span>in<span class="token punctuation">)</span>            <span class="token number">2'b00</span> <span class="token punctuation">:</span> out <span class="token operator">=</span> <span class="token number">4'b0001</span><span class="token punctuation">;</span>            <span class="token number">2'b01</span> <span class="token punctuation">:</span> out <span class="token operator">=</span> <span class="token number">4'b0010</span><span class="token punctuation">;</span>            <span class="token number">2'b10</span> <span class="token punctuation">:</span> out <span class="token operator">=</span> <span class="token number">4'b0100</span><span class="token punctuation">;</span>            <span class="token number">2'b11</span> <span class="token punctuation">:</span> out <span class="token operator">=</span> <span class="token number">4'b1000</span><span class="token punctuation">;</span>        <span class="token keyword">endcase</span>    <span class="token keyword">end</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为需要一个初值, 在 <code>begin/end</code> 中有两条语句, 必须构造出一个语句块, 也往往被称为是串行块, 其含义就是 “顺序执行” 的. 在硬件综合完成之后, 各个部分的电信号就开始驱动整个硬件电路信号扩散, 并逐步稳定下来, 输出会随着输入的变化而随时变化. </p><h3 id="赋值语句"><a href="#赋值语句" class="headerlink" title="赋值语句"></a>赋值语句</h3><p>赋值语句可以将不同的信号组织起来, 包括了持续赋值语句和过程赋值语句. 持续赋值语句在过程外使用, 与过程语句并行执行. 过程赋值语句在过程内串行执行, 用于描述过程的功能.</p><h4 id="持续赋值语句"><a href="#持续赋值语句" class="headerlink" title="持续赋值语句"></a>持续赋值语句</h4><p>在 SystemVerilog 中使用 <code>assign</code> 作为持续赋值语句使用, 用于对 <code>wire</code> 类型的变量进行赋值. 其对应的硬件即通过对输出进行赋值, 当输入变化时, 经过一定延迟, 输出就会按照 <code>assign</code> 所描述的那样发生变化. 例如: </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">assign</span> res <span class="token operator">=</span> input_a <span class="token operator">&amp;</span> input_b<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在一个模块中, 可以有多个 <code>assign</code> 的持续赋值语句并行执行. 一个模块的持续赋值语句和前面所说的 <code>always</code> 过程语句可以出现多次, 执行关系也是并行的.</p><h4 id="过程赋值语句"><a href="#过程赋值语句" class="headerlink" title="过程赋值语句"></a>过程赋值语句</h4><p>在 <code>always</code> 过程里面的赋值语句被称为过程赋值语句, 一般用来对 <code>reg</code> 类型的变量进行赋值. 一个是非阻塞赋值语句 <code>&lt;=</code>, 一个是阻塞赋值语句 <code>=</code>. 之间的区别是: </p><ul><li>非阻塞赋值语句 <code>&lt;=</code> 不立即更新被赋值的信号, 等到整个过程块结束时才更新. 由于不是立即发生的, 在过程内仿佛这条语句不存在一样. 在这个执行的过程中, 所有的左值会维持不变, 反映了时钟边沿触发的寄存器的行为特征, 在 <code>always_ff</code> 中需要采用非阻塞赋值. </li></ul><ol><li>阻塞赋值语句 <code>=</code> 立即完成赋值操作, 左值立刻发生变化. 一个块语句中存在多条阻塞赋值语句, 会按照先后顺序关系执行. 这种行为模式和网络 IO 编程中的阻塞函数调用方式一样, 完成函数执行之后调用才会退出. 这种特性可以用来直观描述组合逻辑的行为特征, 在 <code>always_comb</code> 中需要采用阻塞赋值.</li></ol><p>非阻塞赋值要比阻塞赋值多加一个触发器, 因为信号的变化不是同步的, 需要进行一个周期的延迟. </p><h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><p>在 SystemVerilog 中, 条件语句包括了 <code>if-else</code> 语句以及 <code>case</code> 语句.</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> decoder2_4 <span class="token punctuation">(</span>    <span class="token keyword">input</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> din<span class="token punctuation">,</span>    <span class="token keyword">output</span> <span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> dout<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token important">always_comb</span> <span class="token keyword">begin</span>        dout <span class="token operator">=</span> <span class="token number">4'b0000</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>din <span class="token operator">==</span> <span class="token number">2'b00</span><span class="token punctuation">)</span>            dout <span class="token operator">=</span> <span class="token number">4'b0001</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>din <span class="token operator">==</span> <span class="token number">2'b01</span><span class="token punctuation">)</span>            dout <span class="token operator">=</span> <span class="token number">4'b0010</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>din <span class="token operator">==</span> <span class="token number">2'b10</span><span class="token punctuation">)</span>            dout <span class="token operator">=</span> <span class="token number">4'b0100</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>din <span class="token operator">==</span> <span class="token number">2'b11</span><span class="token punctuation">)</span>            dout <span class="token operator">=</span> <span class="token number">4'b1000</span><span class="token punctuation">;</span>    <span class="token keyword">end</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 SystemVerilog 中也提供了 <code>case</code> 这样的条件判断语句, 避免使用过多的 if-else 进行编写.</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">case</span> <span class="token punctuation">(</span>敏感表达式<span class="token punctuation">)</span>    条件判断<span class="token number">1</span><span class="token punctuation">:</span> 语句<span class="token number">1</span><span class="token punctuation">;</span>     条件判断<span class="token number">2</span><span class="token punctuation">:</span> 语句<span class="token number">2</span><span class="token punctuation">;</span>     <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    条件判断n<span class="token punctuation">:</span> 语句n<span class="token punctuation">;</span>    <span class="token keyword">default</span><span class="token punctuation">:</span> 语句n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">endcase</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里语句不需要插入 <code>break</code>, 在语句执行完成后, 直接跳出了 case 语句本身, 这样的行为模式对于程序员来说更加友好. </p><h3 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h3><p>SystemVerilog 中也存在循环语句. 可综合的循环语句为 <code>for</code> 语句. 循环语句不容易直观想象得出综合之后的效果, 描述的功能更加高层和抽象, 转化为硬件的难度会更大. 其它三个循环语句分别为 <code>forever</code> 语句, <code>repeat</code> 语句, <code>while</code> 语句. 其中 <code>forever</code> 语句会连续执行语句, 主要在仿真中使用, 生成周期性的波形 (时钟信号). </p><p><code>repeat</code> 语句: </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token function">repeat</span><span class="token punctuation">(</span>循环次数的表达式<span class="token punctuation">)</span><span class="token keyword">begin</span>    语句或者语句块<span class="token keyword">end</span> <span class="token comment">// 单个语句不需要 begin 和 end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><code>while</code> 语句: </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token function">while</span><span class="token punctuation">(</span>循环执行的条件表达式<span class="token punctuation">)</span><span class="token keyword">begin</span>    语句或者语句块<span class="token keyword">end</span> <span class="token comment">// 单个语句不需要 begin 和 end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><code>repeat</code> 和 <code>while</code> 往往不可综合, 编写代码时尽量使用 <code>for</code> 语句来实现循环.</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> for_adder <span class="token punctuation">(</span>    <span class="token keyword">input</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span>    <span class="token keyword">input</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> b<span class="token punctuation">,</span>    <span class="token keyword">input</span> cin<span class="token punctuation">,</span>    <span class="token keyword">output</span> <span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> sum<span class="token punctuation">,</span>    <span class="token keyword">output</span> <span class="token keyword">reg</span> cout<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">reg</span> c<span class="token punctuation">;</span>    <span class="token keyword">integer</span> i<span class="token punctuation">;</span>    <span class="token important">always_comb</span> <span class="token keyword">begin</span>        c <span class="token operator">=</span> cin<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">8</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>            <span class="token operator">{</span>c<span class="token punctuation">,</span>sum<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">}</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> b<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> c<span class="token punctuation">;</span>        <span class="token keyword">end</span>        cout <span class="token operator">=</span> c<span class="token punctuation">;</span>    <span class="token keyword">end</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这是一个功能描述的代码, 描述层次比较抽象, 不是功能设计的代码. </p><h2 id="SystemVerilog-的设计层次与风格"><a href="#SystemVerilog-的设计层次与风格" class="headerlink" title="SystemVerilog 的设计层次与风格"></a>SystemVerilog 的设计层次与风格</h2><p>SystemVerilog 的语言有很大的灵活性, 对于相同的电路可以有不同的设计方法. 一个 1 位全加器的输入包括 1 位的低位进位 <code>cin</code>, 两个 1 位的输入信号 <code>a</code> 和 <code>b</code>, 输出则包括了一个当前位的和 <code>sum</code> 以及向高位的进位 <code>cout</code>. 从 1 位全加器的真值表可以获得逻辑表达式 (这里只使用与或非门的表达): </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">CarryOut</span><span class="token operator">=</span><span class="token punctuation">(</span>¬A*B*CarryIn<span class="token punctuation">)</span>+<span class="token punctuation">(</span>A*¬B*CarryIn<span class="token punctuation">)</span>+<span class="token punctuation">(</span>A*B*¬CarryIn<span class="token punctuation">)</span>+<span class="token punctuation">(</span>A*B*CarryIn<span class="token punctuation">)</span><span class="token operator">=</span><span class="token punctuation">(</span>B*CarryIn<span class="token punctuation">)</span>+<span class="token punctuation">(</span>A*CarryIn<span class="token punctuation">)</span>+<span class="token punctuation">(</span>A*B<span class="token punctuation">)</span><span class="token assign-left variable">Sum</span><span class="token operator">=</span><span class="token punctuation">(</span>¬A*¬B*CarryIn<span class="token punctuation">)</span>+<span class="token punctuation">(</span>¬A*B*¬CarryIn<span class="token punctuation">)</span>+<span class="token punctuation">(</span>A*¬B*¬CarryIn<span class="token punctuation">)</span>+<span class="token punctuation">(</span>A*B*CarryIn<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>很容易获得 1 位全加器的电路表达形式: </p><p><img src="/pic/192.png" alt=""></p><p>在上述的电路中, 使用了三个非门 <code>not</code>, 四个 3 输入的与门 <code>and</code>, 三个 2 输入的与门 <code>and</code>, 一个 4 输入的或门 <code>or</code>, 一个 3 输入的或门 <code>or</code>. 这里的非门, 与门和或门都是 SystemVerilog 中内置的门电路, 可以直接构造出 SystemVerilog 的结构描述. </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> full_adder1 <span class="token punctuation">(</span>    <span class="token keyword">input</span> a<span class="token punctuation">,</span>    <span class="token keyword">input</span> b<span class="token punctuation">,</span>    <span class="token keyword">input</span> cin<span class="token punctuation">,</span>    <span class="token keyword">output</span> sum<span class="token punctuation">,</span>    <span class="token keyword">output</span> cout<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">wire</span> a_n<span class="token punctuation">,</span> b_n<span class="token punctuation">,</span> cin_n<span class="token punctuation">,</span> sum_p1<span class="token punctuation">,</span>sum_p2<span class="token punctuation">,</span>sum_p3<span class="token punctuation">,</span>sum_p4<span class="token punctuation">,</span> cout_p1<span class="token punctuation">,</span> cout_p2<span class="token punctuation">,</span> cout_p3<span class="token punctuation">;</span>    <span class="token function">not</span><span class="token punctuation">(</span>a_n<span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span>b_n<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span>cin_n<span class="token punctuation">,</span>cin<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">and</span><span class="token punctuation">(</span>sum_p1<span class="token punctuation">,</span>a_n<span class="token punctuation">,</span>b_n<span class="token punctuation">,</span>cin<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span>sum_p2<span class="token punctuation">,</span>a_n<span class="token punctuation">,</span>b<span class="token punctuation">,</span>cin_n<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span>sum_p3<span class="token punctuation">,</span>a<span class="token punctuation">,</span>b_n<span class="token punctuation">,</span>cin_n<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span>sum_p4<span class="token punctuation">,</span>a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>cin<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span>cout_p1<span class="token punctuation">,</span>b<span class="token punctuation">,</span>cin<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span>cout_p2<span class="token punctuation">,</span>a<span class="token punctuation">,</span>cin<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span>cout_p3<span class="token punctuation">,</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">or</span><span class="token punctuation">(</span>sum<span class="token punctuation">,</span>sum_p1<span class="token punctuation">,</span>sum_p2<span class="token punctuation">,</span>sum_p3<span class="token punctuation">,</span>sum_p4<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span>cout<span class="token punctuation">,</span>cout_p1<span class="token punctuation">,</span>cout_p2<span class="token punctuation">,</span>cout_p3<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>门级结构描述虽然不是最底层的描述 (晶体管搭建), 但是已经非常接近, 可以使用元件进行直接映射. 这种方法一般用于设计比较简单或者高效的工作电路, 方便综合器直接进行综合.</p><p>门级结构描述虽然方便了底层的综合器, 但是对于编程来说不方便, 希望能够进行更加高层的设计, 一个选择是将上述的逻辑表达式写到程序里, 这是数据流描述方法. </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> full_adder1 <span class="token punctuation">(</span>    <span class="token keyword">input</span> a<span class="token punctuation">,</span>    <span class="token keyword">input</span> b<span class="token punctuation">,</span>    <span class="token keyword">input</span> cin<span class="token punctuation">,</span>    <span class="token keyword">output</span> sum<span class="token punctuation">,</span>    <span class="token keyword">output</span> cout<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">assign</span> sum <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">~</span>a<span class="token operator">&amp;~</span>b<span class="token operator">&amp;</span>cin<span class="token punctuation">)</span><span class="token operator">|</span><span class="token punctuation">(</span><span class="token operator">~</span>a<span class="token operator">&amp;</span>b<span class="token operator">&amp;~</span>cin<span class="token punctuation">)</span><span class="token operator">|</span><span class="token punctuation">(</span>a<span class="token operator">&amp;~</span>b<span class="token operator">&amp;~</span>cin<span class="token punctuation">)</span><span class="token operator">|</span><span class="token punctuation">(</span>a<span class="token operator">&amp;</span>b<span class="token operator">&amp;</span>cin<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">assign</span> cout <span class="token operator">=</span> <span class="token punctuation">(</span>b<span class="token operator">&amp;</span>cin<span class="token punctuation">)</span><span class="token operator">|</span><span class="token punctuation">(</span>a<span class="token operator">&amp;</span>cin<span class="token punctuation">)</span><span class="token operator">|</span><span class="token punctuation">(</span>a<span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>数据流描述方法描述了组合逻辑中, 输出是如何随着输入数据的变化而变化, 使用持续赋值语句 <code>assign</code>. 但是, 数据流描述的抽象层次还不是很高, 对于复杂的硬件逻辑设计来说, 使用行为级描述, 即直接描述出硬件所需要完成的功能更为妥当. </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> full_adder1 <span class="token punctuation">(</span>    <span class="token keyword">input</span> a<span class="token punctuation">,</span>    <span class="token keyword">input</span> b<span class="token punctuation">,</span>    <span class="token keyword">input</span> cin<span class="token punctuation">,</span>    <span class="token keyword">output</span> <span class="token keyword">reg</span> sum<span class="token punctuation">,</span>    <span class="token keyword">output</span> <span class="token keyword">reg</span> cout<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token important">always_comb</span> <span class="token keyword">begin</span>        <span class="token operator">{</span>cout<span class="token punctuation">,</span>sum<span class="token operator">}=</span>a<span class="token operator">+</span>b<span class="token operator">+</span>cin<span class="token punctuation">;</span>    <span class="token keyword">end</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从行为级描述中看不到电路怎样使用元件以及怎样布线, 但是完整描述了一个全加器所需要完成的功能. </p><p>在设计更加大型的硬件电路的时候, 使用结构级描述是必不可少的. 可以设计一些小型电路模块, 通过结构描述设计出规模更大的电路. 通过设计 4 位的加法器来说明: </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> full_adder4 <span class="token punctuation">(</span>    <span class="token keyword">input</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span>    <span class="token keyword">input</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> b<span class="token punctuation">,</span>    <span class="token keyword">input</span> cin<span class="token punctuation">,</span>    <span class="token keyword">output</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> sum<span class="token punctuation">,</span>    <span class="token keyword">output</span> cout<span class="token punctuation">)</span><span class="token punctuation">;</span>    full_adder1 <span class="token function">a0</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>b<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>cin<span class="token punctuation">,</span>sum<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>cin1<span class="token punctuation">)</span><span class="token punctuation">;</span>    full_adder1 <span class="token function">a1</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>b<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>cin1sum<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>cin2<span class="token punctuation">)</span><span class="token punctuation">;</span>    full_adder1 <span class="token function">a2</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span>b<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span>cin2sum<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span>cin3<span class="token punctuation">)</span><span class="token punctuation">;</span>    full_adder1 <span class="token function">a3</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span>b<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span>cin3sum<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span>cout<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在实际进行硬件设计的时候, 出发点还是自顶向下, 对硬件总体先分成多个互相独立的模块, 然后定义之间的连线关系, 连线关系即是它们之间的接口, 最终完成的硬件通过结构描述方式将模块连接在一起. </p><h2 id="一些编程建议与经验"><a href="#一些编程建议与经验" class="headerlink" title="一些编程建议与经验"></a>一些编程建议与经验</h2><h3 id="default-nettype-none"><a href="#default-nettype-none" class="headerlink" title="`default_nettype none"></a><code>`default_nettype none</code></h3><p>SystemVerilog 中没有被定义的标记 label 都被默认为是 <code>wire</code> 类型的, 建议的做法是 <code>`default_nettype none</code>. 这可以防止在信号名字上出现的拼写错误. </p><h3 id="锁相环电路"><a href="#锁相环电路" class="headerlink" title="锁相环电路"></a>锁相环电路</h3><p>PLL 是 FPGA 上专用的时钟生成模块, 内部是模拟电路. PLL 在启动时需要一段时间才能进入稳定状态, <code>locked</code> 信号输出表示稳定. 在锁相环电路稳定输出之后, <code>locked</code> 信号会被置位, 此时可以进行电路寄存器初始化. </p><h3 id="调时序"><a href="#调时序" class="headerlink" title="调时序"></a>调时序</h3><p>硬件编程是仿真驱动的, 比较难的部分是调时序, 使各个部分的时序相互匹配, 同时满足对于外设的时间要求. 不同模块之间由于寄存器的关系有相位差, 需要增加几个空的状态机节拍, 匹配不同路径的信号传播. </p><h3 id="阻塞赋值语句和非阻塞赋值语句"><a href="#阻塞赋值语句和非阻塞赋值语句" class="headerlink" title="阻塞赋值语句和非阻塞赋值语句"></a>阻塞赋值语句和非阻塞赋值语句</h3><p>一般来说, 组合逻辑用 <code>=</code>, 时序逻辑用 <code>&lt;=</code>. <code>wire</code> 和 <code>reg</code> 是语法层面的内容, <code>assign</code> 的左值必须是 <code>wire</code>, <code>always</code> 里的左值必须是 <code>reg</code>, 否则综合会报错. 是否综合成触发器, 根据有没有时钟信号决定. 综合器通过 <code>posedge</code> 的描述方法知道对应的模块里面需要响应 <code>posedge</code> 或是 <code>negedge</code>, 从而综合出触发器. 尽量使用 <code>logic</code> 类型并匹配 <code>always_comb</code> 和 <code>always_ff</code> 来分别描述组合逻辑和时序逻辑.</p><h3 id="程序的可读性"><a href="#程序的可读性" class="headerlink" title="程序的可读性"></a>程序的可读性</h3><p>增加程序的可维护性, 在选择信号名称的时候需要按照名称选择的惯例, 有一些命名方法是常用的.</p><ul><li><code>_i</code>, <code>_o</code>, 分别代表一个模块的输入信号和输出信号. </li><li><code>n</code> 或者 <code>_n</code> 为后缀, 表明这个信号是 0 使能, 0 表示有效. </li><li><code>clk</code>, <code>clock</code> 时钟信号, 后面或者前面接上频率, 可以显示时钟信号的频率. </li><li><code>rst</code>, <code>reset</code> 复位信号, 使得信号可以重置, 一般在重置响应中写入状态机的初值. </li><li><code>we</code>, <code>write enable</code> 信号, 对应于模块的写入使能. </li><li><code>oe</code>, <code>output enable</code> 信号, 对应于模块的输出使能. </li><li><code>ce</code>, <code>chip enable</code>, 对应于模块的总体使能信号. 上述的信号几乎在所有的模块中都会有 (注意信号是正向的还是反向的, 即 1 使能还是 0 使能. 0 使能会在信号名称的上面带有横线).</li><li><code>select</code>, <code>sel</code> 信号, 一般用于对芯片的选择. </li></ul><h3 id="代码检查工具"><a href="#代码检查工具" class="headerlink" title="代码检查工具"></a>代码检查工具</h3><p><a href="https://www.veripool.org/">这个网址</a>中有一些 SystemVerilog 的工具可供参考. 使用</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">verilator --lint-only <span class="token parameter variable">-Wall</span> <span class="token punctuation">[</span>source_files.v<span class="token punctuation">]</span><span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以帮助做一些检查. </p><h3 id="一些特殊的语法点"><a href="#一些特殊的语法点" class="headerlink" title="一些特殊的语法点"></a>一些特殊的语法点</h3><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog">ram_address <span class="token operator">=</span> pc<span class="token punctuation">[</span><span class="token number">2</span><span class="token operator">+</span><span class="token punctuation">:</span><span class="token number">21</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>从第 2 位开始的 21 位, 把最后两位去掉. 也可以写成 <code>pc[22-:21]</code> 或 <code>pc[22:2]</code>. </p><h3 id="case-语句可能出现错误的情况"><a href="#case-语句可能出现错误的情况" class="headerlink" title="case 语句可能出现错误的情况:"></a>case 语句可能出现错误的情况:</h3><p>使用 <code>case</code> 的时候把所有信号在所有情况下写全, 或者灵活使用阻塞赋值语句 <code>=</code>, 在过程最前面的时候先进行赋值. </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token important">always_comb</span> <span class="token keyword">begin</span>    ram_we_n <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>    ram_oe_n <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>    ram_address <span class="token operator">=</span> <span class="token number">21'h0</span><span class="token punctuation">;</span>    <span class="token keyword">case</span> <span class="token punctuation">(</span>state<span class="token punctuation">)</span>        STATE_FETCH<span class="token punctuation">:</span> <span class="token keyword">begin</span>            ram_oe_n <span class="token operator">=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span>            ram_address <span class="token operator">=</span> pc<span class="token punctuation">[</span><span class="token number">22</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">end</span>        STATE_MEM<span class="token punctuation">:</span> <span class="token keyword">begin</span>            ram_oe_n <span class="token operator">=</span> mem_op_write<span class="token punctuation">;</span>            ram_we_n <span class="token operator">=</span> <span class="token operator">~</span>mem_op_write<span class="token punctuation">;</span>            ram_address <span class="token operator">=</span> ex_val_o<span class="token punctuation">[</span><span class="token number">22</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>         <span class="token keyword">end</span>    <span class="token keyword">endcase</span><span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面的 case 语句代码块也是正确的: </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token important">always_comb</span> <span class="token keyword">begin</span>    <span class="token keyword">case</span> <span class="token punctuation">(</span>state<span class="token punctuation">)</span>        STATE_FETCH<span class="token punctuation">:</span> <span class="token keyword">begin</span>            ram_oe_n <span class="token operator">=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span>            ram_we_n <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>            ram_address <span class="token operator">=</span> pc<span class="token punctuation">[</span><span class="token number">22</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">end</span>        STATE_MEM<span class="token punctuation">:</span> <span class="token keyword">begin</span>            ram_oe_n <span class="token operator">=</span> mem_op_write<span class="token punctuation">;</span>            ram_we_n <span class="token operator">=</span> <span class="token operator">~</span>mem_op_write<span class="token punctuation">;</span>            ram_address <span class="token operator">=</span> ex_val_o<span class="token punctuation">[</span><span class="token number">22</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>         <span class="token keyword">end</span>        <span class="token keyword">default</span><span class="token punctuation">:</span> <span class="token keyword">begin</span>            ram_oe_n <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>            ram_we_n <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>            ram_address <span class="token operator">=</span> <span class="token number">21'h0</span><span class="token punctuation">;</span>        <span class="token keyword">end</span>    <span class="token keyword">endcase</span><span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是下面的 case 语句代码块是错误的.</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token important">always_comb</span> <span class="token keyword">begin</span>    <span class="token keyword">case</span> <span class="token punctuation">(</span>state<span class="token punctuation">)</span>        STATE_FETCH<span class="token punctuation">:</span> <span class="token keyword">begin</span>            ram_oe_n <span class="token operator">=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span>            ram_address <span class="token operator">=</span> pc<span class="token punctuation">[</span><span class="token number">22</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">end</span>        STATE_MEM<span class="token punctuation">:</span> <span class="token keyword">begin</span>            ram_oe_n <span class="token operator">=</span> mem_op_write<span class="token punctuation">;</span>            ram_we_n <span class="token operator">=</span> <span class="token operator">~</span>mem_op_write<span class="token punctuation">;</span>            ram_address <span class="token operator">=</span> ex_val_o<span class="token punctuation">[</span><span class="token number">22</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>         <span class="token keyword">end</span>        <span class="token keyword">default</span><span class="token punctuation">:</span> <span class="token keyword">begin</span>            ram_oe_n <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>            ram_we_n <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>            ram_address <span class="token operator">=</span> <span class="token number">21'h0</span><span class="token punctuation">;</span>        <span class="token keyword">end</span>    <span class="token keyword">endcase</span><span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Warning-empty-statement-in-sequential-block"><a href="#Warning-empty-statement-in-sequential-block" class="headerlink" title="Warning: empty statement in sequential block"></a>Warning: empty statement in sequential block</h3><p>两个分号放在一起 <code>;;</code> 就会出现这个警告. 一个容易出现的错误是在信号常数定义 <code>`define</code> 的时候, 在信号后面跟了一个分号, 在模块代码里面直接使用的时候就会出现上面的情况. </p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;SystemVerilog入门使用&quot;&gt;&lt;a href=&quot;#SystemVerilog入门使用&quot; class=&quot;headerlink&quot; title=&quot;SystemVerilog入门使用&quot;&gt;&lt;/a&gt;SystemVerilog入门使用&lt;/h1&gt;&lt;h2</summary>
        
      
    
    
    
    <category term="CS" scheme="http://chengsx21.github.io/categories/CS/"/>
    
    <category term="COD" scheme="http://chengsx21.github.io/categories/CS/COD/"/>
    
    
    <category term="COD" scheme="http://chengsx21.github.io/tags/COD/"/>
    
    <category term="SV" scheme="http://chengsx21.github.io/tags/SV/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成原理 笔记2</title>
    <link href="http://chengsx21.github.io/2023/09/23/risc-v-jian-kong-cheng-xu/"/>
    <id>http://chengsx21.github.io/2023/09/23/risc-v-jian-kong-cheng-xu/</id>
    <published>2023-09-23T09:18:57.000Z</published>
    <updated>2023-09-27T12:38:30.718Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RISC-V-监控程序"><a href="#RISC-V-监控程序" class="headerlink" title="RISC-V 监控程序"></a>RISC-V 监控程序</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong>Thinpad</strong> 教学计算机搭配了监控程序, 能够接受用户命令, 支持输入汇编指令并运行, 查看寄存器及内存状态. 监控程序可在实现的 32/64 位 <strong>RISC-V</strong> CPU 上运行, 一方面帮助理解、掌握 RISC-V 指令系统及其软件开发, 另一方面作为验证 CPU 功能正确性的标准. </p><p>监控程序分为 <strong>Kernel</strong> 和 <strong>Term</strong> 两个部分. 其中 Kernel 使用 RISC-V 汇编语言编写, 运行在 Thinpad 上学生实现的 <strong>CPU</strong> 中, 用于<strong>管理硬件资源</strong>; Term 是上位机程序, 使用 Python 语言编写, 有基于命令行的用户界面, 达到与<strong>用户交互</strong>的目的. Kernel 和 Term 直接通过串口通信, 即用户在 Term 界面中输入的命令、代码经过 Term 处理后, 通过串口传输给 Kernel 程序; 反过来, Kernel 输出的信息也会通过串口传输到 Term 并展示给用户. </p><h2 id="Kernel"><a href="#Kernel" class="headerlink" title="Kernel"></a>Kernel</h2><p>Kernel 使用汇编语言编写, 使用到的指令有 20 余条, 均符合 RISC-V 规范. Kernel 提供了三种不同的版本, 以适应不同的档次的 CPU 实现: 第一档为<strong>基础版本</strong>, 直接基本的 I/O 和命令执行功能, 不依赖异常、中断、csr 等处理器特征, 适合于最简单的 CPU 实现; 第二档<strong>支持中断</strong>, 使用中断方式完成串口的 I/O 功能, 需要处理器实现中断处理机制, 及相关的 csr 寄存器; 第三档进一步增加了<strong>页表的应用</strong>, 要求处理器支持基于 Sv32 或者 Sv39 的内存映射, 更加接近于操作系统对处理器的需求. </p><p>为了在硬件上运行 Kernel 程序, 我们首先要对 Kernel 的汇编代码进行编译. 在 <code>kernel</code> 文件夹下面, 有汇编代码和 Makefile 文件, 我们可以使用 make 工具编译 Kernel 程序. 假设当前目录为 <code>kernel</code> , 目标版本为基础版本, 在终端中运行命令:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">make</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>即可开始编译流程. 如果顺利结束, 将生成 <code>kernel.elf</code> 和 <code>kernel.bin</code> 文件, 即可执行文件. 要在模拟器中运行它, 可以使用命令:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">make</span> sim<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>它会在 <strong>QEMU</strong> 中启动监控程序, 并等待 Term 程序连接. 本文后续章节介绍了如何使用 Term 连接模拟器. 需要注意的是, 如果需要打开一些开关, 需要在每条命令中传递参数, 比如:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">make</span> <span class="token assign-left variable">EN_INT</span><span class="token operator">=</span>y sim<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>而不是</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">make</span> <span class="token assign-left variable">EN_INT</span><span class="token operator">=</span>y<span class="token function">make</span> sim<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>目前所有可能出现的开关有: </p><ol><li><code>EN_INT</code>: 打开中断、异常和用户态支持, 默认关闭. </li><li><code>EN_PAGING</code>: 打开页表支持, 要求 <code>EN_INT</code> 已打开, 默认关闭. </li><li><code>EN_FENCEI</code>: 如果实现了 L1 Cache 并且分离了 I Cache 和 D Cache 则应当开启, 在写入代码后执行 <code>FENCE.I</code> 指令, 默认关闭. </li><li><code>EN_UART16550</code>: 如果实现了 UART 16550 兼容的串口控制器则要开启, 否则可以关闭, 默认开启. </li></ol><p>若要在硬件上运行, 使用开发板提供的工具, 将 <code>kernel.bin</code> 写入内存 0x80000000 地址位置, 并让处理器复位从 0x80000000 地址处开始执行, Kernel 就运行起来了. </p><p>Kernel 运行后会先通过串口输出版本号, 该功能可作为检验其正常运行的标志. 之后 Kernel 将等待 Term 从串口发来的命令, 关于 Term 的使用将在后续章节描述.  </p><h3 id="基础版本"><a href="#基础版本" class="headerlink" title="基础版本"></a>基础版本</h3><p>基础版本的 Kernel 共使用了 19 条不同的指令, 它们是: </p><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">ADD   0000000SSSSSsssss000ddddd0110011ADDI  iiiiiiiiiiiisssss000ddddd0010011AND   0000000SSSSSsssss111ddddd0110011ANDI  iiiiiiiiiiiisssss111ddddd0010011AUIPC iiiiiiiiiiiiiiiiiiiiddddd0010111BEQ   iiiiiiiSSSSSsssss000iiiii1100011BNE   iiiiiiiSSSSSsssss001iiiii1100011JAL   iiiiiiiiiiiiiiiiiiiiddddd1101111JALR  iiiiiiiiiiiisssss000ddddd1100111LB    iiiiiiiiiiiisssss000ddddd0000011LUI   iiiiiiiiiiiiiiiiiiiiddddd0110111LW    iiiiiiiiiiiisssss010ddddd0000011OR    0000000SSSSSsssss110ddddd0110011ORI   iiiiiiiiiiiisssss110ddddd0010011SB    iiiiiiiSSSSSsssss000iiiii0100011SLLI  0000000iiiiisssss001ddddd0010011SRLI  0000000iiiiisssss101ddddd0010011SW    iiiiiiiSSSSSsssss010iiiii0100011XOR   0000000SSSSSsssss100ddddd0110011<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果实现的是 RISC-V 64 位, 则额外需要实现以下指令: </p><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">ADDIW iiiiiiiiiiiisssss000ddddd0011011LD    iiiiiiiiiiiisssss011ddddd0000011SD    iiiiiiiSSSSSsssss011iiiii0100011<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在以上指令里面, 很多指令的功能是相近的, 分类以后, 实际上只需要实现如下的几种指令, 然后很容易就可以扩展到其它指令:</p><pre class="line-numbers language-none"><code class="language-none">ADD: ADDI, AND, ANDI, OR, ORI, SLLI, SRLI, XOR, ADDIWAUIPC:BEQ: BNEJAL:JALR:LB: LW, LDLUI:SB: SW, SD<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实际上只需要实现上面的八条指令, 简单扩展即可实现需要的所有指令. 根据 RISC-V 规范正确实现这些指令后, 程序才能正常工作. </p><p>监控程序使用了 8 MB 的内存空间, 其中约 1 MB 由 Kernel 使用, 剩下的空间留给用户程序. 此外, 为了支持串口通信, 还设置了一个内存以外的地址区域, 用于串口收发. 具体内存地址的分配方法如下表所示: </p><div class="table-container"><table><thead><tr><th>地址区间</th><th>说明</th></tr></thead><tbody><tr><td>0x80000000-0x800FFFFF</td><td>监控程序代码</td></tr><tr><td>0x80100000-0x803FFFFF</td><td>用户程序代码</td></tr><tr><td>0x80400000-0x807EFFFF</td><td>用户程序数据</td></tr><tr><td>0x807F0000-0x807FFFFF</td><td>监控程序数据</td></tr><tr><td>0x10000000-0x10000007</td><td>串口数据及状态</td></tr></tbody></table></div><p>串口控制器按照 <a href="https://www.lammertbies.nl/comm/info/serial-uart">16550 UART 的寄存器</a> 的子集实现, 访问的代码位于 <code>kern/utils.S</code> , 其部分数据格式为:</p><div class="table-container"><table><thead><tr><th>地址</th><th>位</th><th>说明</th></tr></thead><tbody><tr><td>0x10000000</td><td>[7:0]</td><td>串口数据, 读、写地址分别表示串口接收、发送一个字节</td></tr><tr><td>0x10000005</td><td>[5]</td><td>只读, 为 1 时表示串口空闲, 可发送数据</td></tr><tr><td>0x10000005</td><td>[0]</td><td>只读, 为 1 时表示串口收到数据</td></tr></tbody></table></div><p>默认情况下还会按照 UART 16550 的初始化流程进行一些寄存器的配置. 在 QEMU 中运行的时候, 请保持 <code>EN_UART16550=y</code> 默认行为. 如果采用自定义的实现, 请设置 <code>EN_UART16550=n</code> 以去掉这些寄存器操作, 或者忽略掉这些操作 (但初始化时仍会输出额外字符, 因为 RBR THR 和 DLL 在同一个地址). 如果使用了 AXI UART16550 作为串口控制器, 请参考代码注释并修改 <code>kernel/include/serial.h</code> 中的常量, 并设置 <code>EN_UART16550=y</code>. </p><p>Kernel 的入口地址为 0x80000000, 对应汇编代码 <code>kern/init.S</code> 中的 <code>START:</code> 标签. 在完成必要的初始化流程后, Kernel 输出版本信息, 随后进入 shell 线程, 与用户交互. shell 线程会等待串口输入, 执行输入的命令, 并通过串口返回结果, 如此往复运行. </p><p>当收到启动用户程序的命令后, 用户线程代替 shell 线程的活动. 用户程序的寄存器, 保存在从 0x807F0000 开始的连续 <code>31*XLEN</code> 字节中, 依次对应 x1 到 x31 用户寄存器, 每次启动用户程序时从上述地址装载寄存器值, 用户程序运行结束后保存到上述地址. </p><h3 id="进阶一-中断和异常支持"><a href="#进阶一-中断和异常支持" class="headerlink" title="进阶一: 中断和异常支持"></a>进阶一: 中断和异常支持</h3><p>作为扩展功能之一, Kernel 支持中断方式的 I/O, 和 Syscall 功能. 要启用这一功能, 编译时的命令变为: </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">make</span> <span class="token assign-left variable">EN_INT</span><span class="token operator">=</span>y<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这一编译选项, 会使得代码编译时增加宏定义 <code>ENABLE_INT</code> , 从而使能中断相关的代码. 为支持中断, CPU 要额外实现以下指令</p><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">CSRRC  ccccccccccccsssss011ddddd1110011CSRRS  ccccccccccccsssss010ddddd1110011CSRRW  ccccccccccccsssss001ddddd1110011EBREAK 00000000000100000000000001110011ECALL  00000000000000000000000001110011MRET   00110000001000000000000001110011SLTU   0000000SSSSSsssss011ddddd0110011<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此外还需要实现 CSR 寄存器的这些字段: </p><ol><li><code>mtvec</code>: BASE, MODE</li><li><code>mscratch</code></li><li><code>mepc</code></li><li><code>mcause</code>: Interrupt, Exception Code</li><li><code>mstatus</code>: MPP</li><li><code>mie</code>: MTIE</li><li><code>mip</code>: MTIP</li></ol><p>CSR 寄存器字段功能定义见 RISC-V 特权态规范. 监控程序对于异常、中断的使用方式如下: </p><ul><li>入口函数 <code>EXCEPTION_HANDLER</code>, 根据异常号跳转至相应的异常处理程序. </li><li>初始化时设置 <code>mtvec = EXCEPTION_HANDLER</code>, 使用正常中断模式 (<code>MODE = DIRECT</code>); 如果不支持 <code>MODE = DIRECT</code> (利用 <code>mtvec</code> 的 <code>WARL</code> 判断), 则会使用向量中断模式 (<code>MODE = VECTORED</code>). </li><li>用户程序在 U-mode 中运行 (<code>mret</code> 时 <code>mstatus.MPP = 0</code>), 通过 <code>ebreak</code> 回到 M-mode, 在异常处理中跳回到 SHELL. </li><li>异常帧保存 31 个通用寄存器及 <code>mepc</code> 寄存器. </li><li>禁止发生嵌套异常. </li><li>支持 <code>SYS_putc</code> 系统调用, 调用方法参考 <code>UTEST_PUTC</code> 函数. 写串口忙等待, 与禁止嵌套异常不冲突. </li><li>当发生不能处理的中断时, 表示出现严重错误, 终止当前任务, 自行重启. 并且发送错误信号 0x80 提醒 Term. </li></ul><p>为了支持时钟中断, 还需要实现 CLINT 设备的两个 MMIO 寄存器: </p><div class="table-container"><table><thead><tr><th>地址</th><th>说明</th></tr></thead><tbody><tr><td>0x200BFF8</td><td>mtime, 64 位, 可读写. 表示当前时间</td></tr><tr><td>0x2004000</td><td>mtimecmp, 64 位, 可读写. 表示下次时钟中断时间</td></tr></tbody></table></div><p>在 CLINT 设备的实现中, 需要每隔固定时间将 <code>mtime</code> 的值 +1, 并且当 <code>mtime &gt;= mtimecmp</code> 时拉高时钟中断信号, 然后 CPU 核心将 <code>mip.MTIP</code> 置 1. 当 <code>mip.MTIP</code>, <code>mie.MTIE</code> 同时为 1, 且当前特权态下全局中断启用时, CPU 即触发时钟中断. </p><p>具体参见 RISC-V 特权态手册 <em>3.1.10 Machine Timer Registers (mtime and mtimecmp)</em>. 有了时钟中断以后, Kernel 就可以杀掉运行超时的用户程序. </p><h3 id="进阶二-页表支持"><a href="#进阶二-页表支持" class="headerlink" title="进阶二: 页表支持"></a>进阶二: 页表支持</h3><p>在支持异常处理的基础上, 可以进一步使能页表支持, 从而实现用户态地址映射. 要启用这一功能, 编译时的命令变为: </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">make</span> <span class="token assign-left variable">EN_INT</span><span class="token operator">=</span>y <span class="token assign-left variable">EN_PAGING</span><span class="token operator">=</span>y<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>CPU 需要额外实现以下指令</p><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">SFENCE.VMA  0001001SSSSSsssss000000001110011<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果没有实现 TLB, 可把 <code>SFENCE.VMA</code> 实现为 NOP. 此外还需要实现 csr 寄存器: </p><ol><li><code>satp</code>: MODE, PPN</li></ol><p>以及页表相关的几个异常, RV32 需要实现 Sv32 的页表格式, RV64 需要实现 Sv39 的页表格式. 为了简化, 实际的映射是线性映射, Sv32 映射的方式在下面给出: </p><ul><li>`va[0x00000000, 0x002FFFFF] = pa[0x80100000, 0x803FFFFF] DAGUX-RV 用户态代码</li><li>va[0x7FC10000, 0x7FFFFFFF] = pa[0x80400000, 0x807EFFFF] DAGU-WRV 用户态数据</li><li>va[0x80000000, 0x80000FFF] = pa[0x80000000, 0x80000FFF] DAGUX-RV 用于返回内核态</li><li>va[0x80001000, 0x80001FFF] = pa[0x80001000, 0x80001FFF] DAGUX-RV 用于运行 UTEST 程序 (CRYPTONIGHT 除外)</li><li>va[0x80100000, 0x80100FFF] = pa[0x80100000, 0x80100FFF] DAGUX-RV 方便测试</li></ul><p>Sv39 下为了实现的方便, 映射的地址比以上的地址区域更大一些: </p><ul><li>va[0x00000000, 0x002FFFFF] = pa[0x80100000, 0x803FFFFF] DAGUX-RV 用户态代码</li><li>va[0x7FC10000, 0x7FFFFFFF] = pa[0x80400000, 0x807EFFFF] DAGU-WRV 用户态数据</li><li>va[0x80000000, 0x801FFFFF] = pa[0x80000000, 0x801FFFFF] DAGUX-RV 用于返回内核态、运行 UTEST 程序和方便测试</li></ul><p>其它地址都未经映射, 访问则会引发异常. </p><p>初始化过程: </p><ol><li>根据 RV32 还是 RV64 选择 Sv32 或者 Sv39 的页表进行填写</li><li>将页表的物理地址写入 <code>satp</code> 并配置好模式, 启用 U-mode 下的页表映射机制. </li><li>通过 <code>sfence.vma</code> 指令刷新 TLB. </li><li>将用户栈指针设为 0x80000000. </li></ol><h2 id="Term"><a href="#Term" class="headerlink" title="Term"></a>Term</h2><p>Term 程序运行在实验者电脑上, 提供监控程序交互界面. Term 支持以下命令: </p><ul><li><code>R</code>: 按照 x1 至 x31 的顺序返回用户程序寄存器值. </li><li><code>D</code>: 显示从指定地址开始的一段内存区域中的数据. </li><li><code>A</code>: 用户输入汇编指令, 并放置到指定地址上. </li><li><code>F</code>: 从文件读入汇编指令并放置到指定地址上, 格式与 A 命令相同. </li><li><code>U</code>: 从指定地址读取一定长度的数据, 并显示反汇编结果. </li><li><code>G</code>: 执行指定地址的用户程序. </li><li><code>T</code>: 查看页表内容, 仅在启用页表时有效. </li><li><code>Q</code>: 退出 Term. </li></ul><p>利用这些命令, 实验者可以输入一段汇编程序, 检查数据是否正确写入, 并让程序在处理器上运行验证. Term 程序位于 <code>term</code> 文件夹中, 可执行文件为 <code>term.py</code> . 对于本地的 Thinpad, 运行程序时用 <code>-s</code> 选项指定串口. 例如: </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">python term.py <span class="token parameter variable">-s</span> COM3<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">python term.py <span class="token parameter variable">-s</span> /dev/ttyACM0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>连接远程实验平台 Thinpad 或 QEMU 模拟器时, 使用 -t 选项指定 IP 和端口. 如: </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">python term.py <span class="token parameter variable">-t</span> <span class="token number">127.0</span>.0.1:6666<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="测试程序"><a href="#测试程序" class="headerlink" title="测试程序"></a>测试程序</h3><p>监控程序附带了几个测试程序, 代码见 <code>kern/test.S</code> . 可以通过命令</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">make</span> <span class="token assign-left variable">EN_XXX</span><span class="token operator">=</span>y show-utest<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>来查看测试程序入口地址. 记下这些地址, 并在 Term 中使用 <code>G</code> 命令运行它们. </p><ul><li><p><code>CRYPTONIGHT</code> 测试模仿了 CryptoNight 算法, 它会进行很多次的随机访存, 数据缓存命中率会很低. 运行结束后, 寄存器 <code>t0</code> 保存的是最终结果, 32 位下应该是 <code>a2e31a85</code>, 64 位下应该是 <code>ffffffff861c65d4</code>. </p></li><li><p><code>SPIN</code> 测试是一个死循环, 用来测试时钟中断能否正确杀掉超时程序. </p></li></ul><h3 id="用户程序编写"><a href="#用户程序编写" class="headerlink" title="用户程序编写"></a>用户程序编写</h3><p>根据监控程序设计, 用户程序的代码区为 0x80100000-0x803FFFFF, 实验时需要把用户程序写入这一区域. 用户程序的最后需要以 <code>jr ra</code> 结束, 保证正确返回监控程序. </p><p>在输入用户程序的过程中, 可以用汇编指令, 可以直接写 16 进制的机器码, 还可以写 label (见以下例子中 <code>loop:</code>). 以下是一次输入用户程序并运行的过程演示: </p><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">connecting to 127.0.0.1:6666...connectedrunning in 32bit, xlen = 4&gt;&gt; aaddr: 0x80100000one instruction per line, empty line to end.[0x80100000] li a0, 5[0x80100004] li t0, 0[0x80100008] 00000313[0x8010000c] loop:[0x8010000c] add t1, t1, t0[0x80100010] addi t0, t0, 1[0x80100014] bne a0, t0, loop[0x80100018] jr ra[0x8010001c]&gt;&gt; uaddr: 0x80100000num: 320x80100000:00500513lia0,50x80100004: 00000293lit0,00x80100008: 00000313lit1,00x8010000c: 00530333addt1,t1,t00x80100010: 00128293addit0,t0,10x80100014: fe551ce3bnea0,t0,0x8010000c0x80100018: 00008067ret0x8010001c: 00000000...&gt;&gt; gaddr: 0x80100000elapsed time: 0.000s&gt;&gt; rR1 (ra)    = 0x80000414R2 (sp)    = 0x807fff00R3 (gp)    = 0x00000000R4 (tp)    = 0x00000000R5 (t0)    = 0x00000005R6 (t1)    = 0x0000000aR7 (t2)    = 0x00000000R8 (s0/fp) = 0x80000000R9 (s1)    = 0x00000000R10(a0)    = 0x00000005R11(a1)    = 0x00000000R12(a2)    = 0x00000000R13(a3)    = 0x00000000R14(a4)    = 0x00000000R15(a5)    = 0x00000000R16(a6)    = 0x00000000R17(a7)    = 0x00000000R18(s2)    = 0x00000000R19(s3)    = 0x00000000R20(s4)    = 0x00000000R21(s5)    = 0x00000000R22(s6)    = 0x00000000R23(s7)    = 0x00000000R24(s8)    = 0x00000000R25(s9)    = 0x00000000R26(s10)   = 0x80100000R27(s11)   = 0x00000000R28(t3)    = 0x00000000R29(t4)    = 0x00000000R30(t5)    = 0x00000000R31(t6)    = 0x00000000&gt;&gt; q<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当处理器和 Kernel 支持异常功能时 (即上文所述 <code>EN_INT=y</code>), 用户还可以用 Syscall 的方式打印字符. 打印字符的系统调用号为 30. 使用时, 用户把调用号保存在 s0 寄存器, 打印字符参数保存在 a0 寄存器, 并执行 syscall 指令, a0 寄存器的低八位将作为字符打印. 例如: </p><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">li s0, 30           # 系统调用号li a0, 0x4F         # 'O'ecallli a0, 0x4B         # 'K'ecalljr ra<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>用 <code>A</code> 命令输入的汇编指令支持常见的伪指令 (pseudo instructions), 并且地址也会相应地变化, 如:</p><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">connecting to 127.0.0.1:6666...connectedrunning in 32bit, xlen = 4&gt;&gt; Aaddr: 0x80100000one instruction per line, empty line to end.[0x80100000] li a0, 0x12345678[0x80100008] li t0, 0x23333332[0x80100010] ret[0x80100014]&gt;&gt; Uaddr: 0x80100000num: 200x80100000:     12345537        lui     a0,0x123450x80100004:     67850513        addi    a0,a0,16560x80100008:     233332b7        lui     t0,0x233330x8010000c:     33228293        addi    t0,t0,8180x80100010:     00008067        ret&gt;&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果是 RV64, 上面的 <code>addi</code> 指令会相应地变成 <code>addiw</code> 指令. </p><h2 id="在-QEMU-里调试监控程序"><a href="#在-QEMU-里调试监控程序" class="headerlink" title="在 QEMU 里调试监控程序"></a>在 QEMU 里调试监控程序</h2><p>在 Makefile 中提供了 <code>debug</code> 目标, 它会编译 kernel 并且运行 QEMU: </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">cd</span> kernel$ <span class="token function">make</span> debugqemu-system-riscv32 <span class="token parameter variable">-M</span> virt <span class="token parameter variable">-m</span> 32M <span class="token parameter variable">-kernel</span> kernel.elf <span class="token parameter variable">-nographic</span> <span class="token parameter variable">-monitor</span> stdio <span class="token parameter variable">-serial</span> tcp::6666,server <span class="token parameter variable">-S</span> <span class="token parameter variable">-s</span>QEMU <span class="token number">5.0</span>.0 monitor - <span class="token builtin class-name">type</span> <span class="token string">'help'</span> <span class="token keyword">for</span> <span class="token function">more</span> information<span class="token punctuation">(</span>qemu<span class="token punctuation">)</span> qemu-system-riscv32: <span class="token parameter variable">-serial</span> tcp::6666,server: info: QEMU waiting <span class="token keyword">for</span> connection on: disconnected:tcp::::6666,server<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>之后它会在 6666 端口上等待 term 的连接. 另起一个窗口, 运行 term 连接到 <code>localhost:6666</code>: </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ python3 term/term.py <span class="token parameter variable">-t</span> <span class="token number">127.0</span>.0.1:6666 <span class="token parameter variable">-c</span>connecting to <span class="token number">127.0</span>.0.1:6666<span class="token punctuation">..</span>.connected<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这一步连上以后, 就可以用 gdb 挂载到 qemu 里的 kernel 上了. 采用<strong>比较新</strong>的 gdb 或者 SiFive 的 riscv64-elf-unknown-gdb (Windows 最好用这个) 都是可以的. 命令: </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ riscv64-unknown-elf-gdb kernel/kernel.elfGNU gdb <span class="token punctuation">(</span>SiFive GDB <span class="token number">8.3</span>.0-2019.08.0<span class="token punctuation">)</span> <span class="token number">8.3</span>Copyright <span class="token punctuation">(</span>C<span class="token punctuation">)</span> <span class="token number">2019</span> Free Software Foundation, Inc.License GPLv3+: GNU GPL version <span class="token number">3</span> or later <span class="token operator">&lt;</span>http://gnu.org/licenses/gpl.html<span class="token operator">&gt;</span>This is <span class="token function">free</span> software: you are <span class="token function">free</span> to change and redistribute it.There is NO WARRANTY, to the extent permitted by law.Type <span class="token string">"show copying"</span> and <span class="token string">"show warranty"</span> <span class="token keyword">for</span> details.This GDB was configured as <span class="token string">"--host=x86_64-w64-mingw32 --target=riscv64-unknown-elf"</span><span class="token builtin class-name">.</span>Type <span class="token string">"show configuration"</span> <span class="token keyword">for</span> configuration details.For bug reporting instructions, please see:<span class="token operator">&lt;</span>https://github.com/sifive/freedom-tools/issues<span class="token operator">&gt;</span>.Find the GDB manual and other documentation resources online at:    <span class="token operator">&lt;</span>http://www.gnu.org/software/gdb/documentation/<span class="token operator">&gt;</span>.For help, <span class="token builtin class-name">type</span> <span class="token string">"help"</span><span class="token builtin class-name">.</span>Type <span class="token string">"apropos word"</span> to search <span class="token keyword">for</span> commands related to <span class="token string">"word"</span><span class="token punctuation">..</span>.Reading symbols from kernel/kernel.elf<span class="token punctuation">..</span>.<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> target remote localhost:1234Remote debugging using localhost:12340x00001000 <span class="token keyword">in</span> ?? <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>之后就可以正常进行调试. </p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li>CPU 采用的 RISC-V 指令集标准: The RISC-V Instruction Set Manual Volume I: User-Level ISA Document</li><li>RISC-V 中断及 Sv32/Sv39 等特权态资源: The RISC-V Instruction Set Manual Volume II: Privileged Architecture</li></ul>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;RISC-V-监控程序&quot;&gt;&lt;a href=&quot;#RISC-V-监控程序&quot; class=&quot;headerlink&quot; title=&quot;RISC-V 监控程序&quot;&gt;&lt;/a&gt;RISC-V 监控程序&lt;/h1&gt;&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot;</summary>
        
      
    
    
    
    <category term="CS" scheme="http://chengsx21.github.io/categories/CS/"/>
    
    <category term="COD" scheme="http://chengsx21.github.io/categories/CS/COD/"/>
    
    
    <category term="COD" scheme="http://chengsx21.github.io/tags/COD/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成原理 笔记1</title>
    <link href="http://chengsx21.github.io/2023/09/19/ji-suan-ji-zhi-ling-xi-tong/"/>
    <id>http://chengsx21.github.io/2023/09/19/ji-suan-ji-zhi-ling-xi-tong/</id>
    <published>2023-09-19T09:18:57.000Z</published>
    <updated>2023-09-27T13:13:12.693Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机指令系统"><a href="#计算机指令系统" class="headerlink" title="计算机指令系统"></a>计算机指令系统</h1><h2 id="Risc-V-指令"><a href="#Risc-V-指令" class="headerlink" title="Risc-V 指令"></a>Risc-V 指令</h2><h3 id="U-型"><a href="#U-型" class="headerlink" title="U 型"></a>U 型</h3><p><img src="/pic/173.png" alt=""></p><p><img src="/pic/174.png" alt=""></p><ul><li><strong>lui</strong> 和 <strong>auipc</strong> 主要用于构造大的常量数值和链接.</li><li><strong>lui</strong> 设置寄存器高位立即数, 用两条指令便可以任意偏移量转移控制流或者加载任意 32 位数据.<ul><li>将 <strong>lui</strong> 中的 20 位立即数与 <strong>jalr</strong> 中 12 位立即数组合, 可以将执行流转移到任何 32 位绝对地址.</li><li><strong>lui</strong> 加上标准的立即指令, 可构造一个任意 32 位常量.</li></ul></li><li><strong>auipc</strong> 向 PC 高位加上立即数, 仅用两条指令便可以基于当前 PC 以任意偏移量转移控制流或者访问数据.<ul><li>将 <strong>auipc</strong> 中的 20 位立即数与 <strong>jalr</strong> 中 12 位立即数组合, 可以将执行流转移到任何 32 位 PC 相对地址.</li><li><strong>auipc</strong> 加上普通加载或存储指令中的 12 位立即数偏移量, 可以访问任何 32 位 PC 相对地址的数据.</li></ul></li></ul><h3 id="UJ-J-型"><a href="#UJ-J-型" class="headerlink" title="UJ/J 型"></a>UJ/J 型</h3><p><img src="/pic/175.png" alt=""></p><ul><li><strong>J</strong> 类型的直接字段在 <strong>U</strong> 类型的基础上旋转了 12 位. 这可以降低指令信号扇出和立即数多路复用的成本, 并简化低端实现中的数据通路逻辑.</li><li>由于指令长度必须是两个字节的倍数, <strong>J</strong> 格式的分支和跳转地址必须向左移动 1 位以将地址乘以 2, 给予分支和跳转指令更大的跳转范围, 进行符号扩展后再添加到 PC 上, 得到跳转地址.</li><li><strong>jal</strong> 具有双重功能. 若将下一条指令 PC + 4 的地址保存到目标寄存器中.<ul><li>通常是返回地址寄存器 ra, 便可实现过程调用.</li><li>使用零寄存器 x0 替换 ra 作为目标寄存器, 则可实现无条件跳转. </li></ul></li></ul><h3 id="I-型-1"><a href="#I-型-1" class="headerlink" title="I 型 - 1"></a>I 型 - 1</h3><p><img src="/pic/176.png" alt=""></p><ul><li>跳转链接指令的寄存器版本 <strong>jalr</strong> 同样是多用途的.<ul><li>可以调用地址是动态计算出来的函数.</li><li>可以实现调用返回 (ra 作为源寄存器, x0 作为目的寄存器).</li><li>switch 和 case 语句的地址跳转也可使用 <strong>jalr</strong> 指令, 目的寄存器设为 x0.</li></ul></li></ul><p><img src="/pic/177.png" alt=""></p><p><img src="/pic/178.png" alt=""></p><h3 id="I-型-2"><a href="#I-型-2" class="headerlink" title="I 型 - 2"></a>I 型 - 2</h3><p><img src="/pic/179.png" alt=""></p><p><img src="/pic/180.png" alt=""></p><p><img src="/pic/181.png" alt=""></p><p><img src="/pic/182.png" alt=""></p><p><img src="/pic/183.png" alt=""></p><ul><li><strong>slli</strong> 和 <strong>srli</strong> 的 shamt[4:0] 为移动量, 范围都是[4:0], 因为在 RV32I 中最大的移位量是 31 位.</li><li>imm[10] 用来区分移位类型, 其中 <strong>slli</strong> 和 <strong>srli</strong> 指令机器码的 bit 30 为 0, 而 <strong>srai</strong> 指令机器码的 bit 30 为 1.</li></ul><h3 id="R-型"><a href="#R-型" class="headerlink" title="R 型"></a>R 型</h3><p><img src="/pic/184.png" alt=""></p><p><img src="/pic/185.png" alt=""></p><p><img src="/pic/186.png" alt=""></p><p><img src="/pic/187.png" alt=""></p><h3 id="S-型"><a href="#S-型" class="headerlink" title="S 型"></a>S 型</h3><p><img src="/pic/188.png" alt=""></p><p><img src="/pic/189.png" alt=""></p><h3 id="SB-B-型"><a href="#SB-B-型" class="headerlink" title="SB/B 型"></a>SB/B 型</h3><p><img src="/pic/190.png" alt=""></p><p><img src="/pic/191.png" alt=""></p><ul><li><strong>B</strong> 类型的立即数字段在 <strong>S</strong> 类型的基础上旋转了 1 位. 这可以降低指令信号扇出和立即数多路复用的成本, 并简化低端实现中的数据通路逻辑.</li><li>由于指令长度必须是两个字节的倍数, <strong>B</strong> 格式的分支和跳转地址必须向左移动 1 位以将地址乘以 2, 给予分支和跳转指令更大的跳转范围, 进行符号扩展后再添加到 PC 上, 得到跳转地址.</li></ul>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;计算机指令系统&quot;&gt;&lt;a href=&quot;#计算机指令系统&quot; class=&quot;headerlink&quot; title=&quot;计算机指令系统&quot;&gt;&lt;/a&gt;计算机指令系统&lt;/h1&gt;&lt;h2 id=&quot;Risc-V-指令&quot;&gt;&lt;a href=&quot;#Risc-V-指令&quot;</summary>
        
      
    
    
    
    <category term="CS" scheme="http://chengsx21.github.io/categories/CS/"/>
    
    <category term="COD" scheme="http://chengsx21.github.io/categories/CS/COD/"/>
    
    
    <category term="COD" scheme="http://chengsx21.github.io/tags/COD/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络原理 期末复习</title>
    <link href="http://chengsx21.github.io/2023/06/13/ji-suan-ji-wang-luo-yuan-li-qi-mo-fu-xi/"/>
    <id>http://chengsx21.github.io/2023/06/13/ji-suan-ji-wang-luo-yuan-li-qi-mo-fu-xi/</id>
    <published>2023-06-13T07:00:13.000Z</published>
    <updated>2023-09-27T12:06:37.531Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Computer-Network-Final-Notes"><a href="#Computer-Network-Final-Notes" class="headerlink" title="Computer Network Final Notes"></a>Computer Network Final Notes</h1><blockquote><p><em>Some useful (maybe) facts are first shown.</em></p></blockquote><ul><li><p><strong>Protocal Stack</strong></p>  <div align="center"><img src="/pic/136.png" width="100%" height="100%"></div></li><li><p><strong>Turing Award</strong></p><ul><li><strong>Bob Metcalfe</strong>: Father of Ethernet</li><li><strong>Vinton G. Cerf &amp; Robert E. Kahn</strong>: TCP/IP</li><li><strong>Tim Berners-Lee</strong>: Web &amp; HTTP</li></ul></li></ul><blockquote><p><em>Now comes the crazy things!</em></p></blockquote><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><h3 id="Connect-end-systems-to-edge-router"><a href="#Connect-end-systems-to-edge-router" class="headerlink" title="Connect end systems to edge router"></a>Connect end systems to edge router</h3><ul><li><strong>Residential</strong> access networks</li><li><strong>Institutional</strong> access networks (school, company)</li><li><strong>Mobile</strong> access networks (WiFi, 4G/5G)<ul><li><strong>Wireless local</strong> area networks<ul><li>802.11 (WiFi)</li></ul></li><li><strong>Wide-area cellular</strong> access networks<ul><li>4G cellular networks</li></ul></li></ul></li></ul><h3 id="Links-physical-media"><a href="#Links-physical-media" class="headerlink" title="Links physical media"></a>Links physical media</h3><ul><li><strong>Twisted pair</strong> (TP)</li><li><strong>Coaxial cable</strong></li><li><strong>Fiber optic cable</strong><ul><li>high-speed operation</li><li><strong>low error rate</strong></li></ul></li><li><strong>Wireless radio</strong><ul><li>no physical “wire”</li><li><strong>broadcast</strong>, “half-duplex”</li><li><strong>propagation environment effects</strong></li></ul></li></ul><h3 id="Packet-switching"><a href="#Packet-switching" class="headerlink" title="Packet switching"></a>Packet switching</h3><ul><li><strong>On-demand allocation</strong><ul><li>Store-and-forward</li><li>Great for “bursty” data</li><li><strong>Resource sharing</strong></li></ul></li></ul><h3 id="Circuit-switching"><a href="#Circuit-switching" class="headerlink" title="Circuit switching"></a>Circuit switching</h3><ul><li><strong>Reserved resources</strong><ul><li>Dedicated, <strong>no resource sharing</strong></li><li>FDMA and TDMA</li></ul></li></ul><h3 id="Network-of-networks"><a href="#Network-of-networks" class="headerlink" title="Network of networks"></a>Network of networks</h3><ul><li><p><strong>Global Transit ISP</strong></p></li><li><p><strong>Content Provider Network</strong> (<strong>bypassing tier-1, regional ISPs</strong>)</p></li><li><p><strong>Internet Exchange Point</strong></p></li><li><p>Regional ISP</p></li><li><p>Access ISP</p>  <div align="center"><img src="/pic/137.png" width="100%" height="100%"></div></li></ul><h3 id="Performance"><a href="#Performance" class="headerlink" title="Performance"></a>Performance</h3><ul><li><p>Delay:</p><script type="math/tex; mode=display">  d_{nodal}=d_{proc}+d_{queue}+d_{trans}+d_{prop}</script></li><li><p><strong>Throughput</strong>: <strong>bottleneck link</strong> on end-end path that constrains throughput</p></li></ul><h3 id="Security"><a href="#Security" class="headerlink" title="Security"></a>Security</h3><ul><li><strong>Packet Sniffing</strong>:<ul><li><strong>broadcast</strong> media (shared Ethernet, wireless)</li><li>promiscuous network interface reads/records all packets</li></ul></li><li><strong>IP spoofing</strong>:<ul><li>injection of packet with false source address</li></ul></li><li><strong>Denial of Service</strong>:<ul><li>overwhelme resource with bogus traffic</li><li>make resources (server, bandwidth) unavailable</li></ul></li></ul><h2 id="Application-layer"><a href="#Application-layer" class="headerlink" title="Application layer"></a>Application layer</h2><h3 id="Network-app"><a href="#Network-app" class="headerlink" title="Network app"></a>Network app</h3><ul><li>Run on <strong>end systems</strong></li><li>Not run on <strong>network-core devices</strong></li><li>(<strong>Network layer protocols</strong> in every Internet device: <strong>hosts, routers</strong>)</li></ul><h3 id="Client-server-paradigm"><a href="#Client-server-paradigm" class="headerlink" title="Client-server paradigm"></a>Client-server paradigm</h3><ul><li>Server:<ul><li>permanent IP address</li><li>often in data centers, for scaling</li></ul></li><li>Client:<ul><li><strong>intermittently</strong> connected</li><li><strong>dynamic IP addresses</strong></li><li>do <strong>not communicate directly</strong> with each other</li></ul></li><li>Examples: <strong>HTTP, IMAP, FTP</strong></li></ul><h3 id="Peer-peer-architecture"><a href="#Peer-peer-architecture" class="headerlink" title="Peer-peer architecture"></a>Peer-peer architecture</h3><ul><li>Peer:<ul><li><strong>intermittently</strong> connected</li><li><strong>dynamic IP addresses</strong></li><li>arbitrary end systems <strong>directly communicate</strong></li><li><strong>self scalability</strong> – new peers bring new service capacity and service demands</li></ul></li><li>Example: <strong>P2P file sharing</strong></li></ul><h3 id="TSL"><a href="#TSL" class="headerlink" title="TSL"></a>TSL</h3><ul><li><strong>Application-layer protocal</strong>, Provides <strong>encrypted TCP connections</strong></li></ul><h3 id="HTTP-Hypertext-Transfer-Protocol"><a href="#HTTP-Hypertext-Transfer-Protocol" class="headerlink" title="HTTP (Hypertext Transfer Protocol)"></a>HTTP (Hypertext Transfer Protocol)</h3><ul><li><p>Web’s <strong>Application-layer protocol</strong>, use <strong>TCP</strong></p>  <div align="center"><img src="/pic/138.png" width="100%" height="100%"></div></li><li><p><strong>Stateless</strong>: server maintains no information about past client requests</p></li><li><p>Developments:</p><ul><li>HTTP 1.1:<ul><li><strong>persistent</strong> HTTP</li><li>multiple, pipelined GETs over single TCP connection</li><li><strong>FCFS</strong> scheduling, <strong>HOL</strong> <strong>blocking</strong></li><li>loss recovery stalls object transmission</li></ul></li><li>HTTP/2:<ul><li>transmission order based on client-specified <strong>priority</strong>, interleaved</li><li>divide objects into frames, <strong>mitigate HOL blocking</strong></li><li>loss recovery stalls object transmission</li></ul></li><li>HTTP/3:<ul><li>adds <strong>security</strong>, per object error- &amp; congestion-control (more pipelining) <strong>over UDP</strong></li></ul></li></ul></li></ul><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><ul><li>Components:<ul><li>header line of <strong>HTTP response message</strong></li><li>header line in next <strong>HTTP request message</strong></li><li>file kept on <strong>user’s host</strong>, managed by user’s browser</li><li>back-end <strong>database at web site</strong></li></ul></li><li><div align="center"><img src="/pic/139.png" width="100%" height="100%"></div></li><li>Used for:<ul><li>authorization</li><li>recommendations</li><li>user session state</li></ul></li><li><strong>GDPR</strong> (EU General Data Protection Regulation)</li></ul><h3 id="Web-caches"><a href="#Web-caches" class="headerlink" title="Web caches"></a>Web caches</h3><ul><li>Acts as <strong>both client and server</strong></li><li><div align="center"><img src="/pic/140.png" width="100%" height="100%"></div></li><li>Browser caching: <strong>Conditional GET</strong></li><li>Pros:<ul><li>reduce <strong>end-end response time</strong></li><li>reduce <strong>traffic</strong> on institution’s <strong>access link</strong></li><li>enables content providers to <strong>effectively deliver content</strong></li></ul></li></ul><h3 id="SMTP-Simple-Mail-Transfer-Protocol"><a href="#SMTP-Simple-Mail-Transfer-Protocol" class="headerlink" title="SMTP (Simple Mail Transfer Protocol)"></a>SMTP (Simple Mail Transfer Protocol)</h3><ul><li>E-mail’s <strong>Application-layer protocol</strong>, use <strong>TCP</strong></li><li>Use <strong>persistent connections</strong></li><li>Comparison:<ul><li>HTTP<ul><li>client <strong>pull</strong></li><li>each object encapsulated in its own response message</li></ul></li><li>SMTP<ul><li>client <strong>push</strong></li><li>multiple objects sent in multipart message</li></ul></li></ul></li><li><strong>Mail access protocol</strong>: retrieval from server<ul><li><strong>IMAP</strong> (Internet Mail Access Protocol)</li><li><strong>POP</strong></li><li><strong>HTTP</strong></li></ul></li></ul><h3 id="DNS-Domain-Name-System"><a href="#DNS-Domain-Name-System" class="headerlink" title="DNS (Domain Name System)"></a>DNS (Domain Name System)</h3><ul><li><strong>Application-layer protocol</strong>, <strong>distributed</strong> and <strong>hierarchical</strong> database</li><li><p>Services:</p><ul><li>hostname to IP address translation</li><li>host aliasing<ul><li>canonical, alias names</li></ul></li><li>mail server aliasing</li><li><strong>load distribution</strong><ul><li><strong>replicated IP addresses</strong> correspond to <strong>one name</strong></li></ul></li></ul></li><li><p><strong>Decentralized</strong>:</p><ul><li><strong>single point of failure</strong></li><li><strong>traffic volume</strong></li><li><strong>distant</strong> centralized database</li><li><strong>maintenance</strong></li></ul></li><li><strong>DNSSEC</strong> – provides security</li><li><strong>ICANN</strong> - manages root DNS domain</li><li><strong>Local</strong> DNS server:<ul><li>local cache of recent translation pairs</li><li>doesn’t strictly belong to hierarchy</li><li><strong>forwarding request into DNS hierarchy</strong></li><li>TLD servers typically cached, <strong>allowing root server bypass</strong></li></ul></li><li><strong>Iterated</strong> query &amp; <strong>Recursive</strong> query</li><li>DNS <strong>records</strong>:<ul><li>type = A<ul><li>hostname - IP address</li></ul></li><li>type = CNAME<ul><li>alias name - canonical name</li></ul></li><li>type = NS<ul><li>domain - hostname of authoritative name server</li></ul></li><li>type = MX<ul><li>name - name of SMTP mail server</li></ul></li></ul></li><li><strong>Example</strong>:<ul><li><strong>register</strong> name at DNS registrar<ul><li>provide names, IP addresses of authoritative name server</li><li>inserts NS, A RRs into .com TLD server<ul><li>(networkutopia.com, dns1.networkutopia.com, NS)</li><li>(dns1.networkutopia.com, 212.212.212.1, A)</li></ul></li></ul></li><li><strong>create authoritative server locally</strong> with IP address 212.212.212.1<ul><li>type A record for www.networkuptopia.com</li><li>type MX record for networkutopia.com</li></ul></li></ul></li></ul><h3 id="P2P"><a href="#P2P" class="headerlink" title="P2P"></a>P2P</h3><ul><li><strong>File distribution time</strong>:<ul><li>client-server: $\max\{NF/u_s,F/d_{min}\}$</li><li>P2P: $\max\{F/u_s,F/d_{min},NF/(u_s+\sum u_i)\}$</li><li><div align="center"><img src="/pic/141.png" width="100%" height="100%"></div></li></ul></li><li>File distribution: <strong>BitTorrent</strong><ul><li>tracker</li><li>torrent</li><li>churn</li><li><strong>Sending chunks: tit-for-tat</strong><ul><li>sends chunks to four peers sending her chunks at highest rate </li><li>other peers <strong>choked</strong></li><li>every 30 secs select another peer, starts sending chunks</li><li>optimistically <strong>unchoke</strong> this peer</li></ul></li></ul></li></ul><h3 id="Video-Streaming-and-CDNs"><a href="#Video-Streaming-and-CDNs" class="headerlink" title="Video Streaming and CDNs"></a>Video Streaming and CDNs</h3><ul><li>Challenges:<ul><li><strong>server-to-client bandwidth varies</strong></li><li><strong>changing network congestion levels</strong></li><li><strong>packet loss, delay due to congestion</strong></li></ul></li><li><strong>DASH</strong> (Dynamic, Adaptive Streaming over HTTP)<ul><li><strong>Application-layer protocol</strong>, use <strong>HTTP</strong> and <strong>TCP</strong></li><li>Server:<ul><li>divides video file into <strong>chunks</strong>, encoded at different <strong>rates</strong></li><li>files <strong>replicated</strong> in various <strong>CDN nodes</strong></li><li>provides <strong>URLs</strong> for different chunks (<strong>manifest file</strong>)</li></ul></li><li>Client:<ul><li>periodically <strong>estimates server-to-client bandwidth</strong></li><li><strong>consulting manifest</strong>, requests one chunk at a time </li><li>choose rates at <strong>different time</strong> and from <strong>different servers</strong></li><li><strong>“Intelligence” at client</strong></li></ul></li></ul></li><li><strong>single, large “mega-server”:</strong><ul><li><strong>single point of failure</strong></li><li>point of network <strong>congestion</strong></li><li><strong>long path</strong> to distant clients</li></ul></li><li><strong>CDN</strong>:<ul><li>multiple copies of videos at <strong>geographically distributed sites</strong><ul><li><strong>enter deep</strong>: push servers deep into many access networks</li><li><strong>bring home</strong>: smaller number of larger clusters in POPs near access nets</li></ul></li></ul></li></ul><h2 id="Transport-Layer"><a href="#Transport-Layer" class="headerlink" title="Transport Layer"></a>Transport Layer</h2><h3 id="Services-not-available"><a href="#Services-not-available" class="headerlink" title="Services not available"></a>Services not available</h3><ul><li><strong>Delay</strong> guarantees</li><li><strong>Bandwidth</strong> guarantees</li></ul><h3 id="Demultiplexing"><a href="#Demultiplexing" class="headerlink" title="Demultiplexing"></a>Demultiplexing</h3><ul><li><strong>Connectionless</strong>:<ul><li>UDP: using destination <strong>port number</strong> (only)</li></ul></li><li><strong>Connection-oriented</strong>:<ul><li>TCP: using <strong>4-tuple</strong>, <strong>IP addresses and port numbers</strong></li><li>support <strong>simultaneous TCP sockets</strong></li></ul></li></ul><h3 id="UDP-User-Datagram-Protocol"><a href="#UDP-User-Datagram-Protocol" class="headerlink" title="UDP (User Datagram Protocol)"></a>UDP (User Datagram Protocol)</h3><div align="center"><img src="/pic/142.png" width="100%" height="100%"></div><ul><li>Pros:<ul><li><strong>No connection establishment</strong> (which <strong>adds RTT delay</strong>)</li><li><strong>No connection state</strong> at sender, receiver</li><li><strong>Small header size</strong></li><li><strong>No congestion control</strong>, blast away as fast as desired</li><li>Helps with <strong>reliability</strong> (checksum)</li></ul></li><li><strong>Used by</strong>:<ul><li>streaming multimedia apps</li><li><strong>DNS</strong></li><li><strong>DHCP</strong></li><li><strong>SNMP</strong></li><li><strong>HTTP/3</strong></li></ul></li></ul><h3 id="RDT-Reliable-Data-Transfer-Protocol"><a href="#RDT-Reliable-Data-Transfer-Protocol" class="headerlink" title="RDT (Reliable Data Transfer Protocol)"></a>RDT (Reliable Data Transfer Protocol)</h3><ul><li><p><strong>Stop and Wait</strong>:</p>  <div align="center"><img src="/pic/143.png" width="100%" height="100%"></div>  <div align="center"><img src="/pic/144.png" width="100%" height="100%"></div>  <div align="center"><img src="/pic/145.png" width="100%" height="100%"></div></li><li><p><strong>Go-Back-N</strong>:</p>  <div align="center"><img src="/pic/146.png" width="100%" height="100%"></div></li><li><p><strong>Selective repeat</strong>:</p>  <div align="center"><img src="/pic/147.png" width="100%" height="100%"></div></li></ul><h3 id="TCP-Transfer-Control-Protocol"><a href="#TCP-Transfer-Control-Protocol" class="headerlink" title="TCP (Transfer Control Protocol)"></a>TCP (Transfer Control Protocol)</h3><div align="center"><img src="/pic/148.png" width="100%" height="100%"></div><ul><li><p>Retransmission:</p>  <div align="center"><img src="/pic/149.png" width="100%" height="100%"></div>  <div align="center"><img src="/pic/150.png" width="100%" height="100%"></div></li><li><p><strong>Flow control</strong>:</p><ul><li>network layer <strong>delivers</strong> data <strong>faster</strong> than application layer <strong>removes</strong> data from socket buffers</li><li><strong>receiver “advertises” free buffer space</strong> in <strong>rwnd</strong> in TCP header</li><li><strong>sender limits amount of unACKed data</strong> to received <strong>rwnd</strong></li></ul></li><li><p><strong>Connection management</strong>:</p><ul><li><p>2-way handshake:</p><ul><li><strong>half open connection</strong> (no client)</li><li><strong>dup data accepted</strong></li></ul></li><li><p>3-way handshake:</p>  <div align="center"><img src="/pic/151.png" width="100%" height="100%"></div></li></ul></li></ul><h3 id="Congestion-control"><a href="#Congestion-control" class="headerlink" title="Congestion control"></a>Congestion control</h3><ul><li><p><strong>Costs</strong> of congestion: </p><ul><li><strong>needed retransmissions</strong>: more work for given receiver throughput</li><li><strong>unneeded retransmissions</strong>: link carries multiple copies of a packet</li><li><p><strong>packet dropped</strong>: upstream capacity and buffering wasted</p><div align="center"><img src="/pic/152.png" width="100%" height="100%"></div></li></ul></li><li><p><strong>End-end</strong> congestion control:</p><ul><li><strong>no explicit feedback</strong> from network</li><li>congestion <strong>inferred</strong> from <strong>observed loss, delay</strong></li><li>taken by: <strong>TCP</strong></li></ul></li><li><p><strong>Network-assisted</strong> congestion control:</p><ul><li><strong>router</strong>s provide <strong>direct feedback</strong> to hosts</li><li>taken by: <strong>TCP ECN, ATM, DECbit</strong></li></ul></li></ul><h3 id="AIMD-Additive-Increase-Multiplicative-Decrease"><a href="#AIMD-Additive-Increase-Multiplicative-Decrease" class="headerlink" title="AIMD (Additive Increase Multiplicative Decrease)"></a>AIMD (Additive Increase Multiplicative Decrease)</h3><ul><li><p><strong>Multiplicative decrease</strong>:</p><ul><li><strong>Cut in half</strong> on loss detected by triple duplicate ACK (<strong>TCP Reno</strong>)</li><li><strong>Cut to 1 MSS</strong> when loss detected by timeout (<strong>TCP Tahoe</strong>)</li></ul></li><li><p>(1) TCP <strong>slow start</strong>:</p>  <div align="center"><img src="/pic/153.png" width="100%" height="100%"></div></li><li><p>(2) TCP <strong>congestion avoidance</strong>:</p>  <div align="center"><img src="/pic/154.png" width="100%" height="100%"></div></li><li><p><strong>AIMD Summary</strong>:</p>  <div align="center"><img src="/pic/155.png" width="100%" height="100%"></div></li></ul><h3 id="Other-congestion-control-methods"><a href="#Other-congestion-control-methods" class="headerlink" title="Other congestion control methods"></a>Other congestion control methods</h3><ul><li><p><strong>TCP CUBIC</strong></p><ul><li><p>Increase W as <strong>function of cube distance</strong> between time and K</p>  <div align="center"><img src="/pic/156.png" width="100%" height="100%"></div></li></ul></li><li><p><strong>Delay-based TCP congestion control</strong></p><ul><li>Minimum observed RTT (uncongested path)</li><li>Measured throughput <strong>close to</strong> uncongested throughput:<ul><li><strong>increase cwnd linearly</strong></li></ul></li><li>Measured throughput <strong>far below</strong> uncongested throughout:<ul><li><strong>decrease cwnd linearly</strong></li></ul></li><li><strong>Without inducing/forcing loss</strong></li></ul></li><li><p><strong>ECN</strong> (Explicit congestion notification)</p><ul><li><strong>congestion indication</strong> carried to <strong>destination</strong></li><li><strong>destination</strong> sets <strong>ECE bit</strong> on <strong>ACK segment</strong> to <strong>notify sender</strong></li><li>involves <strong>IP</strong> (header <strong>ECN bit</strong>) and <strong>TCP</strong> (header <strong>C, E bit</strong>)</li></ul></li></ul><h3 id="QUIC-Quick-UDP-Internet-Connections"><a href="#QUIC-Quick-UDP-Internet-Connections" class="headerlink" title="QUIC (Quick UDP Internet Connections)"></a>QUIC (Quick UDP Internet Connections)</h3><ul><li><strong>Application-layer protocol</strong>, use <strong>UDP</strong><ul><li>increase performance of HTTP</li><li>deployed on many Google servers, apps</li><li>parallelism streams, <strong>no HOL blocking</strong></li></ul></li></ul><h2 id="Network-Layer-Data-Plane"><a href="#Network-Layer-Data-Plane" class="headerlink" title="Network Layer: Data Plane"></a>Network Layer: Data Plane</h2><h3 id="Input-port-functions"><a href="#Input-port-functions" class="headerlink" title="Input port functions"></a>Input port functions</h3><div align="center"><img src="/pic/157.png" width="100%" height="100%"></div><ul><li><strong>Decentralized switching</strong>: <ul><li>Using <strong>header field values</strong>, <strong>lookup output port</strong> using <strong>forwarding table</strong> in memory (“<strong>match plus action</strong>”)</li><li><strong>destination-based forwarding</strong>: based on destination <strong>IP address</strong></li><li><strong>generalized forwarding</strong>: based on any set of <strong>header field values</strong></li></ul></li></ul><h3 id="Switching-fabrics"><a href="#Switching-fabrics" class="headerlink" title="Switching fabrics:"></a><strong>Switching fabrics</strong>:</h3><ul><li>Switching via <strong>memory</strong>:<ul><li>speed limited by memory bandwidth (2 bus crossings per gram)</li></ul></li><li>Switching via <strong>bus</strong>:<ul><li>switching speed limited by bus bandwidth</li></ul></li><li><strong>Switching via interconnection network</strong>:<ul><li>n$\times$n switch from multiple stages of smaller switches</li></ul></li></ul><h3 id="Output-port-functions"><a href="#Output-port-functions" class="headerlink" title="Output port functions"></a>Output port functions</h3><div align="center"><img src="/pic/158.png" width="100%" height="100%"></div><ul><li><strong>Queueing</strong> and <strong>loss</strong> due to output port <strong>buffer overflow</strong></li><li>Buffer management: <strong>drop</strong> and <strong>marking</strong></li><li><strong>Packet scheduling</strong>: which packet to send next on link<ul><li><strong>FCFS</strong></li><li><strong>Priority</strong>: FCFS within priority class</li><li><strong>Round Robin</strong> (RR): cyclically, repeatedly scans class queues</li><li><strong>Weighted Fair Queueing</strong> (WFQ): minimum bandwidth guarantee</li></ul></li></ul><h3 id="IP-addressing"><a href="#IP-addressing" class="headerlink" title="IP addressing"></a>IP addressing</h3><div align="center"><img src="/pic/159.png" width="100%" height="100%"></div><ul><li><strong>Subnets</strong>: device interfaces reaching each other <strong>without passing a router</strong></li><li><strong>CIDR</strong> (Classless InterDomain Routing)</li><li><strong>DHCP</strong> (Dynamic Host Configuration Protocol)<ul><li><strong>Application-layer protocal</strong>, use <strong>UDP</strong></li><li>Pros:<ul><li>can <strong>renew</strong> its lease on address in use</li><li><strong>allows reuse</strong> of addresses (hold address while connected/on)</li><li><strong>support for mobile</strong> users who join/leave network </li></ul></li></ul></li><li><strong>Hierarchical addressing</strong>:<ul><li><strong>route aggregation</strong></li><li>allows efficient advertisement of routing information</li></ul></li><li><strong>ICANN</strong>: allocates IP addresses</li></ul><h3 id="NAT-Network-Address-Translation"><a href="#NAT-Network-Address-Translation" class="headerlink" title="NAT (Network Address Translation)"></a>NAT (Network Address Translation)</h3><ul><li>Devices in <strong>local network</strong> share <strong>one IPv4 address</strong> as outside is concerned</li><li>Pros:<ul><li>just <strong>one IP address</strong> needed from provider ISP for <strong>all devices</strong></li><li><strong>change address</strong> of host in local network <strong>without notifying outside</strong> </li><li><strong>change ISP</strong> without changing addresses of devices in local network</li><li>security: devices inside local net <strong>not directly addressable</strong> by outside</li></ul></li><li>Remember in <strong>NAT translation table</strong></li><li>Violates <strong>end-to-end argument</strong> (<strong>port manipulation</strong> by <strong>network-layer</strong>)</li></ul><h3 id="Tunneling"><a href="#Tunneling" class="headerlink" title="Tunneling"></a>Tunneling</h3><div align="center"><img src="/pic/160.png" width="100%" height="100%"></div><ul><li><p><strong>IPv6 datagram</strong> as <strong>payload</strong> in IPv4 datagram <strong>among IPv4 routers</strong></p>  <div align="center"><img src="/pic/161.png" width="100%" height="100%"></div></li></ul><h3 id="Generalized-forwarding"><a href="#Generalized-forwarding" class="headerlink" title="Generalized forwarding"></a>Generalized forwarding</h3><ul><li><strong>“match plus action”</strong> abstraction: match <strong>bits in packet header</strong> in <strong>any layers</strong>, take action<ul><li>matching over many fields (<strong>link-, network-, transport-layer</strong>)</li><li>drop, forward, modify, or send matched packet to controller</li><li>“program” network-wide behaviors</li></ul></li></ul><h3 id="Architectural-Principles-of-the-Internet"><a href="#Architectural-Principles-of-the-Internet" class="headerlink" title="Architectural Principles of the Internet"></a>Architectural Principles of the Internet</h3><ul><li>Three cornerstone beliefs:<ul><li><strong>simple connectivity</strong></li><li><strong>IP protocol: that narrow waist</strong></li><li><strong>intelligence, complexity at network edge</strong></li></ul></li></ul><h2 id="Network-Layer-Control-Plane"><a href="#Network-Layer-Control-Plane" class="headerlink" title="Network Layer: Control Plane"></a>Network Layer: Control Plane</h2><h3 id="Routing-protocols"><a href="#Routing-protocols" class="headerlink" title="Routing protocols"></a>Routing protocols</h3><ul><li><strong>Link state</strong>:<ul><li><strong>centralized</strong></li><li><strong>iterative</strong></li><li>link costs depend on <strong>traffic volume</strong>, route oscillations possible</li></ul></li><li><strong>Distance vector</strong>:<ul><li><strong>distributed</strong></li><li><strong>iterative</strong></li><li><strong>asynchronous</strong></li><li><strong>self-stopping</strong></li><li>good news travels fast, bad news travels slow (<strong>count-to-infinity</strong>)</li></ul></li></ul><h3 id="Intra-ISP-routing"><a href="#Intra-ISP-routing" class="headerlink" title="Intra-ISP routing"></a>Intra-ISP routing</h3><ul><li><p>Focus on <strong>performance</strong></p></li><li><p><strong>Aggregate routers into regions</strong> as <strong>autonomous systems (AS)</strong></p><ul><li>Routers in same AS run <strong>same intra-AS protocol</strong></li><li>Routers in different AS run <strong>different intra-AS protocols</strong></li><li><strong>Gateways</strong> perform <strong>inter-AS as well as intra-AS routing</strong></li></ul></li><li><p><strong>Forwarding table</strong> configured by <strong>intra- &amp; inter-AS routing algorithms</strong></p></li><li><p><strong>RIP</strong> (Routing Information Protocol)</p><ul><li><strong>Application-layer protocal</strong>, use <strong>UDP</strong></li><li>classic <strong>DV</strong></li><li>no longer widely used</li></ul></li><li><p><strong>EIGRP</strong> (Enhanced Interior Gateway Routing Protocol)</p><ul><li><strong>Network-layer protocal</strong></li><li><strong>DV</strong> based</li></ul></li><li><p><strong>OSPF</strong> (Open Shortest Path First)</p><ul><li><p><strong>Network-layer protocal</strong>, use <strong>IP</strong></p></li><li><p><strong>LS</strong> routing</p></li><li><p><strong>IS-IS</strong> protocol (ISO standard) essentially same as <strong>OSPF</strong></p></li><li><p><strong>Hierarchical</strong>:</p><ul><li><strong>two-level</strong> hierarchy: local area, backbone.</li><li><p>each node has detailed <strong>area topology</strong> (only direction to others)</p><div align="center"><img src="/pic/162.png" width="100%" height="100%"></div></li></ul></li></ul></li></ul><h3 id="Inter-ISP-routing"><a href="#Inter-ISP-routing" class="headerlink" title="Inter-ISP routing"></a>Inter-ISP routing</h3><ul><li><strong>Policy</strong> dominates over <strong>performance</strong></li><li><strong>BGP</strong> (Border Gateway Protocol)<ul><li><strong>Application-layer protocal</strong>, use <strong>TCP</strong></li><li><strong>path vector</strong> protocol</li><li><strong>policy-based</strong> routing: AS1 gateway router 1c chooses path AS3,X</li><li><div align="center"><img src="/pic/163.png" width="100%" height="100%"></div></li><li>Route selection:<ul><li><strong>local preference</strong> value attribute: <strong>policy</strong> decision</li><li><strong>shortest AS-PATH</strong></li><li><strong>closest NEXT-HOP router</strong> <strong>(hot potato routing)</strong></li></ul></li></ul></li></ul><h3 id="SDN-Software-defined-networking"><a href="#SDN-Software-defined-networking" class="headerlink" title="SDN (Software defined networking)"></a>SDN (Software defined networking)</h3><ul><li><p><strong>Logically centralized</strong> control plane:</p><ul><li><strong>easier</strong> network <strong>management</strong>: avoid misconfigurations, greater flexibility of flows</li><li><strong>table-based</strong> forwarding allows <strong>easier</strong> centralized “<strong>programming</strong>”</li><li><strong>open implementation</strong> of control plane</li></ul></li><li><p>Components:</p><ul><li>Data-plane <strong>switches</strong></li><li>SDN <strong>controller</strong>: distributed for performance, scalability, robustness</li><li>Network-control <strong>apps</strong>: unbundled</li></ul></li><li><p><strong>SDN controller</strong>:</p><ul><li><strong>interface layer</strong> to network control apps: abstractions API</li><li>network-wide <strong>state management</strong>: a distributed database</li><li><strong>communication</strong>: communicate between controller and switches</li></ul></li><li><p><strong>OpenFlow protocol</strong>:</p><ul><li>operates between <strong>controller and switch</strong></li><li><strong>Application-layer protocal</strong>, use <strong>TCP</strong> to exchange messages</li><li>distinct from <strong>OpenFlow API</strong> (specify generalized forwarding actions)</li></ul></li><li><p>Example:</p>  <div align="center"><img src="/pic/164.png" width="100%" height="100%"></div></li><li><p><strong>ODL controller</strong>:</p><ul><li><strong>Service Abstraction Layer</strong>: interconnects internal, external applications and services</li></ul></li></ul><h3 id="ICMP-Internet-Control-Message-Protocol"><a href="#ICMP-Internet-Control-Message-Protocol" class="headerlink" title="ICMP (Internet Control Message Protocol)"></a>ICMP (Internet Control Message Protocol)</h3><ul><li>Communicate <strong>network-level</strong> information</li><li><strong>Network-layer protocal</strong>, carried in <strong>IP datagrams</strong>.</li></ul><h3 id="Network-management"><a href="#Network-management" class="headerlink" title="Network management"></a>Network management</h3><ul><li><p>Components:</p><ul><li>Managing server</li><li>Managed device</li><li>Network management protocol</li></ul></li><li><p><strong>SNMP</strong> (Simple Network Management Protocol):</p>  <div align="center"><img src="/pic/165.png" width="100%" height="100%"></div><ul><li><strong>Application-layer protocol</strong>, use <strong>UDP</strong></li><li><strong>SMI</strong> (Structure of Management Information): data definition language</li></ul></li></ul><h2 id="Link-Layer-and-LANs"><a href="#Link-Layer-and-LANs" class="headerlink" title="Link Layer and LANs"></a>Link Layer and LANs</h2><h3 id="Services"><a href="#Services" class="headerlink" title="Services"></a>Services</h3><ul><li>implemented in <strong>network interface card (NIC)</strong> or on a chip</li><li>combination of <strong>hardware, software, firmware</strong><ul><li>framing</li><li><strong>link access</strong></li><li><strong>reliable delivery</strong><ul><li>seldom used on <strong>low bit-error links</strong></li></ul></li><li>flow control</li><li><strong>error detection &amp; correction</strong><ul><li><strong>CRC</strong>: used in <strong>Ethernet</strong>, <strong>802.11 WiFi</strong></li></ul></li></ul></li></ul><h3 id="Multiple-Access-Protocols"><a href="#Multiple-Access-Protocols" class="headerlink" title="Multiple Access Protocols"></a>Multiple Access Protocols</h3><ul><li><p>Channel Partitioning</p><ul><li><strong>TDMA, FDMA</strong></li></ul></li><li><p>Random Access: detect and recover from collisions</p><ul><li><p><strong>ALOHA, slotted ALOHA</strong></p></li><li><p><strong>CSMA, CSMA/CD, CSMA/CA</strong></p>  <div align="center"><img src="/pic/166.png" width="100%" height="100%"></div></li></ul></li><li><p>Taking Turns</p><ul><li><strong>Polling, Token Passing</strong></li></ul></li></ul><h3 id="ARP-Address-Resolution-Protocol"><a href="#ARP-Address-Resolution-Protocol" class="headerlink" title="ARP (Address Resolution Protocol)"></a>ARP (Address Resolution Protocol)</h3><ul><li><strong>Network-layer - Link-layer protocal</strong></li><li>MAC <strong>flat address</strong>:<ul><li><strong>portability</strong> </li><li>move interface from one LAN to another</li></ul></li><li>Routing <strong>within a subnet</strong> or <strong>to another subnet</strong></li></ul><h3 id="Ethernet"><a href="#Ethernet" class="headerlink" title="Ethernet"></a>Ethernet</h3><ul><li><p>Physical topology:</p><ul><li>bus</li><li>switched</li></ul></li><li><p><strong>Ethernet frame</strong></p>  <div align="center"><img src="/pic/167.png" width="100%" height="100%"></div><ul><li>receive frame with matching destination address or with broadcast address (ARP packet), pass data in frame to network layer protocol</li><li>otherwise discard frame</li></ul></li><li><p><strong>Unreliable</strong>, <strong>connectionless</strong>, unslotted <strong>CSMA/CD with binary backoff</strong></p></li></ul><h3 id="Switch"><a href="#Switch" class="headerlink" title="Switch"></a>Switch</h3><ul><li>Store and <strong>selectively forward</strong> </li><li><strong>Transparent</strong>, <strong>no collisions</strong></li><li><strong>Plug-and-play</strong>, <strong>self-learning</strong></li></ul><h3 id="VLANs"><a href="#VLANs" class="headerlink" title="VLANs"></a>VLANs</h3><ul><li>Reasons:<ul><li>scaling: all <strong>layer-2 broadcast traffic</strong> must <strong>cross entire LAN</strong> </li><li>efficiency, security, privacy, efficiency issues</li></ul></li><li><strong>Port-based VLAN</strong>:<ul><li><strong>multiple virtual LANS</strong> over <strong>single physical LAN infrastructure</strong></li><li><strong>traffic isolation</strong></li><li><strong>dynamic membership</strong></li><li><strong>forwarding between VLANS via routing</strong></li><li><strong>trunk</strong> port:<ul><li>carry frames between <strong>VLANS over multiple physical switches</strong></li><li>frames must carry <strong>VLAN ID info</strong></li><li><strong>802.1Q protocol</strong> adds/removed additional header fields</li></ul></li></ul></li></ul><h3 id="MPLS-Multiprotocol-label-switching"><a href="#MPLS-Multiprotocol-label-switching" class="headerlink" title="MPLS (Multiprotocol label switching)"></a>MPLS (Multiprotocol label switching)</h3><ul><li>Between <strong>Ethernet</strong> and <strong>IP</strong></li><li><strong>high-speed IP forwarding</strong> among network of <strong>label-switched router</strong></li><li>MPLS <strong>forwarding table</strong> distinct from IP forwarding tables</li><li><strong>Flexibility</strong><ul><li><strong>traffic engineering</strong>: use <strong>destination and source addresses</strong> to route flows to same destination differently</li><li><strong>fast reroute</strong>: <strong>pre-computed backup paths</strong> in case of link failure</li></ul></li></ul><h3 id="Datacenter-networks"><a href="#Datacenter-networks" class="headerlink" title="Datacenter networks"></a>Datacenter networks</h3><ul><li>Network elements:<ul><li>Border routers</li><li>Tier-1 switches</li><li>Tier-2 switches</li><li>Top of Rack (TOR) switch</li><li>Server racks</li></ul></li><li><strong>Load balancer</strong><ul><li><strong>application-layer routing</strong></li><li>hiding data center internals from client</li></ul></li></ul><h2 id="Wireless-and-Mobile-Networks"><a href="#Wireless-and-Mobile-Networks" class="headerlink" title="Wireless and Mobile Networks"></a>Wireless and Mobile Networks</h2><h3 id="Wireless-network-taxonomy"><a href="#Wireless-network-taxonomy" class="headerlink" title="Wireless network taxonomy"></a>Wireless network taxonomy</h3><ul><li><div align="center"><img src="/pic/168.png" width="100%" height="100%"></div></li></ul><h3 id="Wireless-link-characteristics"><a href="#Wireless-link-characteristics" class="headerlink" title="Wireless link characteristics"></a>Wireless link characteristics</h3><ul><li>Differences from wired link:<ul><li><strong>decreased signal strength</strong></li><li><strong>interference</strong> from other sources</li><li><strong>multipath propagation</strong></li></ul></li><li><strong>SNR</strong> (signal-to-noise ratio)<ul><li><strong>given physical layer</strong>: increase power $\rightarrow$ increase SNR $\rightarrow$ decrease BER</li><li><strong>given SNR</strong>: choose physical layer to meet BER requirement, giving highest throughput</li></ul></li><li><strong>Hidden terminal problem &amp; Signal attenuation</strong></li></ul><h3 id="IEEE-802-11-Wireless-LAN"><a href="#IEEE-802-11-Wireless-LAN" class="headerlink" title="IEEE 802.11 Wireless LAN"></a>IEEE 802.11 Wireless LAN</h3><ul><li><p>BSS (Basic Service Set)</p><ul><li>wireless hosts</li><li>access point: base station</li></ul></li><li><p><strong>Active scanning</strong>: </p><ul><li><strong>Probe Request frame</strong> broadcast from H1</li><li><strong>Probe Response frames</strong> sent from APs</li><li>Association Request frame sent to selected AP </li><li>Association Response frame sent from selected AP to H1</li></ul></li><li><p><strong>Passive scanning</strong>:</p><ul><li><strong>Beacon frames</strong> sent from APs</li><li>Association Request frame sent to selected AP </li><li>Association Response frame sent from selected AP to H1</li></ul></li><li><p><strong>CSMA/CA</strong></p>  <div align="center"><img src="/pic/169.png" width="100%" height="100%"></div>  <div align="center"><img src="/pic/170.png" width="100%" height="100%"></div><ul><li>difficult to sense collisions: weak received signal due to fading</li><li>can’t sense all collisions in any case: hidden terminal, fading</li></ul></li><li><p>802.11 frame</p>  <div align="center"><img src="/pic/171.png" width="100%" height="100%"></div>  <div align="center"><img src="/pic/172.png" width="100%" height="100%"></div></li><li><p>Advanced capabilities:</p><ul><li><strong>Rate adaptation</strong><ul><li>dynamically change transmission rate as mobile moves</li><li>BER becomes too high, switch to lower transmission rate but with lower BER</li></ul></li><li><strong>Power management</strong><ul><li>beacon frame contains list of mobiles with AP-to-mobile frames waiting to be sent</li></ul></li></ul></li><li><p><strong>Bluetooth</strong> (Personal area networks)</p><ul><li><strong>replacement for cables</strong></li><li><strong>ad hoc</strong>: no infrastructure</li><li>master <strong>polls</strong> clients, grants requests for client transmissions</li><li><strong>parked mode</strong>: clients can park and later wakeup</li><li><strong>bootstrapping</strong>: nodes self-assemble into piconet (plug and play)</li></ul></li></ul><h3 id="4G-LTE-Network"><a href="#4G-LTE-Network" class="headerlink" title="4G LTE Network"></a>4G LTE Network</h3><ul><li>LTE data plane protocol stack<ul><li><strong>Packet Data Convergence</strong>: header compression, encryption</li><li><strong>Radio Link Control Protocol</strong>: fragmentation/reassembly </li><li><strong>Medium Access</strong>: requesting, use of radio transmission slots</li></ul></li></ul>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;Computer-Network-Final-Notes&quot;&gt;&lt;a href=&quot;#Computer-Network-Final-Notes&quot; class=&quot;headerlink&quot; title=&quot;Computer Network Final</summary>
        
      
    
    
    
    <category term="CS" scheme="http://chengsx21.github.io/categories/CS/"/>
    
    
    <category term="CS" scheme="http://chengsx21.github.io/tags/CS/"/>
    
  </entry>
  
  <entry>
    <title>人工智能导论 笔记4</title>
    <link href="http://chengsx21.github.io/2023/06/04/ren-gong-zhi-neng-dao-lun-bi-ji-4/"/>
    <id>http://chengsx21.github.io/2023/06/04/ren-gong-zhi-neng-dao-lun-bi-ji-4/</id>
    <published>2023-06-04T01:52:54.000Z</published>
    <updated>2023-09-22T08:18:14.738Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第四章-统计机器学习"><a href="#第四章-统计机器学习" class="headerlink" title="第四章 统计机器学习"></a>第四章 统计机器学习</h1><h2 id="统计机器学习"><a href="#统计机器学习" class="headerlink" title="统计机器学习"></a>统计机器学习</h2><ul><li><p>如果一个系统能够通过执行某个过程改进它的<strong>性能</strong>, 这就是学习.</p></li><li><p>统计学习就是计算机系统通过运用<strong>数据及统计方法</strong>提高系统性能的机器学习.</p></li><li><p>统计学习从<strong>数据</strong>出发, 提取特征, 抽象模型, 发现知识, 回到分析与预测.</p></li><li><p>统计学习的目标就是考虑学习什么样的模型和如何学习, 以使模型能对数据进行准确的预测和分析, 具有<strong>优秀的理论基础与可解释性</strong>.</p>  <div align="center"><img src="/pic/128.png" width="100%" height="100%"></div><p>  其中 $x_i$ 为<strong>特征</strong>, $y_i$ 为<strong>标签</strong>. <strong>学习算法</strong> <strong>A</strong> 根据<strong>训练集</strong> <strong>D</strong> 从<strong>假设空间</strong> <strong>H</strong> 中选择一个<strong>最好的</strong> $g\approx f$.</p></li><li><p><strong>统计学习三要素:</strong></p><ul><li><strong>模型</strong>: 学习什么样的模型.<ul><li>条件概率分布、决策函数.</li></ul></li><li><strong>策略</strong>: 模型选择的准则.<ul><li>经验风险最小化、结构风险最小化.</li></ul></li><li><strong>算法</strong>: 模型学习的算法.<ul><li>一般归结为一个<strong>最优化问题</strong>.</li></ul></li></ul></li><li><p><strong>统计机器学习分类: </strong></p><ul><li><strong>监督</strong>学习: 有标签、人为标注 (汉字识别、动物识别).</li><li><strong>非监督</strong>学习: 无标签 (图片归类).</li><li><strong>自监督</strong>学习: 非监督学习的一种 (神经网络语言模型).</li><li><strong>半监督</strong>学习: 综合监督与非监督学习.</li><li><strong>弱监督</strong>学习: 强化学习 (围棋训练).</li></ul></li></ul><h2 id="支持向量机-SVM"><a href="#支持向量机-SVM" class="headerlink" title="支持向量机 (SVM)"></a>支持向量机 (SVM)</h2><ul><li><p><strong>定义:</strong></p><ul><li><strong>二类分类器</strong>: 经过组合可解决多分类问题.</li><li>特征空间上的<strong>间隔最大化线性分类器</strong>.</li><li>通过<strong>核技巧</strong>可实现<strong>非线性分类</strong>.</li><li>根据模型的复杂程度划分.</li></ul></li><li><p><strong>线性可分支持向量机</strong>:</p>  <div align="center"><img src="/pic/129.png" width="100%" height="100%"></div><p>  通过<strong>间隔最大化</strong>得到分类超平面:</p><script type="math/tex; mode=display">  w^*\cdot x+b^*=0.</script><p>  相应的决策函数:</p><script type="math/tex; mode=display">  f(x)=sign(w^*\cdot x+b^*).</script><p>  <strong>函数间隔</strong>:</p><script type="math/tex; mode=display">  \hat\gamma_i=y_i(w\cdot x_i+b)\Rightarrow\hat\gamma=\min_{i}\hat\gamma_i.</script><p>  <strong>几何间隔</strong>:</p><script type="math/tex; mode=display">  \gamma_i=y_i(\dfrac{w}{\Vert w\Vert}\cdot x_i+\dfrac{b}{\Vert w\Vert})\Rightarrow\gamma=\min_{i}\gamma_i.</script><p>  <strong>间隔最大化</strong>问题:</p><script type="math/tex; mode=display">  \max_{w,b}\gamma\quad s.t.\quad y_i(\dfrac{w}{\Vert w\Vert}\cdot x_i+\dfrac{b}{\Vert w\Vert})\ge\gamma,\,1\le i\le N.</script><p>  转化为<strong>凸二次规划问题</strong>:</p><script type="math/tex; mode=display">  \min_{w,b}\dfrac{1}{2}\Vert w\Vert^2\quad s.t.\quad y_i(w\cdot x_i+b)\ge 1,\,1\le i\le N.</script><p>  定义<strong>拉格朗日函数</strong>:</p><script type="math/tex; mode=display">  L(w,b,\alpha)=\dfrac{1}{2}\Vert w\Vert^2+\sum_{i=1}^{N}\alpha_i[1-y_i(w\cdot x_i+b)],\,\alpha_i\ge 0,\,1\le i\le N.</script><p>  下列命题与原命题<strong>等价</strong>:</p><script type="math/tex; mode=display">  \min_{w,b}\max_{\alpha}L(w,b,\alpha).</script><p>  满足<strong>KKT</strong>条件时, <strong>对偶命题</strong>与原命题<strong>等价</strong>:</p><script type="math/tex; mode=display">  \min_{w,b}\max_{\alpha}L(w,b,\alpha)=\max_{\alpha}\min_{w,b}L(w,b,\alpha).</script><p>  对 $w, b$ 求偏导令其为 0 并代入, 得到<strong>对偶问题</strong>:</p><script type="math/tex; mode=display">  \min_{\alpha}\Big(\dfrac{1}{2}\sum_{i=1}^{N}\sum_{j=1}^{N}\alpha_i\alpha_jy_iy_j(x_i\cdot x_j)-\sum_{i=1}^{N}\alpha_i\Big)\quad s.t.\quad \sum_{i=1}^{N}\alpha_iy_i=0.</script><p>  获得 $w^<em>,b^</em>$:</p>  <div align="center"><img src="/pic/130.png" width="100%" height="100%"></div><p>  <strong>与 $\alpha_i&gt;0$ 对应的实例 $x_i$ 就是支持向量.</strong></p></li><li><p><strong>线性支持向量机</strong>:</p>  <div align="center"><img src="/pic/131.png" width="100%" height="100%"></div><p>  转化为<strong>凸二次规划</strong>问题:</p><script type="math/tex; mode=display">  \min_{w,b}(\dfrac{1}{2}\Vert w\Vert^2+C\sum_{i=1}^{N}\xi_i)\quad s.t.\quad y_i(w\cdot x_i+b)\ge 1-\xi_i,\,1\le i\le N.</script><p>  得到<strong>对偶问题</strong>:</p><script type="math/tex; mode=display">  \min_{\alpha}\Big(\dfrac{1}{2}\sum_{i,j=1}^{N}\alpha_i\alpha_jy_iy_j(x_i\cdot x_j)-\sum_{i=1}^{N}\alpha_i\Big)\, s.t.\,0\le\alpha_i\le C, \sum_{i=1}^{N}\alpha_iy_i=0.</script><p>  获得 $w^<em>,b^</em>$:</p>  <div align="center"><img src="/pic/132.png" width="100%" height="100%"></div><p>  <strong>与 $\alpha_i&gt;0$ 对应的实例 $x_i$ 就是支持向量.</strong></p>  <div align="center"><img src="/pic/133.png" width="100%" height="100%"></div></li><li><p><strong>非线性支持向量机</strong>:</p>  <div align="center"><img src="/pic/134.png" width="100%" height="100%"></div><p>  利用<strong>变换</strong>:</p><script type="math/tex; mode=display">  z=\phi(x)=((x^{(1)})^2,(x^{(2)})^2)^T.</script><p>  将原空间的椭圆:</p><script type="math/tex; mode=display">  w_1(x^{(1)})^2+w_2(x^{(2)})^2+b=0</script><p>  变换为新空间的直线:</p><script type="math/tex; mode=display">  w_1z^{(1)}+w_2z^{(2)}+b=0.</script><p>  通过一个<strong>非线性变换</strong>将<strong>输入空间 $X$</strong> 对应于一个<strong>特征空间 $H$</strong> 使, 得在输入空间 $X$ 的<strong>超曲面模型</strong>对应于特征空间 $H$ 中的<strong>超平面模型</strong>. 分类问题的学习就可以通过<strong>在 $H$ 空间中求解线性支持向量机</strong>完成.</p><p>  得到对偶问题:</p><script type="math/tex; mode=display">  \min_{\alpha}\Big(\dfrac{1}{2}\sum_{i,j=1}^{N}\alpha_i\alpha_jy_iy_jK(x_i,x_j)-\sum_{i=1}^{N}\alpha_i\Big) s.t.\,0\le\alpha_i\le C, \sum_{i=1}^{N}\alpha_iy_i=0.</script><p>  常见<strong>核函数</strong>为:</p><ul><li><p>内积核函数</p><script type="math/tex; mode=display">K(x,z)=(x\cdot z)^2.</script></li><li><p>多项式核函数</p><script type="math/tex; mode=display">K(x,z)=(x\cdot z+1)^p.</script></li><li><p>高斯核函数</p><ul><li><strong>$\sigma$ 过大: 欠拟合;</strong></li><li><strong>$\sigma$ 恰当: 恰拟合;</strong></li><li><strong>$\sigma$ 过小: 过拟合.</strong></li></ul><script type="math/tex; mode=display">K(x,z)=\exp\big(-\dfrac{\Vert x-z\Vert^2}{2\sigma^2}\big).</script><p>得到<strong>最终对偶问题</strong>:</p><script type="math/tex; mode=display">\min_{\alpha}\Big(\dfrac{1}{2}\sum_{i,j=1}^{N}\alpha_i\alpha_jy_iy_jK(x_i,x_j)-\sum_{i=1}^{N}\alpha_i\Big)\, s.t.\,\alpha_i\le C, \sum_{i=1}^{N}\alpha_iy_i=0.</script><p>获得 $w^<em>,b^</em>$:</p><div align="center"><img src="/pic/135.png" width="100%" height="100%"></div><p>其中 <strong>$w$ 无法直接得到</strong>, 此时情况为<strong>超曲面</strong>.</p></li></ul></li><li><p><strong>序列最小最优化算法 SMO</strong>:</p><ul><li>支持向量机的学习问题是一个<strong>凸二次规划问题</strong>, 具有<strong>全局最优解</strong>.</li><li>是一种<strong>快速算法</strong>.</li></ul></li><li><p><strong>SVM</strong>求解<strong>多类问题</strong>:</p><ul><li><strong>一对多</strong>: <strong>某类为正例, 其余类为负例</strong>. 分类时将未知样本分类为具有最大分类函数值的那类 (<strong>样本不均衡</strong>).</li><li><strong>一对一</strong>: <strong>任两类构造</strong> <strong>SVM</strong>, 采取<strong>投票法</strong>决定类别 (效果好、数量大).</li><li><strong>层次法</strong>: 所有类<strong>先分成两类</strong>, <strong>每类再分为两类</strong>, 以此类推.</li></ul></li></ul><h2 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h2><ul><li><p>对实例分类的树形结构. <strong>内部</strong>节点表示一个<strong>特征或属性</strong>, <strong>叶</strong>节点表示一个<strong>类</strong>.</p></li><li><p><strong>决策树学习</strong>:</p><ul><li>从训练集归纳出分类规则, 得到与训练集矛盾较小的决策树.</li><li>对给定训练集, 可构造多个决策树, 以损失函数最小化作为优化目标.</li><li>选取<strong>最优决策树</strong>是一个 <strong>NPC</strong> 问题, 一般采用启发式方法得到近似解.</li></ul></li><li><p><strong>决策树学习</strong>——<strong>特征选择</strong>:</p><ul><li><p>按照<strong>信息增益</strong>选择特征.</p></li><li><p><strong>熵</strong>表示数据的混乱程度, <strong>条件熵</strong>表示已知条件下数据的不确定性.</p><ul><li><p>随机变量 $X$ 的<strong>熵</strong>:</p><script type="math/tex; mode=display">  H(X)=-\sum_{i=1}^{n}p_i\log p_i.</script><p>  当条件由数据集 $D$ 估计得到时, 记为 $H(D)$.</p></li><li><p><strong>条件熵</strong>:</p><script type="math/tex; mode=display">  H(Y\mid X)=\sum_{i=1}^{n}p_iH(Y\mid X=x_i).</script><p>  表示已知 $X$ 时 $Y$ 的不确定性.</p></li></ul></li><li><p><strong>信息增益</strong>是特征 <strong>A</strong> 对数据集 <strong>D</strong> 进行分类不确定性的减少程度.</p><script type="math/tex; mode=display">  g(D,A)=H(D)-H(D\mid A).</script><p>  <strong>信息增益大</strong>的特征具有<strong>更强的分类能力</strong>.</p></li><li><p>设<strong>训练集</strong> $D$, $K$ 个<strong>类</strong> $C_k$, <strong>特征</strong> $A$ 有 $n$ 个不同的取值 $\{a_1,\cdots,a_n\}$. $A$ 的<strong>不同取值</strong>将 $D$ 划分为 $n$ 个子集 $D_1$, $\cdots$, $D_n$, $D_i$ 中<strong>属于类</strong> $C_k$ 的<strong>样本</strong>的集合为 $D_{ik}$, $\vert\cdot\vert$ 表示<strong>样本个数</strong>. 计算<strong>信息增益</strong>:</p><script type="math/tex; mode=display">  H(D)=-\sum_{k=1}^{K}\dfrac{\vert C_k\vert}{\vert D\vert}\log_2\dfrac{\vert C_k\vert}{\vert D\vert}.\\  H(D\mid A)=\sum_{i=1}^{n}\dfrac{\vert D_i\vert}{\vert D\vert}H(D_i)=-\sum_{i=1}^{n}\dfrac{\vert D_i\vert}{\vert D\vert}\sum_{k=1}^{K}\dfrac{\vert D_{ik}\vert}{\vert D_i\vert}\log_2\dfrac{\vert D_{ik}\vert}{\vert D_i\vert}.</script></li></ul></li><li><p><strong>决策树学习</strong>——<strong>决策树的生成</strong>:</p><ul><li><p><strong>ID3 算法</strong>:</p><ul><li>输入: <strong>训练集</strong> $D$, <strong>特征集</strong> $A$, 阈值 $\varepsilon$ &gt;0.</li><li>输出: <strong>决策树</strong> $T$.</li></ul><ol><li>若 $D$ 中所有实例<strong>属于同一类</strong> $C_k$, 则 $T$ 为<strong>单节点树</strong>, $C_k$ 为<strong>该节点类标记</strong>, 返回 $T$.</li><li>若 $A$ 为<strong>空</strong>, 则 $T$ 为<strong>单节点树</strong>, $D$ 中<strong>实例数最大</strong>的类 $C_k$ 为<strong>该节点类标记</strong>, 返回 $T$.</li><li>否则计算 $A$ 中<strong>各特征</strong>对 $D$ 的<strong>信息增益</strong>. 选择<strong>最大的特征</strong> $A_g$.</li><li>如果 $A_g$ <strong>信息增益小于阈值</strong>, 则置 $T$ 为<strong>单节点树</strong>, 将 $D$ 中<strong>实例数最大</strong>的类 $C_k$ 作为<strong>该节点类标记</strong>, 返回 $T$.</li><li>否则对 $A_g$ 的<strong>每一可能值</strong> $a_i$, 依 $A_g=a_i$ 将<strong>分割</strong>为 $D$ 若干子集 $D_i$, 作为 $D$ 的<strong>子节点</strong>.</li><li>对于 $D$ 的每个<strong>子节点</strong> $D_i$, 如果 $D_i$ <strong>为空</strong>, 则将 $D$ 中<strong>实例数最大</strong>的类作为<strong>标记</strong>, 构建子节点.</li><li>否则以 $D_i$ 为<strong>训练集</strong>, 以 $A-\{A_g\}$为<strong>特征集</strong>, <strong>递归地调用</strong>得到子树 $T_i$, 返回 $T_i$.</li></ol><ul><li><p>不足: <strong>信息增益</strong>倾向于选择<strong>分枝比较多的属性</strong>.</p></li><li><p>解决: <strong>信息增益比</strong>. $A$ 为属性, $A$ 的不同取值将 $D$ 划分为 $n$ 个子集 $D_1$, $\cdots$, $D_n$.</p><script type="math/tex; mode=display">  g_R(D,A)=\dfrac{g(D,A)}{H_A(D)}.\\  H_A(D)=-\sum_{k=1}^{n}\dfrac{\vert D_k\vert}{\vert D\vert}\log_2\dfrac{\vert D_k\vert}{\vert D\vert}.</script></li></ul></li><li><p><strong>C4.5 算法</strong>:</p><ul><li>除了根据信息增益比选择特征外, <strong>C4.5</strong> 算法与 <strong>ID3</strong> 基本一样.</li><li>增加了对<strong>连续值属性</strong>的处理, 对于连续值属性 <strong>A</strong>, 找到一个属性值 $a_0$, 将 $\le a_0$ 的划分到左子树, $＞a_0$ 的划分到右子树.</li><li>不足: <strong>信息增益比</strong>倾向于选择<strong>分割不均匀的特征</strong>, 轻重不均匀.</li><li>解决: 先选择 <strong>n</strong> 个<strong>信息增益大</strong>的特征, 再从这 <strong>n</strong> 个特征中选择<strong>信息增益比最大</strong>的特征.</li></ul></li></ul></li><li><p><strong>决策树学习</strong>——<strong>决策树的剪枝</strong>:</p><ul><li><p>为防止出现<strong>过拟合</strong>, 对决策树进行简化的过程称为<strong>剪枝</strong>. 从已经生成的树上裁掉一些子树或者叶节点, 将其父节点作为新的叶节点, 用<strong>实例数最大的类别作为标记</strong>.</p></li><li><p>这种生成树再剪枝的方法称为<strong>后剪枝</strong>.</p></li><li><p>当<strong>数据量大</strong>时:</p><ul><li>将数据划分为训练集、验证集和测试集.</li><li>用训练集训练得到决策树.</li><li>从下向上逐步剪枝, 在验证集上测试性能, 直到性能下降为止.</li><li>最后在测试集上的性能作为系统的性能.</li></ul></li><li><p>当<strong>数据量小</strong>时:</p><ul><li><p>直接利用训练集进行剪枝.</p></li><li><p>树 $T$ 的<strong>叶节点</strong>个数为 $\vert T\vert$, $t$ 是树 $T$ 的叶节点, 该节点有 $N_t$ 个<strong>样本</strong>, 其中 $k$ 类的<strong>样本点</strong>有 $N_{tk}$ 个 ($k=1,\cdots,K$). $H_t(T)$ 为叶节点 $t$ 上的<strong>经验熵</strong>, $a\ge 0$ 为参数.</p><script type="math/tex; mode=display">  C_a(T)=\sum_{t=1}^{\vert T\vert}N_tH_t(T)+a\vert T\vert.\\  C(T)=\sum_{t=1}^{\vert T\vert}N_tH_t(T)=-\sum_{t=1}^{\vert T\vert}\sum_{k=1}^{K}N_{tk}\log\dfrac{N_{tk}}{N_t}.</script><p>  其中 $C(T)$ 表示对<strong>训练数据的预测误差</strong>, $\vert T\vert$ 表示模型的<strong>复杂程度</strong>.</p></li></ul></li><li><p><strong>剪枝</strong>就是当 $a$ 确定时, 选择损失函数最小的模型.</p><ul><li>输入: 生成算法产生的<strong>整个树</strong> $T$, <strong>参数</strong> $a$.</li><li>输出: 修剪后的<strong>子树</strong> $T_a$.</li></ul><ol><li>计算每个节点的<strong>经验熵</strong>.</li><li><strong>递归</strong>地从树的叶节点<strong>向上回缩</strong>, 如果回缩后的<strong>损失函数</strong>小于等于回缩前, 则<strong>剪枝</strong>将父节点变为新的叶节点.</li><li><strong>返回 2</strong>, 直至不能继续为止, 得到<strong>损失函数最小</strong>的子树 $T_a$.</li></ol></li></ul></li><li><p><strong>随机森林</strong>:</p><ul><li>决策树容易过拟合.</li><li>随机森林是由多个决策树组成的分类器.</li><li>通过投票机制改善决策树.</li><li>单个决策树的生成:<ul><li>有放回的数据采样.</li><li>属性 (特征) 的采样.</li></ul></li><li>集外数据的使用:<ul><li>单个决策树未用到的数据.</li></ul></li></ul></li></ul>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;第四章-统计机器学习&quot;&gt;&lt;a href=&quot;#第四章-统计机器学习&quot; class=&quot;headerlink&quot; title=&quot;第四章 统计机器学习&quot;&gt;&lt;/a&gt;第四章 统计机器学习&lt;/h1&gt;&lt;h2 id=&quot;统计机器学习&quot;&gt;&lt;a href=&quot;#统计机器学习&quot;</summary>
        
      
    
    
    
    <category term="CS" scheme="http://chengsx21.github.io/categories/CS/"/>
    
    <category term="IAI" scheme="http://chengsx21.github.io/categories/CS/IAI/"/>
    
    
    <category term="IAI" scheme="http://chengsx21.github.io/tags/IAI/"/>
    
  </entry>
  
  <entry>
    <title>概率论与数理统计 笔记8</title>
    <link href="http://chengsx21.github.io/2023/05/28/gai-lu-lun-yu-shu-li-tong-ji-bi-ji-8/"/>
    <id>http://chengsx21.github.io/2023/05/28/gai-lu-lun-yu-shu-li-tong-ji-bi-ji-8/</id>
    <published>2023-05-28T09:27:40.000Z</published>
    <updated>2023-09-22T08:18:28.202Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Chap-8-线性回归"><a href="#Chap-8-线性回归" class="headerlink" title="Chap 8 线性回归"></a>Chap 8 线性回归</h1><h2 id="回归问题"><a href="#回归问题" class="headerlink" title="回归问题"></a>回归问题</h2><ul><li><p><strong>定义</strong>  </p><script type="math/tex; mode=display">  Y=f(X_1,\cdots,X_n)+\varepsilon.</script><ul><li>$Y$ — 因变量(响应变量).</li><li>$X_1,\cdots,X_n$ — 自变量(回归变量).</li><li><p>$\varepsilon$ — 随机误差(无法测量或不重要的因素).</p><p>假定 $E(\varepsilon\mid X_1,\cdots,X_n)=0$,</p><script type="math/tex; mode=display">\Rightarrow E(Y\mid X_1,\cdots,X_n)=f(X_1,\cdots,X_n).</script><p>称为 $Y$ 对 $X_1,\cdots,X_n$ 的回归函数. 由样本数据 $X_1,\cdots,X_n,Y$ 获取 $f$ 的过程称为回归(有监督学习).</p></li></ul></li><li><p><strong>注</strong>  </p><ul><li>$X_1,\cdots,X_n$ 可以是随机的(<strong>e.g.</strong> 随机抽取一人的身高、体重等).</li><li>$X_1,\cdots,X_n$ 也可以是非随机的控制变量(<strong>e.g.</strong> 施肥量、药品使用剂量).</li><li>在应用中, 自变量一律视为非随机的.</li></ul></li><li><p><strong>假设</strong>  $E(\varepsilon)=0$, $Var(\varepsilon)=\sigma^2$ (未知).</p></li><li><p><strong>注</strong>  要素是否完全、$f$ 的形式是否准确关乎 $\sigma^2$ 的大小.</p></li></ul><h2 id="简单线性回归"><a href="#简单线性回归" class="headerlink" title="简单线性回归"></a>简单线性回归</h2><ul><li><p><strong>定义</strong></p><script type="math/tex; mode=display">  Y=\beta_0+\beta_1 X+\varepsilon.</script><p>  这是<strong>理论模型</strong>, 提供背景作用. 其中回归参数(未知待定):</p><ul><li>$\beta_0$ — 截距.</li><li><p>$\beta_1$ — 斜率(回归系数).</p><p>对 $(X,Y)$ 进行 $n$ 次独立观测, 得到样本观测值 $(x_1,y_1),\cdots,(x_n,y_n)$. 则</p><script type="math/tex; mode=display">y_i=\beta_0+\beta_1 x_i+\varepsilon_i\,(1\le i\le n).</script><p>其中 $\varepsilon_i$ 作为第 $i$ 次观测的随机误差, 无法直接观测得到. 不妨认为</p><script type="math/tex; mode=display">\begin{cases}E(\varepsilon_i)=0,\\\\Var(\varepsilon_i)=\sigma^2.\end{cases}</script><p>这是<strong>简单线性回归模型</strong>. 其中:</p></li><li><p>$E(y_i)=\beta_0+\beta_1 x_i$.</p></li><li>$Var(y_i)=\sigma^2$.</li></ul></li><li><p><strong>注</strong></p><ul><li><strong>简单</strong>: $n=1$.</li><li><strong>线性</strong>: $f$ 关于参数 $\beta_0$, $\beta_1$ 线性.</li></ul></li></ul><h2 id="最小二乘法-LS-估计参数"><a href="#最小二乘法-LS-估计参数" class="headerlink" title="最小二乘法 (LS) 估计参数"></a>最小二乘法 (LS) 估计参数</h2><ul><li><p><strong>定义</strong></p><script type="math/tex; mode=display">  S(\beta_0,\beta_1)=\sum_{i=1}^{n}(y_i-(\beta_0+\beta_1 x_i))^2.</script><p>  最小化 $S(\beta_0,\beta_1)$, 得</p><ul><li>$\hat\beta_1=\dfrac{\sum\limits_{i=1}^{n}(x_i-\overline{x})(y_i-\overline{y})}{\sum\limits_{i=1}^{n}(x_i-\overline{x})^2}=\dfrac{\sum\limits_{i=1}^{n}(x_i-\overline{x})y_i}{S_{xx}}$ ($y_i$ 的线性组合).</li><li>$\hat\beta_0=\overline{y}-\hat\beta_1\overline{x}=\sum\limits_{i=1}^{n}(\dfrac{1}{n}-\dfrac{(x_i-\overline{x})\overline{x}}{S_{xx}})y_i$ ($y_i$ 的线性组合).</li><li>$y=\hat\beta_0+\hat\beta_1 x$ (拟合直线).</li></ul></li><li><p><strong>注</strong></p><ul><li>损失函数: $(y-(\beta_0+\beta_1 x))^2$.</li><li>线性模型是否合理.</li></ul></li><li><p><strong>命题</strong>  $\hat\beta_0$, $\hat\beta_1$ 分别为 $\beta_0$, $\beta_1$ 的无偏估计.</p></li><li><p><strong>证明</strong>  </p><script type="math/tex; mode=display">  \begin{aligned}  E(\hat\beta_1)&=\dfrac{\sum_{i=1}^{n}(x_i-\overline{x})E(y_i)}{S_{xx}}\\  &=\dfrac{\sum_{i=1}^{n}(x_i-\overline{x})(\beta_0+\beta_1 x_i)}{S_{xx}}\\  &=\beta_1\dfrac{\sum_{i=1}^{n}(x_i-\overline{x})x_i}{S_{xx}}\\  &=\beta_1\dfrac{\sum_{i=1}^{n}(x_i-\overline{x})^2}{S_{xx}}\\  &=\beta_1.  \end{aligned}</script><script type="math/tex; mode=display">  \begin{aligned}  E(\hat\beta_0)&=E(\overline{y}-\hat\beta_1\overline{x})\\  &=\dfrac{1}{n}\sum_{i=1}^{n}E(y_i)-E(\hat\beta_1)\overline{x}\\  &=\dfrac{1}{n}\sum_{i=1}^{n}(\beta_0+\beta_1 x_i)-\beta_1\overline{x}\\  &=\beta_0.  \end{aligned}</script><script type="math/tex; mode=display">  \begin{aligned}  Var(\hat\beta_1)&=Var\Big(\dfrac{\sum_{i=1}^{n}(x_i-\overline{x})y_i}{S_{xx}}\Big)\\  &=\dfrac{\sum_{i=1}^{n}(x_i-\overline{x})^2}{S_{xx}^2}Var(y_i)\\  &=\dfrac{\sigma^2}{S_{xx}}.  \end{aligned}</script><script type="math/tex; mode=display">  \begin{aligned}  Var(\hat\beta_0)&=Var\Big(\sum\limits_{i=1}^{n}(\dfrac{1}{n}-\dfrac{(x_i-\overline{x})\overline{x}}{S_{xx}})y_i\Big)\\  &=\sum\limits_{i=1}^{n}(\dfrac{1}{n}-\dfrac{(x_i-\overline{x})\overline{x}}{S_{xx}})^2 Var(y_i)\\  &=(\dfrac{1}{n}+\dfrac{\overline{x}^2}{S_{xx}})\sigma^2\\  &=\dfrac{\sigma^2}{S_{xx}}\cdot\dfrac{\sum_{i=1}^{n}x_i^2}{n}.  \end{aligned}</script></li><li><p><strong>注</strong>  中心化处理:</p><script type="math/tex; mode=display">  y_i=\beta_0+\beta_1\overline{x}+\beta_1(x_i-\overline{x})+\varepsilon_i.</script><p>  此时常数项 $\beta_0+\beta_1\overline{x}$ 的估计 $=\hat\beta_0+\hat\beta_1\overline{x}=\overline{y}$.</p></li><li><p><strong>定义(残差)</strong>  当 $X=x_i$ 时, 拟合直线上相应点为 $(x_i,\hat\beta_0+\hat\beta_1 x_i)$.</p><p>  记 $\hat{y}_i=\hat\beta_0+\hat\beta_1 x_i$, 称为 $x_i$ 处的拟合值. 定义残差 $y_i-\hat{y}_i$. 考虑残差平方和</p><script type="math/tex; mode=display">  SSE:=\sum_{i=1}^{n}(y_i-\hat y_i)^2=\sum_{i=1}^{n}(y_i-(\hat\beta_0+\hat\beta_1 x_i))^2.</script></li><li><p><strong>命题</strong>  $\hat\sigma^2:=\dfrac{SSE}{n-2}$ 为 $\sigma^2$ 的无偏估计. 此时</p><ul><li>$\hat{se}(\hat\beta_1)=\dfrac{\hat\sigma}{\sqrt{S_{xx}}}$.</li><li>$\hat{se}(\hat\beta_0)=\hat\sigma\sqrt{\dfrac{1}{n}+\dfrac{\overline{x}^2}{S_{xx}}}$.</li></ul></li></ul><h2 id="回归参数推断"><a href="#回归参数推断" class="headerlink" title="回归参数推断"></a>回归参数推断</h2><ul><li><p><strong>追加假设</strong>  $\varepsilon_i\sim N(0,\sigma^2)$, $1\le i\le n$.</p></li><li><p><strong>注</strong></p><ul><li><p>$y_i\sim N(\beta_0+\beta_1 x_i,\sigma^2)$ 独立, $1\le i\le n$.</p></li><li><p><strong>MLE</strong>$(\beta_0^<em>,\beta_1^</em>)=(\hat\beta_0,\hat\beta_1)$ (<strong>习题课 5</strong>).</p><p>  $L(\beta_0,\beta_1,\sigma^2)=\prod\limits_{i=1}^{n}\dfrac{1}{\sqrt{2\pi}\sigma}e^{-\tfrac{(y_i-(\beta_0+\beta_1 x_i))^2}{2\sigma^2}}$.</p><p>  $(\sigma^2)^*=\dfrac{SSE}{n}$.</p></li></ul></li><li><p><strong>定义(假设检验)</strong>  $H_0:\beta_1=0$ <strong>v.s.</strong> $H_1:\beta_1\ne 0$. 因为 $\hat\beta_1$ 为 $y_i$ 的线性组合. 得到</p><script type="math/tex; mode=display">  \dfrac{\hat\beta_1-\beta_1}{\tfrac{\sigma}{\sqrt{S_{xx}}}}\sim N(0,1)</script><p>  可证明</p><script type="math/tex; mode=display">  \dfrac{SSE}{\sigma^2}=\dfrac{(n-2)\hat\sigma^2}{\sigma^2}\sim\chi^2(n-2).</script><p>  从而</p><script type="math/tex; mode=display">  \dfrac{\hat\beta_1-\beta_1}{\hat{se}(\hat\beta_1)}=\dfrac{\hat\beta_1-\beta_1}{\tfrac{\hat\sigma}{\sqrt{S_{xx}}}}=\dfrac{\hat\beta_1-\beta_1}{\tfrac{\sigma}{\sqrt{S_{xx}}}}/\sqrt{\dfrac{(n-2)\hat\sigma^2}{(n-2)\sigma^2}}\sim t(n-2).</script><p>  检验统计量:</p><script type="math/tex; mode=display">  T=\dfrac{\hat\beta_1}{\hat{se}(\hat\beta_1)}.</script><p>  当 $H_0$ 为真时, $T\sim t(n-2)$. 检验准则为: 当 $\vert T\vert\ge t_{\tfrac{\alpha}{2}}(n-2)$ 时拒绝 $H_0$.</p></li><li><p><strong>注</strong></p><ul><li>可以对其他的 $\beta_1$ 可能值进行检验.</li><li>可以对 $\beta_1$ 进行区间估计.</li><li>可以对 $\beta_0$ 进行相应推断, 过程类似.</li></ul></li></ul><h2 id="预测"><a href="#预测" class="headerlink" title="预测"></a>预测</h2><ul><li><p><strong>例</strong>  当 $X=x_0$ 时, $y_0=\beta_0+\beta_1 x_0+\varepsilon_0$, 其中 $\varepsilon\sim N(0,\sigma^2)$. 令</p><script type="math/tex; mode=display">  \mu_0=E(y_0)=\beta_0+\beta_1 x_0,</script><p>  给出对 $\mu_0$ 的预测.</p></li><li><p><strong>解答</strong>  用拟合直线上 $x_0$ 处的取值 $\hat y_0$ 给出 $\mu_0$ 的点估计:</p><script type="math/tex; mode=display">  \hat y_0=\hat\beta_0+\hat\beta_1x_0=\overline{y}-\hat\beta_1(x_0-\overline{x})=\sum_{i=1}^{n}(\dfrac{1}{n}+\dfrac{(x_i-\overline{x})(x_0-\overline{x})}{S_{xx}})y_i</script><p>  分别给出</p><ul><li>$E(\hat y_0)=E(\hat\beta_0+\hat\beta_1x_0)=\beta_0+\beta_1x_0=\mu_0$.</li><li><p>$Var(\hat y_0)=\sum_{i=1}^{n}\Big(\dfrac{1}{n}+\dfrac{(x_i-\overline{x})(x_0-\overline{x})}{S_{xx}}\Big)^2\sigma^2=\Big(\dfrac{1}{n}+\dfrac{(x_0-\overline{x})^2}{S_{xx}}\Big)\sigma^2$.</p><p>从而</p><script type="math/tex; mode=display">\dfrac{\hat y_0-\mu_0}{se(\hat y_0)}\sim N(0,1).</script><p>使用 $\hat{se}(\hat y_0)=\hat\sigma\sqrt{\dfrac{1}{n}+\dfrac{(x_0-\overline{x})^2}{S_{xx}}}$ 估计 $se(\hat y_0)$, 我们有</p><script type="math/tex; mode=display">\dfrac{\hat y_0-\mu_0}{\hat{se}(\hat y_0)}\sim t(n-2).</script><p>从而 $\mu_0$ 的 $(1-\alpha)-$ 置信的双侧区间估计为</p><script type="math/tex; mode=display">\Big(\hat y_0-t_{\tfrac{\alpha}{2}}\hat\sigma\sqrt{\dfrac{1}{n}+\dfrac{(x_0-\overline{x})^2}{S_{xx}}},\hat y_0+t_{\tfrac{\alpha}{2}}\hat\sigma\sqrt{\dfrac{1}{n}+\dfrac{(x_0-\overline{x})^2}{S_{xx}}}\Big).</script></li></ul></li><li><p><strong>例</strong>  当 $X=x_0$ 时, $y_0=\beta_0+\beta_1 x_0+\varepsilon_0$, 其中 $\varepsilon\sim N(0,\sigma^2)$. 给出对 $y_0$ 的预测.</p></li><li><p><strong>解答</strong>  $y_0\sim N(\mu_0,\sigma^2)$. 若 $\mu_0$ 已知, 则 $y_0$ 的(均方意义下最优)估计为 $\mu_0$.</p><p>  一般情况下, $y_0$ 的良好点估计为 $\hat y_0=\hat\beta_0+\hat\beta_1x_0$.</p><p>  注意到 $y_0$ 与 $\hat y_0$ 相互独立, 从而 $\hat y_0- y_0$ 服从正态分布.</p><p>  分别给出</p><ul><li>$E(\hat y_0-y_0)=E(\hat y_0)-E(y_0)=\mu_0-\mu_0=0$.</li><li><p>$Var(\hat y_0-y_0)=Var(\hat y_0)+Var(y_0)=\sigma^2(1+\dfrac{1}{n}+\dfrac{(x_0-\overline{x})^2}{S_{xx}})$.</p><p>从而</p><script type="math/tex; mode=display">\dfrac{\hat y_0-y_0}{\sigma\sqrt{1+\dfrac{1}{n}+\dfrac{(x_0-\overline{x})^2}{S_{xx}}}}\sim N(0,1).</script><p>进而</p><script type="math/tex; mode=display">\dfrac{\hat y_0-y_0}{\hat\sigma\sqrt{1+\dfrac{1}{n}+\dfrac{(x_0-\overline{x})^2}{S_{xx}}}}\sim t(n-2).</script></li></ul></li></ul><pre><code>从而 $y_0$ 的 $(1-\alpha)-$ 置信的双侧区间估计为$$\Big(\hat y_0-t_{\tfrac{\alpha}{2}}\hat\sigma\sqrt{1+\dfrac{1}{n}+\dfrac{(x_0-\overline{x})^2}{S_{xx}}},\hat y_0+t_{\tfrac{\alpha}{2}}\hat\sigma\sqrt{1+\dfrac{1}{n}+\dfrac{(x_0-\overline{x})^2}{S_{xx}}}\Big).$$</code></pre><ul><li><p><strong>注</strong>  当 $x_0$ 与 $\overline{x}$ 距离增加时, 估计误差增大.</p></li><li><p><strong>注</strong></p><ul><li>结合实际理解 $\beta$.</li><li>外推需谨慎.</li><li>截距为 0 的回归复杂度 $n-2\rightarrow n-1$.</li><li>回归方程不可逆转使用.</li><li>常见应用:<ul><li>描述趋势.</li><li>预测均值\取值.</li><li>实验控制.</li></ul></li></ul></li></ul>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;Chap-8-线性回归&quot;&gt;&lt;a href=&quot;#Chap-8-线性回归&quot; class=&quot;headerlink&quot; title=&quot;Chap 8 线性回归&quot;&gt;&lt;/a&gt;Chap 8 线性回归&lt;/h1&gt;&lt;h2 id=&quot;回归问题&quot;&gt;&lt;a href=&quot;#回归问题&quot;</summary>
        
      
    
    
    
    <category term="Math" scheme="http://chengsx21.github.io/categories/Math/"/>
    
    <category term="Probability Theory" scheme="http://chengsx21.github.io/categories/Math/Probability-Theory/"/>
    
    
    <category term="Probability Theory" scheme="http://chengsx21.github.io/tags/Probability-Theory/"/>
    
  </entry>
  
  <entry>
    <title>概率论与数理统计 笔记7</title>
    <link href="http://chengsx21.github.io/2023/05/20/gai-lu-lun-yu-shu-li-tong-ji-bi-ji-7/"/>
    <id>http://chengsx21.github.io/2023/05/20/gai-lu-lun-yu-shu-li-tong-ji-bi-ji-7/</id>
    <published>2023-05-20T09:27:40.000Z</published>
    <updated>2023-09-22T08:18:26.006Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Chap-7-假设检验"><a href="#Chap-7-假设检验" class="headerlink" title="Chap 7 假设检验"></a>Chap 7 假设检验</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li><p><strong>例(女士品茶)</strong>  某女士声称可区分奶茶是先加牛奶还是先加茶. <strong>R.Fisher</strong> 设计实验: 各有 4 杯奶茶随机排成一排, 将这一信息告知女士. 考虑假设 $H$: 该女士没有区分能力. 当 $H$ 正确的情况下, 4 杯全对的概率为</p><script type="math/tex; mode=display">  \dfrac{C_4^4\cdot C_4^0}{C_8^4}=\dfrac{1}{70}.</script><p>  下述两种情况之一必发生:</p><ul><li>$H$ 不正确 (<strong>i.e.</strong>该女士有区分能力);</li><li><p>$H$ 正确 (发生了一件概率为 $\dfrac{1}{70}$ 的事情).</p><p>通常选择阈值 $\alpha=0.05,0.01,0.1$ (预先给定的显著性水平). 若女士选对了三杯, 则在 $H$ 正确的前提下, 挑对三杯及以上的概率为</p><script type="math/tex; mode=display">\dfrac{C_4^4\cdot C_4^0}{C_8^4}+\dfrac{C_4^3\cdot C_4^1}{C_8^4}=\dfrac{17}{70}\approx 0.243.</script></li></ul></li><li><p><strong>注</strong></p><ul><li><p><strong>Fisher</strong> 显著性检验;</p></li><li><p>若认可某组观测(样本), 则用它来证实或证伪某个理论(断言)具有天然的不对等;</p></li><li><p>$H$ 可以模型化:</p><script type="math/tex; mode=display">  P(X=k)\dfrac{C_4^k\cdot C_4^{4-k}}{C_8^4}.</script></li><li><p>历史注记:</p><ul><li><strong>Fisher</strong> 显著性检验;</li><li><strong>Neyman-Pearson</strong> 检验;</li><li>零假设显著性检验 (<strong>MHST</strong>).</li></ul></li></ul></li><li><p><strong>定义(统计假设)</strong>  对一个或多个总体的某种断言或猜测.</p><ul><li>原假设: 被检验的假设 $H_0$;</li><li>备择假设: 拒绝 $H_0$ 后可供选择的假设 $H_1$.</li><li>若假设可表为参数形式, 那么 $H_0: \theta\in\Theta_0$, $H_1: \theta\in\Theta_1$, 且 $\Theta_0\cap\Theta_1=\varnothing$, $\Theta_0\cup\Theta_1=\theta$ 的所有可能取值之集.</li></ul></li><li><p><strong>例</strong>  假设 $X\sim N(\mu,\sigma^2)$, 其中 $\sigma^2$ 已知.</p><ul><li>$H_0:\mu=\mu_0,\quad H_1:\mu\ne\mu_0$. (双侧假设)</li><li>$H_0:\mu=\mu_0,\quad H_1:\mu&gt;\mu_0$. (单侧假设)</li><li>$H_0:\mu\le\mu_0,\quad H_1:\mu&gt;\mu_0$. (单侧假设)</li><li>$H_0:\mu_1=\mu_2,\quad H_1:\mu_1\ne\mu_2$. (双侧假设)</li></ul></li><li><p><strong>注</strong></p><ul><li>简单假设: 只对应一个总体;</li><li>复合假设: 对应多个总体;</li><li>若 $\sigma^2$ 未知, 则 $H_0: \mu=\mu_0\Leftrightarrow H_0: \mu=\mu_0,\sigma^2$ 任意, 是一个复合假设.</li></ul></li><li><p><strong>定义(假设检验)</strong>  依据样本(观测)的决策(拒绝或不拒绝 $H_0$)过程.</p></li><li><p><strong>定义(检验准则)</strong>  做出决策的一个具体法则.</p></li><li><p><strong>定义(拒绝)</strong>  在原假设 $H_0$ 为真的前提下, 所观测的样本出现的概率如果是很小的, 意味着样本提供的概率拒绝 $H_0$.</p></li><li><p><strong>定义(拒绝域/临界域)</strong>  形式上可抽象为</p><script type="math/tex; mode=display">  R=\{(X_1,\cdots,X_n)\mid T(X_1,\cdots,X_n)\ge c\}.</script><p>  其中 $c$ 被定义为临界值. 此时检验准则为, 若样本 $(X_1,\cdots,X_n)\in R$, 则拒绝假设 $H_0$.</p></li><li><p><strong>定义(显著性检验)</strong>  对事先给定的 $\alpha\in(0,1)$, 若 $P_{\theta}(T(X_1,\cdots,X_n)\ge c)\le\alpha$, $\forall\,\theta\in\Theta_0$, 则称这是一个水平为 $\alpha$ 的显著性检验.</p></li><li><p><strong>例</strong>  假设 $X\sim N(\mu,\sigma^2)$, 其中 $\sigma^2$ 已知, 给定检验水平 $\alpha\in(0,1)$ 和已观测样本 $X_i(1\le i\le n)$. $H_0:\mu=\mu_0$, $H_1:\mu\ne\mu_0$. 对原假设进行检验.</p></li><li><p><strong>解答</strong>  拒绝域为双侧拒绝, 当 $H_0$ 为真时, 控制 $P(\vert\overline{X}-\mu_0\vert\ge c)\le\alpha$. </p><p>  根据 <strong>CLT</strong>, 注意到</p><script type="math/tex; mode=display">  \overline{X}-\mu_0\sim N(0,\dfrac{\sigma^2}{n})\Leftrightarrow\dfrac{\overline{X}-\mu_0}{\tfrac{\sigma}{\sqrt{n}}}\sim N(0,1).</script><p>  取 $\dfrac{c}{\tfrac{\sigma}{\sqrt{n}}}=Z_{\tfrac{\alpha}{2}}\Rightarrow c=\dfrac{\sigma}{\sqrt{n}}\cdot Z_{\tfrac{\alpha}{2}}$. </p><p>  给出在 $\alpha$ 的检验水平下拒绝 $H_0$ 的条件: 若 $\vert\overline{X}-\mu_0\vert\ge\dfrac{\sigma}{\sqrt{n}}\cdot Z_{\tfrac{\alpha}{2}}$, 则拒绝 $H_0$.</p></li><li><p><strong>例</strong>  假设 $X\sim N(\mu,\sigma^2)$, 其中 $\sigma^2$ 已知, 给定检验水平 $\alpha\in(0,1)$ 和已观测样本 $X_i(1\le i\le n)$. $H_0:\mu\ge\mu_0$, $H_1:\mu&lt;\mu_0$. 对原假设进行检验.</p></li><li><p><strong>解答</strong>  拒绝域为单侧拒绝, 当 $H_0$ 为真时, 控制 $P(\overline{X}\le c)\le\alpha$.</p><p>  根据 <strong>CLT</strong>, 注意到</p><script type="math/tex; mode=display">  \overline{X}-\mu\sim N(0,\dfrac{\sigma^2}{n})\Leftrightarrow\dfrac{\overline{X}-\mu}{\tfrac{\sigma}{\sqrt{n}}}\sim N(0,1).</script><p>  因此</p><script type="math/tex; mode=display">  \begin{aligned}  P(\overline{X}\le c)&=P(\dfrac{\overline{X}-\mu}{\tfrac{\sigma}{\sqrt{n}}}\le \dfrac{c-\mu}{\tfrac{\sigma}{\sqrt{n}}})\\  &=P(Z\le\dfrac{c-\mu}{\tfrac{\sigma}{\sqrt{n}}})\\  &=\varPhi(\dfrac{c-\mu}{\tfrac{\sigma}{\sqrt{n}}}),\forall\,\mu\ge\mu_0.  \end{aligned}</script></li></ul><pre><code>取 $\dfrac{c-\mu_0}{\tfrac{\sigma}{\sqrt{n}}}=-Z_{\alpha}\Rightarrow c=\mu_0-\dfrac{\sigma}{\sqrt{n}}\cdot Z_{\alpha}$. 给出在 $\alpha$ 的检验水平下拒绝 $H_0$ 的条件: 若 $\overline{X}\le\mu_0-\dfrac{\sigma}{\sqrt{n}}\cdot Z_{\alpha}$, 则拒绝 $H_0$.</code></pre><ul><li><p><strong>注</strong></p><ul><li><p>这种方法称为 $Z$-检验.</p></li><li><p>若 $\sigma^2$ 未知, 考虑</p><script type="math/tex; mode=display">  \dfrac{\overline{X}-\mu}{\tfrac{S}{\sqrt{n}}}\sim t(n-1).</script><p>  这种方法称为 $t$-检验.</p></li></ul></li></ul><h2 id="Neyman-Pearson-假设检验"><a href="#Neyman-Pearson-假设检验" class="headerlink" title="Neyman-Pearson 假设检验"></a>Neyman-Pearson 假设检验</h2><ul><li><p><strong>定义(错误)</strong>  Ⅰ类错误: 在 $H_0$ 为真时拒绝 $H_0$; Ⅱ类错误: 在 $H_0$ 为假时不拒绝 $H_0$. 对应的概率分别为:</p><script type="math/tex; mode=display">  \begin{aligned}  \alpha(R)&:=P_{\theta}(Ⅰ)=P_{\theta}((X_1,\cdots,X_n)\in R),\theta\in\Theta_0;\\  \beta(R)&:=P_{\theta}(Ⅱ)=P_{\theta}((X_1,\cdots,X_n)\in R^c),\theta\in\Theta_1.  \end{aligned}</script><p>  对于已划分的 $R$ 来说, 是定义域不同的 $\theta$ 的函数.</p></li><li><p><strong>注</strong></p><ul><li>依据样本做决策, 错误不能根本避免;</li><li>一次决策不能同时犯两种错误;</li><li>$n$ 固定, 两种错误发生的概率此消彼长.</li></ul></li><li><p><strong>例(直觉)</strong></p><ul><li>都不拒绝 $H_0$, 那么 $P_{\theta}(Ⅰ)=0$, $P_{\theta}(Ⅱ)=1$.</li><li>考虑事件 $H_0:$ 合格, 事件 $H_1:$ 不合格, 当 $P_{\theta}(Ⅰ)$ 变小时, 不容易拒绝事件, 不合格不容易被检出, 从而 $P_{\theta}(Ⅱ)$ 变大.</li></ul></li><li><p><strong>定义(功效函数)</strong>    给定 $\theta$ 与临界域 $R$, 拒绝原假设 $H_0$ 的概率为:</p><script type="math/tex; mode=display">  P_{\theta}((X_1,\cdots,X_n)\in R)=1-\beta(R),\,\theta\in\Theta_1.</script></li><li><p><strong>定义(Neyman-Pearson 范式)</strong>  $n$ 固定, 控制 $P_{\theta}(Ⅰ)\le\alpha$, 其中 $\alpha$ 为预先给定的检验水平, 再在这个限制下使 $P_{\theta}(Ⅱ)(\theta\in\Theta_1)$ 尽可能小.</p></li><li><p><strong>注</strong></p><ul><li>$\alpha$ 固定时, 使 $P_{\theta}(Ⅱ)(\theta\in\Theta_1)$ 最小的检验称为水平 $\alpha$ 下的一致最优检验;</li><li>原假设 $H_0$ 和备择假设 $H_1$ 一般是地位不对等的:<ul><li>原假设通常是受到保护的, 证据不充分不能拒绝;</li><li>备择假设通常是真正感兴趣的.</li></ul></li><li>一致最优检验不一定存在, 一般也不易求解;</li><li>$\mu_0\in$ 置信区间 $\Leftrightarrow$ 假设检验 $(H_0: \mu=\mu_0, H_1: \mu\ne\mu_0)$ 不拒绝 $H_0$.</li></ul></li></ul><h2 id="假设检验与置信区间"><a href="#假设检验与置信区间" class="headerlink" title="假设检验与置信区间"></a>假设检验与置信区间</h2><ul><li><p><strong>例</strong>  $X\sim N(\mu,\sigma^2)$, $\sigma^2$ 已知, $\alpha&gt;0$ 给定, $X_1,\cdots,X_n$ 为随机样本.</p></li><li><p><strong>解答 </strong> 其双侧置信区间为</p><script type="math/tex; mode=display">  P=(\overline{X}-Z_{\tfrac{\alpha}{2}}\dfrac{\sigma}{\sqrt{n}},\overline{X}+Z_{\tfrac{\alpha}{2}}\dfrac{\sigma}{\sqrt{n}}).</script><p>  考虑假设检验 $H_0:\mu=\mu_0$, $H_1:\mu\ne\mu_0$. 需要控制</p><script type="math/tex; mode=display">  P_{H_0}(\vert\overline{X}-\mu_0\vert\ge c)\le\alpha.</script><p>  检验准则为 $\vert\overline{X}-\mu_0\vert\ge Z_{\tfrac{\alpha}{2}}\dfrac{\sigma}{\sqrt{n}}$ 时拒绝 $H_0$. 我们给出接受域</p><script type="math/tex; mode=display">  R^c=\{(X_1,\cdots,X_n)\mid \vert\overline{X}-\mu_0\vert<Z_{\tfrac{\alpha}{2}}\dfrac{\sigma}{\sqrt{n}}\}\\  =\{(X_1,\cdots,X_n)\mid \mu_0\in P\}.</script><p>  由此可见, $\mu_0\in P\Leftrightarrow$ 用 $\overline{X}$ 为检验统计量, 假设检验不拒绝 $H_0$.(<strong>对偶关系</strong>)</p></li></ul><h2 id="检验的-P-值"><a href="#检验的-P-值" class="headerlink" title="检验的 P 值"></a>检验的 P 值</h2><ul><li><p><strong>定义</strong>  当原假设 $H_0$ 为真时, 检验统计量的观测值以及更极端观测出现的概率. </p></li><li><p><strong>例(选举问题)</strong>  $n=1200$, 调查到的支持比例为 $\tfrac{684}{1200}\approx 0.57$ (观测值).</p></li><li><p><strong>解答</strong>  (1) $H_0:p=p_0$ v.s. $H_1:p&gt;p_0$ ($p_0$ 预先给定).</p><p>  考虑检验统计量 $P_n$, 则由 <strong>CLT</strong>:</p><script type="math/tex; mode=display">  \dfrac{P_n-p}{\sqrt{\tfrac{p(1-p)}{n}}}\stackrel{近似}{\sim}N(0,1).</script><p>  当 $H_0$ 为真时, $p=p_0$, 此时 $se(P_n)=\sqrt{\dfrac{p_0(1-p_0)}{n}}$. 因此 <strong>P</strong> 值</p><script type="math/tex; mode=display">  P_{H_0}(P_n\ge p_n)=P(\dfrac{P_n-p_0}{se(P_n)}\ge\dfrac{p_n-p_0}{se(P_n)})\approx P(Z\ge z_0).</script><p>  其中</p><script type="math/tex; mode=display">  Z\stackrel{近似}{\sim}N(0,1),z_0=\dfrac{p_n-p_0}{se(P_n)}=\dfrac{p_n-p_0}{\sqrt{\tfrac{p_0(1-p_0)}{n}}}.</script><p>  因此</p><script type="math/tex; mode=display">  P_{H_0}(P_n\ge p_n)=1-\varPhi(\dfrac{p_n-p_0}{\sqrt{\tfrac{p_0(1-p_0)}{n}}}).</script><p>  若 $p_0=0.55$, 则 <strong>P</strong> 值 $\approx 0.081$; 若 $p_0=0.5$, 则 <strong>P</strong> 值 $\ll 0.001$.</p><p>  在水平 $\alpha$ 下拒绝 $H_0\Leftrightarrow$ <strong>P</strong> 值 $\le\alpha$.</p></li><li><p><strong>注</strong></p><ul><li><strong>P</strong> 值作为数据 (观测) 拒绝 $H_0$ 的证据.</li><li>强弱的度量: <strong>P</strong> 值越小, 拒绝 $H_0$ 的证据越强 (非正式的).</li><li><strong>P</strong> 值 $\ne$ $P(H_0\mid $ 观测$)$.</li><li>若 <strong>P</strong> 值不小, 则不拒绝 $H_0$, 原因可能为 $H_0$ 真 / $H_0$ 不真, 但检验功效不大.</li></ul></li><li><p><strong>定义</strong>  若拒绝 $H_0:\theta\in\Theta_0\Leftrightarrow T(X_1,\cdots,X_n)\ge C$, 则检验的 <strong>P</strong> 值 $:=$</p><script type="math/tex; mode=display">  \sup_{\theta\in\Theta_0}P_{\theta}(T(X_1,\cdots,X_n)\ge T(x_1,\cdots,x_n)).</script><p>  其中 $T(x_1,\cdots,x_n)$ 为检验统计量的观测值.</p></li><li><p><strong>解答</strong>  (2) $H_0:p\le p_0$ v.s. $H_1:p&gt;p_0$ ($p_0$ 预先给定).</p><p>  考虑检验统计量 $P_n$, 则由 <strong>CLT</strong>:</p><script type="math/tex; mode=display">  \dfrac{P_n-p}{\sqrt{\tfrac{p(1-p)}{n}}}\stackrel{近似}{\sim}N(0,1).</script><p>  当 $H_0$ 为真时, 此时 $se(P_n)\approx \hat{se}(P_n)=\sqrt{\dfrac{p_n(1-p_n)}{n}}$. 因此 <strong>P</strong> 值</p><script type="math/tex; mode=display">  P_{H_0}(P_n\ge p_n)=P(\dfrac{P_n-p}{\hat{se}(P_n)}\ge\dfrac{p_n-p}{\hat{se}(P_n)})\approx P(Z\ge z_0).</script><p>  其中</p><script type="math/tex; mode=display">  Z\stackrel{近似}{\sim}N(0,1),z_0=\dfrac{p_n-p}{\hat{se}(P_n)}=\dfrac{p_n-p}{\sqrt{\tfrac{p_n(1-p_n)}{n}}}.</script><p>  因此</p><script type="math/tex; mode=display">  P_{H_0}(P_n\ge p_n)=1-\varPhi(\dfrac{p_n-p}{\sqrt{\tfrac{p_n(1-p_n)}{n}}}),\forall\,p\le p_0.</script><p>  因此 <strong>P</strong> 值</p><script type="math/tex; mode=display">  \sup_{p\le p_0}\Big(1-\varPhi(\dfrac{p_n-p}{\sqrt{\tfrac{p_n(1-p_n)}{n}}})\Big)=1-\varPhi(\dfrac{p_n-p_0}{\sqrt{\tfrac{p_n(1-p_n)}{n}}}).</script><p>  若 $p_0=0.55$, 则 <strong>P</strong> 值 $\approx 0.081$; 若 $p_0=0.5$, 则 <strong>P</strong> 值 $\ll 0.001$.</p></li></ul><h2 id="拟合优度检验"><a href="#拟合优度检验" class="headerlink" title="拟合优度检验"></a>拟合优度检验</h2><ul><li><p><strong>定义(Pearson 卡方统计量)</strong></p><script type="math/tex; mode=display">  \chi^2:=\sum_{i=1}^{k}\dfrac{(O_i-E_i)^2}{E_i}\stackrel{近似}{\sim}\chi^2(k-1).</script><p>  其中 $O_i$ 为观测频数, $E_i$ 为期望频数 ($H_0$ 真的条件下).</p></li><li><p><strong>定理</strong>  $H_0: P(X\in$ 第 $i$ 单元$)=p_i(1\le i\le k)$. 若 $H_0$ 为真, 当 $n\rightarrow\infty$ 时, 有</p><script type="math/tex; mode=display">  \chi^2\rightarrow\chi^2(k-1).</script></li><li><p><strong>例</strong>  投掷一枚骰子 60 次.</p><p>  | 点数     | 1    | 2    | 3    | 4    | 5    | 6    | 总计 |<br>  | ———— | —— | —— | —— | —— | —— | —— | —— |<br>  | 观测频数 | 4    | 6    | 17   | 16   | 8    | 9    | 60   |<br>  | 期望频数 | 10   | 10   | 10   | 10   | 10   | 10   | 60   |</p><p>  $H_0:$ 分布均匀, $H_1:$ 分布不均匀.</p></li><li><p><strong>解答</strong>  检验统计量的观测值:</p><script type="math/tex; mode=display">  \dfrac{(4-10)^2}{10}+\dfrac{(6-10)^2}{10}+\cdots+\dfrac{(9-10)^2}{10}=14.2.</script><p>  自由度为 $6-1=5$. <strong>P</strong> 值 $=P_{H_0}(\chi^2\ge 14.2)\approx 0.014$.</p></li><li><p><strong>注</strong>  在实际应用中, 需要满足 $E_i=nP_i\ge 5$, 才能较好使用 <strong>Pearson</strong> 定理.</p></li><li><p><strong>例(列联表独立性检验)</strong>  对某项议题态度与年龄段是否独立.</p><p>  |      | 青年 | 中年 | 老年 |      |<br>  | —— | —— | —— | —— | —— |<br>  | 支持 | 20   | 40   | 20   | 80   |<br>  | 反对 | 30   | 30   | 10   | 70   |<br>  |      | 50   | 70   | 30   | 150  |</p><p>  $H_0:$ 独立, $H_1:$ 不独立.</p></li><li><p><strong>解答</strong>  $P_{ij}=P_{i+}P_{+j}$, 其中 $P_{i+}$, $P_{+j}$ 称为边际概率.</p><p>  在 $H_0$ 为真前提下估计 $P_{ij}$. <strong>MLE</strong>:</p><script type="math/tex; mode=display">  P_{ij}^*=(P_{i+}P_{+j})^*=P_{i+}^*P_{+j}^*=\dfrac{sum(row_i)}{n}\times\dfrac{sum(column_j)}{n}.</script><p>  得到</p><script type="math/tex; mode=display">  E_{ij}=nP_{ij}\approx nP_{ij}^*=\dfrac{1}{n}sum(row_i)\times sum(column_j).</script><p>  计算得检验统计量观测值为 6.12, 自由度为 $(a-1)(b-1)=2$.</p><p>  得到 <strong>P</strong> 值 $=P_{H_0}(\chi^2\ge 6.12)\approx 0.0469$.</p></li><li><p><strong>注</strong>  对于 $a$ 行 $b$ 列, 当 $H_0$ 成立时, 其未知参数个数为 $s=(a-1)+(b-1)$.</p><p>  因此卡方自由度为:</p><script type="math/tex; mode=display">  ab-1-s=ab-1-(a-1)-(b-1)=(a-1)(b-1).</script></li></ul><h2 id="似然比检验"><a href="#似然比检验" class="headerlink" title="似然比检验"></a>似然比检验</h2><ul><li><p><strong>例</strong>  两种硬币 ($p=0.5$, $p=0.7$) 投掷 $n=10$ 次, 正面向上 $X=x$ 次. 提出假设 $H_0:p=0.5$ v.s. $p=0.7$. 考虑</p><script type="math/tex; mode=display">  \dfrac{P_{H_0}(X=x)}{P_{H_1}(X=x)}\le c\leftrightarrow x 的范围</script><p>  我们需要控制</p><script type="math/tex; mode=display">  P_{H_0}\Big(似然比\le c\Big)\le\alpha.</script></li><li><p><strong>注</strong></p><ul><li>当 $H_0$, $H_1$ 均为简单假设时 (<strong>N-P</strong>), 证明: 似然比检验最优 (功效最大).</li><li>当 $H_0$, $H_1$ 不全为简单假设时, 似然比检验一般不最优, 但通常表现不错.</li></ul></li><li><p><strong>定义(广义似然比)</strong>  $H_0:\theta\in\Theta_0$ v.s. $H_1:\theta\in\Theta_1$, $X_1,\cdots,X_n$ 为随机样本.</p><p>  考虑广义似然比</p><script type="math/tex; mode=display">  \Lambda^*:=\dfrac{\sup_{\theta\in\Theta_0}L(\theta)}{\sup_{\theta\in\Theta_1}L(\theta)}</script><p>  基于技术原因, 检验统计量选为</p><script type="math/tex; mode=display">  \Lambda:=\dfrac{\sup_{\theta\in\Theta_0}L(\theta)}{\sup_{\theta\in\Theta_0\cup\Theta_1}L(\theta)}=\min\{\Lambda^*,1\}=\Lambda(X_1,\cdots,X_n).</script><p>  $\Lambda$ 越小则越反对 $H_0$ (拒绝域的形状). 选择 $\lambda_0$ 使</p><script type="math/tex; mode=display">  P_{H_0}(\Lambda\le\lambda_0)\le\alpha.</script><p>  至此得到了检验准则.</p></li><li><p><strong>定理</strong>  在一定(光滑性)条件下, 当 $n\rightarrow\infty$ 时, 在 $H_0$ 为真前提下:</p><script type="math/tex; mode=display">  -2\log\Lambda\rightarrow\chi^2(d).</script><p>  其中自由度 $d=\dim(\Theta_0\cup\Theta_1)-\dim(\Theta_0)$. 这里的 $\dim$ 指自由参数的个数.</p></li><li><p><strong>例(多项分布检验)</strong>  $H_0:p_1=p_1^<em>$, $\cdots$, $p_k=p_k^</em>$, 观测频数分别为 $n_1,\cdots,n_k$.</p></li><li><p><strong>解答</strong>  得到</p><script type="math/tex; mode=display">  L(p_1,\cdots,p_k)=C_n^{n_1,\cdots,c_k}p_1^{n_1}\cdots p_k^{n_k}.</script><p>  因此</p><script type="math/tex; mode=display">  \Lambda=\dfrac{\sup_{\theta\in\Theta_0}L(\theta)}{\sup_{\theta\in\Theta_0\cup\Theta_1}L(\theta)}=\dfrac{L(p_1^0,\cdots,p_k^0)}{L(p_1^*,\cdots,p_k^*)}.</script><p>  已知</p><script type="math/tex; mode=display">  n_i=np_i^*,E_i=np_i^0,O_i=n_i.</script><p>  且</p><script type="math/tex; mode=display">  x\log\dfrac{x}{x_0}\stackrel{Taylor}{=}0+(x-x_0)+\dfrac{1}{2}\dfrac{(x-x_0)^2}{x_0}+\cdots</script><p>  计算得</p><script type="math/tex; mode=display">  \begin{aligned}  -2\log\Lambda&=-2\sum_{i=1}^{k}\log\big(\dfrac{p_i^0}{p_i^*}\big)^{n_i}\\  &=-2\sum_{i=1}^{k}n_i\log\dfrac{p_i^0}{p_i^*}\\  &=2\sum_{i=1}^{k}O_i\log\dfrac{O_i}{E_i}\\  &=\sum_{i=1}^{k}\dfrac{(O_i-E_i)^2}{E_i}+\cdots.  \end{aligned}</script><p>  考虑到 $\dim(\Theta_0)=0$, $\dim(\Theta_0\cup\Theta_1)=k-1$, 因此给出</p><script type="math/tex; mode=display">  \sum_{i=1}^{k}\dfrac{(O_i-E_i)^2}{E_i}\stackrel{近似}{\sim}\chi^2(k-1).</script></li></ul><h2 id="两独立总体比较"><a href="#两独立总体比较" class="headerlink" title="两独立总体比较"></a>两独立总体比较</h2><ul><li><p>两独立总体:</p><p>  | 总体 | 均值    | 方差         | 样本 (iid)       |<br>  | —— | ———- | —————— | ———————— |<br>  | $X$  | $\mu_1$ | $\sigma_1^2$ | $X_1,\cdots,X_n$ |<br>  | $Y$  | $\mu_2$ | $\sigma_2^2$ | $Y_1,\cdots,Y_m$ |</p></li><li><p><strong>定义(比较均值)</strong>:</p><p>  给出 $E(\overline{X}-\overline{Y})=\mu_1-\mu_2$, $Var(\overline{X}-\overline{Y})=\dfrac{\sigma_1^2}{n}+\dfrac{\sigma_2^2}{m}=se^2$. 参考置信区间部分.</p></li><li><p><strong>定理</strong>  给出 $W_1\sim\chi^2(k_1)$, $W_2\sim\chi^2(k_2)$, 且 $W_1,W_2$ 独立, 我们有</p><script type="math/tex; mode=display">  \dfrac{W_1/k_1}{W_2/k_2}\sim F(k_1,k_2).</script></li><li><p><strong>定义(比较方差)</strong>: 假设 $X$, $Y$ 均为正态. 提出假设 $H_0:\sigma_1^2=\sigma_2^2$ v.s. $H_1:\sigma_1^2\ne\sigma_2^2$.</p><script type="math/tex; mode=display">  \dfrac{(n-1)S_1^2}{\sigma_1^2}\sim\chi^2(n-1), \dfrac{(m-1)S_2^2}{\sigma_2^2}\sim\chi^2(m-1).</script><p>  考虑检验统计量(依赖于<strong>样本</strong>或<strong>已知参数</strong>)</p><script type="math/tex; mode=display">  \dfrac{S_1^2}{S_2^2}.</script><p>  当 $H_0$ 为真时, 有</p><script type="math/tex; mode=display">  \dfrac{S_1^2}{S_2^2}\sim F(n-1,m-1).</script><p>  检验准则为当</p><script type="math/tex; mode=display">  \dfrac{S_1^2}{S_2^2}\ge F_{\tfrac{\alpha}{2}}(n-1,m-1)\,或\,\dfrac{S_1^2}{S_2^2}\le F_{1-\tfrac{\alpha}{2}}(n-1,m-1)</script><p>  时拒绝原假设.</p></li><li><p><strong>注</strong>  由定义 $F_{1-\tfrac{\alpha}{2}}(n-1,m-1)=\dfrac{1}{F_{\tfrac{\alpha}{2}}(m-1,n-1)}$.</p></li><li><p><strong>例(比较成功率/失败率)</strong>  阿司匹林对降低心脏病发病率的有效性.</p><p>  |          | 心脏病发作 | 心脏病未发作 | 合计  | 发作率 |<br>  | ———— | ————— | —————— | ——- | ——— |<br>  | 阿司匹林 | 139        | 10898        | 11037 | 0.0126 |<br>  | 安慰剂   | 239        | 10795        | 11034 | 0.0217 |</p><p>  提出假设 $H_0:p_1=p_2$ (无效) v.s. $H_1:p_1&lt;p_2$ (有效), 检验统计量为 $P_1-P_2$.</p><p>  容易得到 $E(P_1-P_2)=p_1-p_2$, $Var(P_1-P_2)=\dfrac{p_1(1-p_1)}{n_1}+\dfrac{p_2(1-p_2)}{n_2}$.</p><p>  那么</p><script type="math/tex; mode=display">  \dfrac{(P_1-P_2)-(p_1-p_2)}{se}\stackrel{近似}{\sim}N(0,1).</script><p>  在 $H_0$ 为真前提下, 有</p><script type="math/tex; mode=display">  se^2=p(1-p)(\dfrac{1}{n_1}+\dfrac{1}{n_2})\approx p^*(1-p^*)(\dfrac{1}{n_1}+\dfrac{1}{n_2}).</script><p>  其中 $p^<em>=\dfrac{k_1+k_2}{n_1+n_2}$, 得 $se^2\approx\hat{se}^2=0.00175^2$. 结合 $\dfrac{P_1-P_2}{\hat{se}}\stackrel{近似}{\sim}N(0,1)$, 得 <em>*P</em></em> 值</p><script type="math/tex; mode=display">  P\Big(\dfrac{P_1-P_2}{\hat{se}}\le\dfrac{0.0126-0.0217}{0.00175}\Big)\approx P(Z\le -5.20)\approx 10^{-7}.</script><p>  因此有理由拒绝 $H_0$.</p></li><li><p><strong>注</strong></p><ul><li>随机分组.</li><li>双盲实验.</li><li>$n$ 充分大.</li></ul></li><li><p><strong>例(行驶里程)</strong>  比较两种油 <strong>A</strong> 与 <strong>B</strong> 的行驶里程.</p><p>  |          | 样本容量 | 平均里程 | 样本标准差 |<br>  | ———— | ———— | ———— | ————— |<br>  | 油 <strong>A</strong> | 50       | 25       | 5.00       |<br>  | 油 <strong>B</strong> | 50       | 26       | 4.00       |</p><p>  提出假设 $H_0:\mu_A=\mu_B$ v.s. $H_1:\mu_A\ne\mu_B$, 检验统计量为 $\overline{X}_A-\overline{X}_B$.</p><p>  在 $H_0$ 为真前提下, 有</p><script type="math/tex; mode=display">  \dfrac{\overline{X}_A-\overline{X}_B}{\sqrt{\tfrac{S_1^2}{n_1}+\tfrac{S_2^2}{n_2}}}\sim N(0,1).</script><p>  其中 $\hat{se}\approx 0.905$. 得 <strong>P</strong> 值</p><script type="math/tex; mode=display">  P\Big(\vert\dfrac{\overline{X}_A-\overline{X}_B}{\hat{se}}\vert\ge\vert\dfrac{25-26}{0.905}\vert\Big)\approx P(\vert Z\vert\ge 1.1)\approx 0.2714.</script><p>  认为哪种油行驶里程更长的理由均不充分.</p></li></ul><h2 id="两相关总体比较"><a href="#两相关总体比较" class="headerlink" title="两相关总体比较"></a>两相关总体比较</h2><ul><li><p><strong>例(行驶里程-改进)</strong>  同一辆车不同日子加不同油, 记录行驶里程.</p><p>  | 车号     | 油 A     | 油 B     | 差异 ($d_i$) |<br>  | ———— | ———— | ———— | —————— |<br>  | 1        | 27.01    | 26.95    | 0.06         |<br>  | 2        | 20.00    | 20.44    | -0.44        |<br>  | $\cdots$ | $\cdots$ | $\cdots$ | $\cdots$     |<br>  | 10       | 25.22    | 26.01    | -0.79        |<br>  | 均值     | 25.20    | 25.80    | -0.60        |<br>  | 标准差   | 4.27     | 4.10     | 0.61         |</p><p>  提出假设 $H_0:\mu_d=0$ v.s. $H_1:\mu_d\ne 0$, 检验统计量为 $\overline{d}$.</p><p>  假设 $d_i$ 服从正态分布. 在 $H_0$ 为真前提下, 有</p><script type="math/tex; mode=display">  \dfrac{\overline{d}}{\tfrac{S_d}{\sqrt{n}}}\sim t(n-1).</script><p>  得 <strong>P</strong> 值</p><script type="math/tex; mode=display">  P\Big(\vert t(9)\vert\ge\vert\dfrac{-0.60}{\tfrac{0.61}{\sqrt{10}}}\vert\Big)\approx 0.012.</script><p>  有理由拒绝 $H_0$, 两种油的行驶里程有差距.</p></li><li><p><strong>注</strong>  假设检验不能检验试验设计, 仅对数据负责; 功能有限, 作为决策辅助.</p></li></ul><h2 id="Bayes-假设检验"><a href="#Bayes-假设检验" class="headerlink" title="Bayes 假设检验"></a>Bayes 假设检验</h2><ul><li><p><strong>例</strong>  两种硬币 ($p=0.5$, $p=0.7$) 投掷 $n=10$ 次, 正面向上 $X=x$ 次. 提出假设 $H_0:p=0.5$ v.s. $p=0.7$​. 考虑</p><script type="math/tex; mode=display">  \dfrac{P(H_0\mid x)}{P(H_1\mid x)}=\dfrac{P(H_0)P(x\mid H_0)}{P(H_1)P(x\mid H_1)}<1</script><p>  则拒绝 $H_0$.</p></li><li><p><strong>注</strong>  给出一个特别的例子, $H_0:\theta=\theta_0$, $\Theta$ 连续. 则 $P(H_0\mid x)=0$, 此时似乎总是会拒绝 $H_0$? (陈书 <strong>Chap 5.28</strong>)</p></li></ul><h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><h3 id="决策"><a href="#决策" class="headerlink" title="决策"></a>决策</h3><ul><li>拒绝 $H_0$ 或不拒绝 $H_0$.</li><li>检验=决策准则 $\Leftrightarrow$ 拒绝域 $R$ 的划分.</li><li>关键:<ul><li>选择合适的检验统计量.</li><li>确定拒绝域的形状 (由 $H_1$ 决定).</li></ul></li><li>拒绝 $H_0$ 有时也称观测值是显著的.</li></ul><h3 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h3><ul><li><p>统计学中没有绝对的证实或证伪.</p><script type="math/tex; mode=display">  \alpha(R):=P_{\theta}((X_1,\cdots,X_n)\in R\mid H_0).\\  \beta(R):=P_{\theta}((X_1,\cdots,X_n)\in R^c\mid H_1).</script></li><li><p>检验程序的属性, 不是样本的属性. 样本做决策要么正确要么错误.</p><script type="math/tex; mode=display">  \alpha(R)\le\alpha.\\  \beta(R)\le\beta.</script><p>  预先指定的可接受的长期错误率.</p></li></ul><h3 id="显著性检验-v-s-Neyman-Pearson-检验"><a href="#显著性检验-v-s-Neyman-Pearson-检验" class="headerlink" title="显著性检验 v.s. Neyman-Pearson 检验"></a>显著性检验 v.s. Neyman-Pearson 检验</h3><ul><li><p>显著性检验: 只控制 $\alpha(R)\le\alpha$.</p></li><li><p><strong>Neyman-Pearson</strong> 假设检验: 强调两类错误、功效, $H_0,H_1$ 地位不均等.</p></li><li><p>不拒绝 $H_0$ $\ne$ 接受 $H_0$.</p></li><li><p>$\beta(R)$ 越小 (功效越大), 当 $H_0$ 不真时, 越有可能拒绝 $H_0$; 当观测支持 $H_0$, 则可以接受 $H_0$.</p></li><li><p>若忽略了对 $\beta(R)$ 的系统控制 (常见情形), 将导致对结果及下一步工作方向的误判.</p></li><li><p><strong>例</strong>  $H_0:\mu\ge 5$, $H_1:\mu&lt;5$. $n=10$, $\sigma=0.01$, $\alpha=0.01$.</p></li><li><p><strong>解答</strong>  临界值</p><script type="math/tex; mode=display">  c=\mu_0-Z_{\alpha}\dfrac{\sigma}{\sqrt{n}}\approx 4.993.</script></li></ul><h3 id="P-值"><a href="#P-值" class="headerlink" title="P 值"></a>P 值</h3><ul><li>一次具体的观测值没有概率可言, <strong>P</strong> 不能衡量决策错误的概率. (<strong>ASA</strong> 文章)</li></ul><h3 id="卡方检验-——-多项分布的检验"><a href="#卡方检验-——-多项分布的检验" class="headerlink" title="卡方检验 —— 多项分布的检验"></a>卡方检验 —— 多项分布的检验</h3><ul><li><strong>例</strong>  $H_0: p_1=p$, $p_2=1-p$. 此时<script type="math/tex; mode=display">  \begin{aligned}  \chi^2&=\dfrac{(O_1-np_1)^2}{np_1}+\dfrac{(O_2-np_2)^2}{np_2}\\  &=\dfrac{(O_1-np)^2}{np}+\dfrac{(O_1-np)^2}{n(1-p)}\\  &=\dfrac{(O_1-np)^2}{np(1-p)}\\  &\stackrel{近似}{\sim} N^2(0,1)=\chi^2(1).  \end{aligned}</script></li></ul><h3 id="统计显著-ne-实际显著"><a href="#统计显著-ne-实际显著" class="headerlink" title="统计显著 $\ne$ 实际显著"></a>统计显著 $\ne$ 实际显著</h3><ul><li><p><strong>例</strong>  投掷骰子 $n=6\times 10^{10}$ 次​.</p><p>  | 点数               | 1         | 2                  | 3                 | 4                | 5                 | 6                  | 总计              |<br>  | ————————— | ————- | ————————— | ————————- | ———————— | ————————- | ————————— | ————————- |<br>  | 观测频数 $10^{10}$ | $-10^{6}$ | $1.5\times 10^{6}$ | $-2\times 10^{6}$ | $4\times 10^{6}$ | $-3\times 10^{6}$ | $0.5\times 10^{6}$ | $6\times 10^{10}$ |</p><p>  $H_0:$ 分布均匀, $H_1:$ 分布不均匀. </p></li><li><p>计算得到 $\chi^2=3250$, 此时 <strong>P</strong> 值 $\ll 0.0001$. 因此拒绝 $H_0$, 统计显著. </p></li><li><p>实际上 $\vert\hat p_i-\dfrac{1}{6}\vert\sim 10^{-4}$, 实际角度视为无差异, 实际不显著.</p></li><li><p>$n$ 过大, 明察秋毫; $\chi^2$ 统计量关于 $n$ 是非齐次的.</p></li></ul>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;Chap-7-假设检验&quot;&gt;&lt;a href=&quot;#Chap-7-假设检验&quot; class=&quot;headerlink&quot; title=&quot;Chap 7 假设检验&quot;&gt;&lt;/a&gt;Chap 7 假设检验&lt;/h1&gt;&lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot;</summary>
        
      
    
    
    
    <category term="Math" scheme="http://chengsx21.github.io/categories/Math/"/>
    
    <category term="Probability Theory" scheme="http://chengsx21.github.io/categories/Math/Probability-Theory/"/>
    
    
    <category term="Probability Theory" scheme="http://chengsx21.github.io/tags/Probability-Theory/"/>
    
  </entry>
  
  <entry>
    <title>人工智能导论 笔记3</title>
    <link href="http://chengsx21.github.io/2023/05/12/ren-gong-zhi-neng-dao-lun-bi-ji-3/"/>
    <id>http://chengsx21.github.io/2023/05/12/ren-gong-zhi-neng-dao-lun-bi-ji-3/</id>
    <published>2023-05-12T01:52:54.000Z</published>
    <updated>2023-09-22T08:15:43.954Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第三章-对抗搜索"><a href="#第三章-对抗搜索" class="headerlink" title="第三章 对抗搜索"></a>第三章 对抗搜索</h1><h2 id="博弈问题"><a href="#博弈问题" class="headerlink" title="博弈问题"></a>博弈问题</h2><ul><li>一人一步、信息完备、零和博弈.</li><li>通常<strong>不具有穷举性</strong> (棋类问题).</li></ul><h2 id="极小-极大模型"><a href="#极小-极大模型" class="headerlink" title="极小-极大模型"></a>极小-极大模型</h2><ul><li><p>目标: <strong>对方不犯错</strong>的情况下<strong>结局对自己有利</strong> (有利节点的数值&gt;0).</p></li><li><p>圆形为<strong>极小节点</strong>, 正方形为<strong>极大节点</strong>, 自己应该始终沿着极大值行进.</p>  <div align="center"><img src="/pic/113.png" width="100%" height="100%"></div></li><li><p>模仿人类下棋思考过程, 但<strong>有限深度内的穷举</strong>不可行.</p></li><li><p>为解决模型存在的问题, 只在<strong>少数可能的走步范围内</strong>考虑.</p></li></ul><h2 id="alpha-beta-减枝算法"><a href="#alpha-beta-减枝算法" class="headerlink" title="$\alpha$-$\beta$ 减枝算法"></a>$\alpha$-$\beta$ 减枝算法</h2><ul><li><p>极大节点的下界为 $\alpha$, 极小节点的上界为 $\beta$, 使用 <strong>DFS</strong> 生成节点.</p></li><li><p>剪枝条件:</p><ul><li><strong>后辈节点的 $\beta$ 值 ≤ 祖先节点的 $\alpha$ 值时, $\alpha$ 剪枝.</strong></li><li><strong>后辈节点的 $\alpha$ 值 ≥ 祖先节点的 $\beta$ 值时, $\beta$ 剪枝.</strong></li></ul></li><li><p>简记:</p><ul><li><strong>极小 ≤ 极大, 剪枝.</strong></li><li><p><strong>极大 ≥ 极小, 剪枝.</strong></p><div align="center"><img src="/pic/114.png" width="100%" height="100%"></div><div align="center"><img src="/pic/115.png" width="100%" height="100%"></div></li></ul></li><li><p>注意:</p><ul><li>估值需要总结专家知识.</li><li><strong>比较</strong>大小需要<strong>所有祖先节点</strong>进行比较.</li><li>先决定是否<strong>剪枝</strong>, 再决定是否<strong>上传</strong>.</li><li>$\alpha$-$\beta$ 减枝仅能<strong>决定接下来一步的最优选择</strong>.</li><li>对局面评估的准确性要求高.</li></ul></li></ul><h2 id="Monte-Carlo-方法"><a href="#Monte-Carlo-方法" class="headerlink" title="Monte Carlo 方法"></a>Monte Carlo 方法</h2><ul><li><p>从所有可落子点<strong>随机选择</strong>, 重复直到胜负可判断, <strong>多次模拟</strong>选择<strong>胜率最大</strong>的点.</p></li><li><p><strong>(MCTS)</strong> <strong>蒙特卡洛树搜索</strong>:</p><ul><li><p>将可能出现的状态转移过程用<strong>状态树</strong>表示.</p></li><li><p>从初始状态开始重复抽样, 逐步扩展.</p></li><li><p>树中的节点<strong>父节点可以利用子节点的模拟结果</strong>，提高了效率.</p></li><li><p>在搜索过程中可以<strong>随时得到行为的评价</strong>.</p></li><li><p>选择策略:</p><ul><li>对具有较大希望节点的<strong>利用</strong>.</li><li><p>对尚未充分了解节点的<strong>探索</strong>.</p><div align="center"><img src="/pic/116.png" width="100%" height="100%"></div></li></ul></li></ul></li><li><p><strong>(UCB)</strong> <strong>信心上限算法</strong>:</p>  <pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> UCB1<span class="token punctuation">:</span><span class="token keyword">for</span> each j <span class="token keyword">in</span> 拉杆<span class="token punctuation">:</span>访问 j 并记录收益<span class="token keyword">while</span> 尚未达到访问次数限制<span class="token punctuation">:</span>计算每个拉杆的 UCB1 信心上界 Ij访问信心上界最大的拉杆<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script type="math/tex; mode=display">  I_j=\overline{X}_j+c\sqrt{\dfrac{2\ln n}{T_j(n)}}.</script><ul><li><p>$\overline{X}_j$ 是拉杆 $j$ 所获得<strong>回报的均值</strong>.</p></li><li><p>$n$ 是到当前这一时刻为止所访问的总次数.</p></li><li><p>$T_j(n)$ 是拉杆 $j$ 到目前为止所<strong>访问的次数</strong>.</p></li><li><p>上式考虑了 <strong>“利用” 和 “探索” 间的平衡</strong>.</p></li></ul></li><li><p><strong>(UCT)</strong> <strong>信心上限树算法</strong>:</p>  <pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">UctSearch</span><span class="token punctuation">(</span>s0<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token triple-quoted-string string">'''  TREEPOLICY:  节点还可扩展--扩展并模拟节点不可扩展--从子节点选择一个并循环  '''</span>以状态s0创建根节点v0<span class="token punctuation">;</span>    <span class="token keyword">while</span> 尚未用完计算时长<span class="token punctuation">:</span>      vl <span class="token operator">=</span> TreePolicy<span class="token punctuation">(</span>v0<span class="token punctuation">)</span><span class="token punctuation">;</span>      △ <span class="token operator">=</span> DefaultPolicy<span class="token punctuation">(</span>s<span class="token punctuation">(</span>vl<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      Backup<span class="token punctuation">(</span>vl，△<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> a<span class="token punctuation">(</span>BestChild<span class="token punctuation">(</span>v0，<span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>每个节点记录: <strong>获胜</strong>次数 / <strong>模拟</strong>总次数.</p></li><li><p><strong>获胜次数相对于本节点角度</strong>, <strong>方便进行选择.</strong></p></li><li><p>假设 $c=0$, 此时 $I_j=\overline{X}_j$.</p>  <div align="center"><img src="/pic/117.png" width="100%" height="100%"></div></li></ul></li></ul><h2 id="AlphaGo-原理"><a href="#AlphaGo-原理" class="headerlink" title="AlphaGo 原理"></a>AlphaGo 原理</h2><ul><li><p><strong>MCTS</strong> 存在的问题:</p><ul><li>生成<strong>所有子节点</strong>.</li><li>模拟具有<strong>盲目性</strong>.</li></ul></li><li><p><strong>AlphaGo</strong> 中神经网络与 <strong>MCTS</strong> 结合:</p><ul><li>缩小了搜索<strong>范围</strong>.</li><li><p>提高了模拟<strong>水平</strong>.</p><div align="center"><img src="/pic/118.png" width="100%" height="100%"></div></li><li><p><strong>策略网络</strong>:</p><ul><li><p>输入: 当前棋局 —— <strong>48</strong> 个通道, 每个通道大小为 <strong>19*19</strong>.</p></li><li><p>输出: 棋盘上每个点的<strong>行棋概率</strong> —— 概率越大, 行棋点越好.</p></li><li><p>训练数据: <strong>16</strong> 万盘人类棋手的数据.</p></li><li><p><strong>分类问题</strong>: 任意一个棋局分类为 <strong>361</strong> 类之一, 行棋点为标记.</p></li><li><p><strong>损失函数</strong>:</p><script type="math/tex; mode=display">  L(w)=-t_a\log p_a.</script><p>  其中 $t_a$ 为当前棋局下棋手落子在 $a$ 处时为 1, 否则为 0; $p_a$ 为策略网络在 $a$ 处落子的概率.</p>  <div align="center"><img src="/pic/119.png" width="100%" height="100%"></div></li></ul></li><li><p>估值网络: 由一个神经网络构成.</p><ul><li><p>输入: 当前棋局 —— <strong>49</strong> 个通道, 每个通道大小为 <strong>19*19</strong>.</p></li><li><p>输出: 当前棋局的<strong>收益</strong> —— 收益的取值范围为 $[-1, 1]$.</p></li><li><p>训练数据: <strong>16</strong> 万盘人类棋手的数据.</p></li><li><p><strong>回归问题</strong>: 获胜时收益为 $1$, 失败时收益为 $-1$.</p></li><li><p><strong>损失函数</strong>:</p><script type="math/tex; mode=display">  L(w)=(R-V(s))^2.</script><p>  其中 $R$ 为棋局的胜负, 胜为 1, 负为 -1; $V(s)$ 为估值网络的输出, 即预测的收益.</p>  <div align="center"><img src="/pic/120.png" width="100%" height="100%"></div></li></ul></li><li><p><strong>MCTS</strong> 中的选择原则:</p><ul><li><strong>利用</strong>: 收益好的节点.</li><li><p><strong>探索</strong>: 模拟次数少的节点.</p></li><li><p><strong>经验</strong>: <strong>落子概率高</strong>的节点 (<strong>AlphaGo</strong> 增加的第三个原则).</p></li></ul></li><li><p>节点 $s$ 第 $i$ 次<strong>模拟的收益</strong>:</p><script type="math/tex; mode=display">  v_i(s)=\lambda value(s)+(1-\lambda)rollout(s).</script><p>  其中 $value(s)$ 是估值网络的输出, $rollout(s)$ 是一次模拟结果.</p></li><li><p><strong>平均收益</strong>:</p><script type="math/tex; mode=display">  Q(s_a)=\dfrac{1}{n}\sum\limits_{i=1}^{n}v_i(s_a).</script><p>  其中 $s(a)$ 为 $s$ 棋局下在 $a$ 处落子后的棋局.</p></li><li><p><strong>探索项</strong>:</p><script type="math/tex; mode=display">   u(s_a)=c\cdot p(s_a)\dfrac{\sqrt{N(s)}}{N(s_a+1)}.</script><p>  其中 $N(\cdot)$ 为模拟次数, $p(s_a)$ 为策略网络在 $a$ 处下棋概率, $c$ 为加权系数.</p></li></ul></li><li><p><strong>AlphaGo</strong> 中的 <strong>MCTS</strong> 过程:</p>  <div align="center"><img src="/pic/121.png" width="100%" height="100%"></div><ul><li>用 $Q(s_a)+u(s_a)$ 代替信心上限 $I_j$, 优先选择 $Q(s_a)+u(s_a)$ 大的子节点.</li><li>遇到叶节点 $s_l$ 结束, 该节点被选中.</li><li>生成 $s_l$ 的<strong>所有子节点</strong>, 但是<strong>不进行模拟</strong>.</li><li><p>规定了<strong>最大节点深度</strong>.</p><div align="center"><img src="/pic/122.png" width="100%" height="100%"></div></li><li><p>对 $s_l$ 进行模拟, 计算:</p><script type="math/tex; mode=display">  v_i(s)=\lambda value(s)+(1-\lambda)rollout(s).</script></li><li><p><strong>模拟</strong>过程采用<strong>推演策略网络</strong>, 其速度快, 是策略网络的 $1000$ 倍.</p></li><li><p>规定了<strong>总模拟次数</strong>.</p></li></ul></li></ul><h2 id="围棋中的深度强化学习方法"><a href="#围棋中的深度强化学习方法" class="headerlink" title="围棋中的深度强化学习方法"></a>围棋中的深度强化学习方法</h2><ul><li><p>强化学习:</p><ul><li>学习 “做什么才能使得<strong>收益最大化</strong>” 的方法.</li><li>学习者不会被告知如何做, 必须自己通过尝试发现哪些动作会产生最大的收益.</li><li><strong>监督学习</strong>使用<strong>策略网络</strong>、<strong>无需尝试</strong>.</li><li>两个特征: <strong>试错</strong>和<strong>延迟收益</strong>.</li></ul></li><li><p>深度强化学习:</p><ul><li>用<strong>深度学习 (神经网络) 方法</strong>实现的强化学习.</li></ul></li><li><p>关键问题: 如何获得<strong>指示信号</strong>?</p><ul><li>监督学习: <strong>情景与标注一一对应</strong>.</li><li>强化学习:<ul><li><strong>将收益转化为 “标注”</strong>.</li><li>不能获得所有情况下既正确又有代表性的示例.</li></ul></li></ul></li><li><p>手段:</p><ul><li>将<strong>深度强化学习问题</strong>转化为<strong>神经网络训练问题</strong>.</li><li>不同的转换方法构成了不同的深度强化学习方法.</li><li>关键是<strong>损失函数的定义</strong>.</li></ul></li><li><p>围棋中深度强化学习的三种实现方法:</p><ul><li><p>基于<strong>策略梯度</strong>的强化学习:</p><ul><li><p>数据: $(s,a,p_a,t_a)$ (棋局、行棋、获胜概率、延迟胜负值).</p><p>  $t_a$ 为胜负值, 胜为 1, 负为 -1.</p></li><li><p>损失函数: $L(w)=-t_a\log⁡(p_a)$.</p><ul><li>假设获胜者的行为都是正确的, 负者行为都是不正确的.</li><li>假设获负时对权重的修改量大小与获胜时一样, 方向相反.</li></ul><div align="center"><img src="/pic/123.png" width="100%" height="100%"></div></li><li><p><strong>AlphaGo</strong>: <strong>先监督学习, 再强化学习.</strong></p></li><li>注意点:<ul><li>强化学习过程中, 每个<strong>样本只使用一次</strong>;</li><li>基于策略梯度的<strong>强化学习</strong>学到了在每个可落子点行棋的<strong>获胜概率</strong>; <strong>监督学习</strong>学到了在某个可落子点的<strong>行棋概率</strong>.</li></ul></li></ul></li><li><p>基于<strong>价值评估</strong>的强化学习:</p><ul><li><p>输入: 当前棋局和行棋点.</p></li><li><p>输出: 取值在 -1、1 之间的估值.</p></li><li><p>数据: $(s,a,V(s,a),R)$ (棋局、行棋、网络输出、延迟胜负值).</p><p>  $R$ 为胜负值, 胜为 1, 负为 -1.</p></li><li><p>损失函数: $L(w)=(E-V(s,a))^2$.</p></li><li><p><strong>基于价值评估的强化学习</strong>学到了每个落子点<strong>获取最大收益的概率</strong>.</p><div align="center"><img src="/pic/124.png" width="100%" height="100%"></div></li></ul></li><li><p>基于<strong>演员-评价方法</strong>的强化学习:</p>  <div align="center"><img src="/pic/125.png" width="100%" height="100%"></div><ul><li><p>收益增量:</p><ul><li><p>评价一步棋的好坏</p><script type="math/tex; mode=display">  A=Q(s,a)-V(s).</script></li><li><p>$V(s)$ 为棋局 $s$ 的<strong>预期收益</strong>, 取值范围为 $[-1, 1]$.</p></li><li><p>$Q(s,a)$ 为在 $a$ 处<strong>行棋后的收益</strong>, 取值范围为 $[-1, 1]$.</p></li><li><p>$A$ 为<strong>收益增量</strong>, 取值范围为 $[-2, 2]$.</p></li><li><p>$A$ 越大越说明走了一步妙招, 越小越说明走了一步败招.</p></li></ul></li><li><p>收益增量的计算:</p><script type="math/tex; mode=display">  A=R-V(s).</script><p>  其中 $R$ 为胜负值, 胜为 $1$, 负为 $-1$.</p></li><li><p>损失函数:</p><ul><li>评价部分: $L_1(w)=(R-V(s))^2$.</li><li>演员部分: $L_2(w)=-\vert A\vert t_a\log(p_a)=-A\log(p_a)$.</li><li>综合损失函数: $L(w)=L_1(w)+\lambda L_2(w)$.</li></ul></li><li><p><strong>基于演员-评价方法的强化学习</strong>强调<strong>重要行棋点的学习</strong>, 学到了每个落子点获取<strong>最大收益增量的概率</strong>.</p><div align="center"><img src="/pic/126.png" width="100%" height="100%"></div></li></ul></li></ul></li></ul><h2 id="AlphaGo-Zero-原理"><a href="#AlphaGo-Zero-原理" class="headerlink" title="AlphaGo Zero 原理"></a>AlphaGo Zero 原理</h2><ul><li><p>从零学习:</p><ul><li>不再使用人类棋手的数据.</li><li>不再使用人工特征作为输入 (自动抽取).</li><li>利用<strong>强化学习从零学习</strong>.</li></ul></li><li><p><strong>AlphaGo Zero</strong> 的网络结构:</p><ul><li><p>将<strong>策略网络、估值网络</strong>合并为一个 <strong>“双输出” 网络</strong>.</p></li><li><p>输入: <strong>17</strong> 个通道, 每个通道大小为 <strong>19*19</strong>.</p></li><li><p>策略网络输出: <strong>19×19+1</strong>, <strong>多了一个 “放弃” 行为.</strong></p></li><li><p>估值网络输出: 当前棋局的<strong>估值</strong>, 取值范围为 $[-1, 1]$.</p><div align="center"><img src="/pic/127.png" width="100%" height="100%"></div></li></ul></li><li><p><strong>AlphaGo Zero</strong> 中的 <strong>MCTS</strong>:</p><ul><li><p>节点 $s$ 第 $i$ 次<strong>模拟的收益</strong> (<strong>AlphaGo</strong> $\Rightarrow$ <strong>AlphaGo Zero</strong>):</p><script type="math/tex; mode=display">  v_i(s)=\lambda value(s)+(1-\lambda)rollout(s)\Rightarrow v_i(s)=value(s).</script><p>  其中 $value(s)$ 是<strong>估值网络</strong>的输出.</p></li><li><p><strong>平均收益</strong>:</p><script type="math/tex; mode=display">  Q(s_a)=\dfrac{1}{n}\sum\limits_{i=1}^{n}v_i(s_a).</script><p>  其中 $s(a)$ 为 $s$ 棋局下在 $a$ 处落子后的棋局.</p></li><li><p><strong>探索项</strong>:</p><script type="math/tex; mode=display">   u(s_a)=c\cdot p(s_a)\dfrac{\sqrt{N(s)}}{N(s_a+1)}.</script><p>  其中 $N(\cdot)$ 为模拟次数, $p(s_a)$ 为<strong>策略网络</strong>在 $a$ 处下棋概率, $c$ 为加权系数.</p></li></ul></li><li><p><strong>AlphaGo Zero</strong> 中的 <strong>MCTS</strong> 过程:</p><ul><li><p><strong>选择</strong>:</p><ul><li><p>用 $Q(s_a)+u(s_a)$ 代替信心上限 $I_j$, 选择 $Q(s_a)+u(s_a)$ 大的子节点;</p></li><li><p>遇到叶节点 $s_l$ 结束, 该节点被选中.</p></li></ul></li><li><p><strong>生成</strong>:</p><ul><li><p>生成 $s_l$ 的所有子节点, 但是<strong>不进行模拟</strong>;</p></li><li><p>规定了<strong>最大节点深度</strong>.</p></li></ul></li><li><p><strong>模拟回传</strong>:</p><ul><li><p>用<strong>估值网络</strong>输出<strong>取代</strong>快速<strong>模拟</strong>过程, 对 $s_l$ 进行模拟, 计算:</p><script type="math/tex; mode=display">  v_i(s)=value(s).</script></li><li><p>规定了<strong>总模拟次数</strong>.</p></li></ul></li></ul></li><li><p><strong>损失函数</strong>:</p><ul><li><p><strong>估值网络</strong>部分:</p><script type="math/tex; mode=display">  L_1=(z-v)^2.</script><p>  其中 $v$ 是估值网络的输出, $z$ 是胜负值.</p></li><li><p><strong>策略网络</strong>部分:</p><script type="math/tex; mode=display">  L_2=-\sum_{i=1}^{362}\pi_i\log(p_i).</script><p>  其中 $\pi(i)$ 是 <strong>MCTS</strong> 输出的每个落子点的概率 (与每个点被选中次数有关), $p_i$ 是策略网络输出的每个落子点的概率.</p></li><li><p><strong>综合损失函数</strong>:</p><script type="math/tex; mode=display">  L=L_1+L_2+\Vert\theta\Vert_2^2.</script><p>  其中 $\Vert\theta\Vert_2^2$ <strong>防止出现过拟合</strong>.</p></li></ul></li><li><p>引入<strong>多样性</strong>: </p><ul><li><p>防止走向错误的方向, 对策略网络的输出人为引入噪声.</p></li><li><p><strong>狄利克雷分布</strong>:</p><ul><li>通过参数可以产生一些<strong>符合一定条件的概率分布</strong>.</li><li>控制参数 $n$ 概率分布向量的长度与 $\alpha$ 分布浓度.</li></ul></li><li><p>落子概率:</p><script type="math/tex; mode=display">  p=\lambda p_a+(1-\lambda)p_d.</script><p>  其中 $p_a$ 为<strong>策略网络输出</strong>, $p_d$ 为<strong>狄利克雷分布采样</strong>.</p></li><li><p>引入噪声不会引起 “不良反应”, <strong>MCTS</strong> 具有 <strong>“纠错” 能力</strong>.</p></li></ul></li></ul>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;第三章-对抗搜索&quot;&gt;&lt;a href=&quot;#第三章-对抗搜索&quot; class=&quot;headerlink&quot; title=&quot;第三章 对抗搜索&quot;&gt;&lt;/a&gt;第三章 对抗搜索&lt;/h1&gt;&lt;h2 id=&quot;博弈问题&quot;&gt;&lt;a href=&quot;#博弈问题&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    <category term="CS" scheme="http://chengsx21.github.io/categories/CS/"/>
    
    <category term="IAI" scheme="http://chengsx21.github.io/categories/CS/IAI/"/>
    
    
    <category term="IAI" scheme="http://chengsx21.github.io/tags/IAI/"/>
    
  </entry>
  
  <entry>
    <title>概率论与数理统计 笔记6</title>
    <link href="http://chengsx21.github.io/2023/05/07/gai-lu-lun-yu-shu-li-tong-ji-bi-ji-6/"/>
    <id>http://chengsx21.github.io/2023/05/07/gai-lu-lun-yu-shu-li-tong-ji-bi-ji-6/</id>
    <published>2023-05-07T09:27:40.000Z</published>
    <updated>2023-09-22T08:17:11.766Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Chap-6-参数估计"><a href="#Chap-6-参数估计" class="headerlink" title="Chap 6 参数估计"></a>Chap 6 参数估计</h1><ul><li><p><strong>引入</strong>  检测某厂一大批电子元件寿命指标是否合格.</p></li><li><p><strong>总体</strong></p><ul><li>所需检测的电子元件寿命;</li><li>统计分析问题中研究的对象全体的某个数字特征 $X$.</li><li>元件寿命的分布;</li><li>变量 $X$ 的分布.</li></ul></li><li><p><strong>统计总体</strong>  一个概率分布.</p></li><li><p><strong>注</strong></p><ul><li>有限总体;</li><li>无限总体.</li></ul></li><li><p><strong>统计模型</strong></p><ul><li>一族概率分布;</li><li>参数模型 (正态模型);</li><li>非参数模型.</li></ul></li><li><p><strong>样本</strong></p><ul><li>$(X_1,\cdots,X_n)$, 其中 $X_i$ 来自总体 $X$, $n$ 为样本容量;</li><li>获取方式:<ul><li>试验;</li><li>观察 (完全 / 不完全).</li></ul></li></ul></li><li><p><strong>简单随机抽样</strong></p><ul><li>总体个数 $N$ 有限;</li><li>无放回;</li><li>容量为 $n$ 的样本抽取出来的概率为 $p=\dfrac{1}{C_N^n}$.</li></ul></li><li><p><strong>随机样本</strong></p><ul><li>$X_1,\cdots,X_n$ 独立同分布, 例: 有放回 / 近似有放回 ($n&lt;&lt;N$).</li></ul></li><li><p><strong>统计量</strong></p><ul><li><p>$T(X_1,\cdots,X_n)$ - 完全由样本决定, 是一种数据简化方式.</p></li><li><p>样本均值</p><script type="math/tex; mode=display">  \overline{X}=\dfrac{1}{n}\sum_{i=1}^{n}X_i.</script></li><li><p>样本方差 </p><script type="math/tex; mode=display">  S^2=\dfrac{1}{n-1}\sum_{i=1}^{n}(X_i-\overline{X})^2.</script></li></ul></li><li><p><strong>统计推断</strong></p><ul><li>总体为因, 样本为果;</li><li>总体决定样本, 样本推断总体;</li><li>经典方法 (频率) v.s. <strong>Bayes</strong>方法.</li><li><strong>例</strong>  $Y_i=aX_i+\varepsilon_i$.<ul><li>求 $a$. $(X_i,Y_i)(1\le i\le n)\rightarrow a\approx\hat{a}$ (模型推断 参数估计)</li><li>已知 $a=\hat{a}$, 观测到 $Y_i$, 求 $X_i$ (变量推断)</li></ul></li><li><strong>例</strong>  元件寿命.<ul><li>假设 $X\sim Exp(\lambda)$, 求 $\lambda$ (参数估计)</li><li>假设合格标准 $E(X)\ge L$, 需建立可操作的检验标准: $X\ge l$, $\mu$ 未知, 求 $l$ (假设检验)</li></ul></li></ul></li></ul><h2 id="矩估计"><a href="#矩估计" class="headerlink" title="矩估计"></a>矩估计</h2><ul><li><p><strong>定义(样本矩)</strong>  $X_1,\cdots,X_n$ 独立同分布, 定义其 $k$ 阶<strong>原点矩</strong>:</p><script type="math/tex; mode=display">  a_k=\dfrac{1}{n}\sum_{i=1}^{n}X_i^k\stackrel{\textbf{LLN}}{\longrightarrow}E(X^k).</script><p>  其 $k$ 阶<strong>中心矩</strong>:</p><script type="math/tex; mode=display">  m_k=\dfrac{1}{n}\sum_{i=1}^{n}(X_i-\overline{X})^k\stackrel{\textbf{LLN}}{\longrightarrow}E\Big[(X-\mu)^k\Big].</script></li><li><p><strong>例</strong>  $X\sim N(\mu,\sigma^2)$. 考虑其均值、方差对应的样本矩.</p></li><li><p><strong>解答</strong></p><script type="math/tex; mode=display">  \mu=E(X)\approx\overline{X}=a_1;\\  \sigma^2=E\Big[(X-\mu)^2\Big]\approx\dfrac{1}{n}\sum_{i=1}^{n}(X_i-\overline{X})^2=m_2.</script></li><li><p><strong>例</strong>  $X\sim Exp(\lambda)$. 考虑其均值、方差对应的样本矩, 并给出 $\lambda$ 的矩估计.</p></li><li><p><strong>解答</strong></p><script type="math/tex; mode=display">  \dfrac{1}{\lambda}=E(X)\approx\overline{X}=a_1\Rightarrow\lambda=\dfrac{1}{a_1};\\  \dfrac{1}{\lambda^2}=E\Big[(X-E(X))^2\Big]\approx\dfrac{1}{n}\sum_{i=1}^{n}(X_i-\overline{X})^2=m_2\Rightarrow\lambda=\Big(\dfrac{1}{m_2}\Big)^{\tfrac{1}{2}}.</script><p>  我们通常使用<strong>低阶矩</strong>进行估计.</p></li></ul><h2 id="极大似然估计-MLE"><a href="#极大似然估计-MLE" class="headerlink" title="极大似然估计 (MLE)"></a>极大似然估计 (MLE)</h2><ul><li><p><strong>定义(似然函数)</strong>  假设 $X_1,\cdots,X_n$ 的联合分布 $f(x_1,\cdots,x_n;\theta)$ (<strong>PMF\\PDF</strong>), 其中 $\theta$ 为参数. 对于观测 $(X_1,\cdots,X_n)$ 的似然函数为</p><script type="math/tex; mode=display">  L(\theta):=f(X_1,\cdots,X_n;\theta).</script></li><li><p><strong>注</strong></p><ul><li><p>具体观测数据通常记为 $(x_1,\cdots,x_n)$, 视为 $(X_1,\cdots,X_n)$ 的具体的实现值;</p></li><li><p>离散情形下, $L(\theta)$ 为出现 $(X_1,\cdots,X_n)$ 的概率;</p></li><li><p>若 $X_1,\cdots,X_n$ 独立同分布, 总体分布为 $f_1(x;\theta)$ (<strong>PMF\\PDF</strong>), 那么</p><script type="math/tex; mode=display">  L(\theta)=f_1(X_1;\theta)f_1(X_2;\theta)\cdots f_1(X_n;\theta).</script></li></ul></li><li><p><strong>例</strong>  $X_i\sim N(\mu,\sigma^2)$ 独立同分布, 其中 $\mu$,$\sigma^2$ 未知. 考虑观测的似然函数.</p></li><li><p><strong>解答</strong></p><script type="math/tex; mode=display">  L(\mu,\sigma^2)=\prod_{i=1}^{n}\Big(\dfrac{1}{\sqrt{2\pi}\sigma}e^{-\tfrac{(X_i-\mu)^2}{2\sigma^2}}\Big).</script></li><li><p><strong>定义(MLE)</strong>  定义 $\theta$ 的 <strong>MLE</strong> 为</p><script type="math/tex; mode=display">  \theta^{*}=\arg\max_{\theta}L(\theta).</script><p>  其中 $\theta^{<em>}=\theta^{</em>}(X_1,\cdots,X_n)$.</p></li><li><p><strong>解答续</strong>  考虑方程组</p><script type="math/tex; mode=display">  \begin{cases}  \dfrac{\partial\log L(\mu,\sigma^2)}{\partial\mu}=0;\\  \dfrac{\partial\log L(\mu,\sigma^2)}{\partial\sigma^2}=0.  \end{cases}</script><p>  解得</p><script type="math/tex; mode=display">  \begin{cases}  \mu^{*}=\overline{X},\\  (\sigma^2)^{*}=\sum\limits_{i=1}^{n}(X_i-\overline{X})^2.  \end{cases}</script><p>  经验证 $(\mu^{<em>},(\sigma^2)^{</em>})$ 为 $(\mu,\sigma^2)$ 的 <strong>MLE</strong>.</p></li><li><p><strong>注</strong>  $(\sigma^2)^{<em>}=(\sigma^{</em>})^2$ (<strong>MLE</strong> 的不变性).</p></li><li><p><strong>例</strong>  随机变量 $X_i\sim U(0,\theta)$ 独立同分布, $\theta$ 未知. 求 $\theta$ 的 <strong>MLE</strong>.</p></li><li><p><strong>解答</strong></p><script type="math/tex; mode=display">  L(\theta)=  \begin{cases}  \cfrac{1}{\theta^n}, &X_i\in(0,\theta), \theta\ge\max\{X_1,\cdots,X_n\}\\  0, &其他.  \end{cases}</script><p>  我们得到</p><script type="math/tex; mode=display">  \theta^{*}=\max\{X_1,\cdots,X_n\}.</script></li><li><p><strong>例</strong>  总体 <strong>PDF</strong> 为 $f(x;\theta)=\dfrac{1}{\pi(1+(x-\theta)^2)}$, $x\in\mathbb{R}$ (<strong>Cauchy</strong> 分布).</p></li><li><p><strong>解答</strong></p><ul><li>无矩 $\Rightarrow$ 无矩估计;</li><li>似然方程 $\sum\limits_{i=1}^{n}\dfrac{X_i-\theta}{1+(X_i-\theta)^2}=0$, 不易求解;</li><li>合理估计, $\hat{\theta}$ 为样本中位数.</li></ul></li></ul><h2 id="优良性准则"><a href="#优良性准则" class="headerlink" title="优良性准则"></a>优良性准则</h2><ul><li><p><strong>定义(无偏性)</strong>  定义 $\hat{\theta}=\hat{\theta}(X_1,\cdots,X_n)$ 为 $\theta$ 的估计量 (随机变量). 我们称一个估计 $\hat\theta$ 的偏差 (<strong>Bias</strong>):</p><script type="math/tex; mode=display">E_{\theta}(\hat\theta-\theta)=E_{\theta}(\hat\theta)-\theta.</script><p>若 $E_{\theta}(\hat\theta-\theta)=0$, $\forall\,\theta$, 则称 $\hat\theta$ 为 $\theta$ 的一个无偏估计量.</p></li><li><p><strong>注</strong></p><ul><li>一般地, $E_{\theta}(\hat g(X_1,\cdots,X_n)-g(\theta))=0$, $\forall\,\theta\,\Leftrightarrow$ $\hat{g}$ 为 $g(\theta)$ 的无偏估计;</li><li>无偏 $\Leftrightarrow$ 无系统偏差;</li><li>$\dfrac{1}{N}\sum\limits_{m=1}^{N}\hat{\theta}(X_1^{(m)},\cdots,X_n^{(m)})\stackrel{a.s.}{\longrightarrow}E(\hat\theta)\stackrel{无偏}{=}\theta$;</li><li>无偏性的重要性视情形而定.</li></ul></li><li><p><strong>例</strong>  $E(X)=\mu$, $Var(X)=\sigma^2$.</p></li><li><p><strong>解答</strong></p><ul><li>$E(\overline{X})=\mu\Rightarrow \overline{X}$ 为 $\mu$ 的无偏估计;</li><li>$E(m_2)=E\Big(\dfrac{1}{n}\sum\limits_{i=1}^{n}(X_i-\overline{X})^2\Big)=\dfrac{n-1}{n}\sigma^2$;</li><li>$E(S^2)=E\Big(\dfrac{1}{n-1}\sum\limits_{i=1}^{n}(X_i-\overline{X})^2\Big)=\sigma^2$.</li></ul></li><li><p><strong>例</strong>  $X_i\stackrel{iid}{\sim}U(0,\theta)$.</p></li><li><p><strong>解答</strong></p><ul><li>矩估计 $\hat\theta=2\overline{X}$;</li><li><strong>MLE</strong> $\theta^{*}=\max\{X_1,\cdots, X_n\}$;</li><li>计算可得 $E(\hat\theta)=\theta,\,E(\theta^{*})=\dfrac{n}{n+1}\theta$.</li></ul></li><li><p><strong>注</strong>  <strong>MLE</strong> 可也能是有偏的 (本例中即为系统偏小).</p></li><li><p><strong>定义(均方误差准则)</strong>  定义一个估计 $\hat\theta$ 的均方误差 (<strong>MSE</strong>):</p><script type="math/tex; mode=display">  E_{\theta}\Big[(\hat\theta-\theta)^2\Big]=Var(\hat\theta)+E_{\theta}^2(\hat\theta-\theta).</script><p>  其中 $Var(\hat\theta)$ 代表着精确度, $E_{\theta}^2(\hat\theta-\theta)$ 代表着准确度.</p></li><li><p><strong>定义</strong>  假定 $\hat\theta_1$, $\hat\theta_2$ 均为 $\theta$ 的无偏估计, 若</p><script type="math/tex; mode=display">  \forall\,\theta,\,Var(\hat\theta_1)\le Var(\hat\theta_2)</script><p>  且</p><script type="math/tex; mode=display">  \exists\,\theta_0,\,Var_{\theta_0}(\hat\theta_2)<Var_{\theta_0}(\hat\theta_1).</script><p>  则称在均方误差意义下 $\hat\theta_1$ 优于 $\hat\theta_2$.</p></li><li><p><strong>例</strong>  $E(X)=\mu$.</p></li><li><p><strong>解答</strong>  </p><script type="math/tex; mode=display">  E(\overline{X})=E(X_1)=E\Big(\dfrac{1}{2}X_1+\dfrac{1}{2}X_2\Big)=\mu.</script><script type="math/tex; mode=display">  Var(\overline{X})=\dfrac{1}{n}\sigma^2,\,Var(X_1)=\sigma^2,\,Var\Big(\dfrac{1}{2}X_1+\dfrac{1}{2}X_2\Big)=\dfrac{1}{2}\sigma^2.</script></li><li><p><strong>注</strong>  有时也可称为“有效性准则”.</p></li><li><p><strong>定义</strong>  假定 $\hat\theta_0$ 为 $\theta$ 的无偏估计, 若对任意 $\theta$ 与 $\theta$ 的无偏估计 $\hat\theta$</p><script type="math/tex; mode=display">  Var(\hat\theta_0)\le Var(\hat\theta)</script><p>  则称 $\hat\theta_0$ 为最小方差无偏估计 (<strong>MVUE</strong>).</p></li><li><p><strong>例</strong>  $X\sim N(\mu,\sigma^2)$.</p></li><li><p><strong>解答</strong>  由于</p><script type="math/tex; mode=display">E(m_2)=\dfrac{n-1}{n}\sigma^2,\,E(S^2)=\sigma^2.</script><p>因此计算可得</p><script type="math/tex; mode=display">E\Big[(m_2-\sigma^2)^2\Big]=\cdots<E\Big[(S^2-\sigma^2)^2\Big]=\cdots</script><p>这是用低偏差换了方差.</p></li><li><p><strong>定义</strong></p><ul><li>$\hat\theta=\hat\theta(X_1,\cdots,X_n)$ 的分布称为抽样分布;</li><li>$\hat\theta=\hat\theta(X_1,\cdots,X_n)$ 的标准差称为标准误差, 记为 $se(\hat\theta)$.</li></ul></li><li><p><strong>定义(大样本性质)</strong>  估计量 $\hat\theta$ 当 $n\rightarrow\theta$ 时的性质.</p></li><li><p><strong>定义(渐进无偏性)</strong>  有 $\lim\limits_{n\rightarrow\infty} E(\hat\theta-\theta)=0$;</p></li><li><p><strong>定义(相合性)</strong>  若 $\forall\,\varepsilon&gt;0$, 有 $\lim\limits_{n\rightarrow\infty}P(\left|\hat\theta-\theta\right|\ge\varepsilon)=0$, 则称 $\hat\theta$ 为 $\theta$ 的一个相合估计, 即 $\hat\theta\stackrel{P}{\longrightarrow}\theta$.</p><ul><li><strong>WLLN</strong> $\Rightarrow$ $\overline{X}$ 是 $\mu$ 的一个相合估计;</li><li>相合性是良好点估计的自然要求.</li></ul></li><li><p><strong>例</strong>  我们得到</p><script type="math/tex; mode=display">  \begin{aligned}  m_2&=\dfrac{1}{n}\sum\limits_{i=1}^{n}(X_i-\overline{X})^2\\  &=\dfrac{1}{n}\sum\limits_{i=1}^{n}(X_i-\mu-\overline{X}+\mu)^2\\  &=\dfrac{1}{n}\sum\limits_{i=1}^{n}(X_i-\mu)^2-(\overline{X}-\mu)^2\\  &\stackrel{P}{\rightarrow}E\Big[(X-\mu)^2\Big]\\  &=\sigma^2.  \end{aligned}</script><p>  进而有</p><script type="math/tex; mode=display">  S^2=\dfrac{n}{n-1}m_2\stackrel{P}{\rightarrow}\sigma^2.</script></li><li><p><strong>定义(渐进正态性)</strong>  $\dfrac{\hat\theta-\theta}{se(\hat\theta)}\stackrel{d}{\rightarrow}Z\sim(0,1)$ (渐进正态估计).</p><ul><li><p>$\hat\theta\stackrel{近似}{\sim}N(0,se^2(\hat\theta))$;</p></li><li><p><strong>CLT</strong> $\Rightarrow\overline{X}$ 为 $\mu$ 的一个渐进正态估计, $se(\overline{X})=\dfrac{\sigma}{\sqrt{n}}$.</p></li></ul></li></ul><h2 id="置信区间-Condifence-Interval"><a href="#置信区间-Condifence-Interval" class="headerlink" title="置信区间 (Condifence Interval)"></a>置信区间 (Condifence Interval)</h2><ul><li><p><strong>定义(置信区间)</strong>  $\forall\,\alpha\in(0,1)$, $\forall\,\theta$, 有 $\hat\theta_i=\hat\theta_i(X_1,\cdots,X_n)$, 其中 $i=1,2$, 使得</p><script type="math/tex; mode=display">  P(\hat\theta_1<\theta<\hat\theta_2)\ge 1-\alpha.</script><p>  则称 $(\hat\theta_1,\hat\theta_2)$ 为 $\theta$ 的 $(1-\alpha)$ 置信的区间估计 (双侧).</p></li><li><p><strong>注</strong></p><ul><li>$\alpha$ 通常取为 $0.05$, $0.01$, $0.1$;</li><li>置信 (水平、系数、度) 是针对方法的;</li><li>可靠性优先原则 (先保证 $P(\hat\theta_1&lt;\theta&lt;\hat\theta_2)\ge 1-\alpha$), 再尽量提升精度 (通常用 $E(\hat\theta_2-\hat\theta_1)$ 刻画).</li></ul></li><li><p><strong>例</strong>  $X\sim N(\mu,\sigma^2)$, <strong>已知</strong> $\sigma^2$, 给出 $\mu$ 的 $(1-\alpha)$ 置信区间估计.</p></li><li><p><strong>解答</strong>  注意到</p><script type="math/tex; mode=display">  \begin{aligned}  &\overline{X}-\mu\sim N(0,\dfrac{\sigma^2}{n})\\  \Longleftrightarrow&\dfrac{\overline{X}-\mu}{\frac{\sigma}{\sqrt{n}}}\sim N(0,1)\\  \Longrightarrow&P\Big(\left|\dfrac{\overline{X}-\mu}{\frac{\sigma}{\sqrt{n}}}\right|<Z_{\tfrac{\alpha}{2}}\Big)=1-\alpha.  \end{aligned}</script><p>  其中 $Z_{\tfrac{\alpha}{2}}$ 为 $N(0,1)$ 的上侧 $\dfrac{\alpha}{2}$ 分位数. 因此所求 $(1-\alpha)$ 置信的区间估计为</p><script type="math/tex; mode=display">  (\overline{X}-\frac{\sigma}{\sqrt{n}}Z_{\tfrac{\alpha}{2}},\overline{X}+\frac{\sigma}{\sqrt{n}}Z_{\tfrac{\alpha}{2}}).</script></li><li><p><strong>注</strong></p><ul><li>若 $\alpha=0.05$, 则 $Z_{\tfrac{\alpha}{2}}=Z_{0.025}\approx 1.96\approx 2$;</li><li>若用 $\overline{X}$ 估计 $\mu$, 则有 $(1-\alpha)$ 置信, 误差绝对值 $\vert\overline{X}-\mu\vert\le\frac{\sigma}{\sqrt{n}}Z_{\tfrac{\alpha}{2}}$;</li><li>给定 $\varepsilon&gt;0$, 则 $n\ge\Big(\dfrac{Z_{\frac{\alpha}{2}}\sigma}{\varepsilon}\Big)^2$ 时, 有 $(1-\alpha)$ 置信, 误差绝对值 $\le\varepsilon$.</li></ul></li><li><p><strong>例</strong>  $X\sim N(\mu,\sigma^2)$, <strong>未知</strong> $\sigma^2$, 给出 $\mu$ 的 $(1-\alpha)$ 置信区间估计.</p></li><li><p><strong>解答</strong>  注意到</p><script type="math/tex; mode=display">  \dfrac{\overline{X}-\mu}{\frac{\sigma}{\sqrt{n}}}\sim N(0,1),\\  \dfrac{(n-1)S^2}{\sigma^2}\sim\chi^2(n-1).</script><p>  注意到 $\overline{X}$, $S^2$ 相互独立, 由<strong>陈书 $P_{93-94}$</strong>可得</p><script type="math/tex; mode=display">  \dfrac{\overline{X}-\mu}{\frac{\sigma}{\sqrt{n}}}/\dfrac{S}{\sigma}\sim t(n-1).</script><p>  即</p><script type="math/tex; mode=display">  \dfrac{\overline{X}-\mu}{\frac{S}{\sqrt{n}}}\sim t(n-1).</script><p>  因此</p><script type="math/tex; mode=display">  P\Big(\left|\dfrac{\overline{X}-\mu}{\frac{S}{\sqrt{n}}}\right|<t_{\tfrac{\alpha}{2}}(n-1)\Big)=1-\alpha.</script><p>  其中 $t_{\tfrac{\alpha}{2}}(n-1)$ 为 $t(n-1)$ 分布上侧 $\dfrac{\alpha}{2}$ 分位数, 所求 $(1-\alpha)$ 置信区间估计为</p><script type="math/tex; mode=display">  (\overline{X}-\frac{S}{\sqrt{n}}t_{\tfrac{\alpha}{2}}(n-1),\overline{X}+\frac{S}{\sqrt{n}}t_{\tfrac{\alpha}{2}}(n-1)).</script></li><li><p><strong>注</strong>  $\dfrac{\overline{X}-\mu}{\frac{\sigma}{\sqrt{n}}}$, $\dfrac{\overline{X}-\mu}{\frac{S}{\sqrt{n}}}$ 成为枢轴变量.</p></li><li><p><strong>例</strong>  $X\sim N(\mu,\sigma^2)$, <strong>未知</strong> $\mu$, 给出 $\sigma^2$ 的 $(1-\alpha)$ 置信区间估计.</p></li><li><p><strong>解答</strong>  注意到</p><script type="math/tex; mode=display">  \dfrac{(n-1)S^2}{\sigma^2}\sim\chi^2(n-1).</script><p>  因此所求 $(1-\alpha)$ 置信区间估计为</p><script type="math/tex; mode=display">  \Big(\frac{(n-1)S^2}{\chi^2_{\tfrac{\alpha}{2}}(n-1)},\frac{(n-1)S^2}{\chi^2_{1-\tfrac{\alpha}{2}}(n-1)}\Big).</script></li><li><p><strong>注</strong>  我们有</p><script type="math/tex; mode=display">  \begin{aligned}  \dfrac{(n-1)S^2}{\sigma^2}&=\dfrac{\sum_{i=1}^{n}(X_i-\overline{X})^2}{\sigma^2}\\  &=\sum\limits_{i=1}^{n}\Big(\dfrac{X_i-\mu}{\sigma}\Big)^2-\Big(\dfrac{\overline{X}-\mu}{\tfrac{\sigma}{\sqrt{n}}}\Big)^2\\  &\sim\chi^2(n-1).  \end{aligned}</script></li><li><p><strong>例</strong>  $X\sim N(\mu_1,\sigma^2)$, $Y\sim N(\mu_2,\sigma^2)$ 相互独立, <strong>未知</strong> $\mu_1$, $\mu_2$, $\sigma^2$, 给出 $\mu_1-\mu_2$ 的 $(1-\alpha)$ 置信区间估计.</p></li><li><p><strong>解答</strong>  设 $X_1,\cdots,X_n$, $Y_1,\cdots,Y_m$ 为随机样本, $S_1^2$ 为 $X$ 的样本方差, $S_2^2$ 为 $Y$ 的样本方差, 则</p><script type="math/tex; mode=display">  (\overline{X}-\overline{Y})-(\mu_1-\mu_2)\sim N(0,\dfrac{\sigma^2}{n}+\dfrac{\sigma^2}{m}).</script><p>  因为</p><script type="math/tex; mode=display">  \dfrac{(n-1)S_1^2}{\sigma^2}+\dfrac{(m-1)S_2^2}{\sigma^2}\sim\chi^2(n+m-2).</script><p>  记</p><script type="math/tex; mode=display">  S^2=\dfrac{n-1}{n+m-2}S_1^2+\dfrac{m-1}{n+m-2}S_2^2.</script><p>  从而得到</p><script type="math/tex; mode=display">  \dfrac{(\overline{X}-\overline{Y})-(\mu_1-\mu_2)}{\sqrt{\dfrac{\sigma^2}{n}+\dfrac{\sigma^2}{m}}}/\dfrac{S}{\sigma}\sim t(n+m-2).</script><p>  也即</p><script type="math/tex; mode=display">  \dfrac{(\overline{X}-\overline{Y})-(\mu_1-\mu_2)}{S\sqrt{\dfrac{1}{n}+\dfrac{1}{m}}}\sim t(n+m-2).</script><p>  这是我们用到的枢轴变量, 所求 $(1-\alpha)$ 置信区间估计为</p><script type="math/tex; mode=display">  \Big(\overline{X}-\overline{Y}-t_{\tfrac{\alpha}{2}}(l)S\sqrt{\dfrac{m+n}{mn}},\overline{X}-\overline{Y}+t_{\tfrac{\alpha}{2}}(l)S\sqrt{\dfrac{m+n}{mn}}\Big).</script><p>  其中 $l=n+m-2$.</p></li><li><p><strong>定义(渐进置信区间)</strong>  通过大样本方法进行区间估计.</p></li><li><p><strong>例(选举问题)</strong>  真实支持率 $p$ 未知, $n=1200$, 观测比例 $\dfrac{684}{1200}\approx 0.57$. 给出 $p$ 的一个 $95\%$ 置信的区间估计.</p></li><li><p><strong>解答</strong>  $X_i\sim B(p)\,(1\le i\le n)$ <strong>iid</strong> (近似有放回, $n&lt;&lt;N$). 我们有</p><script type="math/tex; mode=display">  P_n=P_n(X_1,\cdots,X_n)=\dfrac{1}{n}\sum\limits_{i=1}^{n}X_i=\overline{X}.</script><p>  因此</p><script type="math/tex; mode=display">  E(P_n)=p,\,Var(P_n)=\dfrac{p(1-p)}{n}.</script><p>  由 <strong>CLT</strong>, 得到</p><script type="math/tex; mode=display">  \dfrac{P_n-p}{\sqrt{\tfrac{p(1-p)}{n}}}\sim N(0,1)\Rightarrow P\Big(|\dfrac{P_n-p}{\sqrt{\tfrac{p(1-p)}{n}}}|<Z_{\tfrac{\alpha}{2}}\Big)\approx 1-\alpha.</script><p>  $[1]$ 用 $S^2=\dfrac{1}{n-1}\sum\limits_{i=1}^{n}(X_i-\overline{X})^2$ 来估计 $\sigma^2=p(1-p)$. 由 <strong>CLT</strong>, 得到</p><script type="math/tex; mode=display">  \dfrac{P_n-p}{\sqrt{\tfrac{S^2}{n}}}\stackrel{近似} {\sim} N(0,1)\Rightarrow P\Big(|\dfrac{P_n-p}{\sqrt{\tfrac{S^2}{n}}}|<Z_{\tfrac{\alpha}{2}}\Big)\approx 1-\alpha.</script><p>  其中 $S^2\approx 0.2475$, 区间估计为 $(0.542,0.598)$.</p><p>  $[2]$ 用 $m_2=\dfrac{1}{n}\sum\limits_{i=1}^{n}(X_i-\overline{X})^2$ 来估计 $\sigma^2=p(1-p)$. </p><p>  实际上, 我们有</p><script type="math/tex; mode=display">  m_2=\dfrac{1}{n}[(1-P_n)^2nP_n+(0-P_n)^2(n-nP_n)]=P_n(1-P_n).</script><p>  由 <strong>CLT</strong>, 得到</p><script type="math/tex; mode=display">  \dfrac{P_n-p}{\sqrt{\tfrac{P_n(1-P_n)}{n}}}\stackrel{近似} {\sim} N(0,1)\Rightarrow p\in(0.542,0.598).</script><p>  $[3]$ 用 $p(1-p)$ 的最大值来估计 $\sigma^2=p(1-p)$. 由 <strong>CLT</strong>, 得到</p><script type="math/tex; mode=display">  \dfrac{P_n-p}{\sqrt{\tfrac{1}{4n}}}\stackrel{近似} {\sim} N(0,1)\Rightarrow p\in(0.542,0.599).</script></li><li><p><strong>注</strong>  近似分布情况下, 置信度 $\approx 1-\alpha$, 近似程度取决于 $n$ 及总体分布.</p></li><li><p><strong>定义(利用 MLE 构建置信区间)</strong></p><p>  总体分布 $f$ 满足一定的光滑性条件, 存在 $\sigma_n&gt;0$, 使 $\dfrac{\theta^{*}-\theta}{\sigma_n}\rightarrow N(0,1)$.</p></li><li><p><strong>定义(Fisher 信息量)</strong>  $X_1,\cdots,X_n$ <strong>iid</strong>, 其 <strong>PDF</strong> 为 $f(x;\theta)$. 定义对数似然函数</p><script type="math/tex; mode=display">  l(\theta)=\log L(\theta)=\sum_{i=1}^{n}\log f(x_i;\theta).</script><p>  定义</p><script type="math/tex; mode=display">  I_n(\theta)=E\Big[\big(\dfrac{\partial l(\theta)}{\partial\theta}\big)^2\Big]=E\Big[\big(\sum_{i=1}^{n}\dfrac{\partial\log f(X_i;\theta)}{\partial\theta}\big)^2\Big].</script><p>  注意到</p><script type="math/tex; mode=display">  \begin{aligned}  E\Big(\dfrac{\partial\log f(X_i;\theta)}{\partial\theta}\Big)&=E\Big(\dfrac{f_{\theta}(X_i;\theta)}{f(X_i;\theta)}\Big)\\  &=\int\dfrac{f_{\theta}(X_i;\theta)}{f(X_i;\theta)}f(X_i;\theta)dx\\  &=\int f_{\theta}(X_i;\theta)dx\\  &=\dfrac{d}{d\theta}\int f(X_i;\theta)dx=0.  \end{aligned}</script><p>  因此</p><script type="math/tex; mode=display">  \begin{aligned}  \end{aligned}\begin{aligned}  I_n(\theta)&=E\Big[\big(\sum_{i=1}^{n}\dfrac{\partial\log f(X_i;\theta)}{\partial\theta}\big)^2\Big]\\  &=\sum_{i=1}^{n}E\Big[\big(\dfrac{\partial\log f(X_i;\theta)}{\partial\theta}\big)^2\Big]\\  &:=nI(\theta).  \end{aligned}</script><p>  由极大似然估计的定义, 我们有</p><script type="math/tex; mode=display">  0=l'(\theta^*)\approx l'(\theta)+(\theta^*-\theta)l''(\theta)\Rightarrow\theta^*-\theta\approx \dfrac{l'(\theta)}{-l''(\theta)}\\  \Rightarrow\sqrt{n}(\theta^*-\theta)\approx \dfrac{\tfrac{1}{\sqrt{n}}l'(\theta)}{-\tfrac{1}{n}l''(\theta)}.</script><p>  研究上式<strong>分子</strong>: 设随机变量 $Y_i=\dfrac{\partial\log f(X_i;\theta)}{\partial\theta}=\dfrac{f_{\theta}(X_i;\theta)}{f(X_i;\theta)}$, 那么</p><script type="math/tex; mode=display">  E(Y_i)=0,\,Var(Y_i)=E(Y_i^2)-E^2(Y_i)=I(\theta).</script><p>  从而</p><script type="math/tex; mode=display">  \dfrac{1}{\sqrt{n}}l'(\theta)=\dfrac{1}{\sqrt{n}}\sum_{i=1}^{n}Y_i=\dfrac{\overline{Y}}{\tfrac{1}{\sqrt{n}}}\stackrel{CLT}{\longrightarrow}N(0,I(\theta)).</script><p>  研究上式<strong>分母</strong>: </p><script type="math/tex; mode=display">  -\dfrac{1}{n}l''(\theta)=-\dfrac{1}{n}\sum_{i=1}^{n}\Big[\dfrac{f_{\theta\theta}(X_i;\theta)}{f(X_i;\theta)}-\big(\dfrac{f_{\theta}(X_i;\theta)}{f(X_i;\theta)}\big)^2\Big].</script><p>  注意到</p><script type="math/tex; mode=display">  E\Big(\dfrac{f_{\theta\theta}(X_i;\theta)}{f(X_i;\theta)}\Big)=0.</script><p>  因此</p><script type="math/tex; mode=display">  -\dfrac{1}{n}l''(\theta)\stackrel{WLLN}{\longrightarrow}E\Big[\dfrac{1}{n}\sum_{i=1}^{n}\big(\dfrac{f_{\theta}(X_i;\theta)}{f(X_i;\theta)}\big)^2\Big]=\dfrac{1}{n}\sum_{i=1}^{n}E(Y_i^2)=I(\theta).</script><p>  结合上述讨论可得</p><script type="math/tex; mode=display">  \sqrt{n}(\theta^*-\theta)\rightarrow N(0,\dfrac{1}{I(\theta)})\\  \Leftrightarrow\dfrac{\theta^*-\theta}{\tfrac{1}{\sqrt{nI(\theta)}}}\stackrel{近似}{\sim}N(0,1)\\  \Rightarrow\dfrac{\theta^*-\theta}{\tfrac{1}{\sqrt{nI(\theta^*)}}}\stackrel{近似}{\sim}N(0,1).</script><p>  这说明可以取 $\sigma_n=\dfrac{1}{\sqrt{nI(\theta)}}$ 或 $\dfrac{1}{\sqrt{nI(\theta^*)}}$.</p></li><li><p><strong>例(选举问题)</strong>  真实支持率 $p$ 未知, $n=1200$, 观测比例 $\dfrac{684}{1200}\approx 0.57$. 给出 $p$ 的一个 $95\%$ 置信的区间估计.</p></li><li><p><strong>解答续</strong>  注意到 $X_i\stackrel{iid}{\sim}B(p)$, $p$ 的 <strong>MLE</strong> 为 $p^{*}=P_n$. 有似然函数</p><script type="math/tex; mode=display">  f(X;p)=p^{X}(1-p)^{1-X}\Rightarrow \dfrac{\partial\log f}{\partial p}=\dfrac{X-p}{p(1-p)}.</script><p>  <strong>Fisher</strong> 信息量为:</p><script type="math/tex; mode=display">  I(p)=E\Big[\big(\dfrac{X-p}{p(1-p)}\big)^2\Big]=\dfrac{1}{p(1-p)}.</script><p>  得到 $\sigma_n=\dfrac{1}{\sqrt{p(1-p)}}$ 或 $\dfrac{1}{\sqrt{p^{<em>}(1-p^{</em>})}}$. 这与前例 $[2]$ 完全一致.</p></li><li><p><strong>例(两总体)</strong>  $X\sim N(\mu_1,\sigma_1^2)$, $Y\sim N(\mu_2,\sigma_2^2)$ 独立, 参数未知. 估计 $\mu_1-\mu_2$.</p></li><li><p><strong>解答</strong>  得到</p><script type="math/tex; mode=display">  \dfrac{(\overline{X}-\overline{Y})-(\mu_1-\mu_2)}{\sqrt{\dfrac{\sigma_1^2}{n}+\dfrac{\sigma_2^2}{m}}}\sim N(0,1).</script><p>  因此</p><script type="math/tex; mode=display">  \dfrac{(\overline{X}-\overline{Y})-(\mu_1-\mu_2)}{\sqrt{\dfrac{S_1^2}{n}+\dfrac{S_2^2}{m}}}\stackrel{近似}{\sim} N(0,1).</script></li></ul><h2 id="Bayes-估计"><a href="#Bayes-估计" class="headerlink" title="Bayes 估计"></a>Bayes 估计</h2><ul><li><p><strong>定义(Bayes 估计)</strong></p><ul><li><p>在搜集数据之前, 对参数 $\theta$ 有先验知识, 可用一个概率分布来刻画 (先验分布).</p></li><li><p>$\Theta$ — 随机变量, $\theta$ —  $\Theta$ 的实现值.</p></li><li><p>$X$ — 试验观测, $x$ — 具体观测结果.</p></li><li><p>$f_{\Theta}(\theta)$ — 先验分布, $f_{X\mid\Theta}(x\mid\theta)=f_X(x,\theta)$ — 搜集的样本分布.</p></li><li><p>更新先验分布为后验分布:</p><script type="math/tex; mode=display">  f_{\Theta\mid X}(\theta\mid x)=\dfrac{f(x,\theta)}{f_X(x)}=\dfrac{f_{X\mid\Theta}(x\mid\theta)f_{\Theta}(\theta)}{f_X(x)}.</script><p>  其中</p><script type="math/tex; mode=display">  f_X(x)=\int_{\mathbb{R}}f(x,\theta)d\theta.</script><p>  可通过后验期望或后验众数得到 <strong>Bayes</strong> 估计值.</p></li></ul></li><li><p><strong>例</strong>  投掷硬币, 正面向上的概率为 $\theta$ (未知). 抛 $n$ 次观测到 $x$ 次正面向上.</p></li><li><p><strong>解答</strong>  对 $\theta$ 的先验认知: $\theta\sim U(0,1)$ (<strong>Bayes</strong> 法则). 此时有 $f_{\Theta}(\theta)=1$, $\theta\in(0,1)$.</p><p>  令 $X=n$ 次试验正面向上的次数, 给定 $\theta$ 时, $X\sim B(n,\theta)$. 即</p><script type="math/tex; mode=display">  f_{X\mid\Theta}(x\mid\theta)=P(X=x\mid \Theta=\theta)=C_n^x\theta^x(1-\theta)^{n-x},x=0,1,\cdots, n.</script><p>  故 $(X,\Theta)$ 的联合分布为 </p><script type="math/tex; mode=display">  f(x,\theta)=C_n^x\theta^x(1-\theta)^{n-x},\theta\in(0,1),x=0,1,\cdots, n.</script><p>  得到</p><script type="math/tex; mode=display">  f_X(x)=\int_0^1f(x,\theta)d\theta=C_n^x\int_0^1\theta^x(1-\theta)^{n-x}d\theta\\  =\dfrac{n!}{x!(n-x)!}\cdot\dfrac{\Gamma(x+1)\Gamma(n-x+1)}{\Gamma(n+2)}=\dfrac{1}{n+1}</script><p>  进而</p><script type="math/tex; mode=display">  f_{\Theta\mid X}(\theta\mid x)=\dfrac{f(x,\theta)}{f_X(x)}=\dfrac{\Gamma(n+2)}{\Gamma(x+1)\Gamma(n-x+1)}\cdot\theta^x(1-\theta)^{n-x}.</script><p>  注意到这恰好为 $\beta(x+1,n-x+1)$ 的 <strong>PDF</strong>.</p><p>  <strong>后验均值</strong>估计值为</p><script type="math/tex; mode=display">  \hat\theta=E(\Theta\mid X)=\int_0^1\theta f_{\Theta\mid X}(\theta\mid x)d\theta=\dfrac{x+1}{n+2}.</script><p>  <strong>后验众数</strong>估计值为 $f_{\Theta\mid X}(\theta\mid x)$ 的最大值点</p><script type="math/tex; mode=display">  \theta^{*}=\dfrac{x}{n}.</script></li><li><p><strong>注</strong>  </p><ul><li>若 $n=20$, $x=13$, 后验分布服从 $\beta(14,8)$.</li><li>此时 $P(\Theta&gt;\dfrac{1}{2})\approx 0.91$, 而 $\Theta&lt;\dfrac{1}{4}$ 基本不可能.</li></ul></li><li><p><strong>注(合理的点估计)</strong></p><ul><li>后验众数;</li><li>后验均值.</li></ul></li><li><p><strong>注(先验分布选取)</strong> </p><ul><li>本问题先验分布服从 $U(0,1)=\beta(1,1)$, 后验分布服从 $\beta(x+1,n-x+1)$;</li><li>一般地, 先验分布服从 $\beta(a,b)$, 后验分布服从 $\beta(a+x,b+n-x)$.</li></ul></li><li><p><strong>定义(Bayes 区间估计)</strong>  得到参数 $\theta$ 的后验分布 $f_{\Theta}(\theta\mid x)$, 给定观测值 $x$ 和实数 $\alpha\in(0,1)$, 若对参数 $\theta$ 的任意可能取值, 都成立</p><script type="math/tex; mode=display">  P(a<\Theta<b\mid x)\ge 1-\alpha.</script><p>  则称 $(a,b)$ 为 $\theta$ 的 $(1−\alpha)$ 置信的 <strong>Bayes</strong> 区间估计.</p></li><li><p><strong>注</strong></p><ul><li>最大后验区间 (一般单峰);</li><li>等尾可信区间.</li></ul></li><li><p><strong>例</strong>  $X\sim N(\mu,\sigma^2)$, $\sigma^2$ 已知, 给出 $\mu$ 的 $(1-\alpha)$ 置信的 <strong>Bayes</strong> 区间估计.</p></li><li><p><strong>解答</strong>  取 $\mu$ 的先验分布 $f(\mu)\propto 1$, 有后验分布为 $N(\overline{X},\dfrac{\sigma^2}{n})$.</p><p>  进一步可得</p><script type="math/tex; mode=display">  \dfrac{\mu-\overline{X}}{\tfrac{\sigma}{\sqrt{n}}}\sim N(0,1).</script><p>  得到所求 <strong>Bayes</strong> 估计区间为</p><script type="math/tex; mode=display">  (\overline{X}-\frac{\sigma}{\sqrt{n}}Z_{\tfrac{\alpha}{2}},\overline{X}+\frac{\sigma}{\sqrt{n}}Z_{\tfrac{\alpha}{2}}).</script></li></ul><h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><h3 id="样本"><a href="#样本" class="headerlink" title="样本"></a>样本</h3><ul><li>$X_1,\cdots,X_n$ 为样本, 通常为 <strong>iid</strong>.</li><li>$\hat\theta=\hat\theta(X_1,\cdots,X_n)$ 为统计量.</li><li>样本分布: $f(x_1,\cdots,x_n;\theta)$ (<strong>PDF</strong>\*<em>PMF*</em>).</li><li>抽样分布: $\hat\theta$ 的分布.</li><li>标准误差: $se=se(\hat\theta)=\sqrt{Var(\hat\theta)}$.</li></ul><h3 id="经典估计的优良性"><a href="#经典估计的优良性" class="headerlink" title="经典估计的优良性"></a>经典估计的优良性</h3><ul><li>$n$ 固定: 无偏性 &amp; 有效性 (<strong>MSE</strong> 的分解)</li><li>$n\rightarrow\infty$: 渐近无偏 &amp; 相合性 (<strong>WLLN</strong> 一致性) &amp; 渐近正态性 (<strong>CLT</strong>)</li></ul><h3 id="置信区间"><a href="#置信区间" class="headerlink" title="置信区间"></a>置信区间</h3><ul><li>$\hat\theta_i=\hat\theta_i(X_1,\cdots,X_n)\,(i=1,2)$.</li><li>$P(\hat\theta_1&lt;\theta&lt;\hat\theta_2)\ge 1-\alpha$.</li><li>置信 (水平、系数、度) 是针对方法.</li><li>枢轴变量: $H(\hat\theta,\theta)$ 表示分布可用.</li></ul><h3 id="置信区间-v-s-Bayes-区间"><a href="#置信区间-v-s-Bayes-区间" class="headerlink" title="置信区间 v.s. Bayes 区间"></a>置信区间 v.s. Bayes 区间</h3><ul><li><p>(置信区间) 对具体的样本观测值 $(x_1,\cdots,x_n)$, 代入 $\hat\theta_1, \hat\theta_2$ 得到具体区间.</p><script type="math/tex; mode=display">  P(\hat\theta_1<\theta<\hat\theta_2)\ge 1-\alpha.</script></li><li><p>(<strong>Bayes</strong> 区间) 对具体的样本观测值 $(x_1,\cdots,x_n)$, 代入 $a, b$ 得到具体区间.</p><script type="math/tex; mode=display">  P(a<\Theta<b\mid x_1,\cdots,x_n)\ge 1-\alpha.</script></li></ul><h3 id="小样本方法-v-s-大样本方法"><a href="#小样本方法-v-s-大样本方法" class="headerlink" title="小样本方法 v.s. 大样本方法"></a>小样本方法 v.s. 大样本方法</h3><ul><li>精确分布 <strong>v.s.</strong> 近似分布</li></ul><h3 id="Fisher-信息量"><a href="#Fisher-信息量" class="headerlink" title="Fisher 信息量"></a>Fisher 信息量</h3><script type="math/tex; mode=display">\dfrac{\theta^*-\theta}{\sigma_n}\stackrel{近似}{\sim}N(0,1).</script><script type="math/tex; mode=display">\sigma_n=\sqrt{\dfrac{1}{nI(\theta)}}或\sqrt{\dfrac{1}{nI(\theta^*)}}.</script>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;Chap-6-参数估计&quot;&gt;&lt;a href=&quot;#Chap-6-参数估计&quot; class=&quot;headerlink&quot; title=&quot;Chap 6 参数估计&quot;&gt;&lt;/a&gt;Chap 6 参数估计&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;引入&lt;/strong&gt; </summary>
        
      
    
    
    
    <category term="Math" scheme="http://chengsx21.github.io/categories/Math/"/>
    
    <category term="Probability Theory" scheme="http://chengsx21.github.io/categories/Math/Probability-Theory/"/>
    
    
    <category term="Probability Theory" scheme="http://chengsx21.github.io/tags/Probability-Theory/"/>
    
  </entry>
  
  <entry>
    <title>概率论与数理统计 笔记5</title>
    <link href="http://chengsx21.github.io/2023/04/22/gai-lu-lun-yu-shu-li-tong-ji-bi-ji-5/"/>
    <id>http://chengsx21.github.io/2023/04/22/gai-lu-lun-yu-shu-li-tong-ji-bi-ji-5/</id>
    <published>2023-04-22T09:27:40.000Z</published>
    <updated>2023-09-22T08:17:02.300Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Chap-5-不等式与极限定理"><a href="#Chap-5-不等式与极限定理" class="headerlink" title="Chap 5 不等式与极限定理"></a>Chap 5 不等式与极限定理</h1><h2 id="概率不等式"><a href="#概率不等式" class="headerlink" title="概率不等式"></a>概率不等式</h2><ul><li><p><strong>定义(Markov 不等式)</strong>  $Y\ge 0$, $\forall\,a&gt;0$, 有</p><script type="math/tex; mode=display">P(Y\ge a)\le \dfrac{E(Y)}{a}.</script></li><li><p><strong>证明</strong>  令示性变量</p><script type="math/tex; mode=display">I=\begin{cases}1,Y\ge a;\\0,Y<a.\end{cases}</script><p>从而有 $I\le \dfrac{Y}{a}$, 两边取期望, 即得</p><script type="math/tex; mode=display">P(Y\ge a)\le \dfrac{E(Y)}{a}.</script></li><li><p><strong>定义(Chebyshev 不等式)</strong>  $Var(Y)$ 存在, $\forall\,a&gt;0$, 有</p><script type="math/tex; mode=display">P(\vert Y-E(Y)\vert\ge a)\le \dfrac{Var(Y)}{a^2}.</script></li><li><p><strong>证明</strong>  注意到</p><script type="math/tex; mode=display">  \begin{aligned}  P(\vert Y-E(Y)\vert\ge a)&=P((Y-E(Y))^2\ge a^2)\\  &\le\dfrac{E[(Y-E(Y))^2]}{a^2}\\  &=\dfrac{Var(Y)}{a^2}.  \end{aligned}</script></li><li><p><strong>注</strong>  若 $Var(Y)=0$, 则 $P(Y=E(Y))=1$. ($Y=E(Y)$ $a.s.$)</p></li><li><p><strong>定义(Chernoff 不等式)</strong>  $\forall\,a&gt;0$, $t&gt;0$, 有</p><script type="math/tex; mode=display">P(Y\ge a)\le \dfrac{E(e^{tY})}{e^{ta}}.</script></li><li><p><strong>证明</strong>  注意到</p><script type="math/tex; mode=display">  \begin{aligned}  P(Y\ge a)&=P(e^{tY}\ge e^{ta})\,(保证\,e^{tY}>0)\\  &\le\dfrac{E(e^{tY})}{e^{ta}}.  \end{aligned}</script></li><li><p><strong>例</strong>  $X\sim N(0,1)$, 估计 $P(\vert X\vert\ge 3)$.</p></li><li><p><strong>解答</strong>  我们有</p><script type="math/tex; mode=display">  P(\vert X\vert\ge 3)\le   \begin{cases}  \dfrac{E(\vert X\vert)}{3}=\dfrac{1}{3}\sqrt{\dfrac{2}{\pi}}\approx 0.27;\quad(Markov)\\  \dfrac{Var(X)}{3^2}=\dfrac{1}{9}\approx 0.11;\quad(Chebyshev)\\  \dfrac{2E(e^{tX})}{e^{3t}}=2e^{\tfrac{t^2}{2}-3t}\le 2e^{-\tfrac{9}{2}}\approx 0.02.\quad(Chernoff)  \end{cases}</script></li></ul><h2 id="大数定律-LLN"><a href="#大数定律-LLN" class="headerlink" title="大数定律 (LLN)"></a>大数定律 (LLN)</h2><ul><li><p><strong>定义</strong>  $X_1,X_2,\cdots$ <strong>iid</strong> (独立同分布), $E(X_i)=\mu$, $Var(X_i)=\sigma^2&gt;0$. 定义:</p><script type="math/tex; mode=display">\overline{X}=\dfrac{1}{n}\sum_{i=1}^{n}X_i,\, E(\overline{X})=\mu,\,Var(\overline{X})=\dfrac{\sigma^2}{n}\rightarrow 0.</script></li><li><p><strong>定义(Khinchin 弱大数定律)(WLLN)</strong> </p><p>  若 $X_1,X_2,\cdots$ <strong>iid</strong>, $E(X_i)=\mu$, $Var(X_i)=\sigma^2&gt;0$. 则 $\forall\varepsilon&gt;0$, 有</p><script type="math/tex; mode=display">  \lim_{n\rightarrow\infty}P(\vert \overline{X}-\mu\vert\ge \varepsilon)=0.</script></li><li><p><strong>证明</strong>  我们有</p><script type="math/tex; mode=display">  P(\vert \overline{X}-\mu\vert\ge \varepsilon)\le\dfrac{Var(\overline{X})}{\varepsilon^2}=\dfrac{\sigma^2}{n\varepsilon^2}\rightarrow 0, 当\,n\rightarrow 0.</script></li><li><p><strong>注</strong></p><ul><li><p>$\mu\approx\overline{X}$ (在很大概率意义下可以用作样本均值估计);</p></li><li><p>$\forall\,\varepsilon&gt;0$, $\forall\,\alpha&gt;0$, $\exists N&gt;0$ 使得当 $n\ge N$ 时</p><script type="math/tex; mode=display">P(\vert \overline{X}-\mu\vert\ge \varepsilon)\le\alpha.</script><p>其中 $\varepsilon$ 体现了精度，$\alpha$ 体现了置信度.</p></li><li><p><strong>Bernoulli LLN</strong>: $X_i\sim B(p)$, 则特殊地得到 <strong>Bernoulli</strong> 大数定律。</p></li><li><p>方差有限条件可去掉, 结论依然成立;</p></li><li><p>可推广至不同的条件:</p><ul><li>$X_i$ 两两不相关,  $Var(X_i)$ 一致有界 (<strong>Chebyshev</strong>);</li><li>$Var(\overline{X})\rightarrow 0$ (<strong>Markov</strong>).</li></ul></li></ul></li><li><p><strong>定义(依概率收敛)</strong></p><script type="math/tex; mode=display">Y_n\stackrel{P}{\longrightarrow}Y\Longleftrightarrow\forall\varepsilon>0, \lim_{n\rightarrow\infty}P(\vert Y_n-Y\vert\ge\varepsilon)=0.</script></li><li><p><strong>注</strong>  <strong>WLLN</strong> $\Rightarrow\overline{X}\stackrel{P} {\longrightarrow}\mu$ (考虑偏差).</p></li><li><p><strong>定义(Kolmogov 强大数定律)(SLLN)</strong></p><p>  若 $X_1,X_2,\cdots$ <strong>iid</strong>, $E(X_i)=\mu$. 则有</p><script type="math/tex; mode=display">  P(\omega\in\Omega\mid \lim_{n\rightarrow\infty}\overline{X_n}(\omega)=\mu)=P(\lim_{n\rightarrow\infty}\overline{X}=\mu)=1.</script></li><li><p><strong>注</strong>  若 $X_i\sim B(p)$ 则 $\overline{X}$ 为频率,从而概率的频率解释是合理的.</p></li><li><p><strong>定义(以概率 1 收敛)</strong></p><script type="math/tex; mode=display">Y_n\stackrel{a.s.}{\longrightarrow}Y\Longleftrightarrow P(\lim_{n\rightarrow\infty}Y_n=Y)=1.</script></li><li><p><strong>注</strong>  <strong>SLLN</strong> $\Rightarrow\overline{X}\stackrel{a.s.} {\longrightarrow}\mu$ (逐点考虑).</p></li><li><p><strong>例</strong>  (<strong>Monte Carlo</strong> 积分)</p></li><li><p><strong>解答</strong>  在 $[a,b]\times [0,c]$ 上取点 $(X_i,Y_i)$ <strong>iid</strong> 在矩形内均匀分布. 定义</p><script type="math/tex; mode=display">  I_i=  \begin{cases}  1,(X_i,Y_i)\in D;\\  0,(X_i,Y_i)\notin D.  \end{cases}</script><p>  则 $I_i\stackrel{iid} {\longrightarrow}B(p)$. 我们有</p><script type="math/tex; mode=display">  P=\dfrac{1}{(b-a)c}\int_a^bg(x)dx\approx\dfrac{1}{n}\sum_{i=1}^{n}I_i.</script></li><li><p><strong>例</strong>  两种收敛有什么差别?</p></li><li><p><strong>解答</strong>  考虑 $\Omega=[0,1]$ 均匀分布 (从而有 ($\Omega,\mathscr{F},P$)). 我们构造</p><script type="math/tex; mode=display">Y_1(\omega)=\omega+I_{[0,1]}(\omega)\\Y_2(\omega)=\omega+I_{[0,\frac{1}{2}]}(\omega)\\Y_3(\omega)=\omega+I_{[\frac{1}{2},1]}(\omega)\\Y_4(\omega)=\omega+I_{[0,\frac{1}{3}]}(\omega)\\Y_5(\omega)=\omega+I_{[\frac{1}{3},\frac{2}{3}]}(\omega)\\Y_6(\omega)=\omega+I_{[\frac{2}{3},1]}(\omega)\\\cdots\\Y(\omega)=\omega.</script><p>因此有 $Y_n\stackrel{P} {\longrightarrow}Y$, 但是 $Y_n\stackrel{a.s.} {\longrightarrow}Y$ 不成立.</p><p>这是因为 $\forall\,\omega_0\in(0,1)$, $Y_n(\omega_0)$ 是振荡的, 它的极限不存在.</p></li></ul><h2 id="中心极限定理-CLT"><a href="#中心极限定理-CLT" class="headerlink" title="中心极限定理 (CLT)"></a>中心极限定理 (CLT)</h2><ul><li><p><strong>定义(中心极限定理)(CLT)</strong></p><p>若 $X_1,X_2,\cdots$ <strong>iid</strong>, $E(X_i)=\mu$, $Var(X_i)=\sigma^2&gt;0$. 我们有</p><script type="math/tex; mode=display">\lim_{n\rightarrow\infty}P\left(\dfrac{X_1+\cdots+X_n-n\mu}{\sqrt{n}\sigma}\le x\right)=\Phi(x),\,\forall\,x\in\mathbb{R}.</script><p>其中 $\Phi(x)$ 为 $N(0,1)$ 的 <strong>CDF</strong>. 也即</p><script type="math/tex; mode=display">\lim_{n\rightarrow\infty}P\left(\dfrac{\overline{X}-\mu}{\tfrac{\sigma}{\sqrt{n}}}\le x\right)=\Phi(x),\,\forall\,x\in\mathbb{R}.</script></li><li><p><strong>证明</strong>  只在 $X_i$ 的 <strong>MGF</strong> 存在情形下证明, 记 $M(t)=M_{X_i}(t)$.</p><p>  不失一般性地, 令 $\mu=0$, $\sigma^2=1$. 因此</p><script type="math/tex; mode=display">  M(0)=E(1)=1,\\  M'(0)=E(X_i)=\mu=0,\\  M''(0)=E(X_i^2)=\sigma^2=1.</script><p>  我们得到</p><script type="math/tex; mode=display">  \begin{aligned}  E(e^{t\frac{X_1+\cdots+X_n}{\sqrt{n}}})&=M^n(\tfrac{t}{\sqrt{n}})\\  &=\left(1+\tfrac{t^2}{2n}+o(\tfrac{t^2}{n})\right)^n\\  &\rightarrow e^{\tfrac{t^2}{2}}.  \end{aligned}</script></li></ul><ul><li><p><strong>注</strong></p><ul><li><p>上述 <strong>CLT</strong> 通常称为 <strong>Lindeberg-Levy CLT</strong>;</p></li><li><p><strong>CLT</strong> $\Rightarrow X_1+\cdots+X_n\sim N(n\mu,n\sigma^2)$, $\overline{X}\sim N(\mu,\dfrac{\sigma^2}{n})$;</p></li><li><p><strong>(DeMoivre-Laplace CLT)</strong>  </p><p>  若 $X_i\sim B(p)$, 则 $\sum\limits_{i=1}^{n}X_i\sim B(n,p)\stackrel{CLT} {\longrightarrow}$ 正态分布.</p></li></ul></li><li><p><strong>定义(二项分布下 CLT 的连续性修正)</strong></p><p>我们有 $P(t_1\le\sum\limits_{i=1}^{n}X_i\le t_2)\approx\Phi(y_2)-\Phi(y_1)$. 其中</p><script type="math/tex; mode=display">\begin{cases}y_1=\dfrac{t_1-np-\tfrac{1}{2}}{\sqrt{np(1-p)}},\\y_2=\dfrac{t_2-np+\tfrac{1}{2}}{\sqrt{np(1-p)}}.\end{cases}</script><p>修正形式可计算单点 $P(S_n=k)$ 的概率, 对其他离散变量也同样适用.</p></li><li><p><strong>定义(依分布收敛)</strong></p><script type="math/tex; mode=display">Y_n\stackrel{d}{\longrightarrow}Y\Longleftrightarrow \lim_{n\rightarrow\infty}F_n(x)=F(x).</script></li></ul><ul><li><p><strong>注</strong>  <strong>CLT</strong> $\Rightarrow Z_n=\dfrac{X_1+\cdots+X_n-n\mu}{\sqrt{n}\sigma}=\dfrac{\overline{X}-\mu}{\tfrac{\sigma}{\sqrt{n}}}$ (标准化).</p></li><li><p><strong>例(选举问题)</strong>  设 $p$ 为选民支持率(未知), 随机调查 $n$ 个人, 支持比例为 $p_n=\dfrac{1}{n}\sum\limits_{i=1}^{n}X_i$, 其中 $X_i\sim B(p)$. 若 $\varepsilon=0.03$, $1-\alpha=0.95$, 求 $n$ 的取值.</p></li><li><p><strong>解答</strong>  有</p><script type="math/tex; mode=display">  P(\left|p_n-p\right|\ge\varepsilon)\le \alpha.</script><p>  由 <strong>CLT</strong> 可得</p><script type="math/tex; mode=display">  \begin{aligned}  P(\left|p_n-p\right|\ge\varepsilon)&=1-P\Big(-\dfrac{\sqrt{n}\varepsilon}{\sigma}\le\dfrac{p_n-p}{\tfrac{\sigma}{\sqrt{n}}}\le\dfrac{\sqrt{n}\varepsilon}{\sigma}\Big)\\  &=1-\Phi\Big(\dfrac{\sqrt{n}\varepsilon}{\sqrt{p(1-p)}}\Big)+\Phi\Big(-\dfrac{\sqrt{n}\varepsilon}{\sqrt{p(1-p)}}\Big)\\  &=2-2\Phi\Big(\dfrac{\sqrt{n}\varepsilon}{\sqrt{p(1-p)}}\Big)\le\alpha.  \end{aligned}</script><p>  即得</p><script type="math/tex; mode=display">  \Phi\Big(\dfrac{\sqrt{n}\varepsilon}{\sqrt{p(1-p)}}\Big)\ge 1-\dfrac{\alpha}{2}.</script><p>  为使得对任意 $p$ 成立, 取 $p=\dfrac{1}{2}$, 即有</p><script type="math/tex; mode=display">  \Phi\Big(2\sqrt{n}\varepsilon\Big)\ge 1-\dfrac{\alpha}{2}.</script><p>  注意到 $\Phi(1.96)\approx 0.975=1-\dfrac{\alpha}{2}$, 因此取 $n\ge 1068$ 即可 (与 $N$ 无关).</p></li></ul><h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><h3 id="尾部概率控制"><a href="#尾部概率控制" class="headerlink" title="尾部概率控制"></a>尾部概率控制</h3><h3 id="极限定理"><a href="#极限定理" class="headerlink" title="极限定理"></a>极限定理</h3><ul><li><strong>LLN</strong>: 弱 or 强</li><li><strong>CLT</strong></li></ul><h3 id="三种收敛"><a href="#三种收敛" class="headerlink" title="三种收敛"></a>三种收敛</h3><h3 id="CLT-应用"><a href="#CLT-应用" class="headerlink" title="CLT 应用"></a><strong>CLT</strong> 应用</h3><script type="math/tex; mode=display">\begin{cases}X_1+\cdots+X_n\sim N(n\mu,n\sigma^2);\\\overline{X}\sim N(\mu,\dfrac{\sigma^2}{n}).\end{cases}</script>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;Chap-5-不等式与极限定理&quot;&gt;&lt;a href=&quot;#Chap-5-不等式与极限定理&quot; class=&quot;headerlink&quot; title=&quot;Chap 5 不等式与极限定理&quot;&gt;&lt;/a&gt;Chap 5 不等式与极限定理&lt;/h1&gt;&lt;h2 id=&quot;概率不等式&quot;&gt;&lt;a</summary>
        
      
    
    
    
    <category term="Math" scheme="http://chengsx21.github.io/categories/Math/"/>
    
    <category term="Probability Theory" scheme="http://chengsx21.github.io/categories/Math/Probability-Theory/"/>
    
    
    <category term="Probability Theory" scheme="http://chengsx21.github.io/tags/Probability-Theory/"/>
    
  </entry>
  
  <entry>
    <title>人工智能导论 笔记2</title>
    <link href="http://chengsx21.github.io/2023/04/17/ren-gong-zhi-neng-dao-lun-bi-ji-2/"/>
    <id>http://chengsx21.github.io/2023/04/17/ren-gong-zhi-neng-dao-lun-bi-ji-2/</id>
    <published>2023-04-17T01:52:54.000Z</published>
    <updated>2023-09-22T08:21:21.313Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第二章-神经网络和深度学习"><a href="#第二章-神经网络和深度学习" class="headerlink" title="第二章 神经网络和深度学习"></a>第二章 神经网络和深度学习</h1><h2 id="神经网络-——-从数字识别说起"><a href="#神经网络-——-从数字识别说起" class="headerlink" title="神经网络 —— 从数字识别说起"></a>神经网络 —— 从数字识别说起</h2><ul><li><p>深度学习 $\subseteq$ 机器学习 $\subseteq$ 人工智能.</p>  <div align="center"><img src="/pic/61.png" width="100%" height="100%"></div></li><li><p>$w_i(1\le i\le n)$ 表示<strong>数字模式</strong>, $x_i(1\le i\le n)$ 表示<strong>数字图像</strong>, 大小表示<strong>匹配程度</strong>.</p><script type="math/tex; mode=display">  net=\sum_{i=1}^{n}w_i\cdot x_i.</script></li><li><p><strong>Sigmoid 函数</strong>: 评判<strong>匹配的程度</strong>, 将匹配结果变换到 0~1 之间.</p><script type="math/tex; mode=display">  \sigma(net)=\dfrac{1}{1+e^{-net}}.</script></li><li><p><strong>增加偏置项</strong>: 使 <strong>Sigmoid</strong> 函数平移.</p><script type="math/tex; mode=display">  net=\sum_{i=1}^{n}w_i\cdot x_i+b;\\  y=sigmoid(net).</script>  <div align="center"><img src="/pic/62.png" width="100%" height="100%"></div>  <div align="center"><img src="/pic/63.png" width="100%" height="100%"></div></li><li><p><strong>神经元</strong>代表一个<strong>模式</strong>, 其输出为匹配结果.</p></li><li><p><strong>神经网络的扩展</strong>:</p><ul><li><p><strong>横向</strong> —— 增加模式.</p>  <div align="center"><img src="/pic/64.png" width="100%" height="100%"></div></li><li><p><strong>纵向</strong> —— 局部模式.</p>  <div align="center"><img src="/pic/65.png" width="100%" height="100%"></div></li><li><p><strong>网络更深</strong> —— 模式组合.</p>  <div align="center"><img src="/pic/66.png" width="100%" height="100%"></div></li></ul></li><li><p><strong>获得模式</strong>:</p><ul><li>模式通过神经元的<strong>连接权重</strong>表示.</li><li>通过训练样本, <strong>自动学习</strong>权重 (模式), 不是人工设计.</li><li>学习到的模式是一种<strong>隐含表达</strong>.</li></ul></li></ul><h2 id="神经元与神经网络"><a href="#神经元与神经网络" class="headerlink" title="神经元与神经网络"></a>神经元与神经网络</h2><ul><li><p>神经元:</p><script type="math/tex; mode=display">  net=\sum_{i=1}^{n}w_i\cdot x_i+b=\sum_{i=0}^{n}w_i\cdot x_i;\\  o=g(net).</script>  <div align="center"><img src="/pic/67.png" width="100%" height="100%"></div></li><li><p><strong>激活函数</strong>:</p><ul><li><p>符号函数.</p></li><li><p><strong>Sigmoid</strong> 函数.</p></li><li><p>双曲正切函数.</p></li><li><p><strong>ReLU</strong> 函数.</p></li><li><p><strong>Softmax</strong> 函数.</p><script type="math/tex; mode=display">  o_k=\dfrac{e^{net_k}}{\sum\limits_{i=1}^{m}e^{net_i}}.</script>  <div align="center"><img src="/pic/68.png" width="100%" height="100%"></div></li></ul></li></ul><h2 id="如何训练神经网络"><a href="#如何训练神经网络" class="headerlink" title="如何训练神经网络"></a>如何训练神经网络</h2><ul><li><p><strong>建立数据集 (以动物识别为例)</strong>:</p><ul><li>收集各种动物的照片:<ul><li>不同姿势.</li><li>不同角度.</li><li>不同大小.</li></ul></li><li>数据标注:<ul><li>每张照片标注上动物的名称.</li></ul></li><li>训练集与测试集:<ul><li>样本.</li></ul></li></ul></li><li><p><strong>训练网络</strong>: 调整神经元权重.</p></li><li><p><strong>评价效果</strong>: 损失函数.</p></li><li><p><strong>误差平方和损失函数</strong>:</p><ul><li><p>用于<strong>输出是具体数值</strong>的问题.</p></li><li><p>对样本 $d$ 的误差:</p><script type="math/tex; mode=display">  E_d(w)=\dfrac{1}{2}\sum_{k=1}^{m}(t_{kd}-o_{kd})^2.</script></li><li><p>对所有样本的误差:</p><script type="math/tex; mode=display">  E(w)=\sum_{d=1}^{n}E_d(w)=\dfrac{1}{2}\sum_{d=1}^{n}\sum_{k=1}^{m}(t_{kd}-o_{kd})^2.</script>  <div align="center"><img src="/pic/69.png" width="100%" height="100%"></div></li></ul></li><li><p><strong>梯度下降法</strong>:</p><ul><li><p>迭代公式: 对<strong>权重求导</strong>, 作为下降的梯度大小.</p><script type="math/tex; mode=display">  w_i^{new}=w_i^{old}+\Delta w_i,\,\Delta w_i=-\eta\dfrac{\part E(w)}{\part w_i}.\\  \Rightarrow w^{new}=w^{old}+\Delta w,\,\Delta w=-\eta\nabla_wE(w)=-\eta\big[\dfrac{\part E(w)}{\part w_i}\big]_{1\le i\le n}.</script></li><li><p>梯度下降<strong>算法</strong>:</p><ul><li>批量梯度下降算法.</li><li>随机梯度下降算法.</li><li>小批量梯度下降算法.</li></ul><div align="center"><img src="/pic/70.png" width="100%" height="100%"></div></li><li><p><strong>输出层</strong> (只影响<strong>一个输出</strong>):</p>  <div align="center"><img src="/pic/71.png" width="100%" height="100%"></div></li><li><p><strong>隐含层</strong> (影响<strong>多个输出</strong>):</p>  <div align="center"><img src="/pic/72.png" width="100%" height="100%"></div></li><li><p>整体梯度计算:</p>  <div align="center"><img src="/pic/73.png" width="100%" height="100%"></div></li></ul></li><li><p><strong>反向传播算法 (BP算法)</strong>: 随机梯度下降算法的一种实现.</p>  <div align="center"><img src="/pic/75.png" width="100%" height="100%"></div><ul><li>随机梯度下降版: <strong>初始化所有权值为小的随机值</strong>, 如 $[-0.05,0.05]$.</li><li>算法条件:<ul><li><strong>全连接</strong>网络.</li><li>批量、小批量梯度下降算法.</li><li>激活函数: <strong>Sigmoid</strong> 函数.</li><li>损失函数: <strong>误差平方和</strong>.</li></ul></li></ul></li><li><p><strong>交叉熵损失函数</strong>:</p><script type="math/tex; mode=display">  H_d(w)=-\sum_{k=1}^{M}t_{kd}\log o_{kd}.\\  H(w)=\sum_{d=1}^{N}H_d(w)=-\sum_{d=1}^{N}\sum_{k=1}^{M}t_{kd}\log o_{kd}.</script><p>  其中 $t_{kd}$ 为样本的<strong>希望</strong>输出值, $o_{kd}$ 为样本的<strong>实际</strong>输出值, 需要为概率值. 这给出了<strong>两个不同的概率分布间的距离</strong>. 对于<strong>分类问题</strong>, 对于给定输入样本 $d$, 只有 $d$ 对应的希望输出为 1, 其他为 0. 此时</p><script type="math/tex; mode=display">  H_d(w)=-\log o_{kd}.\\</script>  <div align="center"><img src="/pic/75.png" width="100%" height="100%"></div></li></ul><h2 id="卷积神经网络-CNN"><a href="#卷积神经网络-CNN" class="headerlink" title="卷积神经网络 (CNN)"></a>卷积神经网络 (CNN)</h2><ul><li><p><strong>全连接网络</strong>的不足:</p><ul><li>连接<strong>权重过多</strong>.</li><li>影响<strong>训练速度</strong>.</li><li>影响<strong>使用速度</strong>.</li></ul></li><li><p><strong>卷积神经网络</strong>的特点:</p><ul><li><strong>参数少</strong>, 只与卷积核的大小和数量有关.</li><li>具有<strong>特征抽取</strong>能力.</li><li>特征的<strong>平移不变性</strong> (一定程度上).</li></ul></li><li><p>提取局部模式:</p>  <div align="center"><img src="/pic/76.png" width="100%" height="100%"></div><ul><li><p><strong>局部连接</strong>, <strong>权值共享</strong>.</p></li><li><p>卷积核训练通过 <strong>BP</strong> 算法进行.</p></li><li><p><strong>多卷积核</strong>: 一个卷积核产生一个通道, 输出的<strong>通道数</strong>等于<strong>卷积核数</strong>.</p></li><li><p><strong>多输入通道</strong> (例: <strong>RGB</strong> 识别):</p>  <div align="center"><img src="/pic/77.png" width="100%" height="100%"></div><p>  此时视为<strong>多厚度单卷积核</strong>.</p></li><li><p><strong>卷积核大小</strong>: 多层小卷积实现大卷积 (两层 3×3 卷积等效 5×5 卷积).</p></li><li><p><strong>池化</strong>: 一种<strong>降维</strong>的手段 (最大池化/平均池化), 池化<strong>不改变通道数</strong>.</p></li><li><p>卷积核具有<strong>抽取特征</strong>的能力.</p></li></ul></li><li><p><strong>LeNet 神经网络</strong> (数字识别):</p>  <div align="center"><img src="/pic/78.png" width="100%" height="100%"></div></li><li><p><strong>VGG-16 神经网络</strong> (图像识别):</p>  <div align="center"><img src="/pic/79.png" width="100%" height="100%"></div></li></ul><h2 id="梯度消失问题"><a href="#梯度消失问题" class="headerlink" title="梯度消失问题"></a>梯度消失问题</h2><ul><li><p>网络深度过深时:</p>  <div align="center"><img src="/pic/80.png" width="100%" height="100%"></div></li><li><p>使用 <strong>ReLU</strong> 激活函数, 其导数恒为 1:</p>  <div align="center"><img src="/pic/81.png" width="100%" height="100%"></div></li><li><p><strong>GoogLeNet 神经网络</strong> (类比高楼供水系统):</p>  <div align="center"><img src="/pic/82.png" width="100%" height="100%"></div><p>  神经元依靠<strong>就近输出</strong>进行<strong>训练</strong>时的<strong>梯度计算补偿</strong>, 训练结束后只采用最终输出.</p><ul><li><p><strong>Inception 模块</strong>:</p>  <div align="center"><img src="/pic/83.png" width="100%" height="100%"></div><p>  同时使用<strong>不同大小的卷积核.</strong></p></li><li><p><strong>降维 Inception 模块</strong>:</p>  <div align="center"><img src="/pic/84.png" width="100%" height="100%"></div><p>  <strong>使用 1×1 卷积降维</strong>.</p></li><li><p><strong>Inception 模块详析</strong>:</p>  <div align="center"><img src="/pic/85.png" width="100%" height="100%"></div></li></ul></li><li><p><strong>ResNet 残差网络</strong>:</p><ul><li><p>神经网络的<strong>退化</strong>现象 (与<strong>网络结构</strong>有关):</p>  <div align="center"><img src="/pic/86.png" width="100%" height="100%"></div>  <div align="center"><img src="/pic/87.png" width="100%" height="100%"></div></li><li><p>残差模块:</p>  <div align="center"><img src="/pic/88.png" width="100%" height="100%"></div><p>  <strong>恒等映射</strong>的存在<strong>解决了梯度消失问题</strong>.</p>  <div align="center"><img src="/pic/89.png" width="100%" height="100%"></div></li></ul></li></ul><h2 id="过拟合问题"><a href="#过拟合问题" class="headerlink" title="过拟合问题"></a>过拟合问题</h2><ul><li><p>神经网络的<strong>过拟合</strong>问题 (<strong>与网络结构无关, 与训练轮次有关</strong>):</p>  <div align="center"><img src="/pic/90.png" width="100%" height="100%"></div></li><li><p><strong>使用验证集</strong>: 用于调整超参数.</p></li><li><p><strong>限制模型的复杂性</strong>:</p><ul><li><p><strong>正则化项法</strong>: 考虑误差平方和损失函数:</p><script type="math/tex; mode=display">  E_d(w)=\sum_{k=1}^{m}(t_{kd}-o_{kd})^2.</script><p>  加入正则化项用于<strong>降低模型复杂性</strong>:</p><script type="math/tex; mode=display">  E_d(w)=\sum_{k=1}^{m}(t_{kd}-o_{kd})^2+\Vert w\Vert_2^2.</script><ul><li><p>2-范数: 很多参数值很小, 但基本不为 0, <strong>抗干扰能力强</strong>.</p></li><li><p>1-范数: 一些参数为 0, 起到<strong>特征选择</strong>的作用.</p></li></ul></li><li><p><strong>舍弃法</strong>: 随机地<strong>临时舍弃</strong>一些神经元.</p></li></ul></li><li><p><strong>增加数据量</strong>: 获得更多的数据.</p><ul><li><strong>数据增强法</strong>: 数据越多, 过拟合的风险就越小.</li></ul></li></ul><h2 id="词向量"><a href="#词向量" class="headerlink" title="词向量"></a>词向量</h2><ul><li><p>神经网络处理文本 (<strong>词&amp;文本</strong>) 的方法.</p></li><li><p><strong>独热编码 (one-hot)</strong>: 用与<strong>词表</strong>等长的<strong>向量</strong>表示一个词, 只有一个元素为 1.</p><ul><li>优点: 编码<strong>简单</strong>.</li><li>缺点: 编码太长, 无法度量词之间的<strong>相似性</strong> (例: <strong>2-范数度量</strong>).</li></ul></li><li><p><strong>分布式表示</strong>: 相比于独热编码, 是一种稠密表示.</p>  <div align="center"><img src="/pic/91.png" width="100%" height="100%"></div></li><li><p><strong>词嵌入</strong>: 把词向量从高维空间嵌入到低维空间中的一个方法.</p></li><li><p><strong>神经网络语言模型</strong>: 用神经网络实现的语言模型.</p>  <div align="center"><img src="/pic/92.png" width="100%" height="100%"></div><p>  标准的<strong>全连接网络</strong> (<strong>前向神经网络</strong>):</p>  <div align="center"><img src="/pic/93.png" width="100%" height="100%"></div><p>  语言模型同时训练<strong>词向量</strong>和<strong>权重</strong>:</p>  <div align="center"><img src="/pic/94.png" width="100%" height="100%"></div></li><li><p><strong>训练</strong>神经网络语言模型: 让<strong>联合概率最大化</strong>估计概率 (<strong>最大似然估计</strong>).</p><ul><li><p>联合概率分布一般含有参数.</p></li><li><p>通过<strong>最大似然方法</strong>估计联合概率的参数.</p></li><li><p>对于神经网络语言模型, 即是估计网络的参数值.</p></li><li><p><strong>损失函数</strong> (<strong>负对数似然函数</strong>):</p><script type="math/tex; mode=display">  -\sum_{w\in C}\log p(w=k\mid context(w),\theta).</script><p>  其中 $\theta$ 表示神经网络的所有参数, $C$ 为语料库.</p></li><li><p><strong>存在问题</strong>:</p><ul><li><strong>神经元个数</strong>等于<strong>词表长度</strong> $K$.</li><li>$m(n-1)$ 个输入, <strong>全连接参数多</strong>.</li></ul></li></ul></li><li><p><strong>训练</strong>词向量:</p>  <div align="center"><img src="/pic/95.png" width="100%" height="100%"></div><p>  每个词<strong>随机给定</strong>词向量, 并在进行训练<strong>实时更新</strong> (<strong>输入层</strong>相当于一个<strong>新增的隐含层</strong>). 通过训练语言模型, 得到词向量 (<strong>自监督</strong>).</p></li><li><p><strong>word2vec模型</strong>: 一种<strong>简化的神经网络语言模型</strong>.</p><ul><li><p><strong>连续词袋模型 (CBOW)</strong>: <strong>不考虑</strong>上下文中词的<strong>顺序</strong>.</p>  <div align="center"><img src="/pic/96.png" width="100%" height="100%"></div><p>  <strong>输出处理</strong>得到的 $x_w$ 的长度即为<strong>一个词向量的长度</strong>, 使用<strong>语料库预生成</strong>的 <strong>Huffman Tree</strong> 替换隐含层及输出层. <strong>每次训练</strong>时只计算<strong>与该词有关的参数</strong>, 且越是<strong>常用词</strong>涉及的<strong>参数越少</strong>, <strong>训练速度快</strong>.</p><p>  $W$ 经过霍夫曼树每个节点时的概率为:</p><script type="math/tex; mode=display">  p(d_i^w\mid x_w,\theta_{𝑖−1}^w)=      \begin{cases}      \sigma(x_w\cdot\theta_{𝑖−1}^w), & d_i^w=0\\      1-\sigma(x_w\cdot\theta_{𝑖−1}^w), & d_i^w=1      \end{cases}</script><p>  其<strong>损失函数</strong>:</p><script type="math/tex; mode=display">  L=-\sum_{i=2}^{l_w}\{(1-d_i^w)\log{[\sigma(x_w\cdot\theta_{𝑖−1}^w)]}+d_i^w\log{[1-\sigma(x_w\cdot\theta_{𝑖−1}^w)]}\}.</script></li><li><strong>跳词模型 (Skip-Gram Model)</strong>.</li></ul></li><li><p><strong>TextCNN</strong>: 词向量应用——情感分类问题.</p>  <div align="center"><img src="/pic/97.png" width="100%" height="100%"></div></li></ul><h2 id="循环神经网络-RNN"><a href="#循环神经网络-RNN" class="headerlink" title="循环神经网络 (RNN)"></a>循环神经网络 (RNN)</h2><ul><li><p>网络辨析:</p><ul><li><p>数据角度:</p><ul><li>序列数据.</li><li>数据之间有先后联系.</li></ul></li><li><p>网络结构角度:</p><ul><li><strong>前馈网络</strong> (<strong>CNN</strong>).</li><li><strong>反馈网络</strong> (<strong>RNN</strong>).</li></ul></li><li><p>表示角度:</p><ul><li>句子向量、序列向量.</li></ul></li></ul></li><li><p><strong>循环模块</strong>:</p>  <div align="center"><img src="/pic/98.png" width="100%" height="100%"></div>  <div align="center"><img src="/pic/99.png" width="100%" height="100%"></div>  <div align="center"><img src="/pic/100.png" width="100%" height="100%"></div></li><li><p><strong>循环神经网络的训练</strong>: 与具体任务结合.</p>  <div align="center"><img src="/pic/101.png" width="100%" height="100%"></div></li><li><p><strong>例</strong>: <strong>看图说话</strong>问题</p>  <div align="center"><img src="/pic/102.png" width="100%" height="100%"></div></li><li><p><strong>双向循环神经网络</strong>: 防止<strong>序列前面的内容被后面的内容淹没</strong>.</p>  <div align="center"><img src="/pic/103.png" width="100%" height="100%"></div></li><li><p><strong>序列到序列循环神经网络</strong>: 机器翻译、问答系统.</p>  <div align="center"><img src="/pic/104.png" width="100%" height="100%"></div></li></ul><h2 id="长短期记忆网络-LSTM"><a href="#长短期记忆网络-LSTM" class="headerlink" title="长短期记忆网络 (LSTM)"></a>长短期记忆网络 (LSTM)</h2><ul><li><p>简单 <strong>RNN</strong> 存在的问题:</p><ul><li><strong>长期依赖问题</strong>.</li><li><strong>重点选择问题</strong>: 不同的任务词的重要性不同.</li></ul></li><li><p><strong>LSTM</strong> 模块:</p>  <div align="center"><img src="/pic/105.png" width="100%" height="100%"></div>  <div align="center"><img src="/pic/106.png" width="100%" height="100%"></div><p>  通过<strong>状态</strong>解决<strong>梯度消失问题</strong>; 通过<strong>“门”</strong>进行<strong>选择</strong>, 结构一样, 参数不同.</p><p>  同简单 <strong>RNN</strong> 一样, <strong>LSTM</strong> 模块也是<strong>共用</strong>的.</p></li><li><p><strong>LSTM</strong> 具体结构:</p>  <div align="center"><img src="/pic/107.png" width="100%" height="100%"></div>  <div align="center"><img src="/pic/108.png" width="100%" height="100%"></div>  <div align="center"><img src="/pic/109.png" width="100%" height="100%"></div>  <div align="center"><img src="/pic/110.png" width="100%" height="100%"></div>  <div align="center"><img src="/pic/111.png" width="100%" height="100%"></div>  <div align="center"><img src="/pic/112.png" width="100%" height="100%"></div></li></ul>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;第二章-神经网络和深度学习&quot;&gt;&lt;a href=&quot;#第二章-神经网络和深度学习&quot; class=&quot;headerlink&quot; title=&quot;第二章 神经网络和深度学习&quot;&gt;&lt;/a&gt;第二章 神经网络和深度学习&lt;/h1&gt;&lt;h2 id=&quot;神经网络-——-从数字识别说起&quot;&gt;&lt;a</summary>
        
      
    
    
    
    <category term="CS" scheme="http://chengsx21.github.io/categories/CS/"/>
    
    <category term="IAI" scheme="http://chengsx21.github.io/categories/CS/IAI/"/>
    
    
    <category term="IAI" scheme="http://chengsx21.github.io/tags/IAI/"/>
    
  </entry>
  
  <entry>
    <title>概率论与数理统计 笔记4</title>
    <link href="http://chengsx21.github.io/2023/04/11/gai-lu-lun-yu-shu-li-tong-ji-bi-ji-4/"/>
    <id>http://chengsx21.github.io/2023/04/11/gai-lu-lun-yu-shu-li-tong-ji-bi-ji-4/</id>
    <published>2023-04-11T09:27:40.000Z</published>
    <updated>2023-09-22T08:17:00.091Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Chap-4-随机变量的数字特征"><a href="#Chap-4-随机变量的数字特征" class="headerlink" title="Chap 4 随机变量的数字特征"></a>Chap 4 随机变量的数字特征</h1><h2 id="期望"><a href="#期望" class="headerlink" title="期望"></a>期望</h2><ul><li><p><strong>定义(期望)</strong> </p><script type="math/tex; mode=display">  E(X)=  \begin{cases}  \sum\limits_{i}x_if(x_i)\\  \int\limits_{-\infty}^{\infty}xf(x)dx\\  \end{cases}</script></li><li><p><strong>注</strong></p><ul><li>存在 $\Leftrightarrow$ 绝对收敛;</li><li><strong>(Lebesque-Stieltjes 积分)</strong>  一般定义: $E(X)=\int\limits_{-\infty}^{\infty}xdF$;</li><li>集中趋势的一种刻画;</li><li>$E((X_1,\cdots,X_n)):=(E(X_1),\cdots,E(X_n))$.</li></ul></li><li><p><strong>性质</strong></p><ul><li><script type="math/tex; mode=display">E(g(X_1,\cdots,X_n))=\begin{cases}\sum\limits_{(x_1,\cdots,x_n)\in\mathbb{R}^n} g(x_1,\cdots,x_n)f(x_1,\cdots,x_n)\\\int\limits_{\mathbb{R}^n} g(x_1,\cdots,x_n)f(x_1,\cdots,x_n)dx_1\cdots dx_n\end{cases}</script></li><li><p><strong>(线性性质)</strong>  $E(aX+bY)=aE(X)+bE(Y)$;</p></li><li><p>若 $X_1,\cdots,X_n$ 独立, 则 $E(X_1\cdots X_n)=E(X_1)\cdots E(X_n)$.</p></li></ul></li></ul><h2 id="分位数"><a href="#分位数" class="headerlink" title="分位数"></a>分位数</h2><ul><li><p><strong>定义(中位数)</strong>  $X$ 连续, 若 $P(X\le m)=\dfrac{1}{2}$, 则称 $m$ 为 $X$ 的中位数.</p></li><li><p><strong>注</strong></p><ul><li>$F(m)=\dfrac{1}{2}$;</li><li>$P(X<m)=\dfrac{1}{2}=p(x>m)$;</m)=\dfrac{1}{2}=p(x></li><li>中位数不一定唯一.</li></ul></li><li><p><strong>定义(中位数)</strong>  若 $P(X<m)\le\dfrac{1}{2}$ 且="" $p(x="">m)\le\dfrac{1}{2}$, 则称 $m$ 为 $X$ 的中位数.</m)\le\dfrac{1}{2}$></p></li><li><p><strong>定义(下侧 $\alpha-$分位数)</strong></p><p>  $\forall\alpha\in(0,1)$, 若 $P(X<a)\le\alpha$ 且="" $p(x="">a)\le 1-\alpha$, 称 $a$ 为 $X$ 的下侧 $\alpha-$分位数.</a)\le\alpha$></p></li><li><p><strong>注</strong></p><ul><li>若 $X$ 连续, 则 $P(X&lt;a)=\alpha$;</li><li>$F^{-1}(\alpha)=\inf\{x\mid F(x)\ge\alpha\}$ 为一个 $\alpha$ 分位数.</li></ul></li><li><p><strong>注</strong></p><ul><li>中位数也是集中趋势的一种刻画;</li><li>众数 (方便定义: $f(x)$ 的最大值点).</li></ul></li></ul><h2 id="方差"><a href="#方差" class="headerlink" title="方差"></a>方差</h2><ul><li><strong>定义(方差与标准差)</strong>  给出定义:<script type="math/tex; mode=display">Var(X):=E((X-E(X))^2)=E(X^2)-E^2(X);\\SD(X):=\sqrt{Var(X)}.</script></li></ul><ul><li><strong>注</strong>  刻画了数据的集中程度.</li><li><strong>性质</strong><ul><li>$Var(c)\equiv 0$;</li><li>$Var(X+c)\equiv Var(x)$;</li><li>$Var(cX)\equiv c^2Var(X)$;</li><li>$Var(X+Y)=Var(X)+Var(Y)+2E((X-E(X))(Y-E(Y)))$.</li></ul></li><li><strong>注</strong>  定义变异系数 $\dfrac{\sigma}{\mu}$.</li></ul><h2 id="协方差与相关系数"><a href="#协方差与相关系数" class="headerlink" title="协方差与相关系数"></a>协方差与相关系数</h2><ul><li><strong>定义(协方差)</strong> <script type="math/tex; mode=display">Cov(X,Y):=E((X-\mu_1)(Y-\mu_2)).</script></li></ul><ul><li><p><strong>注</strong></p><ul><li><p>$Cov(X,X)=Var(X)$;</p></li><li><p>$Cov(X,Y)=Cov(Y,X)$;</p></li><li><p>$Cov(X,Y)=E(XY)-\mu_1\mu_2=E(XY)-E(X)E(Y)$;</p></li><li><p>$Cov(aX_1+bX_2+c,Y)=aCov(X_1,Y)+bCov(X_2,Y)$.</p></li></ul></li><li><p><strong>定义(协方差矩阵)</strong>  对 $\overline{X}=(X_1,\cdots,X_n), \overline{Y}=(Y_1,\cdots,Y_n).$ 我们有协方差矩阵</p><script type="math/tex; mode=display">  \begin{aligned}  Cov(\overline{X},\overline{Y})&=(Cov(\overline{X}_i,\overline{Y}_j))_{n\times n}\\  &=E((\overline{X}-E(\overline{X}))^{T}(\overline{Y}-E(\overline{Y}))).  \end{aligned}</script></li><li><p><strong>注</strong>  方差矩阵: </p><script type="math/tex; mode=display">\begin{aligned}Var(\overline{X})&=Cov(\overline{X},\overline{Y})\\&=(Cov(\overline{X}_i,\overline{X}_j))_{n\times n}\\&=(\sigma_{ij})_{n\times n}.\end{aligned}</script></li><li><p><strong>定义(相关系数)</strong></p><script type="math/tex; mode=display">  Corr(X,Y)=\dfrac{Cov(X,Y)}{\sigma_1\sigma_2}=E(\dfrac{X-\mu_1}{\sigma_1}\cdot\dfrac{Y-\mu_2}{\sigma_2}).</script></li><li><p><strong>定理</strong></p><ul><li>若 $X,Y$ 独立, 则 $Corr(X,Y)=0$, 称为 $X,Y$ 不相关.</li><li>联合正态的特殊情况, 不相关可推出独立.</li><li>$\vert Corr(X,Y)\vert\le 1$, 等号成立当且仅当 $\exist\,a,b$ 使得 $P(Y=aX+b)=1$.</li></ul></li><li><p><strong>证明</strong>  给出引理 <strong>Schwartz 不等式</strong>: </p><script type="math/tex; mode=display">E^2(UV)\le E(U^2)E(V^2).</script><p>取等当且仅当 $\exist\,c\in\mathbb{R}$ 使得 $U=cV$. 取 $U=\dfrac{X-\mu_1}{\sigma_1},V=\dfrac{Y-\mu_2}{\sigma_2}$.</p></li><li><p><strong>注</strong></p><ul><li>$\rho:=Corr(X,Y)=\pm 1$, 则 $a=\pm\dfrac{\sigma_2}{\sigma_1}$;</li><li><p>$\rho:=Corr(X,Y)=0$ (不相关) $\not\Rightarrow$ 独立;</p><p>如 $X\sim N(0,1)$, $Y=X^2$ 不相关但是不独立.</p></li><li>相关系数为线性相关系数.</li></ul></li><li><p><strong>例</strong>  $(X_1,X_2)\sim N(\mu_1,\mu_2,\sigma_1^2,\sigma_2^2,\rho)$, 则</p><script type="math/tex; mode=display">\rho=Corr(X_1,X_2).</script></li></ul><h2 id="矩"><a href="#矩" class="headerlink" title="矩"></a>矩</h2><ul><li><p><strong>定义(矩)</strong>  称</p><script type="math/tex; mode=display">  E((X-c)^k)(k=1,2,\cdots)</script><p>  为 $X$ 关于 $c$ 点的 $k$ 阶矩. 特别地, $c=0$ 对应原点矩, $c=\mu$ 对应中心矩.</p></li><li><p><strong>注</strong></p><ul><li>$E(X)=$ 1 阶原点矩, 0 $\equiv$ 1 阶中心矩;</li><li>$Var(X)=$ 2 阶中心矩;</li></ul></li><li><p><strong>定义(偏度系数)</strong></p><script type="math/tex; mode=display">  Skew(X)=\dfrac{E((X-\mu)^3)}{\sigma^3}=E\left(\left(\dfrac{X-\mu}{\sigma}\right)^3\right).</script><p>  称为 3 阶标准矩.</p></li><li><p><strong>注</strong></p><ul><li>0 $\equiv$ 1 阶标准矩, 1 $\equiv$ 2 阶标准矩.</li><li>$Skew(X)&lt;0$ 表示负偏, $Skew(X)&gt;0$ 表示正偏, 刻画非对称程度;</li><li>相比于 5 阶及以上的奇数阶矩, 3 阶矩的计算相对简单, 噪声影响较小;</li><li>不是唯一的刻画偏度的特征数.</li></ul></li><li><p><strong>定义(峰度系数)</strong></p><script type="math/tex; mode=display">  Kurt(X)=\dfrac{E((X-\mu)^4)}{\sigma^4}=E\left(\left(\dfrac{X-\mu}{\sigma}\right)^4\right).</script><p>  称为 4 阶标准矩.</p></li><li><p><strong>注</strong></p><ul><li>正态分布的峰度 $\equiv$ 3, 超额峰度 $:=Kurt(X)-3$;</li><li>$Kurt(X)&gt;3\leftrightarrow$ 尖峰厚尾;</li><li>没有一个数字特征能完美刻画尾部形.</li></ul></li></ul><h2 id="矩母函数"><a href="#矩母函数" class="headerlink" title="矩母函数"></a>矩母函数</h2><ul><li><p><strong>定义(矩母函数)</strong></p><p>若 $M_X(t)=E(e^{tX})$ 在 $t=0$ 的某个邻域内存在, 则称 $M_X(t)$ 为 $X$ 的矩母函数. 否则称 $X$ 的矩母函数 <strong>MGF</strong> 不存在.</p></li><li><p><strong>例</strong>  $X\sim Exp(\lambda)$.</p></li><li><p><strong>解答</strong></p><script type="math/tex; mode=display">\begin{aligned}M_X(t)&=E(e^{tX})\\&=\int_{0}^{\infty}e^{tx}\lambda e^{-\lambda x}dx\\&=\dfrac{\lambda}{\lambda - t},\,t<\lambda.\end{aligned}</script></li><li><p><strong>例</strong>  $X\sim N(0,1)$.</p></li><li><p><strong>解答</strong></p><script type="math/tex; mode=display">\begin{aligned}M_X(t)&=E(e^{tX})\\&=\dfrac{1}{\sqrt{2\pi}}\int_{0}^{\infty}e^{tx}e^{-\tfrac{1}{2}x^2}dx\\&=e^{\tfrac{t^2}{2}},\,t\in\mathbb{R}.\end{aligned}</script></li><li><p><strong>性质</strong></p><ul><li>$M_X(0)\equiv 1$;</li><li>$Y=aX+b$, 则 $M_Y(t)=E(e^{t(aX+b)})=e^{tb}M_X(at)$.</li></ul></li><li><p><strong>例</strong>  $Y\sim N(\mu,\sigma^2)$.</p></li><li><p><strong>解答</strong></p><script type="math/tex; mode=display">\begin{aligned}M_Y(t)&=e^{t\mu}M_X(\sigma t)\\&=e^{\tfrac{\sigma^2t^2}{2}+\mu t},\,t\in\mathbb{R}.\end{aligned}</script></li><li><p><strong>性质(矩母函数确定矩)</strong></p><script type="math/tex; mode=display">E(X^n)=M_X^{(n)}(0).</script></li><li><p><strong>证明</strong></p><script type="math/tex; mode=display">  \begin{aligned}  M_X^{(n)}(t)&=\sum_{n=0}^{\infty}\dfrac{M_X^{(n)}(0)}{n!}t^n.  \end{aligned}</script><p>  又因为</p><script type="math/tex; mode=display">  \begin{aligned}  M_X(t)&=E(e^{tX})\\  &=E\left(\sum_{n=0}^{\infty}\dfrac{X^n}{n!}t^n\right)\\  &=\sum_{n=0}^{\infty}\dfrac{E(X^n)}{n!}t^n.\\  \end{aligned}</script><p>  比较系数即得.</p></li><li><p><strong>例</strong>  $X\sim N(0,1)$.</p></li><li><p><strong>解答</strong></p><script type="math/tex; mode=display">\begin{aligned}M_X(t)&=E(e^{tX})\\&=e^{\tfrac{t^2}{2}},\,t\in\mathbb{R}\\&=\sum_{n=0}^{\infty}\dfrac{(\tfrac{t^2}{2})^n}{n!}\\&=\sum_{n=0}^{\infty}\dfrac{(2n)!}{2^nn!}\cdot\dfrac{t^{2n}}{(2n)!}\end{aligned}</script><p>可得</p><script type="math/tex; mode=display">\begin{cases}E(X^{2n+1})\equiv 0,\\E(X^{2n})=\dfrac{(2n)!}{2^nn!}.\end{cases}</script></li><li><p><strong>性质(矩母函数确定分布)</strong></p><p>若 $\exists$ $a&gt;0$, 使得 $M_X(t)=M_Y(t)$, $\forall\,t\in(-a,a)$, 则 $X$, $Y$ 同分布.</p></li><li><p><strong>例</strong>  $M_X(t)=\dfrac{1}{4}e^{-t}+\dfrac{1}{2}+\dfrac{1}{8}e^{4t}+\dfrac{1}{8}e^{5t}$.</p></li><li><p><strong>解答</strong>  $X$ 离散, 设 $P(X=k)=p_k$, 我们有</p><script type="math/tex; mode=display">M_X(t)=E(e^{tX})=\sum_ke^{tk}p_k.</script><p>可得分布</p><script type="math/tex; mode=display">P(X=-1)=\dfrac{1}{4};\\P(X=0)=\dfrac{1}{2};\\P(X=4)=\dfrac{1}{8};\\P(X=5)=\dfrac{1}{8}.</script></li><li><p><strong>例</strong>  $f_1(x)=\dfrac{1}{\sqrt{2\pi}x}e^{-\tfrac{(\ln x)^2}{2}}, x&gt;0$, $f_2(x)=f_1(x)+f_1(x)\sin(2\pi\ln x)$.</p></li><li><p><strong>解答</strong>  注意到</p><script type="math/tex; mode=display">\begin{aligned}E(X_2^n)&=E(X_1^n)+\int_{0}^{\infty}x^nf_1(x)\sin(2\pi\ln x)dx\\&=0\,(令 \,y=\ln x-n)\\\end{aligned}</script><p>这是一个同矩不同分布的例子.</p></li><li><p><strong>性质(独立随机变量和的分布)</strong></p><p>若 $X$, $Y$ 独立, 则 $M_{X+Y}(t)=M_X(t)M_Y(t)$.</p></li><li><p><strong>证明</strong>  注意到</p><script type="math/tex; mode=display">  \begin{aligned}  M_{X+Y}(t)&=E(e^{t(X+Y)})\\  &=E(e^{tX}e^{tY})\\  &=E(e^{tX})E(e^{tY})\\  &=M_X(t)M_Y(t).  \end{aligned}</script></li><li><p><strong>例</strong>  $X_1,X_2,\cdots,X_n$ 独立正态, 则 $X_1+X_2+\cdots+X_n$ 正态.</p></li><li><p><strong>解答</strong>  考察 $X_i\sim N(\mu_i,\sigma_i^2)$, 其中 $i=1,2$. 那么</p><script type="math/tex; mode=display">M_{X+Y}(t)=M_X(t)M_Y(t)=e^{\tfrac{1}{2}(\sigma_1^2+\sigma_2^2)+(\mu_1+\mu_2)t}.</script><p>进而得到</p><script type="math/tex; mode=display">X_1+X_2\sim N(\mu_1+\mu_2,\sigma_1^2+\sigma_2^2).</script></li><li><p><strong>注</strong></p><ul><li>若 $N$ 为有限数;</li><li>若 $N$ 为随机变量, 与 $X_i$ 独立.</li></ul></li><li><p><strong>注</strong></p><ul><li><p>$(X_1,X_2,\cdots,X_n)$ 的 <strong>MGF</strong> 为:</p><script type="math/tex; mode=display">M_{(X_1,X_2,\cdots,X_n)}(t_1,t_2,\cdots,t_n)=E(e^{t_1X_1+t_2X_2+\cdots+t_nX_n}).</script></li><li><p>特征函数 </p><script type="math/tex; mode=display">E(e^{itX}), i^2=-1.</script></li></ul></li></ul><h2 id="条件期望"><a href="#条件期望" class="headerlink" title="条件期望"></a>条件期望</h2><ul><li><p><strong>定义(条件期望)</strong></p><script type="math/tex; mode=display">E(Y\mid X\in A)=\begin{cases}\sum\limits_iy_iP(Y=y_i\mid X\in A)\\\int\limits_{-\infty}^{\infty}yf(y\mid X\in A)dy\\\end{cases}</script><script type="math/tex; mode=display">E(Y\mid x)=\begin{cases}\sum\limits_iy_iP(Y=y_i\mid X=x)\\\int\limits_{-\infty}^{\infty}yf_{Y\mid X}(y\mid x)dy\\\end{cases}</script><p>我们称 $E(Y\mid X)$ 为新的随机变量 $h(X)$, 是 $Y$ 对 $X$ 的回归函数.</p></li><li><p><strong>例</strong>  $(X,Y)\sim N(\mu_1,\mu_2,\sigma_1^2,\sigma_2^2,\rho)$, 则 $E(Y\mid X)=\mu_2+\rho\dfrac{\sigma_2}{\sigma_1}(X-\mu_1)$.</p></li><li><p><strong>例</strong>  甲乙两种同类产品, 评价使用寿命为 10 年, 15 年, 市场占有率为 60%, 40%. 随机购买一件产品, 求期望寿命?</p></li><li><p><strong>解答</strong>  为 $10\times 60\%+15\times 40\%=12$ 年.</p><p>若记 $X$ 为产品类型, $Y$ 为产品寿命, 则上式可写成</p><script type="math/tex; mode=display">\begin{aligned}E(Y)&=12\\&=10\times 60\%+15\times 40\%\\&=E(Y\mid X=1)P(X=1)+E(Y\mid X=2)P(X=2)\\&=E[E(Y\mid X)].\end{aligned}</script><p>不同取值分层平均并加权.</p></li><li><p><strong>定义(全期望公式)</strong></p><script type="math/tex; mode=display">  E(Y)=E[E(Y\mid X)].</script></li><li><p><strong>证明</strong>  以连续型为例:</p><script type="math/tex; mode=display">  \begin{aligned}  E(Y\mid x)&=\int_{-\infty}^{\infty}yf_{Y\mid X}(y\mid x)dy\\  &=\int_{-\infty}^{\infty}y\dfrac{f(x,y)}{f_X(x)}dy  \end{aligned}</script><p>  从而有</p><script type="math/tex; mode=display">  \begin{aligned}  E[E(Y\mid X)]&=\int_{-\infty}^{\infty}E(Y\mid x)f_X(x)dx\\  &=\int_{-\infty}^{\infty}\int_{-\infty}^{\infty}yf(x,y)dydx\\  &=E(Y).  \end{aligned}</script></li><li><p><strong>注</strong>  一般地, $E[g(X,Y)]=E[E(g(X,Y)\mid X)]$.</p></li><li><p><strong>定理(均方最优预测)</strong></p><script type="math/tex; mode=display">E[(Y-g(X))^2]\ge E[(Y-h(X))^2]=E[(Y-E(Y\mid X))^2]</script><p>称为均方误差 <strong>MSE</strong> 下的最优预测.</p></li><li><p><strong>证明</strong></p><script type="math/tex; mode=display">  E[(Y-c)^2]\ge E[(Y-E(Y))^2].</script><p>  因此</p><script type="math/tex; mode=display">  E[(Y-g(X))^2\mid X]\ge E[(Y-E(Y\mid X))^2\mid X].</script><p>   两边对 $X$ 取均值, 可得</p><script type="math/tex; mode=display">  E[(Y-g(X))^2]\ge E[(Y-E(Y\mid X))^2].</script></li><li><p><strong>注</strong></p><ul><li><p>$E(Y\mid X)$ 依赖 $(X,Y)$ 的联合分布 (不易获取);</p></li><li><p>转而求最优线性预测:</p><script type="math/tex; mode=display">\min_{a,b}E[(Y-(aX+b))^2]\,(最小二乘法)</script></li></ul></li></ul>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;Chap-4-随机变量的数字特征&quot;&gt;&lt;a href=&quot;#Chap-4-随机变量的数字特征&quot; class=&quot;headerlink&quot; title=&quot;Chap 4 随机变量的数字特征&quot;&gt;&lt;/a&gt;Chap 4 随机变量的数字特征&lt;/h1&gt;&lt;h2 id=&quot;期望&quot;&gt;&lt;a</summary>
        
      
    
    
    
    <category term="Math" scheme="http://chengsx21.github.io/categories/Math/"/>
    
    <category term="Probability Theory" scheme="http://chengsx21.github.io/categories/Math/Probability-Theory/"/>
    
    
    <category term="Probability Theory" scheme="http://chengsx21.github.io/tags/Probability-Theory/"/>
    
  </entry>
  
  <entry>
    <title>概率论与数理统计 笔记3</title>
    <link href="http://chengsx21.github.io/2023/03/24/gai-lu-lun-yu-shu-li-tong-ji-bi-ji-3/"/>
    <id>http://chengsx21.github.io/2023/03/24/gai-lu-lun-yu-shu-li-tong-ji-bi-ji-3/</id>
    <published>2023-03-24T09:27:40.000Z</published>
    <updated>2023-09-22T08:16:58.231Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Chap-3-联合分布"><a href="#Chap-3-联合分布" class="headerlink" title="Chap 3 联合分布"></a>Chap 3 联合分布</h1><h2 id="随机向量"><a href="#随机向量" class="headerlink" title="随机向量"></a>随机向量</h2><ul><li><p><strong>定义(随机向量)</strong>  我们称</p><script type="math/tex; mode=display">(X_1,\cdots,X_n):\Omega\rightarrow\mathbb{R}^n</script><p>为随机向量, 当 $X_i(1\le i\le n)$ 均为随机变量.</p></li><li><p><strong>定义(联合 CDF)</strong></p><script type="math/tex; mode=display">  F(x_1,\cdots,x_n):=F(X_1\le x_1,\cdots,X_n\le x_n),\forall\,(x_1,\cdots,x_n)\in\mathbb{R}^n.</script></li><li><p><strong>注</strong>  若 $X_i:\Omega_i\rightarrow\mathbb{R}$, 需扩充 $\Omega=\Omega_1\times\cdots\Omega_n$.</p></li></ul><h2 id="离散分布"><a href="#离散分布" class="headerlink" title="离散分布"></a>离散分布</h2><ul><li><p><strong>定义(离散型随机向量)</strong> </p><script type="math/tex; mode=display">(X_1,X_2,\cdots,X_n)为离散型\Leftrightarrow X_i(1\le i\le n)为离散型.</script></li><li><p><strong>定义(概率质量函数)(PMF)</strong></p><script type="math/tex; mode=display">  \begin{aligned}  f(x_1,x_2,\cdots,x_n):&=P((X_1,X_2,\cdots,X_n)=(x_1,x_2,\cdots,x_n))\\  &= P(X_1= x_1,X_2=x_2,\cdots,X_n=x_n).  \end{aligned}</script></li></ul><ul><li><p><strong>注</strong>  $\sum\limits_{(x_1,\cdots,x_n)\in\mathbb{R}}f(x_1,\cdots,x_n)\equiv 1$.</p></li><li><p><strong>定义(多项分布)</strong>  若 $B_1, B_2\cdots,B_n$ 为互斥事件, 且 $\sum\limits_{i=1}^{n}B_i=\Omega$. 其发生的概率为 $p_1,\cdots,p_n$, 且 $\sum\limits_{i=1}^{n}p_i\equiv 1$. 满足</p><script type="math/tex; mode=display">P(X_1=k_1,\cdots,X_n=k_n)=\dfrac{N!}{k_1!\cdots k_n!}p_1^{k_1}\cdots p_n^{k_n},\,k_i\ge 0,\,\sum_{i=1}^{n}k_i=N.</script><p>其中 $\dfrac{N!}{k_1!\cdots k_n!}$ 为多项式系数.</p></li></ul><h2 id="连续分布"><a href="#连续分布" class="headerlink" title="连续分布"></a>连续分布</h2><ul><li><p><strong>定义(联合 PDF)</strong>  若存在 $f(x_1,\cdots,x_n)\ge 0$, 使得 $\forall\,Q\subset\mathbb{R}^n$ 可测, 都有</p><script type="math/tex; mode=display">P((X_1,\cdots,X_n)\in Q)=\int_Qf(x_1,\cdots,x_n)dx_1\cdots dx_n</script><p>则称 $(X_1,\cdots,X_n)$ 为连续型, $f$ 为 $(X_1,\cdots,X_n)$ 的概率密度函数 <strong>(PDF)</strong>.</p></li><li><p><strong>注</strong></p><ul><li>$\int_{\mathbb{R}}f\equiv 1$;</li><li>以 $n=2$ 为例, $F(a,b)=\int_{-\infty}^{a}(\int_{-\infty}^{b}f(s,t)dt)ds$;</li><li>$f(a,b)=\dfrac{\partial^2 F}{\partial y\partial x}(a,b),\,a.e$.</li></ul></li><li><p><strong>定义(连续分布)(矩形域)</strong></p><script type="math/tex; mode=display">  f(x,y)=  \begin{cases}  \dfrac{1}{(b-a)(d-c)}, &(x,y)\in(a,b)\times(c,d) \\  0, &otherwise \\  \end{cases}</script></li><li><p><strong>定义(二元正态分布)</strong></p><script type="math/tex; mode=display">  f(x,y)=\dfrac{1}{2\pi\sigma_1\sigma_2}\cdot\dfrac{1}{\sqrt{1-\rho^2}}e^{-\frac{1}{2(1-\rho^2)}[(\frac{x-\mu_1}{\sigma_1})^2+(\frac{y-\mu_2}{\sigma_2})^2-2\rho\frac{x-\mu_1}{\sigma_1}\frac{y-\mu_2}{\sigma_2}]},\\</script><p>  其中 $(x,y)\in\mathbb{R}^2, \vert\rho\vert&lt;1$. </p><p>  上式中 $\exp$ 的指数可视为 $-\dfrac{1}{2}\overline{X}^TW\overline{X}=-\dfrac{1}{2}\overline{AX}^T\overline{AX}$, 其 <strong>Cholesky</strong> 分解为</p><script type="math/tex; mode=display">  \overline{X}=\left(  \begin{matrix}  \dfrac{x-\mu_1}{\sigma_1}\\  \dfrac{y-\mu_2}{\sigma_2}  \end{matrix}\right),  W=\dfrac{1}{1-\rho^2}\left(  \begin{matrix}  1 &-\rho\\  -\rho &1  \end{matrix}\right)\\  \Rightarrow  A=\dfrac{1}{\sqrt{1-\rho^2}}\left(  \begin{matrix}  \pm 1 &\mp\rho\\  0 &\pm\sqrt{1-\rho^2}  \end{matrix}\right).</script></li><li><p><strong>注</strong></p><ul><li>$f(x,y)$ 的等值线图像为椭圆;</li><li>$\rho$ 的意义?</li></ul></li></ul><h2 id="边际分布"><a href="#边际分布" class="headerlink" title="边际分布"></a>边际分布</h2><ul><li><p><strong>定义(边际 CDF)</strong></p><script type="math/tex; mode=display">  F_i(x) := P(X_i\le x) = P(X_i\le x,-\infty<X_j<\infty\,(j\ne i)).</script></li><li><p><strong>连续型</strong></p><p>  $n=2$ 时</p><script type="math/tex; mode=display">  F_X(x)=P(X\le x)=P(X\le x,-\infty<Y<\infty)=\lim_{y\rightarrow\infty}F(x,y).</script><p>  $n=3$ 时</p><script type="math/tex; mode=display">  F_X(x)=P(X\le x,-\infty<Y, Z<\infty)=\lim_{y\rightarrow\infty,z\rightarrow\infty}F(x,y,z).</script><script type="math/tex; mode=display">  F_{X,Y}(x,y)=P(X\le x,Y\le y,-\infty<Z<\infty)=\lim_{z\rightarrow\infty}F(x,y,z).</script></li><li><p><strong>离散型</strong></p><p>$n=2$ 时</p><script type="math/tex; mode=display">F_X(x)=P(X\le x)=\sum\limits_{a\le x}P(X=a)=\sum\limits_{y}\sum\limits_{a\le x}P(X=a,Y=y).</script></li><li><p><strong>例(容斥原理)</strong></p><script type="math/tex; mode=display">  P(X>a,Y>b)=1-F_X(a)-F_Y(b)+F_{X,Y}(a,b).</script></li><li><p><strong>定义(边际 PDF)</strong></p><script type="math/tex; mode=display">  F_X(x) := P(X\le x) = \lim_{y\rightarrow\infty}F(x,y) = \int_{-\infty}^{x}(\int_{-\infty}^{\infty}f(s,t)dt)ds\\</script><p>  $\Rightarrow X$ 的边际 <strong>PDF</strong> 为</p><script type="math/tex; mode=display">  f_X(x)=\int_{-\infty}^{\infty}f(x,y)dy.</script></li><li><p><strong>例</strong>  二元正态分布 $N(\mu_1,\mu_2,\sigma_1^2,\sigma_2^2,\rho)$.</p></li><li><p><strong>解答</strong></p><script type="math/tex; mode=display">\begin{aligned}f_X(x)=\int_{-\infty}^{+\infty}f(x,y)dy=\dfrac{1}{\sqrt{2\pi}\sigma_1}e^{-\frac{(x-\mu_1)^2}{2\sigma_1^2}},\,x\in\mathbb{R}.\end{aligned}</script><p>因此 $X\sim N(\mu_1,\sigma_1^2)$. 同理 $Y\sim N(\mu_2,\sigma_2^2)$.</p></li><li><p><strong>注</strong>  联合分布可确定边际分布, 边际分布不可确定联合分布.</p></li></ul><h2 id="条件分布-以-n-2-为例"><a href="#条件分布-以-n-2-为例" class="headerlink" title="条件分布 (以 $n=2$ 为例)"></a>条件分布 (以 $n=2$ 为例)</h2><ul><li><p><strong>定义(离散型条件分布)</strong>  $P(X=a_i,Y=b_j)=p_{ij}\ge 0$, $\sum\limits_{i,j}p_{ij}\equiv 1$.</p><script type="math/tex; mode=display">P(X=a_i\mid Y=b_j)=\dfrac{P(X=a_i,Y=b_j)}{P(Y=b_j)}=\dfrac{p_{ij}}{\sum\limits_{k}p_{kj}}.</script></li><li><p><strong>注</strong>  $\sum\limits_{i}P(X=a_i\mid Y=b_j)\equiv 1$.</p></li><li><p><strong>定义(连续型条件分布)</strong>  $(X,Y)$ 的 <strong>PDF</strong> 为 $f(x,y)$.</p><script type="math/tex; mode=display">\begin{aligned}P(X\le x\mid y\le Y\le y+dy)&=\dfrac{P(X\le x, y\le Y\le y+dy)}{P(y\le Y\le y+dy)}\\&=\dfrac{\int_{-\infty}^{x}(\int_{y}^{y+dy}f(s,t)dt)ds}{\int_{y}^{y+dy}f_Y(t)dt}.\end{aligned}</script></li><li><p><strong>定义(条件密度函数)</strong></p><script type="math/tex; mode=display">  f_{X\mid Y}(x\mid y\le Y\le y+dy)=\dfrac{\int_{y}^{y+dy}f(x,t)dt}{\int_{y}^{y+dy}f_Y(t)dt}.</script><p>  令 $dy\rightarrow 0$, 定义条件密度函数:</p><script type="math/tex; mode=display">  f_{X\mid Y}(x\mid y)=\dfrac{f(x,y)}{f_Y(y)}.</script><p>   条件密度函数 $f_{X\mid Y}(x\mid y)$ 为 <strong>PDF</strong>.</p></li><li><p><strong>注</strong></p><ul><li>$F(a\mid y)=P(X\le a\mid Y=y)=\int_{-\infty}^{a}f_{X\mid Y}(x\mid y)dx$;</li><li><strong>(乘法法则)</strong>  $f(x,y)=f_{X\mid Y}(x\mid y)f_Y(y)$;</li><li><strong>(全概率公式)</strong>  $f_X(x)=\int_{-\infty}^{\infty}f(x,y)dy=\int_{-\infty}^{\infty}f_{X\mid Y}(x\mid y)f_Y(y)dy$;</li><li><strong>(Bayes 公式)</strong>  $f_{Y\mid X}(y\mid x)=\dfrac{f(x,y)}{f_X(x)}=\dfrac{f_{X\mid Y}(x\mid y)f_Y(y)}{\int_{-\infty}^{\infty}f_{X\mid Y}(x\mid y)f_Y(y)dy}$.</li></ul></li><li><p><strong>例</strong>  二元正态分布.</p></li><li><p><strong>解答</strong>  注意到</p><script type="math/tex; mode=display">\begin{aligned}f_{Y\mid X}(y\mid x)&=\dfrac{f(x,y)}{f_X(x)}\\&=\dfrac{1}{\sqrt{2\pi}\sigma_2}\cdot\dfrac{1}{\sqrt{1-\rho^2}}\cdot\exp\{-\dfrac{[y-(\mu_2+\rho\dfrac{\sigma_2}{\sigma_1}(x-\mu_1))]^2}{2(1-\rho^2)\sigma_2^2}\}.\end{aligned}</script><p>即当 $X=x$ 时, $Y\sim N(\mu_2+\rho\dfrac{\sigma_2}{\sigma_1}(x-\mu_1),(1-\rho^2)\sigma_2^2)$.</p></li></ul><h2 id="独立性"><a href="#独立性" class="headerlink" title="独立性"></a>独立性</h2><ul><li><p><strong>定义(独立性)</strong>  $(X,Y)$ 的 <strong>CDF</strong> 为 $F(x,y)$, 边际 <strong>CDF</strong> $F_X(x)$, $F_Y(y)$. 若</p><script type="math/tex; mode=display">F(x,y)=F_X(x)F_Y(y),\,\forall\,x,y\in\mathbb{R}.</script><p>则称 $X,Y$ 相互独立.</p></li><li><p><strong>注</strong>  $X$, $Y$ 独立 $\Leftrightarrow f(x,y)=f_X(x)f_Y(y),\,\forall\,x,y\in\mathbb{R}$, 其中 $f$ 为 <strong>PDF/PMF</strong>.</p></li><li><p><strong>定义</strong>  $X_1,\cdots,X_n$ 相互独立 $\Leftrightarrow F(x_1,\cdots,x_n)=F_1(x_1)\cdots F_n(x_n),\,\forall\,x_1,\cdots,x_n\in\mathbb{R}.$</p></li><li><p><strong>注</strong>  $X_1,\cdots,X_n$ 独立 $\Leftrightarrow f(x_1,\cdots,x_n)=f_1(x_1)\cdots f_n(x_n),\,\forall\,x_1,\cdots,x_n\in\mathbb{R}$, 其中 $f$ 为 <strong>PDF/PMF</strong>.</p></li><li><p><strong>定理</strong></p><ul><li>$f(x_1,\cdots,x_n)=g_1(x_1)\cdots g_n(x_n),\,\forall\,x_1,\cdots,x_n\in\mathbb{R}$, 则 $X_1,\cdots,X_n$ 独立.</li><li>$X_1,\cdots,X_n$ 独立, $Y_1=g_1(X_1,\cdots,X_n), Y_2=g_2(X_1,\cdots,X_n)$, 则 $Y_1$, $Y_2$ 独立.</li></ul></li></ul><h2 id="随机向量的函数"><a href="#随机向量的函数" class="headerlink" title="随机向量的函数"></a>随机向量的函数</h2><ul><li><p><strong>定义</strong>  $Y=g(X_1,\cdots,X_n)$ </p></li><li><p><strong>例</strong>  $X_i\sim B(n_i, p),i=1,2$ 独立, $Y=X_1+X_2$.</p></li><li><p><strong>解答</strong></p><script type="math/tex; mode=display">\begin{aligned}P(Y=k)&=P(X_1+X_2=k)=\sum_{j=0}^{k}P(X=j,X_2=k-j)\\&=\sum_{j=0}^{k}P(X=j)P(X_2=k-j)\\&=\sum_{j=0}^{k}C_{n_1}^{j}C_{n_2}^{k-j}p^k(1-p)^{n_1+n_2-k}\\&=C_{n_1+n_2}^{k}p^k(1-p)^{n_1+n_2-k}.\end{aligned}</script><p>那么有 $Y\sim B(n_1+n_2,p).$</p></li><li><p><strong>例</strong>  $X_1,X_2$ 连续, $X_1&gt;0$, 其联合 <strong>PDF</strong> 为 $f(x_1,x_2)$, 且 $Y=\dfrac{X_2}{X_1}$.</p></li><li><p><strong>解答</strong>  注意到 $\forall\,y&gt;0$,</p><script type="math/tex; mode=display">\begin{aligned}P(Y\le y)&=P(\dfrac{X_2}{X_1}\le y)\\&=P(X_2\le yX_1)\\&=\int_{D}f(x_1,x_2)dx_1dx_2\\&=\int_{0}^{\infty}(\int_{-\infty}^{yx_1}f(x_1,x_2)dx_2)dx_1\\&=\int_{0}^{\infty}(\int_{-\infty}^{y}f(x_1,x_1t)x_1dt)dx_1.\end{aligned}</script><p>故 $Y$ 的 <strong>PDF</strong> 为</p><script type="math/tex; mode=display">l(y)=\int_{0}^{\infty}x_1f(x_1,x_1y)dx_1.</script></li><li><p><strong>定义(密度函数变换法)</strong>  $X_1,X_2$ 的联合 <strong>PDF</strong> 为 $f(x_1,x_2)$, $g_1,g_2$ 可微可逆, 满足</p><script type="math/tex; mode=display">  \begin{cases}  Y_1=g_1(X_1,X_2)\\  Y_2=g_2(X_1,X_2)  \end{cases}\Rightarrow  \begin{cases}  X_1=h_1(Y_1,Y_2)\\  X_2=h_2(Y_1,Y_2)  \end{cases}</script><p>  那么</p><script type="math/tex; mode=display">  \begin{aligned}  P((Y_1,Y_2)\in A)&=P((X_1,X_2)\in B)\\  &=\int_{B}f(x_1,x_2)dx_1dx_2\\  &=\int_{A}f(h_1(y_1,y_2),h_2(y_1,y_2))\vert J\vert dy_1dy_2.  \end{aligned}</script><p>  其中</p><script type="math/tex; mode=display">  J=det\begin{pmatrix}  \dfrac{\partial h_1}{\partial y_1},\dfrac{\partial h_1}{\partial y_2}\\  \dfrac{\partial h_2}{\partial y_1},\dfrac{\partial h_2}{\partial y_2}  \end{pmatrix}</script><p>  故 $Y_1,Y_2$ 的 <strong>PDF</strong> 为</p><script type="math/tex; mode=display">  l(y_1,y_2)=f(h_1(y_1,y_2),h_2(y_1,y_2))\vert J\vert.</script></li><li><p><strong>例</strong>  $X_1,X_2$ 连续, $X_1&gt;0$, 其联合 <strong>PDF</strong> 为 $f(x_1,x_2)$, 且 $Y=X_1+X_2$.</p></li><li><p><strong>解答</strong></p><p>令 $Z=X_1$, 则 $X_1=Z, X_2=Y-Z$. 故 $Y,Z$ 的 <strong>PDF</strong> 为</p><script type="math/tex; mode=display">l(y,z)=f(z,y-z)\vert J\vert=f(z,y-z).</script><p>其中</p><script type="math/tex; mode=display">J=det\begin{pmatrix}0,&1\\1,&-1\end{pmatrix}</script><p>那么 $Y$ 的 <strong>PDF</strong> 为</p><script type="math/tex; mode=display">l_Y(y)=\int_{-\infty}^{\infty}f(z,y-z)dz</script></li><li><p><strong>注</strong></p><ul><li><p>若 $X_1,X_2$ 独立, 则</p><script type="math/tex; mode=display">l_Y(y)=\int_{-\infty}^{\infty}f_1(z)f_2(y-z)dz=f_1*f_2(y).</script></li><li><p>若 $(X_1,X_2)\sim N(\mu_1,\mu_2,\sigma_1^2,\sigma_2^2,\rho)$, 则 </p><script type="math/tex; mode=display">Y=X_1+X_2\sim N(\mu_1+\mu_2,\sigma_1^2+\sigma_2^2+2\rho\sigma_1\sigma_2).</script></li></ul></li><li><p><strong>注</strong>  三大分布: <strong>Chi-Square</strong> 分布 $\chi^2(n)$, $t_n$, $F$.</p></li></ul>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;Chap-3-联合分布&quot;&gt;&lt;a href=&quot;#Chap-3-联合分布&quot; class=&quot;headerlink&quot; title=&quot;Chap 3 联合分布&quot;&gt;&lt;/a&gt;Chap 3 联合分布&lt;/h1&gt;&lt;h2 id=&quot;随机向量&quot;&gt;&lt;a href=&quot;#随机向量&quot;</summary>
        
      
    
    
    
    <category term="Math" scheme="http://chengsx21.github.io/categories/Math/"/>
    
    <category term="Probability Theory" scheme="http://chengsx21.github.io/categories/Math/Probability-Theory/"/>
    
    
    <category term="Probability Theory" scheme="http://chengsx21.github.io/tags/Probability-Theory/"/>
    
  </entry>
  
  <entry>
    <title>人工智能导论 笔记1</title>
    <link href="http://chengsx21.github.io/2023/03/15/ren-gong-zhi-neng-dao-lun-bi-ji-1/"/>
    <id>http://chengsx21.github.io/2023/03/15/ren-gong-zhi-neng-dao-lun-bi-ji-1/</id>
    <published>2023-03-15T01:52:54.000Z</published>
    <updated>2023-09-22T08:14:15.192Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一章-搜索问题"><a href="#第一章-搜索问题" class="headerlink" title="第一章 搜索问题"></a>第一章 搜索问题</h1><h2 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h2><ul><li><p>优先扩展深度深的节点.</p></li><li><p><strong>例</strong>  皇后问题 (<strong>深度优先+回溯</strong>).</p>  <div align="center"><img src="/pic/49.png" width="100%" height="100%"></div></li><li><p>性质:</p><ul><li>一般<strong>不能保证</strong>找到最优解.</li><li>当深度限制不合理时, 可能找不到解, 可以将算法改为<strong>可变深度</strong>限制.</li><li>最坏情况时, 搜索空间等同于<strong>穷举</strong>.</li><li>是一个通用的<strong>与问题无关</strong>的方法.</li><li><strong>节省内存</strong>, 只存储从初始节点到当前节点的路径.</li></ul></li></ul><h2 id="宽度优先搜索"><a href="#宽度优先搜索" class="headerlink" title="宽度优先搜索"></a>宽度优先搜索</h2><ul><li><p>优先扩展深度浅的节点.</p>  <div align="center"><img src="/pic/50.png" width="100%" height="100%"></div></li><li><p>性质:</p><ul><li>当问题有解时, <strong>一定</strong>能找到解.</li><li>当问题为<strong>单位耗散值</strong>, 且问题<strong>有解</strong>时, 一定能找到<strong>最优解</strong>.</li><li>方法与问题无关, 具有<strong>通用性</strong>.</li><li><strong>效率</strong>较低, <strong>存储量</strong>比较大 (带<strong>深度模拟</strong>的<strong>深度优先搜索</strong>).</li></ul></li></ul><h2 id="Dijkstra-算法"><a href="#Dijkstra-算法" class="headerlink" title="Dijkstra 算法"></a>Dijkstra 算法</h2><ul><li><p>宽度优先没有考虑两个节点间的距离.</p>  <div align="center"><img src="/pic/51.png" width="100%" height="100%"></div></li><li><p>优先扩展距离起点最近的节点, 直到终点距离最短.</p>  <div align="center"><img src="/pic/52.png" width="100%" height="100%"></div></li><li><p>优点: 当问题<strong>有解</strong>时, 可以找到<strong>最佳解</strong>.</p></li><li>不足: 只考虑了<strong>节点距离起点</strong>的距离, 没有考虑<strong>节点到终点</strong>的距离.</li></ul><h2 id="启发式图搜索"><a href="#启发式图搜索" class="headerlink" title="启发式图搜索"></a>启发式图搜索</h2><ul><li><p>引入<strong>启发知识</strong>, 保证找到<strong>最佳解</strong>时, 尽可能<strong>减少搜索范围</strong>, 提高<strong>搜索效率</strong>.</p></li><li><p>启发知识: <strong>评估节点到达目标的距离</strong>.</p></li><li><p><strong>启发式搜索算法 A</strong>:</p><ul><li><p>$g^*(n)$: 从 $s$ 到 $n$ 的最短路径的耗散值.</p></li><li><p>$h^*(n)$: 从 $n$ 到 $g$ 的最短路径的耗散值.</p></li><li><p>$f^*(n)=g^*(n)+h^*(n)$: 从 $s$ 经过 $n$ 到 $g$ 的最短路径的耗散值.</p></li><li><p>$g(n)$, $h(n)$, $f(n)$ 分别是 $g^*(n)$, $h^*(n)$, $f^*(n)$ 的<strong>估计值</strong>.</p></li><li><p>用 $f(n)$ 对待扩展节点<strong>进行评价</strong>, 优先扩展 $f(n)$ 值最小的节点, 直到 $f(终点)$ 最小.</p>  <div align="center"><img src="/pic/53.png" width="100%" height="100%"></div></li><li><p>$m_j$: 扩展时<strong>第一次生成</strong>, 父节点标记为 $n$.</p></li><li><p>$m_k$: 已生成<strong>尚未扩展</strong>, 比较 $f(m_k)$, $f(n,m_k)$ 决定是否重标记父节点.</p></li><li><p>$m_l$: 已生成<strong>已扩展</strong>, 比较 $f(m_l)$, $f(n,m_l)$ 决定是否重标记父节点, 并重新扩展.</p>  <div align="center"><img src="/pic/54.png" width="100%" height="100%"></div>  <pre class="line-numbers language-pseudocode" data-language="pseudocode"><code class="language-pseudocode"># A-algorithm(s): s 为初始节点OPEN=(s), CLOSED=(), f(s)=g(s)+h(s);while OPEN 不空 do:    begin        n=FIRST(OPEN);        if GOAL(n) THEN return n;        REMOVE(n, OPEN), ADD(n, CLOSED);        EXPAND(n)→{m_i},      计算 f(n, m_i)=g(n, m_i)+h(m_i);  ADD(m_j, OPEN), 标记 m_j 到 n 的指针;      if f(n, m_k)&lt;f(m_k) then             f(m_k)=f(n, m_k), 标记 m_k 到 n 的指针;      if f(n, m_l)&lt;f(m_l) then             f(m_l)=f(n, m_l), 标记 m_l 到 n 的指针,       ADD(m_l, OPEN);    OPEN 中的节点按 f 值从小到大排序;   end whilereturn FAIL;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>从目标开始, 顺序访问<strong>父节点</strong>, 直到初始节点, 得到<strong>解路径</strong>.</p></li><li><p><strong>例(八数码问题)</strong>  定义 $g(n)$ 为到当前节点的耗散值, $h(n)$ 为当前节点<strong>不在位</strong>的将牌数.</p>  <div align="center"><img src="/pic/55.png" width="100%" height="100%"></div></li></ul></li><li><p><strong>最佳图搜索算法 A*</strong>:</p><ul><li><p>在 <strong>A</strong> 算法中, 如果满足条件:</p><script type="math/tex; mode=display">  h(n)\le h^*(n)</script><p>  则 <strong>A</strong> 算法称为 <strong>A*</strong> 算法.</p></li><li><p><strong>例(八数码问题)</strong>  定义 $h_1(n)$ 为当前节点<strong>不在位</strong>的将牌数, $h_2(n)$ 为当前节点将牌<strong>不在位的距离和</strong>, 注意到这两种定义均满足 <strong>A*</strong> 算法的条件.</p></li><li><p>选取 $h$ 的<strong>一般原则</strong>: 放宽限制条件, 在<strong>宽条件</strong>下给出<strong>估计函数</strong>.</p></li><li><p><strong>定理 1</strong>  若存在从初始节点 $s$ 到目标节点 $t$ 有路径, 则 <strong>A*</strong> 必能找到最佳解结束.</p></li><li><p><strong>定理 2</strong>  对同一问题定义两个 <strong>A*</strong> 算法 <strong>A</strong>$_1$ 和 <strong>A</strong>$_2$, 若 <strong>A</strong>$_2$ 比 <strong>A</strong>$_1$ 有较多的启发信息, 即对所有非目标节点有 $h_2(n)&gt;h_1(n)$, 则在具有一条从 $s$ 到 $t$ 的路径的隐含图上, 搜索结束时由 <strong>A</strong>$_2$ 所扩展的每一个节点, 也必定由 <strong>A</strong>$_1$ 所扩展, 即 <strong>A</strong>$_1$ 扩展的节点数 $\ge$ <strong>A</strong>$_2$ 扩展的节点数 (估计更准确).</p><ul><li>上述评价指标是 “<strong>扩展的节点数</strong>”, 同一个节点只计算一次.</li><li>为什么条件不能是 $h_2(n)\ge h_1(n)$? 什么情况下会出现问题? 能否给定理再增加条件, 使得定理在 $h_2(n)\ge h_1(n)$ 条件下也成立?</li><li><strong>提示</strong>: 考虑那些 $f(n)=f^*(t)$ 的节点, $t$ 为目标节点. 如果不考虑这样的节点, 等号可以加上.</li></ul></li><li><p>对 $h$ 的<strong>评价方法</strong>: 设共<strong>扩展</strong>了 $d$ <strong>层</strong>节点, 共<strong>搜索</strong>了 $N$ <strong>个</strong>节点, 计算得<strong>平均分叉数</strong> $b^*$.</p><script type="math/tex; mode=display">  N=\dfrac{1-b^{*(d+1)}}{1-b^*}.</script><p>  $b^*$ <strong>越小</strong>, 说明 $h$ <strong>效果越好</strong>. $b^*$ 是较<strong>稳定</strong>的常数, 基本<strong>不随问题规模变化</strong>.</p></li></ul></li><li><p><strong>A* 算法的改进</strong>:</p><ul><li><p>因 <strong>A</strong> 算法对 $m_l$ 类节点可能要<strong>重新放回</strong>到 <strong>OPEN</strong> 表中, 因此可能会导致多次<strong>重复扩展</strong>同一个节点, 导致<strong>搜索效率下降</strong>.</p></li><li><p>扩展未找到<strong>初始节点</strong>到<strong>当前节点</strong>的<strong>最短路径</strong>; 距离<strong>越近</strong>, 估计应<strong>越准</strong>.</p>  <div align="center"><img src="/pic/56.png" width="100%" height="100%"></div></li><li><p><strong>对 $h$ 加以限制</strong>: 第一次扩展节点时, 就找到了从 $s$ 到该节点的最短路径.</p>  <div align="center"><img src="/pic/57.png" width="100%" height="100%"></div><p>  此时称 $h$ 是单调的.</p><ul><li><p><strong>定理</strong>  若 $h(n)$ 是单调的, 则 <strong>A*</strong> 扩展了节点 $n$ 之后, 就已经找到了到达节点 $n$ 的最佳路径. 即当 <strong>A*</strong> 选 $n$ 扩展时, 有 $g(n)=g^*(n)$.</p></li><li><p><strong>定理</strong>  当 $h(n)$ 满足单调条件时, 一定满足 <strong>A*</strong> 条件.</p></li></ul></li><li><p><strong>对算法加以改进</strong>: 避免或减少节点的多次扩展.</p><ul><li><strong>定理</strong>  <strong>OPEN</strong> 表上任以具有 $f(n)&lt;f^*(s)$ 的节点定会被 <strong>A*</strong> 扩展.</li><li><strong>定理</strong>  <strong>A*</strong> 选作扩展的任一节点, 定有 $f(n)\le f^*(s)$.</li><li><p><strong>定理</strong>  当 $h(n)$ 恒等于 0 时, $h$ 为单调的.</p><pre class="line-numbers language-pseudocode" data-language="pseudocode"><code class="language-pseudocode"># Modified-A-algorithm(s): s 为初始节点OPEN=(s), CLOSED=(), f(s)=g(s)+h(s), f_m=0;while OPEN 不空 do：    begin        NEST={n_i|f(n_i)&lt;f_m,ni-&gt;OPEN}      if NEST≠( ) then n=NEST 中 g 最小的节点        else n=FIRST(OPEN), f_m=f(n);        if GOAL(n) THEN return n;        REMOVE(n, OPEN), ADD(n, CLOSED);        EXPAND(n →{mi},      计算 f(n, m_i)=g(n, m_i)+h(m_i);  ADD(m_j, OPEN), 标记 m_j 到 n 的指针;      if f(n, m_k)&lt;f(m_k) then             f(m_k)=f(n, m_k), 标记 m_k 到 n 的指针;      if f(n, m_l)&lt;f(m_l) then             f(m_l)=f(n, m_l), 标记 m_l 到 n 的指针,       ADD(m_l, OPEN);    OPEN 中的节点按 f 值从小到大排序;   end whilereturn FAIL;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><div align="center"><img src="/pic/58.png" width="100%" height="100%"></div></li></ul></li></ul></li></ul><h2 id="其他的搜索算法"><a href="#其他的搜索算法" class="headerlink" title="其他的搜索算法"></a>其他的搜索算法</h2><ul><li><p><strong>局部搜索</strong>算法: <strong>爬山法</strong>.</p></li><li><p><strong>随机搜索</strong>算法.</p></li><li><p><strong>动态规划</strong>算法 (当 $\forall\,n$, 有 $h(n)=0$, <strong>A*</strong> 算法即为动态规划): <strong>viterbi</strong> 算法.</p>  <div align="center"><img src="/pic/59.png" width="100%" height="100%"></div><script type="math/tex; mode=display">  Q(W_{i,j})=\begin{cases}  \min\limits_k(Q(W_{i-1,k})+D(W_{i-1,k},W_{i,j})),&i\ne 0\\  0,&i=0.  \end{cases}</script></li></ul><h2 id="搜索算法实用举例"><a href="#搜索算法实用举例" class="headerlink" title="搜索算法实用举例"></a>搜索算法实用举例</h2><ul><li><p><strong>拼音输入法</strong>:</p><script type="math/tex; mode=display">  P(S)=\prod_{i=1}^{n}P(w_i\mid w_1\cdots w_{i-1}).</script><p>  二元语法时:</p><script type="math/tex; mode=display">  P(S)=\prod_{i=1}^{n}P(w_i\mid w_{i-1}).</script><p>  需要求</p><script type="math/tex; mode=display">  \min\Big(-\sum_{i=1}^{n}\log\big(P(w_i\mid w_{i-1})\big)\Big)</script><p>  对应的句子.</p>  <div align="center"><img src="/pic/60.png" width="100%" height="100%"></div></li></ul>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;第一章-搜索问题&quot;&gt;&lt;a href=&quot;#第一章-搜索问题&quot; class=&quot;headerlink&quot; title=&quot;第一章 搜索问题&quot;&gt;&lt;/a&gt;第一章 搜索问题&lt;/h1&gt;&lt;h2 id=&quot;深度优先搜索&quot;&gt;&lt;a href=&quot;#深度优先搜索&quot;</summary>
        
      
    
    
    
    <category term="CS" scheme="http://chengsx21.github.io/categories/CS/"/>
    
    <category term="IAI" scheme="http://chengsx21.github.io/categories/CS/IAI/"/>
    
    
    <category term="IAI" scheme="http://chengsx21.github.io/tags/IAI/"/>
    
  </entry>
  
  <entry>
    <title>概率论与数理统计 笔记2</title>
    <link href="http://chengsx21.github.io/2023/03/08/gai-lu-lun-yu-shu-li-tong-ji-bi-ji-2/"/>
    <id>http://chengsx21.github.io/2023/03/08/gai-lu-lun-yu-shu-li-tong-ji-bi-ji-2/</id>
    <published>2023-03-08T09:27:40.000Z</published>
    <updated>2023-09-22T08:16:56.446Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Chap-2-随机变量"><a href="#Chap-2-随机变量" class="headerlink" title="Chap 2 随机变量"></a>Chap 2 随机变量</h1><h2 id="1-维随机变量"><a href="#1-维随机变量" class="headerlink" title="1 维随机变量"></a>1 维随机变量</h2><ul><li><p><strong>定义(随机变量)</strong>  样本空间上的实值函数.</p><script type="math/tex; mode=display">X: \Omega\rightarrow\mathbb{R},\,\omega\rightarrow X(\omega).</script></li><li><p><strong>例</strong></p></li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">试验</th><th style="text-align:center">样本空间</th><th style="text-align:center">随机变量</th><th style="text-align:center">像集 (新样本空间)</th></tr></thead><tbody><tr><td style="text-align:center">随机调查 $50$ 人对某议题支持与否</td><td style="text-align:center">$\{(1, 0, \cdots), \cdots\}$</td><td style="text-align:center">$X_1= 1$ 的个数</td><td style="text-align:center">$\{0, 1, 2, \cdots, 50\}$</td></tr><tr><td style="text-align:center">随机抽取一个北京市成年公民</td><td style="text-align:center">所有北京市成年公民之集</td><td style="text-align:center">$X_2=$ 其 $2022$ 年的收入</td><td style="text-align:center">$(-\infty, +\infty)$</td></tr></tbody></table></div><ul><li><p><strong>定义(事件)</strong>  $X_1 = 30$, $X_2&gt;100,000$.</p></li><li><p><strong>注</strong></p><ul><li>概括作用: 提供了试验结果的数值摘要;</li><li>事件 <strong>v.s.</strong> 变量, 静态 <strong>v.s.</strong> 动态.</li></ul></li><li><p><strong>分类</strong></p><ul><li>离散型: 至多可数个取值;</li><li>连续型: 区间型取值 (定义不严格);</li><li>其他.</li></ul></li><li><p><strong>定义</strong>  $\forall I\subset\mathbb{R}$, 令 $X^{-1}(I)$ 表示 $I$ 在 $X$ 下的原像集, $X^{-1}(I)\subset\Omega$, 例如</p><script type="math/tex; mode=display">X^{-1}((a, b)) = \{\omega\in\Omega\mid a<X(\omega)<b\}.</script></li><li><p><strong>定义</strong> </p><script type="math/tex; mode=display">  P_{X}(X\in I) = P(X^{-1}(I)), \,\forall I\subset\mathbb{R}\,可测.</script><p>  需要 $X^{-1}(I)\in\mathscr{F}$, 一般记 $P_X$ 为 $P$.</p></li><li><p><strong>定义(累积分布函数)(CDF)</strong> </p><script type="math/tex; mode=display">  F(x) := P(X\le x), \,\forall x\in\mathbb{R}.</script><p>  我们有</p><script type="math/tex; mode=display">  P(a<X\le b)=F(b)-F(a).</script></li><li><p><strong>性质</strong></p><ul><li>$0\le F(x)\le 1$, 单调增(未必严格);</li><li>$\lim\limits_{x\rightarrow+\infty}F(x) = 1$, $\lim\limits_{x\rightarrow-\infty}F(x) = 0$;</li><li>右连续 ($PS.$ 若定义 $F(x) := P(X&lt;x)$, $\forall x\in\mathbb{R}$, 则有 $F(x)$ 左连续).</li></ul></li><li><p><strong>注</strong></p><ul><li><p>随机要素体现在样本点 $\omega$ 的不确定性;</p></li><li><p>随机变量的直观意义往往出现在样本空间的直观意义之前;</p></li></ul></li></ul><ul><li><p><strong>辨析</strong> </p><script type="math/tex; mode=display">  X_i=  \begin{cases}  1,\,第i次抛硬币正面向上; \\  0,\,第i次抛硬币正面向下. \\  \end{cases}</script><p>  其中 $i=1, 2$. 那么 $X_1 + X_2$ 的样本空间为</p><script type="math/tex; mode=display">  \{正正, 正反, 反正, 反反\}.</script><p>  因为随机变量可视作函数, 需要满足定义域相同, 因此 $X_1$, $X_2$ 的定义域同上.</p></li><li><p><strong>注</strong></p><ul><li>$aX+bY$, $XY$, $\dfrac{X}{Y}(Y\ne 0)$, $g(X,Y)$ 为随机变量, 其中 $X$, $Y$ 样本空间相同;</li><li>需要有 $X^{-1}(I)\in\mathscr{F}$, 从而 $P(X^{-1}(I))$ 有意义.</li></ul></li><li><p><strong>定义(同分布)</strong>  $X_1, X_2$ 的 <strong>CDF</strong> 分别为 $F_1(x), F_2(x)$, 那么</p><script type="math/tex; mode=display">  X_1, X_2 同分布\Leftrightarrow P(X_1^{-1}(I)) = P(X_2^{-1}(I)),\forall\,I\subset\mathbb{R}\,可测\\  \Leftrightarrow F_1(x) = F_2(x),\,\forall\,x\in\mathbb{R}.</script></li><li><p><strong>注</strong></p><ul><li>$X_1, X_2$ 同分布 $\nRightarrow X_1 = X_2$.</li><li>考虑掷一次硬币,  $X_1=$ 正面向上的次数, $X_2=$ 反面向上的次数, 这两个随机变量是同分布的.</li><li>随机变量是函数!</li></ul></li></ul><h2 id="离散型随机变量"><a href="#离散型随机变量" class="headerlink" title="离散型随机变量"></a>离散型随机变量</h2><ul><li><p><strong>定义(概率质量函数)(PMF)</strong> </p><script type="math/tex; mode=display">f(x) = P(X = x),\,\forall\,x\in\,\mathbb{R}.</script></li><li><p><strong>注</strong></p><ul><li>$f(x_i)=p_i, \sum\limits_{i}P_i = 1$;</li><li><strong>CDF</strong> 为阶梯函数.</li></ul></li><li><p><strong>定义(期望与方差)</strong> </p><script type="math/tex; mode=display">  E(X) = \sum\limits_{i}x_ip_i = \sum\limits_{i}x_if(x_i) = \mu\\  Var(X) = \sum\limits_{i}(x_i-\mu)^2p_i = \sum\limits_{i}(x_i-\mu)^2f(x_i) = \sigma^2</script><p>  我们有</p><script type="math/tex; mode=display">  Var(X) = E((X-E(X))^2) = E(X^2) - E^2(X).</script></li><li><p><strong>注</strong></p><ul><li>算数均值即期望:</li></ul><script type="math/tex; mode=display">\dfrac{1}{n}\sum_{i = 1}^na_i=\dfrac{1}{n}\sum_{i = 1}^nk_ix_i=\sum_{i = 1}^np_ix_i=\mu;</script><ul><li>期望存在 $\Leftrightarrow$ $\sum\limits_{i}\vert x_i\vert p_i&lt;+\infty$;</li><li>$E(g(X)) = \sum\limits_{i}g(x_i)p_i$;</li><li>$E(X), Var(X)$ 为随机变量 $X$ 的分布的特征, 分别刻画了随机变量的集中趋势和分散程度.</li></ul></li></ul><h2 id="常见离散分布"><a href="#常见离散分布" class="headerlink" title="常见离散分布"></a>常见离散分布</h2><ul><li><p><strong>定义(Bernoulli 分布)</strong></p><script type="math/tex; mode=display">X=\begin{cases}1,\,事件成功,\,p \\0,\,事件不成功,\,1-p \\\end{cases}</script><p>记为 $X\sim B(p)$. 我们有</p><script type="math/tex; mode=display">E(X)=p, Var(X)=p(1-p).</script></li><li><p><strong>定义(二项分布)</strong></p><p>  记 $X$ 为 $n$ 次独立 <strong>Bernoulli</strong> 试验的成功次数. 满足</p><script type="math/tex; mode=display">  P(X=k)=C_n^kp^k(1-p)^{n-k},\,k=0,1,\cdots,n.</script><p>  记为 $X\sim B(n,p)$. 我们有</p><script type="math/tex; mode=display">  E(X)=np, Var(X)=np(1-p).</script></li><li><p><strong>定义(Poisson 分布)</strong></p><p>  满足</p><script type="math/tex; mode=display">  P(X=k)=\dfrac{\lambda^k}{k!}e^{-\lambda},\,k=0,1,2,\cdots.</script><p>  记为 $X\sim P(\lambda)$. 我们有</p><script type="math/tex; mode=display">  E(X)=\lambda, Var(X)=\lambda.</script></li><li><p><strong>例</strong>  观察时间 $[0,1)$ 某路口发生的交通事故数 $X$.</p><ul><li><p>$l_i=[\dfrac{i-1}{n},\dfrac{i}{n}), i=1,2,\cdots,n$.</p></li><li><p>$n$ 充分大.</p></li><li><p>假设:</p><ul><li>$l_i$ 上至多发生一起事故;</li><li>$l_i$ 上恰发生一次事故的概率 $p=\dfrac{\lambda}{n}$, 与时长成正比;</li><li>$l_i$ 各段相互独立.</li></ul></li><li><p>此时</p><script type="math/tex; mode=display">  \begin{aligned}  P(X=k)&=C_n^kp^k(1-p)^{n-k}\\  &=\dfrac{n!}{k!(n-k)!}(\dfrac{\lambda}{n})^k(1-\dfrac{\lambda}{n})^{n-k}\\  &\rightarrow\dfrac{\lambda^k}{k!}e^{-\lambda}, 当\,n\to\infty.  \end{aligned}</script></li></ul></li><li><p><strong>注</strong></p><ul><li>若 $X\sim B(n,p)$, $p$ 很小, $n$ 很大, $np$ 不太大, 则 $X\sim P(\lambda)$, $\lambda=np$.</li><li>误差最多为 $\min(p,np^2)$.</li><li><strong>Poisson</strong> 分布多用于一定时间或空间内小概率事件发生次数的场景.</li></ul></li><li><p><strong>例</strong>  某医院平均每小时出生婴儿 $\lambda$ 名, 接下来 $t$ 小时出生婴儿数的分布.</p></li><li><p><strong>解答</strong>  我们有</p><script type="math/tex; mode=display">P(N(t)=k)=\dfrac{(\lambda t)^k}{k!}e^{-\lambda t},\,k=0,1,2,\cdots.</script><p>其中 $\lambda$ 为均值.</p></li><li><p><strong>注</strong>  <strong>Bernoulli</strong> 试验不独立, 但弱相依条件下仍为较好近似.</p></li><li><p><strong>例(配对问题)</strong></p></li><li><p><strong>解答</strong>  弱相依条件下:</p><script type="math/tex; mode=display">P(A_i)=\dfrac{1}{n}\simeq P(A_i\mid A_j)=\dfrac{1}{n-1}</script><p>恰有 $k$ 个人拿到自己的帽子的概率:</p><script type="math/tex; mode=display">P(X=k)=\dfrac{\lambda^k}{k!}e^{-\lambda}=\dfrac{e^{-1}}{k!}</script></li><li><p><strong>常规解答</strong></p><p>  设 $E=$ 指定的 $k$ 个人拿到了自己的帽子.</p><p>  设 $F=$ 其余的 $n-k$ 个人未拿到自己的帽子.</p><p>  我们有:</p><script type="math/tex; mode=display">  P(EF)=P(F\mid E)P(E)=P_{n-k}\dfrac{(n-k)!}{n!}</script><p>  进而有:</p><script type="math/tex; mode=display">  P(X=k)=C_n^kP(EF)=\dfrac{1}{k!}P_{n-k}\rightarrow\dfrac{e^{-1}}{k!}.</script></li></ul><h2 id="连续随机变量"><a href="#连续随机变量" class="headerlink" title="连续随机变量"></a>连续随机变量</h2><ul><li><p><strong>定义(概率密度函数)(PDF)</strong>  若存在 $f\ge 0$, 使得 $\forall I\subset\mathbb{R}$ 可测, 都有</p><script type="math/tex; mode=display">P(X\in I)=\int_If(x)dx</script><p>则称 $X$ 为连续型随机变量, $f$ 为 $X$ 的概率密度函数 <strong>(PDF)</strong>.</p></li><li><p><strong>性质</strong></p><ul><li>$\int_{-\infty}^{\infty}f(x)dx\equiv 1$;</li><li>$P(a&lt;X\le b)=\int_a^bf(x)dx=P(a\le X\le b)=P(a\le X&lt;b)=P(a&lt;X&lt;b)$;</li><li>$P(X=a)=0,\forall a\in\mathbb{R}$;</li><li>$P(x_0-\delta&lt;X\le x_0+\delta)=\int_{x_0-\delta}^{x_0+\delta}f(x)dx=2\delta f(x_0)$, 要求 $f$ 在 $x_0$ 处连续;</li><li>$F(x)=P(X\le x)=\int_{-\infty}^xf(t)dt$ 连续, $F’(x)=f(x)$ ($f$ 在 $x$ 处连续);</li><li><strong>PDF</strong> 与 <strong>PMF</strong> 实质上可以统一; <strong>PDF</strong> 若存在, 则不唯一.</li></ul></li><li><p><strong>定义(期望与方差)</strong></p><script type="math/tex; mode=display">  E(X) = \int_{-\infty}^{\infty}xf(x)dx = \mu\\  Var(X) = \int_{-\infty}^{\infty}(x-\mu)^2f(x)dx = \sigma^2</script><p>  我们有</p><script type="math/tex; mode=display">  Var(X) = E((X-E(X))^2) = E(X^2) - E^2(X).</script></li><li><p><strong>约定</strong>  $E(X)$ 存在 $\Leftrightarrow$ $E(X)&lt;\infty$.</p></li><li><p><strong>注</strong></p><ul><li>$E(X)$ 存在 $\Leftrightarrow$ $\int\limits_{-\infty}^{\infty}\vert x\vert f(x)dx&lt;\infty$;</li><li>一般地, $E(g(X))=\int\limits_{-\infty}^{\infty}g(x)f(x)dx$.</li></ul></li></ul><h2 id="常见连续分布"><a href="#常见连续分布" class="headerlink" title="常见连续分布"></a>常见连续分布</h2><ul><li><p><strong>定义(连续分布)</strong></p><script type="math/tex; mode=display">f(x)=\begin{cases}\dfrac{1}{b-a},\,a<x<b \\0,\,其他情况 \\\end{cases}</script><p>记为 $X\sim U(a,b)$. 我们有</p><script type="math/tex; mode=display">E(X)=\dfrac{a+b}{2}, Var(X)=?.</script></li><li><p><strong>注</strong>  $X\sim U(0,1)$ 称为随机数.</p></li><li><p><strong>定义(正态分布)</strong></p><script type="math/tex; mode=display">  f(x)=\dfrac{1}{\sqrt{2\pi}\sigma}e^{-\dfrac{(x-\mu)^2}{2\sigma^2}},\,x\in\mathbb{R}.</script><p>  记为 $X\sim N(\mu,\sigma^2)$. 我们有</p><script type="math/tex; mode=display">  E(X)=\mu, Var(X)=\sigma^2.</script></li><li><p><strong>注</strong></p><ul><li>$X\sim N(\mu,\sigma^2)\Leftrightarrow Y=\dfrac{X-\mu}{\sigma}\sim N(0,1)$;</li><li>$N(0,1)$ 标准正态;</li><li>经验法则.</li></ul></li><li><p><strong>定义(指数分布)</strong></p><script type="math/tex; mode=display">  f(x)=  \begin{cases}  \lambda e^{-\lambda x},\,x>0 \\  0,\,x\le 0 \\  \end{cases}</script><p>  记为 $X\sim Exp(\lambda)$. 我们有</p><script type="math/tex; mode=display">  E(X)=\dfrac{1}{\lambda}, Var(X)=\dfrac{1}{\lambda^2}.</script></li><li><p><strong>注</strong></p><ul><li>有的软件取参数为 $\beta=\dfrac{1}{\lambda}$;</li><li>通常刻画寿命或等待时间.</li></ul></li><li><p><strong>例</strong>  观察到有婴儿出生, 接下来 $t$ 小时有婴儿出生的概率为?</p></li><li><p><strong>解答</strong></p><script type="math/tex; mode=display">\begin{aligned}P(X\le t)&=1-P(X>t)\\&=1-P(N(t)=0)\\&=1-\dfrac{(\lambda t)^0}{0!}e^{-\lambda t}\\&=1-e^{-\lambda t}.\end{aligned}</script><p>这是一个 <strong>Poisson</strong> 过程, 数量是 <strong>Poisson</strong> 分布, 间隔是指数分布.</p></li><li><p><strong>定义</strong>  假设 $X&gt;0$ 连续, 其 <strong>CDF</strong> 为 $F(x)$, 满足 $F(0)=0$. 考虑</p><script type="math/tex; mode=display">\begin{aligned}&P(x<X<x+dx\mid X>x)\\=&\dfrac{P(x<X<x+dx)}{P(X>x)}\\=&\dfrac{F(x+dx)-F(x)}{1-F(x)}\\\approx&\dfrac{F'(x)}{1-F(x)}dx.\end{aligned}</script><p>视为年龄为 $x$ 的元件失效的条件概率密度 (瞬时失效率/危险率).</p></li><li><p><strong>注</strong></p><ul><li><p>令 $\dfrac{F’(x)}{1-F(x)}=\lambda(x)\Rightarrow F(x)=1-e^{-\int_0^x\lambda(t)dt},x&gt;0$;</p></li><li><p>若 $\lambda(x)\equiv\lambda\,(无老化假设)$, 则 $F(x)=1-e^{-\lambda x}$,</p><p>$\Rightarrow P(X&gt;t+s\mid X&gt;s)=\dfrac{P(X&gt;t+s)}{P(X&gt;s)}=\dfrac{1-F(s+t)}{1-F(s)}=e^{-\lambda t}$  $(无记忆性)$;</p></li><li><p>改进 $\lambda(x)=\alpha\dfrac{x^{\alpha-1}}{\beta^\alpha},\alpha,\beta&gt;0$, 则 $F(x)=1-e^{-(\dfrac{x}{\beta})^{\alpha}}\Rightarrow$ <strong>Weibull</strong> 分布.</p></li></ul></li></ul><h2 id="随机变量的函数"><a href="#随机变量的函数" class="headerlink" title="随机变量的函数"></a>随机变量的函数</h2><ul><li><p><strong>定义</strong>  $Y=g(X)$ </p></li><li><p><strong>例</strong>  $X\sim Exp(\lambda)$.</p></li><li><p><strong>解答</strong></p><script type="math/tex; mode=display">Y=\begin{cases}1,\,x>t_0 \\0,\,x\le t_0 \\\end{cases}    \quad t_0>0\,给定.</script><p>那么有 $P(Y=0)=1-e^{-\lambda t_0}$, $P(Y=1)=e^{-\lambda t_0}$.</p></li><li><p><strong>例</strong>  $X$ 连续, 其 <strong>PDF</strong> 为 $f(x)$, 且 $Y=X^2$.</p></li><li><p><strong>解答</strong>   $\forall y&gt;0$, 我们有</p><script type="math/tex; mode=display">\begin{aligned}P(Y\le y)&=P(X^2\le y)\\&=P(-\sqrt{y}\le X\le\sqrt{y})\\&=\int_{-\sqrt{y}}^{\sqrt{y}}f(x)dx\\&=\int_0^yl(t)dt.\end{aligned}</script><p>其中 $Y$  的 <strong>PDF</strong> 为 $l(y)=\dfrac{1}{2\sqrt{y}}(f(\sqrt{y})+f(-\sqrt{y}))$.</p></li><li><p><strong>例</strong>  $X\sim N(0,1)$, 且 $Y=X^2$.</p></li><li><p><strong>解答</strong>  $Y$  的 <strong>PDF</strong> 为</p><script type="math/tex; mode=display">l(y)=\dfrac{1}{\sqrt{2\pi}}\dfrac{1}{\sqrt{y}}e^{-\dfrac{y}{2}}</script><p>这是自由度为 $1$ 的 <strong>Chi-Square</strong> 分布 $\chi^2(1)$.</p></li></ul>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;Chap-2-随机变量&quot;&gt;&lt;a href=&quot;#Chap-2-随机变量&quot; class=&quot;headerlink&quot; title=&quot;Chap 2 随机变量&quot;&gt;&lt;/a&gt;Chap 2 随机变量&lt;/h1&gt;&lt;h2 id=&quot;1-维随机变量&quot;&gt;&lt;a href=&quot;#1-维随机变量&quot;</summary>
        
      
    
    
    
    <category term="Math" scheme="http://chengsx21.github.io/categories/Math/"/>
    
    <category term="Probability Theory" scheme="http://chengsx21.github.io/categories/Math/Probability-Theory/"/>
    
    
    <category term="Probability Theory" scheme="http://chengsx21.github.io/tags/Probability-Theory/"/>
    
  </entry>
  
  <entry>
    <title>概率论与数理统计 笔记1</title>
    <link href="http://chengsx21.github.io/2023/02/23/gai-lu-lun-yu-shu-li-tong-ji-bi-ji-1/"/>
    <id>http://chengsx21.github.io/2023/02/23/gai-lu-lun-yu-shu-li-tong-ji-bi-ji-1/</id>
    <published>2023-02-23T09:27:40.000Z</published>
    <updated>2023-09-22T08:16:54.132Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Chap-1-概率"><a href="#Chap-1-概率" class="headerlink" title="Chap 1 概率"></a>Chap 1 概率</h1><h2 id="试验与事件"><a href="#试验与事件" class="headerlink" title="试验与事件"></a>试验与事件</h2><ul><li><p><strong>定义(随机试验)</strong></p><ul><li>不能预先确知结果;</li><li>试验之前可预测所有可能结果.</li></ul></li><li><p><strong>定义(样本空间)</strong>  一个试验所有可能结果之集 $(\Omega)$.</p></li><li><strong>定义(随机事件)</strong>  $a$ $well$ $defined$ $subset$ $A\in\Omega$.<ul><li>全事件 $\Omega$ (必然事件);</li><li>空事件 $\varPhi$ (不可能事件);</li><li>单一试验结果 (基本事件).</li></ul></li></ul><h2 id="事件的运算"><a href="#事件的运算" class="headerlink" title="事件的运算"></a>事件的运算</h2><ul><li><p>借助集合的语言 $or$ $Venn$ 图.</p><ul><li>余: $A^c-(\Omega\backslash A)$;</li><li>和: $A+B-(A\cup B)$;</li><li>差: $A-B-(A\backslash B)$;</li><li>积: $AB-(A\cap B)$;</li><li>互斥: $AB = \varnothing$;</li><li>对立: $AB = \varnothing, A + B = \Omega$;</li><li><strong>De Morgan</strong> 定律: $(A + B)^c = A^cB^c$ $(\sum_n A_n)^c = \prod_n A_n^c$.</li></ul></li></ul><h2 id="概率的几种解释"><a href="#概率的几种解释" class="headerlink" title="概率的几种解释"></a>概率的几种解释</h2><ul><li>古典解释 - 基于等可能性;</li><li>频率解释;</li><li>主观解释.</li></ul><h2 id="公理化定义"><a href="#公理化定义" class="headerlink" title="公理化定义"></a>公理化定义</h2><ul><li><p>$2^{\Omega}\Rightarrow\Omega$ 的所有子集构成的集合.</p></li><li><p>事件集类 $\mathscr{F}\subset\Omega\Rightarrow\sigma{-}$代数: 事件运算的封闭性.</p></li><li><p>特别地, </p><script type="math/tex; mode=display">\sum_{i = 1}^{\infty}A_i\in\mathscr{F}, \forall A_i\in\mathscr{F}.</script></li><li><p><strong>定义(Kolmogorov)</strong></p><script type="math/tex; mode=display">  P: \mathscr{F}\rightarrow\mathbb{R} \\</script><p>  满足以下三条公理:</p><ul><li>$P(A)\ge 0, \forall A\in\mathscr{F}$</li><li>$P(\Omega) = 1$</li><li><p>$P(\sum_{i = 1}^{\infty}A_i) = \sum_{i = 1}^{\infty}P(A_i), A_iA_j = \varnothing, \forall i\ne j$</p><p>则称 $P$ 为概率函数, $(\Omega, \mathscr{F}, P)$ 为概率空间.</p></li></ul></li><li><p><strong>命题</strong></p><ul><li>$P(A)\le1, \forall A\in\mathscr{F}$;</li><li>$P(\varPhi) = 0$;</li><li>$P(A^c) = 1 - P(A)$;</li><li>$P(\sum_{i = 1}^{n}A_i) = \sum_{i = 1}^{n}P(A_i), A_iA_j = \varnothing, \forall i\ne j$;</li><li>$P(A)\le P(B), \forall A\subset B$;</li><li>$P(A + B) = P(A) + P(B) - P(AB)$.</li></ul></li><li><p><strong>推广</strong></p><p>$P(\sum_\limits{i = 1}^{n}A_i) = \sum_\limits{i = 1}^{n}P(A_i) - \sum_\limits{i_1&lt;i_2}P(A_{i_1}A_{i_2}) + \cdots + (-1)^{r - 1}\sum_\limits{i_1 &lt; \cdots &lt; i_r}P(A_{i_1}\cdots A_{i_r}) + \cdots$</p></li><li><p><strong>例</strong>  $n$ 个人, 每人一顶帽子, 随机挑选一顶帽子. 无人拿到自己帽子的概率为? 恰有 $k$ 人拿到自己帽子的概率为?</p></li><li><p><strong>解答</strong>  令 $A_i = $ 第 $i$ 个人拿到自己帽子. 注意到</p><script type="math/tex; mode=display">P(A_i) = \cfrac{1}{n}.</script><p>运用排列组合知识可得</p><script type="math/tex; mode=display">P(A_{i_1}\cdots A_{i_r}) = \cfrac{(n - r)!}{n!},\\\sum_\limits{i_1 < \cdots < i_r}P(A_{i_1}\cdots A_{i_r}) = \cfrac{(n - r)!}{n!}C_n^r = \cfrac{1}{r!}.</script><p>故至少有一个人拿到自己帽子的概率为</p><script type="math/tex; mode=display">\begin{equation*}    \begin{aligned}    P(\sum_\limits{i = 1}^{n}A_i) &= \sum_\limits{r = 1}^{n}(-1)^{r - 1}\sum_\limits{i_1 < \cdots < i_r}P(A_{i_1}\cdots A_{i_r}) \\    &= \sum_\limits{r = 1}^{n}(-1)^{r - 1}\cfrac{1}{r!}.    \end{aligned}\end{equation*}</script><p>无人拿到自己帽子的概率为</p><script type="math/tex; mode=display">\begin{equation*}    \begin{aligned}    P_n &= 1 - P(\sum_\limits{i = 1}^{n}A_i) \\    &= 1 - \sum_\limits{r = 1}^{n}(-1)^{r - 1}\sum_\limits{i_1 < \cdots < i_r}P(A_{i_1}\cdots A_{i_r}) \\    &= \sum_\limits{r = 0}^{n}(-1)^{r}\cfrac{1}{r!} \\    &= \cfrac{1}{e}.    \end{aligned}\end{equation*}</script></li></ul><h2 id="条件概率"><a href="#条件概率" class="headerlink" title="条件概率"></a>条件概率</h2><ul><li><p><strong>定义(条件概率)</strong>  $P(A\mid B) := \cfrac{P(AB)}{P(B)}\,( 需\,P(B) &gt; 0)$.</p></li><li><p>$A\mid B$ 不是事件.</p></li><li><p><strong>计算</strong>  $(1)$ 缩小样本空间; $(2)$ 定义.</p></li><li><p><strong>定义(乘法法则)</strong>  $P(AB) = P(A\mid B)P(B) = P(B\mid A)P(A).$</p></li><li><p><strong>例</strong>  $8$ 个红球, $4$ 个白球, 等可能无放回地取出 $2$ 红球的概率为?</p></li><li><p><strong>解答</strong>  无放回地取出 $2$ 红球的概率为</p><script type="math/tex; mode=display">P(R_1R_2) = P(R_1)P(R_2\mid R_1) = \cfrac{8}{12}\times\cfrac{7}{11} = \cfrac{14}{33}.</script></li><li><p><strong>推广</strong></p><p>$P(A_1A_2\cdots A_n) = P(A_1)P(A_2\mid A_1)P(A_3\mid A_1A_2)\cdots P(A_n\mid A_1A_2\cdots A_{n - 1}).$</p></li><li><p><strong>解答续</strong>  在配对问题中, 注意到</p><script type="math/tex; mode=display">  \begin{equation*}      \begin{aligned}    P(A_{i_1}\cdots A_{i_r}) &= P(A_{i_1})P(A_{i_2}\mid A_{i_1})\cdots P(A_{i_r}\mid A_{i_1}A_{i_2}\cdots A_{i_{r - 1}}) \\    &= \cfrac{1}{n}\cdot\cfrac{1}{n - 1}\cdot\cfrac{1}{n - 2}\cdots\cfrac{1}{n - (r - 1)} \\    &= \cfrac{(n - r)!}{n!}.      \end{aligned}  \end{equation*}</script></li><li><p><strong>定义</strong></p><script type="math/tex; mode=display">  P(\cdot\mid B): \mathscr{F}\rightarrow\mathbb{R}</script><p>  令 $\widetilde{P} = P(\cdot\mid B)$, 则 $\widetilde{P}$ 满足以下三条公理:</p><ul><li>$\widetilde{P}(A)\ge 0, \forall A\in\mathscr{R}$</li><li>$\widetilde{P}(\Omega) = 1$</li><li><p>$\widetilde{P}(\sum_{i = 1}^{\infty}A_i) = \sum_{i = 1}^{\infty}\widetilde{P}(A_i), A_iA_j = \varnothing, \forall i\ne j$</p><p>故 $\widetilde{P}$ 为概率函数, $(\Omega, \mathscr{F}, \widetilde{P})$ 为新概率空间.</p></li></ul></li><li><p><strong>注</strong></p><ul><li>$P(A)\,\textbf{v.s.}\,\widetilde{P}(A) = P(A\mid B)$;</li><li>“已观测到 $A$ 发生, 则 $P(A) = 1$” 这句话是错误的, 因为 $P(A\mid A) = 1$.</li></ul></li></ul><h2 id="独立事件"><a href="#独立事件" class="headerlink" title="独立事件"></a>独立事件</h2><ul><li><p><strong>定义(独立事件)</strong>  若 $P(AB) = P(A)P(B)$, 则称事件 $A, B$ 相互独立.</p></li><li><p><strong>注</strong></p><ul><li>此时 $P(A\mid B) = P(A)$, 即 $\cfrac{P(AB)}{P(B)} = \cfrac{P(A\Omega)}{P(\Omega)}$;</li><li>事件 $B$ 的发生未改变 $A$ 发生的概率;</li><li>从实际角度判断可应用定义中的关系式; 一般利用定义判断独立性.</li></ul></li><li><p><strong>例</strong>  中奖率为 $10^{-5}$ 的彩票每周开奖, 不累积, 一个人购彩十年未中奖的概率为?</p></li><li><p><strong>解答</strong></p><p>每次购彩事件都是独立的.</p><p>设事件 $A_i = $ 第 $i$ 周未中奖, 那么 $P(A_i) = 1 - 10^{-5}$.</p><p>故 $P = P(A_1A_2\cdots A_{520}) = (1 - 10^{-5})^520 = 99.48\%$. </p></li><li><p>事件 $A, B$ 相互独立, 则事件 $A^c, B$ 相互独立.</p></li><li><p><strong>推广</strong></p><ul><li><p>$A, B, C\,相互独立\Leftrightarrow P(ABC) = P(A)P(B)P(C)\,且\,A, B, C\,两两独立$;</p></li><li><p>$A, B, C\,两两独立\nRightarrow A, B, C\,相互独立$</p><p>  (反例) 甲乙两人抛掷 $2$ 枚硬币. $A =$ 甲正, $B =$ 乙正, $C =$ 甲乙同.</p></li></ul></li><li><p><strong>定义(相互独立)</strong></p><p>  $A_1, A_2, \cdots, A_n\,相互独立\Leftrightarrow 任\,m\,个事件\,A_{i_1},\cdots, A_{i_m}, 有 P(A_{i_1}\cdots A_{i_m}) = P(A_{i_1})\cdots P(A_{i_m}).$</p></li><li><p><strong>定义(条件独立)</strong></p><p>  $A, B$ 关于事件 $E$ 条件独立 $\Leftrightarrow P(AB\mid E) = P(A\mid E)P(B\mid E)$.</p></li><li><p><strong>注</strong>  条件独立与独立不可互推.</p></li></ul><h2 id="textbf-Bayes-公式"><a href="#textbf-Bayes-公式" class="headerlink" title="$\textbf{Bayes}$ 公式"></a>$\textbf{Bayes}$ 公式</h2><ul><li><p><strong>定义(全概率公式)</strong>  给出 $\Omega$ 的一个分割</p><ul><li>$\sum_iB_i = \Omega$;</li><li>$B_iB_j = \varnothing, \forall\,i\ne j$;</li><li>$P(B_i) &gt; 0, \forall\,i$.</li></ul><p>则有</p><script type="math/tex; mode=display">P(A) = P(\sum_i(AB_i)) = \sum_iP(AB_i) = \sum_iP(A\mid B_i)P(B_i).</script></li><li><p><strong>定义(Bayes 公式)</strong></p><script type="math/tex; mode=display">  P(B_i\mid A) = \dfrac{P(A\mid B_i)P(B_i)}{\sum_jP(A\mid B_j)P(B_j)}</script><p>  其中 $P(B_i)$ 为先验概率, $P(B_i\mid A)$ 为后验概率.</p></li></ul><ul><li><p><strong>例</strong>  $A =$ 阳性, $B =$ 患病, $P(B) = 10^{-4}$, $P(A\mid B) = 0.99$, $P(A\mid B^c) = 10^{-3}$. 求 $P(B\mid A)$, $P(B\mid A_1A_2)$.</p></li><li><p><strong>解答</strong>  由 <strong>Bayes</strong> 公式, 容易得到</p><script type="math/tex; mode=display">  \begin{equation*}      \begin{aligned}          P(B\mid A)&= \dfrac{P(AB)}{P(A)} \\          &= \dfrac{P(A\mid B)P(B)}{P(A)} \\          &= \dfrac{P(A\mid B)P(B)}{P(A\mid B)P(B) + P(A\mid B^c)P(B^c)} \\          &= 9.01\%.      \end{aligned}  \end{equation*}</script><script type="math/tex; mode=display">  \begin{equation*}      \begin{aligned}          P(B\mid A_1A_2)&= \dfrac{P(A_1A_2B)}{P(A_1A_2)} \\          &= \dfrac{P(A_1A_2\mid B)P(B)}{P(A_1A_2)} \\          &= \dfrac{P(A_1A_2\mid B)P(B)}{P(A_1A_2\mid B)P(B) + P(A_1A_2\mid B^c)P(B^c)} \\          &= \dfrac{P(A\mid B)^2P(B)}{P(A\mid B)^2P(B) + P(A\mid B^c)^2P(B^c)} \\          &= 98.99\%.      \end{aligned}  \end{equation*}</script></li></ul><h2 id="一些讨论"><a href="#一些讨论" class="headerlink" title="一些讨论"></a>一些讨论</h2><ul><li>什么是概率?<ul><li>不确定性的一种度量;</li><li>具有不同的解释;</li><li>公理化定义.</li></ul></li><li>为什么用概率?<ul><li>不确定性的来源<ul><li>被建模系统的内在随机性;</li><li>不完全观测 (<strong>Monty Hall</strong> 中的参与者);</li><li>不完全建模.</li></ul></li><li>很多情况下, 简单而不确定的规则好于复杂而确定的规则</li><li>应用、维护、沟通</li></ul></li><li>怎么用概率?<ul><li>计算正确的概率;</li><li>正确计算概率;</li><li>正确使用概率.</li></ul></li></ul>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;Chap-1-概率&quot;&gt;&lt;a href=&quot;#Chap-1-概率&quot; class=&quot;headerlink&quot; title=&quot;Chap 1 概率&quot;&gt;&lt;/a&gt;Chap 1 概率&lt;/h1&gt;&lt;h2 id=&quot;试验与事件&quot;&gt;&lt;a href=&quot;#试验与事件&quot;</summary>
        
      
    
    
    
    <category term="Math" scheme="http://chengsx21.github.io/categories/Math/"/>
    
    <category term="Probability Theory" scheme="http://chengsx21.github.io/categories/Math/Probability-Theory/"/>
    
    
    <category term="Probability Theory" scheme="http://chengsx21.github.io/tags/Probability-Theory/"/>
    
  </entry>
  
  <entry>
    <title>复变函数</title>
    <link href="http://chengsx21.github.io/2022/12/31/fu-bian-han-shu/"/>
    <id>http://chengsx21.github.io/2022/12/31/fu-bian-han-shu/</id>
    <published>2022-12-31T12:31:59.000Z</published>
    <updated>2023-09-22T06:55:42.451Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-解析函数"><a href="#1-解析函数" class="headerlink" title="1. 解析函数"></a>1. 解析函数</h3><p>$\textbf{Example:}$<br>对于 $x, y\in\mathbb{R}$, 求 $\cos(x + iy)$ 的实, 虚部, 并说明方程</p><script type="math/tex; mode=display">\cos(x + iy) = A + iB\thinspace(A, B\in\mathbb{R})</script><p>有无穷多组解. ◻</p><p>$\textbf{Solution:}$<br>由于 <script type="math/tex">\cos z = \frac{1}{2}\left(e^{iz} + e^{-iz}\right),</script></p><p>得到 <script type="math/tex">\begin{aligned}            \cos(x + iy) &= \frac{1}{2}\left(e^{-y + ix} + e^{y - ix}\right) \\            &= \frac{1}{2}\left[e^{-y}\left(\cos x + i\sin x\right) + e^y\left(\cos x - i\sin x\right)\right] \\            &= \frac{1}{2}\cos x\left(e^y + e^{-y}\right) + \frac{1}{2}\sin x\left(e^{-y} - e^y\right)i.        \end{aligned}</script></p><p>于是 <script type="math/tex">\Re\cos(x + iy) = \frac{1}{2}\cos x\left(e^y + e^{-y}\right),</script></p><script type="math/tex; mode=display">\Im\cos(x + iy) = \frac{1}{2}\sin x\left(e^{-y} - e^y\right).</script><p>考虑方程组 <script type="math/tex">\begin{cases}            \frac{1}{2}\cos x\left(e^y + e^{-y}\right) = A, \\            \frac{1}{2}\sin x\left(e^{-y} - e^y\right) = B.        \end{cases}</script></p><p>$(1)$ 若$B = 0$:</p><p>$(a)$ $A &gt; 1$ 时,</p><p>取 $x = 2k\pi, \thinspace k\in\mathbb{Z}$, 考虑</p><script type="math/tex; mode=display">f(y) = e^y + e^{-y} - 2A.</script><p>因为 <script type="math/tex">f(0) = 2 - 2A < 0, \thinspace f(+\infty) = +\infty,</script></p><p>由介值定理得 <script type="math/tex">\exists\thinspace y_1 > 0, \thinspace f(y_1) = 0.</script></p><p>那么 <script type="math/tex">\begin{cases}            x = 2k\pi, \\            y = y_1,        \end{cases}</script></p><p>为原方程的解, $\forall k\in\mathbb{Z}$.</p><p>$(b)$ $A &lt; -1$ 时,</p><p>取 $x = 2k\pi + \pi, \thinspace k\in\mathbb{Z}$, 考虑</p><script type="math/tex; mode=display">g(y) = e^y + e^{-y} + 2A.</script><p>因为 <script type="math/tex">g(0) = 2 + 2A < 0, \thinspace g(+\infty) = +\infty,</script></p><p>由介值定理得 <script type="math/tex">\exists\thinspace y_2 > 0, \thinspace g(y_2) = 0.</script></p><p>那么 <script type="math/tex">\begin{cases}            x = 2k\pi + \pi, \\            y = y_2,        \end{cases}</script></p><p>为原方程的解, $\forall k\in\mathbb{Z}$.</p><p>$(c)$ $-1\le A\le 1$ 时,</p><p>取 $y = 0$, 考虑 <script type="math/tex">\cos x = A.</script></p><p>那么 <script type="math/tex">\begin{cases}            x = \arccos A + 2k\pi, \\            y = 0,        \end{cases}</script></p><p>为原方程的解, $\forall k\in\mathbb{Z}$.</p><p>$(2)$ 若$B \ne 0$:</p><p>可得</p><script type="math/tex; mode=display">\left(\frac{2A}{e^y + e^{-y}}\right)^2 + \left(\frac{2B}{e^{-y} - e^y}\right)^2 = 1.</script><p>令</p><script type="math/tex; mode=display">h(y) = \left(\frac{2A}{e^y + e^{-y}}\right)^2 + \left(\frac{2B}{e^{-y} - e^y}\right)^2 - 1,</script><p>因为 <script type="math/tex">h(0^{+}) = +\infty, \thinspace h(+\infty) = -1 < 0,</script></p><p>由介值定理得 <script type="math/tex">\exists\thinspace y_{AB} > 0, \thinspace h(y_{AB}) = 0.</script></p><p>那么 <script type="math/tex">\begin{cases}            x = \arccos\cfrac{2A}{e^{y_{AB}} + e^{-y_{AB}}} + 2k\pi, \\            y = y_{AB},        \end{cases}</script></p><p>为原方程的解, $\forall k\in\mathbb{Z}$. ◻</p><h3 id="2-Cauchy高阶导数公式"><a href="#2-Cauchy高阶导数公式" class="headerlink" title="2. Cauchy高阶导数公式"></a>2. Cauchy高阶导数公式</h3><p>$\textbf{Example:}$<br>$f(z)$ 在 $D$ 内解析, 则对 $z_0\in D$, 有</p><script type="math/tex; mode=display">f^{(n)}(z_0) = \frac{n!}{2\pi i}\oint_{\left|{z - z_0}\right| = r}\limits\frac{f(z)dz}{(z - z_0)^{n + 1}}.$$ ◻$\textbf{Solution:}$由于 $f(z)$ 在 $z_0$ 处解析, 可以认为$$f(z) = \sum_{k = 0}^{\infty}\limits\frac{1}{k!}f^{(k)}(z_0)(z - z_0)^k</script><p>在 $\left|{z - z_0}\right|\le r$ 内处处成立.</p><p>两边同时除以 $(z - z_0)^{n + 1}$, 再对 $\left|{z - z_0}\right| = r$<br>积分可得</p><script type="math/tex; mode=display">\oint_{\left|{z - z_0}\right| = r}\limits\frac{f(z)dz}{(z - z_0)^{n + 1}} = \frac{2\pi i}{n!}f^{(n)}(z_0).$$ ◻$\textbf{Example:}$求积分$$\oint_{\left|{z}\right| = 1}\limits\cfrac{1 - \cos 4z^5}{z^n}dz.$$ ◻$\textbf{Solution:}$当 $n = 0$ 时,由于 $f(z) = 1 - \cos 4z^5$ 在复平面上处处解析,得 $$\oint_{\left|{z}\right| = 1}\limits (1 - \cos 4z^5)dz = 0.</script><p>当 $n\ge 1$ 时,</p><script type="math/tex; mode=display">\cfrac{1 - \cos 4z^5}{z^n} = \sum_{k = 1}^{\infty}\limits\cfrac{1}{z^n}\cdot(-1)^k\cfrac{(4z^5)^{2k}}{(2k)!} = \sum_{k = 1}^{\infty}\limits\cfrac{(-1)^{k + 1}4^{2k}z^{10k - n}}{(2k)!}.</script><p>进而</p><script type="math/tex; mode=display">\oint_{\left|{z}\right| = 1}\limits\cfrac{1 - \cos 4z^5}{z^n}dz = \begin{cases}            2\pi i\cdot\cfrac{(-1)^{k + 1}16^k}{(2k)!}, n = 10k + 1 \\            0, n\ne 10k + 1 \\        \end{cases}        (\mbox{其中}k\in\mathbb{N})$$ ◻### 3. 最大模原理$\textbf{Example:}$$f(z)$ 非常函数, 在有界域 $D$ 内可导, 在边界 $\partial D$ 上连续, 则$$\max_{z\in D\cup\partial D}\limits\left|{f(z)}\right| = \max_{z\in \partial D}\limits\left|{f(z)}\right|,</script><p>并且满足 $f’(z_0)\ne 0$. ◻</p><p>$\textbf{Solution:}$<br>设 $z_0\in D\cup\partial D$ 使得<br>$f(z_0) = \max_{z\in D\cup\partial D}\limits\left|{f(z)}\right|$.</p><p>若 $z_0\in D$, 由平均值公式, $\exists\thinspace r_0 &gt; 0$,</p><p>当 $0 &lt; r\le r_0$ 时, $\left|{z - z_0}\right|$ 位于 $D$ 内. 那么</p><script type="math/tex; mode=display">\begin{aligned}            \left|{f(z_0)}\right| &= \frac{1}{2\pi}\left|{\int_0^{2\pi}\limits f(z_0 + re^{i\theta})d\theta}\right| \\            &\le \frac{1}{2\pi}\int_0^{2\pi}\limits \left|{f(z_0 + re^{i\theta})}\right|d\theta \\            &\le \frac{1}{2\pi}\int_0^{2\pi}\limits \left|{f(z_0)}\right|d\theta \\            &= \left|{f(z_0)}\right|,        \end{aligned}</script><p>即<br>$\left|{f(z)}\right|\equiv \left|{f(z_0)}\right|, \thinspace\forall \left|{z - z_0}\right| &lt; r$.</p><p>进而<br>$\left|{f(z)}\right|\equiv \left|{f(z_0)}\right|, \thinspace\forall z\in D$,<br>这与 $f(z)$ 为连续非常函数矛盾.</p><p>故若<br>$\left|{f(z_0)}\right| = \max_{z\in D\cup\partial D}\limits\left|{f(z)}\right|$,<br>则有 $z_0\in\partial D$. ◻</p><h3 id="4-最小模原理"><a href="#4-最小模原理" class="headerlink" title="4. 最小模原理"></a>4. 最小模原理</h3><p>$\textbf{Example:}$<br>$f(z)$ 非常函数, 在有界域 $D$ 内可导且非零, 在边界 $\partial D$<br>上连续, 则</p><script type="math/tex; mode=display">\min_{z\in D\cup\partial D}\limits\left|{f(z)}\right| = \min_{z\in \partial D}\limits\left|{f(z)}\right|,</script><p>并且满足 $f’(z_0)\ne 0$. ◻</p><p>$\textbf{Solution:}$<br>注意到 $\frac{1}{f(z)}$ 是解析的, 再使用最大模原理即可. ◻</p><h3 id="5-调和函数最大值原理"><a href="#5-调和函数最大值原理" class="headerlink" title="5. 调和函数最大值原理"></a>5. 调和函数最大值原理</h3><p>$\textbf{Example:}$<br>$u(x, y)\in C^2(D)$ 为调和函数, 在边界 $\partial D$ 上连续, 则</p><script type="math/tex; mode=display">\max_{(x, y)\in D\cup\partial D}\limits\left|{u(x, y)}\right| = \max_{(x, y)\in \partial D}\limits\left|{u(x, y)}\right|.$$ ◻$\textbf{Solution:}$由于 $u$ 为调和函数, 故存在调和函数 $v$,其中 $u, v$ 满足 $Cauchy-Riemann$ 条件, 使得 $f(z) = u + iv$ 为解析函数.令 $g(z) = e^{f(z)}\thinspace(z\in D\cup\partial D)$, 那么$g'(z) = f'(z)e^{f(z)}$ 处处存在.由最大模原理,$$\max_{z\in D\cup\partial D}\limits\left|{g(z)}\right| = \max_{z\in \partial D}\limits\left|{g(z)}\right|.</script><p>又因为</p><script type="math/tex; mode=display">\left|{g(z)}\right| = \left|{e^{f(z)}}\right| = \left|{e^{u + iv}}\right| = \left|{e^u}\right|\cdot \left|{e^{iv}}\right| = e^u,</script><p>故</p><script type="math/tex; mode=display">\max_{z\in D\cup\partial D}\limits e^{u(x, y)} = \max_{z\in \partial D}\limits e^{u(x, y)}.</script><p>即得</p><script type="math/tex; mode=display">\max_{z\in D\cup\partial D}\limits u(x, y) = \max_{z\in \partial D}\limits u(x, y).$$ ◻### 6. 调和函数最小值原理$\textbf{Example:}$$u(x, y)\in C^2(D)$ 为调和函数, 在边界 $\partial D$ 上连续, 则$$\min_{(x, y)\in D\cup\partial D}\limits\left|{u(x, y)}\right| = \min_{(x, y)\in \partial D}\limits\left|{u(x, y)}\right|.$$ ◻$\textbf{Solution:}$注意到 $u_0(x, y) = -u(x, y)$ 也为 $D$ 上的调和函数,对其使用调和函数最大值原理即可. ◻### 7. $M(r)$的应用$\textbf{Example:}$定义$$M(r) = \max_{\left|{z}\right| = r}\limits\left|{f(z)}\right|.$$ ◻$\textbf{Example:}$$f(z)$ 为整函数, 则$$\left|{f^{(n)}(0)}\right|\le \frac{n!M(r)}{r^n}.$$ ◻$\textbf{Solution:}$注意到$$f^{(n)}(0) = \frac{n!}{2\pi i}\oint_{\left|{z}\right| = r}\limits\frac{f(z)dz}{z^{n + 1}},</script><p>那么 <script type="math/tex">\begin{aligned}            \left|{f^{(n)}(0)}\right| &= \frac{n!}{2\pi}\left|{\thinspace\oint_{\left|{z}\right| = r}\limits\frac{f(z)dz}{z^{n + 1}}}\right| \\            &\le \frac{n!}{2\pi}\oint_{\left|{z}\right| = r}\limits\left|{\frac{f(z)}{z^{n + 1}}}\right|\left|{dz}\right| \\            &= \frac{n!}{2\pi}\oint_{\left|{z}\right| = r}\limits\frac{\left|{f(z)}\right|}{r^{n + 1}}\left|{d(re^{i\theta})}\right| \\            &\le \frac{n!}{2\pi}\int_{0}^{2\pi}\frac{M(r)}{r^n}d\theta \\            &= \frac{n!M(r)}{r^n}.        \end{aligned}</script> ◻</p><p>$\textbf{Example:}$<br>有界的整函数为常数<strong>(Liouville定理)</strong>. ◻</p><p>$\textbf{Solution:}$<br>易得 $f(z)$ 在原点处的 $Taylor$ 展开:</p><script type="math/tex; mode=display">f(z) = \sum_{n = 0}^{\infty}\limits\frac{1}{n!}f^{(n)}(0)z^n.</script><p>只需要证明 <script type="math/tex">f^{(n)}(0)\equiv 0, \thinspace\forall\thinspace n\ge 1.</script></p><p>由 $f(z)$ 有界, 故 $\exists\thinspace M_0\in\mathbb{R}$, 使</p><script type="math/tex; mode=display">\left|{f(z)}\right|\le M_0, \thinspace\forall z\in\mathbb{C}.</script><p>由</p><script type="math/tex; mode=display">f^{(n)}(0) = \frac{n!}{2\pi i}\oint_{\left|{z}\right| = r}\limits\frac{f(z)dz}{z^{n + 1}},</script><p>可得</p><script type="math/tex; mode=display">\left|{f^{(n)}(0)}\right|\le \frac{n!M(r)}{r^n}\le \frac{n!M_0}{r^n}.</script><p>注意到当 $r\rightarrow\infty$, 有 <script type="math/tex">\left|{f^{(n)}(0)}\right| = 0,</script></p><p>即 <script type="math/tex">f^{(n)}(0) = 0\thinspace, \thinspace\forall\thinspace n\ge 1.</script></p><p>从而 $f(z)\equiv f(0)$ 为常数. ◻</p><p>$\textbf{Example:}$<br>$f(z)$ 为整函数, 且存在 $M_0 &gt; 0$, 使</p><script type="math/tex; mode=display">\left|{f(z)}\right|\le M\sum_{k = 0}^{n}\limits\left|{z}\right|^k.</script><p>则 $f(z)$ 是一个次数不高于 $n$ 的多项式. ◻</p><p>$\textbf{Solution:}$<br>易得 $f(z)$ 在原点处的 $Taylor$ 展开:</p><script type="math/tex; mode=display">f(z) = \sum_{n = 0}^{\infty}\limits\frac{1}{n!}f^{(n)}(0)z^n.</script><p>只需要证明</p><script type="math/tex; mode=display">f^{(n + i)}(0)\equiv 0, \thinspace\forall\thinspace i\ge 1.</script><p>可得</p><script type="math/tex; mode=display">\left|{f^{(n + i)}(0)}\right|\le \frac{(n + i)!M(r)}{r^{n + i}}\le \frac{(n + i)!M_0}{r^{n + i}}\sum_{k = 0}^{n}\limits r^k.</script><p>注意到当 $r\rightarrow\infty$ 时, 有</p><script type="math/tex; mode=display">\left|{f^{(n + i)}(0)}\right| = 0,</script><p>即 <script type="math/tex">f^{(n + i)}(0) = 0, \thinspace\forall\thinspace i\ge 1.</script></p><p>从而 <script type="math/tex">f(z)\equiv \sum_{k = 0}^{n}\limits\frac{1}{k!}f^{(k)}(0)z^k</script></p><p>为一个次数不高于 $n$ 的多项式. ◻</p><h3 id="8-代数学基本定理"><a href="#8-代数学基本定理" class="headerlink" title="8. 代数学基本定理"></a>8. 代数学基本定理</h3><p>$\textbf{Example:}$<br>设<br>$P_n(z) = \sum_{k = 0}^{n}\limits C_kz^k\thinspace(C_n\ne 0, n\ge 1)$,<br>则 <script type="math/tex">P_n(z) = C_n\prod_{k = 0}^{n}(z - z_k),</script></p><p>即 <script type="math/tex">\exists z_1\in \mathbb{C}, P_n(z_1) = 0.</script> ◻</p><p>$\textbf{Solution:}$<br>设 $\forall z\in\mathbb{C}$, 有 $P_n(z)\ne 0$.</p><p>令 $f(z) = \cfrac{1}{P_n(z)}$, 则 <script type="math/tex">f'(z) = -\cfrac{P'_n(z)}{P_n^2(z)}</script></p><p>处处存在, 那么 $f(z)$ 满足最大模原理, 有</p><script type="math/tex; mode=display">\max_{\left|{z}\right|\le r}\limits\left|{f(z)}\right| = \max_{\left|{z}\right| = r}\limits\left|{f(z)}\right|\rightarrow 0, \mbox{当}r\rightarrow\infty.</script><p>但结合 $f(0) = \cfrac{1}{C_0}\ne 0$, 显然矛盾.</p><p>故 $\exists\thinspace z_1\in \mathbb{C}$, 使得</p><script type="math/tex; mode=display">P_n(z_1) = 0\thinspace\Longleftrightarrow P_n(z) = (z - z_1)P_{n - 1}(z).</script><p>重复可得 <script type="math/tex">P_n(z) = C_n\prod_{k = 0}^{n}(z - z_k).</script> ◻</p><p>$\textbf{Solution:}$<br>设 $\forall z\in\mathbb{C}$, 有 $P_n(z)\ne 0$.</p><p>令 $g(z) = \cfrac{1}{P_n(z)}$, 则 <script type="math/tex">g'(z) = -\cfrac{P'_n(z)}{P_n^2(z)}</script></p><p>处处存在, 那么 $g(z)$ 在 $\mathbb{C}$ 内解析. 由于</p><script type="math/tex; mode=display">P_n(z)\rightarrow\infty, \mbox{当}r\rightarrow\infty,</script><p>故 <script type="math/tex">g(z)\rightarrow 0, \mbox{当}r\rightarrow\infty,</script></p><p>即 $g(z)$ 有界.</p><p>由 $Liouville$ 定理, 得 $g(z)$ 为常数, 进而 $P_n(z)$ 为常数.</p><p>这与 $C_n\ne 0$ 矛盾. 以下同 $\textit{Proof 1}$. ◻</p><h3 id="9-幂级数的收敛半径"><a href="#9-幂级数的收敛半径" class="headerlink" title="9. 幂级数的收敛半径"></a>9. 幂级数的收敛半径</h3><p>$\textbf{Example:}$<br>对幂级数 $f(z) = \sum_{k = 0}^{\infty}\limits c_kz^k$, 若存在<br>$R &gt; 0$, 使得</p><p>当 $\left|{z}\right| &gt; R$ 时 $f(z)$ 发散, 当 $\left|{z}\right| &lt; R$ 时<br>$f(z)$ 绝对收敛,</p><p>那么称 $R$ 为 $f(z)$ 的收敛半径. ◻</p><p>$\textbf{Example:}$<br>$\textbf{(Abel定理)}$ 对幂级数<br>$f(z) = \sum_{k = 0}^{\infty}\limits c_kz^k$, 若</p><p>$f(z)$ 在 $z = z_1\ne 0$ 处收敛, 则在<br>$\left|{z}\right| &lt; \left|{z_1}\right|$ 绝对收敛;</p><p>$f(z)$ 在 $z = z_2\ne 0$ 处发散, 则在<br>$\left|{z}\right| &gt; \left|{z_2}\right|$ 发散. ◻</p><p>$\textbf{Example:}$<br>若幂级数 $f(z) = \sum_{k = 0}^{\infty}\limits c_kz^k$ 在 $z_0$<br>处条件收敛, 则收敛半径 $R = \left|{z_0}\right|$. ◻</p><p>$\textbf{Solution:}$<br>由收敛半径的定义:</p><p>若 $\left|{z_o}\right| &gt; R$ $\Longrightarrow$ $f(z_0)$ 发散, 与题设矛盾,<br>故 $f(z_0)$ 收敛, $\left|{z_0}\right|\le R$.</p><p>若 $\left|{z_0}\right| &lt; R$ $\Longrightarrow$ $f(z_0)$ 绝对收敛,<br>与题设矛盾, 故 $\left|{z_0}\right|\ge R$.</p><p>综上, 得 $\left|{z_0}\right| = R$. ◻</p><p>$\textbf{Example:}$<br>对幂级数</p><script type="math/tex; mode=display">f(z) = \sum_{k = 0}^{\infty}\limits c_kz^k, g(z) = \sum_{k = 0}^{\infty}\limits d_kz^k</script><p>当 $n$ 充分大时, 有 $\left|{d_n}\right| \le \left|{c_n}\right|$,<br>则收敛半径 $R_1\le R_2$. ◻</p><p>$\textbf{Example:}$<br>若 $c_n = a_n + ib_n, a_n, b_n\in\mathbb{R}$, 对幂级数</p><script type="math/tex; mode=display">f(z) = \sum_{n = 0}^{\infty}\limits c_nz^n = \sum_{n = 0}^{\infty}\limits a_nz^n + i\sum_{n = 0}^{\infty}\limits b_nz^n</script><p>其中<br>$\sum_{n = 0}^{\infty}\limits a_nz^n, \sum_{n = 0}^{\infty}\limits b_nz^n$<br>的收敛半径分别为 $R_1, R_2$, 那么 $\sum_{n = 0}^{\infty}\limits c_nz^n$<br>的收敛半径 $R = \min\left\{R_1, R_2\right\}$. ◻</p><p>$\textbf{Solution:}$<br>不妨设 $R_1\le R_2$, 此时 $\min\left\{R_1, R_2\right\} = R_1$.</p><p>下证 $R = R_1$. 先证 $R_1\ge R$.</p><p>由 $c_n = a_n + ib_n$, 有 $\left|{c_n}\right| \ge \left|{a_n}\right|$,<br>进而</p><script type="math/tex; mode=display">\sum_{n = 0}^{\infty}\limits \left|{c_nz^n}\right| \ge \sum_{n = 0}^{\infty}\limits \left|{a_nz^n}\right|.</script><p>那么当 $\left|{z}\right| &lt; R$ 时, 由收敛半径定义,</p><script type="math/tex; mode=display">\sum_{n = 0}^{\infty}\limits \left|{c_nz^n}\right| \ge \sum_{n = 0}^{\infty}\limits \left|{a_nz^n}\right| < \infty.</script><p>此时 $\sum_{n = 0}^{\infty}\limits a_nz^n$ 绝对收敛, 那么 $R_1 \ge R$.</p><p>再证 $R_1\le R$.</p><p>若 $R_1 &gt; R$, 取<br>$z = \cfrac{1}{2}\left(R + R_1\right)\in\left(R, R_1\right)$ 由</p><script type="math/tex; mode=display">\sum_{n = 0}^{\infty}\limits c_nz^n = \sum_{n = 0}^{\infty}\limits a_nz^n + i\sum_{n = 0}^{\infty}\limits b_nz^n</script><p>那么此时 $\sum_{n = 0}^{\infty}\limits a_nz^n$,<br>$\sum_{n = 0}^{\infty}\limits b_nz^n$ 均收敛,</p><p>进而 $\sum_{n = 0}^{\infty}\limits c_nz^n$ 收敛, 且 $z &gt; R$,<br>与收敛半径定义矛盾. 故 $R_1\le R$.</p><p>综上, 有 $R = \min\left\{R_1, R_2\right\}$ 成立. ◻</p><p>$\textbf{Example:}$<br>若 $f(z)$ 在 $R$ 上无奇点, 则收敛半径 $R = +\infty$;</p><p>若 $f(z)$ 在 $R$ 上有奇点 $z_1, z_2, \cdots, z_n$, 则收敛半径<br>$R = \min_{1\le k\le n}\limits \left|{z_k}\right|$. ◻</p><h3 id="10-幂级数的敛散性"><a href="#10-幂级数的敛散性" class="headerlink" title="10. 幂级数的敛散性"></a>10. 幂级数的敛散性</h3><p>$\textbf{Example:}$</p><script type="math/tex; mode=display">f_1(z) = \sum_{n = 1}^{\infty}\limits z^n</script><p>在收敛圆周上处处发散. ◻</p><p>$\textbf{Solution:}$<br>收敛半径 $R = 1$. 当 $\left|{z}\right| = 1$ 时,<br>$z = e^{i\theta}\thinspace(\theta\in\left[0, 2\pi\right))$,</p><p>那么</p><script type="math/tex; mode=display">\left|{z^n}\right| = \left|{e^{in\theta}}\right| = 1\nrightarrow 0, \mbox{当}\thinspace n\rightarrow \infty.</script><p>由 $Cauchy$ 收敛准则, <script type="math/tex">f_1(z) = \sum_{n = 1}^{\infty}\limits z^n</script></p><p>在收敛圆周上处处发散. ◻</p><p>$\textbf{Example:}$</p><script type="math/tex; mode=display">f_2(z) = \sum_{n = 1}^{\infty}\limits \frac{z^n}{n}</script><p>在收敛圆周上部分发散, 部分收敛. ◻</p><p>$\textbf{Solution:}$<br>注意到</p><script type="math/tex; mode=display">f_2(z) = \sum_{n = 1}^{\infty}\limits\int_{0}^{z} t^{n - 1}dt = \int_{0}^{z}\sum_{n = 1}^{\infty}\limits t^{n - 1}dt = -\ln(1 - z), \left|{z}\right| < 1 = R.</script><p>且 $f_2(1) = \sum_{n = 1}^{\infty}\limits\cfrac{1}{n}$ 发散,<br>$f_2(-1) = \sum_{n = 1}^{\infty}\limits\cfrac{(-1)^n}{n} = -\ln2$ 收敛.</p><p>那么 <script type="math/tex">f_2(z) = \sum_{n = 1}^{\infty}\limits\frac{z^n}{n}</script></p><p>在收敛圆周上部分发散, 部分收敛. ◻</p><p>$\textbf{Example:}$<br>给出</p><script type="math/tex; mode=display">\sum_{n = 1}^{\infty}\limits\frac{\cos{n\theta}}{n}, \sum_{n = 1}^{\infty}\limits\frac{\sin{n\theta}}{n}</script><p>的和函数, 其中 $\theta\in\left(0, 2\pi\right)$. ◻</p><p>$\textbf{Solution:}$<br>注意到对于<br>$z = x + iy\in\mathbb{C}, \mbox{其中}\thinspace x, y\in\mathbb{R}$, 有</p><script type="math/tex; mode=display">\ln(x + iy) = \ln\left|{x + iy}\right| + i\theta = \frac{1}{2}\ln(x^2 + y^2) + i\arctan\frac{y}{x}.</script><p>对于 $z = re^{i\theta}, 0\le r &lt; 1, 0\le\theta &lt; 2\pi$, 有</p><script type="math/tex; mode=display">\sum_{n = 1}^{\infty}\limits\frac{r^ne^{in\theta}}{n} = -\ln(1-re^{i\theta}) = -\ln(1-r\cos\theta - i\sin\theta),</script><p>展开得</p><script type="math/tex; mode=display">\sum_{n = 1}^{\infty}\limits\frac{r^n\cos{n\theta}}{n} + i\sum_{n = 1}^{\infty}\limits\frac{r^n\sin{n\theta}}{n} = -\frac{1}{2}\ln(1 - 2r\cos\theta + r^2) + i\arctan\frac{r\sin\theta}{1 - r\cos\theta}.</script><p>当 $\theta\in\left(0, 2\pi\right)$ 时, 令 $r\rightarrow 1^{-}$, 即得</p><script type="math/tex; mode=display">\sum_{n = 1}^{\infty}\limits\frac{\cos{n\theta}}{n} = -\frac{1}{2}\ln(2 - 2\cos\theta) = -\ln\left(2\sin\frac{\theta}{2}\right),</script><script type="math/tex; mode=display">\sum_{n = 1}^{\infty}\limits\frac{\sin{n\theta}}{n} = \arctan\frac{\sin\theta}{1 - \cos\theta} = \arctan\left(\cot\frac{\theta}{2}\right) = \frac{\pi - \theta}{2}.$$ ◻$\textbf{Example:}$给出$$\sum_{n = 1}^{\infty}\limits\frac{\cos{n\theta}}{n^2}, \sum_{n = 1}^{\infty}\limits\frac{\sin{n\theta}}{n^2}</script><p>的和函数, 其中 $\theta\in\left[0, 2\pi\right)$. ◻</p><p>$\textbf{Solution:}$<br>注意到</p><script type="math/tex; mode=display">\sum_{n = 1}^{\infty}\limits\frac{\cos{n\theta}}{n^2} = \sum_{n = 1}^{\infty}\frac{1}{n^2} - \sum_{n = 1}^{\infty}\limits\int_{0}^{\theta}\frac{\sin{nt}}{n}dt = \frac{\pi^2}{6} - \frac{\theta\left(2\pi - \theta\right)}{4}.</script><script type="math/tex; mode=display">\sum_{n = 1}^{\infty}\limits\frac{\sin{n\theta}}{n^2} = \sum_{n = 1}^{\infty}\limits\int_{0}^{\theta}\frac{\cos{nt}}{n}dt = \int_{0}^{\theta}\sum_{n = 1}^{\infty}\limits\frac{\cos{nt}}{n}dt = -\int_{0}^{\theta}\ln\left(2\sin\frac{t}{2}\right)dt.$$ ◻$\textbf{Example:}$$$f_3(z) = \sum_{n = 1}^{\infty}\limits \frac{z^n}{n^2}</script><p>在收敛圆周上处处收敛. ◻</p><p>$\textbf{Solution:}$<br>注意到当 $\left|{z}\right| = 1$ 时,</p><script type="math/tex; mode=display">\sum_{n = 1}^{\infty}\left|{\frac{z^n}{n^2}}\right| = \sum_{n = 1}^{\infty}\frac{1}{n^2} = \frac{\pi^2}{6},</script><p>那么 <script type="math/tex">f_3(z) = \sum_{n = 1}^{\infty}\limits \frac{z^n}{n^2}</script></p><p>在收敛圆周上处处收敛. ◻</p><p>$\textbf{Example:}$<br>幂级数收敛圆周上的点都是其奇点. ◻</p><h3 id="11-Laurent-级数"><a href="#11-Laurent-级数" class="headerlink" title="11. Laurent 级数"></a>11. Laurent 级数</h3><p>$\textbf{Example:}$<br>$\mathbb{C}^2$ 上的分片函数: <script type="math/tex">f(z) = \cfrac{1}{1 + z^2} =         \begin{cases}            \sum_{n = 0}^{\infty}\limits(-1)^nz^{2n}, \left|{z}\right| < 1 \\            \cfrac{1}{1 + z^2}, \left|{z}\right| = 1, z\ne\pm i \\            \sum_{n = 0}^{\infty}\limits\cfrac{(-1)^n}{z^{2(n + 1)}}, \left|{z}\right| > 1         \end{cases}</script> ◻</p><h3 id="12-留数-A"><a href="#12-留数-A" class="headerlink" title="12. 留数 A"></a>12. 留数 A</h3><p>$\textbf{Example:}$<br>求复积分</p><script type="math/tex; mode=display">I = \oint_{\left|{z}\right| = \varepsilon > 1}e^{\frac{1}{z}}dz.$$ ◻$\textbf{Solution:}$令 $t = \cfrac{1}{z}$, $dz = -\cfrac{dt}{t^2}$. 记$z = \varepsilon e^{i\theta}$, 那么$t = \cfrac{1}{\varepsilon}e^{-i\theta}$,$\theta\in\left[0, 2\pi\right)$.那么$$I = -\oint_{\left|{t}\right| = \frac{1}{\varepsilon}}{e^t\left(-\frac{dt}{t^2}\right)} = \oint_{\left|{t}\right| = \frac{1}{\varepsilon}}\frac{e^t}{t^2}dt = 2\pi i\left(e^t\right)'|_{t = 0} = 2\pi i.$$ ◻$\textbf{Solution:}$注意到$$I = \oint_{\left|{z}\right| = \varepsilon}\limits e^{\frac{1}{z}}dz = \sum_{n = 0}^{+\infty}\cfrac{1}{n!}\oint_{\left|{z}\right| = \varepsilon}\cfrac{dz}{z^n} = \sum_{n = 0}^{+\infty}\limits\cfrac{1}{n!}I_n = I_1 = 2\pi i.$$ ◻$\textbf{Example:}$求复积分$$J_n = \oint_{\left|{z}\right| = r > 1}\cfrac{dz}{1 + z^n}, n\in\mathbb{N}.$$ ◻$\textbf{Solution:}$令 $t = \cfrac{1}{z}$, $dz = -\cfrac{dt}{t^2}$. 那么$$\begin{aligned}            J_n &= -\oint_{\left|{t}\right| = \frac{1}{r}}\cfrac{1}{1 + \frac{1}{t^n}}\left(-\frac{dt}{t^2}\right) \\            &= \oint_{\left|{t}\right| = \frac{1}{r}}\cfrac{t^{n - 2}}{1 + t^n}dt \\            &= \begin{cases}                2\pi i, n = 1; \\                0, n\ge 2.            \end{cases}        \end{aligned}$$ ◻$\textbf{Solution:}$$$\begin{aligned}            J_n &= 2\pi i\sum_{k = 1}^{n}\limits Res\left[\frac{1}{1 + z^n}, z_k\right] \\            &= 2\pi i\sum_{k = 1}^{n}\limits\cfrac{1}{nz_k^{n - 1}} \\            &= \cfrac{2\pi i}{n}\sum_{k = 1}^{n}(-z_k) \\            &= -\cfrac{2\pi i}{n}\sum_{k = 1}^{n}z_k \\            &= \begin{cases}                2\pi i, n = 1; \\                0, n\ge 2.            \end{cases}        \end{aligned}$$ ◻$\textbf{Example:}$给出$$K_n = \oint_{\left|{z}\right| = r > 1}\cfrac{z^{2n}dz}{1 + z^n} = \oint_{\left|{z}\right| = r}\cfrac{dz}{1 + z^n} + \oint_{\left|{z}\right| = r}(z^n - 1) = J_n, n\in\mathbb{N}.$$ ◻$\textbf{Example:}$求复积分$$J = \oint_{\left|{z}\right| = r > 1}\frac{z^3e^{\frac{1}{z}}}{1 + z}dz.$$ ◻$\textbf{Solution:}$令 $t = \cfrac{1}{z}$, $dz = -\cfrac{dt}{t^2}$. 从而$$J = \oint_{\left|{t}\right| = \frac{1}{r}}\frac{e^t}{t^4(1 + t)}dt = \cfrac{2\pi i}{3!}\left(\frac{e^t}{1 + t}\right)^{(3)}|_{t = 0} = -\frac{2}{3}\pi i.$$ ◻$\textbf{Solution:}$令 $t = \cfrac{1}{z}$, $dz = -\cfrac{dt}{t^2}$. 从而$$\begin{aligned}            J &= \oint_{\left|{t}\right| = \frac{1}{r}}\frac{e^t}{t^4(1 + t)}dt \\            &= \oint_{\left|{t}\right| = \frac{1}{r}}\frac{e^t(1 - t^4 + t^4)}{t^4(1 + t)}dt \\            &= \oint_{\left|{t}\right| = \frac{1}{r}}\frac{e^t(1 - t^4)}{t^4(1 + t)}dt + \oint_{\left|{t}\right| = \frac{1}{r}}\frac{e^tt^4}{1 + t}dt \\            &= \oint\frac{e^t}{t^4}dt - \oint\frac{e^t}{t^3}dt + \oint\frac{e^t}{t^2}dt - \oint\frac{e^t}{t}dt \\            &= 2\pi i\left(\frac{1}{3!} - \frac{1}{2!} + \frac{1}{1!} - \frac{1}{0!}\right) \\            &= -\frac{2}{3}\pi i.        \end{aligned}$$ ◻$\textbf{Solution:}$令 $t = \cfrac{1}{z}$, $dz = -\cfrac{dt}{t^2}$. 从而$$J = \oint_{\left|{t}\right| = \frac{1}{r}}\frac{e^t}{t^4(1 + t)}dt,</script><p>注意到 <script type="math/tex">\begin{aligned}            \frac{e^t}{t^4(1 + t)} &= \frac{1}{t^4}\left(1 + t + \frac{t^2}{2!} + \frac{t^3}{3!} + \cdots\right)\left(1 - t + t^2 - t^3 + \cdots\right) \\            &= \frac{1}{t^4}\left(1 + \frac{1}{2}t^2 - \frac{1}{3}t^3 + O(t^3)\right),        \end{aligned}</script></p><p>故 <script type="math/tex">\begin{aligned}            J &= \oint_{\left|{t}\right| = \frac{1}{r}}\frac{1}{t^4}\left(1 + \frac{1}{2}t^2 - \frac{1}{3}t^3 + O(t^3)\right) \\            &= I_4 + \frac{1}{2}I_2 - \frac{1}{3}I_1 \\            &= -\frac{1}{3}I_1 \\            &= -\frac{2}{3}\pi i.        \end{aligned}</script> ◻</p><p>$\textbf{Solution:}$</p><script type="math/tex; mode=display">\begin{aligned}            J &= \oint_{\left|{z}\right| = r > 1}\frac{z^3e^{\frac{1}{z}}}{1 + z}dz \\            &= 2\pi i\left\{Res\left[f, 0\right] + Res\left[f, -1\right]\right\}.        \end{aligned}</script><p>注意到 <script type="math/tex">\begin{aligned}            Res\left[f, -1\right] = \frac{(-1)^3e^{-1}}{1} = -e^{-1},        \end{aligned}</script></p><p>而 $Res\left[f, 0\right]$ 为 $f$ 在 $z_0 = 0$ 处 $Larent$ 级数中的系数<br>$C_{-1}$.</p><p>注意到 <script type="math/tex">\begin{aligned}            \frac{z^3e^{\frac{1}{z}}}{1 + z} = z^3\left(1 + \frac{1}{z} + \frac{1}{2!z^2} + \frac{1}{3!z^3} + \cdots\right)\left(1 - z + z^2 - z^3 + \cdots\right),        \end{aligned}</script></p><p>那么</p><script type="math/tex; mode=display">C_{-1} = \frac{1}{4!} - \frac{1}{5!} + \frac{1}{6!} - \frac{1}{7!} + \cdots = e^{-1} - \frac{1}{3}.</script><p>进而 <script type="math/tex">\begin{aligned}            J &= \oint_{\left|{z}\right| = r > 1}\frac{z^3e^{\frac{1}{z}}}{1 + z}dz \\            &= 2\pi i\left\{Res\left[f, 0\right] + Res\left[f, -1\right]\right\} \\            &= 2\pi i\left(-e^{-1} + e^{-1} - \frac{1}{3}\right) \\            &= -\frac{2}{3}\pi i.        \end{aligned}</script> ◻</p><p>$\textbf{Example:}$<br>求复积分</p><script type="math/tex; mode=display">I_{a, b} = \int_{0}^{2\pi}\cfrac{d\theta}{a + b\cos\theta},</script><p>其中 $a &gt; \left|{b}\right|$, $a, b\in\mathbb{R}$. ◻</p><p>$\textbf{Solution:}$<br>令</p><script type="math/tex; mode=display">z = e^{i\theta}\Longrightarrow \cos\theta = \cfrac{z + z^{-1}}{2}.</script><p>那么</p><script type="math/tex; mode=display">dz = ie^{i\theta}d\theta = izd\theta\Longrightarrow d\theta = \cfrac{dz}{iz}.</script><p>进而</p><script type="math/tex; mode=display">I_{a, b} = \int_{0}^{2\pi}\cfrac{d\theta}{a + b\frac{z + z^{-1}}{2}} = \cfrac{2}{i}\oint_{\left|{z}\right| = 1}\cfrac{dz}{bz^2 + 2az + b}.</script><p>$\circ$ 若 $b = 0$, 得 <script type="math/tex">I_{a, b} = \frac{2\pi}{a}.</script></p><p>$\circ$ 若 $b &gt; 0$, 考虑方程 $z^2 + 2\cfrac{a}{b}z + 1 = 0$. 解得</p><script type="math/tex; mode=display">\begin{aligned}            \begin{cases}                z_1 = -\cfrac{a}{b} + \cfrac{\sqrt{a^2 - b^2}}{b},\\                z_2 = -\cfrac{a}{b} - \cfrac{\sqrt{a^2 - b^2}}{b} < -\cfrac{a}{b} < -1.                    \end{cases}        \end{aligned}</script><p>故</p><script type="math/tex; mode=display">I_{a, b} = \cfrac{2}{i}\cdot 2\pi i\cdot Res\left[f(z), z_1\right] = \cfrac{2}{i}\cdot 2\pi i\cdot\cfrac{1}{2bz_1 + 2a} = \cfrac{2\pi}{\sqrt{a^2 - b^2}}.</script><p>$\circ$ 若 $b &lt; 0$, 同理有</p><script type="math/tex; mode=display">I_{a, b} = \cfrac{2\pi}{\sqrt{a^2 - b^2}}.</script><p>综上, 有</p><script type="math/tex; mode=display">I_{a, b} = \int_{0}^{2\pi}\cfrac{d\theta}{a + b\cos\theta} = \cfrac{2\pi}{\sqrt{a^2 - b^2}}.$$ ◻$\textbf{Example:}$求复积分$$I_p = \int_{0}^{2\pi}\cfrac{d\theta}{1 + p^2 - 2p\cos\theta},</script><p>其中 $p\in(-1, 1).$ ◻</p><p>$\textbf{Solution:}$<br>在 $I_{a, b}$ 中取 $a = 1 + p^2$, $b = -2p$, 得</p><script type="math/tex; mode=display">I_p = \cfrac{2\pi}{\sqrt{(1 + p^2)^2 - (-2p)^2}} = \cfrac{2\pi}{1 - p^2}.$$ ◻$\textbf{Example:}$求复积分$$J_{a, b} = \int_{0}^{2\pi}\cfrac{d\theta}{a^2\cos^2\theta + b^2\sin^2\theta},</script><p>其中 $a &gt; 0$, $b &gt; 0$. ◻</p><p>$\textbf{Solution:}$</p><script type="math/tex; mode=display">J_{a, b} = \int_{0}^{2\pi}\cfrac{2d\theta}{(a^2 + b^2) + (a^2 - b^2)\cos 2\theta} = \int_{0}^{4\pi}\cfrac{dt}{(a^2 + b^2) + (a^2 - b^2)\cos t},</script><p>在 $I_{A, B}$ 中取 $A = a^2 + b^2$, $B = a^2 - b^2$, 得</p><script type="math/tex; mode=display">J_{a, b} = 2\cfrac{2\pi}{\sqrt{(a^2 + b^2)^2 - (a^2 - b^2)^2}} = \cfrac{2\pi}{ab}.$$ ◻### 13. 留数 B$\textbf{Example:}$$C_R: Re^{i\theta}$, $0\le\theta\le\pi$, 多项式 $P$, $Q$ 满足$\deg Q\ge\deg P + 2$, 则$$\lim_{R\rightarrow +\infty}\limits\int_{C_R}\frac{P(z)}{Q(z)}dz = 0.$$ ◻$\textbf{Example:}$求积分$$I_{a, b} = \int_{0}^{+\infty}\cfrac{dx}{(x^2 + a^2)(x^2 + b^2)},</script><p>其中 $a &gt; 0$, $b &gt; 0$ 为常数. ◻</p><p>$\textbf{Solution:}$<br>注意到</p><script type="math/tex; mode=display">I_{a, b} = \frac{1}{2}\lim_{R\rightarrow +\infty}\int_{-R}^{R}\cfrac{dx}{(x^2 + a^2)(x^2 + b^2)}.</script><p>作 $\Gamma_R: \left[-R, R\right]\cup C_R$,</p><p>那么根据复合闭路定理, 得</p><script type="math/tex; mode=display">\oint_{\Gamma_R}f(z)dz = \int_{-R}^{R}f(x)dx + \int_{C_R}f(z)dz.</script><p>令 $R\rightarrow +\infty$, 由于</p><script type="math/tex; mode=display">\lim_{R\rightarrow +\infty}\int_{C_R}f(z)dz = 0,</script><p>那么 <script type="math/tex">\begin{aligned}            I_{a, b} &= \frac{1}{2}\lim_{R\rightarrow +\infty}\oint_{\Gamma_R}f(z)dz \\            &= \pi i\left(Res\left[f(z), ai\right], Res\left[f(z), bi\right]\right) \\            &= \pi i\left(\frac{1}{2ai(a^2 + b^2 +2(ai)^2)} + \frac{1}{2bi(a^2 + b^2 +2(bi)^2)}\right) \\            &= \frac{\pi}{2ab(a + b)}.        \end{aligned}</script> ◻</p><p>$\textbf{Example:}$<br>求复积分 <script type="math/tex">I_n = \int_{0}^{+\infty}\cfrac{dx}{1 + x^{2n}}.</script> ◻</p><p>$\textbf{Solution:}$<br>注意到</p><script type="math/tex; mode=display">I_n = \frac{1}{2}\lim_{R\rightarrow +\infty}\int_{-R}^{R}\cfrac{dx}{1 + x^{2n}}.</script><p>作 $\Gamma_R: \left[-R, R\right]\cup C_R$,</p><p>那么根据复合闭路定理, 得</p><script type="math/tex; mode=display">\oint_{\Gamma_R}f(z)dz = \int_{-R}^{R}f(x)dx + \int_{C_R}f(z)dz.</script><p>令 $R\rightarrow +\infty$, 由于</p><script type="math/tex; mode=display">\lim_{R\rightarrow +\infty}\int_{C_R}f(z)dz = 0,</script><p>那么 <script type="math/tex">\begin{aligned}            I_n &= \frac{1}{2}\lim_{R\rightarrow +\infty}\oint_{\Gamma_R}f(z)dz \\            &= \pi i\sum_{k = 1}^{n}Res\left[\frac{1}{1 + z^{2n}}, z_k\right] = \pi i\sum_{k = 1}^{n}\frac{1}{2nz_k^{2n - 1}} \\            &= \frac{\pi i}{2n}\sum_{k = 1}^{n}z_k^{2n - 1} = -\frac{\pi i}{2n}\sum_{k = 1}^{n}z_k \\            &= -\frac{\pi i}{2n}\sum_{k = 1}^{n}e^{\frac{(2k - 1)\pi i}{2n}} = -\frac{\pi i}{2n}e^{-\frac{\pi i}{2n}}\sum_{k = 1}^{n}e^{\frac{k\pi i}{n}} \\            &= -\frac{\pi i}{2n}e^{-\frac{\pi i}{2n}}\frac{2}{1 - e^{\frac{\pi i}{n}}} = \frac{\pi i}{n}\frac{1}{e^{\frac{\pi i}{2n}} - e^{-\frac{\pi i}{2n}}} \\            &= \frac{\pi i}{n}\frac{1}{2i\sin\frac{\pi}{2n}} = \frac{\frac{\pi}{2n}}{\sin\frac{\pi}{2n}}.        \end{aligned}</script> ◻</p><p>$\textbf{Example:}$<br>求复积分</p><script type="math/tex; mode=display">I_{r, n} = \int_{0}^{+\infty}\cfrac{dx}{r^{2n} + x^{2n}}.</script><p>其中 $r &gt; 0$. ◻</p><p>$\textbf{Solution:}$</p><script type="math/tex; mode=display">\begin{aligned}            I_{r, n} &= \cfrac{1}{r^{2n - 1}}\int_{0}^{+\infty}\cfrac{d\left(\frac{x}{r}\right)}{1 + \left(\frac{x}{r}\right)^{2n}} \\            &= \cfrac{1}{r^{2n - 1}}I_n \\            &= \frac{\frac{\pi}{2n}}{r^{2n - 1}\sin\frac{\pi}{2n}}.        \end{aligned}$$ ◻$\textbf{Example:}$求积分 $$J_n = \int_{0}^{+\infty}\cfrac{dx}{1 + x^n},</script><p>其中 $n \ge 2$. ◻</p><p>$\textbf{Solution:}$<br>注意到</p><script type="math/tex; mode=display">J_n = \lim_{R\rightarrow +\infty}\int_{0}^{R}\cfrac{dx}{1 + x^n}.</script><p>作<br>$\Gamma_R: \left[0, R\right]\cup C_R\cup \left[Re^{i\theta}, 0\right]$,</p><p>那么根据复合闭路定理, 得</p><script type="math/tex; mode=display">\oint_{\Gamma_R}f(z)dz = \int_{0}^{R}f(x)dx + \int_{C_R}f(z)dz + \int_{R}^{0}f(xe^{i\theta})d(xe^{i\theta}).</script><p>令 $R\rightarrow +\infty$, 由于</p><script type="math/tex; mode=display">\lim_{R\rightarrow +\infty}\int_{C_R}f(z)dz = 0,</script><p>取 $\theta = \cfrac{2\pi}{n}, \varphi = \cfrac{\pi}{n}$, 那么</p><script type="math/tex; mode=display">\begin{aligned}            \lim_{R\rightarrow +\infty}\oint_{\Gamma_R}f(z)dz &= \lim_{R\rightarrow +\infty}\int_{0}^{R}f(x)dx + \lim_{R\rightarrow +\infty}\int_{R}^{0}f(xe^{i\theta})d(xe^{i\theta}) \\            &= \lim_{R\rightarrow +\infty}\left(\int_{0}^{R}\cfrac{dx}{1 + x^n}dx - \int_{0}^{R}\cfrac{e^{i\theta}dx}{1 + e^{ni\theta}x^n}\right) \\            &= \lim_{R\rightarrow +\infty}\left(\int_{0}^{R}\cfrac{dx}{1 + x^n}dx - e^{\frac{2\pi i}{n}}\int_{0}^{R}\cfrac{dx}{1 + x^n}\right) \\            &= \left(1 - e^{\frac{2\pi i}{n}}\right)\lim_{R\rightarrow +\infty}\int_{0}^{R}\cfrac{dx}{1 + x^n}dx \\            &= \left(1 - e^{\frac{2\pi i}{n}}\right)J_n.        \end{aligned}</script><p>又注意到 <script type="math/tex">\begin{aligned}            \lim_{R\rightarrow +\infty}\oint_{\Gamma_R}f(z)dz = 2\pi i\frac{1}{ne^{(n - 1)\frac{\pi i}{n}}},        \end{aligned}</script></p><p>故 <script type="math/tex">\begin{aligned}            J_n &= \frac{2\pi i}{ne^{(n - 1)\frac{\pi i}{n}}\left(1 - e^{\frac{2\pi i}{n}}\right)} \\            &= \frac{2\pi i}{ne^{(\pi - \varphi)i}\left(1 - e^{2\varphi i}\right)} \\            &= \frac{\pi i}{n(-\cos\varphi + i\sin\varphi)\sin\varphi(\sin\varphi - i\cos\varphi)} \\            &= \frac{\pi}{n\sin\varphi} = \frac{\frac{\pi}{n}}{\sin\frac{\pi}{n}}.        \end{aligned}</script> ◻</p><p>$\textbf{Example:}$</p><script type="math/tex; mode=display">\frac{1}{(1 + z)^n} = \sum_{k = 0}^{+\infty}(-1)^k C_{n + k - 1}^{n - 1}z^k,</script><p>其中 $\left|{z}\right| &lt; 1$. 特别地, 其中 $z^{n - 1}$ 项的系数为</p><script type="math/tex; mode=display">(-1)^{n - 1}C_{2n - 2}^{n - 1} = (-1)^{n - 1}\cfrac{(2n - 2)!}{(n - 1)!(n - 1)!}.$$ ◻$\textbf{Example:}$求积分 $$J_n = \int_{0}^{+\infty}\cfrac{dx}{(1 + x^2)^n}.$$ ◻$\textbf{Solution:}$注意到$$J_n = \frac{1}{2}\lim_{R\rightarrow +\infty}\int_{-R}^{R}\cfrac{dx}{(1 + x^2)^n}.</script><p>作 $\Gamma_R: \left[-R, R\right]\cup C_R$,</p><p>那么根据复合闭路定理, 得</p><script type="math/tex; mode=display">\oint_{\Gamma_R}f(z)dz = \int_{-R}^{R}f(x)dx + \int_{C_R}f(z)dz.</script><p>令 $R\rightarrow +\infty$, 由于</p><script type="math/tex; mode=display">\lim_{R\rightarrow +\infty}\int_{C_R}f(z)dz = 0,</script><p>因为 <script type="math/tex">\begin{aligned}            \cfrac{1}{(1 + z^2)^n} &= \cfrac{1}{(z + i)^n(z - i)^n} \\            &= \cfrac{1}{(2i)^n(1 + \frac{z - i}{2i})^n(z - i)^n} \\            &= \cfrac{1}{(2i)^n(z - i)^n}\sum_{k = 0}^{+\infty}(-1)^k C_{n + k - 1}^{n - 1}(\frac{z - i}{2i})^k.        \end{aligned}</script></p><p>其中 $\cfrac{1}{z - i}$ 的系数<br>$c_{-1} = \cfrac{(-1)^{n - 1}C_{2n - 2}^{n - 1}}{(2i)^{2n - 1}} = \cfrac{-iC_{2n - 2}^{n - 1}}{2^{2n - 1}}$.</p><p>那么 <script type="math/tex">\begin{aligned}            J_n &= \pi i Res[f, i] \\            &= \pi ic_{-1} \\            &= \cfrac{\pi C_{2n - 2}^{n - 1}}{2^{2n - 1}}.        \end{aligned}</script> ◻</p><p>$\textbf{Example:}$<br>求复积分 <script type="math/tex">J_{r, n} = \int_{0}^{+\infty}\cfrac{dx}{(r^2 + x^2)^n}.</script></p><p>其中 $r &gt; 0$. ◻</p><p>$\textbf{Solution:}$</p><script type="math/tex; mode=display">\begin{aligned}            J_{r, n} &= \cfrac{1}{r^{2n - 1}}\int_{0}^{+\infty}\cfrac{d\left(\frac{x}{r}\right)}{\left(1 + \left(\frac{x}{r}\right)^{2}\right)^n} \\            &= \cfrac{1}{r^{2n - 1}}J_n \\            &= \cfrac{\pi C_{2n - 2}^{n - 1}}{(2r)^{2n - 1}}.        \end{aligned}$$ ◻### 14. 留数 C$\textbf{Example:}$$C_R: Re^{i\theta}$, $0\le\theta\le\pi$, 多项式 $P$, $Q$ 满足$\deg Q\ge\deg P + 1$, 则$$\lim_{R\rightarrow +\infty}\limits\int_{C_R}\frac{P(z)e^{ikz}}{Q(z)}dz = 0.$$ ◻$\textbf{Example:}$求积分 $$I = \int_{0}^{+\infty}\cfrac{x\sin kx}{x^2 + a^2}dx,</script><p>其中 $a &gt; 0$, $k &gt; 0$ 为常数. ◻</p><p>$\textbf{Solution:}$<br>记 $f(z) = \cfrac{z\sin kz}{z^2 + a^2}$,<br>$h(z) = \cfrac{ze^{ikx}}{z^2 + a^2}$.</p><p>那么</p><script type="math/tex; mode=display">\int_{-\infty}^{+\infty}\limits h(z)dz = \int_{-\infty}^{+\infty}\limits\cfrac{z\cos kz}{z^2 + a^2}dz + i\int_{-\infty}^{+\infty}\limits f(z)dz = 2iI.</script><p>作 $\Gamma_R: \left[-R, R\right]\cup C_R$, 那么根据复合闭路定理, 得</p><script type="math/tex; mode=display">\oint_{\Gamma_R}h(z)dz = \int_{-R}^{R}h(x)dx + \int_{C_R}h(z)dz.</script><p>令 $R\rightarrow +\infty$, 由于</p><script type="math/tex; mode=display">\lim_{R\rightarrow +\infty}\int_{C_R}h(z)dz = 0,</script><p>那么 <script type="math/tex">\begin{aligned}            \int_{-\infty}^{+\infty}\cfrac{ze^{ikz}}{z^2 + a^2}dz &= \lim_{R\rightarrow +\infty}\oint_{\Gamma_R}h(z)dz \\            &= 2\pi i Res\left[f(z), ai\right] \\            &= 2\pi i\cdot\cfrac{e^{-ka}}{2} \\            &= \cfrac{\pi i}{e^{ka}}.        \end{aligned}</script></p><p>两边取虚部, 得 <script type="math/tex">\begin{aligned}            I = \cfrac{\pi}{2e^{ka}}.        \end{aligned}</script> ◻</p><p>$\textbf{Example:}$<br>求积分</p><script type="math/tex; mode=display">I_n = \int_{0}^{+\infty}\cfrac{x\sin kx}{(x^2 + a^2)^n}dx,</script><p>其中 $a &gt; 0$, $k &gt; 0$ 为常数. ◻</p><p>$\textbf{Solution:}$<br>注意到</p><script type="math/tex; mode=display">\frac{\partial I_n}{\partial a} = -2na\int_{0}^{+\infty}\cfrac{x\sin kx}{(x^2 + a^2)^{n + 1}}dx = -2naI_{n + 1}.</script><p>即 <script type="math/tex">I_{n + 1} = -\cfrac{1}{2na}\frac{\partial I_n}{\partial a}.</script></p><p>依次递归求解即可. ◻</p><p>$\textbf{Example:}$<br>求积分</p><script type="math/tex; mode=display">I_{a, b, k} = \int_{0}^{+\infty}\cfrac{x^3\sin kx}{(x^2 + a^2)(x^2 + b^2)}dx,</script><p>其中 $a&gt;0$, $b &gt; 0$, $k &gt; 0$ 为常数. ◻</p><p>$\textbf{Solution:}$<br>记 $f(z) = \cfrac{z^3\sin kz}{(z^2 + a^2)(z^2 + b^2)}$,<br>$h(z) = \cfrac{z^3e^{ikx}}{(z^2 + a^2)(z^2 + b^2)}$.</p><p>那么</p><script type="math/tex; mode=display">\int_{-\infty}^{+\infty}\limits h(z)dz = \int_{-\infty}^{+\infty}\limits\cfrac{z^3\cos kz}{(z^2 + a^2)(z^2 + b^2)}dz + i\int_{-\infty}^{+\infty}\limits f(z)dz = 2iI_{a, b, k}.</script><p>作 $\Gamma_R: \left[-R, R\right]\cup C_R$, 那么根据复合闭路定理, 得</p><script type="math/tex; mode=display">\oint_{\Gamma_R}h(z)dz = \int_{-R}^{R}h(x)dx + \int_{C_R}h(z)dz.</script><p>令 $R\rightarrow +\infty$, 由于</p><script type="math/tex; mode=display">\lim_{R\rightarrow +\infty}\int_{C_R}h(z)dz = 0,</script><p>那么 <script type="math/tex">\begin{aligned}            \int_{-\infty}^{+\infty}\cfrac{z^3e^{ikz}}{(z^2 + a^2)(z^2 + b^2)}dz &= \lim_{R\rightarrow +\infty}\oint_{\Gamma_R}h(z)dz \\            &= 2\pi i\left(Res\left[f(z), ai\right] + Res\left[f(z), bi\right]\right) \\            &= \pi i\cdot\cfrac{b^2e^{-kb} - a^2e^{-ka}}{b^2 - a^2}.        \end{aligned}</script></p><p>两边取虚部, 得 <script type="math/tex">\begin{aligned}            \int_{0}^{+\infty}\cfrac{x^3\sin kx}{(x^2 + a^2)(x^2 + b^2)}dx = \cfrac{\pi}{2}\cdot\cfrac{b^2e^{-kb} - a^2e^{-ka}}{b^2 - a^2}.        \end{aligned}</script> ◻</p><p>$\textbf{Example:}$<br>求积分</p><script type="math/tex; mode=display">I_{a, k} = \int_{0}^{+\infty}\cfrac{x^3\sin kx}{(x^2 + a^2)^2}dx,</script><p>其中 $a &gt; 0$, $k &gt; 0$ 为常数. ◻</p><p>$\textbf{Solution:}$<br>在 <script type="math/tex">\begin{aligned}            \int_{0}^{+\infty}\cfrac{x^3\sin kx}{(x^2 + a^2)(x^2 + b^2)}dx = \cfrac{\pi}{2}\cdot\cfrac{b^2e^{-kb} - a^2e^{-ka}}{b^2 - a^2}.        \end{aligned}</script></p><p>中, 令 $b\rightarrow a$, 得 <script type="math/tex">\begin{aligned}            \int_{0}^{+\infty}\cfrac{x^3\sin kx}{(x^2 + a^2)^2}dx = \cfrac{\pi}{2}\cdot\cfrac{(2 - ka)e^{-ka}}{2}.        \end{aligned}</script> ◻</p><p>$\textbf{Example:}$<br>求复积分 <script type="math/tex">I_k = \int_{0}^{+\infty}\cfrac{\sin kx}{x}dx.</script></p><p>其中 $k &gt; 0$. ◻</p><p>$\textbf{Solution:}$<br>在 <script type="math/tex">\begin{aligned}            \int_{0}^{+\infty}\cfrac{x^3\sin kx}{(x^2 + a^2)^2}dx = \cfrac{\pi}{2}\cdot\cfrac{(2 - ka)e^{-ka}}{2}.        \end{aligned}</script></p><p>中, 令 $a\rightarrow 0^{+}$, 得 <script type="math/tex">\begin{aligned}            \int_{0}^{+\infty}\cfrac{\sin kx}{x}dx = \cfrac{\pi}{2}.        \end{aligned}</script> ◻</p><h3 id="15-解析映射"><a href="#15-解析映射" class="headerlink" title="15. 解析映射"></a>15. 解析映射</h3><p>$\textbf{Example:}$<br>求分式线性映射 $w(z)$ 将 $z_k = -1, 0, 1$ 映射到 $w_k = -1, 1, i$. ◻</p><p>$\textbf{Solution:}$<br>利用不变式</p><script type="math/tex; mode=display">\cfrac{w - w_1}{w - w_2}\bigg/\cfrac{w_3 - w_1}{w_3 - w_2} = \cfrac{z - z_1}{z - z_2}\bigg/\cfrac{z_3 - z_1}{z_3 - z_2}.</script><p>那么</p><script type="math/tex; mode=display">\cfrac{w + 1}{w - 1}\bigg/\cfrac{i + 1}{i - 1} = \cfrac{z + 1}{z}\bigg/\cfrac{2}{1}.</script><p>从中解得 <script type="math/tex">w = \cfrac{(1 + 2i)z + 1}{(1 - 2i)z + 1}.</script> ◻</p><p>$\textbf{Example:}$<br>求分式线性映射 $w(z)$ 将单位圆周映射到直线. ◻</p><p>$\textbf{Solution:}$<br>一方面, 容易知道存在 $\left|{z_0}\right| = 1$, 使得<br>$cz_0 + d = 0$.</p><p>注意到 <script type="math/tex">\begin{aligned}            &\hspace{1.8em} cz_0 + d = 0 \\            &\Rightarrow \left|{cz_0}\right| = \left|{d}\right| \\            &\Leftrightarrow \left|{c}\right| = \left|{d}\right| \\            &\Leftrightarrow c = de^{i\theta}.        \end{aligned}</script></p><p>另一方面, 当 $c = de^{i\theta}$ 时, 该分式线性映射满足条件. ◻</p><p>$\textbf{Example:}$<br>求分式线性映射 $w(z)$ 满足:</p><ul><li>将单位圆盘 $\left|{z}\right| &lt; 1$ 映射到单位圆盘<br>$\left|{w}\right| &lt; 1$;</li><li>将点 $z = z_1\thinspace(\left|{z_1}\right| &lt; 1)$ 映射到点 $w = 0$. ◻</li></ul><p>$\textbf{Solution:}$<br>由于分式线性映射保对称点的性质,</p><p>映射前 $z_1$ 的对称点为 $\cfrac{1}{\overline{z_1}}$, 映射后为 $0$<br>的对称点 $+\infty$. 故</p><script type="math/tex; mode=display">w = \alpha\cfrac{z - z_1}{z - \frac{1}{\overline{z_1}}} = (-\alpha z_1)\cfrac{z - z_1}{1 - z\overline{z_1}} = \beta\cfrac{z - z_1}{1 - z\overline{z_1}}.</script><p>由最大模原理:</p><script type="math/tex; mode=display">\left|{z}\right| = 1\Leftrightarrow\left|{w}\right| = 1.</script><p>注意到 $\left|{z_1}\right| &lt; 1$, 从而有 <script type="math/tex">\begin{aligned}            1 &= \left|{\beta}\right|\left|{\cfrac{z - z_1}{1 - z\overline{z_1}}}\right|_{\left|{z}\right| = 1} \\            &= \left|{\beta}\right|\left|{\cfrac{z - z_1}{z\overline{z} - z\overline{z_1}}}\right|_{\left|{z}\right| = 1} \\            &= \cfrac{\left|{\beta}\right|}{\left|{z}\right|}\left|{\cfrac{z - z_1}{\overline{z  - z_1}}}\right|_{\left|{z}\right| = 1} \\            &= \left|{\beta}\right|.        \end{aligned}</script></p><p>即 <script type="math/tex">\beta = e^{i\theta}, \theta\in[0, 2\pi).</script></p><p>那么有</p><script type="math/tex; mode=display">w = e^{i\theta}\cfrac{z - z_1}{1 - z\overline{z_1}}, \thinspace\left|{z_1}\right| < 1, \thinspace\theta\in[0, 2\pi).$$ ◻$\textbf{Example:}$求分式线性映射 $w(z)$ 满足:- 将单位圆盘 $\left|{z - z_0}\right| < r$ 映射到单位圆盘  $\left|{w - w_0}\right| < R$;- 将点 $z = z_1\thinspace(\left|{z_1 - z_0}\right| < r)$ 映射到点  $w = w_0$. ◻$\textbf{Solution:}$考虑 $$z' = \cfrac{z - z_0}{r}, w' = \cfrac{w - w_0}{R}.</script><p>则 $z’(z)$, $w’(w)$ 均将原区域映射为单位圆盘. 那么有</p><script type="math/tex; mode=display">w' = e^{i\theta}\cfrac{z' - z_1'}{1 - z'\overline{z_1'}}, \thinspace\left|{z_1'}\right| < 1, \thinspace\theta\in[0, 2\pi).</script><p>代入 $w’$, $z’$ 可得</p><script type="math/tex; mode=display">w = w_0 + rRe^{i\theta}\cfrac{z - z_1}{r^2 - (z - z_0)(\overline{z_1} - \overline{z_0})}, \thinspace\left|{z_1 - z_0}\right| < r, \thinspace\theta\in[0, 2\pi).$$ ◻$\textbf{Example:}$对于 中的映射, 证明不变式:$$\cfrac{\left|{dw}\right|}{1 - \left|{w}\right|^2} = \cfrac{\left|{dz}\right|}{1 - \left|{z}\right|^2}.$$ ◻$\textbf{Solution:}$即证:$$\left|{\cfrac{dw}{dz}}\right| = \cfrac{1 - \left|{w}\right|^2}{1 - \left|{z}\right|^2}.</script><p>注意到 <script type="math/tex">w = e^{i\theta}\cfrac{z - z_1}{1 - z\overline{z_1}},</script></p><p>其中 <script type="math/tex">\left|{z_1}\right| < 1, \thinspace\theta\in[0, 2\pi)</script></p><p>那么 <script type="math/tex">\begin{aligned}            LHS = \left|{e^{i\theta}\cfrac{1 - z_1\overline{z_1}}{(1 - z\overline{z_1})^2}}\right| = \cfrac{1 - z_1\overline{z_1}}{\left|{1 - z\overline{z_1}}\right|^2}.        \end{aligned}</script></p><script type="math/tex; mode=display">\begin{aligned}            RHS &= \cfrac{1 - w\overline{w}}{1 - z\overline{z}} \\            &= \cfrac{\left|{1 - z\overline{z_1}}\right|^2 - \left|{z - z_1}\right|^2}{(1 - z\overline{z})\left|{1 - z\overline{z_1}}\right|^2} \\            &= \cfrac{(1 - z\overline{z_1})(1 - z_1\overline{z}) - (z - z_1)(\overline{z} - \overline{z_1})}{(1 - z\overline{z})\left|{1 - z\overline{z_1}}\right|^2} \\            &= \cfrac{1 - z\overline{z} - z_1\overline{z_1} + z\overline{z}z_1\overline{z_1}}{(1 - z\overline{z})\left|{1 - z\overline{z_1}}\right|^2} \\            &= \cfrac{(1 - z\overline{z})(1 - z_1\overline{z_1})}{(1 - z\overline{z})\left|{1 - z\overline{z_1}}\right|^2} \\            &= \cfrac{1 - z_1\overline{z_1}}{\left|{1 - z\overline{z_1}}\right|^2} = LHS.        \end{aligned}</script><p>至此证毕.  ◻</p><p>$\textbf{Example:}$<br>对于 中的映射, 证明不变式:</p><script type="math/tex; mode=display">\cfrac{R\left|{dw}\right|}{R^2 - \left|{w - w_0}\right|^2} = \cfrac{r\left|{dz}\right|}{r^2 - \left|{z - z^0}\right|^2}.$$ ◻$\textbf{Solution:}$考虑 $$z' = \cfrac{z - z_0}{r}, w' = \cfrac{w - w_0}{R}.</script><p>则 $z’(z)$, $w’(w)$ 均将原区域映射为单位圆盘. 那么有</p><script type="math/tex; mode=display">\cfrac{\left|{dw’}\right|}{1 - \left|{w'}\right|^2} = \cfrac{\left|{dz'}\right|}{1 - \left|{z'}\right|^2}.</script><p>代入 $w’$, $z’$ 可得</p><script type="math/tex; mode=display">\cfrac{R\left|{dw}\right|}{R^2 - \left|{w - w_0}\right|^2} = \cfrac{r\left|{dz}\right|}{r^2 - \left|{z - z^0}\right|^2}.$$ ◻$\textbf{Example:}$求分式线性映射 $w(z)$ 满足:- 将上半复平面 $Im{z} > 0$ 映射到单位圆盘 $\left|{w}\right| < 1$;- 将点 $z = z_1\thinspace(Im{z_1} > 0)$ 映射到点 $w = 0$. ◻ $\textbf{Solution:}$将上半平面看作半径无穷的圆, $z_1$ 关于圆周的对称点为$\overline{z_1}$.由于分式线性映射保对称点的性质,映射前 $z_1$ 的对称点为 $\overline{z_1}$, 映射后为 $0$ 的对称点$+\infty$. 故 $$w = \alpha\cfrac{z - z_1}{z - \overline{z_1}}.</script><p>由最大模原理: <script type="math/tex">z = x\in\mathbb{R}\Leftrightarrow\left|{w}\right| = 1.</script></p><p>注意到 $Im{z_1} &gt; 0$, 从而有 <script type="math/tex">\begin{aligned}            1 &= \left|{\alpha}\right|\left|{\cfrac{x - z_1}{x - \overline{z_1}}}\right| \\            &= \left|{\alpha}\right|\left|{\cfrac{x - z_1}{\overline{x} - \overline{z_1}}}\right| \\            &= \left|{\alpha}\right|.        \end{aligned}</script></p><p>即 <script type="math/tex">\alpha = e^{i\theta}, \theta\in[0, 2\pi).</script></p><p>那么有</p><script type="math/tex; mode=display">w = e^{i\theta}\cfrac{z - z_1}{z - \overline{z_1}}, \thinspace Im{z_1} > 0, \thinspace\theta\in[0, 2\pi).</script><p>特别地, 取 $\theta = 0, z_1 = i$, 可得 <script type="math/tex">w = \cfrac{z - i}{z + i}.</script> ◻</p><p>$\textbf{Example:}$<br>求分式线性映射 $w(z)$ 满足:</p><ul><li>将过点 $x_0\in\mathbb{R}$, 旋转角为 $\theta_0$<br>的半平面映射到单位圆盘 $\left|{w - w_0}\right| &lt; R$;</li><li>将点 $z = z_1\thinspace(Im{[(z_1 - x_0)e^{-i\theta_0}]} &gt; 0)$<br>映射到点 $w = w_0$. ◻</li></ul><p>$\textbf{Solution:}$<br>考虑</p><script type="math/tex; mode=display">z' = (z - x_0)e^{-i\theta_0}, w' = \cfrac{w - w_0}{R}.</script><p>则 $z’(z)$, $w’(w)$ 均将原区域映射为上半复平面与单位圆盘. 那么有</p><script type="math/tex; mode=display">w' = e^{i\theta}\cfrac{z' - z_1'}{z' - \overline{z_1'}}, \thinspace Im{z_1'} > 0, \thinspace\theta\in[0, 2\pi).</script><p>代入 $w’$, $z’$ 可得</p><script type="math/tex; mode=display">w = w_0 + Re^{i\theta}\cfrac{z - z_1}{z - x_0 - (\overline{z_1} - x_0)e^{2i\theta_0}},</script><p>其中</p><script type="math/tex; mode=display">Im{[(z_1 - x_0)e^{-i\theta_0}]} > 0, \thinspace\theta\in[0, 2\pi).$$ ◻$\textbf{Example:}$映射 $w = \cfrac{az + b}{cz + d}$, 若 $a, b, c, d\in\mathbb{R}$, 则$$Im{z} > 0\leftrightarrow Im{w} > 0 \Longleftrightarrow ad - bc > 0.$$ ◻$\textbf{Solution:}$将 $z = x + iy$ 待入 $$w = \cfrac{az + b}{cz + d},</script><p>得 <script type="math/tex">w = u + iv = \cfrac{(ax + b) + iay}{(cx + d) + icy},</script></p><p>那么 <script type="math/tex">v = \cfrac{(ad - bc)y}{(cx + d)^2 + (cy)^2}.</script></p><p>从而 <script type="math/tex">\begin{aligned}            &\hspace{2em} Im{z} > 0\leftrightarrow Im{w} > 0 \\            &\Longleftrightarrow y > 0\leftrightarrow v > 0 \\            &\Longleftrightarrow yv > 0 \\            &\Longleftrightarrow \cfrac{(ad - bc)y^2}{(cx + d)^2 + (cy)^2} > 0 \\            &\Longleftrightarrow ad - bc > 0.        \end{aligned}</script></p><p>根据最大模原理可知,</p><p>该映射将上半复平面映到上半复平面, 实轴映到实轴.</p><p>又当 $z\in\mathbb{R}$ 时,</p><script type="math/tex; mode=display">\cfrac{dw}{dz} = \cfrac{ad - bc}{(cz + d)^2} > 0.</script><p>即 <script type="math/tex">\arg\left(\frac{dw}{dz}\right) = 0.</script></p><p>故该映射将上半复平面映到上半复平面, 实轴正向映到实轴正向. ◻</p><p>$\textbf{Example:}$<br>求分式线性映射 $w(z)$ 满足:</p><ul><li>将过点 $a, b\in\mathbb{R}$, 旋转角为 $\alpha\in(0, \pi)$<br>的长条映射到单位圆盘 $\left|{w}\right| &lt; 1$. ◻</li></ul><p>$\textbf{Solution:}$<br>分为四步</p><ol><li>$z_1 = e^{-i\alpha}(z - b)$</li><li>$z_2 = \cfrac{\pi}{h}z_1$</li><li>$z_3 = e^{z_2}$</li><li>$w = \cfrac{z_3 - i}{z_3 + i}$</li></ol><p>整理得</p><script type="math/tex; mode=display">w = \cfrac{e^{\frac{e^{-i\alpha}(z - b)\pi}{(b - a)\sin\alpha}} - i}{e^{\frac{e^{-i\alpha}(z - b)\pi}{(b - a)\sin\alpha}} + i}.</script><p>特别地, 当 $\alpha = \cfrac{\pi}{2}$ 时,</p><script type="math/tex; mode=display">w = \cfrac{e^{\frac{b - z}{b - a}\pi i} - i}{e^{\frac{b - z}{b - a}\pi i} + i}.$$ ◻$\textbf{Example:}$求分式线性映射 $w(z)$ 满足:/- 将区域  $0 < r < R, \thinspace 0 < \theta < \alpha \thinspace(\alpha\in[0, 2\pi))$  映射到单位圆盘 $\left|{w}\right| < 1$. ◻ $\textbf{Solution:}$分为四步1. $z_1 = z^{\frac{\pi}{\alpha}}$2. $z_2 = \cfrac{R^{\frac{\pi}{\alpha}} + z_1}{R^{\frac{\pi}{\alpha}} - z_1}$   (上半圆 $\longrightarrow$ 第一象限)3. $z_3 = z_2^2$4. $w = \cfrac{z_3 - i}{z_3 + i}$整理得$$w = \cfrac{\left(\frac{R^{\frac{\pi}{\alpha}} + z^{\frac{\pi}{\alpha}}}{R^{\frac{\pi}{\alpha}} - z^{\frac{\pi}{\alpha}}}\right)^2 - i}{\left(\frac{R^{\frac{\pi}{\alpha}} + z^{\frac{\pi}{\alpha}}}{R^{\frac{\pi}{\alpha}} - z^{\frac{\pi}{\alpha}}}\right)^2 + i}.</script><p>特别地, 当 $\alpha = \cfrac{\pi}{8}$ 时,</p><p><script type="math/tex">w = \cfrac{\left(\frac{R^8 + z^8}{R^8 - z^8}\right)^2 - i}{\left(\frac{R^8 + z^8}{R^8 - z^8}\right)^2 + i}.</script> ◻</p><p>$\textbf{Example:}$<br>求分式线性映射 $w(z)$ 满足:</p><ul><li>将<br>$\left|{z - a}\right| &gt; a, \left|{z - b}\right| &lt; b\thinspace(0 &lt; a &lt; b)$<br>所围区域映到单位圆盘 $\left|{w}\right| &lt; 1$. ◻</li></ul><p>$\textbf{Solution:}$<br>分为五步</p><ol><li>$z_1 = \cfrac{z - 2a}{z}$ ($0 &lt; x &lt; \cfrac{b - a}{a}$ 的竖直长条)</li><li>$z_2 = iz_1$</li><li>$z_3 = \cfrac{\pi}{\frac{b - a}{a}}z_2$</li><li>$z_4 = e^{z_3}$</li><li>$w = \cfrac{z_4 - i}{z_4 + i}$</li></ol><p>整理得</p><p><script type="math/tex">w = \cfrac{e^{\frac{ib(z - 2a)\pi}{(b - a)z}} - i}{e^{\frac{ib(z - 2a)\pi}{(b - a)z}} + i}.</script> ◻</p><p>$\textbf{Example:}$<br>求分式线性映射 $w(z)$ 满足:</p><ul><li><p>将以 $A, B$ 为端点, $\theta_0\in(0, 2\pi)$<br>为弦切角的弓形映到单位圆盘 $\left|{w}\right| &lt; 1$. ◻</p><p>$\textbf{Solution:}$<br>分为三步</p></li></ul><ol><li>$z_1 = \cfrac{z - A}{B - z}$ (弓形 $\longrightarrow$ 第一象限角域)</li><li>$z_2 = z_1^{\frac{\pi}{\theta_0}}$</li><li>$w = \cfrac{z_2 - i}{z_2 + i}$</li></ol><p>整理得</p><p><script type="math/tex">w = \cfrac{\left(\frac{z - A}{B - z}\right)^{\frac{\pi}{\theta_0}} - i}{\left(\frac{z - A}{B - z}\right)^{\frac{\pi}{\theta_0}} + i}.</script> ◻</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h3 id=&quot;1-解析函数&quot;&gt;&lt;a href=&quot;#1-解析函数&quot; class=&quot;headerlink&quot; title=&quot;1. 解析函数&quot;&gt;&lt;/a&gt;1. 解析函数&lt;/h3&gt;&lt;p&gt;$&#92;textbf{Example:}$&lt;br&gt;对于 $x, y&#92;in&#92;mathbb{R}$, 求</summary>
        
      
    
    
    
    <category term="Maths" scheme="http://chengsx21.github.io/categories/Maths/"/>
    
    <category term="Algebra" scheme="http://chengsx21.github.io/categories/Maths/Algebra/"/>
    
    
    <category term="Maths" scheme="http://chengsx21.github.io/tags/Maths/"/>
    
  </entry>
  
  <entry>
    <title>Russian End-of-term Revision</title>
    <link href="http://chengsx21.github.io/2022/12/28/russian-end-of-term-revision/"/>
    <id>http://chengsx21.github.io/2022/12/28/russian-end-of-term-revision/</id>
    <published>2022-12-28T07:00:13.000Z</published>
    <updated>2023-09-22T08:21:53.573Z</updated>
    
    <content type="html"><![CDATA[<h4 id="及物动词"><a href="#及物动词" class="headerlink" title="及物动词"></a>及物动词</h4><ul><li>(第四课) есть; </li><li>(第五课) делать, читать, считать, искать, знать, слушать; </li><li>(第六课) смотреть, писать, учить;</li><li>(第七课) любить, изучать;</li><li>(第九课) рассказывать, видеть, ждать, петь, вспоминать;</li><li>(第十课) звать;</li><li>(常用) покупать.</li></ul><ol><li><p>делать (做):</p><p>делать урок; делать упражнения (练习);</p></li><li><p>читать (读):</p><p>читать книгу (书); читать текст; читать диалог; читать стихи (诗歌); </p></li><li><p>считать (数):</p><p>считать бананы; </p></li><li><p>искать (寻找):</p><p>искать часы (时间); искать плащ; искать счастье (幸福); </p></li><li><p>знать (了解, 认识):</p><p>знать это; знать тебя; знать русский язык; </p></li><li><p>слушать (听):</p><p>слушать музыку; слушать текст; слушать диалог; слушать стихи;</p></li><li><p>смотреть (看):</p><p>смотреть телевизор (电视); смотреть фильм; </p></li><li><p>писать (写):</p><p>писать письмо; писать новые слова; писать диалог; писать стихи;</p></li><li><p>любить (热爱):</p><p>любить весну и зиму; любить русский язык; Я тебя люблю (我爱你);</p></li><li><p>изучать (研究): </p><p>изучать русский язык; изучать математику; изучать стихи; изучать Пушкина;</p></li><li><p>видеть (看见):</p><p>Вчера мы видели тебя в библиотеке.</p></li><li><p>ждать (等待):</p><p>Мы тебя ждали вчера в аудитории.</p></li><li><p>петь (唱歌):</p><p>Мы поём русскую песню «Подмосковные вечера».</p></li><li><p>звать (招呼; 叫做)</p><p>Как тебя зовут? </p></li></ol><h4 id="非及物动词"><a href="#非及物动词" class="headerlink" title="非及物动词"></a>非及物动词</h4><ul><li>(第五课) работать, отдыхать, ужинать, играть, жить; </li><li>(第六课) говорить, хотеть, обедать, учиться;</li><li>(第七课) идти, ехать, разговаривать, мечтать, отвечать, заниматься;</li><li>(第八课) вставать, завтракать;</li><li>(第九课) лежать, быть, гулять, фотографироваться, собраться;</li><li>(第十课) сидеть, родиться;</li><li>(常用) стоять, лететь.</li></ul><ol><li><p>работать (工作):</p><p>работать на заводе; работать в Пекине; работать в Москве; работать на юге;</p></li><li><p>отдыхать (休息):</p><p>отдыхать дома; отдыхать на юге;</p></li><li><p>завтракать, обедать, ужинать (吃早 / 午 / 晚饭):</p><p>завтракать дома; обедать в кафе; ужинать  в институте; ужинать  в буфете (小吃部);</p></li><li><p>жить (居住):</p><p>жить дома; жить в институте; жить в Санкт-Петербурге;</p></li><li><p>играть (玩):</p><p>играть в футбол; играть в шахматы;</p></li><li><p>говорить (说):</p><p>говорить по-русски; говорить по-китайски;</p></li><li><p>хотеть (想):</p><p>хотеть читать стихи; хотеть смотреть телевизор; хотеть слушать музыку.</p></li><li><p>идти (步行): </p><p>Я иду на урок.</p></li><li><p>ехать (乘车):</p><p>Я еду на работу.</p></li><li><p>разговаривать (交谈):</p><p>Они разговаривают об учебе и о работе. Вы разговариваете о Москве?</p></li><li><p>мечтать (渴望):</p><p>мечтать учиться в России;  мечтать работать на юге;</p></li><li><p>отвечать (回答):</p><p>отвечать на вопросы;</p></li><li><p>стоять (站立):</p><p>На столе стоит красивая ваза.</p></li><li><p>лежать (放置):</p><p>На столе лежат книги и словари.</p></li><li><p>быть (曾经在):</p><p>Вчера вечером Антон и Нина были в театре.</p></li><li><p>гулять (散步):</p><p>Виктор и Анна гуляют в саду.</p></li><li><p>фотографироваться (摄像):</p><p>Они фотографируются в парке.</p></li><li><p>собраться (聚集):</p><p>Вчера мои товарищи собрались вместе. </p></li><li><p>сидеть (坐着):</p><p>Мы сидим в своей красивой аудитории. </p></li><li><p>родиться (出生):</p><p>Он родился в Пекине.</p></li></ol><h4 id="第一变位法"><a href="#第一变位法" class="headerlink" title="第一变位法"></a>第一变位法</h4><p><strong>正常变位</strong></p><ul><li>разговаривать, мечтать, отвечать, изучать, заниматься, покупать (购买), гулять.</li></ul><p><strong>特殊变位</strong></p><ul><li>писать: я пишу, ты пишешь, они пишут;</li><li>жить: я живу, ты живёшь, они живут;</li><li>звать: я зову, ты зовёшь, они зовут;</li><li>искать: я ищу, ты ищешь, они ищут;</li><li>идти: я иду, ты идёшь, они идут; </li><li>ехать: я еду, ты едешь, они едут;</li><li>вставать: я встаю, ты встаёшь, они встают.</li><li>танцевать: я танцую, ты танцуешь, они танцуют.  </li></ul><h4 id="第二变位法"><a href="#第二变位法" class="headerlink" title="第二变位法"></a>第二变位法</h4><p><strong>正常变位</strong></p><ul><li>говорить: я говорю, ты говоришь, они говорят;</li><li>стоять: я стою, ты стоишь, они стоят; </li><li>учить: я учу, ты учишь, они учат;</li><li>учиться: я учусь, ты учишься, они учатся;</li><li>смотреть: я смотрю, ты смотришь, они смотрят;</li></ul><p><strong>特殊变位</strong></p><ul><li>любить: я люблю, ты любишь, они любят.</li><li>лететь (飞行): я лечу, ты летишь, они летят.</li><li>сидеть: я сижу, ты сидишь, они сидят.</li></ul><h4 id="语言"><a href="#语言" class="headerlink" title="语言"></a>语言</h4><ul><li>говорить по-русски 俄语</li><li>говорить по-китайски 汉语</li><li>говорить по-английски 英语</li></ul><h4 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h4><ul><li>один час;</li><li>два / три / четыре часа;</li><li>пять / шесть / семь / восемь / девять / десять / одиннадцать / двенадцать часов.</li></ul><h4 id="星期"><a href="#星期" class="headerlink" title="星期"></a>星期</h4><ul><li>понедельник, вторник, среда, четверг, пятница, суббота, воскресенье.</li></ul><h4 id="月份"><a href="#月份" class="headerlink" title="月份"></a>月份</h4><ul><li>январь, февраль, март, апрель;</li><li>май, июнь, июль, август;</li><li>сентябрь, октябрь, ноябрь, декабрь.</li></ul><h4 id="第一至六课词组"><a href="#第一至六课词组" class="headerlink" title="第一至六课词组"></a>第一至六课词组</h4><ul><li>我 / 你 / 您 / 他 / 她叫… меня / тебя / вас / его / её зовут…</li><li>在喷泉旁 у фонтана</li><li>您的儿子 ваш сын</li><li>我的朋友 мой друг; моя подруга</li><li>你们的新房子 ваш новый дом</li><li>我的旧作业本 моя старая тетрадь</li><li>他的新车 его новая машина</li><li>我们的旧桌子 наш старый стол</li><li>你们的旧花园 ваш старый сад</li><li>他们的新护照 их новые паспорта</li><li>在工厂工作 работать на заводе</li><li>在学院里工作 работать в институте</li><li>在剧院里工作 работать в театре</li><li>懂俄语 знать русский язык</li><li>了解你 знать тебя</li><li>听音乐 слушать музыку</li><li>在南方休息  отдыхать на юге</li><li>在疗养院休息 отдыхать в санатории</li><li>在家休息 отдыхать дома</li><li>在家吃早餐 завтракать дома</li><li>在咖啡厅吃午餐 обедать в кафе</li><li>在小吃部吃晚餐 ужинать в буфете</li><li>在教室里做功课 делать урок в аудитории</li><li>在宿舍里做练习 делать упражнение в общежитии</li><li>踢足球 играть в футбол</li><li>下象棋 играть в шахматы</li><li>数香蕉 считать бананы</li><li>写生词 писать новые слова</li><li>住在莫斯科 жить в Москве</li><li>住在上海 жить в Шанхае</li><li>背单词 учить новые слова</li><li>渴望上大学 хотеть учиться в университете</li><li>渴望在俄罗斯留学 хотеть учиться в России</li><li>关于我 обо мне</li><li>3点钟 три часа</li><li>5点钟 пять часов</li><li>看电视 смотреть телевизор</li><li>看书 читать книгу</li><li>寻找教科书 искать учебник</li><li>请问 скажите пожалуйста</li><li>几点钟 который час</li><li>很好 очень хорошо</li></ul><h4 id="第七课词组"><a href="#第七课词组" class="headerlink" title="第七课词组"></a>第七课词组</h4><ol><li>俄语学院 Институт русского языка</li><li>学习研究俄语 изучать русский язык</li><li>在课堂上 на уроке </li><li>回答问题 отвечать на вопросы</li><li>做很多练习 делать упражнения</li><li>懂俄语 знать русский язык</li><li>谈论有关学习和生活的事情 разговаривать об учёбе и о жизни</li><li>学院里的生活 жизнь в институте</li><li>向往着留学俄罗斯 мечтать учиться в России</li><li>去上班 идти на работу </li><li>乘车去莫斯科 ехать в Москву</li><li>喜欢春天 любить весну</li><li>报刊和杂志 газета и журнал</li></ol><h4 id="第九课词组"><a href="#第九课词组" class="headerlink" title="第九课词组"></a>第九课词组</h4><ol><li>写生词 писать новые слова</li><li>看电视 смотреть телевизор</li><li>在教室里上自习 заниматься в аудитории</li><li>在宿舍休息 отдыхать в общежитии</li><li>好朋友  большие друзья (хорошие друзья)</li><li>喜欢数学 любить математику</li><li>做家庭作业 делать домашние задания</li><li>出行日 выходной день</li><li>弹吉他  играть на гитаре</li><li>乘车去听音乐会  ехать на концерт</li><li>看电影  смотреть фильм</li><li>好久没见到你 давно тебя не видеть</li><li>在学院里等你 ждать тебя в институте</li><li>上大学 учиться в университете</li><li>唱俄语歌 петь русские песни</li><li>在莫大学习 учиться в МГУ</li><li>中小学同学 школьные товарищи</li></ol><h4 id="第十课词组"><a href="#第十课词组" class="headerlink" title="第十课词组"></a>第十课词组</h4><ol><li>出生在莫斯科 родиться в Москве</li><li>在中学工作 работать в средней школе</li><li>大而美丽的城市 большой и красивый город</li><li>长江 река Янцзы</li><li>在童年 в детстве</li><li>在北大上学 учиться в Пекинском университете</li><li>俄罗斯语言与文学 русский язык и литература</li><li>每天 каждый день</li><li>除此以外 кроме того</li><li>听俄语诗歌 слушать русские стихи</li><li>好教师 хороший преподаватель</li><li>令人愉悦的和善良的人 весёлый и добрый человек</li><li>熟知故乡的城市 хорошо знать свой родной город</li><li>喜欢听他的故事 любить слушать его рассказы</li><li>著名的地方 знаменитые места</li><li>红场 Красная площадь</li><li>历史博物馆 Исторический музей</li><li>大剧院 Большой театр</li><li>冬宫 Зимний дворец</li><li>晚报 вечерняя газета</li><li>我的父母双亲 мои родители</li></ol><h4 id="重点词组"><a href="#重点词组" class="headerlink" title="重点词组"></a>重点词组</h4><ol><li>吃新鲜的菠萝 есть свежие ананасы</li><li>吃热汤 есть горячий суп</li><li>读书和报刊杂志 читать книгу, газету и журнал</li><li>听音乐 слушать музыку</li><li>在美丽的花园里散步 гулять в красивом саду</li><li>在周六  в субботу</li><li>谈论关于我的情况  разговаривать обо мне</li><li>乘公共汽车  ехать на автобусе</li><li>乘坐地铁  ехать на метро</li><li>谈论关于我的生活和工作  разговаривать о моей жизни и работе</li><li>飞往莫斯科 лететь в Москву</li><li>师范学院  педагогический институт</li><li>医学院  медицинский институт</li><li>历史系  исторический факультет</li><li>一年四季  времена года</li><li>站在喷泉旁 стоять у фонтана</li><li>背单词 учить новые слова</li><li>6点钟 шесть часов</li><li>唱歌跳舞 петь и танцевать</li><li>回忆起学校和老师同学 вспоминать о школе, об учителях и товарищах</li><li>高楼  большие дома</li><li>起床很早 вставать рано</li><li>他有课 у него уроки</li><li>购买蔬菜和苹果 покупать овощи и яблоки</li><li>回答问题 отвечать на вопросы</li><li>去上班 идти на работу</li><li>梦想在俄罗斯学习 мечтать учиться в России</li><li>美丽的花朵 красивые цветы</li><li>写信 писать письмо</li><li>在小吃部吃午饭 обедать в буфете</li></ol><h4 id="形容词"><a href="#形容词" class="headerlink" title="形容词"></a>形容词</h4><p><strong>硬变化</strong></p><ul><li>新的 новый, новая, новое, новые;</li><li>旧的 старый, старая, старое, старые;</li><li>美丽的 красивый, красивая, красивое, красивые;</li><li>美味的 вкусный, вкусная, вкусное, вкусные;</li><li>时尚的 модный, модная, модное, модные;</li><li>红色的 красный, красная, красное, красные;</li><li>学校的 школьный, школьная, школьное, школьные;</li><li>年青的 молодой, молодая, молодое, молодые; </li><li>大的 большой, большая, большое, большие; </li><li>不好的 плохой，плохая, плохое, плохие; </li><li>英国的  английский, английская, английское, английские; </li></ul><p><strong>软变化</strong></p><ul><li>家庭的 домашний, домашняя, домашнее, домашние; </li><li>蓝色的 синий, синяя, синее, синие; </li><li>晚上的 вечерний，вечерняя, вечернее, вечерние; </li><li>冬日的 зимний, зимняя, зимнее, зимние; </li><li>好的 хороший，хорошая, хорошее, хорошие; </li><li>新鲜的 свежий，свежая, свежее, свежие; </li><li>滚烫的 горячий, горячая, горячее, горячие. </li></ul><h4 id="на-固定词组-第四格"><a href="#на-固定词组-第四格" class="headerlink" title="на 固定词组 (第四格)"></a>на 固定词组 (第四格)</h4><p>на завод, на рынок, на мост, на работу, на урок, на лекцию, на выставку, на концерт, на почту, на кухню, на фирму, на улицу, на проспект, на стадион, на остановку автобуса, на обед, на ужин, на завтрак, на собрание, на юг, на вокзал, на футбол, на гору, на занятия, на факультет, на реку, на озеро, на поле, на море.</p><h4 id="об-固定词组-第六格"><a href="#об-固定词组-第六格" class="headerlink" title="об 固定词组 (第六格)"></a>об 固定词组 (第六格)</h4><p>обо мне, об учёбе, об аудитории, об общежитии, об уксусе, об автобусе, об остановке, об ухе, об яйце, об языке, об ужине, об Европе, об Азии, об имени, об Интернете, об отце, об юге, об овощах, об обуви, об обеде, об осени, об озере, об июле, об июне, об улице, об учителе, об учительнице, об январе, об апреле, об августе, об октябре.</p><h4 id="问答题"><a href="#问答题" class="headerlink" title="问答题"></a>问答题</h4><ol><li><p>Кто твой отец? </p><p>Мой отец инженер. Он работает на заводе.</p></li><li><p>Что стоит на столе? </p><p>На столе стоят красивые цветы.</p></li><li><p>Что ты читаешь? </p><p>Я читаю книгу и газету.</p></li><li><p>Что делала Инна вчера вечером? </p><p>Вчера вечером она смотрела телевизор.</p></li><li><p>Какой язык ты знаешь? </p><p>Я знаю китайский и русский языки.</p></li><li><p>Который час сейчас?</p><p>Сейчас два часа.</p></li><li><p>Куда они едут?</p><p>Они едут в Москву.</p></li><li><p>Когда ты встаёшь утром каждый день? </p><p>Каждый день утром я встаю в шесть часов.</p></li><li><p>Где Миша учился раньше? </p><p>Раньше он учился в Санкт-Петербурге.</p></li><li><p>Где Виктор был вчера? </p><p>Вчера он был в институте.</p></li><li><p>Чья это машина? </p><p>Это моя машина.</p></li><li><p>Какой сегодня день? </p><p>Сегодня понедельник.</p></li><li><p>Почему Анна много работает? </p><p>Она хочет учиться в России.</p></li><li><p>Какое время года ты любишь? </p><p>Я люблю весну и зиму.</p></li><li><p>Где учится твой брат? </p><p>Мой брат учится в МГУ.</p></li><li><p>Ребята хорошо знают о тебе? </p><p>Да, они хорошо знают обо мне.</p></li><li><p>О чём вы разговариваете? </p><p>Мы разговариваем об учёбе и о жизни в университете.</p></li><li><p>О ком рассказывал ваш преподаватель сегодня на уроке? </p><p>Сегодня на уроке он рассказывал о великом русском поэте Пушкине.</p></li><li><p>В каком городе ты живёшь? </p><p>Я живу в большом и красивом городе Шанхае.</p></li><li><p>Где вы родились?</p><p>Я родился в Москве.</p></li><li><p>Где вы учились раньше? </p><p>Раньше мы учились в школе.</p></li><li><p>Какой язык они учили в школе? </p><p>В школе они учили английский язык.</p></li><li><p>Как вы говорите по-русски? </p><p>Мы говорим по-русски очень хорошо.</p></li><li><p>Где обычно занимаются студенты? </p><p>Они обычно занимаются в аудиториях и библиотеках.</p></li><li><p>Какой язык изучает Виктор? </p><p>Он изучает китайский язык.</p></li><li><p>Что ты делал вчера вечером? </p><p>Вчера вечером я писал новые слова.</p></li><li><p>Кто такой Антон? </p><p>Антон хороший преподаватель, весёлый и добрый человек.</p></li><li><p>Какой ваш родной город?</p><p>Мой родной город — Пекин.</p></li><li><p>Ты любишь изучать русский язык? </p><p>Да, я люблю изучать русский язык.</p></li><li><p>Когда у вас уроки русского языка? </p><p>У нас уроки русского языка во вторник и в пятницу. </p></li></ol>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h4 id=&quot;及物动词&quot;&gt;&lt;a href=&quot;#及物动词&quot; class=&quot;headerlink&quot; title=&quot;及物动词&quot;&gt;&lt;/a&gt;及物动词&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;(第四课) есть; &lt;/li&gt;
&lt;li&gt;(第五课) делать, читать, считать,</summary>
        
      
    
    
    
    <category term="Russian" scheme="http://chengsx21.github.io/categories/Russian/"/>
    
    
    <category term="Russian" scheme="http://chengsx21.github.io/tags/Russian/"/>
    
  </entry>
  
  <entry>
    <title>计算机系统概论 Lab 3</title>
    <link href="http://chengsx21.github.io/2022/12/25/ji-suan-ji-xi-tong-gai-lun-lab-3/"/>
    <id>http://chengsx21.github.io/2022/12/25/ji-suan-ji-xi-tong-gai-lun-lab-3/</id>
    <published>2022-12-25T09:27:55.000Z</published>
    <updated>2023-09-27T12:36:33.531Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Lab-3-Malloc-Lab-实验报告"><a href="#Lab-3-Malloc-Lab-实验报告" class="headerlink" title="Lab 3 Malloc Lab 实验报告"></a>Lab 3 Malloc Lab 实验报告</h1><h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><ul><li>使用 $C$ 语言实现一个 $Dynamic$ $Storage$ $Allocater$.</li><li>实现并优化 $malloc$, $free$, $realloc$ 等功能.</li><li>熟练 $gdb$ 调试技巧.</li></ul><h2 id="最终性能"><a href="#最终性能" class="headerlink" title="最终性能"></a>最终性能</h2><p>在最终提交的版本中, 我对 $mm.c$ 的相关实现策略如下:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Data Structure -------- Explicit Free List <span class="token punctuation">(</span>Double Linked List<span class="token punctuation">)</span>  / Allocated Block --- Header, Payload and Footer  <span class="token punctuation">\</span> Free Block -------- Header, Pred_ptr, Succ_ptr and FooterFit Strategy ---------- First FitCoalesce Strategy ----- Immediate CoalesceRealloc Strategy ------ First Try to Coalesce, Then Try to Malloc and Free<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最终实现的性能如下:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Results <span class="token keyword">for</span> mm malloc:Score <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">46</span> <span class="token punctuation">(</span>util<span class="token punctuation">)</span> + <span class="token number">40</span> <span class="token punctuation">(</span>thru<span class="token punctuation">))</span> * <span class="token number">11</span>/11 <span class="token punctuation">(</span>testcase<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">86</span>/100<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="Version-0"><a href="#Version-0" class="headerlink" title="Version 0"></a>Version 0</h2><p>$Version$ $0$ 为未作任何修改的原始 $mm.c$ 文件, 直接进行测试的结果.</p><h3 id="Block-Structure"><a href="#Block-Structure" class="headerlink" title="Block Structure"></a>Block Structure</h3><p>在原始 $mm.c$ 文件中, 一个 $block$ 没有 $header$ 或 $footer$ 标记, 也不会被 $coalesce$ 或 $reuse$.</p><h3 id="Helper-Functions"><a href="#Helper-Functions" class="headerlink" title="Helper Functions"></a>Helper Functions</h3><ul><li>没有实现任何 $helper$ $function$ 以辅助进行内存块的分配.</li><li>所有内存块不进行 $coalesce$, 经过 $free$ 后不会被 $malloc$ 或 $realloc$ 复用.</li></ul><h3 id="Malloc-Functions"><a href="#Malloc-Functions" class="headerlink" title="Malloc Functions"></a>Malloc Functions</h3><h4 id="mm-init"><a href="#mm-init" class="headerlink" title="mm_init"></a>mm_init</h4><ul><li>不进行 $init$, 直接返回.</li></ul><h4 id="mm-malloc"><a href="#mm-malloc" class="headerlink" title="mm_malloc"></a>mm_malloc</h4><ul><li>将 $size$ 对齐至 $16$ 字节, 直接调用 $mem_sbrk$ 申请新的堆区域, 并返回一个指向连续内存块的指针.</li></ul><h4 id="mm-free"><a href="#mm-free" class="headerlink" title="mm_free"></a>mm_free</h4><ul><li>不进行 $free$, 直接返回.</li></ul><h4 id="mm-realloc"><a href="#mm-realloc" class="headerlink" title="mm_realloc"></a>mm_realloc</h4><ul><li>直接调用 $mm_malloc$ 分配 $newptr$. </li><li>如果 $newptr$ 为 $NULL$, 此时堆可扩展内存不足, 直接返回 $NULL$.</li><li>否则, 依据大小关系将 $ptr$ 指向的旧内存块内容复制到 $newptr$ 指向的新块.</li></ul><h3 id="Performance"><a href="#Performance" class="headerlink" title="Performance"></a>Performance</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Results <span class="token keyword">for</span> mm malloc:trace            name     valid  util     ops      secs   Kops <span class="token number">1</span>     amptjp-bal.rep       <span class="token function">yes</span>   <span class="token number">23</span>%    <span class="token number">5694</span>  <span class="token number">0.000070</span>  <span class="token number">81459</span> <span class="token number">2</span>       cccp-bal.rep       <span class="token function">yes</span>   <span class="token number">19</span>%    <span class="token number">5848</span>  <span class="token number">0.000072</span>  <span class="token number">81110</span> <span class="token number">3</span>    cp-decl-bal.rep       <span class="token function">yes</span>   <span class="token number">30</span>%    <span class="token number">6648</span>  <span class="token number">0.000084</span>  <span class="token number">78768</span> <span class="token number">4</span>       expr-bal.rep       <span class="token function">yes</span>   <span class="token number">40</span>%    <span class="token number">5380</span>  <span class="token number">0.000066</span>  <span class="token number">82137</span> <span class="token number">5</span> coalescing-bal.rep        no     -       -         -      - <span class="token number">6</span>     random-bal.rep        no     -       -         -      - <span class="token number">7</span>    random2-bal.rep        no     -       -         -      - <span class="token number">8</span>     binary-bal.rep       <span class="token function">yes</span>   <span class="token number">54</span>%   <span class="token number">12000</span>  <span class="token number">0.000144</span>  <span class="token number">83624</span> <span class="token number">9</span>    binary2-bal.rep       <span class="token function">yes</span>   <span class="token number">47</span>%   <span class="token number">24000</span>  <span class="token number">0.000186</span> <span class="token number">128755</span><span class="token number">10</span>    realloc-bal.rep        no     -       -         -      -<span class="token number">11</span>   realloc2-bal.rep        no     -       -         -      -Total                               -       -         -      -Score <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">12</span> <span class="token punctuation">(</span>util<span class="token punctuation">)</span> + <span class="token number">40</span> <span class="token punctuation">(</span>thru<span class="token punctuation">))</span> * <span class="token number">6</span>/11 <span class="token punctuation">(</span>testcase<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">28</span>/100<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>此时实现的分配器尚不能正确实现所有任务.</p><p>$Kops$ 满足要求, 但 $Memory$ $Utilization$ 过低.</p></blockquote><h2 id="Version-1"><a href="#Version-1" class="headerlink" title="Version 1"></a>Version 1</h2><p>参考 $CSAPP3e$ : $9.9.12$ 中的实现, 采用 $Implicit$ $Free$ $List$ 组织空闲块.</p><h3 id="Block-Structure-1"><a href="#Block-Structure-1" class="headerlink" title="Block Structure"></a>Block Structure</h3><p>一个 $block$ 的结构被组织为:</p><p><img src="/pic/46.png" alt=""></p><p>考虑 $Boundary$ $Tags$ 与 $Alignment$ 条件, 此时 $minimum$ $block$ $size$ 为 $4 * WSIZE\,(32\,Bytes)$.</p><p>$Implicit$ $Free$ $List$ 被组织为:</p><p><img src="/pic/47.png" alt=""></p><p>其中 $heap_listp$ 初始默认指向 $Prologue$ $Block$, 而 $Epilogue$ $Block$ 在进行 $coalesce$ 时可以用于消除边界条件.</p><h3 id="Macros"><a href="#Macros" class="headerlink" title="Macros"></a>Macros</h3><p>相关 $Macro$ $Definition$ 完全参考了 $CSAPP3e$ : $9.9.12$ 中的实现.</p><h3 id="Helper-Functions-1"><a href="#Helper-Functions-1" class="headerlink" title="Helper Functions"></a>Helper Functions</h3><h4 id="first-fit"><a href="#first-fit" class="headerlink" title="first_fit"></a>first_fit</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">first_fit</span><span class="token punctuation">(</span>size_t asize<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span>bp <span class="token operator">=</span> heap_lo<span class="token punctuation">;</span> <span class="token function">GET_SIZE</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span> bp <span class="token operator">=</span> <span class="token function">NEXT_BLKP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">GET_ALLOC</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token function">GET_SIZE</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&gt;=</span> asize<span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token keyword">return</span> bp<span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>采用 $first$ $fit$ 查询 $free$ $block$, 其中 $heap_lo$ 为定义的 $Implicit$ $Free$ $List$ 的起始地址.</li><li>若 $no$ $fit$, 则返回 $NULL$.</li></ul><h4 id="place"><a href="#place" class="headerlink" title="place"></a>place</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">place</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>bp<span class="token punctuation">,</span> size_t asize<span class="token punctuation">)</span> <span class="token punctuation">{</span>  size_t size <span class="token operator">=</span> <span class="token function">GET_SIZE</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>size <span class="token operator">-</span> asize<span class="token punctuation">)</span> <span class="token operator">&gt;=</span> <span class="token punctuation">(</span><span class="token number">4</span> <span class="token operator">*</span> WSIZE<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>asize<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">FTRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>asize<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span><span class="token function">NEXT_BLKP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>size <span class="token operator">-</span> asize<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">FTRP</span><span class="token punctuation">(</span><span class="token function">NEXT_BLKP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>size <span class="token operator">-</span> asize<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>   <span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">FTRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>将大小为 $asize$ 的块放置在 $bp$ 指向的 $free$ $block$ 处. </li><li>由于 $minimum$ $block$ $size$ 为 $4 * WSIZE$, 若剩余 $payloader$ 的 $size$ 过大, 则进行 $split$ 操作产生一个新的 $free$ $block$.</li></ul><h4 id="coalesce"><a href="#coalesce" class="headerlink" title="coalesce"></a>coalesce</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">coalesce</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>bp<span class="token punctuation">)</span> <span class="token punctuation">{</span>  size_t prev_alloc <span class="token operator">=</span> <span class="token function">GET_ALLOC</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span><span class="token function">PREV_BLKP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  size_t next_alloc <span class="token operator">=</span> <span class="token function">GET_ALLOC</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span><span class="token function">NEXT_BLKP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  size_t size <span class="token operator">=</span> <span class="token function">GET_SIZE</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>prev_alloc <span class="token operator">&amp;&amp;</span> next_alloc<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">/* Case 1 */</span>    <span class="token keyword">return</span> bp<span class="token punctuation">;</span>  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>prev_alloc <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>next_alloc<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment">/* Case 2 */</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>prev_alloc <span class="token operator">&amp;&amp;</span> next_alloc<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment">/* Case 3 */</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>  <span class="token comment">/* Case 4 */</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> bp<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>采用 $immediate$ $coalesce$ 策略.</li><li>使用 $header$, $footer$ 作为 $boundary$ $tag$ 进行标记, 根据前后块的 $alloc$ $bit$ 位进行 $free$ $block$ 的合并.</li></ul><h4 id="extend-heap"><a href="#extend-heap" class="headerlink" title="extend_heap"></a>extend_heap</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">extend_heap</span><span class="token punctuation">(</span>size_t words<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">char</span> <span class="token operator">*</span>bp<span class="token punctuation">;</span>  size_t size<span class="token punctuation">;</span>  size <span class="token operator">=</span> <span class="token punctuation">(</span>words <span class="token operator">%</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">(</span>words <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> WSIZE <span class="token operator">:</span> words <span class="token operator">*</span> WSIZE<span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span><span class="token punctuation">(</span>bp <span class="token operator">=</span> <span class="token function">mem_sbrk</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>  <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* Free block header */</span>  <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">FTRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* Free block footer */</span>  <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span><span class="token function">NEXT_BLKP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* New epilogue header */</span>  <span class="token keyword">return</span> <span class="token function">coalesce</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>用大小为 $size$ 的双字对齐的 $free$ $block$ 扩展堆.</li><li>$epilogue$ $block$ 的 $size$ 为 $0$, $alloc$ $bit$ 位置为 $1$.</li><li>使用 $mem_sbrk$ 分配一个双字对齐块后, $epilogue$ $block$ 变成了 $new$ $free$ $block$ $header$, 下一 $block$ $header$ 特殊化为 $new$ $epilogue$ $block$.</li></ul><h3 id="Malloc-Functions-1"><a href="#Malloc-Functions-1" class="headerlink" title="Malloc Functions"></a>Malloc Functions</h3><h4 id="mm-init-1"><a href="#mm-init-1" class="headerlink" title="mm_init"></a>mm_init</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">mm_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>heap_lo <span class="token operator">=</span> <span class="token function">mem_sbrk</span><span class="token punctuation">(</span><span class="token number">4</span> <span class="token operator">*</span> WSIZE<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token function">PUT</span><span class="token punctuation">(</span>heap_lo<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">PUT</span><span class="token punctuation">(</span>heap_lo <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">*</span> WSIZE<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>DSIZE<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">PUT</span><span class="token punctuation">(</span>heap_lo <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> WSIZE<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>DSIZE<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">PUT</span><span class="token punctuation">(</span>heap_lo <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token number">3</span> <span class="token operator">*</span> WSIZE<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  heap_lo <span class="token operator">+=</span> <span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> WSIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">extend_heap</span><span class="token punctuation">(</span>CHUNKSIZE <span class="token operator">/</span> WSIZE<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>设置  $prologue$ $block$, $epilogue$ $block$.</li><li>用 $CHUNKSIZE$ 大小的 $free$ $block$ 扩展空堆, 若扩展失败则返回 $NULL$.</li></ul><h4 id="mm-malloc-1"><a href="#mm-malloc-1" class="headerlink" title="mm_malloc"></a>mm_malloc</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">mm_malloc</span><span class="token punctuation">(</span>size_t size<span class="token punctuation">)</span> <span class="token punctuation">{</span>  size_t asize<span class="token punctuation">;</span>  <span class="token keyword">char</span> <span class="token operator">*</span>bp<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>  <span class="token comment">/* Adjust block size to include overhead and alignment reqs. */</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">&lt;=</span> DSIZE<span class="token punctuation">)</span> asize <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> DSIZE<span class="token punctuation">;</span>  <span class="token keyword">else</span> asize <span class="token operator">=</span> DSIZE <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>size <span class="token operator">+</span> <span class="token punctuation">(</span>DSIZE<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>DSIZE <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">/</span> DSIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">/* Search the free list for a fit */</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>bp <span class="token operator">=</span> <span class="token function">first_fit</span><span class="token punctuation">(</span>asize<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">place</span><span class="token punctuation">(</span>bp<span class="token punctuation">,</span> asize<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> bp<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment">/* No fit found. Get more memory and place the block */</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>bp <span class="token operator">=</span> <span class="token function">extend_heap</span><span class="token punctuation">(</span><span class="token function">MAX</span><span class="token punctuation">(</span>asize<span class="token punctuation">,</span> CHUNKSIZE<span class="token punctuation">)</span> <span class="token operator">/</span> WSIZE<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>  <span class="token function">place</span><span class="token punctuation">(</span>bp<span class="token punctuation">,</span> asize<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> bp<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>将 $size$ 对齐至 $16$ 字节, 并扩展加上 $header$, $footer$.</li><li>首先使用 $first$ $fit$ 策略查询 $free$ $list$, 返回一个指向连续内存块的指针.</li><li>若返回为 $NULL$, 则在该处进行 $extend_heap$.</li></ul><h4 id="mm-free-1"><a href="#mm-free-1" class="headerlink" title="mm_free"></a>mm_free</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">mm_free</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">)</span> <span class="token punctuation">{</span>  size_t size <span class="token operator">=</span> <span class="token function">GET_SIZE</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">FTRP</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">coalesce</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>将 $alloc$ $bit$ 位置 $0$, 并进行 $free$ $block$ 的合并.</li></ul><h4 id="mm-realloc-1"><a href="#mm-realloc-1" class="headerlink" title="mm_realloc"></a>mm_realloc</h4><ul><li>如果 $ptr$ 为 $NULL$, 直接调用 $mm_malloc$. </li><li>如果 $size$ 为 $0$, 直接调用 $mm_free$. </li><li>否则, 直接调用 $mm_malloc$ 分配 $newptr$, 以下同 $Version$ $0$. </li></ul><h3 id="Performance-1"><a href="#Performance-1" class="headerlink" title="Performance"></a>Performance</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Results <span class="token keyword">for</span> mm malloc:trace            name     valid  util     ops      secs   Kops <span class="token number">1</span>     amptjp-bal.rep       <span class="token function">yes</span>   <span class="token number">90</span>%    <span class="token number">5694</span>  <span class="token number">0.001877</span>   <span class="token number">3033</span> <span class="token number">2</span>       cccp-bal.rep       <span class="token function">yes</span>   <span class="token number">92</span>%    <span class="token number">5848</span>  <span class="token number">0.001071</span>   <span class="token number">5459</span> <span class="token number">3</span>    cp-decl-bal.rep       <span class="token function">yes</span>   <span class="token number">94</span>%    <span class="token number">6648</span>  <span class="token number">0.004788</span>   <span class="token number">1389</span> <span class="token number">4</span>       expr-bal.rep       <span class="token function">yes</span>   <span class="token number">96</span>%    <span class="token number">5380</span>  <span class="token number">0.005364</span>   <span class="token number">1003</span> <span class="token number">5</span> coalescing-bal.rep       <span class="token function">yes</span>   <span class="token number">50</span>%   <span class="token number">14400</span>  <span class="token number">0.000173</span>  <span class="token number">83189</span> <span class="token number">6</span>     random-bal.rep       <span class="token function">yes</span>   <span class="token number">90</span>%    <span class="token number">4800</span>  <span class="token number">0.006984</span>    <span class="token number">687</span> <span class="token number">7</span>    random2-bal.rep       <span class="token function">yes</span>   <span class="token number">87</span>%    <span class="token number">4800</span>  <span class="token number">0.006384</span>    <span class="token number">752</span> <span class="token number">8</span>     binary-bal.rep       <span class="token function">yes</span>   <span class="token number">54</span>%   <span class="token number">12000</span>  <span class="token number">0.015309</span>    <span class="token number">784</span> <span class="token number">9</span>    binary2-bal.rep       <span class="token function">yes</span>   <span class="token number">47</span>%   <span class="token number">24000</span>  <span class="token number">0.007432</span>   <span class="token number">3229</span><span class="token number">10</span>    realloc-bal.rep       <span class="token function">yes</span>   <span class="token number">32</span>%   <span class="token number">14401</span>  <span class="token number">0.141429</span>    <span class="token number">102</span><span class="token number">11</span>   realloc2-bal.rep       <span class="token function">yes</span>   <span class="token number">34</span>%   <span class="token number">14401</span>  <span class="token number">0.003931</span>   <span class="token number">3663</span>Total                             <span class="token number">70</span>%  <span class="token number">112372</span>  <span class="token number">0.194743</span>    <span class="token number">577</span>Score <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">42</span> <span class="token punctuation">(</span>util<span class="token punctuation">)</span> + <span class="token number">2</span> <span class="token punctuation">(</span>thru<span class="token punctuation">))</span> * <span class="token number">11</span>/11 <span class="token punctuation">(</span>testcase<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">44</span>/100<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>通过了所有测试文件.</p><p>几乎所有测试点的 $Kops$ 均需进行优化, 最后两个测试 $mm_realloc$ 功能点的 $Memory$ $Utilization$ 过低.</p></blockquote><h2 id="Version-2"><a href="#Version-2" class="headerlink" title="Version 2"></a>Version 2</h2><p>采用 $Explicit$ $Free$ $List$ 组织空闲块, 使用的数据结构为 $Double$ $Linked$ $List$.</p><h3 id="Block-Structure-2"><a href="#Block-Structure-2" class="headerlink" title="Block Structure"></a>Block Structure</h3><p>一个 $block$ 的结构被组织为:</p><p><img src="/pic/48.png" alt=""></p><p>考虑 $Boundary$ $Tags$ 与 $Alignment$ 条件, 此时 $minimum$ $block$ $size$ 为 $4 * WSIZE\,(32\,Bytes)$.</p><h3 id="Macros-1"><a href="#Macros-1" class="headerlink" title="Macros"></a>Macros</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/* 前/后 block 中 payloader 的起始地址 */</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">PREV_BLK</span><span class="token expression"><span class="token punctuation">(</span>bp<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token function">GET_SIZE</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span> <span class="token operator">-</span> DSIZE<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">NEXT_BLK</span><span class="token expression"><span class="token punctuation">(</span>bp<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">GET_SIZE</span><span class="token punctuation">(</span><span class="token function">HEADER</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span></span><span class="token comment">/* 前/后 free block 中 payloader 的起始地址 */</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">PRED_BLK</span><span class="token expression"><span class="token punctuation">(</span>bp<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">SUCC_BLK</span><span class="token expression"><span class="token punctuation">(</span>bp<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>bp <span class="token operator">+</span> WSIZE<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>模拟了 $Double$ $Linked$ $List$ 的实现.</li><li>$PRED_BLK$, $SUCC_BLK$ 区别于先前定义的 $PREV_BLK$, $NEXT_BLK$, 用于在 $Explicit$ $Free$ $List$ 中进行前后 $free$ $block$ 的标记.</li></ul><h3 id="Helper-Functions-2"><a href="#Helper-Functions-2" class="headerlink" title="Helper Functions"></a>Helper Functions</h3><h4 id="insert-free-block"><a href="#insert-free-block" class="headerlink" title="insert_free_block"></a>insert_free_block</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">insert_free_block</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>bp<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token function">PRED_BLK</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>  <span class="token function">SUCC_BLK</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span> <span class="token operator">=</span> heap_lo<span class="token punctuation">;</span>  <span class="token function">PRED_BLK</span><span class="token punctuation">(</span>sentinel<span class="token punctuation">)</span> <span class="token operator">=</span> bp<span class="token punctuation">;</span>   heap_lo <span class="token operator">=</span> bp<span class="token punctuation">;</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>将 $bp$ ( 指向一个 $free$ $block$ ) 插入 $Explicit$ $Free$ $List$ 的尾部作为 $sentinel$.</li></ul><h4 id="remove-free-block"><a href="#remove-free-block" class="headerlink" title="remove_free_block"></a>remove_free_block</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">remove_free_block</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>bp<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token function">PRED_BLK</span><span class="token punctuation">(</span><span class="token function">SUCC_BLK</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">PRED_BLK</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">PRED_BLK</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token function">SUCC_BLK</span><span class="token punctuation">(</span><span class="token function">PRED_BLK</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">SUCC_BLK</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">else</span>    heap_lo <span class="token operator">=</span> <span class="token function">SUCC_BLK</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>将 $bp$ ( 指向一个被分配的 $block$ ) 从 $Explicit$ $Free$ $List$ 中删除.</li><li>需要检查 $bp$ 是否为 $sentinel$.</li></ul><h4 id="first-fit-1"><a href="#first-fit-1" class="headerlink" title="first_fit"></a>first_fit</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">first_fit</span><span class="token punctuation">(</span>size_t asize<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>malloced <span class="token operator">!=</span> asize<span class="token punctuation">)</span> counter <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>counter <span class="token operator">&gt;=</span> <span class="token number">48</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    bp <span class="token operator">=</span> <span class="token function">extend_heap</span><span class="token punctuation">(</span><span class="token function">MAX</span><span class="token punctuation">(</span>asize <span class="token operator">/</span> WSIZE<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> bp<span class="token punctuation">;</span>  <span class="token punctuation">}</span> <span class="token keyword">else</span> counter<span class="token operator">++</span><span class="token punctuation">;</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>在 $binary{-}bal.rep$ 与 $binary2{-}bal.rep$ 测试文件中进行了大量相同 $size$ 的 $malloc$ 操作.</p><p>如果重复使用 $first_fit$ 进行检索, 会使 $Kops$ 显著过低.</p></blockquote><ul><li>定义 $malloced$ 为上一次调用 $mm_malloc$ 分配的 $size$ 大小.</li><li>如果重复分配同样 $size$ 的块超过 $48$ 次 ( $48$ 为反复调节获得的最佳参数 ), 则直接调用 $extend_heap$ 将堆扩展相应大小, 不再通过 $first_fit$ 进行检索.</li></ul><h4 id="place-1"><a href="#place-1" class="headerlink" title="place"></a>place</h4><ul><li>若剩余 $payloader$ 需要进行 $split$ 操作, 则先进行 $remove_free_block$, 最后对剩余 $free$ $block$ 进行 $insert_free_block$.</li><li>否则, 直接进行 $remove_free_block$ 并设置 $alloc$ $bit$.</li></ul><h4 id="coalesce-1"><a href="#coalesce-1" class="headerlink" title="coalesce"></a>coalesce</h4><ul><li>仍采用 $immediate$ $coalesce$ 策略.</li><li>在设置 $alloc$ $bit$ 前进行 $remove_free_block$, 最后对合并的 $free$ $block$ 进行 $insert_free_block$.</li></ul><h4 id="extend-heap-1"><a href="#extend-heap-1" class="headerlink" title="extend_heap"></a>extend_heap</h4><ul><li>由于此时 $minimum$ $block$ $size$ 为 $4 <em> WSIZE$, 将 $size$ 双字对齐后, 若其为 $2 </em> WSIZE$, 则置为 $4 * WSIZE$.</li></ul><h3 id="Malloc-Functions-2"><a href="#Malloc-Functions-2" class="headerlink" title="Malloc Functions"></a>Malloc Functions</h3><h4 id="mm-init-2"><a href="#mm-init-2" class="headerlink" title="mm_init"></a>mm_init</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">mm_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">extend_heap</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>$mm_init$ 会调用 $extend_heap$ 预分配一块 $4096\,Bytes$ 大小的空间做为起始 $free$ $block$, $mm_malloc$ 在 $List$ 中没有合适 $free$ $block$ 的情况下总会调用 $extend_heap$ 扩展空间, 其大小取 $4096\,Bytes$ 与待分配大小中较大者.</p><p>在 $coalescing{-}bal.rep$ 中, 起始分配 $4095\,Bytes$ 大小的空间, 经过 $16$ 字节对齐和 $Tag$ 扩展后大于 $4096\,Bytes$, 初始的 $4096\,Bytes$ 空间永远不会被利用.</p><p>只需修改 $mm_init$ 中 $extend_heap$ 初始扩展大小为 $minimun$ $block$ $size$ 即可.</p></blockquote><ul><li>用 $minimun$ $block$ $size$ ( $4$ ) 大小的 $free$ $block$ 扩展空堆, 若扩展失败则返回 $NULL$.</li></ul><h4 id="mm-realloc-2"><a href="#mm-realloc-2" class="headerlink" title="mm_realloc"></a>mm_realloc</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">mm_realloc</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>bp<span class="token punctuation">,</span> size_t size<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">mm_free</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>   size_t oldsize <span class="token operator">=</span> <span class="token function">GET_SIZE</span><span class="token punctuation">(</span><span class="token function">HEADER</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  size_t newsize <span class="token operator">=</span> size <span class="token operator">+</span> <span class="token number">2</span> <span class="token operator">*</span> WSIZE<span class="token punctuation">;</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>newsize <span class="token operator">&lt;=</span> oldsize<span class="token punctuation">)</span> <span class="token keyword">return</span> bp<span class="token punctuation">;</span>   size_t next_alloc <span class="token operator">=</span> <span class="token function">GET_ALLOC</span><span class="token punctuation">(</span><span class="token function">HEADER</span><span class="token punctuation">(</span><span class="token function">NEXT_BLK</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   size_t asize <span class="token operator">=</span> oldsize <span class="token operator">+</span> <span class="token function">GET_SIZE</span><span class="token punctuation">(</span><span class="token function">HEADER</span><span class="token punctuation">(</span><span class="token function">NEXT_BLK</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>next_alloc <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>asize <span class="token operator">&gt;=</span> newsize<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token function">remove_free_block</span><span class="token punctuation">(</span><span class="token function">NEXT_BLK</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">HEADER</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>asize<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">FOOTER</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>asize<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">return</span> bp<span class="token punctuation">;</span>   <span class="token punctuation">}</span>  <span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token operator">*</span>newbp <span class="token operator">=</span> <span class="token function">mm_malloc</span><span class="token punctuation">(</span>newsize<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">place</span><span class="token punctuation">(</span>newbp<span class="token punctuation">,</span> newsize<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">memcpy</span><span class="token punctuation">(</span>newbp<span class="token punctuation">,</span> bp<span class="token punctuation">,</span> newsize<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token function">mm_free</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">return</span> newbp<span class="token punctuation">;</span>   <span class="token punctuation">}</span>   <span class="token punctuation">}</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>原始的 $mm_realloc$ 没有考虑被分配块前后 $free$ $block$ 的情况, 以及 $new$ $block$ $size$ 和 $old$ $block$ $size$ 的比较, 需对此进行优化.</p></blockquote><ul><li>如果 $size$ 为 $0$, 直接调用 $mm_free$. </li><li>如果 $new$ $block$ $size$ 不大于 $old$ $block$ $size$, 直接返回原指针 $bp$ 即可.</li><li>否则, 需要考察后面邻块.<ul><li>若其未分配, 且 $size$ 和不小于 $newsize$, 则直接合并两个 $free$ $block$ 即可.</li><li>否则, 需通过 $mm_malloc$ 分配 $new$ $block$, 并进行内存 $memcpy$.</li></ul></li></ul><h3 id="Performance-2"><a href="#Performance-2" class="headerlink" title="Performance"></a>Performance</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Results <span class="token keyword">for</span> mm malloc:trace            name     valid  util     ops      secs   Kops <span class="token number">1</span>     amptjp-bal.rep       <span class="token function">yes</span>   <span class="token number">88</span>%    <span class="token number">5694</span>  <span class="token number">0.000291</span>  <span class="token number">19594</span> <span class="token number">2</span>       cccp-bal.rep       <span class="token function">yes</span>   <span class="token number">86</span>%    <span class="token number">5848</span>  <span class="token number">0.000208</span>  <span class="token number">28142</span> <span class="token number">3</span>    cp-decl-bal.rep       <span class="token function">yes</span>   <span class="token number">94</span>%    <span class="token number">6648</span>  <span class="token number">0.000386</span>  <span class="token number">17214</span> <span class="token number">4</span>       expr-bal.rep       <span class="token function">yes</span>   <span class="token number">96</span>%    <span class="token number">5380</span>  <span class="token number">0.000287</span>  <span class="token number">18739</span> <span class="token number">5</span> coalescing-bal.rep       <span class="token function">yes</span>   <span class="token number">98</span>%   <span class="token number">14400</span>  <span class="token number">0.000202</span>  <span class="token number">71111</span> <span class="token number">6</span>     random-bal.rep       <span class="token function">yes</span>   <span class="token number">88</span>%    <span class="token number">4800</span>  <span class="token number">0.000645</span>   <span class="token number">7442</span> <span class="token number">7</span>    random2-bal.rep       <span class="token function">yes</span>   <span class="token number">85</span>%    <span class="token number">4800</span>  <span class="token number">0.000747</span>   <span class="token number">6429</span> <span class="token number">8</span>     binary-bal.rep       <span class="token function">yes</span>   <span class="token number">54</span>%   <span class="token number">12000</span>  <span class="token number">0.000393</span>  <span class="token number">30519</span> <span class="token number">9</span>    binary2-bal.rep       <span class="token function">yes</span>   <span class="token number">47</span>%   <span class="token number">24000</span>  <span class="token number">0.000480</span>  <span class="token number">50042</span><span class="token number">10</span>    realloc-bal.rep       <span class="token function">yes</span>   <span class="token number">86</span>%   <span class="token number">14401</span>  <span class="token number">0.000233</span>  <span class="token number">61754</span><span class="token number">11</span>   realloc2-bal.rep       <span class="token function">yes</span>   <span class="token number">17</span>%   <span class="token number">14401</span>  <span class="token number">0.000186</span>  <span class="token number">77383</span>Total                             <span class="token number">76</span>%  <span class="token number">112372</span>  <span class="token number">0.004058</span>  <span class="token number">27692</span>Score <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">46</span> <span class="token punctuation">(</span>util<span class="token punctuation">)</span> + <span class="token number">40</span> <span class="token punctuation">(</span>thru<span class="token punctuation">))</span> * <span class="token number">11</span>/11 <span class="token punctuation">(</span>testcase<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">86</span>/100<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h2><ul><li>$Malloc$ $Lab$ 需要用心 $DEBUG$, 并考验 $gdb$ 的使用掌握. </li><li>我从最简单的实现 —— $Implicit$ $Free$ $List$ 开始, 最后选择了 $Explicit$ $Free$ $List$ 进行实现. </li><li>根据不同 $trace$ 的组成, 我进行了分析与优化, 与 $Segmentation$ $Fault$ 日夜作战. </li><li>这次 $Lab$ 确实是对我的一次难得的体验!</li></ul>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;Lab-3-Malloc-Lab-实验报告&quot;&gt;&lt;a href=&quot;#Lab-3-Malloc-Lab-实验报告&quot; class=&quot;headerlink&quot; title=&quot;Lab 3 Malloc Lab 实验报告&quot;&gt;&lt;/a&gt;Lab 3 Malloc Lab</summary>
        
      
    
    
    
    <category term="CS" scheme="http://chengsx21.github.io/categories/CS/"/>
    
    <category term="CSAPP" scheme="http://chengsx21.github.io/categories/CS/CSAPP/"/>
    
    
    <category term="CSAPP" scheme="http://chengsx21.github.io/tags/CSAPP/"/>
    
  </entry>
  
</feed>
